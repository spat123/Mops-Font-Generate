"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunk_N_E"] = self["webpackChunk_N_E"] || []).push([["components_WaterfallMode_jsx"],{

/***/ "./components/WaterfallMode.jsx":
/*!**************************************!*\
  !*** ./components/WaterfallMode.jsx ***!
  \**************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"./node_modules/react/jsx-dev-runtime.js\");\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"./node_modules/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var react_virtuoso__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! react-virtuoso */ \"./node_modules/react-virtuoso/dist/index.mjs\");\n/* harmony import */ var _contexts_SettingsContext__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../contexts/SettingsContext */ \"./contexts/SettingsContext.js\");\n/* harmony import */ var _contexts_FontContext__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../contexts/FontContext */ \"./contexts/FontContext.js\");\n/* harmony import */ var _EditableText__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./EditableText */ \"./components/EditableText.jsx\");\n\nvar _s = $RefreshSig$();\n\n\n\n\n\n// Стандартные размеры для режима Waterfall - НАЧИНАЕМ СО 180px\nconst waterfallSizes = [\n    180,\n    120,\n    96,\n    72,\n    60,\n    48,\n    36,\n    30,\n    24,\n    18,\n    14,\n    12,\n    10,\n    8\n];\nconst WaterfallMode = ()=>{\n    _s();\n    // Получаем все нужные настройки, включая textColor\n    const { text, backgroundColor, textAlignment, lineHeight, textCase, textColor } = (0,_contexts_SettingsContext__WEBPACK_IMPORTED_MODULE_2__.useSettings)();\n    const { selectedFont, getFontFamily, getVariationSettings } = (0,_contexts_FontContext__WEBPACK_IMPORTED_MODULE_3__.useFontContext)();\n    // const { selectedFont } = useFontManager(); // This seems unused now\n    // console.log(\"WaterfallMode rendering with text:\", text, \"Settings:\", settings); // Удаляем закомментированный лог\n    // Стили для текста, зависящие от выбранного шрифта И НАСТРОЕК\n    const baseTextStyle = {\n        fontFamily: getFontFamily(),\n        fontVariationSettings: getVariationSettings(),\n        textAlign: textAlignment,\n        textTransform: textCase === \"none\" ? \"none\" : textCase,\n        color: textColor\n    };\n    // Оборачиваем renderItem в useCallback\n    const renderItem = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)((index, size)=>{\n        const uniqueKey = \"\".concat((selectedFont === null || selectedFont === void 0 ? void 0 : selectedFont.id) || \"no-font\", \"-\").concat(size, \"-\").concat(index); // Уникальный ключ\n        // Собираем itemStyle точно как в оригинале\n        const itemStyle = {\n            ...baseTextStyle,\n            fontSize: \"\".concat(size, \"px\"),\n            lineHeight: size > 48 ? 1.0 : lineHeight,\n            whiteSpace: \"nowrap\",\n            overflow: \"hidden\",\n            width: \"100%\",\n            textAlign: textAlignment\n        };\n        // Возвращаем ТОЧНУЮ JSX-структуру из оригинального кода\n        return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n            className: \"border-t border-blue-100 pt-4 pb-4\",\n            children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                className: \"flex items-center\",\n                children: [\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                        className: \"text-xs text-gray-500 pl-8 font-medium shrink-0 text-right\",\n                        children: [\n                            size,\n                            \"px\"\n                        ]\n                    }, void 0, true, {\n                        fileName: \"/Users/igormocalov/Desktop/Font/components/WaterfallMode.jsx\",\n                        lineNumber: 55,\n                        columnNumber: 11\n                    }, undefined),\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                        className: \"flex-1 overflow-hidden\",\n                        children: [\n                            \" \",\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_EditableText__WEBPACK_IMPORTED_MODULE_4__[\"default\"], {\n                                style: itemStyle,\n                                isStyles: false,\n                                syncId: \"waterfall-\".concat(size),\n                                viewMode: \"waterfall\",\n                                isWaterfall: true\n                            }, void 0, false, {\n                                fileName: \"/Users/igormocalov/Desktop/Font/components/WaterfallMode.jsx\",\n                                lineNumber: 57,\n                                columnNumber: 13\n                            }, undefined)\n                        ]\n                    }, void 0, true, {\n                        fileName: \"/Users/igormocalov/Desktop/Font/components/WaterfallMode.jsx\",\n                        lineNumber: 56,\n                        columnNumber: 11\n                    }, undefined)\n                ]\n            }, void 0, true, {\n                fileName: \"/Users/igormocalov/Desktop/Font/components/WaterfallMode.jsx\",\n                lineNumber: 54,\n                columnNumber: 9\n            }, undefined)\n        }, uniqueKey, false, {\n            fileName: \"/Users/igormocalov/Desktop/Font/components/WaterfallMode.jsx\",\n            lineNumber: 53,\n            columnNumber: 7\n        }, undefined);\n    }, [\n        // Добавляем все зависимости, используемые внутри renderItem\n        selectedFont,\n        baseTextStyle,\n        lineHeight,\n        textAlignment\n    ]);\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n        className: \"font-preview-area pt-1.5 overflow-y-auto w-full h-full\",\n        style: {\n            backgroundColor: backgroundColor\n        },\n        children: selectedFont ? /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n            className: \"pb-2\",\n            children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(react_virtuoso__WEBPACK_IMPORTED_MODULE_5__.Virtuoso, {\n                style: {\n                    height: \"calc(100vh - 100px)\"\n                },\n                data: waterfallSizes,\n                itemContent: renderItem,\n                overscan: 200\n            }, void 0, false, {\n                fileName: \"/Users/igormocalov/Desktop/Font/components/WaterfallMode.jsx\",\n                lineNumber: 86,\n                columnNumber: 11\n            }, undefined)\n        }, void 0, false, {\n            fileName: \"/Users/igormocalov/Desktop/Font/components/WaterfallMode.jsx\",\n            lineNumber: 85,\n            columnNumber: 9\n        }, undefined) : /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n            className: \"flex items-center justify-center h-full text-gray-500\",\n            children: \"Выберите или загрузите шрифт для просмотра в режиме Waterfall.\"\n        }, void 0, false, {\n            fileName: \"/Users/igormocalov/Desktop/Font/components/WaterfallMode.jsx\",\n            lineNumber: 94,\n            columnNumber: 9\n        }, undefined)\n    }, void 0, false, {\n        fileName: \"/Users/igormocalov/Desktop/Font/components/WaterfallMode.jsx\",\n        lineNumber: 80,\n        columnNumber: 5\n    }, undefined);\n};\n_s(WaterfallMode, \"VexfIRLYQZWJ76QpvD5l6Veng/8=\", false, function() {\n    return [\n        _contexts_SettingsContext__WEBPACK_IMPORTED_MODULE_2__.useSettings,\n        _contexts_FontContext__WEBPACK_IMPORTED_MODULE_3__.useFontContext\n    ];\n});\n_c = WaterfallMode;\n/* harmony default export */ __webpack_exports__[\"default\"] = (WaterfallMode);\nvar _c;\n$RefreshReg$(_c, \"WaterfallMode\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9jb21wb25lbnRzL1dhdGVyZmFsbE1vZGUuanN4IiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7O0FBQTJDO0FBQ0Q7QUFDZ0I7QUFDRDtBQUNmO0FBRTFDLCtEQUErRDtBQUMvRCxNQUFNTSxpQkFBaUI7SUFBQztJQUFLO0lBQUs7SUFBSTtJQUFJO0lBQUk7SUFBSTtJQUFJO0lBQUk7SUFBSTtJQUFJO0lBQUk7SUFBSTtJQUFJO0NBQUU7QUFFaEYsTUFBTUMsZ0JBQWdCOztJQUNwQixtREFBbUQ7SUFDbkQsTUFBTSxFQUNKQyxJQUFJLEVBQ0pDLGVBQWUsRUFDZkMsYUFBYSxFQUNiQyxVQUFVLEVBQ1ZDLFFBQVEsRUFDUkMsU0FBUyxFQUNWLEdBQUdWLHNFQUFXQTtJQUVmLE1BQU0sRUFBRVcsWUFBWSxFQUFFQyxhQUFhLEVBQUVDLG9CQUFvQixFQUFFLEdBQUdaLHFFQUFjQTtJQUM1RSxzRUFBc0U7SUFFdEUsb0hBQW9IO0lBRXBILDhEQUE4RDtJQUM5RCxNQUFNYSxnQkFBZ0I7UUFDcEJDLFlBQVlIO1FBQ1pJLHVCQUF1Qkg7UUFDdkJJLFdBQVdWO1FBQ1hXLGVBQWVULGFBQWEsU0FBUyxTQUFTQTtRQUM5Q1UsT0FBT1Q7SUFFVDtJQUVBLHVDQUF1QztJQUN2QyxNQUFNVSxhQUFhdEIsa0RBQVdBLENBQUMsQ0FBQ3VCLE9BQU9DO1FBQ3JDLE1BQU1DLFlBQVksR0FBb0NELE9BQWpDWCxDQUFBQSx5QkFBQUEsbUNBQUFBLGFBQWNhLEVBQUUsS0FBSSxXQUFVLEtBQVdILE9BQVJDLE1BQUssS0FBUyxPQUFORCxRQUFTLGtCQUFrQjtRQUV6RiwyQ0FBMkM7UUFDM0MsTUFBTUksWUFBWTtZQUNoQixHQUFHWCxhQUFhO1lBQ2hCWSxVQUFVLEdBQVEsT0FBTEosTUFBSztZQUNsQmQsWUFBWWMsT0FBTyxLQUFLLE1BQU1kO1lBQzlCbUIsWUFBWTtZQUNaQyxVQUFVO1lBQ1ZDLE9BQU87WUFDUFosV0FBV1Y7UUFDYjtRQUVBLHdEQUF3RDtRQUN4RCxxQkFDRSw4REFBQ3VCO1lBQW9CQyxXQUFVO3NCQUM3Qiw0RUFBQ0Q7Z0JBQUlDLFdBQVU7O2tDQUNiLDhEQUFDRDt3QkFBSUMsV0FBVTs7NEJBQThEVDs0QkFBSzs7Ozs7OztrQ0FDbEYsOERBQUNRO3dCQUFJQyxXQUFVOzs0QkFBeUI7MENBQ3RDLDhEQUFDN0IscURBQVlBO2dDQUNYOEIsT0FBT1A7Z0NBQ1BRLFVBQVU7Z0NBQ1ZDLFFBQVEsYUFBa0IsT0FBTFo7Z0NBQ3JCYSxVQUFTO2dDQUNUQyxhQUFhOzs7Ozs7Ozs7Ozs7Ozs7Ozs7V0FUWGI7Ozs7O0lBZWQsR0FBRztRQUNELDREQUE0RDtRQUM1RFo7UUFDQUc7UUFDQU47UUFDQUQ7S0FJRDtJQUVELHFCQUNFLDhEQUFDdUI7UUFDQ0MsV0FBVTtRQUNWQyxPQUFPO1lBQUUxQixpQkFBaUJBO1FBQWdCO2tCQUV6Q0ssNkJBQ0MsOERBQUNtQjtZQUFJQyxXQUFVO3NCQUNiLDRFQUFDaEMsb0RBQVFBO2dCQUNQaUMsT0FBTztvQkFBRUssUUFBUTtnQkFBc0I7Z0JBQ3ZDQyxNQUFNbkM7Z0JBQ05vQyxhQUFhbkI7Z0JBQ2JvQixVQUFVOzs7Ozs7Ozs7O3NDQUlkLDhEQUFDVjtZQUFJQyxXQUFVO3NCQUF3RDs7Ozs7Ozs7Ozs7QUFNL0U7R0ExRk0zQjs7UUFTQUosa0VBQVdBO1FBRStDQyxpRUFBY0E7OztLQVh4RUc7QUE0Rk4sK0RBQWVBLGFBQWFBLEVBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vY29tcG9uZW50cy9XYXRlcmZhbGxNb2RlLmpzeD83NWI5Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBSZWFjdCwgeyB1c2VDYWxsYmFjayB9IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7IFZpcnR1b3NvIH0gZnJvbSAncmVhY3QtdmlydHVvc28nO1xuaW1wb3J0IHsgdXNlU2V0dGluZ3MgfSBmcm9tICcuLi9jb250ZXh0cy9TZXR0aW5nc0NvbnRleHQnO1xuaW1wb3J0IHsgdXNlRm9udENvbnRleHQgfSBmcm9tICcuLi9jb250ZXh0cy9Gb250Q29udGV4dCc7XG5pbXBvcnQgRWRpdGFibGVUZXh0IGZyb20gJy4vRWRpdGFibGVUZXh0JztcblxuLy8g0KHRgtCw0L3QtNCw0YDRgtC90YvQtSDRgNCw0LfQvNC10YDRiyDQtNC70Y8g0YDQtdC20LjQvNCwIFdhdGVyZmFsbCAtINCd0JDQp9CY0J3QkNCV0Jwg0KHQniAxODBweFxuY29uc3Qgd2F0ZXJmYWxsU2l6ZXMgPSBbMTgwLCAxMjAsIDk2LCA3MiwgNjAsIDQ4LCAzNiwgMzAsIDI0LCAxOCwgMTQsIDEyLCAxMCwgOF07XG5cbmNvbnN0IFdhdGVyZmFsbE1vZGUgPSAoKSA9PiB7XG4gIC8vINCf0L7Qu9GD0YfQsNC10Lwg0LLRgdC1INC90YPQttC90YvQtSDQvdCw0YHRgtGA0L7QudC60LgsINCy0LrQu9GO0YfQsNGPIHRleHRDb2xvclxuICBjb25zdCB7IFxuICAgIHRleHQsIFxuICAgIGJhY2tncm91bmRDb2xvciwgXG4gICAgdGV4dEFsaWdubWVudCwgXG4gICAgbGluZUhlaWdodCwgXG4gICAgdGV4dENhc2UsIFxuICAgIHRleHRDb2xvciBcbiAgfSA9IHVzZVNldHRpbmdzKCk7XG4gIFxuICBjb25zdCB7IHNlbGVjdGVkRm9udCwgZ2V0Rm9udEZhbWlseSwgZ2V0VmFyaWF0aW9uU2V0dGluZ3MgfSA9IHVzZUZvbnRDb250ZXh0KCk7XG4gIC8vIGNvbnN0IHsgc2VsZWN0ZWRGb250IH0gPSB1c2VGb250TWFuYWdlcigpOyAvLyBUaGlzIHNlZW1zIHVudXNlZCBub3dcblxuICAvLyBjb25zb2xlLmxvZyhcIldhdGVyZmFsbE1vZGUgcmVuZGVyaW5nIHdpdGggdGV4dDpcIiwgdGV4dCwgXCJTZXR0aW5nczpcIiwgc2V0dGluZ3MpOyAvLyDQo9C00LDQu9GP0LXQvCDQt9Cw0LrQvtC80LzQtdC90YLQuNGA0L7QstCw0L3QvdGL0Lkg0LvQvtCzXG5cbiAgLy8g0KHRgtC40LvQuCDQtNC70Y8g0YLQtdC60YHRgtCwLCDQt9Cw0LLQuNGB0Y/RidC40LUg0L7RgiDQstGL0LHRgNCw0L3QvdC+0LPQviDRiNGA0LjRhNGC0LAg0Jgg0J3QkNCh0KLQoNCe0JXQmlxuICBjb25zdCBiYXNlVGV4dFN0eWxlID0ge1xuICAgIGZvbnRGYW1pbHk6IGdldEZvbnRGYW1pbHkoKSxcbiAgICBmb250VmFyaWF0aW9uU2V0dGluZ3M6IGdldFZhcmlhdGlvblNldHRpbmdzKCksXG4gICAgdGV4dEFsaWduOiB0ZXh0QWxpZ25tZW50LFxuICAgIHRleHRUcmFuc2Zvcm06IHRleHRDYXNlID09PSAnbm9uZScgPyAnbm9uZScgOiB0ZXh0Q2FzZSwgXG4gICAgY29sb3I6IHRleHRDb2xvciwgLy8g0JTQvtCx0LDQstC70Y/QtdC8INGG0LLQtdGCINGC0LXQutGB0YLQsFxuICAgIC8vIGxpbmVIZWlnaHQg0L/RgNC40LzQtdC90Y/QtdGC0YHRjyDQsiBpdGVtU3R5bGUg0L3QuNC20LUsINGH0YLQvtCx0Ysg0L7QvSDQt9Cw0LLQuNGB0LXQuyDQvtGCINGA0LDQt9C80LXRgNCwXG4gIH07XG5cbiAgLy8g0J7QsdC+0YDQsNGH0LjQstCw0LXQvCByZW5kZXJJdGVtINCyIHVzZUNhbGxiYWNrXG4gIGNvbnN0IHJlbmRlckl0ZW0gPSB1c2VDYWxsYmFjaygoaW5kZXgsIHNpemUpID0+IHtcbiAgICBjb25zdCB1bmlxdWVLZXkgPSBgJHtzZWxlY3RlZEZvbnQ/LmlkIHx8ICduby1mb250J30tJHtzaXplfS0ke2luZGV4fWA7IC8vINCj0L3QuNC60LDQu9GM0L3Ri9C5INC60LvRjtGHXG5cbiAgICAvLyDQodC+0LHQuNGA0LDQtdC8IGl0ZW1TdHlsZSDRgtC+0YfQvdC+INC60LDQuiDQsiDQvtGA0LjQs9C40L3QsNC70LVcbiAgICBjb25zdCBpdGVtU3R5bGUgPSB7XG4gICAgICAuLi5iYXNlVGV4dFN0eWxlLCBcbiAgICAgIGZvbnRTaXplOiBgJHtzaXplfXB4YCwgXG4gICAgICBsaW5lSGVpZ2h0OiBzaXplID4gNDggPyAxLjAgOiBsaW5lSGVpZ2h0LCAvLyDQntGA0LjQs9C40L3QsNC70YzQvdCw0Y8g0LvQvtCz0LjQutCwIGxpbmVIZWlnaHRcbiAgICAgIHdoaXRlU3BhY2U6ICdub3dyYXAnLCBcbiAgICAgIG92ZXJmbG93OiAnaGlkZGVuJywgXG4gICAgICB3aWR0aDogJzEwMCUnLCBcbiAgICAgIHRleHRBbGlnbjogdGV4dEFsaWdubWVudCwgLy8g0JjRgdC/0L7Qu9GM0LfRg9C10LwgdGV4dEFsaWdubWVudCDQuNC3IGNvbnRleHRcbiAgICB9O1xuXG4gICAgLy8g0JLQvtC30LLRgNCw0YnQsNC10Lwg0KLQntCn0J3Qo9CuIEpTWC3RgdGC0YDRg9C60YLRg9GA0YMg0LjQtyDQvtGA0LjQs9C40L3QsNC70YzQvdC+0LPQviDQutC+0LTQsFxuICAgIHJldHVybiAoXG4gICAgICA8ZGl2IGtleT17dW5pcXVlS2V5fSBjbGFzc05hbWU9XCJib3JkZXItdCBib3JkZXItYmx1ZS0xMDAgcHQtNCBwYi00XCI+XG4gICAgICAgIDxkaXYgY2xhc3NOYW1lPVwiZmxleCBpdGVtcy1jZW50ZXJcIj5cbiAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cInRleHQteHMgdGV4dC1ncmF5LTUwMCBwbC04IGZvbnQtbWVkaXVtIHNocmluay0wIHRleHQtcmlnaHRcIj57c2l6ZX1weDwvZGl2PlxuICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwiZmxleC0xIG92ZXJmbG93LWhpZGRlblwiPiB7Lyog0J7QsdC10YDRgtC60LAg0LTQu9GPIEVkaXRhYmxlVGV4dCAqL30gXG4gICAgICAgICAgICA8RWRpdGFibGVUZXh0XG4gICAgICAgICAgICAgIHN0eWxlPXtpdGVtU3R5bGV9XG4gICAgICAgICAgICAgIGlzU3R5bGVzPXtmYWxzZX0gXG4gICAgICAgICAgICAgIHN5bmNJZD17YHdhdGVyZmFsbC0ke3NpemV9YH0gXG4gICAgICAgICAgICAgIHZpZXdNb2RlPVwid2F0ZXJmYWxsXCJcbiAgICAgICAgICAgICAgaXNXYXRlcmZhbGw9e3RydWV9XG4gICAgICAgICAgICAvPlxuICAgICAgICAgIDwvZGl2PlxuICAgICAgICA8L2Rpdj5cbiAgICAgIDwvZGl2PlxuICAgICk7XG4gIH0sIFtcbiAgICAvLyDQlNC+0LHQsNCy0LvRj9C10Lwg0LLRgdC1INC30LDQstC40YHQuNC80L7RgdGC0LgsINC40YHQv9C+0LvRjNC30YPQtdC80YvQtSDQstC90YPRgtGA0LggcmVuZGVySXRlbVxuICAgIHNlbGVjdGVkRm9udCwgXG4gICAgYmFzZVRleHRTdHlsZSwgLy8gYmFzZVRleHRTdHlsZSDQt9Cw0LLQuNGB0LjRgiDQvtGCIGdldEZvbnRGYW1pbHksIGdldFZhcmlhdGlvblNldHRpbmdzLCB0ZXh0Q2FzZSwgdGV4dENvbG9yXG4gICAgbGluZUhlaWdodCwgXG4gICAgdGV4dEFsaWdubWVudCwgXG4gICAgLy8gdGV4dCAo0LjQtyB1c2VTZXR0aW5ncykg0LjRgdC/0L7Qu9GM0LfRg9C10YLRgdGPINCyIEVkaXRhYmxlVGV4dCwg0L3QviDQv9C10YDQtdC00LDQtdGC0YHRjyDRh9C10YDQtdC3IGluaXRpYWxUZXh0LCBcbiAgICAvLyDQv9C+0Y3RgtC+0LzRgyDRj9Cy0L3QviByZW5kZXJJdGVtINC+0YIg0L3QtdCz0L4g0L3QtSDQt9Cw0LLQuNGB0LjRgiDQvdCw0L/RgNGP0LzRg9GOINC00LvRjyDRgdGC0YDRg9C60YLRg9GA0Ysv0YHRgtC40LvQtdC5XG4gICAgLy8gZ2V0Rm9udEZhbWlseSwgZ2V0VmFyaWF0aW9uU2V0dGluZ3Mg0LLQutC70Y7Rh9C10L3RiyDRh9C10YDQtdC3IGJhc2VUZXh0U3R5bGVcbiAgXSk7XG5cbiAgcmV0dXJuIChcbiAgICA8ZGl2XG4gICAgICBjbGFzc05hbWU9XCJmb250LXByZXZpZXctYXJlYSBwdC0xLjUgb3ZlcmZsb3cteS1hdXRvIHctZnVsbCBoLWZ1bGxcIlxuICAgICAgc3R5bGU9e3sgYmFja2dyb3VuZENvbG9yOiBiYWNrZ3JvdW5kQ29sb3IgfX0gLy8g0J/RgNC40LzQtdC90Y/QtdC8INGE0L7QvSDQt9C00LXRgdGMXG4gICAgPlxuICAgICAge3NlbGVjdGVkRm9udCA/IChcbiAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJwYi0yXCI+XG4gICAgICAgICAgPFZpcnR1b3NvXG4gICAgICAgICAgICBzdHlsZT17eyBoZWlnaHQ6ICdjYWxjKDEwMHZoIC0gMTAwcHgpJyB9fSAvLyDQn9C+0LTQsdC40YDQsNC10Lwg0LLRi9GB0L7RgtGDLCDRh9GC0L7QsdGLINC/0L7QvNC10YHRgtC40LvRgdGPIHBiLTgg0Lgg0L3QtSDQsdGL0LvQviDQtNCy0L7QudC90L7Qs9C+INGB0LrRgNC+0LvQu9CwXG4gICAgICAgICAgICBkYXRhPXt3YXRlcmZhbGxTaXplc30gLy8g0J/QtdGA0LXQtNCw0LXQvCDQvtGC0YHQvtGA0YLQuNGA0L7QstCw0L3QvdGL0LUg0YDQsNC30LzQtdGA0YtcbiAgICAgICAgICAgIGl0ZW1Db250ZW50PXtyZW5kZXJJdGVtfSAvLyDQmNGB0L/QvtC70YzQt9GD0LXQvCDQstC+0YHRgdGC0LDQvdC+0LLQu9C10L3QvdGD0Y4g0YTRg9C90LrRhtC40Y4g0YDQtdC90LTQtdGA0LjQvdCz0LBcbiAgICAgICAgICAgIG92ZXJzY2FuPXsyMDB9IC8vINCU0L7QsdCw0LLQu9GP0LXQvCBvdmVyc2NhblxuICAgICAgICAgIC8+XG4gICAgICAgIDwvZGl2PlxuICAgICAgKSA6IChcbiAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJmbGV4IGl0ZW1zLWNlbnRlciBqdXN0aWZ5LWNlbnRlciBoLWZ1bGwgdGV4dC1ncmF5LTUwMFwiPlxuICAgICAgICAgINCS0YvQsdC10YDQuNGC0LUg0LjQu9C4INC30LDQs9GA0YPQt9C40YLQtSDRiNGA0LjRhNGCINC00LvRjyDQv9GA0L7RgdC80L7RgtGA0LAg0LIg0YDQtdC20LjQvNC1IFdhdGVyZmFsbC5cbiAgICAgICAgPC9kaXY+XG4gICAgICApfVxuICAgIDwvZGl2PlxuICApO1xufTtcblxuZXhwb3J0IGRlZmF1bHQgV2F0ZXJmYWxsTW9kZTsiXSwibmFtZXMiOlsiUmVhY3QiLCJ1c2VDYWxsYmFjayIsIlZpcnR1b3NvIiwidXNlU2V0dGluZ3MiLCJ1c2VGb250Q29udGV4dCIsIkVkaXRhYmxlVGV4dCIsIndhdGVyZmFsbFNpemVzIiwiV2F0ZXJmYWxsTW9kZSIsInRleHQiLCJiYWNrZ3JvdW5kQ29sb3IiLCJ0ZXh0QWxpZ25tZW50IiwibGluZUhlaWdodCIsInRleHRDYXNlIiwidGV4dENvbG9yIiwic2VsZWN0ZWRGb250IiwiZ2V0Rm9udEZhbWlseSIsImdldFZhcmlhdGlvblNldHRpbmdzIiwiYmFzZVRleHRTdHlsZSIsImZvbnRGYW1pbHkiLCJmb250VmFyaWF0aW9uU2V0dGluZ3MiLCJ0ZXh0QWxpZ24iLCJ0ZXh0VHJhbnNmb3JtIiwiY29sb3IiLCJyZW5kZXJJdGVtIiwiaW5kZXgiLCJzaXplIiwidW5pcXVlS2V5IiwiaWQiLCJpdGVtU3R5bGUiLCJmb250U2l6ZSIsIndoaXRlU3BhY2UiLCJvdmVyZmxvdyIsIndpZHRoIiwiZGl2IiwiY2xhc3NOYW1lIiwic3R5bGUiLCJpc1N0eWxlcyIsInN5bmNJZCIsInZpZXdNb2RlIiwiaXNXYXRlcmZhbGwiLCJoZWlnaHQiLCJkYXRhIiwiaXRlbUNvbnRlbnQiLCJvdmVyc2NhbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./components/WaterfallMode.jsx\n"));

/***/ }),

/***/ "./node_modules/react-virtuoso/dist/index.mjs":
/*!****************************************************!*\
  !*** ./node_modules/react-virtuoso/dist/index.mjs ***!
  \****************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   GroupedVirtuoso: function() { return /* binding */ jr; },\n/* harmony export */   LogLevel: function() { return /* binding */ ht; },\n/* harmony export */   TableVirtuoso: function() { return /* binding */ qr; },\n/* harmony export */   Virtuoso: function() { return /* binding */ Kr; },\n/* harmony export */   VirtuosoGrid: function() { return /* binding */ Yr; },\n/* harmony export */   VirtuosoGridMockContext: function() { return /* binding */ Yn; },\n/* harmony export */   VirtuosoMockContext: function() { return /* binding */ Re; }\n/* harmony export */ });\n/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-runtime */ \"./node_modules/react/jsx-runtime.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"./node_modules/react/index.js\");\n/* harmony import */ var react_dom__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! react-dom */ \"./node_modules/react-dom/index.js\");\n\n\n\nconst we = 0, zt = 1, qt = 2, En = 4;\nfunction ln(t) {\n  return () => t;\n}\nfunction co(t) {\n  t();\n}\nfunction ne(t, e) {\n  return (n) => t(e(n));\n}\nfunction cn(t, e) {\n  return () => t(e);\n}\nfunction kn(t, e) {\n  return (n) => t(e, n);\n}\nfunction Me(t) {\n  return t !== void 0;\n}\nfunction uo(...t) {\n  return () => {\n    t.map(co);\n  };\n}\nfunction Yt() {\n}\nfunction ye(t, e) {\n  return e(t), t;\n}\nfunction ao(t, e) {\n  return e(t);\n}\nfunction X(...t) {\n  return t;\n}\nfunction K(t, e) {\n  return t(zt, e);\n}\nfunction W(t, e) {\n  t(we, e);\n}\nfunction We(t) {\n  t(qt);\n}\nfunction lt(t) {\n  return t(En);\n}\nfunction F(t, e) {\n  return K(t, kn(e, we));\n}\nfunction Rt(t, e) {\n  const n = t(zt, (o) => {\n    n(), e(o);\n  });\n  return n;\n}\nfunction un(t) {\n  let e, n;\n  return (o) => (r) => {\n    e = r, n && clearTimeout(n), n = setTimeout(() => {\n      o(e);\n    }, t);\n  };\n}\nfunction Bn(t, e) {\n  return t === e;\n}\nfunction Y(t = Bn) {\n  let e;\n  return (n) => (o) => {\n    t(e, o) || (e = o, n(o));\n  };\n}\nfunction P(t) {\n  return (e) => (n) => {\n    t(n) && e(n);\n  };\n}\nfunction E(t) {\n  return (e) => ne(e, t);\n}\nfunction vt(t) {\n  return (e) => () => {\n    e(t);\n  };\n}\nfunction x(t, ...e) {\n  const n = fo(...e);\n  return (o, r) => {\n    switch (o) {\n      case qt:\n        We(t);\n        return;\n      case zt:\n        return K(t, n(r));\n    }\n  };\n}\nfunction bt(t, e) {\n  return (n) => (o) => {\n    n(e = t(e, o));\n  };\n}\nfunction jt(t) {\n  return (e) => (n) => {\n    t > 0 ? t-- : e(n);\n  };\n}\nfunction Lt(t) {\n  let e = null, n;\n  return (o) => (r) => {\n    e = r, !n && (n = setTimeout(() => {\n      n = void 0, o(e);\n    }, t));\n  };\n}\nfunction G(...t) {\n  const e = new Array(t.length);\n  let n = 0, o = null;\n  const r = Math.pow(2, t.length) - 1;\n  return t.forEach((s, i) => {\n    const l = Math.pow(2, i);\n    K(s, (c) => {\n      const u = n;\n      n = n | l, e[i] = c, u !== r && n === r && o && (o(), o = null);\n    });\n  }), (s) => (i) => {\n    const l = () => {\n      s([i].concat(e));\n    };\n    n === r ? l() : o = l;\n  };\n}\nfunction fo(...t) {\n  return (e) => t.reduceRight(ao, e);\n}\nfunction mo(t) {\n  let e, n;\n  const o = () => e == null ? void 0 : e();\n  return function(r, s) {\n    switch (r) {\n      case zt:\n        return s ? n === s ? void 0 : (o(), n = s, e = K(t, s), e) : (o(), Yt);\n      case qt:\n        o(), n = null;\n        return;\n    }\n  };\n}\nfunction y(t) {\n  let e = t;\n  const n = $();\n  return (o, r) => {\n    switch (o) {\n      case we:\n        e = r;\n        break;\n      case zt: {\n        r(e);\n        break;\n      }\n      case En:\n        return e;\n    }\n    return n(o, r);\n  };\n}\nfunction ct(t, e) {\n  return ye(y(e), (n) => F(t, n));\n}\nfunction $() {\n  const t = [];\n  return (e, n) => {\n    switch (e) {\n      case we:\n        t.slice().forEach((o) => {\n          o(n);\n        });\n        return;\n      case qt:\n        t.splice(0, t.length);\n        return;\n      case zt:\n        return t.push(n), () => {\n          const o = t.indexOf(n);\n          o > -1 && t.splice(o, 1);\n        };\n    }\n  };\n}\nfunction pt(t) {\n  return ye($(), (e) => F(t, e));\n}\nfunction U(t, e = [], { singleton: n } = { singleton: !0 }) {\n  return {\n    constructor: t,\n    dependencies: e,\n    id: po(),\n    singleton: n\n  };\n}\nconst po = () => Symbol();\nfunction ho(t) {\n  const e = /* @__PURE__ */ new Map(), n = ({ constructor: o, dependencies: r, id: s, singleton: i }) => {\n    if (i && e.has(s))\n      return e.get(s);\n    const l = o(r.map((c) => n(c)));\n    return i && e.set(s, l), l;\n  };\n  return n(t);\n}\nfunction rt(...t) {\n  const e = $(), n = new Array(t.length);\n  let o = 0;\n  const r = Math.pow(2, t.length) - 1;\n  return t.forEach((s, i) => {\n    const l = Math.pow(2, i);\n    K(s, (c) => {\n      n[i] = c, o = o | l, o === r && W(e, n);\n    });\n  }), function(s, i) {\n    switch (s) {\n      case qt: {\n        We(e);\n        return;\n      }\n      case zt:\n        return o === r && i(n), K(e, i);\n    }\n  };\n}\nfunction A(t, e = Bn) {\n  return x(t, Y(e));\n}\nfunction an(...t) {\n  return function(e, n) {\n    switch (e) {\n      case qt:\n        return;\n      case zt:\n        return uo(...t.map((o) => K(o, n)));\n    }\n  };\n}\nvar ht = /* @__PURE__ */ ((t) => (t[t.DEBUG = 0] = \"DEBUG\", t[t.INFO = 1] = \"INFO\", t[t.WARN = 2] = \"WARN\", t[t.ERROR = 3] = \"ERROR\", t))(ht || {});\nconst go = {\n  0: \"debug\",\n  3: \"error\",\n  1: \"log\",\n  2: \"warn\"\n}, Io = () => typeof globalThis > \"u\" ? window : globalThis, Vt = U(\n  () => {\n    const t = y(\n      3\n      /* ERROR */\n    );\n    return {\n      log: y((n, o, r = 1) => {\n        var i;\n        const s = (i = Io().VIRTUOSO_LOG_LEVEL) != null ? i : lt(t);\n        r >= s && console[go[r]](\n          \"%creact-virtuoso: %c%s %o\",\n          \"color: #0253b3; font-weight: bold\",\n          \"color: initial\",\n          n,\n          o\n        );\n      }),\n      logLevel: t\n    };\n  },\n  [],\n  { singleton: !0 }\n);\nfunction Ht(t, e, n) {\n  return _e(t, e, n).callbackRef;\n}\nfunction _e(t, e, n) {\n  const o = react__WEBPACK_IMPORTED_MODULE_1__.useRef(null);\n  let r = (s) => {\n  };\n  if (typeof ResizeObserver < \"u\") {\n    const s = react__WEBPACK_IMPORTED_MODULE_1__.useMemo(() => new ResizeObserver((i) => {\n      const l = () => {\n        const c = i[0].target;\n        c.offsetParent !== null && t(c);\n      };\n      n ? l() : requestAnimationFrame(l);\n    }), [t]);\n    r = (i) => {\n      i && e ? (s.observe(i), o.current = i) : (o.current && s.unobserve(o.current), o.current = null);\n    };\n  }\n  return { callbackRef: r, ref: o };\n}\nfunction On(t, e, n, o, r, s, i, l, c) {\n  const u = react__WEBPACK_IMPORTED_MODULE_1__.useCallback(\n    (f) => {\n      const S = So(f.children, e, l ? \"offsetWidth\" : \"offsetHeight\", r);\n      let p = f.parentElement;\n      for (; !p.dataset.virtuosoScroller; )\n        p = p.parentElement;\n      const m = p.lastElementChild.dataset.viewportType === \"window\";\n      let w;\n      m && (w = p.ownerDocument.defaultView);\n      const I = i ? l ? i.scrollLeft : i.scrollTop : m ? l ? w.scrollX || w.document.documentElement.scrollLeft : w.scrollY || w.document.documentElement.scrollTop : l ? p.scrollLeft : p.scrollTop, C = i ? l ? i.scrollWidth : i.scrollHeight : m ? l ? w.document.documentElement.scrollWidth : w.document.documentElement.scrollHeight : l ? p.scrollWidth : p.scrollHeight, g = i ? l ? i.offsetWidth : i.offsetHeight : m ? l ? w.innerWidth : w.innerHeight : l ? p.offsetWidth : p.offsetHeight;\n      o({\n        scrollHeight: C,\n        scrollTop: Math.max(I, 0),\n        viewportHeight: g\n      }), s == null || s(\n        l ? dn(\"column-gap\", getComputedStyle(f).columnGap, r) : dn(\"row-gap\", getComputedStyle(f).rowGap, r)\n      ), S !== null && t(S);\n    },\n    [t, e, r, s, i, o]\n  );\n  return _e(u, n, c);\n}\nfunction So(t, e, n, o) {\n  const r = t.length;\n  if (r === 0)\n    return null;\n  const s = [];\n  for (let i = 0; i < r; i++) {\n    const l = t.item(i);\n    if (l.dataset.index === void 0)\n      continue;\n    const c = parseInt(l.dataset.index), u = parseFloat(l.dataset.knownSize), f = e(l, n);\n    if (f === 0 && o(\"Zero-sized element, this should not happen\", { child: l }, ht.ERROR), f === u)\n      continue;\n    const S = s[s.length - 1];\n    s.length === 0 || S.size !== f || S.endIndex !== c - 1 ? s.push({ endIndex: c, size: f, startIndex: c }) : s[s.length - 1].endIndex++;\n  }\n  return s;\n}\nfunction dn(t, e, n) {\n  return e !== \"normal\" && !(e != null && e.endsWith(\"px\")) && n(`${t} was not resolved to pixel value correctly`, e, ht.WARN), e === \"normal\" ? 0 : parseInt(e != null ? e : \"0\", 10);\n}\nfunction Ge(t, e, n) {\n  const o = react__WEBPACK_IMPORTED_MODULE_1__.useRef(null), r = react__WEBPACK_IMPORTED_MODULE_1__.useCallback(\n    (c) => {\n      if (!(c != null && c.offsetParent))\n        return;\n      const u = c.getBoundingClientRect(), f = u.width;\n      let S, p;\n      if (e) {\n        const m = e.getBoundingClientRect(), w = u.top - m.top;\n        p = m.height - Math.max(0, w), S = w + e.scrollTop;\n      } else {\n        const m = i.current.ownerDocument.defaultView;\n        p = m.innerHeight - Math.max(0, u.top), S = u.top + m.scrollY;\n      }\n      o.current = {\n        offsetTop: S,\n        visibleHeight: p,\n        visibleWidth: f\n      }, t(o.current);\n    },\n    [t, e]\n  ), { callbackRef: s, ref: i } = _e(r, !0, n), l = react__WEBPACK_IMPORTED_MODULE_1__.useCallback(() => {\n    r(i.current);\n  }, [r, i]);\n  return react__WEBPACK_IMPORTED_MODULE_1__.useEffect(() => {\n    var c;\n    if (e) {\n      e.addEventListener(\"scroll\", l);\n      const u = new ResizeObserver(() => {\n        requestAnimationFrame(l);\n      });\n      return u.observe(e), () => {\n        e.removeEventListener(\"scroll\", l), u.unobserve(e);\n      };\n    } else {\n      const u = (c = i.current) == null ? void 0 : c.ownerDocument.defaultView;\n      return u == null || u.addEventListener(\"scroll\", l), u == null || u.addEventListener(\"resize\", l), () => {\n        u == null || u.removeEventListener(\"scroll\", l), u == null || u.removeEventListener(\"resize\", l);\n      };\n    }\n  }, [l, e]), s;\n}\nconst at = U(\n  () => {\n    const t = $(), e = $(), n = y(0), o = $(), r = y(0), s = $(), i = $(), l = y(0), c = y(0), u = y(0), f = y(0), S = $(), p = $(), m = y(!1), w = y(!1), I = y(!1);\n    return F(\n      x(\n        t,\n        E(({ scrollTop: C }) => C)\n      ),\n      e\n    ), F(\n      x(\n        t,\n        E(({ scrollHeight: C }) => C)\n      ),\n      i\n    ), F(e, r), {\n      deviation: n,\n      fixedFooterHeight: u,\n      fixedHeaderHeight: c,\n      footerHeight: f,\n      headerHeight: l,\n      horizontalDirection: w,\n      scrollBy: p,\n      // input\n      scrollContainerState: t,\n      scrollHeight: i,\n      scrollingInProgress: m,\n      // signals\n      scrollTo: S,\n      scrollTop: e,\n      skipAnimationFrameInResizeObserver: I,\n      smoothScrollTargetReached: o,\n      // state\n      statefulScrollTop: r,\n      viewportHeight: s\n    };\n  },\n  [],\n  { singleton: !0 }\n), oe = { lvl: 0 };\nfunction Fn(t, e) {\n  const n = t.length;\n  if (n === 0)\n    return [];\n  let { index: o, value: r } = e(t[0]);\n  const s = [];\n  for (let i = 1; i < n; i++) {\n    const { index: l, value: c } = e(t[i]);\n    s.push({ end: l - 1, start: o, value: r }), o = l, r = c;\n  }\n  return s.push({ end: 1 / 0, start: o, value: r }), s;\n}\nfunction j(t) {\n  return t === oe;\n}\nfunction re(t, e) {\n  if (!j(t))\n    return e === t.k ? t.v : e < t.k ? re(t.l, e) : re(t.r, e);\n}\nfunction Ct(t, e, n = \"k\") {\n  if (j(t))\n    return [-1 / 0, void 0];\n  if (Number(t[n]) === e)\n    return [t.k, t.v];\n  if (Number(t[n]) < e) {\n    const o = Ct(t.r, e, n);\n    return o[0] === -1 / 0 ? [t.k, t.v] : o;\n  }\n  return Ct(t.l, e, n);\n}\nfunction mt(t, e, n) {\n  return j(t) ? Vn(e, n, 1) : e === t.k ? ot(t, { k: e, v: n }) : e < t.k ? fn(ot(t, { l: mt(t.l, e, n) })) : fn(ot(t, { r: mt(t.r, e, n) }));\n}\nfunction Ut() {\n  return oe;\n}\nfunction ve(t, e, n) {\n  if (j(t))\n    return [];\n  const o = Ct(t, e)[0];\n  return xo(ze(t, o, n));\n}\nfunction Le(t, e) {\n  if (j(t)) return oe;\n  const { k: n, l: o, r } = t;\n  if (e === n) {\n    if (j(o))\n      return r;\n    if (j(r))\n      return o;\n    {\n      const [s, i] = zn(o);\n      return ge(ot(t, { k: s, l: Ln(o), v: i }));\n    }\n  } else return e < n ? ge(ot(t, { l: Le(o, e) })) : ge(ot(t, { r: Le(r, e) }));\n}\nfunction _t(t) {\n  return j(t) ? [] : [..._t(t.l), { k: t.k, v: t.v }, ..._t(t.r)];\n}\nfunction ze(t, e, n) {\n  if (j(t))\n    return [];\n  const { k: o, l: r, r: s, v: i } = t;\n  let l = [];\n  return o > e && (l = l.concat(ze(r, e, n))), o >= e && o <= n && l.push({ k: o, v: i }), o <= n && (l = l.concat(ze(s, e, n))), l;\n}\nfunction ge(t) {\n  const { l: e, lvl: n, r: o } = t;\n  if (o.lvl >= n - 1 && e.lvl >= n - 1)\n    return t;\n  if (n > o.lvl + 1) {\n    if (Ee(e))\n      return Pn(ot(t, { lvl: n - 1 }));\n    if (!j(e) && !j(e.r))\n      return ot(e.r, {\n        l: ot(e, { r: e.r.l }),\n        lvl: n,\n        r: ot(t, {\n          l: e.r.r,\n          lvl: n - 1\n        })\n      });\n    throw new Error(\"Unexpected empty nodes\");\n  } else {\n    if (Ee(t))\n      return Ve(ot(t, { lvl: n - 1 }));\n    if (!j(o) && !j(o.l)) {\n      const r = o.l, s = Ee(r) ? o.lvl - 1 : o.lvl;\n      return ot(r, {\n        l: ot(t, {\n          lvl: n - 1,\n          r: r.l\n        }),\n        lvl: r.lvl + 1,\n        r: Ve(ot(o, { l: r.r, lvl: s }))\n      });\n    } else\n      throw new Error(\"Unexpected empty nodes\");\n  }\n}\nfunction ot(t, e) {\n  return Vn(\n    e.k !== void 0 ? e.k : t.k,\n    e.v !== void 0 ? e.v : t.v,\n    e.lvl !== void 0 ? e.lvl : t.lvl,\n    e.l !== void 0 ? e.l : t.l,\n    e.r !== void 0 ? e.r : t.r\n  );\n}\nfunction Ln(t) {\n  return j(t.r) ? t.l : ge(ot(t, { r: Ln(t.r) }));\n}\nfunction Ee(t) {\n  return j(t) || t.lvl > t.r.lvl;\n}\nfunction zn(t) {\n  return j(t.r) ? [t.k, t.v] : zn(t.r);\n}\nfunction Vn(t, e, n, o = oe, r = oe) {\n  return { k: t, l: o, lvl: n, r, v: e };\n}\nfunction fn(t) {\n  return Ve(Pn(t));\n}\nfunction Pn(t) {\n  const { l: e } = t;\n  return !j(e) && e.lvl === t.lvl ? ot(e, { r: ot(t, { l: e.r }) }) : t;\n}\nfunction Ve(t) {\n  const { lvl: e, r: n } = t;\n  return !j(n) && !j(n.r) && n.lvl === e && n.r.lvl === e ? ot(n, { l: ot(t, { r: n.l }), lvl: e + 1 }) : t;\n}\nfunction xo(t) {\n  return Fn(t, ({ k: e, v: n }) => ({ index: e, value: n }));\n}\nfunction An(t, e) {\n  return !!(t && t.startIndex === e.startIndex && t.endIndex === e.endIndex);\n}\nfunction se(t, e) {\n  return !!(t && t[0] === e[0] && t[1] === e[1]);\n}\nconst Ne = U(\n  () => ({ recalcInProgress: y(!1) }),\n  [],\n  { singleton: !0 }\n);\nfunction Mn(t, e, n) {\n  return t[Se(t, e, n)];\n}\nfunction Se(t, e, n, o = 0) {\n  let r = t.length - 1;\n  for (; o <= r; ) {\n    const s = Math.floor((o + r) / 2), i = t[s], l = n(i, e);\n    if (l === 0)\n      return s;\n    if (l === -1) {\n      if (r - o < 2)\n        return s - 1;\n      r = s - 1;\n    } else {\n      if (r === o)\n        return s;\n      o = s + 1;\n    }\n  }\n  throw new Error(`Failed binary finding record in array - ${t.join(\",\")}, searched for ${e}`);\n}\nfunction To(t, e, n, o) {\n  const r = Se(t, e, o), s = Se(t, n, o, r);\n  return t.slice(r, s + 1);\n}\nfunction wt(t, e) {\n  return Math.round(t.getBoundingClientRect()[e]);\n}\nfunction be(t) {\n  return !j(t.groupOffsetTree);\n}\nfunction De({ index: t }, e) {\n  return e === t ? 0 : e < t ? -1 : 1;\n}\nfunction Co() {\n  return {\n    groupIndices: [],\n    groupOffsetTree: Ut(),\n    lastIndex: 0,\n    lastOffset: 0,\n    lastSize: 0,\n    offsetTree: [],\n    sizeTree: Ut()\n  };\n}\nfunction wo(t, e) {\n  let n = j(t) ? 0 : 1 / 0;\n  for (const o of e) {\n    const { endIndex: r, size: s, startIndex: i } = o;\n    if (n = Math.min(n, i), j(t)) {\n      t = mt(t, 0, s);\n      continue;\n    }\n    const l = ve(t, i - 1, r + 1);\n    if (l.some(ko(o)))\n      continue;\n    let c = !1, u = !1;\n    for (const { end: f, start: S, value: p } of l)\n      c ? (r >= S || s === p) && (t = Le(t, S)) : (u = p !== s, c = !0), f > r && r >= S && p !== s && (t = mt(t, r + 1, p));\n    u && (t = mt(t, i, s));\n  }\n  return [t, n];\n}\nfunction yo(t) {\n  return typeof t.groupIndex < \"u\";\n}\nfunction vo({ offset: t }, e) {\n  return e === t ? 0 : e < t ? -1 : 1;\n}\nfunction ie(t, e, n) {\n  if (e.length === 0)\n    return 0;\n  const { index: o, offset: r, size: s } = Mn(e, t, De), i = t - o, l = s * i + (i - 1) * n + r;\n  return l > 0 ? l + n : l;\n}\nfunction Wn(t, e) {\n  if (!be(e))\n    return t;\n  let n = 0;\n  for (; e.groupIndices[n] <= t + n; )\n    n++;\n  return t + n;\n}\nfunction _n(t, e, n) {\n  if (yo(t))\n    return e.groupIndices[t.groupIndex] + 1;\n  {\n    const o = t.index === \"LAST\" ? n : t.index;\n    let r = Wn(o, e);\n    return r = Math.max(0, r, Math.min(n, r)), r;\n  }\n}\nfunction bo(t, e, n, o = 0) {\n  return o > 0 && (e = Math.max(e, Mn(t, o, De).offset)), Fn(To(t, e, n, vo), Eo);\n}\nfunction Ro(t, [e, n, o, r]) {\n  e.length > 0 && o(\"received item sizes\", e, ht.DEBUG);\n  const s = t.sizeTree;\n  let i = s, l = 0;\n  if (n.length > 0 && j(s) && e.length === 2) {\n    const p = e[0].size, m = e[1].size;\n    i = n.reduce((w, I) => mt(mt(w, I, p), I + 1, m), i);\n  } else\n    [i, l] = wo(i, e);\n  if (i === s)\n    return t;\n  const { lastIndex: c, lastOffset: u, lastSize: f, offsetTree: S } = Pe(t.offsetTree, l, i, r);\n  return {\n    groupIndices: n,\n    groupOffsetTree: n.reduce((p, m) => mt(p, m, ie(m, S, r)), Ut()),\n    lastIndex: c,\n    lastOffset: u,\n    lastSize: f,\n    offsetTree: S,\n    sizeTree: i\n  };\n}\nfunction Ho(t) {\n  return _t(t).map(({ k: e, v: n }, o, r) => {\n    const s = r[o + 1];\n    return { endIndex: s ? s.k - 1 : 1 / 0, size: n, startIndex: e };\n  });\n}\nfunction mn(t, e) {\n  let n = 0, o = 0;\n  for (; n < t; )\n    n += e[o + 1] - e[o] - 1, o++;\n  return o - (n === t ? 0 : 1);\n}\nfunction Pe(t, e, n, o) {\n  let r = t, s = 0, i = 0, l = 0, c = 0;\n  if (e !== 0) {\n    c = Se(r, e - 1, De), l = r[c].offset;\n    const f = Ct(n, e - 1);\n    s = f[0], i = f[1], r.length && r[c].size === Ct(n, e)[1] && (c -= 1), r = r.slice(0, c + 1);\n  } else\n    r = [];\n  for (const { start: u, value: f } of ve(n, e, 1 / 0)) {\n    const S = u - s, p = S * i + l + S * o;\n    r.push({\n      index: u,\n      offset: p,\n      size: f\n    }), s = u, l = p, i = f;\n  }\n  return {\n    lastIndex: s,\n    lastOffset: l,\n    lastSize: i,\n    offsetTree: r\n  };\n}\nfunction Eo(t) {\n  return { index: t.index, value: t };\n}\nfunction ko(t) {\n  const { endIndex: e, size: n, startIndex: o } = t;\n  return (r) => r.start === o && (r.end === e || r.end === 1 / 0) && r.value === n;\n}\nconst Bo = {\n  offsetHeight: \"height\",\n  offsetWidth: \"width\"\n}, Et = U(\n  ([{ log: t }, { recalcInProgress: e }]) => {\n    const n = $(), o = $(), r = ct(o, 0), s = $(), i = $(), l = y(0), c = y([]), u = y(void 0), f = y(void 0), S = y((h, d) => wt(h, Bo[d])), p = y(void 0), m = y(0), w = Co(), I = ct(\n      x(n, G(c, t, m), bt(Ro, w), Y()),\n      w\n    ), C = ct(\n      x(\n        c,\n        Y(),\n        bt((h, d) => ({ current: d, prev: h.current }), {\n          current: [],\n          prev: []\n        }),\n        E(({ prev: h }) => h)\n      ),\n      []\n    );\n    F(\n      x(\n        c,\n        P((h) => h.length > 0),\n        G(I, m),\n        E(([h, d, R]) => {\n          const B = h.reduce((O, L, V) => mt(O, L, ie(L, d.offsetTree, R) || V), Ut());\n          return {\n            ...d,\n            groupIndices: h,\n            groupOffsetTree: B\n          };\n        })\n      ),\n      I\n    ), F(\n      x(\n        o,\n        G(I),\n        P(([h, { lastIndex: d }]) => h < d),\n        E(([h, { lastIndex: d, lastSize: R }]) => [\n          {\n            endIndex: d,\n            size: R,\n            startIndex: h\n          }\n        ])\n      ),\n      n\n    ), F(u, f);\n    const g = ct(\n      x(\n        u,\n        E((h) => h === void 0)\n      ),\n      !0\n    );\n    F(\n      x(\n        f,\n        P((h) => h !== void 0 && j(lt(I).sizeTree)),\n        E((h) => [{ endIndex: 0, size: h, startIndex: 0 }])\n      ),\n      n\n    );\n    const a = pt(\n      x(\n        n,\n        G(I),\n        bt(\n          ({ sizes: h }, [d, R]) => ({\n            changed: R !== h,\n            sizes: R\n          }),\n          { changed: !1, sizes: w }\n        ),\n        E((h) => h.changed)\n      )\n    );\n    K(\n      x(\n        l,\n        bt(\n          (h, d) => ({ diff: h.prev - d, prev: d }),\n          { diff: 0, prev: 0 }\n        ),\n        E((h) => h.diff)\n      ),\n      (h) => {\n        const { groupIndices: d } = lt(I);\n        if (h > 0)\n          W(e, !0), W(s, h + mn(h, d));\n        else if (h < 0) {\n          const R = lt(C);\n          R.length > 0 && (h -= mn(-h, R)), W(i, h);\n        }\n      }\n    ), K(x(l, G(t)), ([h, d]) => {\n      h < 0 && d(\n        \"`firstItemIndex` prop should not be set to less than zero. If you don't know the total count, just use a very high value\",\n        { firstItemIndex: l },\n        ht.ERROR\n      );\n    });\n    const T = pt(s);\n    F(\n      x(\n        s,\n        G(I),\n        E(([h, d]) => {\n          const R = d.groupIndices.length > 0, B = [], O = d.lastSize;\n          if (R) {\n            const L = re(d.sizeTree, 0);\n            let V = 0, D = 0;\n            for (; V < h; ) {\n              const k = d.groupIndices[D], q = d.groupIndices.length === D + 1 ? 1 / 0 : d.groupIndices[D + 1] - k - 1;\n              B.push({\n                endIndex: k,\n                size: L,\n                startIndex: k\n              }), B.push({\n                endIndex: k + 1 + q - 1,\n                size: O,\n                startIndex: k + 1\n              }), D++, V += q + 1;\n            }\n            const J = _t(d.sizeTree);\n            return V !== h && J.shift(), J.reduce(\n              (k, { k: q, v: st }) => {\n                let dt = k.ranges;\n                return k.prevSize !== 0 && (dt = [\n                  ...k.ranges,\n                  {\n                    endIndex: q + h - 1,\n                    size: k.prevSize,\n                    startIndex: k.prevIndex\n                  }\n                ]), {\n                  prevIndex: q + h,\n                  prevSize: st,\n                  ranges: dt\n                };\n              },\n              {\n                prevIndex: h,\n                prevSize: 0,\n                ranges: B\n              }\n            ).ranges;\n          }\n          return _t(d.sizeTree).reduce(\n            (L, { k: V, v: D }) => ({\n              prevIndex: V + h,\n              prevSize: D,\n              ranges: [...L.ranges, { endIndex: V + h - 1, size: L.prevSize, startIndex: L.prevIndex }]\n            }),\n            {\n              prevIndex: 0,\n              prevSize: O,\n              ranges: []\n            }\n          ).ranges;\n        })\n      ),\n      n\n    );\n    const b = pt(\n      x(\n        i,\n        G(I, m),\n        E(([h, { offsetTree: d }, R]) => {\n          const B = -h;\n          return ie(B, d, R);\n        })\n      )\n    );\n    return F(\n      x(\n        i,\n        G(I, m),\n        E(([h, d, R]) => {\n          if (d.groupIndices.length > 0) {\n            if (j(d.sizeTree))\n              return d;\n            let O = Ut();\n            const L = lt(C);\n            let V = 0, D = 0, J = 0;\n            for (; V < -h; ) {\n              J = L[D];\n              const k = L[D + 1] - J - 1;\n              D++, V += k + 1;\n            }\n            if (O = _t(d.sizeTree).reduce((k, { k: q, v: st }) => mt(k, Math.max(0, q + h), st), O), V !== -h) {\n              const k = re(d.sizeTree, J);\n              O = mt(O, 0, k);\n              const q = Ct(d.sizeTree, -h + 1)[1];\n              O = mt(O, 1, q);\n            }\n            return {\n              ...d,\n              sizeTree: O,\n              ...Pe(d.offsetTree, 0, O, R)\n            };\n          } else {\n            const O = _t(d.sizeTree).reduce((L, { k: V, v: D }) => mt(L, Math.max(0, V + h), D), Ut());\n            return {\n              ...d,\n              sizeTree: O,\n              ...Pe(d.offsetTree, 0, O, R)\n            };\n          }\n        })\n      ),\n      I\n    ), {\n      beforeUnshiftWith: T,\n      // input\n      data: p,\n      defaultItemSize: f,\n      firstItemIndex: l,\n      fixedItemSize: u,\n      gap: m,\n      groupIndices: c,\n      itemSize: S,\n      listRefresh: a,\n      shiftWith: i,\n      shiftWithOffset: b,\n      sizeRanges: n,\n      // output\n      sizes: I,\n      statefulTotalCount: r,\n      totalCount: o,\n      trackItemSizes: g,\n      unshiftWith: s\n    };\n  },\n  X(Vt, Ne),\n  { singleton: !0 }\n);\nfunction Oo(t) {\n  return t.reduce(\n    (e, n) => (e.groupIndices.push(e.totalCount), e.totalCount += n + 1, e),\n    {\n      groupIndices: [],\n      totalCount: 0\n    }\n  );\n}\nconst Gn = U(\n  ([{ groupIndices: t, sizes: e, totalCount: n }, { headerHeight: o, scrollTop: r }]) => {\n    const s = $(), i = $(), l = pt(x(s, E(Oo)));\n    return F(\n      x(\n        l,\n        E((c) => c.totalCount)\n      ),\n      n\n    ), F(\n      x(\n        l,\n        E((c) => c.groupIndices)\n      ),\n      t\n    ), F(\n      x(\n        rt(r, e, o),\n        P(([c, u]) => be(u)),\n        E(([c, u, f]) => Ct(u.groupOffsetTree, Math.max(c - f, 0), \"v\")[0]),\n        Y(),\n        E((c) => [c])\n      ),\n      i\n    ), { groupCounts: s, topItemsIndexes: i };\n  },\n  X(Et, at)\n), Pt = U(\n  ([{ log: t }]) => {\n    const e = y(!1), n = pt(\n      x(\n        e,\n        P((o) => o),\n        Y()\n      )\n    );\n    return K(e, (o) => {\n      o && lt(t)(\"props updated\", {}, ht.DEBUG);\n    }), { didMount: n, propsReady: e };\n  },\n  X(Vt),\n  { singleton: !0 }\n), Fo = typeof document < \"u\" && \"scrollBehavior\" in document.documentElement.style;\nfunction Nn(t) {\n  const e = typeof t == \"number\" ? { index: t } : t;\n  return e.align || (e.align = \"start\"), (!e.behavior || !Fo) && (e.behavior = \"auto\"), e.offset || (e.offset = 0), e;\n}\nconst ce = U(\n  ([\n    { gap: t, listRefresh: e, sizes: n, totalCount: o },\n    {\n      fixedFooterHeight: r,\n      fixedHeaderHeight: s,\n      footerHeight: i,\n      headerHeight: l,\n      scrollingInProgress: c,\n      scrollTo: u,\n      smoothScrollTargetReached: f,\n      viewportHeight: S\n    },\n    { log: p }\n  ]) => {\n    const m = $(), w = $(), I = y(0);\n    let C = null, g = null, a = null;\n    function T() {\n      C && (C(), C = null), a && (a(), a = null), g && (clearTimeout(g), g = null), W(c, !1);\n    }\n    return F(\n      x(\n        m,\n        G(n, S, o, I, l, i, p),\n        G(t, s, r),\n        E(\n          ([\n            [b, h, d, R, B, O, L, V],\n            D,\n            J,\n            nt\n          ]) => {\n            const k = Nn(b), { align: q, behavior: st, offset: dt } = k, St = R - 1, ft = _n(k, h, St);\n            let ut = ie(ft, h.offsetTree, D) + O;\n            q === \"end\" ? (ut += J + Ct(h.sizeTree, ft)[1] - d + nt, ft === St && (ut += L)) : q === \"center\" ? ut += (J + Ct(h.sizeTree, ft)[1] - d + nt) / 2 : ut -= B, dt && (ut += dt);\n            const At = (xt) => {\n              T(), xt ? (V(\"retrying to scroll to\", { location: b }, ht.DEBUG), W(m, b)) : (W(w, !0), V(\"list did not change, scroll successful\", {}, ht.DEBUG));\n            };\n            if (T(), st === \"smooth\") {\n              let xt = !1;\n              a = K(e, (Xt) => {\n                xt = xt || Xt;\n              }), C = Rt(f, () => {\n                At(xt);\n              });\n            } else\n              C = Rt(x(e, Lo(150)), At);\n            return g = setTimeout(() => {\n              T();\n            }, 1200), W(c, !0), V(\"scrolling from index to\", { behavior: st, index: ft, top: ut }, ht.DEBUG), { behavior: st, top: ut };\n          }\n        )\n      ),\n      u\n    ), {\n      scrollTargetReached: w,\n      scrollToIndex: m,\n      topListHeight: I\n    };\n  },\n  X(Et, at, Vt),\n  { singleton: !0 }\n);\nfunction Lo(t) {\n  return (e) => {\n    const n = setTimeout(() => {\n      e(!1);\n    }, t);\n    return (o) => {\n      o && (e(!0), clearTimeout(n));\n    };\n  };\n}\nfunction $e(t, e) {\n  t == 0 ? e() : requestAnimationFrame(() => {\n    $e(t - 1, e);\n  });\n}\nfunction Ue(t, e) {\n  const n = e - 1;\n  return typeof t == \"number\" ? t : t.index === \"LAST\" ? n : t.index;\n}\nconst ue = U(\n  ([{ defaultItemSize: t, listRefresh: e, sizes: n }, { scrollTop: o }, { scrollTargetReached: r, scrollToIndex: s }, { didMount: i }]) => {\n    const l = y(!0), c = y(0), u = y(!0);\n    return F(\n      x(\n        i,\n        G(c),\n        P(([f, S]) => !!S),\n        vt(!1)\n      ),\n      l\n    ), F(\n      x(\n        i,\n        G(c),\n        P(([f, S]) => !!S),\n        vt(!1)\n      ),\n      u\n    ), K(\n      x(\n        rt(e, i),\n        G(l, n, t, u),\n        P(([[, f], S, { sizeTree: p }, m, w]) => f && (!j(p) || Me(m)) && !S && !w),\n        G(c)\n      ),\n      ([, f]) => {\n        Rt(r, () => {\n          W(u, !0);\n        }), $e(4, () => {\n          Rt(o, () => {\n            W(l, !0);\n          }), W(s, f);\n        });\n      }\n    ), {\n      initialItemFinalLocationReached: u,\n      initialTopMostItemIndex: c,\n      scrolledToInitialItem: l\n    };\n  },\n  X(Et, at, ce, Pt),\n  { singleton: !0 }\n);\nfunction Dn(t, e) {\n  return Math.abs(t - e) < 1.01;\n}\nconst le = \"up\", te = \"down\", zo = \"none\", Vo = {\n  atBottom: !1,\n  notAtBottomBecause: \"NOT_SHOWING_LAST_ITEM\",\n  state: {\n    offsetBottom: 0,\n    scrollHeight: 0,\n    scrollTop: 0,\n    viewportHeight: 0\n  }\n}, Po = 0, ae = U(([{ footerHeight: t, headerHeight: e, scrollBy: n, scrollContainerState: o, scrollTop: r, viewportHeight: s }]) => {\n  const i = y(!1), l = y(!0), c = $(), u = $(), f = y(4), S = y(Po), p = ct(\n    x(\n      an(x(A(r), jt(1), vt(!0)), x(A(r), jt(1), vt(!1), un(100))),\n      Y()\n    ),\n    !1\n  ), m = ct(\n    x(an(x(n, vt(!0)), x(n, vt(!1), un(200))), Y()),\n    !1\n  );\n  F(\n    x(\n      rt(A(r), A(S)),\n      E(([a, T]) => a <= T),\n      Y()\n    ),\n    l\n  ), F(x(l, Lt(50)), u);\n  const w = pt(\n    x(\n      rt(o, A(s), A(e), A(t), A(f)),\n      bt((a, [{ scrollHeight: T, scrollTop: b }, h, d, R, B]) => {\n        const O = b + h - T > -B, L = {\n          scrollHeight: T,\n          scrollTop: b,\n          viewportHeight: h\n        };\n        if (O) {\n          let D, J;\n          return b > a.state.scrollTop ? (D = \"SCROLLED_DOWN\", J = a.state.scrollTop - b) : (D = \"SIZE_DECREASED\", J = a.state.scrollTop - b || a.scrollTopDelta), {\n            atBottom: !0,\n            atBottomBecause: D,\n            scrollTopDelta: J,\n            state: L\n          };\n        }\n        let V;\n        return L.scrollHeight > a.state.scrollHeight ? V = \"SIZE_INCREASED\" : h < a.state.viewportHeight ? V = \"VIEWPORT_HEIGHT_DECREASING\" : b < a.state.scrollTop ? V = \"SCROLLING_UPWARDS\" : V = \"NOT_FULLY_SCROLLED_TO_LAST_ITEM_BOTTOM\", {\n          atBottom: !1,\n          notAtBottomBecause: V,\n          state: L\n        };\n      }, Vo),\n      Y((a, T) => a && a.atBottom === T.atBottom)\n    )\n  ), I = ct(\n    x(\n      o,\n      bt(\n        (a, { scrollHeight: T, scrollTop: b, viewportHeight: h }) => {\n          if (Dn(a.scrollHeight, T))\n            return {\n              changed: !1,\n              jump: 0,\n              scrollHeight: T,\n              scrollTop: b\n            };\n          {\n            const d = T - (b + h) < 1;\n            return a.scrollTop !== b && d ? {\n              changed: !0,\n              jump: a.scrollTop - b,\n              scrollHeight: T,\n              scrollTop: b\n            } : {\n              changed: !0,\n              jump: 0,\n              scrollHeight: T,\n              scrollTop: b\n            };\n          }\n        },\n        { changed: !1, jump: 0, scrollHeight: 0, scrollTop: 0 }\n      ),\n      P((a) => a.changed),\n      E((a) => a.jump)\n    ),\n    0\n  );\n  F(\n    x(\n      w,\n      E((a) => a.atBottom)\n    ),\n    i\n  ), F(x(i, Lt(50)), c);\n  const C = y(te);\n  F(\n    x(\n      o,\n      E(({ scrollTop: a }) => a),\n      Y(),\n      bt(\n        (a, T) => lt(m) ? { direction: a.direction, prevScrollTop: T } : { direction: T < a.prevScrollTop ? le : te, prevScrollTop: T },\n        { direction: te, prevScrollTop: 0 }\n      ),\n      E((a) => a.direction)\n    ),\n    C\n  ), F(x(o, Lt(50), vt(zo)), C);\n  const g = y(0);\n  return F(\n    x(\n      p,\n      P((a) => !a),\n      vt(0)\n    ),\n    g\n  ), F(\n    x(\n      r,\n      Lt(100),\n      G(p),\n      P(([a, T]) => !!T),\n      bt(([a, T], [b]) => [T, b], [0, 0]),\n      E(([a, T]) => T - a)\n    ),\n    g\n  ), {\n    atBottomState: w,\n    atBottomStateChange: c,\n    atBottomThreshold: f,\n    atTopStateChange: u,\n    atTopThreshold: S,\n    isAtBottom: i,\n    isAtTop: l,\n    isScrolling: p,\n    lastJumpDueToItemResize: I,\n    scrollDirection: C,\n    scrollVelocity: g\n  };\n}, X(at)), xe = \"top\", Te = \"bottom\", pn = \"none\";\nfunction hn(t, e, n) {\n  return typeof t == \"number\" ? n === le && e === xe || n === te && e === Te ? t : 0 : n === le ? e === xe ? t.main : t.reverse : e === Te ? t.main : t.reverse;\n}\nfunction gn(t, e) {\n  var n;\n  return typeof t == \"number\" ? t : (n = t[e]) != null ? n : 0;\n}\nconst Ke = U(\n  ([{ deviation: t, fixedHeaderHeight: e, headerHeight: n, scrollTop: o, viewportHeight: r }]) => {\n    const s = $(), i = y(0), l = y(0), c = y(0), u = ct(\n      x(\n        rt(\n          A(o),\n          A(r),\n          A(n),\n          A(s, se),\n          A(c),\n          A(i),\n          A(e),\n          A(t),\n          A(l)\n        ),\n        E(\n          ([\n            f,\n            S,\n            p,\n            [m, w],\n            I,\n            C,\n            g,\n            a,\n            T\n          ]) => {\n            const b = f - a, h = C + g, d = Math.max(p - b, 0);\n            let R = pn;\n            const B = gn(T, xe), O = gn(T, Te);\n            return m -= a, m += p + g, w += p + g, w -= a, m > f + h - B && (R = le), w < f - d + S + O && (R = te), R !== pn ? [\n              Math.max(b - p - hn(I, xe, R) - B, 0),\n              b - d - g + S + hn(I, Te, R) + O\n            ] : null;\n          }\n        ),\n        P((f) => f != null),\n        Y(se)\n      ),\n      [0, 0]\n    );\n    return {\n      increaseViewportBy: l,\n      // input\n      listBoundary: s,\n      overscan: c,\n      topListHeight: i,\n      // output\n      visibleRange: u\n    };\n  },\n  X(at),\n  { singleton: !0 }\n);\nfunction Ao(t, e, n) {\n  if (be(e)) {\n    const o = Wn(t, e);\n    return [\n      { index: Ct(e.groupOffsetTree, o)[0], offset: 0, size: 0 },\n      { data: n == null ? void 0 : n[0], index: o, offset: 0, size: 0 }\n    ];\n  }\n  return [{ data: n == null ? void 0 : n[0], index: t, offset: 0, size: 0 }];\n}\nconst ke = {\n  bottom: 0,\n  firstItemIndex: 0,\n  items: [],\n  offsetBottom: 0,\n  offsetTop: 0,\n  top: 0,\n  topItems: [],\n  topListHeight: 0,\n  totalCount: 0\n};\nfunction Ie(t, e, n, o, r, s) {\n  const { lastIndex: i, lastOffset: l, lastSize: c } = r;\n  let u = 0, f = 0;\n  if (t.length > 0) {\n    u = t[0].offset;\n    const I = t[t.length - 1];\n    f = I.offset + I.size;\n  }\n  const S = n - i, p = l + S * c + (S - 1) * o, m = u, w = p - f;\n  return {\n    bottom: f,\n    firstItemIndex: s,\n    items: In(t, r, s),\n    offsetBottom: w,\n    offsetTop: u,\n    top: m,\n    topItems: In(e, r, s),\n    topListHeight: e.reduce((I, C) => C.size + I, 0),\n    totalCount: n\n  };\n}\nfunction $n(t, e, n, o, r, s) {\n  let i = 0;\n  if (n.groupIndices.length > 0)\n    for (const f of n.groupIndices) {\n      if (f - i >= t)\n        break;\n      i++;\n    }\n  const l = t + i, c = Ue(e, l), u = Array.from({ length: l }).map((f, S) => ({\n    data: s[S + c],\n    index: S + c,\n    offset: 0,\n    size: 0\n  }));\n  return Ie(u, [], l, r, n, o);\n}\nfunction In(t, e, n) {\n  if (t.length === 0)\n    return [];\n  if (!be(e))\n    return t.map((u) => ({ ...u, index: u.index + n, originalIndex: u.index }));\n  const o = t[0].index, r = t[t.length - 1].index, s = [], i = ve(e.groupOffsetTree, o, r);\n  let l, c = 0;\n  for (const u of t) {\n    (!l || l.end < u.index) && (l = i.shift(), c = e.groupIndices.indexOf(l.start));\n    let f;\n    u.index === l.start ? f = {\n      index: c,\n      type: \"group\"\n    } : f = {\n      groupIndex: c,\n      index: u.index - (c + 1) + n\n    }, s.push({\n      ...f,\n      data: u.data,\n      offset: u.offset,\n      originalIndex: u.index,\n      size: u.size\n    });\n  }\n  return s;\n}\nconst Gt = U(\n  ([\n    { data: t, firstItemIndex: e, gap: n, sizes: o, totalCount: r },\n    s,\n    { listBoundary: i, topListHeight: l, visibleRange: c },\n    { initialTopMostItemIndex: u, scrolledToInitialItem: f },\n    { topListHeight: S },\n    p,\n    { didMount: m },\n    { recalcInProgress: w }\n  ]) => {\n    const I = y([]), C = y(0), g = $();\n    F(s.topItemsIndexes, I);\n    const a = ct(\n      x(\n        rt(\n          m,\n          w,\n          A(c, se),\n          A(r),\n          A(o),\n          A(u),\n          f,\n          A(I),\n          A(e),\n          A(n),\n          t\n        ),\n        P(([d, R, , B, , , , , , , O]) => {\n          const L = O && O.length !== B;\n          return d && !R && !L;\n        }),\n        E(\n          ([\n            ,\n            ,\n            [d, R],\n            B,\n            O,\n            L,\n            V,\n            D,\n            J,\n            nt,\n            k\n          ]) => {\n            const q = O, { offsetTree: st, sizeTree: dt } = q, St = lt(C);\n            if (B === 0)\n              return { ...ke, totalCount: B };\n            if (d === 0 && R === 0)\n              return St === 0 ? { ...ke, totalCount: B } : $n(St, L, O, J, nt, k || []);\n            if (j(dt))\n              return St > 0 ? null : Ie(\n                Ao(Ue(L, B), q, k),\n                [],\n                B,\n                nt,\n                q,\n                J\n              );\n            const ft = [];\n            if (D.length > 0) {\n              const Mt = D[0], yt = D[D.length - 1];\n              let kt = 0;\n              for (const v of ve(dt, Mt, yt)) {\n                const N = v.value, Q = Math.max(v.start, Mt), it = Math.min(v.end, yt);\n                for (let tt = Q; tt <= it; tt++)\n                  ft.push({ data: k == null ? void 0 : k[tt], index: tt, offset: kt, size: N }), kt += N;\n              }\n            }\n            if (!V)\n              return Ie([], ft, B, nt, q, J);\n            const ut = D.length > 0 ? D[D.length - 1] + 1 : 0, At = bo(st, d, R, ut);\n            if (At.length === 0)\n              return null;\n            const xt = B - 1, Xt = ye([], (Mt) => {\n              for (const yt of At) {\n                const kt = yt.value;\n                let v = kt.offset, N = yt.start;\n                const Q = kt.size;\n                if (kt.offset < d) {\n                  N += Math.floor((d - kt.offset + nt) / (Q + nt));\n                  const tt = N - yt.start;\n                  v += tt * Q + tt * nt;\n                }\n                N < ut && (v += (ut - N) * Q, N = ut);\n                const it = Math.min(yt.end, xt);\n                for (let tt = N; tt <= it && !(v >= R); tt++)\n                  Mt.push({ data: k == null ? void 0 : k[tt], index: tt, offset: v, size: Q }), v += Q + nt;\n              }\n            });\n            return Ie(Xt, ft, B, nt, q, J);\n          }\n        ),\n        //@ts-expect-error filter needs to be fixed\n        P((d) => d !== null),\n        Y()\n      ),\n      ke\n    );\n    F(\n      x(\n        t,\n        P(Me),\n        E((d) => d == null ? void 0 : d.length)\n      ),\n      r\n    ), F(\n      x(\n        a,\n        E((d) => d.topListHeight)\n      ),\n      S\n    ), F(S, l), F(\n      x(\n        a,\n        E((d) => [d.top, d.bottom])\n      ),\n      i\n    ), F(\n      x(\n        a,\n        E((d) => d.items)\n      ),\n      g\n    );\n    const T = pt(\n      x(\n        a,\n        P(({ items: d }) => d.length > 0),\n        G(r, t),\n        P(([{ items: d }, R]) => d[d.length - 1].originalIndex === R - 1),\n        E(([, d, R]) => [d - 1, R]),\n        Y(se),\n        E(([d]) => d)\n      )\n    ), b = pt(\n      x(\n        a,\n        Lt(200),\n        P(({ items: d, topItems: R }) => d.length > 0 && d[0].originalIndex === R.length),\n        E(({ items: d }) => d[0].index),\n        Y()\n      )\n    ), h = pt(\n      x(\n        a,\n        P(({ items: d }) => d.length > 0),\n        E(({ items: d }) => {\n          let R = 0, B = d.length - 1;\n          for (; d[R].type === \"group\" && R < B; )\n            R++;\n          for (; d[B].type === \"group\" && B > R; )\n            B--;\n          return {\n            endIndex: d[B].index,\n            startIndex: d[R].index\n          };\n        }),\n        Y(An)\n      )\n    );\n    return { endReached: T, initialItemCount: C, itemsRendered: g, listState: a, rangeChanged: h, startReached: b, topItemsIndexes: I, ...p };\n  },\n  X(\n    Et,\n    Gn,\n    Ke,\n    ue,\n    ce,\n    ae,\n    Pt,\n    Ne\n  ),\n  { singleton: !0 }\n), Un = U(\n  ([{ fixedFooterHeight: t, fixedHeaderHeight: e, footerHeight: n, headerHeight: o }, { listState: r }]) => {\n    const s = $(), i = ct(\n      x(\n        rt(n, t, o, e, r),\n        E(([l, c, u, f, S]) => l + c + u + f + S.offsetBottom + S.bottom)\n      ),\n      0\n    );\n    return F(A(i), s), { totalListHeight: i, totalListHeightChanged: s };\n  },\n  X(at, Gt),\n  { singleton: !0 }\n), Mo = U(\n  ([{ viewportHeight: t }, { totalListHeight: e }]) => {\n    const n = y(!1), o = ct(\n      x(\n        rt(n, t, e),\n        P(([r]) => r),\n        E(([, r, s]) => Math.max(0, r - s)),\n        Lt(0),\n        Y()\n      ),\n      0\n    );\n    return { alignToBottom: n, paddingTopAddition: o };\n  },\n  X(at, Un),\n  { singleton: !0 }\n);\nfunction Sn(t) {\n  return t ? t === \"smooth\" ? \"smooth\" : \"auto\" : !1;\n}\nconst Wo = (t, e) => typeof t == \"function\" ? Sn(t(e)) : e && Sn(t), _o = U(\n  ([\n    { listRefresh: t, totalCount: e },\n    { atBottomState: n, isAtBottom: o },\n    { scrollToIndex: r },\n    { scrolledToInitialItem: s },\n    { didMount: i, propsReady: l },\n    { log: c },\n    { scrollingInProgress: u }\n  ]) => {\n    const f = y(!1), S = $();\n    let p = null;\n    function m(I) {\n      W(r, {\n        align: \"end\",\n        behavior: I,\n        index: \"LAST\"\n      });\n    }\n    K(\n      x(\n        rt(x(A(e), jt(1)), i),\n        G(A(f), o, s, u),\n        E(([[I, C], g, a, T, b]) => {\n          let h = C && T, d = \"auto\";\n          return h && (d = Wo(g, a || b), h = h && !!d), { followOutputBehavior: d, shouldFollow: h, totalCount: I };\n        }),\n        P(({ shouldFollow: I }) => I)\n      ),\n      ({ followOutputBehavior: I, totalCount: C }) => {\n        p && (p(), p = null), p = Rt(t, () => {\n          lt(c)(\"following output to \", { totalCount: C }, ht.DEBUG), m(I), p = null;\n        });\n      }\n    );\n    function w(I) {\n      const C = Rt(n, (g) => {\n        I && !g.atBottom && g.notAtBottomBecause === \"SIZE_INCREASED\" && !p && (lt(c)(\"scrolling to bottom due to increased size\", {}, ht.DEBUG), m(\"auto\"));\n      });\n      setTimeout(C, 100);\n    }\n    return K(\n      x(\n        rt(A(f), e, l),\n        P(([I, , C]) => I && C),\n        bt(\n          ({ value: I }, [, C]) => ({ refreshed: I === C, value: C }),\n          { refreshed: !1, value: 0 }\n        ),\n        P(({ refreshed: I }) => I),\n        G(f, e)\n      ),\n      ([, I]) => {\n        lt(s) && w(I !== !1);\n      }\n    ), K(S, () => {\n      w(lt(f) !== !1);\n    }), K(rt(A(f), n), ([I, C]) => {\n      I && !C.atBottom && C.notAtBottomBecause === \"VIEWPORT_HEIGHT_DECREASING\" && m(\"auto\");\n    }), { autoscrollToBottom: S, followOutput: f };\n  },\n  X(Et, ae, ce, ue, Pt, Vt, at)\n), Go = U(\n  ([{ data: t, firstItemIndex: e, gap: n, sizes: o }, { initialTopMostItemIndex: r }, { initialItemCount: s, listState: i }, { didMount: l }]) => (F(\n    x(\n      l,\n      G(s),\n      P(([, c]) => c !== 0),\n      G(r, o, e, n, t),\n      E(([[, c], u, f, S, p, m = []]) => $n(c, u, f, S, p, m))\n    ),\n    i\n  ), {}),\n  X(Et, ue, Gt, Pt),\n  { singleton: !0 }\n), No = U(\n  ([{ didMount: t }, { scrollTo: e }, { listState: n }]) => {\n    const o = y(0);\n    return K(\n      x(\n        t,\n        G(o),\n        P(([, r]) => r !== 0),\n        E(([, r]) => ({ top: r }))\n      ),\n      (r) => {\n        Rt(\n          x(\n            n,\n            jt(1),\n            P((s) => s.items.length > 1)\n          ),\n          () => {\n            requestAnimationFrame(() => {\n              W(e, r);\n            });\n          }\n        );\n      }\n    ), {\n      initialScrollTop: o\n    };\n  },\n  X(Pt, at, Gt),\n  { singleton: !0 }\n), Do = ({\n  itemBottom: t,\n  itemTop: e,\n  locationParams: { align: n, behavior: o, ...r },\n  viewportBottom: s,\n  viewportTop: i\n}) => e < i ? { ...r, align: n != null ? n : \"start\", behavior: o } : t > s ? { ...r, align: n != null ? n : \"end\", behavior: o } : null, $o = U(\n  ([\n    { gap: t, sizes: e, totalCount: n },\n    { fixedFooterHeight: o, fixedHeaderHeight: r, headerHeight: s, scrollingInProgress: i, scrollTop: l, viewportHeight: c },\n    { scrollToIndex: u }\n  ]) => {\n    const f = $();\n    return F(\n      x(\n        f,\n        G(e, c, n, s, r, o, l),\n        G(t),\n        E(([[S, p, m, w, I, C, g, a], T]) => {\n          const { align: b, behavior: h, calculateViewLocation: d = Do, done: R, ...B } = S, O = _n(S, p, w - 1), L = ie(O, p.offsetTree, T) + I + C, V = L + Ct(p.sizeTree, O)[1], D = a + C, J = a + m - g, nt = d({\n            itemBottom: V,\n            itemTop: L,\n            locationParams: { align: b, behavior: h, ...B },\n            viewportBottom: J,\n            viewportTop: D\n          });\n          return nt ? R && Rt(\n            x(\n              i,\n              P((k) => !k),\n              // skips the initial publish of false, and the cleanup call.\n              // but if scrollingInProgress is true, we skip the initial publish.\n              jt(lt(i) ? 1 : 2)\n            ),\n            R\n          ) : R && R(), nt;\n        }),\n        P((S) => S !== null)\n      ),\n      u\n    ), {\n      scrollIntoView: f\n    };\n  },\n  X(Et, at, ce, Gt, Vt),\n  { singleton: !0 }\n), Kn = U(\n  ([{ scrollVelocity: t }]) => {\n    const e = y(!1), n = $(), o = y(!1);\n    return F(\n      x(\n        t,\n        G(o, e, n),\n        P(([r, s]) => !!s),\n        E(([r, s, i, l]) => {\n          const { enter: c, exit: u } = s;\n          if (i) {\n            if (u(r, l))\n              return !1;\n          } else if (c(r, l))\n            return !0;\n          return i;\n        }),\n        Y()\n      ),\n      e\n    ), K(\n      x(rt(e, t, n), G(o)),\n      ([[r, s, i], l]) => {\n        r && l && l.change && l.change(s, i);\n      }\n    ), { isSeeking: e, scrollSeekConfiguration: o, scrollSeekRangeChanged: n, scrollVelocity: t };\n  },\n  X(ae),\n  { singleton: !0 }\n), je = U(([{ scrollContainerState: t, scrollTo: e }]) => {\n  const n = $(), o = $(), r = $(), s = y(!1), i = y(void 0);\n  return F(\n    x(\n      rt(n, o),\n      E(([{ scrollHeight: l, scrollTop: c, viewportHeight: u }, { offsetTop: f }]) => ({\n        scrollHeight: l,\n        scrollTop: Math.max(0, c - f),\n        viewportHeight: u\n      }))\n    ),\n    t\n  ), F(\n    x(\n      e,\n      G(o),\n      E(([l, { offsetTop: c }]) => ({\n        ...l,\n        top: l.top + c\n      }))\n    ),\n    r\n  ), {\n    customScrollParent: i,\n    // config\n    useWindowScroll: s,\n    // input\n    windowScrollContainerState: n,\n    // signals\n    windowScrollTo: r,\n    windowViewportRect: o\n  };\n}, X(at)), Uo = U(\n  ([\n    { sizeRanges: t, sizes: e },\n    { headerHeight: n, scrollTop: o },\n    { initialTopMostItemIndex: r },\n    { didMount: s },\n    { useWindowScroll: i, windowScrollContainerState: l, windowViewportRect: c }\n  ]) => {\n    const u = $(), f = y(void 0), S = y(null), p = y(null);\n    return F(l, S), F(c, p), K(\n      x(\n        u,\n        G(e, o, i, S, p, n)\n      ),\n      ([m, w, I, C, g, a, T]) => {\n        const b = Ho(w.sizeTree);\n        C && g !== null && a !== null && (I = g.scrollTop - a.offsetTop), I -= T, m({ ranges: b, scrollTop: I });\n      }\n    ), F(x(f, P(Me), E(Ko)), r), F(\n      x(\n        s,\n        G(f),\n        P(([, m]) => m !== void 0),\n        Y(),\n        E(([, m]) => m.ranges)\n      ),\n      t\n    ), {\n      getState: u,\n      restoreStateFrom: f\n    };\n  },\n  X(Et, at, ue, Pt, je)\n);\nfunction Ko(t) {\n  return { align: \"start\", index: 0, offset: t.scrollTop };\n}\nconst jo = U(([{ topItemsIndexes: t }]) => {\n  const e = y(0);\n  return F(\n    x(\n      e,\n      P((n) => n >= 0),\n      E((n) => Array.from({ length: n }).map((o, r) => r))\n    ),\n    t\n  ), { topItemCount: e };\n}, X(Gt));\nfunction jn(t) {\n  let e = !1, n;\n  return () => (e || (e = !0, n = t()), n);\n}\nconst qo = jn(() => /iP(ad|od|hone)/i.test(navigator.userAgent) && /WebKit/i.test(navigator.userAgent)), Yo = U(\n  ([\n    { deviation: t, scrollBy: e, scrollingInProgress: n, scrollTop: o },\n    { isAtBottom: r, isScrolling: s, lastJumpDueToItemResize: i, scrollDirection: l },\n    { listState: c },\n    { beforeUnshiftWith: u, gap: f, shiftWithOffset: S, sizes: p },\n    { log: m },\n    { recalcInProgress: w }\n  ]) => {\n    const I = pt(\n      x(\n        c,\n        G(i),\n        bt(\n          ([, g, a, T], [{ bottom: b, items: h, offsetBottom: d, totalCount: R }, B]) => {\n            const O = b + d;\n            let L = 0;\n            return a === R && g.length > 0 && h.length > 0 && (h[0].originalIndex === 0 && g[0].originalIndex === 0 || (L = O - T, L !== 0 && (L += B))), [L, h, R, O];\n          },\n          [0, [], 0, 0]\n        ),\n        P(([g]) => g !== 0),\n        G(o, l, n, r, m, w),\n        P(([, g, a, T, , , b]) => !b && !T && g !== 0 && a === le),\n        E(([[g], , , , , a]) => (a(\"Upward scrolling compensation\", { amount: g }, ht.DEBUG), g))\n      )\n    );\n    function C(g) {\n      g > 0 ? (W(e, { behavior: \"auto\", top: -g }), W(t, 0)) : (W(t, 0), W(e, { behavior: \"auto\", top: -g }));\n    }\n    return K(x(I, G(t, s)), ([g, a, T]) => {\n      T && qo() ? W(t, a - g) : C(-g);\n    }), K(\n      x(\n        rt(ct(s, !1), t, w),\n        P(([g, a, T]) => !g && !T && a !== 0),\n        E(([g, a]) => a),\n        Lt(1)\n      ),\n      C\n    ), F(\n      x(\n        S,\n        E((g) => ({ top: -g }))\n      ),\n      e\n    ), K(\n      x(\n        u,\n        G(p, f),\n        E(([g, { groupIndices: a, lastSize: T, sizeTree: b }, h]) => {\n          function d(R) {\n            return R * (T + h);\n          }\n          if (a.length === 0)\n            return d(g);\n          {\n            let R = 0;\n            const B = re(b, 0);\n            let O = 0, L = 0;\n            for (; O < g; ) {\n              O++, R += B;\n              let V = a.length === L + 1 ? 1 / 0 : a[L + 1] - a[L] - 1;\n              O + V > g && (R -= B, V = g - O + 1), O += V, R += d(V), L++;\n            }\n            return R;\n          }\n        })\n      ),\n      (g) => {\n        W(t, g), requestAnimationFrame(() => {\n          W(e, { top: g }), requestAnimationFrame(() => {\n            W(t, 0), W(w, !1);\n          });\n        });\n      }\n    ), { deviation: t };\n  },\n  X(at, ae, Gt, Et, Vt, Ne)\n), Zo = U(\n  ([\n    t,\n    e,\n    n,\n    o,\n    r,\n    s,\n    i,\n    l,\n    c,\n    u\n  ]) => ({\n    ...t,\n    ...e,\n    ...n,\n    ...o,\n    ...r,\n    ...s,\n    ...i,\n    ...l,\n    ...c,\n    ...u\n  }),\n  X(\n    Ke,\n    Go,\n    Pt,\n    Kn,\n    Un,\n    No,\n    Mo,\n    je,\n    $o,\n    Vt\n  )\n), qn = U(\n  ([\n    {\n      data: t,\n      defaultItemSize: e,\n      firstItemIndex: n,\n      fixedItemSize: o,\n      gap: r,\n      groupIndices: s,\n      itemSize: i,\n      sizeRanges: l,\n      sizes: c,\n      statefulTotalCount: u,\n      totalCount: f,\n      trackItemSizes: S\n    },\n    { initialItemFinalLocationReached: p, initialTopMostItemIndex: m, scrolledToInitialItem: w },\n    I,\n    C,\n    g,\n    { listState: a, topItemsIndexes: T, ...b },\n    { scrollToIndex: h },\n    d,\n    { topItemCount: R },\n    { groupCounts: B },\n    O\n  ]) => (F(b.rangeChanged, O.scrollSeekRangeChanged), F(\n    x(\n      O.windowViewportRect,\n      E((L) => L.visibleHeight)\n    ),\n    I.viewportHeight\n  ), {\n    data: t,\n    defaultItemHeight: e,\n    firstItemIndex: n,\n    fixedItemHeight: o,\n    gap: r,\n    groupCounts: B,\n    initialItemFinalLocationReached: p,\n    initialTopMostItemIndex: m,\n    scrolledToInitialItem: w,\n    sizeRanges: l,\n    topItemCount: R,\n    topItemsIndexes: T,\n    // input\n    totalCount: f,\n    ...g,\n    groupIndices: s,\n    itemSize: i,\n    listState: a,\n    scrollToIndex: h,\n    // output\n    statefulTotalCount: u,\n    trackItemSizes: S,\n    // exported from stateFlagsSystem\n    ...b,\n    // the bag of IO from featureGroup1System\n    ...O,\n    ...I,\n    sizes: c,\n    ...C\n  }),\n  X(\n    Et,\n    ue,\n    at,\n    Uo,\n    _o,\n    Gt,\n    ce,\n    Yo,\n    jo,\n    Gn,\n    Zo\n  )\n);\nfunction Xo(t, e) {\n  const n = {}, o = {};\n  let r = 0;\n  const s = t.length;\n  for (; r < s; )\n    o[t[r]] = 1, r += 1;\n  for (const i in e)\n    Object.hasOwn(o, i) || (n[i] = e[i]);\n  return n;\n}\nconst pe = typeof document < \"u\" ? react__WEBPACK_IMPORTED_MODULE_1__.useLayoutEffect : react__WEBPACK_IMPORTED_MODULE_1__.useEffect;\nfunction qe(t, e, n) {\n  const o = Object.keys(e.required || {}), r = Object.keys(e.optional || {}), s = Object.keys(e.methods || {}), i = Object.keys(e.events || {}), l = react__WEBPACK_IMPORTED_MODULE_1__.createContext({});\n  function c(g, a) {\n    g.propsReady && W(g.propsReady, !1);\n    for (const T of o) {\n      const b = g[e.required[T]];\n      W(b, a[T]);\n    }\n    for (const T of r)\n      if (T in a) {\n        const b = g[e.optional[T]];\n        W(b, a[T]);\n      }\n    g.propsReady && W(g.propsReady, !0);\n  }\n  function u(g) {\n    return s.reduce((a, T) => (a[T] = (b) => {\n      const h = g[e.methods[T]];\n      W(h, b);\n    }, a), {});\n  }\n  function f(g) {\n    return i.reduce((a, T) => (a[T] = mo(g[e.events[T]]), a), {});\n  }\n  const S = react__WEBPACK_IMPORTED_MODULE_1__.forwardRef((g, a) => {\n    const { children: T, ...b } = g, [h] = react__WEBPACK_IMPORTED_MODULE_1__.useState(() => ye(ho(t), (B) => {\n      c(B, b);\n    })), [d] = react__WEBPACK_IMPORTED_MODULE_1__.useState(cn(f, h));\n    pe(() => {\n      for (const B of i)\n        B in b && K(d[B], b[B]);\n      return () => {\n        Object.values(d).map(We);\n      };\n    }, [b, d, h]), pe(() => {\n      c(h, b);\n    }), react__WEBPACK_IMPORTED_MODULE_1__.useImperativeHandle(a, ln(u(h)));\n    const R = n;\n    return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(l.Provider, { value: h, children: n ? /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(R, { ...Xo([...o, ...r, ...i], b), children: T }) : T });\n  }), p = (g) => react__WEBPACK_IMPORTED_MODULE_1__.useCallback(kn(W, react__WEBPACK_IMPORTED_MODULE_1__.useContext(l)[g]), [g]), m = (g) => {\n    const T = react__WEBPACK_IMPORTED_MODULE_1__.useContext(l)[g], b = react__WEBPACK_IMPORTED_MODULE_1__.useCallback(\n      (h) => K(T, h),\n      [T]\n    );\n    return react__WEBPACK_IMPORTED_MODULE_1__.useSyncExternalStore(\n      b,\n      () => lt(T),\n      () => lt(T)\n    );\n  }, w = (g) => {\n    const T = react__WEBPACK_IMPORTED_MODULE_1__.useContext(l)[g], [b, h] = react__WEBPACK_IMPORTED_MODULE_1__.useState(cn(lt, T));\n    return pe(\n      () => K(T, (d) => {\n        d !== b && h(ln(d));\n      }),\n      [T, b]\n    ), b;\n  }, I = react__WEBPACK_IMPORTED_MODULE_1__.version.startsWith(\"18\") ? m : w;\n  return {\n    Component: S,\n    useEmitter: (g, a) => {\n      const b = react__WEBPACK_IMPORTED_MODULE_1__.useContext(l)[g];\n      pe(() => K(b, a), [a, b]);\n    },\n    useEmitterValue: I,\n    usePublisher: p\n  };\n}\nconst Re = react__WEBPACK_IMPORTED_MODULE_1__.createContext(void 0), Yn = react__WEBPACK_IMPORTED_MODULE_1__.createContext(void 0), Zn = typeof document < \"u\" ? react__WEBPACK_IMPORTED_MODULE_1__.useLayoutEffect : react__WEBPACK_IMPORTED_MODULE_1__.useEffect;\nfunction Be(t) {\n  return \"self\" in t;\n}\nfunction Jo(t) {\n  return \"body\" in t;\n}\nfunction Xn(t, e, n, o = Yt, r, s) {\n  const i = react__WEBPACK_IMPORTED_MODULE_1__.useRef(null), l = react__WEBPACK_IMPORTED_MODULE_1__.useRef(null), c = react__WEBPACK_IMPORTED_MODULE_1__.useRef(null), u = react__WEBPACK_IMPORTED_MODULE_1__.useCallback(\n    (p) => {\n      let m, w, I;\n      const C = p.target;\n      if (Jo(C) || Be(C)) {\n        const a = Be(C) ? C : C.defaultView;\n        I = s ? a.scrollX : a.scrollY, m = s ? a.document.documentElement.scrollWidth : a.document.documentElement.scrollHeight, w = s ? a.innerWidth : a.innerHeight;\n      } else\n        I = s ? C.scrollLeft : C.scrollTop, m = s ? C.scrollWidth : C.scrollHeight, w = s ? C.offsetWidth : C.offsetHeight;\n      const g = () => {\n        t({\n          scrollHeight: m,\n          scrollTop: Math.max(I, 0),\n          viewportHeight: w\n        });\n      };\n      p.suppressFlushSync ? g() : react_dom__WEBPACK_IMPORTED_MODULE_2__.flushSync(g), l.current !== null && (I === l.current || I <= 0 || I === m - w) && (l.current = null, e(!0), c.current && (clearTimeout(c.current), c.current = null));\n    },\n    [t, e]\n  );\n  react__WEBPACK_IMPORTED_MODULE_1__.useEffect(() => {\n    const p = r || i.current;\n    return o(r || i.current), u({ suppressFlushSync: !0, target: p }), p.addEventListener(\"scroll\", u, { passive: !0 }), () => {\n      o(null), p.removeEventListener(\"scroll\", u);\n    };\n  }, [i, u, n, o, r]);\n  function f(p) {\n    const m = i.current;\n    if (!m || (s ? \"offsetWidth\" in m && m.offsetWidth === 0 : \"offsetHeight\" in m && m.offsetHeight === 0))\n      return;\n    const w = p.behavior === \"smooth\";\n    let I, C, g;\n    Be(m) ? (C = Math.max(\n      wt(m.document.documentElement, s ? \"width\" : \"height\"),\n      s ? m.document.documentElement.scrollWidth : m.document.documentElement.scrollHeight\n    ), I = s ? m.innerWidth : m.innerHeight, g = s ? window.scrollX : window.scrollY) : (C = m[s ? \"scrollWidth\" : \"scrollHeight\"], I = wt(m, s ? \"width\" : \"height\"), g = m[s ? \"scrollLeft\" : \"scrollTop\"]);\n    const a = C - I;\n    if (p.top = Math.ceil(Math.max(Math.min(a, p.top), 0)), Dn(I, C) || p.top === g) {\n      t({ scrollHeight: C, scrollTop: g, viewportHeight: I }), w && e(!0);\n      return;\n    }\n    w ? (l.current = p.top, c.current && clearTimeout(c.current), c.current = setTimeout(() => {\n      c.current = null, l.current = null, e(!0);\n    }, 1e3)) : l.current = null, s && (p = { behavior: p.behavior, left: p.top }), m.scrollTo(p);\n  }\n  function S(p) {\n    s && (p = { behavior: p.behavior, left: p.top }), i.current.scrollBy(p);\n  }\n  return { scrollByCallback: S, scrollerRef: i, scrollToCallback: f };\n}\nconst Oe = \"-webkit-sticky\", xn = \"sticky\", Jn = jn(() => {\n  if (typeof document > \"u\")\n    return xn;\n  const t = document.createElement(\"div\");\n  return t.style.position = Oe, t.style.position === Oe ? Oe : xn;\n});\nfunction Ye(t) {\n  return t;\n}\nconst Qo = /* @__PURE__ */ U(() => {\n  const t = y((c) => `Item ${c}`), e = y(null), n = y((c) => `Group ${c}`), o = y({}), r = y(Ye), s = y(\"div\"), i = y(Yt), l = (c, u = null) => ct(\n    x(\n      o,\n      E((f) => f[c]),\n      Y()\n    ),\n    u\n  );\n  return {\n    components: o,\n    computeItemKey: r,\n    context: e,\n    EmptyPlaceholder: l(\"EmptyPlaceholder\"),\n    FooterComponent: l(\"Footer\"),\n    GroupComponent: l(\"Group\", \"div\"),\n    groupContent: n,\n    HeaderComponent: l(\"Header\"),\n    HeaderFooterTag: s,\n    ItemComponent: l(\"Item\", \"div\"),\n    itemContent: t,\n    ListComponent: l(\"List\", \"div\"),\n    ScrollerComponent: l(\"Scroller\", \"div\"),\n    scrollerRef: i,\n    ScrollSeekPlaceholder: l(\"ScrollSeekPlaceholder\"),\n    TopItemListComponent: l(\"TopItemList\")\n  };\n}), tr = /* @__PURE__ */ U(\n  ([t, e]) => ({ ...t, ...e }),\n  X(qn, Qo)\n), er = ({ height: t }) => /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"div\", { style: { height: t } }), nr = { overflowAnchor: \"none\", position: Jn(), zIndex: 1 }, Qn = { overflowAnchor: \"none\" }, or = { ...Qn, display: \"inline-block\", height: \"100%\" }, Tn = /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_1__.memo(function({ showTopList: e = !1 }) {\n  const n = M(\"listState\"), o = gt(\"sizeRanges\"), r = M(\"useWindowScroll\"), s = M(\"customScrollParent\"), i = gt(\"windowScrollContainerState\"), l = gt(\"scrollContainerState\"), c = s || r ? i : l, u = M(\"itemContent\"), f = M(\"context\"), S = M(\"groupContent\"), p = M(\"trackItemSizes\"), m = M(\"itemSize\"), w = M(\"log\"), I = gt(\"gap\"), C = M(\"horizontalDirection\"), { callbackRef: g } = On(\n    o,\n    m,\n    p,\n    e ? Yt : c,\n    w,\n    I,\n    s,\n    C,\n    M(\"skipAnimationFrameInResizeObserver\")\n  ), [a, T] = react__WEBPACK_IMPORTED_MODULE_1__.useState(0);\n  Je(\"deviation\", (k) => {\n    a !== k && T(k);\n  });\n  const b = M(\"EmptyPlaceholder\"), h = M(\"ScrollSeekPlaceholder\") || er, d = M(\"ListComponent\"), R = M(\"ItemComponent\"), B = M(\"GroupComponent\"), O = M(\"computeItemKey\"), L = M(\"isSeeking\"), V = M(\"groupIndices\").length > 0, D = M(\"alignToBottom\"), J = M(\"initialItemFinalLocationReached\"), nt = e ? {} : {\n    boxSizing: \"border-box\",\n    ...C ? {\n      display: \"inline-block\",\n      height: \"100%\",\n      marginLeft: a !== 0 ? a : D ? \"auto\" : 0,\n      paddingLeft: n.offsetTop,\n      paddingRight: n.offsetBottom,\n      whiteSpace: \"nowrap\"\n    } : {\n      marginTop: a !== 0 ? a : D ? \"auto\" : 0,\n      paddingBottom: n.offsetBottom,\n      paddingTop: n.offsetTop\n    },\n    ...J ? {} : { visibility: \"hidden\" }\n  };\n  return !e && n.totalCount === 0 && b ? /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(b, { ...Z(b, f) }) : /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\n    d,\n    {\n      ...Z(d, f),\n      \"data-testid\": e ? \"virtuoso-top-item-list\" : \"virtuoso-item-list\",\n      ref: g,\n      style: nt,\n      children: (e ? n.topItems : n.items).map((k) => {\n        const q = k.originalIndex, st = O(q + n.firstItemIndex, k.data, f);\n        return L ? /* @__PURE__ */ (0,react__WEBPACK_IMPORTED_MODULE_1__.createElement)(\n          h,\n          {\n            ...Z(h, f),\n            height: k.size,\n            index: k.index,\n            key: st,\n            type: k.type || \"item\",\n            ...k.type === \"group\" ? {} : { groupIndex: k.groupIndex }\n          }\n        ) : k.type === \"group\" ? /* @__PURE__ */ (0,react__WEBPACK_IMPORTED_MODULE_1__.createElement)(\n          B,\n          {\n            ...Z(B, f),\n            \"data-index\": q,\n            \"data-item-index\": k.index,\n            \"data-known-size\": k.size,\n            key: st,\n            style: nr\n          },\n          S(k.index, f)\n        ) : /* @__PURE__ */ (0,react__WEBPACK_IMPORTED_MODULE_1__.createElement)(\n          R,\n          {\n            ...Z(R, f),\n            ...to(R, k.data),\n            \"data-index\": q,\n            \"data-item-group-index\": k.groupIndex,\n            \"data-item-index\": k.index,\n            \"data-known-size\": k.size,\n            key: st,\n            style: C ? or : Qn\n          },\n          V ? u(k.index, k.groupIndex, k.data, f) : u(k.index, k.data, f)\n        );\n      })\n    }\n  );\n}), rr = {\n  height: \"100%\",\n  outline: \"none\",\n  overflowY: \"auto\",\n  position: \"relative\",\n  WebkitOverflowScrolling: \"touch\"\n}, sr = {\n  outline: \"none\",\n  overflowX: \"auto\",\n  position: \"relative\"\n}, Zt = (t) => ({\n  height: \"100%\",\n  position: \"absolute\",\n  top: 0,\n  width: \"100%\",\n  ...t ? { display: \"flex\", flexDirection: \"column\" } : {}\n}), ir = {\n  position: Jn(),\n  top: 0,\n  width: \"100%\",\n  zIndex: 1\n};\nfunction Z(t, e) {\n  if (typeof t != \"string\")\n    return { context: e };\n}\nfunction to(t, e) {\n  return { item: typeof t == \"string\" ? void 0 : e };\n}\nconst lr = /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_1__.memo(function() {\n  const e = M(\"HeaderComponent\"), n = gt(\"headerHeight\"), o = M(\"HeaderFooterTag\"), r = Ht(\n    react__WEBPACK_IMPORTED_MODULE_1__.useMemo(\n      () => (i) => {\n        n(wt(i, \"height\"));\n      },\n      [n]\n    ),\n    !0,\n    M(\"skipAnimationFrameInResizeObserver\")\n  ), s = M(\"context\");\n  return e ? /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(o, { ref: r, children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(e, { ...Z(e, s) }) }) : null;\n}), cr = /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_1__.memo(function() {\n  const e = M(\"FooterComponent\"), n = gt(\"footerHeight\"), o = M(\"HeaderFooterTag\"), r = Ht(\n    react__WEBPACK_IMPORTED_MODULE_1__.useMemo(\n      () => (i) => {\n        n(wt(i, \"height\"));\n      },\n      [n]\n    ),\n    !0,\n    M(\"skipAnimationFrameInResizeObserver\")\n  ), s = M(\"context\");\n  return e ? /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(o, { ref: r, children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(e, { ...Z(e, s) }) }) : null;\n});\nfunction Ze({ useEmitter: t, useEmitterValue: e, usePublisher: n }) {\n  return react__WEBPACK_IMPORTED_MODULE_1__.memo(function({ children: s, style: i, ...l }) {\n    const c = n(\"scrollContainerState\"), u = e(\"ScrollerComponent\"), f = n(\"smoothScrollTargetReached\"), S = e(\"scrollerRef\"), p = e(\"context\"), m = e(\"horizontalDirection\") || !1, { scrollByCallback: w, scrollerRef: I, scrollToCallback: C } = Xn(\n      c,\n      f,\n      u,\n      S,\n      void 0,\n      m\n    );\n    return t(\"scrollTo\", C), t(\"scrollBy\", w), /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\n      u,\n      {\n        \"data-testid\": \"virtuoso-scroller\",\n        \"data-virtuoso-scroller\": !0,\n        ref: I,\n        style: { ...m ? sr : rr, ...i },\n        tabIndex: 0,\n        ...l,\n        ...Z(u, p),\n        children: s\n      }\n    );\n  });\n}\nfunction Xe({ useEmitter: t, useEmitterValue: e, usePublisher: n }) {\n  return react__WEBPACK_IMPORTED_MODULE_1__.memo(function({ children: s, style: i, ...l }) {\n    const c = n(\"windowScrollContainerState\"), u = e(\"ScrollerComponent\"), f = n(\"smoothScrollTargetReached\"), S = e(\"totalListHeight\"), p = e(\"deviation\"), m = e(\"customScrollParent\"), w = e(\"context\"), I = react__WEBPACK_IMPORTED_MODULE_1__.useRef(null), C = e(\"scrollerRef\"), { scrollByCallback: g, scrollerRef: a, scrollToCallback: T } = Xn(\n      c,\n      f,\n      u,\n      C,\n      m\n    );\n    return Zn(() => {\n      var b;\n      return a.current = m || ((b = I.current) == null ? void 0 : b.ownerDocument.defaultView), () => {\n        a.current = null;\n      };\n    }, [a, m]), t(\"windowScrollTo\", T), t(\"scrollBy\", g), /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\n      u,\n      {\n        ref: I,\n        \"data-virtuoso-scroller\": !0,\n        style: { position: \"relative\", ...i, ...S !== 0 ? { height: S + p } : {} },\n        ...l,\n        ...Z(u, w),\n        children: s\n      }\n    );\n  });\n}\nconst ur = ({ children: t }) => {\n  const e = react__WEBPACK_IMPORTED_MODULE_1__.useContext(Re), n = gt(\"viewportHeight\"), o = gt(\"fixedItemHeight\"), r = M(\"alignToBottom\"), s = M(\"horizontalDirection\"), i = react__WEBPACK_IMPORTED_MODULE_1__.useMemo(\n    () => ne(n, (c) => wt(c, s ? \"width\" : \"height\")),\n    [n, s]\n  ), l = Ht(i, !0, M(\"skipAnimationFrameInResizeObserver\"));\n  return react__WEBPACK_IMPORTED_MODULE_1__.useEffect(() => {\n    e && (n(e.viewportHeight), o(e.itemHeight));\n  }, [e, n, o]), /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"div\", { \"data-viewport-type\": \"element\", ref: l, style: Zt(r), children: t });\n}, ar = ({ children: t }) => {\n  const e = react__WEBPACK_IMPORTED_MODULE_1__.useContext(Re), n = gt(\"windowViewportRect\"), o = gt(\"fixedItemHeight\"), r = M(\"customScrollParent\"), s = Ge(\n    n,\n    r,\n    M(\"skipAnimationFrameInResizeObserver\")\n  ), i = M(\"alignToBottom\");\n  return react__WEBPACK_IMPORTED_MODULE_1__.useEffect(() => {\n    e && (o(e.itemHeight), n({ offsetTop: 0, visibleHeight: e.viewportHeight, visibleWidth: 100 }));\n  }, [e, n, o]), /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"div\", { \"data-viewport-type\": \"window\", ref: s, style: Zt(i), children: t });\n}, dr = ({ children: t }) => {\n  const e = M(\"TopItemListComponent\") || \"div\", n = M(\"headerHeight\"), o = { ...ir, marginTop: `${n}px` }, r = M(\"context\");\n  return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(e, { style: o, ...Z(e, r), children: t });\n}, fr = /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_1__.memo(function(e) {\n  const n = M(\"useWindowScroll\"), o = M(\"topItemsIndexes\").length > 0, r = M(\"customScrollParent\"), s = M(\"context\"), i = r || n ? pr : mr, l = r || n ? ar : ur;\n  return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(i, { ...e, ...Z(i, s), children: [\n    o && /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(dr, { children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(Tn, { showTopList: !0 }) }),\n    /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(l, { children: [\n      /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(lr, {}),\n      /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(Tn, {}),\n      /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(cr, {})\n    ] })\n  ] });\n}), {\n  Component: eo,\n  useEmitter: Je,\n  useEmitterValue: M,\n  usePublisher: gt\n} = /* @__PURE__ */ qe(\n  tr,\n  {\n    events: {\n      atBottomStateChange: \"atBottomStateChange\",\n      atTopStateChange: \"atTopStateChange\",\n      endReached: \"endReached\",\n      groupIndices: \"groupIndices\",\n      isScrolling: \"isScrolling\",\n      itemsRendered: \"itemsRendered\",\n      rangeChanged: \"rangeChanged\",\n      startReached: \"startReached\",\n      totalListHeightChanged: \"totalListHeightChanged\"\n    },\n    methods: {\n      autoscrollToBottom: \"autoscrollToBottom\",\n      getState: \"getState\",\n      scrollBy: \"scrollBy\",\n      scrollIntoView: \"scrollIntoView\",\n      scrollTo: \"scrollTo\",\n      scrollToIndex: \"scrollToIndex\"\n    },\n    optional: {\n      alignToBottom: \"alignToBottom\",\n      atBottomThreshold: \"atBottomThreshold\",\n      atTopThreshold: \"atTopThreshold\",\n      components: \"components\",\n      computeItemKey: \"computeItemKey\",\n      context: \"context\",\n      customScrollParent: \"customScrollParent\",\n      data: \"data\",\n      defaultItemHeight: \"defaultItemHeight\",\n      firstItemIndex: \"firstItemIndex\",\n      fixedItemHeight: \"fixedItemHeight\",\n      followOutput: \"followOutput\",\n      groupContent: \"groupContent\",\n      groupCounts: \"groupCounts\",\n      headerFooterTag: \"HeaderFooterTag\",\n      horizontalDirection: \"horizontalDirection\",\n      increaseViewportBy: \"increaseViewportBy\",\n      initialItemCount: \"initialItemCount\",\n      initialScrollTop: \"initialScrollTop\",\n      initialTopMostItemIndex: \"initialTopMostItemIndex\",\n      itemContent: \"itemContent\",\n      itemSize: \"itemSize\",\n      logLevel: \"logLevel\",\n      overscan: \"overscan\",\n      restoreStateFrom: \"restoreStateFrom\",\n      scrollerRef: \"scrollerRef\",\n      scrollSeekConfiguration: \"scrollSeekConfiguration\",\n      skipAnimationFrameInResizeObserver: \"skipAnimationFrameInResizeObserver\",\n      topItemCount: \"topItemCount\",\n      totalCount: \"totalCount\",\n      useWindowScroll: \"useWindowScroll\"\n    },\n    required: {}\n  },\n  fr\n), mr = /* @__PURE__ */ Ze({ useEmitter: Je, useEmitterValue: M, usePublisher: gt }), pr = /* @__PURE__ */ Xe({ useEmitter: Je, useEmitterValue: M, usePublisher: gt }), Kr = eo, jr = eo, hr = /* @__PURE__ */ U(() => {\n  const t = y((c) => /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(\"td\", { children: [\n    \"Item $\",\n    c\n  ] })), e = y(null), n = y(null), o = y(null), r = y({}), s = y(Ye), i = y(Yt), l = (c, u = null) => ct(\n    x(\n      r,\n      E((f) => f[c]),\n      Y()\n    ),\n    u\n  );\n  return {\n    components: r,\n    computeItemKey: s,\n    context: e,\n    EmptyPlaceholder: l(\"EmptyPlaceholder\"),\n    FillerRow: l(\"FillerRow\"),\n    fixedFooterContent: o,\n    fixedHeaderContent: n,\n    itemContent: t,\n    ScrollerComponent: l(\"Scroller\", \"div\"),\n    scrollerRef: i,\n    ScrollSeekPlaceholder: l(\"ScrollSeekPlaceholder\"),\n    TableBodyComponent: l(\"TableBody\", \"tbody\"),\n    TableComponent: l(\"Table\", \"table\"),\n    TableFooterComponent: l(\"TableFoot\", \"tfoot\"),\n    TableHeadComponent: l(\"TableHead\", \"thead\"),\n    TableRowComponent: l(\"TableRow\", \"tr\")\n  };\n}), gr = /* @__PURE__ */ U(\n  ([t, e]) => ({ ...t, ...e }),\n  X(qn, hr)\n), Ir = ({ height: t }) => /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"tr\", { children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"td\", { style: { height: t } }) }), Sr = ({ height: t }) => /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"tr\", { children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"td\", { style: { border: 0, height: t, padding: 0 } }) }), xr = { overflowAnchor: \"none\" }, Cn = /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_1__.memo(function({ showTopList: e = !1 }) {\n  const n = _(\"listState\"), o = _(\"computeItemKey\"), r = _(\"firstItemIndex\"), s = _(\"isSeeking\"), i = _(\"ScrollSeekPlaceholder\") || Ir, l = _(\"context\"), c = _(\"TableRowComponent\"), u = _(\"fixedHeaderHeight\"), f = _(\"itemContent\"), S = (e ? n.topItems : []).reduce((m, w, I) => (I === 0 ? m.push(w.size) : m.push(m[I - 1] + w.size), m), []), p = (e ? n.topItems : n.items).map((m) => {\n    const w = m.originalIndex, I = o(w + r, m.data, l), C = e ? w === 0 ? 0 : S[w - 1] : 0;\n    return s ? /* @__PURE__ */ (0,react__WEBPACK_IMPORTED_MODULE_1__.createElement)(\n      i,\n      {\n        ...Z(i, l),\n        height: m.size,\n        index: m.index,\n        key: I,\n        type: m.type || \"item\"\n      }\n    ) : /* @__PURE__ */ (0,react__WEBPACK_IMPORTED_MODULE_1__.createElement)(\n      c,\n      {\n        ...Z(c, l),\n        ...to(c, m.data),\n        \"data-index\": w,\n        \"data-item-index\": m.index,\n        \"data-known-size\": m.size,\n        key: I,\n        style: e ? { overflowAnchor: \"none\", position: \"sticky\", top: u + C, zIndex: 2 } : xr\n      },\n      f(m.index, m.data, l)\n    );\n  });\n  return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.Fragment, { children: p });\n}), Tr = /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_1__.memo(function() {\n  const e = _(\"listState\"), n = _(\"topItemsIndexes\").length > 0, o = Tt(\"sizeRanges\"), r = _(\"useWindowScroll\"), s = _(\"customScrollParent\"), i = Tt(\"windowScrollContainerState\"), l = Tt(\"scrollContainerState\"), c = s || r ? i : l, u = _(\"trackItemSizes\"), f = _(\"itemSize\"), S = _(\"log\"), { callbackRef: p, ref: m } = On(\n    o,\n    f,\n    u,\n    c,\n    S,\n    void 0,\n    s,\n    !1,\n    _(\"skipAnimationFrameInResizeObserver\")\n  ), [w, I] = react__WEBPACK_IMPORTED_MODULE_1__.useState(0);\n  Qe(\"deviation\", (V) => {\n    w !== V && (m.current.style.marginTop = `${V}px`, I(V));\n  });\n  const C = _(\"EmptyPlaceholder\"), g = _(\"FillerRow\") || Sr, a = _(\"TableBodyComponent\"), T = _(\"paddingTopAddition\"), b = _(\"statefulTotalCount\"), h = _(\"context\");\n  if (b === 0 && C)\n    return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(C, { ...Z(C, h) });\n  const d = (n ? e.topItems : []).reduce((V, D) => V + D.size, 0), R = e.offsetTop + T + w - d, B = e.offsetBottom, O = R > 0 ? /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(g, { context: h, height: R }, \"padding-top\") : null, L = B > 0 ? /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(g, { context: h, height: B }, \"padding-bottom\") : null;\n  return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(a, { \"data-testid\": \"virtuoso-item-list\", ref: p, ...Z(a, h), children: [\n    O,\n    n && /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(Cn, { showTopList: !0 }),\n    /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(Cn, {}),\n    L\n  ] });\n}), Cr = ({ children: t }) => {\n  const e = react__WEBPACK_IMPORTED_MODULE_1__.useContext(Re), n = Tt(\"viewportHeight\"), o = Tt(\"fixedItemHeight\"), r = Ht(\n    react__WEBPACK_IMPORTED_MODULE_1__.useMemo(() => ne(n, (s) => wt(s, \"height\")), [n]),\n    !0,\n    _(\"skipAnimationFrameInResizeObserver\")\n  );\n  return react__WEBPACK_IMPORTED_MODULE_1__.useEffect(() => {\n    e && (n(e.viewportHeight), o(e.itemHeight));\n  }, [e, n, o]), /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"div\", { \"data-viewport-type\": \"element\", ref: r, style: Zt(!1), children: t });\n}, wr = ({ children: t }) => {\n  const e = react__WEBPACK_IMPORTED_MODULE_1__.useContext(Re), n = Tt(\"windowViewportRect\"), o = Tt(\"fixedItemHeight\"), r = _(\"customScrollParent\"), s = Ge(\n    n,\n    r,\n    _(\"skipAnimationFrameInResizeObserver\")\n  );\n  return react__WEBPACK_IMPORTED_MODULE_1__.useEffect(() => {\n    e && (o(e.itemHeight), n({ offsetTop: 0, visibleHeight: e.viewportHeight, visibleWidth: 100 }));\n  }, [e, n, o]), /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"div\", { \"data-viewport-type\": \"window\", ref: s, style: Zt(!1), children: t });\n}, yr = /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_1__.memo(function(e) {\n  const n = _(\"useWindowScroll\"), o = _(\"customScrollParent\"), r = Tt(\"fixedHeaderHeight\"), s = Tt(\"fixedFooterHeight\"), i = _(\"fixedHeaderContent\"), l = _(\"fixedFooterContent\"), c = _(\"context\"), u = Ht(\n    react__WEBPACK_IMPORTED_MODULE_1__.useMemo(() => ne(r, (a) => wt(a, \"height\")), [r]),\n    !0,\n    _(\"skipAnimationFrameInResizeObserver\")\n  ), f = Ht(\n    react__WEBPACK_IMPORTED_MODULE_1__.useMemo(() => ne(s, (a) => wt(a, \"height\")), [s]),\n    !0,\n    _(\"skipAnimationFrameInResizeObserver\")\n  ), S = o || n ? Rr : br, p = o || n ? wr : Cr, m = _(\"TableComponent\"), w = _(\"TableHeadComponent\"), I = _(\"TableFooterComponent\"), C = i ? /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\n    w,\n    {\n      ref: u,\n      style: { position: \"sticky\", top: 0, zIndex: 2 },\n      ...Z(w, c),\n      children: i()\n    },\n    \"TableHead\"\n  ) : null, g = l ? /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\n    I,\n    {\n      ref: f,\n      style: { bottom: 0, position: \"sticky\", zIndex: 1 },\n      ...Z(I, c),\n      children: l()\n    },\n    \"TableFoot\"\n  ) : null;\n  return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(S, { ...e, ...Z(S, c), children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(p, { children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(m, { style: { borderSpacing: 0, overflowAnchor: \"none\" }, ...Z(m, c), children: [\n    C,\n    /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(Tr, {}, \"TableBody\"),\n    g\n  ] }) }) });\n}), {\n  Component: vr,\n  useEmitter: Qe,\n  useEmitterValue: _,\n  usePublisher: Tt\n} = /* @__PURE__ */ qe(\n  gr,\n  {\n    events: {\n      atBottomStateChange: \"atBottomStateChange\",\n      atTopStateChange: \"atTopStateChange\",\n      endReached: \"endReached\",\n      groupIndices: \"groupIndices\",\n      isScrolling: \"isScrolling\",\n      itemsRendered: \"itemsRendered\",\n      rangeChanged: \"rangeChanged\",\n      startReached: \"startReached\",\n      totalListHeightChanged: \"totalListHeightChanged\"\n    },\n    methods: {\n      getState: \"getState\",\n      scrollBy: \"scrollBy\",\n      scrollIntoView: \"scrollIntoView\",\n      scrollTo: \"scrollTo\",\n      scrollToIndex: \"scrollToIndex\"\n    },\n    optional: {\n      alignToBottom: \"alignToBottom\",\n      atBottomThreshold: \"atBottomThreshold\",\n      atTopThreshold: \"atTopThreshold\",\n      components: \"components\",\n      computeItemKey: \"computeItemKey\",\n      context: \"context\",\n      customScrollParent: \"customScrollParent\",\n      data: \"data\",\n      defaultItemHeight: \"defaultItemHeight\",\n      firstItemIndex: \"firstItemIndex\",\n      fixedFooterContent: \"fixedFooterContent\",\n      fixedHeaderContent: \"fixedHeaderContent\",\n      fixedItemHeight: \"fixedItemHeight\",\n      followOutput: \"followOutput\",\n      groupCounts: \"groupCounts\",\n      increaseViewportBy: \"increaseViewportBy\",\n      initialItemCount: \"initialItemCount\",\n      initialScrollTop: \"initialScrollTop\",\n      initialTopMostItemIndex: \"initialTopMostItemIndex\",\n      itemContent: \"itemContent\",\n      itemSize: \"itemSize\",\n      logLevel: \"logLevel\",\n      overscan: \"overscan\",\n      restoreStateFrom: \"restoreStateFrom\",\n      scrollerRef: \"scrollerRef\",\n      scrollSeekConfiguration: \"scrollSeekConfiguration\",\n      topItemCount: \"topItemCount\",\n      totalCount: \"totalCount\",\n      useWindowScroll: \"useWindowScroll\"\n    },\n    required: {}\n  },\n  yr\n), br = /* @__PURE__ */ Ze({ useEmitter: Qe, useEmitterValue: _, usePublisher: Tt }), Rr = /* @__PURE__ */ Xe({ useEmitter: Qe, useEmitterValue: _, usePublisher: Tt }), qr = vr, wn = {\n  bottom: 0,\n  itemHeight: 0,\n  items: [],\n  itemWidth: 0,\n  offsetBottom: 0,\n  offsetTop: 0,\n  top: 0\n}, Hr = {\n  bottom: 0,\n  itemHeight: 0,\n  items: [{ index: 0 }],\n  itemWidth: 0,\n  offsetBottom: 0,\n  offsetTop: 0,\n  top: 0\n}, { ceil: yn, floor: Ce, max: ee, min: Fe, round: vn } = Math;\nfunction bn(t, e, n) {\n  return Array.from({ length: e - t + 1 }).map((o, r) => ({ data: n === null ? null : n[r + t], index: r + t }));\n}\nfunction Er(t) {\n  return {\n    ...Hr,\n    items: t\n  };\n}\nfunction he(t, e) {\n  return t && t.width === e.width && t.height === e.height;\n}\nfunction kr(t, e) {\n  return t && t.column === e.column && t.row === e.row;\n}\nconst Br = /* @__PURE__ */ U(\n  ([\n    { increaseViewportBy: t, listBoundary: e, overscan: n, visibleRange: o },\n    { footerHeight: r, headerHeight: s, scrollBy: i, scrollContainerState: l, scrollTo: c, scrollTop: u, smoothScrollTargetReached: f, viewportHeight: S },\n    p,\n    m,\n    { didMount: w, propsReady: I },\n    { customScrollParent: C, useWindowScroll: g, windowScrollContainerState: a, windowScrollTo: T, windowViewportRect: b },\n    h\n  ]) => {\n    const d = y(0), R = y(0), B = y(wn), O = y({ height: 0, width: 0 }), L = y({ height: 0, width: 0 }), V = $(), D = $(), J = y(0), nt = y(null), k = y({ column: 0, row: 0 }), q = $(), st = $(), dt = y(!1), St = y(0), ft = y(!0), ut = y(!1), At = y(!1);\n    K(\n      x(\n        w,\n        G(St),\n        P(([v, N]) => !!N)\n      ),\n      () => {\n        W(ft, !1);\n      }\n    ), K(\n      x(\n        rt(w, ft, L, O, St, ut),\n        P(([v, N, Q, it, , tt]) => v && !N && Q.height !== 0 && it.height !== 0 && !tt)\n      ),\n      ([, , , , v]) => {\n        W(ut, !0), $e(1, () => {\n          W(V, v);\n        }), Rt(x(u), () => {\n          W(e, [0, 0]), W(ft, !0);\n        });\n      }\n    ), F(\n      x(\n        st,\n        P((v) => v != null && v.scrollTop > 0),\n        vt(0)\n      ),\n      R\n    ), K(\n      x(\n        w,\n        G(st),\n        P(([, v]) => v != null)\n      ),\n      ([, v]) => {\n        v && (W(O, v.viewport), W(L, v.item), W(k, v.gap), v.scrollTop > 0 && (W(dt, !0), Rt(x(u, jt(1)), (N) => {\n          W(dt, !1);\n        }), W(c, { top: v.scrollTop })));\n      }\n    ), F(\n      x(\n        O,\n        E(({ height: v }) => v)\n      ),\n      S\n    ), F(\n      x(\n        rt(\n          A(O, he),\n          A(L, he),\n          A(k, (v, N) => v && v.column === N.column && v.row === N.row),\n          A(u)\n        ),\n        E(([v, N, Q, it]) => ({\n          gap: Q,\n          item: N,\n          scrollTop: it,\n          viewport: v\n        }))\n      ),\n      q\n    ), F(\n      x(\n        rt(\n          A(d),\n          o,\n          A(k, kr),\n          A(L, he),\n          A(O, he),\n          A(nt),\n          A(R),\n          A(dt),\n          A(ft),\n          A(St)\n        ),\n        P(([, , , , , , , v]) => !v),\n        E(\n          ([\n            v,\n            [N, Q],\n            it,\n            tt,\n            Bt,\n            Jt,\n            Nt,\n            ,\n            de,\n            Ot\n          ]) => {\n            const { column: Ft, row: Qt } = it, { height: fe, width: He } = tt, { width: tn } = Bt;\n            if (Nt === 0 && (v === 0 || tn === 0))\n              return wn;\n            if (He === 0) {\n              const sn = Ue(Ot, v), so = sn + Math.max(Nt - 1, 0);\n              return Er(bn(sn, so, Jt));\n            }\n            const me = no(tn, He, Ft);\n            let Dt, Wt;\n            de ? N === 0 && Q === 0 && Nt > 0 ? (Dt = 0, Wt = Nt - 1) : (Dt = me * Ce((N + Qt) / (fe + Qt)), Wt = me * yn((Q + Qt) / (fe + Qt)) - 1, Wt = Fe(v - 1, ee(Wt, me - 1)), Dt = Fe(Wt, ee(0, Dt))) : (Dt = 0, Wt = -1);\n            const en = bn(Dt, Wt, Jt), { bottom: nn, top: on } = Rn(Bt, it, tt, en), rn = yn(v / me), ro = rn * fe + (rn - 1) * Qt - nn;\n            return { bottom: nn, itemHeight: fe, items: en, itemWidth: He, offsetBottom: ro, offsetTop: on, top: on };\n          }\n        )\n      ),\n      B\n    ), F(\n      x(\n        nt,\n        P((v) => v !== null),\n        E((v) => v.length)\n      ),\n      d\n    ), F(\n      x(\n        rt(O, L, B, k),\n        P(([v, N, { items: Q }]) => Q.length > 0 && N.height !== 0 && v.height !== 0),\n        E(([v, N, { items: Q }, it]) => {\n          const { bottom: tt, top: Bt } = Rn(v, it, N, Q);\n          return [Bt, tt];\n        }),\n        Y(se)\n      ),\n      e\n    );\n    const xt = y(!1);\n    F(\n      x(\n        u,\n        G(xt),\n        E(([v, N]) => N || v !== 0)\n      ),\n      xt\n    );\n    const Xt = pt(\n      x(\n        rt(B, d),\n        P(([{ items: v }]) => v.length > 0),\n        G(xt),\n        P(([[v, N], Q]) => {\n          const tt = v.items[v.items.length - 1].index === N - 1;\n          return (Q || v.bottom > 0 && v.itemHeight > 0 && v.offsetBottom === 0 && v.items.length === N) && tt;\n        }),\n        E(([[, v]]) => v - 1),\n        Y()\n      )\n    ), Mt = pt(\n      x(\n        A(B),\n        P(({ items: v }) => v.length > 0 && v[0].index === 0),\n        vt(0),\n        Y()\n      )\n    ), yt = pt(\n      x(\n        A(B),\n        G(dt),\n        P(([{ items: v }, N]) => v.length > 0 && !N),\n        E(([{ items: v }]) => ({\n          endIndex: v[v.length - 1].index,\n          startIndex: v[0].index\n        })),\n        Y(An),\n        Lt(0)\n      )\n    );\n    F(yt, m.scrollSeekRangeChanged), F(\n      x(\n        V,\n        G(O, L, d, k),\n        E(([v, N, Q, it, tt]) => {\n          const Bt = Nn(v), { align: Jt, behavior: Nt, offset: de } = Bt;\n          let Ot = Bt.index;\n          Ot === \"LAST\" && (Ot = it - 1), Ot = ee(0, Ot, Fe(it - 1, Ot));\n          let Ft = Ae(N, tt, Q, Ot);\n          return Jt === \"end\" ? Ft = vn(Ft - N.height + Q.height) : Jt === \"center\" && (Ft = vn(Ft - N.height / 2 + Q.height / 2)), de && (Ft += de), { behavior: Nt, top: Ft };\n        })\n      ),\n      c\n    );\n    const kt = ct(\n      x(\n        B,\n        E((v) => v.offsetBottom + v.bottom)\n      ),\n      0\n    );\n    return F(\n      x(\n        b,\n        E((v) => ({ height: v.visibleHeight, width: v.visibleWidth }))\n      ),\n      O\n    ), {\n      customScrollParent: C,\n      // input\n      data: nt,\n      deviation: J,\n      footerHeight: r,\n      gap: k,\n      headerHeight: s,\n      increaseViewportBy: t,\n      initialItemCount: R,\n      itemDimensions: L,\n      overscan: n,\n      restoreStateFrom: st,\n      scrollBy: i,\n      scrollContainerState: l,\n      scrollHeight: D,\n      scrollTo: c,\n      scrollToIndex: V,\n      scrollTop: u,\n      smoothScrollTargetReached: f,\n      totalCount: d,\n      useWindowScroll: g,\n      viewportDimensions: O,\n      windowScrollContainerState: a,\n      windowScrollTo: T,\n      windowViewportRect: b,\n      ...m,\n      // output\n      gridState: B,\n      horizontalDirection: At,\n      initialTopMostItemIndex: St,\n      totalListHeight: kt,\n      ...p,\n      endReached: Xt,\n      propsReady: I,\n      rangeChanged: yt,\n      startReached: Mt,\n      stateChanged: q,\n      stateRestoreInProgress: dt,\n      ...h\n    };\n  },\n  X(Ke, at, ae, Kn, Pt, je, Vt)\n);\nfunction no(t, e, n) {\n  return ee(1, Ce((t + n) / (Ce(e) + n)));\n}\nfunction Rn(t, e, n, o) {\n  const { height: r } = n;\n  if (r === void 0 || o.length === 0)\n    return { bottom: 0, top: 0 };\n  const s = Ae(t, e, n, o[0].index);\n  return { bottom: Ae(t, e, n, o[o.length - 1].index) + r, top: s };\n}\nfunction Ae(t, e, n, o) {\n  const r = no(t.width, n.width, e.column), s = Ce(o / r), i = s * n.height + ee(0, s - 1) * e.row;\n  return i > 0 ? i + e.row : i;\n}\nconst Or = /* @__PURE__ */ U(() => {\n  const t = y((S) => `Item ${S}`), e = y({}), n = y(null), o = y(\"virtuoso-grid-item\"), r = y(\"virtuoso-grid-list\"), s = y(Ye), i = y(\"div\"), l = y(Yt), c = (S, p = null) => ct(\n    x(\n      e,\n      E((m) => m[S]),\n      Y()\n    ),\n    p\n  ), u = y(!1), f = y(!1);\n  return F(A(f), u), {\n    components: e,\n    computeItemKey: s,\n    context: n,\n    FooterComponent: c(\"Footer\"),\n    HeaderComponent: c(\"Header\"),\n    headerFooterTag: i,\n    itemClassName: o,\n    ItemComponent: c(\"Item\", \"div\"),\n    itemContent: t,\n    listClassName: r,\n    ListComponent: c(\"List\", \"div\"),\n    readyStateChanged: u,\n    reportReadyState: f,\n    ScrollerComponent: c(\"Scroller\", \"div\"),\n    scrollerRef: l,\n    ScrollSeekPlaceholder: c(\"ScrollSeekPlaceholder\", \"div\")\n  };\n}), Fr = /* @__PURE__ */ U(\n  ([t, e]) => ({ ...t, ...e }),\n  X(Br, Or)\n), Lr = /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_1__.memo(function() {\n  const e = et(\"gridState\"), n = et(\"listClassName\"), o = et(\"itemClassName\"), r = et(\"itemContent\"), s = et(\"computeItemKey\"), i = et(\"isSeeking\"), l = It(\"scrollHeight\"), c = et(\"ItemComponent\"), u = et(\"ListComponent\"), f = et(\"ScrollSeekPlaceholder\"), S = et(\"context\"), p = It(\"itemDimensions\"), m = It(\"gap\"), w = et(\"log\"), I = et(\"stateRestoreInProgress\"), C = It(\"reportReadyState\"), g = Ht(\n    react__WEBPACK_IMPORTED_MODULE_1__.useMemo(\n      () => (a) => {\n        const T = a.parentElement.parentElement.scrollHeight;\n        l(T);\n        const b = a.firstChild;\n        if (b) {\n          const { height: h, width: d } = b.getBoundingClientRect();\n          p({ height: h, width: d });\n        }\n        m({\n          column: Hn(\"column-gap\", getComputedStyle(a).columnGap, w),\n          row: Hn(\"row-gap\", getComputedStyle(a).rowGap, w)\n        });\n      },\n      [l, p, m, w]\n    ),\n    !0,\n    !1\n  );\n  return Zn(() => {\n    e.itemHeight > 0 && e.itemWidth > 0 && C(!0);\n  }, [e]), I ? null : /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\n    u,\n    {\n      className: n,\n      ref: g,\n      ...Z(u, S),\n      \"data-testid\": \"virtuoso-item-list\",\n      style: { paddingBottom: e.offsetBottom, paddingTop: e.offsetTop },\n      children: e.items.map((a) => {\n        const T = s(a.index, a.data, S);\n        return i ? /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\n          f,\n          {\n            ...Z(f, S),\n            height: e.itemHeight,\n            index: a.index,\n            width: e.itemWidth\n          },\n          T\n        ) : /* @__PURE__ */ (0,react__WEBPACK_IMPORTED_MODULE_1__.createElement)(\n          c,\n          {\n            ...Z(c, S),\n            className: o,\n            \"data-index\": a.index,\n            key: T\n          },\n          r(a.index, a.data, S)\n        );\n      })\n    }\n  );\n}), zr = react__WEBPACK_IMPORTED_MODULE_1__.memo(function() {\n  const e = et(\"HeaderComponent\"), n = It(\"headerHeight\"), o = et(\"headerFooterTag\"), r = Ht(\n    react__WEBPACK_IMPORTED_MODULE_1__.useMemo(\n      () => (i) => {\n        n(wt(i, \"height\"));\n      },\n      [n]\n    ),\n    !0,\n    !1\n  ), s = et(\"context\");\n  return e ? /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(o, { ref: r, children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(e, { ...Z(e, s) }) }) : null;\n}), Vr = react__WEBPACK_IMPORTED_MODULE_1__.memo(function() {\n  const e = et(\"FooterComponent\"), n = It(\"footerHeight\"), o = et(\"headerFooterTag\"), r = Ht(\n    react__WEBPACK_IMPORTED_MODULE_1__.useMemo(\n      () => (i) => {\n        n(wt(i, \"height\"));\n      },\n      [n]\n    ),\n    !0,\n    !1\n  ), s = et(\"context\");\n  return e ? /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(o, { ref: r, children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(e, { ...Z(e, s) }) }) : null;\n}), Pr = ({ children: t }) => {\n  const e = react__WEBPACK_IMPORTED_MODULE_1__.useContext(Yn), n = It(\"itemDimensions\"), o = It(\"viewportDimensions\"), r = Ht(\n    react__WEBPACK_IMPORTED_MODULE_1__.useMemo(\n      () => (s) => {\n        o(s.getBoundingClientRect());\n      },\n      [o]\n    ),\n    !0,\n    !1\n  );\n  return react__WEBPACK_IMPORTED_MODULE_1__.useEffect(() => {\n    e && (o({ height: e.viewportHeight, width: e.viewportWidth }), n({ height: e.itemHeight, width: e.itemWidth }));\n  }, [e, o, n]), /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"div\", { ref: r, style: Zt(!1), children: t });\n}, Ar = ({ children: t }) => {\n  const e = react__WEBPACK_IMPORTED_MODULE_1__.useContext(Yn), n = It(\"windowViewportRect\"), o = It(\"itemDimensions\"), r = et(\"customScrollParent\"), s = Ge(n, r, !1);\n  return react__WEBPACK_IMPORTED_MODULE_1__.useEffect(() => {\n    e && (o({ height: e.itemHeight, width: e.itemWidth }), n({ offsetTop: 0, visibleHeight: e.viewportHeight, visibleWidth: e.viewportWidth }));\n  }, [e, n, o]), /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"div\", { ref: s, style: Zt(!1), children: t });\n}, Mr = /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_1__.memo(function({ ...e }) {\n  const n = et(\"useWindowScroll\"), o = et(\"customScrollParent\"), r = o || n ? Gr : _r, s = o || n ? Ar : Pr, i = et(\"context\");\n  return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(r, { ...e, ...Z(r, i), children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(s, { children: [\n    /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(zr, {}),\n    /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(Lr, {}),\n    /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(Vr, {})\n  ] }) });\n}), {\n  Component: Wr,\n  useEmitter: oo,\n  useEmitterValue: et,\n  usePublisher: It\n} = /* @__PURE__ */ qe(\n  Fr,\n  {\n    events: {\n      atBottomStateChange: \"atBottomStateChange\",\n      atTopStateChange: \"atTopStateChange\",\n      endReached: \"endReached\",\n      isScrolling: \"isScrolling\",\n      rangeChanged: \"rangeChanged\",\n      readyStateChanged: \"readyStateChanged\",\n      startReached: \"startReached\",\n      stateChanged: \"stateChanged\"\n    },\n    methods: {\n      scrollBy: \"scrollBy\",\n      scrollTo: \"scrollTo\",\n      scrollToIndex: \"scrollToIndex\"\n    },\n    optional: {\n      components: \"components\",\n      computeItemKey: \"computeItemKey\",\n      context: \"context\",\n      customScrollParent: \"customScrollParent\",\n      data: \"data\",\n      headerFooterTag: \"headerFooterTag\",\n      increaseViewportBy: \"increaseViewportBy\",\n      initialItemCount: \"initialItemCount\",\n      initialTopMostItemIndex: \"initialTopMostItemIndex\",\n      itemClassName: \"itemClassName\",\n      itemContent: \"itemContent\",\n      listClassName: \"listClassName\",\n      logLevel: \"logLevel\",\n      overscan: \"overscan\",\n      restoreStateFrom: \"restoreStateFrom\",\n      scrollerRef: \"scrollerRef\",\n      scrollSeekConfiguration: \"scrollSeekConfiguration\",\n      totalCount: \"totalCount\",\n      useWindowScroll: \"useWindowScroll\"\n    }\n  },\n  Mr\n), _r = /* @__PURE__ */ Ze({ useEmitter: oo, useEmitterValue: et, usePublisher: It }), Gr = /* @__PURE__ */ Xe({ useEmitter: oo, useEmitterValue: et, usePublisher: It });\nfunction Hn(t, e, n) {\n  return e !== \"normal\" && !(e != null && e.endsWith(\"px\")) && n(`${t} was not resolved to pixel value correctly`, e, ht.WARN), e === \"normal\" ? 0 : parseInt(e != null ? e : \"0\", 10);\n}\nconst Yr = Wr;\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcmVhY3QtdmlydHVvc28vZGlzdC9pbmRleC5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7OztBQUF5RTtBQUMxQjtBQUNwQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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X21vZHVsZXMvcmVhY3QtdmlydHVvc28vZGlzdC9pbmRleC5tanM/YjY2MSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBqc3ggYXMgeiwganN4cyBhcyBLdCwgRnJhZ21lbnQgYXMgaW8gfSBmcm9tIFwicmVhY3QvanN4LXJ1bnRpbWVcIjtcbmltcG9ydCBILCB7IGNyZWF0ZUVsZW1lbnQgYXMgJHQgfSBmcm9tIFwicmVhY3RcIjtcbmltcG9ydCBsbyBmcm9tIFwicmVhY3QtZG9tXCI7XG5jb25zdCB3ZSA9IDAsIHp0ID0gMSwgcXQgPSAyLCBFbiA9IDQ7XG5mdW5jdGlvbiBsbih0KSB7XG4gIHJldHVybiAoKSA9PiB0O1xufVxuZnVuY3Rpb24gY28odCkge1xuICB0KCk7XG59XG5mdW5jdGlvbiBuZSh0LCBlKSB7XG4gIHJldHVybiAobikgPT4gdChlKG4pKTtcbn1cbmZ1bmN0aW9uIGNuKHQsIGUpIHtcbiAgcmV0dXJuICgpID0+IHQoZSk7XG59XG5mdW5jdGlvbiBrbih0LCBlKSB7XG4gIHJldHVybiAobikgPT4gdChlLCBuKTtcbn1cbmZ1bmN0aW9uIE1lKHQpIHtcbiAgcmV0dXJuIHQgIT09IHZvaWQgMDtcbn1cbmZ1bmN0aW9uIHVvKC4uLnQpIHtcbiAgcmV0dXJuICgpID0+IHtcbiAgICB0Lm1hcChjbyk7XG4gIH07XG59XG5mdW5jdGlvbiBZdCgpIHtcbn1cbmZ1bmN0aW9uIHllKHQsIGUpIHtcbiAgcmV0dXJuIGUodCksIHQ7XG59XG5mdW5jdGlvbiBhbyh0LCBlKSB7XG4gIHJldHVybiBlKHQpO1xufVxuZnVuY3Rpb24gWCguLi50KSB7XG4gIHJldHVybiB0O1xufVxuZnVuY3Rpb24gSyh0LCBlKSB7XG4gIHJldHVybiB0KHp0LCBlKTtcbn1cbmZ1bmN0aW9uIFcodCwgZSkge1xuICB0KHdlLCBlKTtcbn1cbmZ1bmN0aW9uIFdlKHQpIHtcbiAgdChxdCk7XG59XG5mdW5jdGlvbiBsdCh0KSB7XG4gIHJldHVybiB0KEVuKTtcbn1cbmZ1bmN0aW9uIEYodCwgZSkge1xuICByZXR1cm4gSyh0LCBrbihlLCB3ZSkpO1xufVxuZnVuY3Rpb24gUnQodCwgZSkge1xuICBjb25zdCBuID0gdCh6dCwgKG8pID0+IHtcbiAgICBuKCksIGUobyk7XG4gIH0pO1xuICByZXR1cm4gbjtcbn1cbmZ1bmN0aW9uIHVuKHQpIHtcbiAgbGV0IGUsIG47XG4gIHJldHVybiAobykgPT4gKHIpID0+IHtcbiAgICBlID0gciwgbiAmJiBjbGVhclRpbWVvdXQobiksIG4gPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIG8oZSk7XG4gICAgfSwgdCk7XG4gIH07XG59XG5mdW5jdGlvbiBCbih0LCBlKSB7XG4gIHJldHVybiB0ID09PSBlO1xufVxuZnVuY3Rpb24gWSh0ID0gQm4pIHtcbiAgbGV0IGU7XG4gIHJldHVybiAobikgPT4gKG8pID0+IHtcbiAgICB0KGUsIG8pIHx8IChlID0gbywgbihvKSk7XG4gIH07XG59XG5mdW5jdGlvbiBQKHQpIHtcbiAgcmV0dXJuIChlKSA9PiAobikgPT4ge1xuICAgIHQobikgJiYgZShuKTtcbiAgfTtcbn1cbmZ1bmN0aW9uIEUodCkge1xuICByZXR1cm4gKGUpID0+IG5lKGUsIHQpO1xufVxuZnVuY3Rpb24gdnQodCkge1xuICByZXR1cm4gKGUpID0+ICgpID0+IHtcbiAgICBlKHQpO1xuICB9O1xufVxuZnVuY3Rpb24geCh0LCAuLi5lKSB7XG4gIGNvbnN0IG4gPSBmbyguLi5lKTtcbiAgcmV0dXJuIChvLCByKSA9PiB7XG4gICAgc3dpdGNoIChvKSB7XG4gICAgICBjYXNlIHF0OlxuICAgICAgICBXZSh0KTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgY2FzZSB6dDpcbiAgICAgICAgcmV0dXJuIEsodCwgbihyKSk7XG4gICAgfVxuICB9O1xufVxuZnVuY3Rpb24gYnQodCwgZSkge1xuICByZXR1cm4gKG4pID0+IChvKSA9PiB7XG4gICAgbihlID0gdChlLCBvKSk7XG4gIH07XG59XG5mdW5jdGlvbiBqdCh0KSB7XG4gIHJldHVybiAoZSkgPT4gKG4pID0+IHtcbiAgICB0ID4gMCA/IHQtLSA6IGUobik7XG4gIH07XG59XG5mdW5jdGlvbiBMdCh0KSB7XG4gIGxldCBlID0gbnVsbCwgbjtcbiAgcmV0dXJuIChvKSA9PiAocikgPT4ge1xuICAgIGUgPSByLCAhbiAmJiAobiA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgbiA9IHZvaWQgMCwgbyhlKTtcbiAgICB9LCB0KSk7XG4gIH07XG59XG5mdW5jdGlvbiBHKC4uLnQpIHtcbiAgY29uc3QgZSA9IG5ldyBBcnJheSh0Lmxlbmd0aCk7XG4gIGxldCBuID0gMCwgbyA9IG51bGw7XG4gIGNvbnN0IHIgPSBNYXRoLnBvdygyLCB0Lmxlbmd0aCkgLSAxO1xuICByZXR1cm4gdC5mb3JFYWNoKChzLCBpKSA9PiB7XG4gICAgY29uc3QgbCA9IE1hdGgucG93KDIsIGkpO1xuICAgIEsocywgKGMpID0+IHtcbiAgICAgIGNvbnN0IHUgPSBuO1xuICAgICAgbiA9IG4gfCBsLCBlW2ldID0gYywgdSAhPT0gciAmJiBuID09PSByICYmIG8gJiYgKG8oKSwgbyA9IG51bGwpO1xuICAgIH0pO1xuICB9KSwgKHMpID0+IChpKSA9PiB7XG4gICAgY29uc3QgbCA9ICgpID0+IHtcbiAgICAgIHMoW2ldLmNvbmNhdChlKSk7XG4gICAgfTtcbiAgICBuID09PSByID8gbCgpIDogbyA9IGw7XG4gIH07XG59XG5mdW5jdGlvbiBmbyguLi50KSB7XG4gIHJldHVybiAoZSkgPT4gdC5yZWR1Y2VSaWdodChhbywgZSk7XG59XG5mdW5jdGlvbiBtbyh0KSB7XG4gIGxldCBlLCBuO1xuICBjb25zdCBvID0gKCkgPT4gZSA9PSBudWxsID8gdm9pZCAwIDogZSgpO1xuICByZXR1cm4gZnVuY3Rpb24ociwgcykge1xuICAgIHN3aXRjaCAocikge1xuICAgICAgY2FzZSB6dDpcbiAgICAgICAgcmV0dXJuIHMgPyBuID09PSBzID8gdm9pZCAwIDogKG8oKSwgbiA9IHMsIGUgPSBLKHQsIHMpLCBlKSA6IChvKCksIFl0KTtcbiAgICAgIGNhc2UgcXQ6XG4gICAgICAgIG8oKSwgbiA9IG51bGw7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gIH07XG59XG5mdW5jdGlvbiB5KHQpIHtcbiAgbGV0IGUgPSB0O1xuICBjb25zdCBuID0gJCgpO1xuICByZXR1cm4gKG8sIHIpID0+IHtcbiAgICBzd2l0Y2ggKG8pIHtcbiAgICAgIGNhc2Ugd2U6XG4gICAgICAgIGUgPSByO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgenQ6IHtcbiAgICAgICAgcihlKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBjYXNlIEVuOlxuICAgICAgICByZXR1cm4gZTtcbiAgICB9XG4gICAgcmV0dXJuIG4obywgcik7XG4gIH07XG59XG5mdW5jdGlvbiBjdCh0LCBlKSB7XG4gIHJldHVybiB5ZSh5KGUpLCAobikgPT4gRih0LCBuKSk7XG59XG5mdW5jdGlvbiAkKCkge1xuICBjb25zdCB0ID0gW107XG4gIHJldHVybiAoZSwgbikgPT4ge1xuICAgIHN3aXRjaCAoZSkge1xuICAgICAgY2FzZSB3ZTpcbiAgICAgICAgdC5zbGljZSgpLmZvckVhY2goKG8pID0+IHtcbiAgICAgICAgICBvKG4pO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgY2FzZSBxdDpcbiAgICAgICAgdC5zcGxpY2UoMCwgdC5sZW5ndGgpO1xuICAgICAgICByZXR1cm47XG4gICAgICBjYXNlIHp0OlxuICAgICAgICByZXR1cm4gdC5wdXNoKG4pLCAoKSA9PiB7XG4gICAgICAgICAgY29uc3QgbyA9IHQuaW5kZXhPZihuKTtcbiAgICAgICAgICBvID4gLTEgJiYgdC5zcGxpY2UobywgMSk7XG4gICAgICAgIH07XG4gICAgfVxuICB9O1xufVxuZnVuY3Rpb24gcHQodCkge1xuICByZXR1cm4geWUoJCgpLCAoZSkgPT4gRih0LCBlKSk7XG59XG5mdW5jdGlvbiBVKHQsIGUgPSBbXSwgeyBzaW5nbGV0b246IG4gfSA9IHsgc2luZ2xldG9uOiAhMCB9KSB7XG4gIHJldHVybiB7XG4gICAgY29uc3RydWN0b3I6IHQsXG4gICAgZGVwZW5kZW5jaWVzOiBlLFxuICAgIGlkOiBwbygpLFxuICAgIHNpbmdsZXRvbjogblxuICB9O1xufVxuY29uc3QgcG8gPSAoKSA9PiBTeW1ib2woKTtcbmZ1bmN0aW9uIGhvKHQpIHtcbiAgY29uc3QgZSA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCksIG4gPSAoeyBjb25zdHJ1Y3RvcjogbywgZGVwZW5kZW5jaWVzOiByLCBpZDogcywgc2luZ2xldG9uOiBpIH0pID0+IHtcbiAgICBpZiAoaSAmJiBlLmhhcyhzKSlcbiAgICAgIHJldHVybiBlLmdldChzKTtcbiAgICBjb25zdCBsID0gbyhyLm1hcCgoYykgPT4gbihjKSkpO1xuICAgIHJldHVybiBpICYmIGUuc2V0KHMsIGwpLCBsO1xuICB9O1xuICByZXR1cm4gbih0KTtcbn1cbmZ1bmN0aW9uIHJ0KC4uLnQpIHtcbiAgY29uc3QgZSA9ICQoKSwgbiA9IG5ldyBBcnJheSh0Lmxlbmd0aCk7XG4gIGxldCBvID0gMDtcbiAgY29uc3QgciA9IE1hdGgucG93KDIsIHQubGVuZ3RoKSAtIDE7XG4gIHJldHVybiB0LmZvckVhY2goKHMsIGkpID0+IHtcbiAgICBjb25zdCBsID0gTWF0aC5wb3coMiwgaSk7XG4gICAgSyhzLCAoYykgPT4ge1xuICAgICAgbltpXSA9IGMsIG8gPSBvIHwgbCwgbyA9PT0gciAmJiBXKGUsIG4pO1xuICAgIH0pO1xuICB9KSwgZnVuY3Rpb24ocywgaSkge1xuICAgIHN3aXRjaCAocykge1xuICAgICAgY2FzZSBxdDoge1xuICAgICAgICBXZShlKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY2FzZSB6dDpcbiAgICAgICAgcmV0dXJuIG8gPT09IHIgJiYgaShuKSwgSyhlLCBpKTtcbiAgICB9XG4gIH07XG59XG5mdW5jdGlvbiBBKHQsIGUgPSBCbikge1xuICByZXR1cm4geCh0LCBZKGUpKTtcbn1cbmZ1bmN0aW9uIGFuKC4uLnQpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKGUsIG4pIHtcbiAgICBzd2l0Y2ggKGUpIHtcbiAgICAgIGNhc2UgcXQ6XG4gICAgICAgIHJldHVybjtcbiAgICAgIGNhc2UgenQ6XG4gICAgICAgIHJldHVybiB1byguLi50Lm1hcCgobykgPT4gSyhvLCBuKSkpO1xuICAgIH1cbiAgfTtcbn1cbnZhciBodCA9IC8qIEBfX1BVUkVfXyAqLyAoKHQpID0+ICh0W3QuREVCVUcgPSAwXSA9IFwiREVCVUdcIiwgdFt0LklORk8gPSAxXSA9IFwiSU5GT1wiLCB0W3QuV0FSTiA9IDJdID0gXCJXQVJOXCIsIHRbdC5FUlJPUiA9IDNdID0gXCJFUlJPUlwiLCB0KSkoaHQgfHwge30pO1xuY29uc3QgZ28gPSB7XG4gIDA6IFwiZGVidWdcIixcbiAgMzogXCJlcnJvclwiLFxuICAxOiBcImxvZ1wiLFxuICAyOiBcIndhcm5cIlxufSwgSW8gPSAoKSA9PiB0eXBlb2YgZ2xvYmFsVGhpcyA+IFwidVwiID8gd2luZG93IDogZ2xvYmFsVGhpcywgVnQgPSBVKFxuICAoKSA9PiB7XG4gICAgY29uc3QgdCA9IHkoXG4gICAgICAzXG4gICAgICAvKiBFUlJPUiAqL1xuICAgICk7XG4gICAgcmV0dXJuIHtcbiAgICAgIGxvZzogeSgobiwgbywgciA9IDEpID0+IHtcbiAgICAgICAgdmFyIGk7XG4gICAgICAgIGNvbnN0IHMgPSAoaSA9IElvKCkuVklSVFVPU09fTE9HX0xFVkVMKSAhPSBudWxsID8gaSA6IGx0KHQpO1xuICAgICAgICByID49IHMgJiYgY29uc29sZVtnb1tyXV0oXG4gICAgICAgICAgXCIlY3JlYWN0LXZpcnR1b3NvOiAlYyVzICVvXCIsXG4gICAgICAgICAgXCJjb2xvcjogIzAyNTNiMzsgZm9udC13ZWlnaHQ6IGJvbGRcIixcbiAgICAgICAgICBcImNvbG9yOiBpbml0aWFsXCIsXG4gICAgICAgICAgbixcbiAgICAgICAgICBvXG4gICAgICAgICk7XG4gICAgICB9KSxcbiAgICAgIGxvZ0xldmVsOiB0XG4gICAgfTtcbiAgfSxcbiAgW10sXG4gIHsgc2luZ2xldG9uOiAhMCB9XG4pO1xuZnVuY3Rpb24gSHQodCwgZSwgbikge1xuICByZXR1cm4gX2UodCwgZSwgbikuY2FsbGJhY2tSZWY7XG59XG5mdW5jdGlvbiBfZSh0LCBlLCBuKSB7XG4gIGNvbnN0IG8gPSBILnVzZVJlZihudWxsKTtcbiAgbGV0IHIgPSAocykgPT4ge1xuICB9O1xuICBpZiAodHlwZW9mIFJlc2l6ZU9ic2VydmVyIDwgXCJ1XCIpIHtcbiAgICBjb25zdCBzID0gSC51c2VNZW1vKCgpID0+IG5ldyBSZXNpemVPYnNlcnZlcigoaSkgPT4ge1xuICAgICAgY29uc3QgbCA9ICgpID0+IHtcbiAgICAgICAgY29uc3QgYyA9IGlbMF0udGFyZ2V0O1xuICAgICAgICBjLm9mZnNldFBhcmVudCAhPT0gbnVsbCAmJiB0KGMpO1xuICAgICAgfTtcbiAgICAgIG4gPyBsKCkgOiByZXF1ZXN0QW5pbWF0aW9uRnJhbWUobCk7XG4gICAgfSksIFt0XSk7XG4gICAgciA9IChpKSA9PiB7XG4gICAgICBpICYmIGUgPyAocy5vYnNlcnZlKGkpLCBvLmN1cnJlbnQgPSBpKSA6IChvLmN1cnJlbnQgJiYgcy51bm9ic2VydmUoby5jdXJyZW50KSwgby5jdXJyZW50ID0gbnVsbCk7XG4gICAgfTtcbiAgfVxuICByZXR1cm4geyBjYWxsYmFja1JlZjogciwgcmVmOiBvIH07XG59XG5mdW5jdGlvbiBPbih0LCBlLCBuLCBvLCByLCBzLCBpLCBsLCBjKSB7XG4gIGNvbnN0IHUgPSBILnVzZUNhbGxiYWNrKFxuICAgIChmKSA9PiB7XG4gICAgICBjb25zdCBTID0gU28oZi5jaGlsZHJlbiwgZSwgbCA/IFwib2Zmc2V0V2lkdGhcIiA6IFwib2Zmc2V0SGVpZ2h0XCIsIHIpO1xuICAgICAgbGV0IHAgPSBmLnBhcmVudEVsZW1lbnQ7XG4gICAgICBmb3IgKDsgIXAuZGF0YXNldC52aXJ0dW9zb1Njcm9sbGVyOyApXG4gICAgICAgIHAgPSBwLnBhcmVudEVsZW1lbnQ7XG4gICAgICBjb25zdCBtID0gcC5sYXN0RWxlbWVudENoaWxkLmRhdGFzZXQudmlld3BvcnRUeXBlID09PSBcIndpbmRvd1wiO1xuICAgICAgbGV0IHc7XG4gICAgICBtICYmICh3ID0gcC5vd25lckRvY3VtZW50LmRlZmF1bHRWaWV3KTtcbiAgICAgIGNvbnN0IEkgPSBpID8gbCA/IGkuc2Nyb2xsTGVmdCA6IGkuc2Nyb2xsVG9wIDogbSA/IGwgPyB3LnNjcm9sbFggfHwgdy5kb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc2Nyb2xsTGVmdCA6IHcuc2Nyb2xsWSB8fCB3LmRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zY3JvbGxUb3AgOiBsID8gcC5zY3JvbGxMZWZ0IDogcC5zY3JvbGxUb3AsIEMgPSBpID8gbCA/IGkuc2Nyb2xsV2lkdGggOiBpLnNjcm9sbEhlaWdodCA6IG0gPyBsID8gdy5kb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc2Nyb2xsV2lkdGggOiB3LmRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zY3JvbGxIZWlnaHQgOiBsID8gcC5zY3JvbGxXaWR0aCA6IHAuc2Nyb2xsSGVpZ2h0LCBnID0gaSA/IGwgPyBpLm9mZnNldFdpZHRoIDogaS5vZmZzZXRIZWlnaHQgOiBtID8gbCA/IHcuaW5uZXJXaWR0aCA6IHcuaW5uZXJIZWlnaHQgOiBsID8gcC5vZmZzZXRXaWR0aCA6IHAub2Zmc2V0SGVpZ2h0O1xuICAgICAgbyh7XG4gICAgICAgIHNjcm9sbEhlaWdodDogQyxcbiAgICAgICAgc2Nyb2xsVG9wOiBNYXRoLm1heChJLCAwKSxcbiAgICAgICAgdmlld3BvcnRIZWlnaHQ6IGdcbiAgICAgIH0pLCBzID09IG51bGwgfHwgcyhcbiAgICAgICAgbCA/IGRuKFwiY29sdW1uLWdhcFwiLCBnZXRDb21wdXRlZFN0eWxlKGYpLmNvbHVtbkdhcCwgcikgOiBkbihcInJvdy1nYXBcIiwgZ2V0Q29tcHV0ZWRTdHlsZShmKS5yb3dHYXAsIHIpXG4gICAgICApLCBTICE9PSBudWxsICYmIHQoUyk7XG4gICAgfSxcbiAgICBbdCwgZSwgciwgcywgaSwgb11cbiAgKTtcbiAgcmV0dXJuIF9lKHUsIG4sIGMpO1xufVxuZnVuY3Rpb24gU28odCwgZSwgbiwgbykge1xuICBjb25zdCByID0gdC5sZW5ndGg7XG4gIGlmIChyID09PSAwKVxuICAgIHJldHVybiBudWxsO1xuICBjb25zdCBzID0gW107XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgcjsgaSsrKSB7XG4gICAgY29uc3QgbCA9IHQuaXRlbShpKTtcbiAgICBpZiAobC5kYXRhc2V0LmluZGV4ID09PSB2b2lkIDApXG4gICAgICBjb250aW51ZTtcbiAgICBjb25zdCBjID0gcGFyc2VJbnQobC5kYXRhc2V0LmluZGV4KSwgdSA9IHBhcnNlRmxvYXQobC5kYXRhc2V0Lmtub3duU2l6ZSksIGYgPSBlKGwsIG4pO1xuICAgIGlmIChmID09PSAwICYmIG8oXCJaZXJvLXNpemVkIGVsZW1lbnQsIHRoaXMgc2hvdWxkIG5vdCBoYXBwZW5cIiwgeyBjaGlsZDogbCB9LCBodC5FUlJPUiksIGYgPT09IHUpXG4gICAgICBjb250aW51ZTtcbiAgICBjb25zdCBTID0gc1tzLmxlbmd0aCAtIDFdO1xuICAgIHMubGVuZ3RoID09PSAwIHx8IFMuc2l6ZSAhPT0gZiB8fCBTLmVuZEluZGV4ICE9PSBjIC0gMSA/IHMucHVzaCh7IGVuZEluZGV4OiBjLCBzaXplOiBmLCBzdGFydEluZGV4OiBjIH0pIDogc1tzLmxlbmd0aCAtIDFdLmVuZEluZGV4Kys7XG4gIH1cbiAgcmV0dXJuIHM7XG59XG5mdW5jdGlvbiBkbih0LCBlLCBuKSB7XG4gIHJldHVybiBlICE9PSBcIm5vcm1hbFwiICYmICEoZSAhPSBudWxsICYmIGUuZW5kc1dpdGgoXCJweFwiKSkgJiYgbihgJHt0fSB3YXMgbm90IHJlc29sdmVkIHRvIHBpeGVsIHZhbHVlIGNvcnJlY3RseWAsIGUsIGh0LldBUk4pLCBlID09PSBcIm5vcm1hbFwiID8gMCA6IHBhcnNlSW50KGUgIT0gbnVsbCA/IGUgOiBcIjBcIiwgMTApO1xufVxuZnVuY3Rpb24gR2UodCwgZSwgbikge1xuICBjb25zdCBvID0gSC51c2VSZWYobnVsbCksIHIgPSBILnVzZUNhbGxiYWNrKFxuICAgIChjKSA9PiB7XG4gICAgICBpZiAoIShjICE9IG51bGwgJiYgYy5vZmZzZXRQYXJlbnQpKVxuICAgICAgICByZXR1cm47XG4gICAgICBjb25zdCB1ID0gYy5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSwgZiA9IHUud2lkdGg7XG4gICAgICBsZXQgUywgcDtcbiAgICAgIGlmIChlKSB7XG4gICAgICAgIGNvbnN0IG0gPSBlLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLCB3ID0gdS50b3AgLSBtLnRvcDtcbiAgICAgICAgcCA9IG0uaGVpZ2h0IC0gTWF0aC5tYXgoMCwgdyksIFMgPSB3ICsgZS5zY3JvbGxUb3A7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCBtID0gaS5jdXJyZW50Lm93bmVyRG9jdW1lbnQuZGVmYXVsdFZpZXc7XG4gICAgICAgIHAgPSBtLmlubmVySGVpZ2h0IC0gTWF0aC5tYXgoMCwgdS50b3ApLCBTID0gdS50b3AgKyBtLnNjcm9sbFk7XG4gICAgICB9XG4gICAgICBvLmN1cnJlbnQgPSB7XG4gICAgICAgIG9mZnNldFRvcDogUyxcbiAgICAgICAgdmlzaWJsZUhlaWdodDogcCxcbiAgICAgICAgdmlzaWJsZVdpZHRoOiBmXG4gICAgICB9LCB0KG8uY3VycmVudCk7XG4gICAgfSxcbiAgICBbdCwgZV1cbiAgKSwgeyBjYWxsYmFja1JlZjogcywgcmVmOiBpIH0gPSBfZShyLCAhMCwgbiksIGwgPSBILnVzZUNhbGxiYWNrKCgpID0+IHtcbiAgICByKGkuY3VycmVudCk7XG4gIH0sIFtyLCBpXSk7XG4gIHJldHVybiBILnVzZUVmZmVjdCgoKSA9PiB7XG4gICAgdmFyIGM7XG4gICAgaWYgKGUpIHtcbiAgICAgIGUuYWRkRXZlbnRMaXN0ZW5lcihcInNjcm9sbFwiLCBsKTtcbiAgICAgIGNvbnN0IHUgPSBuZXcgUmVzaXplT2JzZXJ2ZXIoKCkgPT4ge1xuICAgICAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUobCk7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiB1Lm9ic2VydmUoZSksICgpID0+IHtcbiAgICAgICAgZS5yZW1vdmVFdmVudExpc3RlbmVyKFwic2Nyb2xsXCIsIGwpLCB1LnVub2JzZXJ2ZShlKTtcbiAgICAgIH07XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IHUgPSAoYyA9IGkuY3VycmVudCkgPT0gbnVsbCA/IHZvaWQgMCA6IGMub3duZXJEb2N1bWVudC5kZWZhdWx0VmlldztcbiAgICAgIHJldHVybiB1ID09IG51bGwgfHwgdS5hZGRFdmVudExpc3RlbmVyKFwic2Nyb2xsXCIsIGwpLCB1ID09IG51bGwgfHwgdS5hZGRFdmVudExpc3RlbmVyKFwicmVzaXplXCIsIGwpLCAoKSA9PiB7XG4gICAgICAgIHUgPT0gbnVsbCB8fCB1LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJzY3JvbGxcIiwgbCksIHUgPT0gbnVsbCB8fCB1LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJyZXNpemVcIiwgbCk7XG4gICAgICB9O1xuICAgIH1cbiAgfSwgW2wsIGVdKSwgcztcbn1cbmNvbnN0IGF0ID0gVShcbiAgKCkgPT4ge1xuICAgIGNvbnN0IHQgPSAkKCksIGUgPSAkKCksIG4gPSB5KDApLCBvID0gJCgpLCByID0geSgwKSwgcyA9ICQoKSwgaSA9ICQoKSwgbCA9IHkoMCksIGMgPSB5KDApLCB1ID0geSgwKSwgZiA9IHkoMCksIFMgPSAkKCksIHAgPSAkKCksIG0gPSB5KCExKSwgdyA9IHkoITEpLCBJID0geSghMSk7XG4gICAgcmV0dXJuIEYoXG4gICAgICB4KFxuICAgICAgICB0LFxuICAgICAgICBFKCh7IHNjcm9sbFRvcDogQyB9KSA9PiBDKVxuICAgICAgKSxcbiAgICAgIGVcbiAgICApLCBGKFxuICAgICAgeChcbiAgICAgICAgdCxcbiAgICAgICAgRSgoeyBzY3JvbGxIZWlnaHQ6IEMgfSkgPT4gQylcbiAgICAgICksXG4gICAgICBpXG4gICAgKSwgRihlLCByKSwge1xuICAgICAgZGV2aWF0aW9uOiBuLFxuICAgICAgZml4ZWRGb290ZXJIZWlnaHQ6IHUsXG4gICAgICBmaXhlZEhlYWRlckhlaWdodDogYyxcbiAgICAgIGZvb3RlckhlaWdodDogZixcbiAgICAgIGhlYWRlckhlaWdodDogbCxcbiAgICAgIGhvcml6b250YWxEaXJlY3Rpb246IHcsXG4gICAgICBzY3JvbGxCeTogcCxcbiAgICAgIC8vIGlucHV0XG4gICAgICBzY3JvbGxDb250YWluZXJTdGF0ZTogdCxcbiAgICAgIHNjcm9sbEhlaWdodDogaSxcbiAgICAgIHNjcm9sbGluZ0luUHJvZ3Jlc3M6IG0sXG4gICAgICAvLyBzaWduYWxzXG4gICAgICBzY3JvbGxUbzogUyxcbiAgICAgIHNjcm9sbFRvcDogZSxcbiAgICAgIHNraXBBbmltYXRpb25GcmFtZUluUmVzaXplT2JzZXJ2ZXI6IEksXG4gICAgICBzbW9vdGhTY3JvbGxUYXJnZXRSZWFjaGVkOiBvLFxuICAgICAgLy8gc3RhdGVcbiAgICAgIHN0YXRlZnVsU2Nyb2xsVG9wOiByLFxuICAgICAgdmlld3BvcnRIZWlnaHQ6IHNcbiAgICB9O1xuICB9LFxuICBbXSxcbiAgeyBzaW5nbGV0b246ICEwIH1cbiksIG9lID0geyBsdmw6IDAgfTtcbmZ1bmN0aW9uIEZuKHQsIGUpIHtcbiAgY29uc3QgbiA9IHQubGVuZ3RoO1xuICBpZiAobiA9PT0gMClcbiAgICByZXR1cm4gW107XG4gIGxldCB7IGluZGV4OiBvLCB2YWx1ZTogciB9ID0gZSh0WzBdKTtcbiAgY29uc3QgcyA9IFtdO1xuICBmb3IgKGxldCBpID0gMTsgaSA8IG47IGkrKykge1xuICAgIGNvbnN0IHsgaW5kZXg6IGwsIHZhbHVlOiBjIH0gPSBlKHRbaV0pO1xuICAgIHMucHVzaCh7IGVuZDogbCAtIDEsIHN0YXJ0OiBvLCB2YWx1ZTogciB9KSwgbyA9IGwsIHIgPSBjO1xuICB9XG4gIHJldHVybiBzLnB1c2goeyBlbmQ6IDEgLyAwLCBzdGFydDogbywgdmFsdWU6IHIgfSksIHM7XG59XG5mdW5jdGlvbiBqKHQpIHtcbiAgcmV0dXJuIHQgPT09IG9lO1xufVxuZnVuY3Rpb24gcmUodCwgZSkge1xuICBpZiAoIWoodCkpXG4gICAgcmV0dXJuIGUgPT09IHQuayA/IHQudiA6IGUgPCB0LmsgPyByZSh0LmwsIGUpIDogcmUodC5yLCBlKTtcbn1cbmZ1bmN0aW9uIEN0KHQsIGUsIG4gPSBcImtcIikge1xuICBpZiAoaih0KSlcbiAgICByZXR1cm4gWy0xIC8gMCwgdm9pZCAwXTtcbiAgaWYgKE51bWJlcih0W25dKSA9PT0gZSlcbiAgICByZXR1cm4gW3QuaywgdC52XTtcbiAgaWYgKE51bWJlcih0W25dKSA8IGUpIHtcbiAgICBjb25zdCBvID0gQ3QodC5yLCBlLCBuKTtcbiAgICByZXR1cm4gb1swXSA9PT0gLTEgLyAwID8gW3QuaywgdC52XSA6IG87XG4gIH1cbiAgcmV0dXJuIEN0KHQubCwgZSwgbik7XG59XG5mdW5jdGlvbiBtdCh0LCBlLCBuKSB7XG4gIHJldHVybiBqKHQpID8gVm4oZSwgbiwgMSkgOiBlID09PSB0LmsgPyBvdCh0LCB7IGs6IGUsIHY6IG4gfSkgOiBlIDwgdC5rID8gZm4ob3QodCwgeyBsOiBtdCh0LmwsIGUsIG4pIH0pKSA6IGZuKG90KHQsIHsgcjogbXQodC5yLCBlLCBuKSB9KSk7XG59XG5mdW5jdGlvbiBVdCgpIHtcbiAgcmV0dXJuIG9lO1xufVxuZnVuY3Rpb24gdmUodCwgZSwgbikge1xuICBpZiAoaih0KSlcbiAgICByZXR1cm4gW107XG4gIGNvbnN0IG8gPSBDdCh0LCBlKVswXTtcbiAgcmV0dXJuIHhvKHplKHQsIG8sIG4pKTtcbn1cbmZ1bmN0aW9uIExlKHQsIGUpIHtcbiAgaWYgKGoodCkpIHJldHVybiBvZTtcbiAgY29uc3QgeyBrOiBuLCBsOiBvLCByIH0gPSB0O1xuICBpZiAoZSA9PT0gbikge1xuICAgIGlmIChqKG8pKVxuICAgICAgcmV0dXJuIHI7XG4gICAgaWYgKGoocikpXG4gICAgICByZXR1cm4gbztcbiAgICB7XG4gICAgICBjb25zdCBbcywgaV0gPSB6bihvKTtcbiAgICAgIHJldHVybiBnZShvdCh0LCB7IGs6IHMsIGw6IExuKG8pLCB2OiBpIH0pKTtcbiAgICB9XG4gIH0gZWxzZSByZXR1cm4gZSA8IG4gPyBnZShvdCh0LCB7IGw6IExlKG8sIGUpIH0pKSA6IGdlKG90KHQsIHsgcjogTGUociwgZSkgfSkpO1xufVxuZnVuY3Rpb24gX3QodCkge1xuICByZXR1cm4gaih0KSA/IFtdIDogWy4uLl90KHQubCksIHsgazogdC5rLCB2OiB0LnYgfSwgLi4uX3QodC5yKV07XG59XG5mdW5jdGlvbiB6ZSh0LCBlLCBuKSB7XG4gIGlmIChqKHQpKVxuICAgIHJldHVybiBbXTtcbiAgY29uc3QgeyBrOiBvLCBsOiByLCByOiBzLCB2OiBpIH0gPSB0O1xuICBsZXQgbCA9IFtdO1xuICByZXR1cm4gbyA+IGUgJiYgKGwgPSBsLmNvbmNhdCh6ZShyLCBlLCBuKSkpLCBvID49IGUgJiYgbyA8PSBuICYmIGwucHVzaCh7IGs6IG8sIHY6IGkgfSksIG8gPD0gbiAmJiAobCA9IGwuY29uY2F0KHplKHMsIGUsIG4pKSksIGw7XG59XG5mdW5jdGlvbiBnZSh0KSB7XG4gIGNvbnN0IHsgbDogZSwgbHZsOiBuLCByOiBvIH0gPSB0O1xuICBpZiAoby5sdmwgPj0gbiAtIDEgJiYgZS5sdmwgPj0gbiAtIDEpXG4gICAgcmV0dXJuIHQ7XG4gIGlmIChuID4gby5sdmwgKyAxKSB7XG4gICAgaWYgKEVlKGUpKVxuICAgICAgcmV0dXJuIFBuKG90KHQsIHsgbHZsOiBuIC0gMSB9KSk7XG4gICAgaWYgKCFqKGUpICYmICFqKGUucikpXG4gICAgICByZXR1cm4gb3QoZS5yLCB7XG4gICAgICAgIGw6IG90KGUsIHsgcjogZS5yLmwgfSksXG4gICAgICAgIGx2bDogbixcbiAgICAgICAgcjogb3QodCwge1xuICAgICAgICAgIGw6IGUuci5yLFxuICAgICAgICAgIGx2bDogbiAtIDFcbiAgICAgICAgfSlcbiAgICAgIH0pO1xuICAgIHRocm93IG5ldyBFcnJvcihcIlVuZXhwZWN0ZWQgZW1wdHkgbm9kZXNcIik7XG4gIH0gZWxzZSB7XG4gICAgaWYgKEVlKHQpKVxuICAgICAgcmV0dXJuIFZlKG90KHQsIHsgbHZsOiBuIC0gMSB9KSk7XG4gICAgaWYgKCFqKG8pICYmICFqKG8ubCkpIHtcbiAgICAgIGNvbnN0IHIgPSBvLmwsIHMgPSBFZShyKSA/IG8ubHZsIC0gMSA6IG8ubHZsO1xuICAgICAgcmV0dXJuIG90KHIsIHtcbiAgICAgICAgbDogb3QodCwge1xuICAgICAgICAgIGx2bDogbiAtIDEsXG4gICAgICAgICAgcjogci5sXG4gICAgICAgIH0pLFxuICAgICAgICBsdmw6IHIubHZsICsgMSxcbiAgICAgICAgcjogVmUob3QobywgeyBsOiByLnIsIGx2bDogcyB9KSlcbiAgICAgIH0pO1xuICAgIH0gZWxzZVxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5leHBlY3RlZCBlbXB0eSBub2Rlc1wiKTtcbiAgfVxufVxuZnVuY3Rpb24gb3QodCwgZSkge1xuICByZXR1cm4gVm4oXG4gICAgZS5rICE9PSB2b2lkIDAgPyBlLmsgOiB0LmssXG4gICAgZS52ICE9PSB2b2lkIDAgPyBlLnYgOiB0LnYsXG4gICAgZS5sdmwgIT09IHZvaWQgMCA/IGUubHZsIDogdC5sdmwsXG4gICAgZS5sICE9PSB2b2lkIDAgPyBlLmwgOiB0LmwsXG4gICAgZS5yICE9PSB2b2lkIDAgPyBlLnIgOiB0LnJcbiAgKTtcbn1cbmZ1bmN0aW9uIExuKHQpIHtcbiAgcmV0dXJuIGoodC5yKSA/IHQubCA6IGdlKG90KHQsIHsgcjogTG4odC5yKSB9KSk7XG59XG5mdW5jdGlvbiBFZSh0KSB7XG4gIHJldHVybiBqKHQpIHx8IHQubHZsID4gdC5yLmx2bDtcbn1cbmZ1bmN0aW9uIHpuKHQpIHtcbiAgcmV0dXJuIGoodC5yKSA/IFt0LmssIHQudl0gOiB6bih0LnIpO1xufVxuZnVuY3Rpb24gVm4odCwgZSwgbiwgbyA9IG9lLCByID0gb2UpIHtcbiAgcmV0dXJuIHsgazogdCwgbDogbywgbHZsOiBuLCByLCB2OiBlIH07XG59XG5mdW5jdGlvbiBmbih0KSB7XG4gIHJldHVybiBWZShQbih0KSk7XG59XG5mdW5jdGlvbiBQbih0KSB7XG4gIGNvbnN0IHsgbDogZSB9ID0gdDtcbiAgcmV0dXJuICFqKGUpICYmIGUubHZsID09PSB0Lmx2bCA/IG90KGUsIHsgcjogb3QodCwgeyBsOiBlLnIgfSkgfSkgOiB0O1xufVxuZnVuY3Rpb24gVmUodCkge1xuICBjb25zdCB7IGx2bDogZSwgcjogbiB9ID0gdDtcbiAgcmV0dXJuICFqKG4pICYmICFqKG4ucikgJiYgbi5sdmwgPT09IGUgJiYgbi5yLmx2bCA9PT0gZSA/IG90KG4sIHsgbDogb3QodCwgeyByOiBuLmwgfSksIGx2bDogZSArIDEgfSkgOiB0O1xufVxuZnVuY3Rpb24geG8odCkge1xuICByZXR1cm4gRm4odCwgKHsgazogZSwgdjogbiB9KSA9PiAoeyBpbmRleDogZSwgdmFsdWU6IG4gfSkpO1xufVxuZnVuY3Rpb24gQW4odCwgZSkge1xuICByZXR1cm4gISEodCAmJiB0LnN0YXJ0SW5kZXggPT09IGUuc3RhcnRJbmRleCAmJiB0LmVuZEluZGV4ID09PSBlLmVuZEluZGV4KTtcbn1cbmZ1bmN0aW9uIHNlKHQsIGUpIHtcbiAgcmV0dXJuICEhKHQgJiYgdFswXSA9PT0gZVswXSAmJiB0WzFdID09PSBlWzFdKTtcbn1cbmNvbnN0IE5lID0gVShcbiAgKCkgPT4gKHsgcmVjYWxjSW5Qcm9ncmVzczogeSghMSkgfSksXG4gIFtdLFxuICB7IHNpbmdsZXRvbjogITAgfVxuKTtcbmZ1bmN0aW9uIE1uKHQsIGUsIG4pIHtcbiAgcmV0dXJuIHRbU2UodCwgZSwgbildO1xufVxuZnVuY3Rpb24gU2UodCwgZSwgbiwgbyA9IDApIHtcbiAgbGV0IHIgPSB0Lmxlbmd0aCAtIDE7XG4gIGZvciAoOyBvIDw9IHI7ICkge1xuICAgIGNvbnN0IHMgPSBNYXRoLmZsb29yKChvICsgcikgLyAyKSwgaSA9IHRbc10sIGwgPSBuKGksIGUpO1xuICAgIGlmIChsID09PSAwKVxuICAgICAgcmV0dXJuIHM7XG4gICAgaWYgKGwgPT09IC0xKSB7XG4gICAgICBpZiAociAtIG8gPCAyKVxuICAgICAgICByZXR1cm4gcyAtIDE7XG4gICAgICByID0gcyAtIDE7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChyID09PSBvKVxuICAgICAgICByZXR1cm4gcztcbiAgICAgIG8gPSBzICsgMTtcbiAgICB9XG4gIH1cbiAgdGhyb3cgbmV3IEVycm9yKGBGYWlsZWQgYmluYXJ5IGZpbmRpbmcgcmVjb3JkIGluIGFycmF5IC0gJHt0LmpvaW4oXCIsXCIpfSwgc2VhcmNoZWQgZm9yICR7ZX1gKTtcbn1cbmZ1bmN0aW9uIFRvKHQsIGUsIG4sIG8pIHtcbiAgY29uc3QgciA9IFNlKHQsIGUsIG8pLCBzID0gU2UodCwgbiwgbywgcik7XG4gIHJldHVybiB0LnNsaWNlKHIsIHMgKyAxKTtcbn1cbmZ1bmN0aW9uIHd0KHQsIGUpIHtcbiAgcmV0dXJuIE1hdGgucm91bmQodC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKVtlXSk7XG59XG5mdW5jdGlvbiBiZSh0KSB7XG4gIHJldHVybiAhaih0Lmdyb3VwT2Zmc2V0VHJlZSk7XG59XG5mdW5jdGlvbiBEZSh7IGluZGV4OiB0IH0sIGUpIHtcbiAgcmV0dXJuIGUgPT09IHQgPyAwIDogZSA8IHQgPyAtMSA6IDE7XG59XG5mdW5jdGlvbiBDbygpIHtcbiAgcmV0dXJuIHtcbiAgICBncm91cEluZGljZXM6IFtdLFxuICAgIGdyb3VwT2Zmc2V0VHJlZTogVXQoKSxcbiAgICBsYXN0SW5kZXg6IDAsXG4gICAgbGFzdE9mZnNldDogMCxcbiAgICBsYXN0U2l6ZTogMCxcbiAgICBvZmZzZXRUcmVlOiBbXSxcbiAgICBzaXplVHJlZTogVXQoKVxuICB9O1xufVxuZnVuY3Rpb24gd28odCwgZSkge1xuICBsZXQgbiA9IGoodCkgPyAwIDogMSAvIDA7XG4gIGZvciAoY29uc3QgbyBvZiBlKSB7XG4gICAgY29uc3QgeyBlbmRJbmRleDogciwgc2l6ZTogcywgc3RhcnRJbmRleDogaSB9ID0gbztcbiAgICBpZiAobiA9IE1hdGgubWluKG4sIGkpLCBqKHQpKSB7XG4gICAgICB0ID0gbXQodCwgMCwgcyk7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgY29uc3QgbCA9IHZlKHQsIGkgLSAxLCByICsgMSk7XG4gICAgaWYgKGwuc29tZShrbyhvKSkpXG4gICAgICBjb250aW51ZTtcbiAgICBsZXQgYyA9ICExLCB1ID0gITE7XG4gICAgZm9yIChjb25zdCB7IGVuZDogZiwgc3RhcnQ6IFMsIHZhbHVlOiBwIH0gb2YgbClcbiAgICAgIGMgPyAociA+PSBTIHx8IHMgPT09IHApICYmICh0ID0gTGUodCwgUykpIDogKHUgPSBwICE9PSBzLCBjID0gITApLCBmID4gciAmJiByID49IFMgJiYgcCAhPT0gcyAmJiAodCA9IG10KHQsIHIgKyAxLCBwKSk7XG4gICAgdSAmJiAodCA9IG10KHQsIGksIHMpKTtcbiAgfVxuICByZXR1cm4gW3QsIG5dO1xufVxuZnVuY3Rpb24geW8odCkge1xuICByZXR1cm4gdHlwZW9mIHQuZ3JvdXBJbmRleCA8IFwidVwiO1xufVxuZnVuY3Rpb24gdm8oeyBvZmZzZXQ6IHQgfSwgZSkge1xuICByZXR1cm4gZSA9PT0gdCA/IDAgOiBlIDwgdCA/IC0xIDogMTtcbn1cbmZ1bmN0aW9uIGllKHQsIGUsIG4pIHtcbiAgaWYgKGUubGVuZ3RoID09PSAwKVxuICAgIHJldHVybiAwO1xuICBjb25zdCB7IGluZGV4OiBvLCBvZmZzZXQ6IHIsIHNpemU6IHMgfSA9IE1uKGUsIHQsIERlKSwgaSA9IHQgLSBvLCBsID0gcyAqIGkgKyAoaSAtIDEpICogbiArIHI7XG4gIHJldHVybiBsID4gMCA/IGwgKyBuIDogbDtcbn1cbmZ1bmN0aW9uIFduKHQsIGUpIHtcbiAgaWYgKCFiZShlKSlcbiAgICByZXR1cm4gdDtcbiAgbGV0IG4gPSAwO1xuICBmb3IgKDsgZS5ncm91cEluZGljZXNbbl0gPD0gdCArIG47IClcbiAgICBuKys7XG4gIHJldHVybiB0ICsgbjtcbn1cbmZ1bmN0aW9uIF9uKHQsIGUsIG4pIHtcbiAgaWYgKHlvKHQpKVxuICAgIHJldHVybiBlLmdyb3VwSW5kaWNlc1t0Lmdyb3VwSW5kZXhdICsgMTtcbiAge1xuICAgIGNvbnN0IG8gPSB0LmluZGV4ID09PSBcIkxBU1RcIiA/IG4gOiB0LmluZGV4O1xuICAgIGxldCByID0gV24obywgZSk7XG4gICAgcmV0dXJuIHIgPSBNYXRoLm1heCgwLCByLCBNYXRoLm1pbihuLCByKSksIHI7XG4gIH1cbn1cbmZ1bmN0aW9uIGJvKHQsIGUsIG4sIG8gPSAwKSB7XG4gIHJldHVybiBvID4gMCAmJiAoZSA9IE1hdGgubWF4KGUsIE1uKHQsIG8sIERlKS5vZmZzZXQpKSwgRm4oVG8odCwgZSwgbiwgdm8pLCBFbyk7XG59XG5mdW5jdGlvbiBSbyh0LCBbZSwgbiwgbywgcl0pIHtcbiAgZS5sZW5ndGggPiAwICYmIG8oXCJyZWNlaXZlZCBpdGVtIHNpemVzXCIsIGUsIGh0LkRFQlVHKTtcbiAgY29uc3QgcyA9IHQuc2l6ZVRyZWU7XG4gIGxldCBpID0gcywgbCA9IDA7XG4gIGlmIChuLmxlbmd0aCA+IDAgJiYgaihzKSAmJiBlLmxlbmd0aCA9PT0gMikge1xuICAgIGNvbnN0IHAgPSBlWzBdLnNpemUsIG0gPSBlWzFdLnNpemU7XG4gICAgaSA9IG4ucmVkdWNlKCh3LCBJKSA9PiBtdChtdCh3LCBJLCBwKSwgSSArIDEsIG0pLCBpKTtcbiAgfSBlbHNlXG4gICAgW2ksIGxdID0gd28oaSwgZSk7XG4gIGlmIChpID09PSBzKVxuICAgIHJldHVybiB0O1xuICBjb25zdCB7IGxhc3RJbmRleDogYywgbGFzdE9mZnNldDogdSwgbGFzdFNpemU6IGYsIG9mZnNldFRyZWU6IFMgfSA9IFBlKHQub2Zmc2V0VHJlZSwgbCwgaSwgcik7XG4gIHJldHVybiB7XG4gICAgZ3JvdXBJbmRpY2VzOiBuLFxuICAgIGdyb3VwT2Zmc2V0VHJlZTogbi5yZWR1Y2UoKHAsIG0pID0+IG10KHAsIG0sIGllKG0sIFMsIHIpKSwgVXQoKSksXG4gICAgbGFzdEluZGV4OiBjLFxuICAgIGxhc3RPZmZzZXQ6IHUsXG4gICAgbGFzdFNpemU6IGYsXG4gICAgb2Zmc2V0VHJlZTogUyxcbiAgICBzaXplVHJlZTogaVxuICB9O1xufVxuZnVuY3Rpb24gSG8odCkge1xuICByZXR1cm4gX3QodCkubWFwKCh7IGs6IGUsIHY6IG4gfSwgbywgcikgPT4ge1xuICAgIGNvbnN0IHMgPSByW28gKyAxXTtcbiAgICByZXR1cm4geyBlbmRJbmRleDogcyA/IHMuayAtIDEgOiAxIC8gMCwgc2l6ZTogbiwgc3RhcnRJbmRleDogZSB9O1xuICB9KTtcbn1cbmZ1bmN0aW9uIG1uKHQsIGUpIHtcbiAgbGV0IG4gPSAwLCBvID0gMDtcbiAgZm9yICg7IG4gPCB0OyApXG4gICAgbiArPSBlW28gKyAxXSAtIGVbb10gLSAxLCBvKys7XG4gIHJldHVybiBvIC0gKG4gPT09IHQgPyAwIDogMSk7XG59XG5mdW5jdGlvbiBQZSh0LCBlLCBuLCBvKSB7XG4gIGxldCByID0gdCwgcyA9IDAsIGkgPSAwLCBsID0gMCwgYyA9IDA7XG4gIGlmIChlICE9PSAwKSB7XG4gICAgYyA9IFNlKHIsIGUgLSAxLCBEZSksIGwgPSByW2NdLm9mZnNldDtcbiAgICBjb25zdCBmID0gQ3QobiwgZSAtIDEpO1xuICAgIHMgPSBmWzBdLCBpID0gZlsxXSwgci5sZW5ndGggJiYgcltjXS5zaXplID09PSBDdChuLCBlKVsxXSAmJiAoYyAtPSAxKSwgciA9IHIuc2xpY2UoMCwgYyArIDEpO1xuICB9IGVsc2VcbiAgICByID0gW107XG4gIGZvciAoY29uc3QgeyBzdGFydDogdSwgdmFsdWU6IGYgfSBvZiB2ZShuLCBlLCAxIC8gMCkpIHtcbiAgICBjb25zdCBTID0gdSAtIHMsIHAgPSBTICogaSArIGwgKyBTICogbztcbiAgICByLnB1c2goe1xuICAgICAgaW5kZXg6IHUsXG4gICAgICBvZmZzZXQ6IHAsXG4gICAgICBzaXplOiBmXG4gICAgfSksIHMgPSB1LCBsID0gcCwgaSA9IGY7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBsYXN0SW5kZXg6IHMsXG4gICAgbGFzdE9mZnNldDogbCxcbiAgICBsYXN0U2l6ZTogaSxcbiAgICBvZmZzZXRUcmVlOiByXG4gIH07XG59XG5mdW5jdGlvbiBFbyh0KSB7XG4gIHJldHVybiB7IGluZGV4OiB0LmluZGV4LCB2YWx1ZTogdCB9O1xufVxuZnVuY3Rpb24ga28odCkge1xuICBjb25zdCB7IGVuZEluZGV4OiBlLCBzaXplOiBuLCBzdGFydEluZGV4OiBvIH0gPSB0O1xuICByZXR1cm4gKHIpID0+IHIuc3RhcnQgPT09IG8gJiYgKHIuZW5kID09PSBlIHx8IHIuZW5kID09PSAxIC8gMCkgJiYgci52YWx1ZSA9PT0gbjtcbn1cbmNvbnN0IEJvID0ge1xuICBvZmZzZXRIZWlnaHQ6IFwiaGVpZ2h0XCIsXG4gIG9mZnNldFdpZHRoOiBcIndpZHRoXCJcbn0sIEV0ID0gVShcbiAgKFt7IGxvZzogdCB9LCB7IHJlY2FsY0luUHJvZ3Jlc3M6IGUgfV0pID0+IHtcbiAgICBjb25zdCBuID0gJCgpLCBvID0gJCgpLCByID0gY3QobywgMCksIHMgPSAkKCksIGkgPSAkKCksIGwgPSB5KDApLCBjID0geShbXSksIHUgPSB5KHZvaWQgMCksIGYgPSB5KHZvaWQgMCksIFMgPSB5KChoLCBkKSA9PiB3dChoLCBCb1tkXSkpLCBwID0geSh2b2lkIDApLCBtID0geSgwKSwgdyA9IENvKCksIEkgPSBjdChcbiAgICAgIHgobiwgRyhjLCB0LCBtKSwgYnQoUm8sIHcpLCBZKCkpLFxuICAgICAgd1xuICAgICksIEMgPSBjdChcbiAgICAgIHgoXG4gICAgICAgIGMsXG4gICAgICAgIFkoKSxcbiAgICAgICAgYnQoKGgsIGQpID0+ICh7IGN1cnJlbnQ6IGQsIHByZXY6IGguY3VycmVudCB9KSwge1xuICAgICAgICAgIGN1cnJlbnQ6IFtdLFxuICAgICAgICAgIHByZXY6IFtdXG4gICAgICAgIH0pLFxuICAgICAgICBFKCh7IHByZXY6IGggfSkgPT4gaClcbiAgICAgICksXG4gICAgICBbXVxuICAgICk7XG4gICAgRihcbiAgICAgIHgoXG4gICAgICAgIGMsXG4gICAgICAgIFAoKGgpID0+IGgubGVuZ3RoID4gMCksXG4gICAgICAgIEcoSSwgbSksXG4gICAgICAgIEUoKFtoLCBkLCBSXSkgPT4ge1xuICAgICAgICAgIGNvbnN0IEIgPSBoLnJlZHVjZSgoTywgTCwgVikgPT4gbXQoTywgTCwgaWUoTCwgZC5vZmZzZXRUcmVlLCBSKSB8fCBWKSwgVXQoKSk7XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIC4uLmQsXG4gICAgICAgICAgICBncm91cEluZGljZXM6IGgsXG4gICAgICAgICAgICBncm91cE9mZnNldFRyZWU6IEJcbiAgICAgICAgICB9O1xuICAgICAgICB9KVxuICAgICAgKSxcbiAgICAgIElcbiAgICApLCBGKFxuICAgICAgeChcbiAgICAgICAgbyxcbiAgICAgICAgRyhJKSxcbiAgICAgICAgUCgoW2gsIHsgbGFzdEluZGV4OiBkIH1dKSA9PiBoIDwgZCksXG4gICAgICAgIEUoKFtoLCB7IGxhc3RJbmRleDogZCwgbGFzdFNpemU6IFIgfV0pID0+IFtcbiAgICAgICAgICB7XG4gICAgICAgICAgICBlbmRJbmRleDogZCxcbiAgICAgICAgICAgIHNpemU6IFIsXG4gICAgICAgICAgICBzdGFydEluZGV4OiBoXG4gICAgICAgICAgfVxuICAgICAgICBdKVxuICAgICAgKSxcbiAgICAgIG5cbiAgICApLCBGKHUsIGYpO1xuICAgIGNvbnN0IGcgPSBjdChcbiAgICAgIHgoXG4gICAgICAgIHUsXG4gICAgICAgIEUoKGgpID0+IGggPT09IHZvaWQgMClcbiAgICAgICksXG4gICAgICAhMFxuICAgICk7XG4gICAgRihcbiAgICAgIHgoXG4gICAgICAgIGYsXG4gICAgICAgIFAoKGgpID0+IGggIT09IHZvaWQgMCAmJiBqKGx0KEkpLnNpemVUcmVlKSksXG4gICAgICAgIEUoKGgpID0+IFt7IGVuZEluZGV4OiAwLCBzaXplOiBoLCBzdGFydEluZGV4OiAwIH1dKVxuICAgICAgKSxcbiAgICAgIG5cbiAgICApO1xuICAgIGNvbnN0IGEgPSBwdChcbiAgICAgIHgoXG4gICAgICAgIG4sXG4gICAgICAgIEcoSSksXG4gICAgICAgIGJ0KFxuICAgICAgICAgICh7IHNpemVzOiBoIH0sIFtkLCBSXSkgPT4gKHtcbiAgICAgICAgICAgIGNoYW5nZWQ6IFIgIT09IGgsXG4gICAgICAgICAgICBzaXplczogUlxuICAgICAgICAgIH0pLFxuICAgICAgICAgIHsgY2hhbmdlZDogITEsIHNpemVzOiB3IH1cbiAgICAgICAgKSxcbiAgICAgICAgRSgoaCkgPT4gaC5jaGFuZ2VkKVxuICAgICAgKVxuICAgICk7XG4gICAgSyhcbiAgICAgIHgoXG4gICAgICAgIGwsXG4gICAgICAgIGJ0KFxuICAgICAgICAgIChoLCBkKSA9PiAoeyBkaWZmOiBoLnByZXYgLSBkLCBwcmV2OiBkIH0pLFxuICAgICAgICAgIHsgZGlmZjogMCwgcHJldjogMCB9XG4gICAgICAgICksXG4gICAgICAgIEUoKGgpID0+IGguZGlmZilcbiAgICAgICksXG4gICAgICAoaCkgPT4ge1xuICAgICAgICBjb25zdCB7IGdyb3VwSW5kaWNlczogZCB9ID0gbHQoSSk7XG4gICAgICAgIGlmIChoID4gMClcbiAgICAgICAgICBXKGUsICEwKSwgVyhzLCBoICsgbW4oaCwgZCkpO1xuICAgICAgICBlbHNlIGlmIChoIDwgMCkge1xuICAgICAgICAgIGNvbnN0IFIgPSBsdChDKTtcbiAgICAgICAgICBSLmxlbmd0aCA+IDAgJiYgKGggLT0gbW4oLWgsIFIpKSwgVyhpLCBoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICksIEsoeChsLCBHKHQpKSwgKFtoLCBkXSkgPT4ge1xuICAgICAgaCA8IDAgJiYgZChcbiAgICAgICAgXCJgZmlyc3RJdGVtSW5kZXhgIHByb3Agc2hvdWxkIG5vdCBiZSBzZXQgdG8gbGVzcyB0aGFuIHplcm8uIElmIHlvdSBkb24ndCBrbm93IHRoZSB0b3RhbCBjb3VudCwganVzdCB1c2UgYSB2ZXJ5IGhpZ2ggdmFsdWVcIixcbiAgICAgICAgeyBmaXJzdEl0ZW1JbmRleDogbCB9LFxuICAgICAgICBodC5FUlJPUlxuICAgICAgKTtcbiAgICB9KTtcbiAgICBjb25zdCBUID0gcHQocyk7XG4gICAgRihcbiAgICAgIHgoXG4gICAgICAgIHMsXG4gICAgICAgIEcoSSksXG4gICAgICAgIEUoKFtoLCBkXSkgPT4ge1xuICAgICAgICAgIGNvbnN0IFIgPSBkLmdyb3VwSW5kaWNlcy5sZW5ndGggPiAwLCBCID0gW10sIE8gPSBkLmxhc3RTaXplO1xuICAgICAgICAgIGlmIChSKSB7XG4gICAgICAgICAgICBjb25zdCBMID0gcmUoZC5zaXplVHJlZSwgMCk7XG4gICAgICAgICAgICBsZXQgViA9IDAsIEQgPSAwO1xuICAgICAgICAgICAgZm9yICg7IFYgPCBoOyApIHtcbiAgICAgICAgICAgICAgY29uc3QgayA9IGQuZ3JvdXBJbmRpY2VzW0RdLCBxID0gZC5ncm91cEluZGljZXMubGVuZ3RoID09PSBEICsgMSA/IDEgLyAwIDogZC5ncm91cEluZGljZXNbRCArIDFdIC0gayAtIDE7XG4gICAgICAgICAgICAgIEIucHVzaCh7XG4gICAgICAgICAgICAgICAgZW5kSW5kZXg6IGssXG4gICAgICAgICAgICAgICAgc2l6ZTogTCxcbiAgICAgICAgICAgICAgICBzdGFydEluZGV4OiBrXG4gICAgICAgICAgICAgIH0pLCBCLnB1c2goe1xuICAgICAgICAgICAgICAgIGVuZEluZGV4OiBrICsgMSArIHEgLSAxLFxuICAgICAgICAgICAgICAgIHNpemU6IE8sXG4gICAgICAgICAgICAgICAgc3RhcnRJbmRleDogayArIDFcbiAgICAgICAgICAgICAgfSksIEQrKywgViArPSBxICsgMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IEogPSBfdChkLnNpemVUcmVlKTtcbiAgICAgICAgICAgIHJldHVybiBWICE9PSBoICYmIEouc2hpZnQoKSwgSi5yZWR1Y2UoXG4gICAgICAgICAgICAgIChrLCB7IGs6IHEsIHY6IHN0IH0pID0+IHtcbiAgICAgICAgICAgICAgICBsZXQgZHQgPSBrLnJhbmdlcztcbiAgICAgICAgICAgICAgICByZXR1cm4gay5wcmV2U2l6ZSAhPT0gMCAmJiAoZHQgPSBbXG4gICAgICAgICAgICAgICAgICAuLi5rLnJhbmdlcyxcbiAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgZW5kSW5kZXg6IHEgKyBoIC0gMSxcbiAgICAgICAgICAgICAgICAgICAgc2l6ZTogay5wcmV2U2l6ZSxcbiAgICAgICAgICAgICAgICAgICAgc3RhcnRJbmRleDogay5wcmV2SW5kZXhcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBdKSwge1xuICAgICAgICAgICAgICAgICAgcHJldkluZGV4OiBxICsgaCxcbiAgICAgICAgICAgICAgICAgIHByZXZTaXplOiBzdCxcbiAgICAgICAgICAgICAgICAgIHJhbmdlczogZHRcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgcHJldkluZGV4OiBoLFxuICAgICAgICAgICAgICAgIHByZXZTaXplOiAwLFxuICAgICAgICAgICAgICAgIHJhbmdlczogQlxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICApLnJhbmdlcztcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIF90KGQuc2l6ZVRyZWUpLnJlZHVjZShcbiAgICAgICAgICAgIChMLCB7IGs6IFYsIHY6IEQgfSkgPT4gKHtcbiAgICAgICAgICAgICAgcHJldkluZGV4OiBWICsgaCxcbiAgICAgICAgICAgICAgcHJldlNpemU6IEQsXG4gICAgICAgICAgICAgIHJhbmdlczogWy4uLkwucmFuZ2VzLCB7IGVuZEluZGV4OiBWICsgaCAtIDEsIHNpemU6IEwucHJldlNpemUsIHN0YXJ0SW5kZXg6IEwucHJldkluZGV4IH1dXG4gICAgICAgICAgICB9KSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgcHJldkluZGV4OiAwLFxuICAgICAgICAgICAgICBwcmV2U2l6ZTogTyxcbiAgICAgICAgICAgICAgcmFuZ2VzOiBbXVxuICAgICAgICAgICAgfVxuICAgICAgICAgICkucmFuZ2VzO1xuICAgICAgICB9KVxuICAgICAgKSxcbiAgICAgIG5cbiAgICApO1xuICAgIGNvbnN0IGIgPSBwdChcbiAgICAgIHgoXG4gICAgICAgIGksXG4gICAgICAgIEcoSSwgbSksXG4gICAgICAgIEUoKFtoLCB7IG9mZnNldFRyZWU6IGQgfSwgUl0pID0+IHtcbiAgICAgICAgICBjb25zdCBCID0gLWg7XG4gICAgICAgICAgcmV0dXJuIGllKEIsIGQsIFIpO1xuICAgICAgICB9KVxuICAgICAgKVxuICAgICk7XG4gICAgcmV0dXJuIEYoXG4gICAgICB4KFxuICAgICAgICBpLFxuICAgICAgICBHKEksIG0pLFxuICAgICAgICBFKChbaCwgZCwgUl0pID0+IHtcbiAgICAgICAgICBpZiAoZC5ncm91cEluZGljZXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgaWYgKGooZC5zaXplVHJlZSkpXG4gICAgICAgICAgICAgIHJldHVybiBkO1xuICAgICAgICAgICAgbGV0IE8gPSBVdCgpO1xuICAgICAgICAgICAgY29uc3QgTCA9IGx0KEMpO1xuICAgICAgICAgICAgbGV0IFYgPSAwLCBEID0gMCwgSiA9IDA7XG4gICAgICAgICAgICBmb3IgKDsgViA8IC1oOyApIHtcbiAgICAgICAgICAgICAgSiA9IExbRF07XG4gICAgICAgICAgICAgIGNvbnN0IGsgPSBMW0QgKyAxXSAtIEogLSAxO1xuICAgICAgICAgICAgICBEKyssIFYgKz0gayArIDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoTyA9IF90KGQuc2l6ZVRyZWUpLnJlZHVjZSgoaywgeyBrOiBxLCB2OiBzdCB9KSA9PiBtdChrLCBNYXRoLm1heCgwLCBxICsgaCksIHN0KSwgTyksIFYgIT09IC1oKSB7XG4gICAgICAgICAgICAgIGNvbnN0IGsgPSByZShkLnNpemVUcmVlLCBKKTtcbiAgICAgICAgICAgICAgTyA9IG10KE8sIDAsIGspO1xuICAgICAgICAgICAgICBjb25zdCBxID0gQ3QoZC5zaXplVHJlZSwgLWggKyAxKVsxXTtcbiAgICAgICAgICAgICAgTyA9IG10KE8sIDEsIHEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgLi4uZCxcbiAgICAgICAgICAgICAgc2l6ZVRyZWU6IE8sXG4gICAgICAgICAgICAgIC4uLlBlKGQub2Zmc2V0VHJlZSwgMCwgTywgUilcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IE8gPSBfdChkLnNpemVUcmVlKS5yZWR1Y2UoKEwsIHsgazogViwgdjogRCB9KSA9PiBtdChMLCBNYXRoLm1heCgwLCBWICsgaCksIEQpLCBVdCgpKTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgIC4uLmQsXG4gICAgICAgICAgICAgIHNpemVUcmVlOiBPLFxuICAgICAgICAgICAgICAuLi5QZShkLm9mZnNldFRyZWUsIDAsIE8sIFIpXG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH1cbiAgICAgICAgfSlcbiAgICAgICksXG4gICAgICBJXG4gICAgKSwge1xuICAgICAgYmVmb3JlVW5zaGlmdFdpdGg6IFQsXG4gICAgICAvLyBpbnB1dFxuICAgICAgZGF0YTogcCxcbiAgICAgIGRlZmF1bHRJdGVtU2l6ZTogZixcbiAgICAgIGZpcnN0SXRlbUluZGV4OiBsLFxuICAgICAgZml4ZWRJdGVtU2l6ZTogdSxcbiAgICAgIGdhcDogbSxcbiAgICAgIGdyb3VwSW5kaWNlczogYyxcbiAgICAgIGl0ZW1TaXplOiBTLFxuICAgICAgbGlzdFJlZnJlc2g6IGEsXG4gICAgICBzaGlmdFdpdGg6IGksXG4gICAgICBzaGlmdFdpdGhPZmZzZXQ6IGIsXG4gICAgICBzaXplUmFuZ2VzOiBuLFxuICAgICAgLy8gb3V0cHV0XG4gICAgICBzaXplczogSSxcbiAgICAgIHN0YXRlZnVsVG90YWxDb3VudDogcixcbiAgICAgIHRvdGFsQ291bnQ6IG8sXG4gICAgICB0cmFja0l0ZW1TaXplczogZyxcbiAgICAgIHVuc2hpZnRXaXRoOiBzXG4gICAgfTtcbiAgfSxcbiAgWChWdCwgTmUpLFxuICB7IHNpbmdsZXRvbjogITAgfVxuKTtcbmZ1bmN0aW9uIE9vKHQpIHtcbiAgcmV0dXJuIHQucmVkdWNlKFxuICAgIChlLCBuKSA9PiAoZS5ncm91cEluZGljZXMucHVzaChlLnRvdGFsQ291bnQpLCBlLnRvdGFsQ291bnQgKz0gbiArIDEsIGUpLFxuICAgIHtcbiAgICAgIGdyb3VwSW5kaWNlczogW10sXG4gICAgICB0b3RhbENvdW50OiAwXG4gICAgfVxuICApO1xufVxuY29uc3QgR24gPSBVKFxuICAoW3sgZ3JvdXBJbmRpY2VzOiB0LCBzaXplczogZSwgdG90YWxDb3VudDogbiB9LCB7IGhlYWRlckhlaWdodDogbywgc2Nyb2xsVG9wOiByIH1dKSA9PiB7XG4gICAgY29uc3QgcyA9ICQoKSwgaSA9ICQoKSwgbCA9IHB0KHgocywgRShPbykpKTtcbiAgICByZXR1cm4gRihcbiAgICAgIHgoXG4gICAgICAgIGwsXG4gICAgICAgIEUoKGMpID0+IGMudG90YWxDb3VudClcbiAgICAgICksXG4gICAgICBuXG4gICAgKSwgRihcbiAgICAgIHgoXG4gICAgICAgIGwsXG4gICAgICAgIEUoKGMpID0+IGMuZ3JvdXBJbmRpY2VzKVxuICAgICAgKSxcbiAgICAgIHRcbiAgICApLCBGKFxuICAgICAgeChcbiAgICAgICAgcnQociwgZSwgbyksXG4gICAgICAgIFAoKFtjLCB1XSkgPT4gYmUodSkpLFxuICAgICAgICBFKChbYywgdSwgZl0pID0+IEN0KHUuZ3JvdXBPZmZzZXRUcmVlLCBNYXRoLm1heChjIC0gZiwgMCksIFwidlwiKVswXSksXG4gICAgICAgIFkoKSxcbiAgICAgICAgRSgoYykgPT4gW2NdKVxuICAgICAgKSxcbiAgICAgIGlcbiAgICApLCB7IGdyb3VwQ291bnRzOiBzLCB0b3BJdGVtc0luZGV4ZXM6IGkgfTtcbiAgfSxcbiAgWChFdCwgYXQpXG4pLCBQdCA9IFUoXG4gIChbeyBsb2c6IHQgfV0pID0+IHtcbiAgICBjb25zdCBlID0geSghMSksIG4gPSBwdChcbiAgICAgIHgoXG4gICAgICAgIGUsXG4gICAgICAgIFAoKG8pID0+IG8pLFxuICAgICAgICBZKClcbiAgICAgIClcbiAgICApO1xuICAgIHJldHVybiBLKGUsIChvKSA9PiB7XG4gICAgICBvICYmIGx0KHQpKFwicHJvcHMgdXBkYXRlZFwiLCB7fSwgaHQuREVCVUcpO1xuICAgIH0pLCB7IGRpZE1vdW50OiBuLCBwcm9wc1JlYWR5OiBlIH07XG4gIH0sXG4gIFgoVnQpLFxuICB7IHNpbmdsZXRvbjogITAgfVxuKSwgRm8gPSB0eXBlb2YgZG9jdW1lbnQgPCBcInVcIiAmJiBcInNjcm9sbEJlaGF2aW9yXCIgaW4gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnN0eWxlO1xuZnVuY3Rpb24gTm4odCkge1xuICBjb25zdCBlID0gdHlwZW9mIHQgPT0gXCJudW1iZXJcIiA/IHsgaW5kZXg6IHQgfSA6IHQ7XG4gIHJldHVybiBlLmFsaWduIHx8IChlLmFsaWduID0gXCJzdGFydFwiKSwgKCFlLmJlaGF2aW9yIHx8ICFGbykgJiYgKGUuYmVoYXZpb3IgPSBcImF1dG9cIiksIGUub2Zmc2V0IHx8IChlLm9mZnNldCA9IDApLCBlO1xufVxuY29uc3QgY2UgPSBVKFxuICAoW1xuICAgIHsgZ2FwOiB0LCBsaXN0UmVmcmVzaDogZSwgc2l6ZXM6IG4sIHRvdGFsQ291bnQ6IG8gfSxcbiAgICB7XG4gICAgICBmaXhlZEZvb3RlckhlaWdodDogcixcbiAgICAgIGZpeGVkSGVhZGVySGVpZ2h0OiBzLFxuICAgICAgZm9vdGVySGVpZ2h0OiBpLFxuICAgICAgaGVhZGVySGVpZ2h0OiBsLFxuICAgICAgc2Nyb2xsaW5nSW5Qcm9ncmVzczogYyxcbiAgICAgIHNjcm9sbFRvOiB1LFxuICAgICAgc21vb3RoU2Nyb2xsVGFyZ2V0UmVhY2hlZDogZixcbiAgICAgIHZpZXdwb3J0SGVpZ2h0OiBTXG4gICAgfSxcbiAgICB7IGxvZzogcCB9XG4gIF0pID0+IHtcbiAgICBjb25zdCBtID0gJCgpLCB3ID0gJCgpLCBJID0geSgwKTtcbiAgICBsZXQgQyA9IG51bGwsIGcgPSBudWxsLCBhID0gbnVsbDtcbiAgICBmdW5jdGlvbiBUKCkge1xuICAgICAgQyAmJiAoQygpLCBDID0gbnVsbCksIGEgJiYgKGEoKSwgYSA9IG51bGwpLCBnICYmIChjbGVhclRpbWVvdXQoZyksIGcgPSBudWxsKSwgVyhjLCAhMSk7XG4gICAgfVxuICAgIHJldHVybiBGKFxuICAgICAgeChcbiAgICAgICAgbSxcbiAgICAgICAgRyhuLCBTLCBvLCBJLCBsLCBpLCBwKSxcbiAgICAgICAgRyh0LCBzLCByKSxcbiAgICAgICAgRShcbiAgICAgICAgICAoW1xuICAgICAgICAgICAgW2IsIGgsIGQsIFIsIEIsIE8sIEwsIFZdLFxuICAgICAgICAgICAgRCxcbiAgICAgICAgICAgIEosXG4gICAgICAgICAgICBudFxuICAgICAgICAgIF0pID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGsgPSBObihiKSwgeyBhbGlnbjogcSwgYmVoYXZpb3I6IHN0LCBvZmZzZXQ6IGR0IH0gPSBrLCBTdCA9IFIgLSAxLCBmdCA9IF9uKGssIGgsIFN0KTtcbiAgICAgICAgICAgIGxldCB1dCA9IGllKGZ0LCBoLm9mZnNldFRyZWUsIEQpICsgTztcbiAgICAgICAgICAgIHEgPT09IFwiZW5kXCIgPyAodXQgKz0gSiArIEN0KGguc2l6ZVRyZWUsIGZ0KVsxXSAtIGQgKyBudCwgZnQgPT09IFN0ICYmICh1dCArPSBMKSkgOiBxID09PSBcImNlbnRlclwiID8gdXQgKz0gKEogKyBDdChoLnNpemVUcmVlLCBmdClbMV0gLSBkICsgbnQpIC8gMiA6IHV0IC09IEIsIGR0ICYmICh1dCArPSBkdCk7XG4gICAgICAgICAgICBjb25zdCBBdCA9ICh4dCkgPT4ge1xuICAgICAgICAgICAgICBUKCksIHh0ID8gKFYoXCJyZXRyeWluZyB0byBzY3JvbGwgdG9cIiwgeyBsb2NhdGlvbjogYiB9LCBodC5ERUJVRyksIFcobSwgYikpIDogKFcodywgITApLCBWKFwibGlzdCBkaWQgbm90IGNoYW5nZSwgc2Nyb2xsIHN1Y2Nlc3NmdWxcIiwge30sIGh0LkRFQlVHKSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgaWYgKFQoKSwgc3QgPT09IFwic21vb3RoXCIpIHtcbiAgICAgICAgICAgICAgbGV0IHh0ID0gITE7XG4gICAgICAgICAgICAgIGEgPSBLKGUsIChYdCkgPT4ge1xuICAgICAgICAgICAgICAgIHh0ID0geHQgfHwgWHQ7XG4gICAgICAgICAgICAgIH0pLCBDID0gUnQoZiwgKCkgPT4ge1xuICAgICAgICAgICAgICAgIEF0KHh0KTtcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9IGVsc2VcbiAgICAgICAgICAgICAgQyA9IFJ0KHgoZSwgTG8oMTUwKSksIEF0KTtcbiAgICAgICAgICAgIHJldHVybiBnID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICAgIFQoKTtcbiAgICAgICAgICAgIH0sIDEyMDApLCBXKGMsICEwKSwgVihcInNjcm9sbGluZyBmcm9tIGluZGV4IHRvXCIsIHsgYmVoYXZpb3I6IHN0LCBpbmRleDogZnQsIHRvcDogdXQgfSwgaHQuREVCVUcpLCB7IGJlaGF2aW9yOiBzdCwgdG9wOiB1dCB9O1xuICAgICAgICAgIH1cbiAgICAgICAgKVxuICAgICAgKSxcbiAgICAgIHVcbiAgICApLCB7XG4gICAgICBzY3JvbGxUYXJnZXRSZWFjaGVkOiB3LFxuICAgICAgc2Nyb2xsVG9JbmRleDogbSxcbiAgICAgIHRvcExpc3RIZWlnaHQ6IElcbiAgICB9O1xuICB9LFxuICBYKEV0LCBhdCwgVnQpLFxuICB7IHNpbmdsZXRvbjogITAgfVxuKTtcbmZ1bmN0aW9uIExvKHQpIHtcbiAgcmV0dXJuIChlKSA9PiB7XG4gICAgY29uc3QgbiA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgZSghMSk7XG4gICAgfSwgdCk7XG4gICAgcmV0dXJuIChvKSA9PiB7XG4gICAgICBvICYmIChlKCEwKSwgY2xlYXJUaW1lb3V0KG4pKTtcbiAgICB9O1xuICB9O1xufVxuZnVuY3Rpb24gJGUodCwgZSkge1xuICB0ID09IDAgPyBlKCkgOiByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCkgPT4ge1xuICAgICRlKHQgLSAxLCBlKTtcbiAgfSk7XG59XG5mdW5jdGlvbiBVZSh0LCBlKSB7XG4gIGNvbnN0IG4gPSBlIC0gMTtcbiAgcmV0dXJuIHR5cGVvZiB0ID09IFwibnVtYmVyXCIgPyB0IDogdC5pbmRleCA9PT0gXCJMQVNUXCIgPyBuIDogdC5pbmRleDtcbn1cbmNvbnN0IHVlID0gVShcbiAgKFt7IGRlZmF1bHRJdGVtU2l6ZTogdCwgbGlzdFJlZnJlc2g6IGUsIHNpemVzOiBuIH0sIHsgc2Nyb2xsVG9wOiBvIH0sIHsgc2Nyb2xsVGFyZ2V0UmVhY2hlZDogciwgc2Nyb2xsVG9JbmRleDogcyB9LCB7IGRpZE1vdW50OiBpIH1dKSA9PiB7XG4gICAgY29uc3QgbCA9IHkoITApLCBjID0geSgwKSwgdSA9IHkoITApO1xuICAgIHJldHVybiBGKFxuICAgICAgeChcbiAgICAgICAgaSxcbiAgICAgICAgRyhjKSxcbiAgICAgICAgUCgoW2YsIFNdKSA9PiAhIVMpLFxuICAgICAgICB2dCghMSlcbiAgICAgICksXG4gICAgICBsXG4gICAgKSwgRihcbiAgICAgIHgoXG4gICAgICAgIGksXG4gICAgICAgIEcoYyksXG4gICAgICAgIFAoKFtmLCBTXSkgPT4gISFTKSxcbiAgICAgICAgdnQoITEpXG4gICAgICApLFxuICAgICAgdVxuICAgICksIEsoXG4gICAgICB4KFxuICAgICAgICBydChlLCBpKSxcbiAgICAgICAgRyhsLCBuLCB0LCB1KSxcbiAgICAgICAgUCgoW1ssIGZdLCBTLCB7IHNpemVUcmVlOiBwIH0sIG0sIHddKSA9PiBmICYmICghaihwKSB8fCBNZShtKSkgJiYgIVMgJiYgIXcpLFxuICAgICAgICBHKGMpXG4gICAgICApLFxuICAgICAgKFssIGZdKSA9PiB7XG4gICAgICAgIFJ0KHIsICgpID0+IHtcbiAgICAgICAgICBXKHUsICEwKTtcbiAgICAgICAgfSksICRlKDQsICgpID0+IHtcbiAgICAgICAgICBSdChvLCAoKSA9PiB7XG4gICAgICAgICAgICBXKGwsICEwKTtcbiAgICAgICAgICB9KSwgVyhzLCBmKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgKSwge1xuICAgICAgaW5pdGlhbEl0ZW1GaW5hbExvY2F0aW9uUmVhY2hlZDogdSxcbiAgICAgIGluaXRpYWxUb3BNb3N0SXRlbUluZGV4OiBjLFxuICAgICAgc2Nyb2xsZWRUb0luaXRpYWxJdGVtOiBsXG4gICAgfTtcbiAgfSxcbiAgWChFdCwgYXQsIGNlLCBQdCksXG4gIHsgc2luZ2xldG9uOiAhMCB9XG4pO1xuZnVuY3Rpb24gRG4odCwgZSkge1xuICByZXR1cm4gTWF0aC5hYnModCAtIGUpIDwgMS4wMTtcbn1cbmNvbnN0IGxlID0gXCJ1cFwiLCB0ZSA9IFwiZG93blwiLCB6byA9IFwibm9uZVwiLCBWbyA9IHtcbiAgYXRCb3R0b206ICExLFxuICBub3RBdEJvdHRvbUJlY2F1c2U6IFwiTk9UX1NIT1dJTkdfTEFTVF9JVEVNXCIsXG4gIHN0YXRlOiB7XG4gICAgb2Zmc2V0Qm90dG9tOiAwLFxuICAgIHNjcm9sbEhlaWdodDogMCxcbiAgICBzY3JvbGxUb3A6IDAsXG4gICAgdmlld3BvcnRIZWlnaHQ6IDBcbiAgfVxufSwgUG8gPSAwLCBhZSA9IFUoKFt7IGZvb3RlckhlaWdodDogdCwgaGVhZGVySGVpZ2h0OiBlLCBzY3JvbGxCeTogbiwgc2Nyb2xsQ29udGFpbmVyU3RhdGU6IG8sIHNjcm9sbFRvcDogciwgdmlld3BvcnRIZWlnaHQ6IHMgfV0pID0+IHtcbiAgY29uc3QgaSA9IHkoITEpLCBsID0geSghMCksIGMgPSAkKCksIHUgPSAkKCksIGYgPSB5KDQpLCBTID0geShQbyksIHAgPSBjdChcbiAgICB4KFxuICAgICAgYW4oeChBKHIpLCBqdCgxKSwgdnQoITApKSwgeChBKHIpLCBqdCgxKSwgdnQoITEpLCB1bigxMDApKSksXG4gICAgICBZKClcbiAgICApLFxuICAgICExXG4gICksIG0gPSBjdChcbiAgICB4KGFuKHgobiwgdnQoITApKSwgeChuLCB2dCghMSksIHVuKDIwMCkpKSwgWSgpKSxcbiAgICAhMVxuICApO1xuICBGKFxuICAgIHgoXG4gICAgICBydChBKHIpLCBBKFMpKSxcbiAgICAgIEUoKFthLCBUXSkgPT4gYSA8PSBUKSxcbiAgICAgIFkoKVxuICAgICksXG4gICAgbFxuICApLCBGKHgobCwgTHQoNTApKSwgdSk7XG4gIGNvbnN0IHcgPSBwdChcbiAgICB4KFxuICAgICAgcnQobywgQShzKSwgQShlKSwgQSh0KSwgQShmKSksXG4gICAgICBidCgoYSwgW3sgc2Nyb2xsSGVpZ2h0OiBULCBzY3JvbGxUb3A6IGIgfSwgaCwgZCwgUiwgQl0pID0+IHtcbiAgICAgICAgY29uc3QgTyA9IGIgKyBoIC0gVCA+IC1CLCBMID0ge1xuICAgICAgICAgIHNjcm9sbEhlaWdodDogVCxcbiAgICAgICAgICBzY3JvbGxUb3A6IGIsXG4gICAgICAgICAgdmlld3BvcnRIZWlnaHQ6IGhcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKE8pIHtcbiAgICAgICAgICBsZXQgRCwgSjtcbiAgICAgICAgICByZXR1cm4gYiA+IGEuc3RhdGUuc2Nyb2xsVG9wID8gKEQgPSBcIlNDUk9MTEVEX0RPV05cIiwgSiA9IGEuc3RhdGUuc2Nyb2xsVG9wIC0gYikgOiAoRCA9IFwiU0laRV9ERUNSRUFTRURcIiwgSiA9IGEuc3RhdGUuc2Nyb2xsVG9wIC0gYiB8fCBhLnNjcm9sbFRvcERlbHRhKSwge1xuICAgICAgICAgICAgYXRCb3R0b206ICEwLFxuICAgICAgICAgICAgYXRCb3R0b21CZWNhdXNlOiBELFxuICAgICAgICAgICAgc2Nyb2xsVG9wRGVsdGE6IEosXG4gICAgICAgICAgICBzdGF0ZTogTFxuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgbGV0IFY7XG4gICAgICAgIHJldHVybiBMLnNjcm9sbEhlaWdodCA+IGEuc3RhdGUuc2Nyb2xsSGVpZ2h0ID8gViA9IFwiU0laRV9JTkNSRUFTRURcIiA6IGggPCBhLnN0YXRlLnZpZXdwb3J0SGVpZ2h0ID8gViA9IFwiVklFV1BPUlRfSEVJR0hUX0RFQ1JFQVNJTkdcIiA6IGIgPCBhLnN0YXRlLnNjcm9sbFRvcCA/IFYgPSBcIlNDUk9MTElOR19VUFdBUkRTXCIgOiBWID0gXCJOT1RfRlVMTFlfU0NST0xMRURfVE9fTEFTVF9JVEVNX0JPVFRPTVwiLCB7XG4gICAgICAgICAgYXRCb3R0b206ICExLFxuICAgICAgICAgIG5vdEF0Qm90dG9tQmVjYXVzZTogVixcbiAgICAgICAgICBzdGF0ZTogTFxuICAgICAgICB9O1xuICAgICAgfSwgVm8pLFxuICAgICAgWSgoYSwgVCkgPT4gYSAmJiBhLmF0Qm90dG9tID09PSBULmF0Qm90dG9tKVxuICAgIClcbiAgKSwgSSA9IGN0KFxuICAgIHgoXG4gICAgICBvLFxuICAgICAgYnQoXG4gICAgICAgIChhLCB7IHNjcm9sbEhlaWdodDogVCwgc2Nyb2xsVG9wOiBiLCB2aWV3cG9ydEhlaWdodDogaCB9KSA9PiB7XG4gICAgICAgICAgaWYgKERuKGEuc2Nyb2xsSGVpZ2h0LCBUKSlcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgIGNoYW5nZWQ6ICExLFxuICAgICAgICAgICAgICBqdW1wOiAwLFxuICAgICAgICAgICAgICBzY3JvbGxIZWlnaHQ6IFQsXG4gICAgICAgICAgICAgIHNjcm9sbFRvcDogYlxuICAgICAgICAgICAgfTtcbiAgICAgICAgICB7XG4gICAgICAgICAgICBjb25zdCBkID0gVCAtIChiICsgaCkgPCAxO1xuICAgICAgICAgICAgcmV0dXJuIGEuc2Nyb2xsVG9wICE9PSBiICYmIGQgPyB7XG4gICAgICAgICAgICAgIGNoYW5nZWQ6ICEwLFxuICAgICAgICAgICAgICBqdW1wOiBhLnNjcm9sbFRvcCAtIGIsXG4gICAgICAgICAgICAgIHNjcm9sbEhlaWdodDogVCxcbiAgICAgICAgICAgICAgc2Nyb2xsVG9wOiBiXG4gICAgICAgICAgICB9IDoge1xuICAgICAgICAgICAgICBjaGFuZ2VkOiAhMCxcbiAgICAgICAgICAgICAganVtcDogMCxcbiAgICAgICAgICAgICAgc2Nyb2xsSGVpZ2h0OiBULFxuICAgICAgICAgICAgICBzY3JvbGxUb3A6IGJcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB7IGNoYW5nZWQ6ICExLCBqdW1wOiAwLCBzY3JvbGxIZWlnaHQ6IDAsIHNjcm9sbFRvcDogMCB9XG4gICAgICApLFxuICAgICAgUCgoYSkgPT4gYS5jaGFuZ2VkKSxcbiAgICAgIEUoKGEpID0+IGEuanVtcClcbiAgICApLFxuICAgIDBcbiAgKTtcbiAgRihcbiAgICB4KFxuICAgICAgdyxcbiAgICAgIEUoKGEpID0+IGEuYXRCb3R0b20pXG4gICAgKSxcbiAgICBpXG4gICksIEYoeChpLCBMdCg1MCkpLCBjKTtcbiAgY29uc3QgQyA9IHkodGUpO1xuICBGKFxuICAgIHgoXG4gICAgICBvLFxuICAgICAgRSgoeyBzY3JvbGxUb3A6IGEgfSkgPT4gYSksXG4gICAgICBZKCksXG4gICAgICBidChcbiAgICAgICAgKGEsIFQpID0+IGx0KG0pID8geyBkaXJlY3Rpb246IGEuZGlyZWN0aW9uLCBwcmV2U2Nyb2xsVG9wOiBUIH0gOiB7IGRpcmVjdGlvbjogVCA8IGEucHJldlNjcm9sbFRvcCA/IGxlIDogdGUsIHByZXZTY3JvbGxUb3A6IFQgfSxcbiAgICAgICAgeyBkaXJlY3Rpb246IHRlLCBwcmV2U2Nyb2xsVG9wOiAwIH1cbiAgICAgICksXG4gICAgICBFKChhKSA9PiBhLmRpcmVjdGlvbilcbiAgICApLFxuICAgIENcbiAgKSwgRih4KG8sIEx0KDUwKSwgdnQoem8pKSwgQyk7XG4gIGNvbnN0IGcgPSB5KDApO1xuICByZXR1cm4gRihcbiAgICB4KFxuICAgICAgcCxcbiAgICAgIFAoKGEpID0+ICFhKSxcbiAgICAgIHZ0KDApXG4gICAgKSxcbiAgICBnXG4gICksIEYoXG4gICAgeChcbiAgICAgIHIsXG4gICAgICBMdCgxMDApLFxuICAgICAgRyhwKSxcbiAgICAgIFAoKFthLCBUXSkgPT4gISFUKSxcbiAgICAgIGJ0KChbYSwgVF0sIFtiXSkgPT4gW1QsIGJdLCBbMCwgMF0pLFxuICAgICAgRSgoW2EsIFRdKSA9PiBUIC0gYSlcbiAgICApLFxuICAgIGdcbiAgKSwge1xuICAgIGF0Qm90dG9tU3RhdGU6IHcsXG4gICAgYXRCb3R0b21TdGF0ZUNoYW5nZTogYyxcbiAgICBhdEJvdHRvbVRocmVzaG9sZDogZixcbiAgICBhdFRvcFN0YXRlQ2hhbmdlOiB1LFxuICAgIGF0VG9wVGhyZXNob2xkOiBTLFxuICAgIGlzQXRCb3R0b206IGksXG4gICAgaXNBdFRvcDogbCxcbiAgICBpc1Njcm9sbGluZzogcCxcbiAgICBsYXN0SnVtcER1ZVRvSXRlbVJlc2l6ZTogSSxcbiAgICBzY3JvbGxEaXJlY3Rpb246IEMsXG4gICAgc2Nyb2xsVmVsb2NpdHk6IGdcbiAgfTtcbn0sIFgoYXQpKSwgeGUgPSBcInRvcFwiLCBUZSA9IFwiYm90dG9tXCIsIHBuID0gXCJub25lXCI7XG5mdW5jdGlvbiBobih0LCBlLCBuKSB7XG4gIHJldHVybiB0eXBlb2YgdCA9PSBcIm51bWJlclwiID8gbiA9PT0gbGUgJiYgZSA9PT0geGUgfHwgbiA9PT0gdGUgJiYgZSA9PT0gVGUgPyB0IDogMCA6IG4gPT09IGxlID8gZSA9PT0geGUgPyB0Lm1haW4gOiB0LnJldmVyc2UgOiBlID09PSBUZSA/IHQubWFpbiA6IHQucmV2ZXJzZTtcbn1cbmZ1bmN0aW9uIGduKHQsIGUpIHtcbiAgdmFyIG47XG4gIHJldHVybiB0eXBlb2YgdCA9PSBcIm51bWJlclwiID8gdCA6IChuID0gdFtlXSkgIT0gbnVsbCA/IG4gOiAwO1xufVxuY29uc3QgS2UgPSBVKFxuICAoW3sgZGV2aWF0aW9uOiB0LCBmaXhlZEhlYWRlckhlaWdodDogZSwgaGVhZGVySGVpZ2h0OiBuLCBzY3JvbGxUb3A6IG8sIHZpZXdwb3J0SGVpZ2h0OiByIH1dKSA9PiB7XG4gICAgY29uc3QgcyA9ICQoKSwgaSA9IHkoMCksIGwgPSB5KDApLCBjID0geSgwKSwgdSA9IGN0KFxuICAgICAgeChcbiAgICAgICAgcnQoXG4gICAgICAgICAgQShvKSxcbiAgICAgICAgICBBKHIpLFxuICAgICAgICAgIEEobiksXG4gICAgICAgICAgQShzLCBzZSksXG4gICAgICAgICAgQShjKSxcbiAgICAgICAgICBBKGkpLFxuICAgICAgICAgIEEoZSksXG4gICAgICAgICAgQSh0KSxcbiAgICAgICAgICBBKGwpXG4gICAgICAgICksXG4gICAgICAgIEUoXG4gICAgICAgICAgKFtcbiAgICAgICAgICAgIGYsXG4gICAgICAgICAgICBTLFxuICAgICAgICAgICAgcCxcbiAgICAgICAgICAgIFttLCB3XSxcbiAgICAgICAgICAgIEksXG4gICAgICAgICAgICBDLFxuICAgICAgICAgICAgZyxcbiAgICAgICAgICAgIGEsXG4gICAgICAgICAgICBUXG4gICAgICAgICAgXSkgPT4ge1xuICAgICAgICAgICAgY29uc3QgYiA9IGYgLSBhLCBoID0gQyArIGcsIGQgPSBNYXRoLm1heChwIC0gYiwgMCk7XG4gICAgICAgICAgICBsZXQgUiA9IHBuO1xuICAgICAgICAgICAgY29uc3QgQiA9IGduKFQsIHhlKSwgTyA9IGduKFQsIFRlKTtcbiAgICAgICAgICAgIHJldHVybiBtIC09IGEsIG0gKz0gcCArIGcsIHcgKz0gcCArIGcsIHcgLT0gYSwgbSA+IGYgKyBoIC0gQiAmJiAoUiA9IGxlKSwgdyA8IGYgLSBkICsgUyArIE8gJiYgKFIgPSB0ZSksIFIgIT09IHBuID8gW1xuICAgICAgICAgICAgICBNYXRoLm1heChiIC0gcCAtIGhuKEksIHhlLCBSKSAtIEIsIDApLFxuICAgICAgICAgICAgICBiIC0gZCAtIGcgKyBTICsgaG4oSSwgVGUsIFIpICsgT1xuICAgICAgICAgICAgXSA6IG51bGw7XG4gICAgICAgICAgfVxuICAgICAgICApLFxuICAgICAgICBQKChmKSA9PiBmICE9IG51bGwpLFxuICAgICAgICBZKHNlKVxuICAgICAgKSxcbiAgICAgIFswLCAwXVxuICAgICk7XG4gICAgcmV0dXJuIHtcbiAgICAgIGluY3JlYXNlVmlld3BvcnRCeTogbCxcbiAgICAgIC8vIGlucHV0XG4gICAgICBsaXN0Qm91bmRhcnk6IHMsXG4gICAgICBvdmVyc2NhbjogYyxcbiAgICAgIHRvcExpc3RIZWlnaHQ6IGksXG4gICAgICAvLyBvdXRwdXRcbiAgICAgIHZpc2libGVSYW5nZTogdVxuICAgIH07XG4gIH0sXG4gIFgoYXQpLFxuICB7IHNpbmdsZXRvbjogITAgfVxuKTtcbmZ1bmN0aW9uIEFvKHQsIGUsIG4pIHtcbiAgaWYgKGJlKGUpKSB7XG4gICAgY29uc3QgbyA9IFduKHQsIGUpO1xuICAgIHJldHVybiBbXG4gICAgICB7IGluZGV4OiBDdChlLmdyb3VwT2Zmc2V0VHJlZSwgbylbMF0sIG9mZnNldDogMCwgc2l6ZTogMCB9LFxuICAgICAgeyBkYXRhOiBuID09IG51bGwgPyB2b2lkIDAgOiBuWzBdLCBpbmRleDogbywgb2Zmc2V0OiAwLCBzaXplOiAwIH1cbiAgICBdO1xuICB9XG4gIHJldHVybiBbeyBkYXRhOiBuID09IG51bGwgPyB2b2lkIDAgOiBuWzBdLCBpbmRleDogdCwgb2Zmc2V0OiAwLCBzaXplOiAwIH1dO1xufVxuY29uc3Qga2UgPSB7XG4gIGJvdHRvbTogMCxcbiAgZmlyc3RJdGVtSW5kZXg6IDAsXG4gIGl0ZW1zOiBbXSxcbiAgb2Zmc2V0Qm90dG9tOiAwLFxuICBvZmZzZXRUb3A6IDAsXG4gIHRvcDogMCxcbiAgdG9wSXRlbXM6IFtdLFxuICB0b3BMaXN0SGVpZ2h0OiAwLFxuICB0b3RhbENvdW50OiAwXG59O1xuZnVuY3Rpb24gSWUodCwgZSwgbiwgbywgciwgcykge1xuICBjb25zdCB7IGxhc3RJbmRleDogaSwgbGFzdE9mZnNldDogbCwgbGFzdFNpemU6IGMgfSA9IHI7XG4gIGxldCB1ID0gMCwgZiA9IDA7XG4gIGlmICh0Lmxlbmd0aCA+IDApIHtcbiAgICB1ID0gdFswXS5vZmZzZXQ7XG4gICAgY29uc3QgSSA9IHRbdC5sZW5ndGggLSAxXTtcbiAgICBmID0gSS5vZmZzZXQgKyBJLnNpemU7XG4gIH1cbiAgY29uc3QgUyA9IG4gLSBpLCBwID0gbCArIFMgKiBjICsgKFMgLSAxKSAqIG8sIG0gPSB1LCB3ID0gcCAtIGY7XG4gIHJldHVybiB7XG4gICAgYm90dG9tOiBmLFxuICAgIGZpcnN0SXRlbUluZGV4OiBzLFxuICAgIGl0ZW1zOiBJbih0LCByLCBzKSxcbiAgICBvZmZzZXRCb3R0b206IHcsXG4gICAgb2Zmc2V0VG9wOiB1LFxuICAgIHRvcDogbSxcbiAgICB0b3BJdGVtczogSW4oZSwgciwgcyksXG4gICAgdG9wTGlzdEhlaWdodDogZS5yZWR1Y2UoKEksIEMpID0+IEMuc2l6ZSArIEksIDApLFxuICAgIHRvdGFsQ291bnQ6IG5cbiAgfTtcbn1cbmZ1bmN0aW9uICRuKHQsIGUsIG4sIG8sIHIsIHMpIHtcbiAgbGV0IGkgPSAwO1xuICBpZiAobi5ncm91cEluZGljZXMubGVuZ3RoID4gMClcbiAgICBmb3IgKGNvbnN0IGYgb2Ygbi5ncm91cEluZGljZXMpIHtcbiAgICAgIGlmIChmIC0gaSA+PSB0KVxuICAgICAgICBicmVhaztcbiAgICAgIGkrKztcbiAgICB9XG4gIGNvbnN0IGwgPSB0ICsgaSwgYyA9IFVlKGUsIGwpLCB1ID0gQXJyYXkuZnJvbSh7IGxlbmd0aDogbCB9KS5tYXAoKGYsIFMpID0+ICh7XG4gICAgZGF0YTogc1tTICsgY10sXG4gICAgaW5kZXg6IFMgKyBjLFxuICAgIG9mZnNldDogMCxcbiAgICBzaXplOiAwXG4gIH0pKTtcbiAgcmV0dXJuIEllKHUsIFtdLCBsLCByLCBuLCBvKTtcbn1cbmZ1bmN0aW9uIEluKHQsIGUsIG4pIHtcbiAgaWYgKHQubGVuZ3RoID09PSAwKVxuICAgIHJldHVybiBbXTtcbiAgaWYgKCFiZShlKSlcbiAgICByZXR1cm4gdC5tYXAoKHUpID0+ICh7IC4uLnUsIGluZGV4OiB1LmluZGV4ICsgbiwgb3JpZ2luYWxJbmRleDogdS5pbmRleCB9KSk7XG4gIGNvbnN0IG8gPSB0WzBdLmluZGV4LCByID0gdFt0Lmxlbmd0aCAtIDFdLmluZGV4LCBzID0gW10sIGkgPSB2ZShlLmdyb3VwT2Zmc2V0VHJlZSwgbywgcik7XG4gIGxldCBsLCBjID0gMDtcbiAgZm9yIChjb25zdCB1IG9mIHQpIHtcbiAgICAoIWwgfHwgbC5lbmQgPCB1LmluZGV4KSAmJiAobCA9IGkuc2hpZnQoKSwgYyA9IGUuZ3JvdXBJbmRpY2VzLmluZGV4T2YobC5zdGFydCkpO1xuICAgIGxldCBmO1xuICAgIHUuaW5kZXggPT09IGwuc3RhcnQgPyBmID0ge1xuICAgICAgaW5kZXg6IGMsXG4gICAgICB0eXBlOiBcImdyb3VwXCJcbiAgICB9IDogZiA9IHtcbiAgICAgIGdyb3VwSW5kZXg6IGMsXG4gICAgICBpbmRleDogdS5pbmRleCAtIChjICsgMSkgKyBuXG4gICAgfSwgcy5wdXNoKHtcbiAgICAgIC4uLmYsXG4gICAgICBkYXRhOiB1LmRhdGEsXG4gICAgICBvZmZzZXQ6IHUub2Zmc2V0LFxuICAgICAgb3JpZ2luYWxJbmRleDogdS5pbmRleCxcbiAgICAgIHNpemU6IHUuc2l6ZVxuICAgIH0pO1xuICB9XG4gIHJldHVybiBzO1xufVxuY29uc3QgR3QgPSBVKFxuICAoW1xuICAgIHsgZGF0YTogdCwgZmlyc3RJdGVtSW5kZXg6IGUsIGdhcDogbiwgc2l6ZXM6IG8sIHRvdGFsQ291bnQ6IHIgfSxcbiAgICBzLFxuICAgIHsgbGlzdEJvdW5kYXJ5OiBpLCB0b3BMaXN0SGVpZ2h0OiBsLCB2aXNpYmxlUmFuZ2U6IGMgfSxcbiAgICB7IGluaXRpYWxUb3BNb3N0SXRlbUluZGV4OiB1LCBzY3JvbGxlZFRvSW5pdGlhbEl0ZW06IGYgfSxcbiAgICB7IHRvcExpc3RIZWlnaHQ6IFMgfSxcbiAgICBwLFxuICAgIHsgZGlkTW91bnQ6IG0gfSxcbiAgICB7IHJlY2FsY0luUHJvZ3Jlc3M6IHcgfVxuICBdKSA9PiB7XG4gICAgY29uc3QgSSA9IHkoW10pLCBDID0geSgwKSwgZyA9ICQoKTtcbiAgICBGKHMudG9wSXRlbXNJbmRleGVzLCBJKTtcbiAgICBjb25zdCBhID0gY3QoXG4gICAgICB4KFxuICAgICAgICBydChcbiAgICAgICAgICBtLFxuICAgICAgICAgIHcsXG4gICAgICAgICAgQShjLCBzZSksXG4gICAgICAgICAgQShyKSxcbiAgICAgICAgICBBKG8pLFxuICAgICAgICAgIEEodSksXG4gICAgICAgICAgZixcbiAgICAgICAgICBBKEkpLFxuICAgICAgICAgIEEoZSksXG4gICAgICAgICAgQShuKSxcbiAgICAgICAgICB0XG4gICAgICAgICksXG4gICAgICAgIFAoKFtkLCBSLCAsIEIsICwgLCAsICwgLCAsIE9dKSA9PiB7XG4gICAgICAgICAgY29uc3QgTCA9IE8gJiYgTy5sZW5ndGggIT09IEI7XG4gICAgICAgICAgcmV0dXJuIGQgJiYgIVIgJiYgIUw7XG4gICAgICAgIH0pLFxuICAgICAgICBFKFxuICAgICAgICAgIChbXG4gICAgICAgICAgICAsXG4gICAgICAgICAgICAsXG4gICAgICAgICAgICBbZCwgUl0sXG4gICAgICAgICAgICBCLFxuICAgICAgICAgICAgTyxcbiAgICAgICAgICAgIEwsXG4gICAgICAgICAgICBWLFxuICAgICAgICAgICAgRCxcbiAgICAgICAgICAgIEosXG4gICAgICAgICAgICBudCxcbiAgICAgICAgICAgIGtcbiAgICAgICAgICBdKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBxID0gTywgeyBvZmZzZXRUcmVlOiBzdCwgc2l6ZVRyZWU6IGR0IH0gPSBxLCBTdCA9IGx0KEMpO1xuICAgICAgICAgICAgaWYgKEIgPT09IDApXG4gICAgICAgICAgICAgIHJldHVybiB7IC4uLmtlLCB0b3RhbENvdW50OiBCIH07XG4gICAgICAgICAgICBpZiAoZCA9PT0gMCAmJiBSID09PSAwKVxuICAgICAgICAgICAgICByZXR1cm4gU3QgPT09IDAgPyB7IC4uLmtlLCB0b3RhbENvdW50OiBCIH0gOiAkbihTdCwgTCwgTywgSiwgbnQsIGsgfHwgW10pO1xuICAgICAgICAgICAgaWYgKGooZHQpKVxuICAgICAgICAgICAgICByZXR1cm4gU3QgPiAwID8gbnVsbCA6IEllKFxuICAgICAgICAgICAgICAgIEFvKFVlKEwsIEIpLCBxLCBrKSxcbiAgICAgICAgICAgICAgICBbXSxcbiAgICAgICAgICAgICAgICBCLFxuICAgICAgICAgICAgICAgIG50LFxuICAgICAgICAgICAgICAgIHEsXG4gICAgICAgICAgICAgICAgSlxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgY29uc3QgZnQgPSBbXTtcbiAgICAgICAgICAgIGlmIChELmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgY29uc3QgTXQgPSBEWzBdLCB5dCA9IERbRC5sZW5ndGggLSAxXTtcbiAgICAgICAgICAgICAgbGV0IGt0ID0gMDtcbiAgICAgICAgICAgICAgZm9yIChjb25zdCB2IG9mIHZlKGR0LCBNdCwgeXQpKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgTiA9IHYudmFsdWUsIFEgPSBNYXRoLm1heCh2LnN0YXJ0LCBNdCksIGl0ID0gTWF0aC5taW4odi5lbmQsIHl0KTtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCB0dCA9IFE7IHR0IDw9IGl0OyB0dCsrKVxuICAgICAgICAgICAgICAgICAgZnQucHVzaCh7IGRhdGE6IGsgPT0gbnVsbCA/IHZvaWQgMCA6IGtbdHRdLCBpbmRleDogdHQsIG9mZnNldDoga3QsIHNpemU6IE4gfSksIGt0ICs9IE47XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghVilcbiAgICAgICAgICAgICAgcmV0dXJuIEllKFtdLCBmdCwgQiwgbnQsIHEsIEopO1xuICAgICAgICAgICAgY29uc3QgdXQgPSBELmxlbmd0aCA+IDAgPyBEW0QubGVuZ3RoIC0gMV0gKyAxIDogMCwgQXQgPSBibyhzdCwgZCwgUiwgdXQpO1xuICAgICAgICAgICAgaWYgKEF0Lmxlbmd0aCA9PT0gMClcbiAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICBjb25zdCB4dCA9IEIgLSAxLCBYdCA9IHllKFtdLCAoTXQpID0+IHtcbiAgICAgICAgICAgICAgZm9yIChjb25zdCB5dCBvZiBBdCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGt0ID0geXQudmFsdWU7XG4gICAgICAgICAgICAgICAgbGV0IHYgPSBrdC5vZmZzZXQsIE4gPSB5dC5zdGFydDtcbiAgICAgICAgICAgICAgICBjb25zdCBRID0ga3Quc2l6ZTtcbiAgICAgICAgICAgICAgICBpZiAoa3Qub2Zmc2V0IDwgZCkge1xuICAgICAgICAgICAgICAgICAgTiArPSBNYXRoLmZsb29yKChkIC0ga3Qub2Zmc2V0ICsgbnQpIC8gKFEgKyBudCkpO1xuICAgICAgICAgICAgICAgICAgY29uc3QgdHQgPSBOIC0geXQuc3RhcnQ7XG4gICAgICAgICAgICAgICAgICB2ICs9IHR0ICogUSArIHR0ICogbnQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIE4gPCB1dCAmJiAodiArPSAodXQgLSBOKSAqIFEsIE4gPSB1dCk7XG4gICAgICAgICAgICAgICAgY29uc3QgaXQgPSBNYXRoLm1pbih5dC5lbmQsIHh0KTtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCB0dCA9IE47IHR0IDw9IGl0ICYmICEodiA+PSBSKTsgdHQrKylcbiAgICAgICAgICAgICAgICAgIE10LnB1c2goeyBkYXRhOiBrID09IG51bGwgPyB2b2lkIDAgOiBrW3R0XSwgaW5kZXg6IHR0LCBvZmZzZXQ6IHYsIHNpemU6IFEgfSksIHYgKz0gUSArIG50O1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBJZShYdCwgZnQsIEIsIG50LCBxLCBKKTtcbiAgICAgICAgICB9XG4gICAgICAgICksXG4gICAgICAgIC8vQHRzLWV4cGVjdC1lcnJvciBmaWx0ZXIgbmVlZHMgdG8gYmUgZml4ZWRcbiAgICAgICAgUCgoZCkgPT4gZCAhPT0gbnVsbCksXG4gICAgICAgIFkoKVxuICAgICAgKSxcbiAgICAgIGtlXG4gICAgKTtcbiAgICBGKFxuICAgICAgeChcbiAgICAgICAgdCxcbiAgICAgICAgUChNZSksXG4gICAgICAgIEUoKGQpID0+IGQgPT0gbnVsbCA/IHZvaWQgMCA6IGQubGVuZ3RoKVxuICAgICAgKSxcbiAgICAgIHJcbiAgICApLCBGKFxuICAgICAgeChcbiAgICAgICAgYSxcbiAgICAgICAgRSgoZCkgPT4gZC50b3BMaXN0SGVpZ2h0KVxuICAgICAgKSxcbiAgICAgIFNcbiAgICApLCBGKFMsIGwpLCBGKFxuICAgICAgeChcbiAgICAgICAgYSxcbiAgICAgICAgRSgoZCkgPT4gW2QudG9wLCBkLmJvdHRvbV0pXG4gICAgICApLFxuICAgICAgaVxuICAgICksIEYoXG4gICAgICB4KFxuICAgICAgICBhLFxuICAgICAgICBFKChkKSA9PiBkLml0ZW1zKVxuICAgICAgKSxcbiAgICAgIGdcbiAgICApO1xuICAgIGNvbnN0IFQgPSBwdChcbiAgICAgIHgoXG4gICAgICAgIGEsXG4gICAgICAgIFAoKHsgaXRlbXM6IGQgfSkgPT4gZC5sZW5ndGggPiAwKSxcbiAgICAgICAgRyhyLCB0KSxcbiAgICAgICAgUCgoW3sgaXRlbXM6IGQgfSwgUl0pID0+IGRbZC5sZW5ndGggLSAxXS5vcmlnaW5hbEluZGV4ID09PSBSIC0gMSksXG4gICAgICAgIEUoKFssIGQsIFJdKSA9PiBbZCAtIDEsIFJdKSxcbiAgICAgICAgWShzZSksXG4gICAgICAgIEUoKFtkXSkgPT4gZClcbiAgICAgIClcbiAgICApLCBiID0gcHQoXG4gICAgICB4KFxuICAgICAgICBhLFxuICAgICAgICBMdCgyMDApLFxuICAgICAgICBQKCh7IGl0ZW1zOiBkLCB0b3BJdGVtczogUiB9KSA9PiBkLmxlbmd0aCA+IDAgJiYgZFswXS5vcmlnaW5hbEluZGV4ID09PSBSLmxlbmd0aCksXG4gICAgICAgIEUoKHsgaXRlbXM6IGQgfSkgPT4gZFswXS5pbmRleCksXG4gICAgICAgIFkoKVxuICAgICAgKVxuICAgICksIGggPSBwdChcbiAgICAgIHgoXG4gICAgICAgIGEsXG4gICAgICAgIFAoKHsgaXRlbXM6IGQgfSkgPT4gZC5sZW5ndGggPiAwKSxcbiAgICAgICAgRSgoeyBpdGVtczogZCB9KSA9PiB7XG4gICAgICAgICAgbGV0IFIgPSAwLCBCID0gZC5sZW5ndGggLSAxO1xuICAgICAgICAgIGZvciAoOyBkW1JdLnR5cGUgPT09IFwiZ3JvdXBcIiAmJiBSIDwgQjsgKVxuICAgICAgICAgICAgUisrO1xuICAgICAgICAgIGZvciAoOyBkW0JdLnR5cGUgPT09IFwiZ3JvdXBcIiAmJiBCID4gUjsgKVxuICAgICAgICAgICAgQi0tO1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBlbmRJbmRleDogZFtCXS5pbmRleCxcbiAgICAgICAgICAgIHN0YXJ0SW5kZXg6IGRbUl0uaW5kZXhcbiAgICAgICAgICB9O1xuICAgICAgICB9KSxcbiAgICAgICAgWShBbilcbiAgICAgIClcbiAgICApO1xuICAgIHJldHVybiB7IGVuZFJlYWNoZWQ6IFQsIGluaXRpYWxJdGVtQ291bnQ6IEMsIGl0ZW1zUmVuZGVyZWQ6IGcsIGxpc3RTdGF0ZTogYSwgcmFuZ2VDaGFuZ2VkOiBoLCBzdGFydFJlYWNoZWQ6IGIsIHRvcEl0ZW1zSW5kZXhlczogSSwgLi4ucCB9O1xuICB9LFxuICBYKFxuICAgIEV0LFxuICAgIEduLFxuICAgIEtlLFxuICAgIHVlLFxuICAgIGNlLFxuICAgIGFlLFxuICAgIFB0LFxuICAgIE5lXG4gICksXG4gIHsgc2luZ2xldG9uOiAhMCB9XG4pLCBVbiA9IFUoXG4gIChbeyBmaXhlZEZvb3RlckhlaWdodDogdCwgZml4ZWRIZWFkZXJIZWlnaHQ6IGUsIGZvb3RlckhlaWdodDogbiwgaGVhZGVySGVpZ2h0OiBvIH0sIHsgbGlzdFN0YXRlOiByIH1dKSA9PiB7XG4gICAgY29uc3QgcyA9ICQoKSwgaSA9IGN0KFxuICAgICAgeChcbiAgICAgICAgcnQobiwgdCwgbywgZSwgciksXG4gICAgICAgIEUoKFtsLCBjLCB1LCBmLCBTXSkgPT4gbCArIGMgKyB1ICsgZiArIFMub2Zmc2V0Qm90dG9tICsgUy5ib3R0b20pXG4gICAgICApLFxuICAgICAgMFxuICAgICk7XG4gICAgcmV0dXJuIEYoQShpKSwgcyksIHsgdG90YWxMaXN0SGVpZ2h0OiBpLCB0b3RhbExpc3RIZWlnaHRDaGFuZ2VkOiBzIH07XG4gIH0sXG4gIFgoYXQsIEd0KSxcbiAgeyBzaW5nbGV0b246ICEwIH1cbiksIE1vID0gVShcbiAgKFt7IHZpZXdwb3J0SGVpZ2h0OiB0IH0sIHsgdG90YWxMaXN0SGVpZ2h0OiBlIH1dKSA9PiB7XG4gICAgY29uc3QgbiA9IHkoITEpLCBvID0gY3QoXG4gICAgICB4KFxuICAgICAgICBydChuLCB0LCBlKSxcbiAgICAgICAgUCgoW3JdKSA9PiByKSxcbiAgICAgICAgRSgoWywgciwgc10pID0+IE1hdGgubWF4KDAsIHIgLSBzKSksXG4gICAgICAgIEx0KDApLFxuICAgICAgICBZKClcbiAgICAgICksXG4gICAgICAwXG4gICAgKTtcbiAgICByZXR1cm4geyBhbGlnblRvQm90dG9tOiBuLCBwYWRkaW5nVG9wQWRkaXRpb246IG8gfTtcbiAgfSxcbiAgWChhdCwgVW4pLFxuICB7IHNpbmdsZXRvbjogITAgfVxuKTtcbmZ1bmN0aW9uIFNuKHQpIHtcbiAgcmV0dXJuIHQgPyB0ID09PSBcInNtb290aFwiID8gXCJzbW9vdGhcIiA6IFwiYXV0b1wiIDogITE7XG59XG5jb25zdCBXbyA9ICh0LCBlKSA9PiB0eXBlb2YgdCA9PSBcImZ1bmN0aW9uXCIgPyBTbih0KGUpKSA6IGUgJiYgU24odCksIF9vID0gVShcbiAgKFtcbiAgICB7IGxpc3RSZWZyZXNoOiB0LCB0b3RhbENvdW50OiBlIH0sXG4gICAgeyBhdEJvdHRvbVN0YXRlOiBuLCBpc0F0Qm90dG9tOiBvIH0sXG4gICAgeyBzY3JvbGxUb0luZGV4OiByIH0sXG4gICAgeyBzY3JvbGxlZFRvSW5pdGlhbEl0ZW06IHMgfSxcbiAgICB7IGRpZE1vdW50OiBpLCBwcm9wc1JlYWR5OiBsIH0sXG4gICAgeyBsb2c6IGMgfSxcbiAgICB7IHNjcm9sbGluZ0luUHJvZ3Jlc3M6IHUgfVxuICBdKSA9PiB7XG4gICAgY29uc3QgZiA9IHkoITEpLCBTID0gJCgpO1xuICAgIGxldCBwID0gbnVsbDtcbiAgICBmdW5jdGlvbiBtKEkpIHtcbiAgICAgIFcociwge1xuICAgICAgICBhbGlnbjogXCJlbmRcIixcbiAgICAgICAgYmVoYXZpb3I6IEksXG4gICAgICAgIGluZGV4OiBcIkxBU1RcIlxuICAgICAgfSk7XG4gICAgfVxuICAgIEsoXG4gICAgICB4KFxuICAgICAgICBydCh4KEEoZSksIGp0KDEpKSwgaSksXG4gICAgICAgIEcoQShmKSwgbywgcywgdSksXG4gICAgICAgIEUoKFtbSSwgQ10sIGcsIGEsIFQsIGJdKSA9PiB7XG4gICAgICAgICAgbGV0IGggPSBDICYmIFQsIGQgPSBcImF1dG9cIjtcbiAgICAgICAgICByZXR1cm4gaCAmJiAoZCA9IFdvKGcsIGEgfHwgYiksIGggPSBoICYmICEhZCksIHsgZm9sbG93T3V0cHV0QmVoYXZpb3I6IGQsIHNob3VsZEZvbGxvdzogaCwgdG90YWxDb3VudDogSSB9O1xuICAgICAgICB9KSxcbiAgICAgICAgUCgoeyBzaG91bGRGb2xsb3c6IEkgfSkgPT4gSSlcbiAgICAgICksXG4gICAgICAoeyBmb2xsb3dPdXRwdXRCZWhhdmlvcjogSSwgdG90YWxDb3VudDogQyB9KSA9PiB7XG4gICAgICAgIHAgJiYgKHAoKSwgcCA9IG51bGwpLCBwID0gUnQodCwgKCkgPT4ge1xuICAgICAgICAgIGx0KGMpKFwiZm9sbG93aW5nIG91dHB1dCB0byBcIiwgeyB0b3RhbENvdW50OiBDIH0sIGh0LkRFQlVHKSwgbShJKSwgcCA9IG51bGw7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICk7XG4gICAgZnVuY3Rpb24gdyhJKSB7XG4gICAgICBjb25zdCBDID0gUnQobiwgKGcpID0+IHtcbiAgICAgICAgSSAmJiAhZy5hdEJvdHRvbSAmJiBnLm5vdEF0Qm90dG9tQmVjYXVzZSA9PT0gXCJTSVpFX0lOQ1JFQVNFRFwiICYmICFwICYmIChsdChjKShcInNjcm9sbGluZyB0byBib3R0b20gZHVlIHRvIGluY3JlYXNlZCBzaXplXCIsIHt9LCBodC5ERUJVRyksIG0oXCJhdXRvXCIpKTtcbiAgICAgIH0pO1xuICAgICAgc2V0VGltZW91dChDLCAxMDApO1xuICAgIH1cbiAgICByZXR1cm4gSyhcbiAgICAgIHgoXG4gICAgICAgIHJ0KEEoZiksIGUsIGwpLFxuICAgICAgICBQKChbSSwgLCBDXSkgPT4gSSAmJiBDKSxcbiAgICAgICAgYnQoXG4gICAgICAgICAgKHsgdmFsdWU6IEkgfSwgWywgQ10pID0+ICh7IHJlZnJlc2hlZDogSSA9PT0gQywgdmFsdWU6IEMgfSksXG4gICAgICAgICAgeyByZWZyZXNoZWQ6ICExLCB2YWx1ZTogMCB9XG4gICAgICAgICksXG4gICAgICAgIFAoKHsgcmVmcmVzaGVkOiBJIH0pID0+IEkpLFxuICAgICAgICBHKGYsIGUpXG4gICAgICApLFxuICAgICAgKFssIEldKSA9PiB7XG4gICAgICAgIGx0KHMpICYmIHcoSSAhPT0gITEpO1xuICAgICAgfVxuICAgICksIEsoUywgKCkgPT4ge1xuICAgICAgdyhsdChmKSAhPT0gITEpO1xuICAgIH0pLCBLKHJ0KEEoZiksIG4pLCAoW0ksIENdKSA9PiB7XG4gICAgICBJICYmICFDLmF0Qm90dG9tICYmIEMubm90QXRCb3R0b21CZWNhdXNlID09PSBcIlZJRVdQT1JUX0hFSUdIVF9ERUNSRUFTSU5HXCIgJiYgbShcImF1dG9cIik7XG4gICAgfSksIHsgYXV0b3Njcm9sbFRvQm90dG9tOiBTLCBmb2xsb3dPdXRwdXQ6IGYgfTtcbiAgfSxcbiAgWChFdCwgYWUsIGNlLCB1ZSwgUHQsIFZ0LCBhdClcbiksIEdvID0gVShcbiAgKFt7IGRhdGE6IHQsIGZpcnN0SXRlbUluZGV4OiBlLCBnYXA6IG4sIHNpemVzOiBvIH0sIHsgaW5pdGlhbFRvcE1vc3RJdGVtSW5kZXg6IHIgfSwgeyBpbml0aWFsSXRlbUNvdW50OiBzLCBsaXN0U3RhdGU6IGkgfSwgeyBkaWRNb3VudDogbCB9XSkgPT4gKEYoXG4gICAgeChcbiAgICAgIGwsXG4gICAgICBHKHMpLFxuICAgICAgUCgoWywgY10pID0+IGMgIT09IDApLFxuICAgICAgRyhyLCBvLCBlLCBuLCB0KSxcbiAgICAgIEUoKFtbLCBjXSwgdSwgZiwgUywgcCwgbSA9IFtdXSkgPT4gJG4oYywgdSwgZiwgUywgcCwgbSkpXG4gICAgKSxcbiAgICBpXG4gICksIHt9KSxcbiAgWChFdCwgdWUsIEd0LCBQdCksXG4gIHsgc2luZ2xldG9uOiAhMCB9XG4pLCBObyA9IFUoXG4gIChbeyBkaWRNb3VudDogdCB9LCB7IHNjcm9sbFRvOiBlIH0sIHsgbGlzdFN0YXRlOiBuIH1dKSA9PiB7XG4gICAgY29uc3QgbyA9IHkoMCk7XG4gICAgcmV0dXJuIEsoXG4gICAgICB4KFxuICAgICAgICB0LFxuICAgICAgICBHKG8pLFxuICAgICAgICBQKChbLCByXSkgPT4gciAhPT0gMCksXG4gICAgICAgIEUoKFssIHJdKSA9PiAoeyB0b3A6IHIgfSkpXG4gICAgICApLFxuICAgICAgKHIpID0+IHtcbiAgICAgICAgUnQoXG4gICAgICAgICAgeChcbiAgICAgICAgICAgIG4sXG4gICAgICAgICAgICBqdCgxKSxcbiAgICAgICAgICAgIFAoKHMpID0+IHMuaXRlbXMubGVuZ3RoID4gMSlcbiAgICAgICAgICApLFxuICAgICAgICAgICgpID0+IHtcbiAgICAgICAgICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZSgoKSA9PiB7XG4gICAgICAgICAgICAgIFcoZSwgcik7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgICk7XG4gICAgICB9XG4gICAgKSwge1xuICAgICAgaW5pdGlhbFNjcm9sbFRvcDogb1xuICAgIH07XG4gIH0sXG4gIFgoUHQsIGF0LCBHdCksXG4gIHsgc2luZ2xldG9uOiAhMCB9XG4pLCBEbyA9ICh7XG4gIGl0ZW1Cb3R0b206IHQsXG4gIGl0ZW1Ub3A6IGUsXG4gIGxvY2F0aW9uUGFyYW1zOiB7IGFsaWduOiBuLCBiZWhhdmlvcjogbywgLi4uciB9LFxuICB2aWV3cG9ydEJvdHRvbTogcyxcbiAgdmlld3BvcnRUb3A6IGlcbn0pID0+IGUgPCBpID8geyAuLi5yLCBhbGlnbjogbiAhPSBudWxsID8gbiA6IFwic3RhcnRcIiwgYmVoYXZpb3I6IG8gfSA6IHQgPiBzID8geyAuLi5yLCBhbGlnbjogbiAhPSBudWxsID8gbiA6IFwiZW5kXCIsIGJlaGF2aW9yOiBvIH0gOiBudWxsLCAkbyA9IFUoXG4gIChbXG4gICAgeyBnYXA6IHQsIHNpemVzOiBlLCB0b3RhbENvdW50OiBuIH0sXG4gICAgeyBmaXhlZEZvb3RlckhlaWdodDogbywgZml4ZWRIZWFkZXJIZWlnaHQ6IHIsIGhlYWRlckhlaWdodDogcywgc2Nyb2xsaW5nSW5Qcm9ncmVzczogaSwgc2Nyb2xsVG9wOiBsLCB2aWV3cG9ydEhlaWdodDogYyB9LFxuICAgIHsgc2Nyb2xsVG9JbmRleDogdSB9XG4gIF0pID0+IHtcbiAgICBjb25zdCBmID0gJCgpO1xuICAgIHJldHVybiBGKFxuICAgICAgeChcbiAgICAgICAgZixcbiAgICAgICAgRyhlLCBjLCBuLCBzLCByLCBvLCBsKSxcbiAgICAgICAgRyh0KSxcbiAgICAgICAgRSgoW1tTLCBwLCBtLCB3LCBJLCBDLCBnLCBhXSwgVF0pID0+IHtcbiAgICAgICAgICBjb25zdCB7IGFsaWduOiBiLCBiZWhhdmlvcjogaCwgY2FsY3VsYXRlVmlld0xvY2F0aW9uOiBkID0gRG8sIGRvbmU6IFIsIC4uLkIgfSA9IFMsIE8gPSBfbihTLCBwLCB3IC0gMSksIEwgPSBpZShPLCBwLm9mZnNldFRyZWUsIFQpICsgSSArIEMsIFYgPSBMICsgQ3QocC5zaXplVHJlZSwgTylbMV0sIEQgPSBhICsgQywgSiA9IGEgKyBtIC0gZywgbnQgPSBkKHtcbiAgICAgICAgICAgIGl0ZW1Cb3R0b206IFYsXG4gICAgICAgICAgICBpdGVtVG9wOiBMLFxuICAgICAgICAgICAgbG9jYXRpb25QYXJhbXM6IHsgYWxpZ246IGIsIGJlaGF2aW9yOiBoLCAuLi5CIH0sXG4gICAgICAgICAgICB2aWV3cG9ydEJvdHRvbTogSixcbiAgICAgICAgICAgIHZpZXdwb3J0VG9wOiBEXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgcmV0dXJuIG50ID8gUiAmJiBSdChcbiAgICAgICAgICAgIHgoXG4gICAgICAgICAgICAgIGksXG4gICAgICAgICAgICAgIFAoKGspID0+ICFrKSxcbiAgICAgICAgICAgICAgLy8gc2tpcHMgdGhlIGluaXRpYWwgcHVibGlzaCBvZiBmYWxzZSwgYW5kIHRoZSBjbGVhbnVwIGNhbGwuXG4gICAgICAgICAgICAgIC8vIGJ1dCBpZiBzY3JvbGxpbmdJblByb2dyZXNzIGlzIHRydWUsIHdlIHNraXAgdGhlIGluaXRpYWwgcHVibGlzaC5cbiAgICAgICAgICAgICAganQobHQoaSkgPyAxIDogMilcbiAgICAgICAgICAgICksXG4gICAgICAgICAgICBSXG4gICAgICAgICAgKSA6IFIgJiYgUigpLCBudDtcbiAgICAgICAgfSksXG4gICAgICAgIFAoKFMpID0+IFMgIT09IG51bGwpXG4gICAgICApLFxuICAgICAgdVxuICAgICksIHtcbiAgICAgIHNjcm9sbEludG9WaWV3OiBmXG4gICAgfTtcbiAgfSxcbiAgWChFdCwgYXQsIGNlLCBHdCwgVnQpLFxuICB7IHNpbmdsZXRvbjogITAgfVxuKSwgS24gPSBVKFxuICAoW3sgc2Nyb2xsVmVsb2NpdHk6IHQgfV0pID0+IHtcbiAgICBjb25zdCBlID0geSghMSksIG4gPSAkKCksIG8gPSB5KCExKTtcbiAgICByZXR1cm4gRihcbiAgICAgIHgoXG4gICAgICAgIHQsXG4gICAgICAgIEcobywgZSwgbiksXG4gICAgICAgIFAoKFtyLCBzXSkgPT4gISFzKSxcbiAgICAgICAgRSgoW3IsIHMsIGksIGxdKSA9PiB7XG4gICAgICAgICAgY29uc3QgeyBlbnRlcjogYywgZXhpdDogdSB9ID0gcztcbiAgICAgICAgICBpZiAoaSkge1xuICAgICAgICAgICAgaWYgKHUociwgbCkpXG4gICAgICAgICAgICAgIHJldHVybiAhMTtcbiAgICAgICAgICB9IGVsc2UgaWYgKGMociwgbCkpXG4gICAgICAgICAgICByZXR1cm4gITA7XG4gICAgICAgICAgcmV0dXJuIGk7XG4gICAgICAgIH0pLFxuICAgICAgICBZKClcbiAgICAgICksXG4gICAgICBlXG4gICAgKSwgSyhcbiAgICAgIHgocnQoZSwgdCwgbiksIEcobykpLFxuICAgICAgKFtbciwgcywgaV0sIGxdKSA9PiB7XG4gICAgICAgIHIgJiYgbCAmJiBsLmNoYW5nZSAmJiBsLmNoYW5nZShzLCBpKTtcbiAgICAgIH1cbiAgICApLCB7IGlzU2Vla2luZzogZSwgc2Nyb2xsU2Vla0NvbmZpZ3VyYXRpb246IG8sIHNjcm9sbFNlZWtSYW5nZUNoYW5nZWQ6IG4sIHNjcm9sbFZlbG9jaXR5OiB0IH07XG4gIH0sXG4gIFgoYWUpLFxuICB7IHNpbmdsZXRvbjogITAgfVxuKSwgamUgPSBVKChbeyBzY3JvbGxDb250YWluZXJTdGF0ZTogdCwgc2Nyb2xsVG86IGUgfV0pID0+IHtcbiAgY29uc3QgbiA9ICQoKSwgbyA9ICQoKSwgciA9ICQoKSwgcyA9IHkoITEpLCBpID0geSh2b2lkIDApO1xuICByZXR1cm4gRihcbiAgICB4KFxuICAgICAgcnQobiwgbyksXG4gICAgICBFKChbeyBzY3JvbGxIZWlnaHQ6IGwsIHNjcm9sbFRvcDogYywgdmlld3BvcnRIZWlnaHQ6IHUgfSwgeyBvZmZzZXRUb3A6IGYgfV0pID0+ICh7XG4gICAgICAgIHNjcm9sbEhlaWdodDogbCxcbiAgICAgICAgc2Nyb2xsVG9wOiBNYXRoLm1heCgwLCBjIC0gZiksXG4gICAgICAgIHZpZXdwb3J0SGVpZ2h0OiB1XG4gICAgICB9KSlcbiAgICApLFxuICAgIHRcbiAgKSwgRihcbiAgICB4KFxuICAgICAgZSxcbiAgICAgIEcobyksXG4gICAgICBFKChbbCwgeyBvZmZzZXRUb3A6IGMgfV0pID0+ICh7XG4gICAgICAgIC4uLmwsXG4gICAgICAgIHRvcDogbC50b3AgKyBjXG4gICAgICB9KSlcbiAgICApLFxuICAgIHJcbiAgKSwge1xuICAgIGN1c3RvbVNjcm9sbFBhcmVudDogaSxcbiAgICAvLyBjb25maWdcbiAgICB1c2VXaW5kb3dTY3JvbGw6IHMsXG4gICAgLy8gaW5wdXRcbiAgICB3aW5kb3dTY3JvbGxDb250YWluZXJTdGF0ZTogbixcbiAgICAvLyBzaWduYWxzXG4gICAgd2luZG93U2Nyb2xsVG86IHIsXG4gICAgd2luZG93Vmlld3BvcnRSZWN0OiBvXG4gIH07XG59LCBYKGF0KSksIFVvID0gVShcbiAgKFtcbiAgICB7IHNpemVSYW5nZXM6IHQsIHNpemVzOiBlIH0sXG4gICAgeyBoZWFkZXJIZWlnaHQ6IG4sIHNjcm9sbFRvcDogbyB9LFxuICAgIHsgaW5pdGlhbFRvcE1vc3RJdGVtSW5kZXg6IHIgfSxcbiAgICB7IGRpZE1vdW50OiBzIH0sXG4gICAgeyB1c2VXaW5kb3dTY3JvbGw6IGksIHdpbmRvd1Njcm9sbENvbnRhaW5lclN0YXRlOiBsLCB3aW5kb3dWaWV3cG9ydFJlY3Q6IGMgfVxuICBdKSA9PiB7XG4gICAgY29uc3QgdSA9ICQoKSwgZiA9IHkodm9pZCAwKSwgUyA9IHkobnVsbCksIHAgPSB5KG51bGwpO1xuICAgIHJldHVybiBGKGwsIFMpLCBGKGMsIHApLCBLKFxuICAgICAgeChcbiAgICAgICAgdSxcbiAgICAgICAgRyhlLCBvLCBpLCBTLCBwLCBuKVxuICAgICAgKSxcbiAgICAgIChbbSwgdywgSSwgQywgZywgYSwgVF0pID0+IHtcbiAgICAgICAgY29uc3QgYiA9IEhvKHcuc2l6ZVRyZWUpO1xuICAgICAgICBDICYmIGcgIT09IG51bGwgJiYgYSAhPT0gbnVsbCAmJiAoSSA9IGcuc2Nyb2xsVG9wIC0gYS5vZmZzZXRUb3ApLCBJIC09IFQsIG0oeyByYW5nZXM6IGIsIHNjcm9sbFRvcDogSSB9KTtcbiAgICAgIH1cbiAgICApLCBGKHgoZiwgUChNZSksIEUoS28pKSwgciksIEYoXG4gICAgICB4KFxuICAgICAgICBzLFxuICAgICAgICBHKGYpLFxuICAgICAgICBQKChbLCBtXSkgPT4gbSAhPT0gdm9pZCAwKSxcbiAgICAgICAgWSgpLFxuICAgICAgICBFKChbLCBtXSkgPT4gbS5yYW5nZXMpXG4gICAgICApLFxuICAgICAgdFxuICAgICksIHtcbiAgICAgIGdldFN0YXRlOiB1LFxuICAgICAgcmVzdG9yZVN0YXRlRnJvbTogZlxuICAgIH07XG4gIH0sXG4gIFgoRXQsIGF0LCB1ZSwgUHQsIGplKVxuKTtcbmZ1bmN0aW9uIEtvKHQpIHtcbiAgcmV0dXJuIHsgYWxpZ246IFwic3RhcnRcIiwgaW5kZXg6IDAsIG9mZnNldDogdC5zY3JvbGxUb3AgfTtcbn1cbmNvbnN0IGpvID0gVSgoW3sgdG9wSXRlbXNJbmRleGVzOiB0IH1dKSA9PiB7XG4gIGNvbnN0IGUgPSB5KDApO1xuICByZXR1cm4gRihcbiAgICB4KFxuICAgICAgZSxcbiAgICAgIFAoKG4pID0+IG4gPj0gMCksXG4gICAgICBFKChuKSA9PiBBcnJheS5mcm9tKHsgbGVuZ3RoOiBuIH0pLm1hcCgobywgcikgPT4gcikpXG4gICAgKSxcbiAgICB0XG4gICksIHsgdG9wSXRlbUNvdW50OiBlIH07XG59LCBYKEd0KSk7XG5mdW5jdGlvbiBqbih0KSB7XG4gIGxldCBlID0gITEsIG47XG4gIHJldHVybiAoKSA9PiAoZSB8fCAoZSA9ICEwLCBuID0gdCgpKSwgbik7XG59XG5jb25zdCBxbyA9IGpuKCgpID0+IC9pUChhZHxvZHxob25lKS9pLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCkgJiYgL1dlYktpdC9pLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCkpLCBZbyA9IFUoXG4gIChbXG4gICAgeyBkZXZpYXRpb246IHQsIHNjcm9sbEJ5OiBlLCBzY3JvbGxpbmdJblByb2dyZXNzOiBuLCBzY3JvbGxUb3A6IG8gfSxcbiAgICB7IGlzQXRCb3R0b206IHIsIGlzU2Nyb2xsaW5nOiBzLCBsYXN0SnVtcER1ZVRvSXRlbVJlc2l6ZTogaSwgc2Nyb2xsRGlyZWN0aW9uOiBsIH0sXG4gICAgeyBsaXN0U3RhdGU6IGMgfSxcbiAgICB7IGJlZm9yZVVuc2hpZnRXaXRoOiB1LCBnYXA6IGYsIHNoaWZ0V2l0aE9mZnNldDogUywgc2l6ZXM6IHAgfSxcbiAgICB7IGxvZzogbSB9LFxuICAgIHsgcmVjYWxjSW5Qcm9ncmVzczogdyB9XG4gIF0pID0+IHtcbiAgICBjb25zdCBJID0gcHQoXG4gICAgICB4KFxuICAgICAgICBjLFxuICAgICAgICBHKGkpLFxuICAgICAgICBidChcbiAgICAgICAgICAoWywgZywgYSwgVF0sIFt7IGJvdHRvbTogYiwgaXRlbXM6IGgsIG9mZnNldEJvdHRvbTogZCwgdG90YWxDb3VudDogUiB9LCBCXSkgPT4ge1xuICAgICAgICAgICAgY29uc3QgTyA9IGIgKyBkO1xuICAgICAgICAgICAgbGV0IEwgPSAwO1xuICAgICAgICAgICAgcmV0dXJuIGEgPT09IFIgJiYgZy5sZW5ndGggPiAwICYmIGgubGVuZ3RoID4gMCAmJiAoaFswXS5vcmlnaW5hbEluZGV4ID09PSAwICYmIGdbMF0ub3JpZ2luYWxJbmRleCA9PT0gMCB8fCAoTCA9IE8gLSBULCBMICE9PSAwICYmIChMICs9IEIpKSksIFtMLCBoLCBSLCBPXTtcbiAgICAgICAgICB9LFxuICAgICAgICAgIFswLCBbXSwgMCwgMF1cbiAgICAgICAgKSxcbiAgICAgICAgUCgoW2ddKSA9PiBnICE9PSAwKSxcbiAgICAgICAgRyhvLCBsLCBuLCByLCBtLCB3KSxcbiAgICAgICAgUCgoWywgZywgYSwgVCwgLCAsIGJdKSA9PiAhYiAmJiAhVCAmJiBnICE9PSAwICYmIGEgPT09IGxlKSxcbiAgICAgICAgRSgoW1tnXSwgLCAsICwgLCBhXSkgPT4gKGEoXCJVcHdhcmQgc2Nyb2xsaW5nIGNvbXBlbnNhdGlvblwiLCB7IGFtb3VudDogZyB9LCBodC5ERUJVRyksIGcpKVxuICAgICAgKVxuICAgICk7XG4gICAgZnVuY3Rpb24gQyhnKSB7XG4gICAgICBnID4gMCA/IChXKGUsIHsgYmVoYXZpb3I6IFwiYXV0b1wiLCB0b3A6IC1nIH0pLCBXKHQsIDApKSA6IChXKHQsIDApLCBXKGUsIHsgYmVoYXZpb3I6IFwiYXV0b1wiLCB0b3A6IC1nIH0pKTtcbiAgICB9XG4gICAgcmV0dXJuIEsoeChJLCBHKHQsIHMpKSwgKFtnLCBhLCBUXSkgPT4ge1xuICAgICAgVCAmJiBxbygpID8gVyh0LCBhIC0gZykgOiBDKC1nKTtcbiAgICB9KSwgSyhcbiAgICAgIHgoXG4gICAgICAgIHJ0KGN0KHMsICExKSwgdCwgdyksXG4gICAgICAgIFAoKFtnLCBhLCBUXSkgPT4gIWcgJiYgIVQgJiYgYSAhPT0gMCksXG4gICAgICAgIEUoKFtnLCBhXSkgPT4gYSksXG4gICAgICAgIEx0KDEpXG4gICAgICApLFxuICAgICAgQ1xuICAgICksIEYoXG4gICAgICB4KFxuICAgICAgICBTLFxuICAgICAgICBFKChnKSA9PiAoeyB0b3A6IC1nIH0pKVxuICAgICAgKSxcbiAgICAgIGVcbiAgICApLCBLKFxuICAgICAgeChcbiAgICAgICAgdSxcbiAgICAgICAgRyhwLCBmKSxcbiAgICAgICAgRSgoW2csIHsgZ3JvdXBJbmRpY2VzOiBhLCBsYXN0U2l6ZTogVCwgc2l6ZVRyZWU6IGIgfSwgaF0pID0+IHtcbiAgICAgICAgICBmdW5jdGlvbiBkKFIpIHtcbiAgICAgICAgICAgIHJldHVybiBSICogKFQgKyBoKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGEubGVuZ3RoID09PSAwKVxuICAgICAgICAgICAgcmV0dXJuIGQoZyk7XG4gICAgICAgICAge1xuICAgICAgICAgICAgbGV0IFIgPSAwO1xuICAgICAgICAgICAgY29uc3QgQiA9IHJlKGIsIDApO1xuICAgICAgICAgICAgbGV0IE8gPSAwLCBMID0gMDtcbiAgICAgICAgICAgIGZvciAoOyBPIDwgZzsgKSB7XG4gICAgICAgICAgICAgIE8rKywgUiArPSBCO1xuICAgICAgICAgICAgICBsZXQgViA9IGEubGVuZ3RoID09PSBMICsgMSA/IDEgLyAwIDogYVtMICsgMV0gLSBhW0xdIC0gMTtcbiAgICAgICAgICAgICAgTyArIFYgPiBnICYmIChSIC09IEIsIFYgPSBnIC0gTyArIDEpLCBPICs9IFYsIFIgKz0gZChWKSwgTCsrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIFI7XG4gICAgICAgICAgfVxuICAgICAgICB9KVxuICAgICAgKSxcbiAgICAgIChnKSA9PiB7XG4gICAgICAgIFcodCwgZyksIHJlcXVlc3RBbmltYXRpb25GcmFtZSgoKSA9PiB7XG4gICAgICAgICAgVyhlLCB7IHRvcDogZyB9KSwgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+IHtcbiAgICAgICAgICAgIFcodCwgMCksIFcodywgITEpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICApLCB7IGRldmlhdGlvbjogdCB9O1xuICB9LFxuICBYKGF0LCBhZSwgR3QsIEV0LCBWdCwgTmUpXG4pLCBabyA9IFUoXG4gIChbXG4gICAgdCxcbiAgICBlLFxuICAgIG4sXG4gICAgbyxcbiAgICByLFxuICAgIHMsXG4gICAgaSxcbiAgICBsLFxuICAgIGMsXG4gICAgdVxuICBdKSA9PiAoe1xuICAgIC4uLnQsXG4gICAgLi4uZSxcbiAgICAuLi5uLFxuICAgIC4uLm8sXG4gICAgLi4ucixcbiAgICAuLi5zLFxuICAgIC4uLmksXG4gICAgLi4ubCxcbiAgICAuLi5jLFxuICAgIC4uLnVcbiAgfSksXG4gIFgoXG4gICAgS2UsXG4gICAgR28sXG4gICAgUHQsXG4gICAgS24sXG4gICAgVW4sXG4gICAgTm8sXG4gICAgTW8sXG4gICAgamUsXG4gICAgJG8sXG4gICAgVnRcbiAgKVxuKSwgcW4gPSBVKFxuICAoW1xuICAgIHtcbiAgICAgIGRhdGE6IHQsXG4gICAgICBkZWZhdWx0SXRlbVNpemU6IGUsXG4gICAgICBmaXJzdEl0ZW1JbmRleDogbixcbiAgICAgIGZpeGVkSXRlbVNpemU6IG8sXG4gICAgICBnYXA6IHIsXG4gICAgICBncm91cEluZGljZXM6IHMsXG4gICAgICBpdGVtU2l6ZTogaSxcbiAgICAgIHNpemVSYW5nZXM6IGwsXG4gICAgICBzaXplczogYyxcbiAgICAgIHN0YXRlZnVsVG90YWxDb3VudDogdSxcbiAgICAgIHRvdGFsQ291bnQ6IGYsXG4gICAgICB0cmFja0l0ZW1TaXplczogU1xuICAgIH0sXG4gICAgeyBpbml0aWFsSXRlbUZpbmFsTG9jYXRpb25SZWFjaGVkOiBwLCBpbml0aWFsVG9wTW9zdEl0ZW1JbmRleDogbSwgc2Nyb2xsZWRUb0luaXRpYWxJdGVtOiB3IH0sXG4gICAgSSxcbiAgICBDLFxuICAgIGcsXG4gICAgeyBsaXN0U3RhdGU6IGEsIHRvcEl0ZW1zSW5kZXhlczogVCwgLi4uYiB9LFxuICAgIHsgc2Nyb2xsVG9JbmRleDogaCB9LFxuICAgIGQsXG4gICAgeyB0b3BJdGVtQ291bnQ6IFIgfSxcbiAgICB7IGdyb3VwQ291bnRzOiBCIH0sXG4gICAgT1xuICBdKSA9PiAoRihiLnJhbmdlQ2hhbmdlZCwgTy5zY3JvbGxTZWVrUmFuZ2VDaGFuZ2VkKSwgRihcbiAgICB4KFxuICAgICAgTy53aW5kb3dWaWV3cG9ydFJlY3QsXG4gICAgICBFKChMKSA9PiBMLnZpc2libGVIZWlnaHQpXG4gICAgKSxcbiAgICBJLnZpZXdwb3J0SGVpZ2h0XG4gICksIHtcbiAgICBkYXRhOiB0LFxuICAgIGRlZmF1bHRJdGVtSGVpZ2h0OiBlLFxuICAgIGZpcnN0SXRlbUluZGV4OiBuLFxuICAgIGZpeGVkSXRlbUhlaWdodDogbyxcbiAgICBnYXA6IHIsXG4gICAgZ3JvdXBDb3VudHM6IEIsXG4gICAgaW5pdGlhbEl0ZW1GaW5hbExvY2F0aW9uUmVhY2hlZDogcCxcbiAgICBpbml0aWFsVG9wTW9zdEl0ZW1JbmRleDogbSxcbiAgICBzY3JvbGxlZFRvSW5pdGlhbEl0ZW06IHcsXG4gICAgc2l6ZVJhbmdlczogbCxcbiAgICB0b3BJdGVtQ291bnQ6IFIsXG4gICAgdG9wSXRlbXNJbmRleGVzOiBULFxuICAgIC8vIGlucHV0XG4gICAgdG90YWxDb3VudDogZixcbiAgICAuLi5nLFxuICAgIGdyb3VwSW5kaWNlczogcyxcbiAgICBpdGVtU2l6ZTogaSxcbiAgICBsaXN0U3RhdGU6IGEsXG4gICAgc2Nyb2xsVG9JbmRleDogaCxcbiAgICAvLyBvdXRwdXRcbiAgICBzdGF0ZWZ1bFRvdGFsQ291bnQ6IHUsXG4gICAgdHJhY2tJdGVtU2l6ZXM6IFMsXG4gICAgLy8gZXhwb3J0ZWQgZnJvbSBzdGF0ZUZsYWdzU3lzdGVtXG4gICAgLi4uYixcbiAgICAvLyB0aGUgYmFnIG9mIElPIGZyb20gZmVhdHVyZUdyb3VwMVN5c3RlbVxuICAgIC4uLk8sXG4gICAgLi4uSSxcbiAgICBzaXplczogYyxcbiAgICAuLi5DXG4gIH0pLFxuICBYKFxuICAgIEV0LFxuICAgIHVlLFxuICAgIGF0LFxuICAgIFVvLFxuICAgIF9vLFxuICAgIEd0LFxuICAgIGNlLFxuICAgIFlvLFxuICAgIGpvLFxuICAgIEduLFxuICAgIFpvXG4gIClcbik7XG5mdW5jdGlvbiBYbyh0LCBlKSB7XG4gIGNvbnN0IG4gPSB7fSwgbyA9IHt9O1xuICBsZXQgciA9IDA7XG4gIGNvbnN0IHMgPSB0Lmxlbmd0aDtcbiAgZm9yICg7IHIgPCBzOyApXG4gICAgb1t0W3JdXSA9IDEsIHIgKz0gMTtcbiAgZm9yIChjb25zdCBpIGluIGUpXG4gICAgT2JqZWN0Lmhhc093bihvLCBpKSB8fCAobltpXSA9IGVbaV0pO1xuICByZXR1cm4gbjtcbn1cbmNvbnN0IHBlID0gdHlwZW9mIGRvY3VtZW50IDwgXCJ1XCIgPyBILnVzZUxheW91dEVmZmVjdCA6IEgudXNlRWZmZWN0O1xuZnVuY3Rpb24gcWUodCwgZSwgbikge1xuICBjb25zdCBvID0gT2JqZWN0LmtleXMoZS5yZXF1aXJlZCB8fCB7fSksIHIgPSBPYmplY3Qua2V5cyhlLm9wdGlvbmFsIHx8IHt9KSwgcyA9IE9iamVjdC5rZXlzKGUubWV0aG9kcyB8fCB7fSksIGkgPSBPYmplY3Qua2V5cyhlLmV2ZW50cyB8fCB7fSksIGwgPSBILmNyZWF0ZUNvbnRleHQoe30pO1xuICBmdW5jdGlvbiBjKGcsIGEpIHtcbiAgICBnLnByb3BzUmVhZHkgJiYgVyhnLnByb3BzUmVhZHksICExKTtcbiAgICBmb3IgKGNvbnN0IFQgb2Ygbykge1xuICAgICAgY29uc3QgYiA9IGdbZS5yZXF1aXJlZFtUXV07XG4gICAgICBXKGIsIGFbVF0pO1xuICAgIH1cbiAgICBmb3IgKGNvbnN0IFQgb2YgcilcbiAgICAgIGlmIChUIGluIGEpIHtcbiAgICAgICAgY29uc3QgYiA9IGdbZS5vcHRpb25hbFtUXV07XG4gICAgICAgIFcoYiwgYVtUXSk7XG4gICAgICB9XG4gICAgZy5wcm9wc1JlYWR5ICYmIFcoZy5wcm9wc1JlYWR5LCAhMCk7XG4gIH1cbiAgZnVuY3Rpb24gdShnKSB7XG4gICAgcmV0dXJuIHMucmVkdWNlKChhLCBUKSA9PiAoYVtUXSA9IChiKSA9PiB7XG4gICAgICBjb25zdCBoID0gZ1tlLm1ldGhvZHNbVF1dO1xuICAgICAgVyhoLCBiKTtcbiAgICB9LCBhKSwge30pO1xuICB9XG4gIGZ1bmN0aW9uIGYoZykge1xuICAgIHJldHVybiBpLnJlZHVjZSgoYSwgVCkgPT4gKGFbVF0gPSBtbyhnW2UuZXZlbnRzW1RdXSksIGEpLCB7fSk7XG4gIH1cbiAgY29uc3QgUyA9IEguZm9yd2FyZFJlZigoZywgYSkgPT4ge1xuICAgIGNvbnN0IHsgY2hpbGRyZW46IFQsIC4uLmIgfSA9IGcsIFtoXSA9IEgudXNlU3RhdGUoKCkgPT4geWUoaG8odCksIChCKSA9PiB7XG4gICAgICBjKEIsIGIpO1xuICAgIH0pKSwgW2RdID0gSC51c2VTdGF0ZShjbihmLCBoKSk7XG4gICAgcGUoKCkgPT4ge1xuICAgICAgZm9yIChjb25zdCBCIG9mIGkpXG4gICAgICAgIEIgaW4gYiAmJiBLKGRbQl0sIGJbQl0pO1xuICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgT2JqZWN0LnZhbHVlcyhkKS5tYXAoV2UpO1xuICAgICAgfTtcbiAgICB9LCBbYiwgZCwgaF0pLCBwZSgoKSA9PiB7XG4gICAgICBjKGgsIGIpO1xuICAgIH0pLCBILnVzZUltcGVyYXRpdmVIYW5kbGUoYSwgbG4odShoKSkpO1xuICAgIGNvbnN0IFIgPSBuO1xuICAgIHJldHVybiAvKiBAX19QVVJFX18gKi8geihsLlByb3ZpZGVyLCB7IHZhbHVlOiBoLCBjaGlsZHJlbjogbiA/IC8qIEBfX1BVUkVfXyAqLyB6KFIsIHsgLi4uWG8oWy4uLm8sIC4uLnIsIC4uLmldLCBiKSwgY2hpbGRyZW46IFQgfSkgOiBUIH0pO1xuICB9KSwgcCA9IChnKSA9PiBILnVzZUNhbGxiYWNrKGtuKFcsIEgudXNlQ29udGV4dChsKVtnXSksIFtnXSksIG0gPSAoZykgPT4ge1xuICAgIGNvbnN0IFQgPSBILnVzZUNvbnRleHQobClbZ10sIGIgPSBILnVzZUNhbGxiYWNrKFxuICAgICAgKGgpID0+IEsoVCwgaCksXG4gICAgICBbVF1cbiAgICApO1xuICAgIHJldHVybiBILnVzZVN5bmNFeHRlcm5hbFN0b3JlKFxuICAgICAgYixcbiAgICAgICgpID0+IGx0KFQpLFxuICAgICAgKCkgPT4gbHQoVClcbiAgICApO1xuICB9LCB3ID0gKGcpID0+IHtcbiAgICBjb25zdCBUID0gSC51c2VDb250ZXh0KGwpW2ddLCBbYiwgaF0gPSBILnVzZVN0YXRlKGNuKGx0LCBUKSk7XG4gICAgcmV0dXJuIHBlKFxuICAgICAgKCkgPT4gSyhULCAoZCkgPT4ge1xuICAgICAgICBkICE9PSBiICYmIGgobG4oZCkpO1xuICAgICAgfSksXG4gICAgICBbVCwgYl1cbiAgICApLCBiO1xuICB9LCBJID0gSC52ZXJzaW9uLnN0YXJ0c1dpdGgoXCIxOFwiKSA/IG0gOiB3O1xuICByZXR1cm4ge1xuICAgIENvbXBvbmVudDogUyxcbiAgICB1c2VFbWl0dGVyOiAoZywgYSkgPT4ge1xuICAgICAgY29uc3QgYiA9IEgudXNlQ29udGV4dChsKVtnXTtcbiAgICAgIHBlKCgpID0+IEsoYiwgYSksIFthLCBiXSk7XG4gICAgfSxcbiAgICB1c2VFbWl0dGVyVmFsdWU6IEksXG4gICAgdXNlUHVibGlzaGVyOiBwXG4gIH07XG59XG5jb25zdCBSZSA9IEguY3JlYXRlQ29udGV4dCh2b2lkIDApLCBZbiA9IEguY3JlYXRlQ29udGV4dCh2b2lkIDApLCBabiA9IHR5cGVvZiBkb2N1bWVudCA8IFwidVwiID8gSC51c2VMYXlvdXRFZmZlY3QgOiBILnVzZUVmZmVjdDtcbmZ1bmN0aW9uIEJlKHQpIHtcbiAgcmV0dXJuIFwic2VsZlwiIGluIHQ7XG59XG5mdW5jdGlvbiBKbyh0KSB7XG4gIHJldHVybiBcImJvZHlcIiBpbiB0O1xufVxuZnVuY3Rpb24gWG4odCwgZSwgbiwgbyA9IFl0LCByLCBzKSB7XG4gIGNvbnN0IGkgPSBILnVzZVJlZihudWxsKSwgbCA9IEgudXNlUmVmKG51bGwpLCBjID0gSC51c2VSZWYobnVsbCksIHUgPSBILnVzZUNhbGxiYWNrKFxuICAgIChwKSA9PiB7XG4gICAgICBsZXQgbSwgdywgSTtcbiAgICAgIGNvbnN0IEMgPSBwLnRhcmdldDtcbiAgICAgIGlmIChKbyhDKSB8fCBCZShDKSkge1xuICAgICAgICBjb25zdCBhID0gQmUoQykgPyBDIDogQy5kZWZhdWx0VmlldztcbiAgICAgICAgSSA9IHMgPyBhLnNjcm9sbFggOiBhLnNjcm9sbFksIG0gPSBzID8gYS5kb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc2Nyb2xsV2lkdGggOiBhLmRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zY3JvbGxIZWlnaHQsIHcgPSBzID8gYS5pbm5lcldpZHRoIDogYS5pbm5lckhlaWdodDtcbiAgICAgIH0gZWxzZVxuICAgICAgICBJID0gcyA/IEMuc2Nyb2xsTGVmdCA6IEMuc2Nyb2xsVG9wLCBtID0gcyA/IEMuc2Nyb2xsV2lkdGggOiBDLnNjcm9sbEhlaWdodCwgdyA9IHMgPyBDLm9mZnNldFdpZHRoIDogQy5vZmZzZXRIZWlnaHQ7XG4gICAgICBjb25zdCBnID0gKCkgPT4ge1xuICAgICAgICB0KHtcbiAgICAgICAgICBzY3JvbGxIZWlnaHQ6IG0sXG4gICAgICAgICAgc2Nyb2xsVG9wOiBNYXRoLm1heChJLCAwKSxcbiAgICAgICAgICB2aWV3cG9ydEhlaWdodDogd1xuICAgICAgICB9KTtcbiAgICAgIH07XG4gICAgICBwLnN1cHByZXNzRmx1c2hTeW5jID8gZygpIDogbG8uZmx1c2hTeW5jKGcpLCBsLmN1cnJlbnQgIT09IG51bGwgJiYgKEkgPT09IGwuY3VycmVudCB8fCBJIDw9IDAgfHwgSSA9PT0gbSAtIHcpICYmIChsLmN1cnJlbnQgPSBudWxsLCBlKCEwKSwgYy5jdXJyZW50ICYmIChjbGVhclRpbWVvdXQoYy5jdXJyZW50KSwgYy5jdXJyZW50ID0gbnVsbCkpO1xuICAgIH0sXG4gICAgW3QsIGVdXG4gICk7XG4gIEgudXNlRWZmZWN0KCgpID0+IHtcbiAgICBjb25zdCBwID0gciB8fCBpLmN1cnJlbnQ7XG4gICAgcmV0dXJuIG8ociB8fCBpLmN1cnJlbnQpLCB1KHsgc3VwcHJlc3NGbHVzaFN5bmM6ICEwLCB0YXJnZXQ6IHAgfSksIHAuYWRkRXZlbnRMaXN0ZW5lcihcInNjcm9sbFwiLCB1LCB7IHBhc3NpdmU6ICEwIH0pLCAoKSA9PiB7XG4gICAgICBvKG51bGwpLCBwLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJzY3JvbGxcIiwgdSk7XG4gICAgfTtcbiAgfSwgW2ksIHUsIG4sIG8sIHJdKTtcbiAgZnVuY3Rpb24gZihwKSB7XG4gICAgY29uc3QgbSA9IGkuY3VycmVudDtcbiAgICBpZiAoIW0gfHwgKHMgPyBcIm9mZnNldFdpZHRoXCIgaW4gbSAmJiBtLm9mZnNldFdpZHRoID09PSAwIDogXCJvZmZzZXRIZWlnaHRcIiBpbiBtICYmIG0ub2Zmc2V0SGVpZ2h0ID09PSAwKSlcbiAgICAgIHJldHVybjtcbiAgICBjb25zdCB3ID0gcC5iZWhhdmlvciA9PT0gXCJzbW9vdGhcIjtcbiAgICBsZXQgSSwgQywgZztcbiAgICBCZShtKSA/IChDID0gTWF0aC5tYXgoXG4gICAgICB3dChtLmRvY3VtZW50LmRvY3VtZW50RWxlbWVudCwgcyA/IFwid2lkdGhcIiA6IFwiaGVpZ2h0XCIpLFxuICAgICAgcyA/IG0uZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnNjcm9sbFdpZHRoIDogbS5kb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc2Nyb2xsSGVpZ2h0XG4gICAgKSwgSSA9IHMgPyBtLmlubmVyV2lkdGggOiBtLmlubmVySGVpZ2h0LCBnID0gcyA/IHdpbmRvdy5zY3JvbGxYIDogd2luZG93LnNjcm9sbFkpIDogKEMgPSBtW3MgPyBcInNjcm9sbFdpZHRoXCIgOiBcInNjcm9sbEhlaWdodFwiXSwgSSA9IHd0KG0sIHMgPyBcIndpZHRoXCIgOiBcImhlaWdodFwiKSwgZyA9IG1bcyA/IFwic2Nyb2xsTGVmdFwiIDogXCJzY3JvbGxUb3BcIl0pO1xuICAgIGNvbnN0IGEgPSBDIC0gSTtcbiAgICBpZiAocC50b3AgPSBNYXRoLmNlaWwoTWF0aC5tYXgoTWF0aC5taW4oYSwgcC50b3ApLCAwKSksIERuKEksIEMpIHx8IHAudG9wID09PSBnKSB7XG4gICAgICB0KHsgc2Nyb2xsSGVpZ2h0OiBDLCBzY3JvbGxUb3A6IGcsIHZpZXdwb3J0SGVpZ2h0OiBJIH0pLCB3ICYmIGUoITApO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB3ID8gKGwuY3VycmVudCA9IHAudG9wLCBjLmN1cnJlbnQgJiYgY2xlYXJUaW1lb3V0KGMuY3VycmVudCksIGMuY3VycmVudCA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgYy5jdXJyZW50ID0gbnVsbCwgbC5jdXJyZW50ID0gbnVsbCwgZSghMCk7XG4gICAgfSwgMWUzKSkgOiBsLmN1cnJlbnQgPSBudWxsLCBzICYmIChwID0geyBiZWhhdmlvcjogcC5iZWhhdmlvciwgbGVmdDogcC50b3AgfSksIG0uc2Nyb2xsVG8ocCk7XG4gIH1cbiAgZnVuY3Rpb24gUyhwKSB7XG4gICAgcyAmJiAocCA9IHsgYmVoYXZpb3I6IHAuYmVoYXZpb3IsIGxlZnQ6IHAudG9wIH0pLCBpLmN1cnJlbnQuc2Nyb2xsQnkocCk7XG4gIH1cbiAgcmV0dXJuIHsgc2Nyb2xsQnlDYWxsYmFjazogUywgc2Nyb2xsZXJSZWY6IGksIHNjcm9sbFRvQ2FsbGJhY2s6IGYgfTtcbn1cbmNvbnN0IE9lID0gXCItd2Via2l0LXN0aWNreVwiLCB4biA9IFwic3RpY2t5XCIsIEpuID0gam4oKCkgPT4ge1xuICBpZiAodHlwZW9mIGRvY3VtZW50ID4gXCJ1XCIpXG4gICAgcmV0dXJuIHhuO1xuICBjb25zdCB0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgcmV0dXJuIHQuc3R5bGUucG9zaXRpb24gPSBPZSwgdC5zdHlsZS5wb3NpdGlvbiA9PT0gT2UgPyBPZSA6IHhuO1xufSk7XG5mdW5jdGlvbiBZZSh0KSB7XG4gIHJldHVybiB0O1xufVxuY29uc3QgUW8gPSAvKiBAX19QVVJFX18gKi8gVSgoKSA9PiB7XG4gIGNvbnN0IHQgPSB5KChjKSA9PiBgSXRlbSAke2N9YCksIGUgPSB5KG51bGwpLCBuID0geSgoYykgPT4gYEdyb3VwICR7Y31gKSwgbyA9IHkoe30pLCByID0geShZZSksIHMgPSB5KFwiZGl2XCIpLCBpID0geShZdCksIGwgPSAoYywgdSA9IG51bGwpID0+IGN0KFxuICAgIHgoXG4gICAgICBvLFxuICAgICAgRSgoZikgPT4gZltjXSksXG4gICAgICBZKClcbiAgICApLFxuICAgIHVcbiAgKTtcbiAgcmV0dXJuIHtcbiAgICBjb21wb25lbnRzOiBvLFxuICAgIGNvbXB1dGVJdGVtS2V5OiByLFxuICAgIGNvbnRleHQ6IGUsXG4gICAgRW1wdHlQbGFjZWhvbGRlcjogbChcIkVtcHR5UGxhY2Vob2xkZXJcIiksXG4gICAgRm9vdGVyQ29tcG9uZW50OiBsKFwiRm9vdGVyXCIpLFxuICAgIEdyb3VwQ29tcG9uZW50OiBsKFwiR3JvdXBcIiwgXCJkaXZcIiksXG4gICAgZ3JvdXBDb250ZW50OiBuLFxuICAgIEhlYWRlckNvbXBvbmVudDogbChcIkhlYWRlclwiKSxcbiAgICBIZWFkZXJGb290ZXJUYWc6IHMsXG4gICAgSXRlbUNvbXBvbmVudDogbChcIkl0ZW1cIiwgXCJkaXZcIiksXG4gICAgaXRlbUNvbnRlbnQ6IHQsXG4gICAgTGlzdENvbXBvbmVudDogbChcIkxpc3RcIiwgXCJkaXZcIiksXG4gICAgU2Nyb2xsZXJDb21wb25lbnQ6IGwoXCJTY3JvbGxlclwiLCBcImRpdlwiKSxcbiAgICBzY3JvbGxlclJlZjogaSxcbiAgICBTY3JvbGxTZWVrUGxhY2Vob2xkZXI6IGwoXCJTY3JvbGxTZWVrUGxhY2Vob2xkZXJcIiksXG4gICAgVG9wSXRlbUxpc3RDb21wb25lbnQ6IGwoXCJUb3BJdGVtTGlzdFwiKVxuICB9O1xufSksIHRyID0gLyogQF9fUFVSRV9fICovIFUoXG4gIChbdCwgZV0pID0+ICh7IC4uLnQsIC4uLmUgfSksXG4gIFgocW4sIFFvKVxuKSwgZXIgPSAoeyBoZWlnaHQ6IHQgfSkgPT4gLyogQF9fUFVSRV9fICovIHooXCJkaXZcIiwgeyBzdHlsZTogeyBoZWlnaHQ6IHQgfSB9KSwgbnIgPSB7IG92ZXJmbG93QW5jaG9yOiBcIm5vbmVcIiwgcG9zaXRpb246IEpuKCksIHpJbmRleDogMSB9LCBRbiA9IHsgb3ZlcmZsb3dBbmNob3I6IFwibm9uZVwiIH0sIG9yID0geyAuLi5RbiwgZGlzcGxheTogXCJpbmxpbmUtYmxvY2tcIiwgaGVpZ2h0OiBcIjEwMCVcIiB9LCBUbiA9IC8qIEBfX1BVUkVfXyAqLyBILm1lbW8oZnVuY3Rpb24oeyBzaG93VG9wTGlzdDogZSA9ICExIH0pIHtcbiAgY29uc3QgbiA9IE0oXCJsaXN0U3RhdGVcIiksIG8gPSBndChcInNpemVSYW5nZXNcIiksIHIgPSBNKFwidXNlV2luZG93U2Nyb2xsXCIpLCBzID0gTShcImN1c3RvbVNjcm9sbFBhcmVudFwiKSwgaSA9IGd0KFwid2luZG93U2Nyb2xsQ29udGFpbmVyU3RhdGVcIiksIGwgPSBndChcInNjcm9sbENvbnRhaW5lclN0YXRlXCIpLCBjID0gcyB8fCByID8gaSA6IGwsIHUgPSBNKFwiaXRlbUNvbnRlbnRcIiksIGYgPSBNKFwiY29udGV4dFwiKSwgUyA9IE0oXCJncm91cENvbnRlbnRcIiksIHAgPSBNKFwidHJhY2tJdGVtU2l6ZXNcIiksIG0gPSBNKFwiaXRlbVNpemVcIiksIHcgPSBNKFwibG9nXCIpLCBJID0gZ3QoXCJnYXBcIiksIEMgPSBNKFwiaG9yaXpvbnRhbERpcmVjdGlvblwiKSwgeyBjYWxsYmFja1JlZjogZyB9ID0gT24oXG4gICAgbyxcbiAgICBtLFxuICAgIHAsXG4gICAgZSA/IFl0IDogYyxcbiAgICB3LFxuICAgIEksXG4gICAgcyxcbiAgICBDLFxuICAgIE0oXCJza2lwQW5pbWF0aW9uRnJhbWVJblJlc2l6ZU9ic2VydmVyXCIpXG4gICksIFthLCBUXSA9IEgudXNlU3RhdGUoMCk7XG4gIEplKFwiZGV2aWF0aW9uXCIsIChrKSA9PiB7XG4gICAgYSAhPT0gayAmJiBUKGspO1xuICB9KTtcbiAgY29uc3QgYiA9IE0oXCJFbXB0eVBsYWNlaG9sZGVyXCIpLCBoID0gTShcIlNjcm9sbFNlZWtQbGFjZWhvbGRlclwiKSB8fCBlciwgZCA9IE0oXCJMaXN0Q29tcG9uZW50XCIpLCBSID0gTShcIkl0ZW1Db21wb25lbnRcIiksIEIgPSBNKFwiR3JvdXBDb21wb25lbnRcIiksIE8gPSBNKFwiY29tcHV0ZUl0ZW1LZXlcIiksIEwgPSBNKFwiaXNTZWVraW5nXCIpLCBWID0gTShcImdyb3VwSW5kaWNlc1wiKS5sZW5ndGggPiAwLCBEID0gTShcImFsaWduVG9Cb3R0b21cIiksIEogPSBNKFwiaW5pdGlhbEl0ZW1GaW5hbExvY2F0aW9uUmVhY2hlZFwiKSwgbnQgPSBlID8ge30gOiB7XG4gICAgYm94U2l6aW5nOiBcImJvcmRlci1ib3hcIixcbiAgICAuLi5DID8ge1xuICAgICAgZGlzcGxheTogXCJpbmxpbmUtYmxvY2tcIixcbiAgICAgIGhlaWdodDogXCIxMDAlXCIsXG4gICAgICBtYXJnaW5MZWZ0OiBhICE9PSAwID8gYSA6IEQgPyBcImF1dG9cIiA6IDAsXG4gICAgICBwYWRkaW5nTGVmdDogbi5vZmZzZXRUb3AsXG4gICAgICBwYWRkaW5nUmlnaHQ6IG4ub2Zmc2V0Qm90dG9tLFxuICAgICAgd2hpdGVTcGFjZTogXCJub3dyYXBcIlxuICAgIH0gOiB7XG4gICAgICBtYXJnaW5Ub3A6IGEgIT09IDAgPyBhIDogRCA/IFwiYXV0b1wiIDogMCxcbiAgICAgIHBhZGRpbmdCb3R0b206IG4ub2Zmc2V0Qm90dG9tLFxuICAgICAgcGFkZGluZ1RvcDogbi5vZmZzZXRUb3BcbiAgICB9LFxuICAgIC4uLkogPyB7fSA6IHsgdmlzaWJpbGl0eTogXCJoaWRkZW5cIiB9XG4gIH07XG4gIHJldHVybiAhZSAmJiBuLnRvdGFsQ291bnQgPT09IDAgJiYgYiA/IC8qIEBfX1BVUkVfXyAqLyB6KGIsIHsgLi4uWihiLCBmKSB9KSA6IC8qIEBfX1BVUkVfXyAqLyB6KFxuICAgIGQsXG4gICAge1xuICAgICAgLi4uWihkLCBmKSxcbiAgICAgIFwiZGF0YS10ZXN0aWRcIjogZSA/IFwidmlydHVvc28tdG9wLWl0ZW0tbGlzdFwiIDogXCJ2aXJ0dW9zby1pdGVtLWxpc3RcIixcbiAgICAgIHJlZjogZyxcbiAgICAgIHN0eWxlOiBudCxcbiAgICAgIGNoaWxkcmVuOiAoZSA/IG4udG9wSXRlbXMgOiBuLml0ZW1zKS5tYXAoKGspID0+IHtcbiAgICAgICAgY29uc3QgcSA9IGsub3JpZ2luYWxJbmRleCwgc3QgPSBPKHEgKyBuLmZpcnN0SXRlbUluZGV4LCBrLmRhdGEsIGYpO1xuICAgICAgICByZXR1cm4gTCA/IC8qIEBfX1BVUkVfXyAqLyAkdChcbiAgICAgICAgICBoLFxuICAgICAgICAgIHtcbiAgICAgICAgICAgIC4uLlooaCwgZiksXG4gICAgICAgICAgICBoZWlnaHQ6IGsuc2l6ZSxcbiAgICAgICAgICAgIGluZGV4OiBrLmluZGV4LFxuICAgICAgICAgICAga2V5OiBzdCxcbiAgICAgICAgICAgIHR5cGU6IGsudHlwZSB8fCBcIml0ZW1cIixcbiAgICAgICAgICAgIC4uLmsudHlwZSA9PT0gXCJncm91cFwiID8ge30gOiB7IGdyb3VwSW5kZXg6IGsuZ3JvdXBJbmRleCB9XG4gICAgICAgICAgfVxuICAgICAgICApIDogay50eXBlID09PSBcImdyb3VwXCIgPyAvKiBAX19QVVJFX18gKi8gJHQoXG4gICAgICAgICAgQixcbiAgICAgICAgICB7XG4gICAgICAgICAgICAuLi5aKEIsIGYpLFxuICAgICAgICAgICAgXCJkYXRhLWluZGV4XCI6IHEsXG4gICAgICAgICAgICBcImRhdGEtaXRlbS1pbmRleFwiOiBrLmluZGV4LFxuICAgICAgICAgICAgXCJkYXRhLWtub3duLXNpemVcIjogay5zaXplLFxuICAgICAgICAgICAga2V5OiBzdCxcbiAgICAgICAgICAgIHN0eWxlOiBuclxuICAgICAgICAgIH0sXG4gICAgICAgICAgUyhrLmluZGV4LCBmKVxuICAgICAgICApIDogLyogQF9fUFVSRV9fICovICR0KFxuICAgICAgICAgIFIsXG4gICAgICAgICAge1xuICAgICAgICAgICAgLi4uWihSLCBmKSxcbiAgICAgICAgICAgIC4uLnRvKFIsIGsuZGF0YSksXG4gICAgICAgICAgICBcImRhdGEtaW5kZXhcIjogcSxcbiAgICAgICAgICAgIFwiZGF0YS1pdGVtLWdyb3VwLWluZGV4XCI6IGsuZ3JvdXBJbmRleCxcbiAgICAgICAgICAgIFwiZGF0YS1pdGVtLWluZGV4XCI6IGsuaW5kZXgsXG4gICAgICAgICAgICBcImRhdGEta25vd24tc2l6ZVwiOiBrLnNpemUsXG4gICAgICAgICAgICBrZXk6IHN0LFxuICAgICAgICAgICAgc3R5bGU6IEMgPyBvciA6IFFuXG4gICAgICAgICAgfSxcbiAgICAgICAgICBWID8gdShrLmluZGV4LCBrLmdyb3VwSW5kZXgsIGsuZGF0YSwgZikgOiB1KGsuaW5kZXgsIGsuZGF0YSwgZilcbiAgICAgICAgKTtcbiAgICAgIH0pXG4gICAgfVxuICApO1xufSksIHJyID0ge1xuICBoZWlnaHQ6IFwiMTAwJVwiLFxuICBvdXRsaW5lOiBcIm5vbmVcIixcbiAgb3ZlcmZsb3dZOiBcImF1dG9cIixcbiAgcG9zaXRpb246IFwicmVsYXRpdmVcIixcbiAgV2Via2l0T3ZlcmZsb3dTY3JvbGxpbmc6IFwidG91Y2hcIlxufSwgc3IgPSB7XG4gIG91dGxpbmU6IFwibm9uZVwiLFxuICBvdmVyZmxvd1g6IFwiYXV0b1wiLFxuICBwb3NpdGlvbjogXCJyZWxhdGl2ZVwiXG59LCBadCA9ICh0KSA9PiAoe1xuICBoZWlnaHQ6IFwiMTAwJVwiLFxuICBwb3NpdGlvbjogXCJhYnNvbHV0ZVwiLFxuICB0b3A6IDAsXG4gIHdpZHRoOiBcIjEwMCVcIixcbiAgLi4udCA/IHsgZGlzcGxheTogXCJmbGV4XCIsIGZsZXhEaXJlY3Rpb246IFwiY29sdW1uXCIgfSA6IHt9XG59KSwgaXIgPSB7XG4gIHBvc2l0aW9uOiBKbigpLFxuICB0b3A6IDAsXG4gIHdpZHRoOiBcIjEwMCVcIixcbiAgekluZGV4OiAxXG59O1xuZnVuY3Rpb24gWih0LCBlKSB7XG4gIGlmICh0eXBlb2YgdCAhPSBcInN0cmluZ1wiKVxuICAgIHJldHVybiB7IGNvbnRleHQ6IGUgfTtcbn1cbmZ1bmN0aW9uIHRvKHQsIGUpIHtcbiAgcmV0dXJuIHsgaXRlbTogdHlwZW9mIHQgPT0gXCJzdHJpbmdcIiA/IHZvaWQgMCA6IGUgfTtcbn1cbmNvbnN0IGxyID0gLyogQF9fUFVSRV9fICovIEgubWVtbyhmdW5jdGlvbigpIHtcbiAgY29uc3QgZSA9IE0oXCJIZWFkZXJDb21wb25lbnRcIiksIG4gPSBndChcImhlYWRlckhlaWdodFwiKSwgbyA9IE0oXCJIZWFkZXJGb290ZXJUYWdcIiksIHIgPSBIdChcbiAgICBILnVzZU1lbW8oXG4gICAgICAoKSA9PiAoaSkgPT4ge1xuICAgICAgICBuKHd0KGksIFwiaGVpZ2h0XCIpKTtcbiAgICAgIH0sXG4gICAgICBbbl1cbiAgICApLFxuICAgICEwLFxuICAgIE0oXCJza2lwQW5pbWF0aW9uRnJhbWVJblJlc2l6ZU9ic2VydmVyXCIpXG4gICksIHMgPSBNKFwiY29udGV4dFwiKTtcbiAgcmV0dXJuIGUgPyAvKiBAX19QVVJFX18gKi8geihvLCB7IHJlZjogciwgY2hpbGRyZW46IC8qIEBfX1BVUkVfXyAqLyB6KGUsIHsgLi4uWihlLCBzKSB9KSB9KSA6IG51bGw7XG59KSwgY3IgPSAvKiBAX19QVVJFX18gKi8gSC5tZW1vKGZ1bmN0aW9uKCkge1xuICBjb25zdCBlID0gTShcIkZvb3RlckNvbXBvbmVudFwiKSwgbiA9IGd0KFwiZm9vdGVySGVpZ2h0XCIpLCBvID0gTShcIkhlYWRlckZvb3RlclRhZ1wiKSwgciA9IEh0KFxuICAgIEgudXNlTWVtbyhcbiAgICAgICgpID0+IChpKSA9PiB7XG4gICAgICAgIG4od3QoaSwgXCJoZWlnaHRcIikpO1xuICAgICAgfSxcbiAgICAgIFtuXVxuICAgICksXG4gICAgITAsXG4gICAgTShcInNraXBBbmltYXRpb25GcmFtZUluUmVzaXplT2JzZXJ2ZXJcIilcbiAgKSwgcyA9IE0oXCJjb250ZXh0XCIpO1xuICByZXR1cm4gZSA/IC8qIEBfX1BVUkVfXyAqLyB6KG8sIHsgcmVmOiByLCBjaGlsZHJlbjogLyogQF9fUFVSRV9fICovIHooZSwgeyAuLi5aKGUsIHMpIH0pIH0pIDogbnVsbDtcbn0pO1xuZnVuY3Rpb24gWmUoeyB1c2VFbWl0dGVyOiB0LCB1c2VFbWl0dGVyVmFsdWU6IGUsIHVzZVB1Ymxpc2hlcjogbiB9KSB7XG4gIHJldHVybiBILm1lbW8oZnVuY3Rpb24oeyBjaGlsZHJlbjogcywgc3R5bGU6IGksIC4uLmwgfSkge1xuICAgIGNvbnN0IGMgPSBuKFwic2Nyb2xsQ29udGFpbmVyU3RhdGVcIiksIHUgPSBlKFwiU2Nyb2xsZXJDb21wb25lbnRcIiksIGYgPSBuKFwic21vb3RoU2Nyb2xsVGFyZ2V0UmVhY2hlZFwiKSwgUyA9IGUoXCJzY3JvbGxlclJlZlwiKSwgcCA9IGUoXCJjb250ZXh0XCIpLCBtID0gZShcImhvcml6b250YWxEaXJlY3Rpb25cIikgfHwgITEsIHsgc2Nyb2xsQnlDYWxsYmFjazogdywgc2Nyb2xsZXJSZWY6IEksIHNjcm9sbFRvQ2FsbGJhY2s6IEMgfSA9IFhuKFxuICAgICAgYyxcbiAgICAgIGYsXG4gICAgICB1LFxuICAgICAgUyxcbiAgICAgIHZvaWQgMCxcbiAgICAgIG1cbiAgICApO1xuICAgIHJldHVybiB0KFwic2Nyb2xsVG9cIiwgQyksIHQoXCJzY3JvbGxCeVwiLCB3KSwgLyogQF9fUFVSRV9fICovIHooXG4gICAgICB1LFxuICAgICAge1xuICAgICAgICBcImRhdGEtdGVzdGlkXCI6IFwidmlydHVvc28tc2Nyb2xsZXJcIixcbiAgICAgICAgXCJkYXRhLXZpcnR1b3NvLXNjcm9sbGVyXCI6ICEwLFxuICAgICAgICByZWY6IEksXG4gICAgICAgIHN0eWxlOiB7IC4uLm0gPyBzciA6IHJyLCAuLi5pIH0sXG4gICAgICAgIHRhYkluZGV4OiAwLFxuICAgICAgICAuLi5sLFxuICAgICAgICAuLi5aKHUsIHApLFxuICAgICAgICBjaGlsZHJlbjogc1xuICAgICAgfVxuICAgICk7XG4gIH0pO1xufVxuZnVuY3Rpb24gWGUoeyB1c2VFbWl0dGVyOiB0LCB1c2VFbWl0dGVyVmFsdWU6IGUsIHVzZVB1Ymxpc2hlcjogbiB9KSB7XG4gIHJldHVybiBILm1lbW8oZnVuY3Rpb24oeyBjaGlsZHJlbjogcywgc3R5bGU6IGksIC4uLmwgfSkge1xuICAgIGNvbnN0IGMgPSBuKFwid2luZG93U2Nyb2xsQ29udGFpbmVyU3RhdGVcIiksIHUgPSBlKFwiU2Nyb2xsZXJDb21wb25lbnRcIiksIGYgPSBuKFwic21vb3RoU2Nyb2xsVGFyZ2V0UmVhY2hlZFwiKSwgUyA9IGUoXCJ0b3RhbExpc3RIZWlnaHRcIiksIHAgPSBlKFwiZGV2aWF0aW9uXCIpLCBtID0gZShcImN1c3RvbVNjcm9sbFBhcmVudFwiKSwgdyA9IGUoXCJjb250ZXh0XCIpLCBJID0gSC51c2VSZWYobnVsbCksIEMgPSBlKFwic2Nyb2xsZXJSZWZcIiksIHsgc2Nyb2xsQnlDYWxsYmFjazogZywgc2Nyb2xsZXJSZWY6IGEsIHNjcm9sbFRvQ2FsbGJhY2s6IFQgfSA9IFhuKFxuICAgICAgYyxcbiAgICAgIGYsXG4gICAgICB1LFxuICAgICAgQyxcbiAgICAgIG1cbiAgICApO1xuICAgIHJldHVybiBabigoKSA9PiB7XG4gICAgICB2YXIgYjtcbiAgICAgIHJldHVybiBhLmN1cnJlbnQgPSBtIHx8ICgoYiA9IEkuY3VycmVudCkgPT0gbnVsbCA/IHZvaWQgMCA6IGIub3duZXJEb2N1bWVudC5kZWZhdWx0VmlldyksICgpID0+IHtcbiAgICAgICAgYS5jdXJyZW50ID0gbnVsbDtcbiAgICAgIH07XG4gICAgfSwgW2EsIG1dKSwgdChcIndpbmRvd1Njcm9sbFRvXCIsIFQpLCB0KFwic2Nyb2xsQnlcIiwgZyksIC8qIEBfX1BVUkVfXyAqLyB6KFxuICAgICAgdSxcbiAgICAgIHtcbiAgICAgICAgcmVmOiBJLFxuICAgICAgICBcImRhdGEtdmlydHVvc28tc2Nyb2xsZXJcIjogITAsXG4gICAgICAgIHN0eWxlOiB7IHBvc2l0aW9uOiBcInJlbGF0aXZlXCIsIC4uLmksIC4uLlMgIT09IDAgPyB7IGhlaWdodDogUyArIHAgfSA6IHt9IH0sXG4gICAgICAgIC4uLmwsXG4gICAgICAgIC4uLloodSwgdyksXG4gICAgICAgIGNoaWxkcmVuOiBzXG4gICAgICB9XG4gICAgKTtcbiAgfSk7XG59XG5jb25zdCB1ciA9ICh7IGNoaWxkcmVuOiB0IH0pID0+IHtcbiAgY29uc3QgZSA9IEgudXNlQ29udGV4dChSZSksIG4gPSBndChcInZpZXdwb3J0SGVpZ2h0XCIpLCBvID0gZ3QoXCJmaXhlZEl0ZW1IZWlnaHRcIiksIHIgPSBNKFwiYWxpZ25Ub0JvdHRvbVwiKSwgcyA9IE0oXCJob3Jpem9udGFsRGlyZWN0aW9uXCIpLCBpID0gSC51c2VNZW1vKFxuICAgICgpID0+IG5lKG4sIChjKSA9PiB3dChjLCBzID8gXCJ3aWR0aFwiIDogXCJoZWlnaHRcIikpLFxuICAgIFtuLCBzXVxuICApLCBsID0gSHQoaSwgITAsIE0oXCJza2lwQW5pbWF0aW9uRnJhbWVJblJlc2l6ZU9ic2VydmVyXCIpKTtcbiAgcmV0dXJuIEgudXNlRWZmZWN0KCgpID0+IHtcbiAgICBlICYmIChuKGUudmlld3BvcnRIZWlnaHQpLCBvKGUuaXRlbUhlaWdodCkpO1xuICB9LCBbZSwgbiwgb10pLCAvKiBAX19QVVJFX18gKi8geihcImRpdlwiLCB7IFwiZGF0YS12aWV3cG9ydC10eXBlXCI6IFwiZWxlbWVudFwiLCByZWY6IGwsIHN0eWxlOiBadChyKSwgY2hpbGRyZW46IHQgfSk7XG59LCBhciA9ICh7IGNoaWxkcmVuOiB0IH0pID0+IHtcbiAgY29uc3QgZSA9IEgudXNlQ29udGV4dChSZSksIG4gPSBndChcIndpbmRvd1ZpZXdwb3J0UmVjdFwiKSwgbyA9IGd0KFwiZml4ZWRJdGVtSGVpZ2h0XCIpLCByID0gTShcImN1c3RvbVNjcm9sbFBhcmVudFwiKSwgcyA9IEdlKFxuICAgIG4sXG4gICAgcixcbiAgICBNKFwic2tpcEFuaW1hdGlvbkZyYW1lSW5SZXNpemVPYnNlcnZlclwiKVxuICApLCBpID0gTShcImFsaWduVG9Cb3R0b21cIik7XG4gIHJldHVybiBILnVzZUVmZmVjdCgoKSA9PiB7XG4gICAgZSAmJiAobyhlLml0ZW1IZWlnaHQpLCBuKHsgb2Zmc2V0VG9wOiAwLCB2aXNpYmxlSGVpZ2h0OiBlLnZpZXdwb3J0SGVpZ2h0LCB2aXNpYmxlV2lkdGg6IDEwMCB9KSk7XG4gIH0sIFtlLCBuLCBvXSksIC8qIEBfX1BVUkVfXyAqLyB6KFwiZGl2XCIsIHsgXCJkYXRhLXZpZXdwb3J0LXR5cGVcIjogXCJ3aW5kb3dcIiwgcmVmOiBzLCBzdHlsZTogWnQoaSksIGNoaWxkcmVuOiB0IH0pO1xufSwgZHIgPSAoeyBjaGlsZHJlbjogdCB9KSA9PiB7XG4gIGNvbnN0IGUgPSBNKFwiVG9wSXRlbUxpc3RDb21wb25lbnRcIikgfHwgXCJkaXZcIiwgbiA9IE0oXCJoZWFkZXJIZWlnaHRcIiksIG8gPSB7IC4uLmlyLCBtYXJnaW5Ub3A6IGAke259cHhgIH0sIHIgPSBNKFwiY29udGV4dFwiKTtcbiAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyB6KGUsIHsgc3R5bGU6IG8sIC4uLlooZSwgciksIGNoaWxkcmVuOiB0IH0pO1xufSwgZnIgPSAvKiBAX19QVVJFX18gKi8gSC5tZW1vKGZ1bmN0aW9uKGUpIHtcbiAgY29uc3QgbiA9IE0oXCJ1c2VXaW5kb3dTY3JvbGxcIiksIG8gPSBNKFwidG9wSXRlbXNJbmRleGVzXCIpLmxlbmd0aCA+IDAsIHIgPSBNKFwiY3VzdG9tU2Nyb2xsUGFyZW50XCIpLCBzID0gTShcImNvbnRleHRcIiksIGkgPSByIHx8IG4gPyBwciA6IG1yLCBsID0gciB8fCBuID8gYXIgOiB1cjtcbiAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBLdChpLCB7IC4uLmUsIC4uLlooaSwgcyksIGNoaWxkcmVuOiBbXG4gICAgbyAmJiAvKiBAX19QVVJFX18gKi8geihkciwgeyBjaGlsZHJlbjogLyogQF9fUFVSRV9fICovIHooVG4sIHsgc2hvd1RvcExpc3Q6ICEwIH0pIH0pLFxuICAgIC8qIEBfX1BVUkVfXyAqLyBLdChsLCB7IGNoaWxkcmVuOiBbXG4gICAgICAvKiBAX19QVVJFX18gKi8geihsciwge30pLFxuICAgICAgLyogQF9fUFVSRV9fICovIHooVG4sIHt9KSxcbiAgICAgIC8qIEBfX1BVUkVfXyAqLyB6KGNyLCB7fSlcbiAgICBdIH0pXG4gIF0gfSk7XG59KSwge1xuICBDb21wb25lbnQ6IGVvLFxuICB1c2VFbWl0dGVyOiBKZSxcbiAgdXNlRW1pdHRlclZhbHVlOiBNLFxuICB1c2VQdWJsaXNoZXI6IGd0XG59ID0gLyogQF9fUFVSRV9fICovIHFlKFxuICB0cixcbiAge1xuICAgIGV2ZW50czoge1xuICAgICAgYXRCb3R0b21TdGF0ZUNoYW5nZTogXCJhdEJvdHRvbVN0YXRlQ2hhbmdlXCIsXG4gICAgICBhdFRvcFN0YXRlQ2hhbmdlOiBcImF0VG9wU3RhdGVDaGFuZ2VcIixcbiAgICAgIGVuZFJlYWNoZWQ6IFwiZW5kUmVhY2hlZFwiLFxuICAgICAgZ3JvdXBJbmRpY2VzOiBcImdyb3VwSW5kaWNlc1wiLFxuICAgICAgaXNTY3JvbGxpbmc6IFwiaXNTY3JvbGxpbmdcIixcbiAgICAgIGl0ZW1zUmVuZGVyZWQ6IFwiaXRlbXNSZW5kZXJlZFwiLFxuICAgICAgcmFuZ2VDaGFuZ2VkOiBcInJhbmdlQ2hhbmdlZFwiLFxuICAgICAgc3RhcnRSZWFjaGVkOiBcInN0YXJ0UmVhY2hlZFwiLFxuICAgICAgdG90YWxMaXN0SGVpZ2h0Q2hhbmdlZDogXCJ0b3RhbExpc3RIZWlnaHRDaGFuZ2VkXCJcbiAgICB9LFxuICAgIG1ldGhvZHM6IHtcbiAgICAgIGF1dG9zY3JvbGxUb0JvdHRvbTogXCJhdXRvc2Nyb2xsVG9Cb3R0b21cIixcbiAgICAgIGdldFN0YXRlOiBcImdldFN0YXRlXCIsXG4gICAgICBzY3JvbGxCeTogXCJzY3JvbGxCeVwiLFxuICAgICAgc2Nyb2xsSW50b1ZpZXc6IFwic2Nyb2xsSW50b1ZpZXdcIixcbiAgICAgIHNjcm9sbFRvOiBcInNjcm9sbFRvXCIsXG4gICAgICBzY3JvbGxUb0luZGV4OiBcInNjcm9sbFRvSW5kZXhcIlxuICAgIH0sXG4gICAgb3B0aW9uYWw6IHtcbiAgICAgIGFsaWduVG9Cb3R0b206IFwiYWxpZ25Ub0JvdHRvbVwiLFxuICAgICAgYXRCb3R0b21UaHJlc2hvbGQ6IFwiYXRCb3R0b21UaHJlc2hvbGRcIixcbiAgICAgIGF0VG9wVGhyZXNob2xkOiBcImF0VG9wVGhyZXNob2xkXCIsXG4gICAgICBjb21wb25lbnRzOiBcImNvbXBvbmVudHNcIixcbiAgICAgIGNvbXB1dGVJdGVtS2V5OiBcImNvbXB1dGVJdGVtS2V5XCIsXG4gICAgICBjb250ZXh0OiBcImNvbnRleHRcIixcbiAgICAgIGN1c3RvbVNjcm9sbFBhcmVudDogXCJjdXN0b21TY3JvbGxQYXJlbnRcIixcbiAgICAgIGRhdGE6IFwiZGF0YVwiLFxuICAgICAgZGVmYXVsdEl0ZW1IZWlnaHQ6IFwiZGVmYXVsdEl0ZW1IZWlnaHRcIixcbiAgICAgIGZpcnN0SXRlbUluZGV4OiBcImZpcnN0SXRlbUluZGV4XCIsXG4gICAgICBmaXhlZEl0ZW1IZWlnaHQ6IFwiZml4ZWRJdGVtSGVpZ2h0XCIsXG4gICAgICBmb2xsb3dPdXRwdXQ6IFwiZm9sbG93T3V0cHV0XCIsXG4gICAgICBncm91cENvbnRlbnQ6IFwiZ3JvdXBDb250ZW50XCIsXG4gICAgICBncm91cENvdW50czogXCJncm91cENvdW50c1wiLFxuICAgICAgaGVhZGVyRm9vdGVyVGFnOiBcIkhlYWRlckZvb3RlclRhZ1wiLFxuICAgICAgaG9yaXpvbnRhbERpcmVjdGlvbjogXCJob3Jpem9udGFsRGlyZWN0aW9uXCIsXG4gICAgICBpbmNyZWFzZVZpZXdwb3J0Qnk6IFwiaW5jcmVhc2VWaWV3cG9ydEJ5XCIsXG4gICAgICBpbml0aWFsSXRlbUNvdW50OiBcImluaXRpYWxJdGVtQ291bnRcIixcbiAgICAgIGluaXRpYWxTY3JvbGxUb3A6IFwiaW5pdGlhbFNjcm9sbFRvcFwiLFxuICAgICAgaW5pdGlhbFRvcE1vc3RJdGVtSW5kZXg6IFwiaW5pdGlhbFRvcE1vc3RJdGVtSW5kZXhcIixcbiAgICAgIGl0ZW1Db250ZW50OiBcIml0ZW1Db250ZW50XCIsXG4gICAgICBpdGVtU2l6ZTogXCJpdGVtU2l6ZVwiLFxuICAgICAgbG9nTGV2ZWw6IFwibG9nTGV2ZWxcIixcbiAgICAgIG92ZXJzY2FuOiBcIm92ZXJzY2FuXCIsXG4gICAgICByZXN0b3JlU3RhdGVGcm9tOiBcInJlc3RvcmVTdGF0ZUZyb21cIixcbiAgICAgIHNjcm9sbGVyUmVmOiBcInNjcm9sbGVyUmVmXCIsXG4gICAgICBzY3JvbGxTZWVrQ29uZmlndXJhdGlvbjogXCJzY3JvbGxTZWVrQ29uZmlndXJhdGlvblwiLFxuICAgICAgc2tpcEFuaW1hdGlvbkZyYW1lSW5SZXNpemVPYnNlcnZlcjogXCJza2lwQW5pbWF0aW9uRnJhbWVJblJlc2l6ZU9ic2VydmVyXCIsXG4gICAgICB0b3BJdGVtQ291bnQ6IFwidG9wSXRlbUNvdW50XCIsXG4gICAgICB0b3RhbENvdW50OiBcInRvdGFsQ291bnRcIixcbiAgICAgIHVzZVdpbmRvd1Njcm9sbDogXCJ1c2VXaW5kb3dTY3JvbGxcIlxuICAgIH0sXG4gICAgcmVxdWlyZWQ6IHt9XG4gIH0sXG4gIGZyXG4pLCBtciA9IC8qIEBfX1BVUkVfXyAqLyBaZSh7IHVzZUVtaXR0ZXI6IEplLCB1c2VFbWl0dGVyVmFsdWU6IE0sIHVzZVB1Ymxpc2hlcjogZ3QgfSksIHByID0gLyogQF9fUFVSRV9fICovIFhlKHsgdXNlRW1pdHRlcjogSmUsIHVzZUVtaXR0ZXJWYWx1ZTogTSwgdXNlUHVibGlzaGVyOiBndCB9KSwgS3IgPSBlbywganIgPSBlbywgaHIgPSAvKiBAX19QVVJFX18gKi8gVSgoKSA9PiB7XG4gIGNvbnN0IHQgPSB5KChjKSA9PiAvKiBAX19QVVJFX18gKi8gS3QoXCJ0ZFwiLCB7IGNoaWxkcmVuOiBbXG4gICAgXCJJdGVtICRcIixcbiAgICBjXG4gIF0gfSkpLCBlID0geShudWxsKSwgbiA9IHkobnVsbCksIG8gPSB5KG51bGwpLCByID0geSh7fSksIHMgPSB5KFllKSwgaSA9IHkoWXQpLCBsID0gKGMsIHUgPSBudWxsKSA9PiBjdChcbiAgICB4KFxuICAgICAgcixcbiAgICAgIEUoKGYpID0+IGZbY10pLFxuICAgICAgWSgpXG4gICAgKSxcbiAgICB1XG4gICk7XG4gIHJldHVybiB7XG4gICAgY29tcG9uZW50czogcixcbiAgICBjb21wdXRlSXRlbUtleTogcyxcbiAgICBjb250ZXh0OiBlLFxuICAgIEVtcHR5UGxhY2Vob2xkZXI6IGwoXCJFbXB0eVBsYWNlaG9sZGVyXCIpLFxuICAgIEZpbGxlclJvdzogbChcIkZpbGxlclJvd1wiKSxcbiAgICBmaXhlZEZvb3RlckNvbnRlbnQ6IG8sXG4gICAgZml4ZWRIZWFkZXJDb250ZW50OiBuLFxuICAgIGl0ZW1Db250ZW50OiB0LFxuICAgIFNjcm9sbGVyQ29tcG9uZW50OiBsKFwiU2Nyb2xsZXJcIiwgXCJkaXZcIiksXG4gICAgc2Nyb2xsZXJSZWY6IGksXG4gICAgU2Nyb2xsU2Vla1BsYWNlaG9sZGVyOiBsKFwiU2Nyb2xsU2Vla1BsYWNlaG9sZGVyXCIpLFxuICAgIFRhYmxlQm9keUNvbXBvbmVudDogbChcIlRhYmxlQm9keVwiLCBcInRib2R5XCIpLFxuICAgIFRhYmxlQ29tcG9uZW50OiBsKFwiVGFibGVcIiwgXCJ0YWJsZVwiKSxcbiAgICBUYWJsZUZvb3RlckNvbXBvbmVudDogbChcIlRhYmxlRm9vdFwiLCBcInRmb290XCIpLFxuICAgIFRhYmxlSGVhZENvbXBvbmVudDogbChcIlRhYmxlSGVhZFwiLCBcInRoZWFkXCIpLFxuICAgIFRhYmxlUm93Q29tcG9uZW50OiBsKFwiVGFibGVSb3dcIiwgXCJ0clwiKVxuICB9O1xufSksIGdyID0gLyogQF9fUFVSRV9fICovIFUoXG4gIChbdCwgZV0pID0+ICh7IC4uLnQsIC4uLmUgfSksXG4gIFgocW4sIGhyKVxuKSwgSXIgPSAoeyBoZWlnaHQ6IHQgfSkgPT4gLyogQF9fUFVSRV9fICovIHooXCJ0clwiLCB7IGNoaWxkcmVuOiAvKiBAX19QVVJFX18gKi8geihcInRkXCIsIHsgc3R5bGU6IHsgaGVpZ2h0OiB0IH0gfSkgfSksIFNyID0gKHsgaGVpZ2h0OiB0IH0pID0+IC8qIEBfX1BVUkVfXyAqLyB6KFwidHJcIiwgeyBjaGlsZHJlbjogLyogQF9fUFVSRV9fICovIHooXCJ0ZFwiLCB7IHN0eWxlOiB7IGJvcmRlcjogMCwgaGVpZ2h0OiB0LCBwYWRkaW5nOiAwIH0gfSkgfSksIHhyID0geyBvdmVyZmxvd0FuY2hvcjogXCJub25lXCIgfSwgQ24gPSAvKiBAX19QVVJFX18gKi8gSC5tZW1vKGZ1bmN0aW9uKHsgc2hvd1RvcExpc3Q6IGUgPSAhMSB9KSB7XG4gIGNvbnN0IG4gPSBfKFwibGlzdFN0YXRlXCIpLCBvID0gXyhcImNvbXB1dGVJdGVtS2V5XCIpLCByID0gXyhcImZpcnN0SXRlbUluZGV4XCIpLCBzID0gXyhcImlzU2Vla2luZ1wiKSwgaSA9IF8oXCJTY3JvbGxTZWVrUGxhY2Vob2xkZXJcIikgfHwgSXIsIGwgPSBfKFwiY29udGV4dFwiKSwgYyA9IF8oXCJUYWJsZVJvd0NvbXBvbmVudFwiKSwgdSA9IF8oXCJmaXhlZEhlYWRlckhlaWdodFwiKSwgZiA9IF8oXCJpdGVtQ29udGVudFwiKSwgUyA9IChlID8gbi50b3BJdGVtcyA6IFtdKS5yZWR1Y2UoKG0sIHcsIEkpID0+IChJID09PSAwID8gbS5wdXNoKHcuc2l6ZSkgOiBtLnB1c2gobVtJIC0gMV0gKyB3LnNpemUpLCBtKSwgW10pLCBwID0gKGUgPyBuLnRvcEl0ZW1zIDogbi5pdGVtcykubWFwKChtKSA9PiB7XG4gICAgY29uc3QgdyA9IG0ub3JpZ2luYWxJbmRleCwgSSA9IG8odyArIHIsIG0uZGF0YSwgbCksIEMgPSBlID8gdyA9PT0gMCA/IDAgOiBTW3cgLSAxXSA6IDA7XG4gICAgcmV0dXJuIHMgPyAvKiBAX19QVVJFX18gKi8gJHQoXG4gICAgICBpLFxuICAgICAge1xuICAgICAgICAuLi5aKGksIGwpLFxuICAgICAgICBoZWlnaHQ6IG0uc2l6ZSxcbiAgICAgICAgaW5kZXg6IG0uaW5kZXgsXG4gICAgICAgIGtleTogSSxcbiAgICAgICAgdHlwZTogbS50eXBlIHx8IFwiaXRlbVwiXG4gICAgICB9XG4gICAgKSA6IC8qIEBfX1BVUkVfXyAqLyAkdChcbiAgICAgIGMsXG4gICAgICB7XG4gICAgICAgIC4uLlooYywgbCksXG4gICAgICAgIC4uLnRvKGMsIG0uZGF0YSksXG4gICAgICAgIFwiZGF0YS1pbmRleFwiOiB3LFxuICAgICAgICBcImRhdGEtaXRlbS1pbmRleFwiOiBtLmluZGV4LFxuICAgICAgICBcImRhdGEta25vd24tc2l6ZVwiOiBtLnNpemUsXG4gICAgICAgIGtleTogSSxcbiAgICAgICAgc3R5bGU6IGUgPyB7IG92ZXJmbG93QW5jaG9yOiBcIm5vbmVcIiwgcG9zaXRpb246IFwic3RpY2t5XCIsIHRvcDogdSArIEMsIHpJbmRleDogMiB9IDogeHJcbiAgICAgIH0sXG4gICAgICBmKG0uaW5kZXgsIG0uZGF0YSwgbClcbiAgICApO1xuICB9KTtcbiAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyB6KGlvLCB7IGNoaWxkcmVuOiBwIH0pO1xufSksIFRyID0gLyogQF9fUFVSRV9fICovIEgubWVtbyhmdW5jdGlvbigpIHtcbiAgY29uc3QgZSA9IF8oXCJsaXN0U3RhdGVcIiksIG4gPSBfKFwidG9wSXRlbXNJbmRleGVzXCIpLmxlbmd0aCA+IDAsIG8gPSBUdChcInNpemVSYW5nZXNcIiksIHIgPSBfKFwidXNlV2luZG93U2Nyb2xsXCIpLCBzID0gXyhcImN1c3RvbVNjcm9sbFBhcmVudFwiKSwgaSA9IFR0KFwid2luZG93U2Nyb2xsQ29udGFpbmVyU3RhdGVcIiksIGwgPSBUdChcInNjcm9sbENvbnRhaW5lclN0YXRlXCIpLCBjID0gcyB8fCByID8gaSA6IGwsIHUgPSBfKFwidHJhY2tJdGVtU2l6ZXNcIiksIGYgPSBfKFwiaXRlbVNpemVcIiksIFMgPSBfKFwibG9nXCIpLCB7IGNhbGxiYWNrUmVmOiBwLCByZWY6IG0gfSA9IE9uKFxuICAgIG8sXG4gICAgZixcbiAgICB1LFxuICAgIGMsXG4gICAgUyxcbiAgICB2b2lkIDAsXG4gICAgcyxcbiAgICAhMSxcbiAgICBfKFwic2tpcEFuaW1hdGlvbkZyYW1lSW5SZXNpemVPYnNlcnZlclwiKVxuICApLCBbdywgSV0gPSBILnVzZVN0YXRlKDApO1xuICBRZShcImRldmlhdGlvblwiLCAoVikgPT4ge1xuICAgIHcgIT09IFYgJiYgKG0uY3VycmVudC5zdHlsZS5tYXJnaW5Ub3AgPSBgJHtWfXB4YCwgSShWKSk7XG4gIH0pO1xuICBjb25zdCBDID0gXyhcIkVtcHR5UGxhY2Vob2xkZXJcIiksIGcgPSBfKFwiRmlsbGVyUm93XCIpIHx8IFNyLCBhID0gXyhcIlRhYmxlQm9keUNvbXBvbmVudFwiKSwgVCA9IF8oXCJwYWRkaW5nVG9wQWRkaXRpb25cIiksIGIgPSBfKFwic3RhdGVmdWxUb3RhbENvdW50XCIpLCBoID0gXyhcImNvbnRleHRcIik7XG4gIGlmIChiID09PSAwICYmIEMpXG4gICAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyB6KEMsIHsgLi4uWihDLCBoKSB9KTtcbiAgY29uc3QgZCA9IChuID8gZS50b3BJdGVtcyA6IFtdKS5yZWR1Y2UoKFYsIEQpID0+IFYgKyBELnNpemUsIDApLCBSID0gZS5vZmZzZXRUb3AgKyBUICsgdyAtIGQsIEIgPSBlLm9mZnNldEJvdHRvbSwgTyA9IFIgPiAwID8gLyogQF9fUFVSRV9fICovIHooZywgeyBjb250ZXh0OiBoLCBoZWlnaHQ6IFIgfSwgXCJwYWRkaW5nLXRvcFwiKSA6IG51bGwsIEwgPSBCID4gMCA/IC8qIEBfX1BVUkVfXyAqLyB6KGcsIHsgY29udGV4dDogaCwgaGVpZ2h0OiBCIH0sIFwicGFkZGluZy1ib3R0b21cIikgOiBudWxsO1xuICByZXR1cm4gLyogQF9fUFVSRV9fICovIEt0KGEsIHsgXCJkYXRhLXRlc3RpZFwiOiBcInZpcnR1b3NvLWl0ZW0tbGlzdFwiLCByZWY6IHAsIC4uLlooYSwgaCksIGNoaWxkcmVuOiBbXG4gICAgTyxcbiAgICBuICYmIC8qIEBfX1BVUkVfXyAqLyB6KENuLCB7IHNob3dUb3BMaXN0OiAhMCB9KSxcbiAgICAvKiBAX19QVVJFX18gKi8geihDbiwge30pLFxuICAgIExcbiAgXSB9KTtcbn0pLCBDciA9ICh7IGNoaWxkcmVuOiB0IH0pID0+IHtcbiAgY29uc3QgZSA9IEgudXNlQ29udGV4dChSZSksIG4gPSBUdChcInZpZXdwb3J0SGVpZ2h0XCIpLCBvID0gVHQoXCJmaXhlZEl0ZW1IZWlnaHRcIiksIHIgPSBIdChcbiAgICBILnVzZU1lbW8oKCkgPT4gbmUobiwgKHMpID0+IHd0KHMsIFwiaGVpZ2h0XCIpKSwgW25dKSxcbiAgICAhMCxcbiAgICBfKFwic2tpcEFuaW1hdGlvbkZyYW1lSW5SZXNpemVPYnNlcnZlclwiKVxuICApO1xuICByZXR1cm4gSC51c2VFZmZlY3QoKCkgPT4ge1xuICAgIGUgJiYgKG4oZS52aWV3cG9ydEhlaWdodCksIG8oZS5pdGVtSGVpZ2h0KSk7XG4gIH0sIFtlLCBuLCBvXSksIC8qIEBfX1BVUkVfXyAqLyB6KFwiZGl2XCIsIHsgXCJkYXRhLXZpZXdwb3J0LXR5cGVcIjogXCJlbGVtZW50XCIsIHJlZjogciwgc3R5bGU6IFp0KCExKSwgY2hpbGRyZW46IHQgfSk7XG59LCB3ciA9ICh7IGNoaWxkcmVuOiB0IH0pID0+IHtcbiAgY29uc3QgZSA9IEgudXNlQ29udGV4dChSZSksIG4gPSBUdChcIndpbmRvd1ZpZXdwb3J0UmVjdFwiKSwgbyA9IFR0KFwiZml4ZWRJdGVtSGVpZ2h0XCIpLCByID0gXyhcImN1c3RvbVNjcm9sbFBhcmVudFwiKSwgcyA9IEdlKFxuICAgIG4sXG4gICAgcixcbiAgICBfKFwic2tpcEFuaW1hdGlvbkZyYW1lSW5SZXNpemVPYnNlcnZlclwiKVxuICApO1xuICByZXR1cm4gSC51c2VFZmZlY3QoKCkgPT4ge1xuICAgIGUgJiYgKG8oZS5pdGVtSGVpZ2h0KSwgbih7IG9mZnNldFRvcDogMCwgdmlzaWJsZUhlaWdodDogZS52aWV3cG9ydEhlaWdodCwgdmlzaWJsZVdpZHRoOiAxMDAgfSkpO1xuICB9LCBbZSwgbiwgb10pLCAvKiBAX19QVVJFX18gKi8geihcImRpdlwiLCB7IFwiZGF0YS12aWV3cG9ydC10eXBlXCI6IFwid2luZG93XCIsIHJlZjogcywgc3R5bGU6IFp0KCExKSwgY2hpbGRyZW46IHQgfSk7XG59LCB5ciA9IC8qIEBfX1BVUkVfXyAqLyBILm1lbW8oZnVuY3Rpb24oZSkge1xuICBjb25zdCBuID0gXyhcInVzZVdpbmRvd1Njcm9sbFwiKSwgbyA9IF8oXCJjdXN0b21TY3JvbGxQYXJlbnRcIiksIHIgPSBUdChcImZpeGVkSGVhZGVySGVpZ2h0XCIpLCBzID0gVHQoXCJmaXhlZEZvb3RlckhlaWdodFwiKSwgaSA9IF8oXCJmaXhlZEhlYWRlckNvbnRlbnRcIiksIGwgPSBfKFwiZml4ZWRGb290ZXJDb250ZW50XCIpLCBjID0gXyhcImNvbnRleHRcIiksIHUgPSBIdChcbiAgICBILnVzZU1lbW8oKCkgPT4gbmUociwgKGEpID0+IHd0KGEsIFwiaGVpZ2h0XCIpKSwgW3JdKSxcbiAgICAhMCxcbiAgICBfKFwic2tpcEFuaW1hdGlvbkZyYW1lSW5SZXNpemVPYnNlcnZlclwiKVxuICApLCBmID0gSHQoXG4gICAgSC51c2VNZW1vKCgpID0+IG5lKHMsIChhKSA9PiB3dChhLCBcImhlaWdodFwiKSksIFtzXSksXG4gICAgITAsXG4gICAgXyhcInNraXBBbmltYXRpb25GcmFtZUluUmVzaXplT2JzZXJ2ZXJcIilcbiAgKSwgUyA9IG8gfHwgbiA/IFJyIDogYnIsIHAgPSBvIHx8IG4gPyB3ciA6IENyLCBtID0gXyhcIlRhYmxlQ29tcG9uZW50XCIpLCB3ID0gXyhcIlRhYmxlSGVhZENvbXBvbmVudFwiKSwgSSA9IF8oXCJUYWJsZUZvb3RlckNvbXBvbmVudFwiKSwgQyA9IGkgPyAvKiBAX19QVVJFX18gKi8geihcbiAgICB3LFxuICAgIHtcbiAgICAgIHJlZjogdSxcbiAgICAgIHN0eWxlOiB7IHBvc2l0aW9uOiBcInN0aWNreVwiLCB0b3A6IDAsIHpJbmRleDogMiB9LFxuICAgICAgLi4uWih3LCBjKSxcbiAgICAgIGNoaWxkcmVuOiBpKClcbiAgICB9LFxuICAgIFwiVGFibGVIZWFkXCJcbiAgKSA6IG51bGwsIGcgPSBsID8gLyogQF9fUFVSRV9fICovIHooXG4gICAgSSxcbiAgICB7XG4gICAgICByZWY6IGYsXG4gICAgICBzdHlsZTogeyBib3R0b206IDAsIHBvc2l0aW9uOiBcInN0aWNreVwiLCB6SW5kZXg6IDEgfSxcbiAgICAgIC4uLlooSSwgYyksXG4gICAgICBjaGlsZHJlbjogbCgpXG4gICAgfSxcbiAgICBcIlRhYmxlRm9vdFwiXG4gICkgOiBudWxsO1xuICByZXR1cm4gLyogQF9fUFVSRV9fICovIHooUywgeyAuLi5lLCAuLi5aKFMsIGMpLCBjaGlsZHJlbjogLyogQF9fUFVSRV9fICovIHoocCwgeyBjaGlsZHJlbjogLyogQF9fUFVSRV9fICovIEt0KG0sIHsgc3R5bGU6IHsgYm9yZGVyU3BhY2luZzogMCwgb3ZlcmZsb3dBbmNob3I6IFwibm9uZVwiIH0sIC4uLloobSwgYyksIGNoaWxkcmVuOiBbXG4gICAgQyxcbiAgICAvKiBAX19QVVJFX18gKi8geihUciwge30sIFwiVGFibGVCb2R5XCIpLFxuICAgIGdcbiAgXSB9KSB9KSB9KTtcbn0pLCB7XG4gIENvbXBvbmVudDogdnIsXG4gIHVzZUVtaXR0ZXI6IFFlLFxuICB1c2VFbWl0dGVyVmFsdWU6IF8sXG4gIHVzZVB1Ymxpc2hlcjogVHRcbn0gPSAvKiBAX19QVVJFX18gKi8gcWUoXG4gIGdyLFxuICB7XG4gICAgZXZlbnRzOiB7XG4gICAgICBhdEJvdHRvbVN0YXRlQ2hhbmdlOiBcImF0Qm90dG9tU3RhdGVDaGFuZ2VcIixcbiAgICAgIGF0VG9wU3RhdGVDaGFuZ2U6IFwiYXRUb3BTdGF0ZUNoYW5nZVwiLFxuICAgICAgZW5kUmVhY2hlZDogXCJlbmRSZWFjaGVkXCIsXG4gICAgICBncm91cEluZGljZXM6IFwiZ3JvdXBJbmRpY2VzXCIsXG4gICAgICBpc1Njcm9sbGluZzogXCJpc1Njcm9sbGluZ1wiLFxuICAgICAgaXRlbXNSZW5kZXJlZDogXCJpdGVtc1JlbmRlcmVkXCIsXG4gICAgICByYW5nZUNoYW5nZWQ6IFwicmFuZ2VDaGFuZ2VkXCIsXG4gICAgICBzdGFydFJlYWNoZWQ6IFwic3RhcnRSZWFjaGVkXCIsXG4gICAgICB0b3RhbExpc3RIZWlnaHRDaGFuZ2VkOiBcInRvdGFsTGlzdEhlaWdodENoYW5nZWRcIlxuICAgIH0sXG4gICAgbWV0aG9kczoge1xuICAgICAgZ2V0U3RhdGU6IFwiZ2V0U3RhdGVcIixcbiAgICAgIHNjcm9sbEJ5OiBcInNjcm9sbEJ5XCIsXG4gICAgICBzY3JvbGxJbnRvVmlldzogXCJzY3JvbGxJbnRvVmlld1wiLFxuICAgICAgc2Nyb2xsVG86IFwic2Nyb2xsVG9cIixcbiAgICAgIHNjcm9sbFRvSW5kZXg6IFwic2Nyb2xsVG9JbmRleFwiXG4gICAgfSxcbiAgICBvcHRpb25hbDoge1xuICAgICAgYWxpZ25Ub0JvdHRvbTogXCJhbGlnblRvQm90dG9tXCIsXG4gICAgICBhdEJvdHRvbVRocmVzaG9sZDogXCJhdEJvdHRvbVRocmVzaG9sZFwiLFxuICAgICAgYXRUb3BUaHJlc2hvbGQ6IFwiYXRUb3BUaHJlc2hvbGRcIixcbiAgICAgIGNvbXBvbmVudHM6IFwiY29tcG9uZW50c1wiLFxuICAgICAgY29tcHV0ZUl0ZW1LZXk6IFwiY29tcHV0ZUl0ZW1LZXlcIixcbiAgICAgIGNvbnRleHQ6IFwiY29udGV4dFwiLFxuICAgICAgY3VzdG9tU2Nyb2xsUGFyZW50OiBcImN1c3RvbVNjcm9sbFBhcmVudFwiLFxuICAgICAgZGF0YTogXCJkYXRhXCIsXG4gICAgICBkZWZhdWx0SXRlbUhlaWdodDogXCJkZWZhdWx0SXRlbUhlaWdodFwiLFxuICAgICAgZmlyc3RJdGVtSW5kZXg6IFwiZmlyc3RJdGVtSW5kZXhcIixcbiAgICAgIGZpeGVkRm9vdGVyQ29udGVudDogXCJmaXhlZEZvb3RlckNvbnRlbnRcIixcbiAgICAgIGZpeGVkSGVhZGVyQ29udGVudDogXCJmaXhlZEhlYWRlckNvbnRlbnRcIixcbiAgICAgIGZpeGVkSXRlbUhlaWdodDogXCJmaXhlZEl0ZW1IZWlnaHRcIixcbiAgICAgIGZvbGxvd091dHB1dDogXCJmb2xsb3dPdXRwdXRcIixcbiAgICAgIGdyb3VwQ291bnRzOiBcImdyb3VwQ291bnRzXCIsXG4gICAgICBpbmNyZWFzZVZpZXdwb3J0Qnk6IFwiaW5jcmVhc2VWaWV3cG9ydEJ5XCIsXG4gICAgICBpbml0aWFsSXRlbUNvdW50OiBcImluaXRpYWxJdGVtQ291bnRcIixcbiAgICAgIGluaXRpYWxTY3JvbGxUb3A6IFwiaW5pdGlhbFNjcm9sbFRvcFwiLFxuICAgICAgaW5pdGlhbFRvcE1vc3RJdGVtSW5kZXg6IFwiaW5pdGlhbFRvcE1vc3RJdGVtSW5kZXhcIixcbiAgICAgIGl0ZW1Db250ZW50OiBcIml0ZW1Db250ZW50XCIsXG4gICAgICBpdGVtU2l6ZTogXCJpdGVtU2l6ZVwiLFxuICAgICAgbG9nTGV2ZWw6IFwibG9nTGV2ZWxcIixcbiAgICAgIG92ZXJzY2FuOiBcIm92ZXJzY2FuXCIsXG4gICAgICByZXN0b3JlU3RhdGVGcm9tOiBcInJlc3RvcmVTdGF0ZUZyb21cIixcbiAgICAgIHNjcm9sbGVyUmVmOiBcInNjcm9sbGVyUmVmXCIsXG4gICAgICBzY3JvbGxTZWVrQ29uZmlndXJhdGlvbjogXCJzY3JvbGxTZWVrQ29uZmlndXJhdGlvblwiLFxuICAgICAgdG9wSXRlbUNvdW50OiBcInRvcEl0ZW1Db3VudFwiLFxuICAgICAgdG90YWxDb3VudDogXCJ0b3RhbENvdW50XCIsXG4gICAgICB1c2VXaW5kb3dTY3JvbGw6IFwidXNlV2luZG93U2Nyb2xsXCJcbiAgICB9LFxuICAgIHJlcXVpcmVkOiB7fVxuICB9LFxuICB5clxuKSwgYnIgPSAvKiBAX19QVVJFX18gKi8gWmUoeyB1c2VFbWl0dGVyOiBRZSwgdXNlRW1pdHRlclZhbHVlOiBfLCB1c2VQdWJsaXNoZXI6IFR0IH0pLCBSciA9IC8qIEBfX1BVUkVfXyAqLyBYZSh7IHVzZUVtaXR0ZXI6IFFlLCB1c2VFbWl0dGVyVmFsdWU6IF8sIHVzZVB1Ymxpc2hlcjogVHQgfSksIHFyID0gdnIsIHduID0ge1xuICBib3R0b206IDAsXG4gIGl0ZW1IZWlnaHQ6IDAsXG4gIGl0ZW1zOiBbXSxcbiAgaXRlbVdpZHRoOiAwLFxuICBvZmZzZXRCb3R0b206IDAsXG4gIG9mZnNldFRvcDogMCxcbiAgdG9wOiAwXG59LCBIciA9IHtcbiAgYm90dG9tOiAwLFxuICBpdGVtSGVpZ2h0OiAwLFxuICBpdGVtczogW3sgaW5kZXg6IDAgfV0sXG4gIGl0ZW1XaWR0aDogMCxcbiAgb2Zmc2V0Qm90dG9tOiAwLFxuICBvZmZzZXRUb3A6IDAsXG4gIHRvcDogMFxufSwgeyBjZWlsOiB5biwgZmxvb3I6IENlLCBtYXg6IGVlLCBtaW46IEZlLCByb3VuZDogdm4gfSA9IE1hdGg7XG5mdW5jdGlvbiBibih0LCBlLCBuKSB7XG4gIHJldHVybiBBcnJheS5mcm9tKHsgbGVuZ3RoOiBlIC0gdCArIDEgfSkubWFwKChvLCByKSA9PiAoeyBkYXRhOiBuID09PSBudWxsID8gbnVsbCA6IG5bciArIHRdLCBpbmRleDogciArIHQgfSkpO1xufVxuZnVuY3Rpb24gRXIodCkge1xuICByZXR1cm4ge1xuICAgIC4uLkhyLFxuICAgIGl0ZW1zOiB0XG4gIH07XG59XG5mdW5jdGlvbiBoZSh0LCBlKSB7XG4gIHJldHVybiB0ICYmIHQud2lkdGggPT09IGUud2lkdGggJiYgdC5oZWlnaHQgPT09IGUuaGVpZ2h0O1xufVxuZnVuY3Rpb24ga3IodCwgZSkge1xuICByZXR1cm4gdCAmJiB0LmNvbHVtbiA9PT0gZS5jb2x1bW4gJiYgdC5yb3cgPT09IGUucm93O1xufVxuY29uc3QgQnIgPSAvKiBAX19QVVJFX18gKi8gVShcbiAgKFtcbiAgICB7IGluY3JlYXNlVmlld3BvcnRCeTogdCwgbGlzdEJvdW5kYXJ5OiBlLCBvdmVyc2NhbjogbiwgdmlzaWJsZVJhbmdlOiBvIH0sXG4gICAgeyBmb290ZXJIZWlnaHQ6IHIsIGhlYWRlckhlaWdodDogcywgc2Nyb2xsQnk6IGksIHNjcm9sbENvbnRhaW5lclN0YXRlOiBsLCBzY3JvbGxUbzogYywgc2Nyb2xsVG9wOiB1LCBzbW9vdGhTY3JvbGxUYXJnZXRSZWFjaGVkOiBmLCB2aWV3cG9ydEhlaWdodDogUyB9LFxuICAgIHAsXG4gICAgbSxcbiAgICB7IGRpZE1vdW50OiB3LCBwcm9wc1JlYWR5OiBJIH0sXG4gICAgeyBjdXN0b21TY3JvbGxQYXJlbnQ6IEMsIHVzZVdpbmRvd1Njcm9sbDogZywgd2luZG93U2Nyb2xsQ29udGFpbmVyU3RhdGU6IGEsIHdpbmRvd1Njcm9sbFRvOiBULCB3aW5kb3dWaWV3cG9ydFJlY3Q6IGIgfSxcbiAgICBoXG4gIF0pID0+IHtcbiAgICBjb25zdCBkID0geSgwKSwgUiA9IHkoMCksIEIgPSB5KHduKSwgTyA9IHkoeyBoZWlnaHQ6IDAsIHdpZHRoOiAwIH0pLCBMID0geSh7IGhlaWdodDogMCwgd2lkdGg6IDAgfSksIFYgPSAkKCksIEQgPSAkKCksIEogPSB5KDApLCBudCA9IHkobnVsbCksIGsgPSB5KHsgY29sdW1uOiAwLCByb3c6IDAgfSksIHEgPSAkKCksIHN0ID0gJCgpLCBkdCA9IHkoITEpLCBTdCA9IHkoMCksIGZ0ID0geSghMCksIHV0ID0geSghMSksIEF0ID0geSghMSk7XG4gICAgSyhcbiAgICAgIHgoXG4gICAgICAgIHcsXG4gICAgICAgIEcoU3QpLFxuICAgICAgICBQKChbdiwgTl0pID0+ICEhTilcbiAgICAgICksXG4gICAgICAoKSA9PiB7XG4gICAgICAgIFcoZnQsICExKTtcbiAgICAgIH1cbiAgICApLCBLKFxuICAgICAgeChcbiAgICAgICAgcnQodywgZnQsIEwsIE8sIFN0LCB1dCksXG4gICAgICAgIFAoKFt2LCBOLCBRLCBpdCwgLCB0dF0pID0+IHYgJiYgIU4gJiYgUS5oZWlnaHQgIT09IDAgJiYgaXQuaGVpZ2h0ICE9PSAwICYmICF0dClcbiAgICAgICksXG4gICAgICAoWywgLCAsICwgdl0pID0+IHtcbiAgICAgICAgVyh1dCwgITApLCAkZSgxLCAoKSA9PiB7XG4gICAgICAgICAgVyhWLCB2KTtcbiAgICAgICAgfSksIFJ0KHgodSksICgpID0+IHtcbiAgICAgICAgICBXKGUsIFswLCAwXSksIFcoZnQsICEwKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgKSwgRihcbiAgICAgIHgoXG4gICAgICAgIHN0LFxuICAgICAgICBQKCh2KSA9PiB2ICE9IG51bGwgJiYgdi5zY3JvbGxUb3AgPiAwKSxcbiAgICAgICAgdnQoMClcbiAgICAgICksXG4gICAgICBSXG4gICAgKSwgSyhcbiAgICAgIHgoXG4gICAgICAgIHcsXG4gICAgICAgIEcoc3QpLFxuICAgICAgICBQKChbLCB2XSkgPT4gdiAhPSBudWxsKVxuICAgICAgKSxcbiAgICAgIChbLCB2XSkgPT4ge1xuICAgICAgICB2ICYmIChXKE8sIHYudmlld3BvcnQpLCBXKEwsIHYuaXRlbSksIFcoaywgdi5nYXApLCB2LnNjcm9sbFRvcCA+IDAgJiYgKFcoZHQsICEwKSwgUnQoeCh1LCBqdCgxKSksIChOKSA9PiB7XG4gICAgICAgICAgVyhkdCwgITEpO1xuICAgICAgICB9KSwgVyhjLCB7IHRvcDogdi5zY3JvbGxUb3AgfSkpKTtcbiAgICAgIH1cbiAgICApLCBGKFxuICAgICAgeChcbiAgICAgICAgTyxcbiAgICAgICAgRSgoeyBoZWlnaHQ6IHYgfSkgPT4gdilcbiAgICAgICksXG4gICAgICBTXG4gICAgKSwgRihcbiAgICAgIHgoXG4gICAgICAgIHJ0KFxuICAgICAgICAgIEEoTywgaGUpLFxuICAgICAgICAgIEEoTCwgaGUpLFxuICAgICAgICAgIEEoaywgKHYsIE4pID0+IHYgJiYgdi5jb2x1bW4gPT09IE4uY29sdW1uICYmIHYucm93ID09PSBOLnJvdyksXG4gICAgICAgICAgQSh1KVxuICAgICAgICApLFxuICAgICAgICBFKChbdiwgTiwgUSwgaXRdKSA9PiAoe1xuICAgICAgICAgIGdhcDogUSxcbiAgICAgICAgICBpdGVtOiBOLFxuICAgICAgICAgIHNjcm9sbFRvcDogaXQsXG4gICAgICAgICAgdmlld3BvcnQ6IHZcbiAgICAgICAgfSkpXG4gICAgICApLFxuICAgICAgcVxuICAgICksIEYoXG4gICAgICB4KFxuICAgICAgICBydChcbiAgICAgICAgICBBKGQpLFxuICAgICAgICAgIG8sXG4gICAgICAgICAgQShrLCBrciksXG4gICAgICAgICAgQShMLCBoZSksXG4gICAgICAgICAgQShPLCBoZSksXG4gICAgICAgICAgQShudCksXG4gICAgICAgICAgQShSKSxcbiAgICAgICAgICBBKGR0KSxcbiAgICAgICAgICBBKGZ0KSxcbiAgICAgICAgICBBKFN0KVxuICAgICAgICApLFxuICAgICAgICBQKChbLCAsICwgLCAsICwgLCB2XSkgPT4gIXYpLFxuICAgICAgICBFKFxuICAgICAgICAgIChbXG4gICAgICAgICAgICB2LFxuICAgICAgICAgICAgW04sIFFdLFxuICAgICAgICAgICAgaXQsXG4gICAgICAgICAgICB0dCxcbiAgICAgICAgICAgIEJ0LFxuICAgICAgICAgICAgSnQsXG4gICAgICAgICAgICBOdCxcbiAgICAgICAgICAgICxcbiAgICAgICAgICAgIGRlLFxuICAgICAgICAgICAgT3RcbiAgICAgICAgICBdKSA9PiB7XG4gICAgICAgICAgICBjb25zdCB7IGNvbHVtbjogRnQsIHJvdzogUXQgfSA9IGl0LCB7IGhlaWdodDogZmUsIHdpZHRoOiBIZSB9ID0gdHQsIHsgd2lkdGg6IHRuIH0gPSBCdDtcbiAgICAgICAgICAgIGlmIChOdCA9PT0gMCAmJiAodiA9PT0gMCB8fCB0biA9PT0gMCkpXG4gICAgICAgICAgICAgIHJldHVybiB3bjtcbiAgICAgICAgICAgIGlmIChIZSA9PT0gMCkge1xuICAgICAgICAgICAgICBjb25zdCBzbiA9IFVlKE90LCB2KSwgc28gPSBzbiArIE1hdGgubWF4KE50IC0gMSwgMCk7XG4gICAgICAgICAgICAgIHJldHVybiBFcihibihzbiwgc28sIEp0KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBtZSA9IG5vKHRuLCBIZSwgRnQpO1xuICAgICAgICAgICAgbGV0IER0LCBXdDtcbiAgICAgICAgICAgIGRlID8gTiA9PT0gMCAmJiBRID09PSAwICYmIE50ID4gMCA/IChEdCA9IDAsIFd0ID0gTnQgLSAxKSA6IChEdCA9IG1lICogQ2UoKE4gKyBRdCkgLyAoZmUgKyBRdCkpLCBXdCA9IG1lICogeW4oKFEgKyBRdCkgLyAoZmUgKyBRdCkpIC0gMSwgV3QgPSBGZSh2IC0gMSwgZWUoV3QsIG1lIC0gMSkpLCBEdCA9IEZlKFd0LCBlZSgwLCBEdCkpKSA6IChEdCA9IDAsIFd0ID0gLTEpO1xuICAgICAgICAgICAgY29uc3QgZW4gPSBibihEdCwgV3QsIEp0KSwgeyBib3R0b206IG5uLCB0b3A6IG9uIH0gPSBSbihCdCwgaXQsIHR0LCBlbiksIHJuID0geW4odiAvIG1lKSwgcm8gPSBybiAqIGZlICsgKHJuIC0gMSkgKiBRdCAtIG5uO1xuICAgICAgICAgICAgcmV0dXJuIHsgYm90dG9tOiBubiwgaXRlbUhlaWdodDogZmUsIGl0ZW1zOiBlbiwgaXRlbVdpZHRoOiBIZSwgb2Zmc2V0Qm90dG9tOiBybywgb2Zmc2V0VG9wOiBvbiwgdG9wOiBvbiB9O1xuICAgICAgICAgIH1cbiAgICAgICAgKVxuICAgICAgKSxcbiAgICAgIEJcbiAgICApLCBGKFxuICAgICAgeChcbiAgICAgICAgbnQsXG4gICAgICAgIFAoKHYpID0+IHYgIT09IG51bGwpLFxuICAgICAgICBFKCh2KSA9PiB2Lmxlbmd0aClcbiAgICAgICksXG4gICAgICBkXG4gICAgKSwgRihcbiAgICAgIHgoXG4gICAgICAgIHJ0KE8sIEwsIEIsIGspLFxuICAgICAgICBQKChbdiwgTiwgeyBpdGVtczogUSB9XSkgPT4gUS5sZW5ndGggPiAwICYmIE4uaGVpZ2h0ICE9PSAwICYmIHYuaGVpZ2h0ICE9PSAwKSxcbiAgICAgICAgRSgoW3YsIE4sIHsgaXRlbXM6IFEgfSwgaXRdKSA9PiB7XG4gICAgICAgICAgY29uc3QgeyBib3R0b206IHR0LCB0b3A6IEJ0IH0gPSBSbih2LCBpdCwgTiwgUSk7XG4gICAgICAgICAgcmV0dXJuIFtCdCwgdHRdO1xuICAgICAgICB9KSxcbiAgICAgICAgWShzZSlcbiAgICAgICksXG4gICAgICBlXG4gICAgKTtcbiAgICBjb25zdCB4dCA9IHkoITEpO1xuICAgIEYoXG4gICAgICB4KFxuICAgICAgICB1LFxuICAgICAgICBHKHh0KSxcbiAgICAgICAgRSgoW3YsIE5dKSA9PiBOIHx8IHYgIT09IDApXG4gICAgICApLFxuICAgICAgeHRcbiAgICApO1xuICAgIGNvbnN0IFh0ID0gcHQoXG4gICAgICB4KFxuICAgICAgICBydChCLCBkKSxcbiAgICAgICAgUCgoW3sgaXRlbXM6IHYgfV0pID0+IHYubGVuZ3RoID4gMCksXG4gICAgICAgIEcoeHQpLFxuICAgICAgICBQKChbW3YsIE5dLCBRXSkgPT4ge1xuICAgICAgICAgIGNvbnN0IHR0ID0gdi5pdGVtc1t2Lml0ZW1zLmxlbmd0aCAtIDFdLmluZGV4ID09PSBOIC0gMTtcbiAgICAgICAgICByZXR1cm4gKFEgfHwgdi5ib3R0b20gPiAwICYmIHYuaXRlbUhlaWdodCA+IDAgJiYgdi5vZmZzZXRCb3R0b20gPT09IDAgJiYgdi5pdGVtcy5sZW5ndGggPT09IE4pICYmIHR0O1xuICAgICAgICB9KSxcbiAgICAgICAgRSgoW1ssIHZdXSkgPT4gdiAtIDEpLFxuICAgICAgICBZKClcbiAgICAgIClcbiAgICApLCBNdCA9IHB0KFxuICAgICAgeChcbiAgICAgICAgQShCKSxcbiAgICAgICAgUCgoeyBpdGVtczogdiB9KSA9PiB2Lmxlbmd0aCA+IDAgJiYgdlswXS5pbmRleCA9PT0gMCksXG4gICAgICAgIHZ0KDApLFxuICAgICAgICBZKClcbiAgICAgIClcbiAgICApLCB5dCA9IHB0KFxuICAgICAgeChcbiAgICAgICAgQShCKSxcbiAgICAgICAgRyhkdCksXG4gICAgICAgIFAoKFt7IGl0ZW1zOiB2IH0sIE5dKSA9PiB2Lmxlbmd0aCA+IDAgJiYgIU4pLFxuICAgICAgICBFKChbeyBpdGVtczogdiB9XSkgPT4gKHtcbiAgICAgICAgICBlbmRJbmRleDogdlt2Lmxlbmd0aCAtIDFdLmluZGV4LFxuICAgICAgICAgIHN0YXJ0SW5kZXg6IHZbMF0uaW5kZXhcbiAgICAgICAgfSkpLFxuICAgICAgICBZKEFuKSxcbiAgICAgICAgTHQoMClcbiAgICAgIClcbiAgICApO1xuICAgIEYoeXQsIG0uc2Nyb2xsU2Vla1JhbmdlQ2hhbmdlZCksIEYoXG4gICAgICB4KFxuICAgICAgICBWLFxuICAgICAgICBHKE8sIEwsIGQsIGspLFxuICAgICAgICBFKChbdiwgTiwgUSwgaXQsIHR0XSkgPT4ge1xuICAgICAgICAgIGNvbnN0IEJ0ID0gTm4odiksIHsgYWxpZ246IEp0LCBiZWhhdmlvcjogTnQsIG9mZnNldDogZGUgfSA9IEJ0O1xuICAgICAgICAgIGxldCBPdCA9IEJ0LmluZGV4O1xuICAgICAgICAgIE90ID09PSBcIkxBU1RcIiAmJiAoT3QgPSBpdCAtIDEpLCBPdCA9IGVlKDAsIE90LCBGZShpdCAtIDEsIE90KSk7XG4gICAgICAgICAgbGV0IEZ0ID0gQWUoTiwgdHQsIFEsIE90KTtcbiAgICAgICAgICByZXR1cm4gSnQgPT09IFwiZW5kXCIgPyBGdCA9IHZuKEZ0IC0gTi5oZWlnaHQgKyBRLmhlaWdodCkgOiBKdCA9PT0gXCJjZW50ZXJcIiAmJiAoRnQgPSB2bihGdCAtIE4uaGVpZ2h0IC8gMiArIFEuaGVpZ2h0IC8gMikpLCBkZSAmJiAoRnQgKz0gZGUpLCB7IGJlaGF2aW9yOiBOdCwgdG9wOiBGdCB9O1xuICAgICAgICB9KVxuICAgICAgKSxcbiAgICAgIGNcbiAgICApO1xuICAgIGNvbnN0IGt0ID0gY3QoXG4gICAgICB4KFxuICAgICAgICBCLFxuICAgICAgICBFKCh2KSA9PiB2Lm9mZnNldEJvdHRvbSArIHYuYm90dG9tKVxuICAgICAgKSxcbiAgICAgIDBcbiAgICApO1xuICAgIHJldHVybiBGKFxuICAgICAgeChcbiAgICAgICAgYixcbiAgICAgICAgRSgodikgPT4gKHsgaGVpZ2h0OiB2LnZpc2libGVIZWlnaHQsIHdpZHRoOiB2LnZpc2libGVXaWR0aCB9KSlcbiAgICAgICksXG4gICAgICBPXG4gICAgKSwge1xuICAgICAgY3VzdG9tU2Nyb2xsUGFyZW50OiBDLFxuICAgICAgLy8gaW5wdXRcbiAgICAgIGRhdGE6IG50LFxuICAgICAgZGV2aWF0aW9uOiBKLFxuICAgICAgZm9vdGVySGVpZ2h0OiByLFxuICAgICAgZ2FwOiBrLFxuICAgICAgaGVhZGVySGVpZ2h0OiBzLFxuICAgICAgaW5jcmVhc2VWaWV3cG9ydEJ5OiB0LFxuICAgICAgaW5pdGlhbEl0ZW1Db3VudDogUixcbiAgICAgIGl0ZW1EaW1lbnNpb25zOiBMLFxuICAgICAgb3ZlcnNjYW46IG4sXG4gICAgICByZXN0b3JlU3RhdGVGcm9tOiBzdCxcbiAgICAgIHNjcm9sbEJ5OiBpLFxuICAgICAgc2Nyb2xsQ29udGFpbmVyU3RhdGU6IGwsXG4gICAgICBzY3JvbGxIZWlnaHQ6IEQsXG4gICAgICBzY3JvbGxUbzogYyxcbiAgICAgIHNjcm9sbFRvSW5kZXg6IFYsXG4gICAgICBzY3JvbGxUb3A6IHUsXG4gICAgICBzbW9vdGhTY3JvbGxUYXJnZXRSZWFjaGVkOiBmLFxuICAgICAgdG90YWxDb3VudDogZCxcbiAgICAgIHVzZVdpbmRvd1Njcm9sbDogZyxcbiAgICAgIHZpZXdwb3J0RGltZW5zaW9uczogTyxcbiAgICAgIHdpbmRvd1Njcm9sbENvbnRhaW5lclN0YXRlOiBhLFxuICAgICAgd2luZG93U2Nyb2xsVG86IFQsXG4gICAgICB3aW5kb3dWaWV3cG9ydFJlY3Q6IGIsXG4gICAgICAuLi5tLFxuICAgICAgLy8gb3V0cHV0XG4gICAgICBncmlkU3RhdGU6IEIsXG4gICAgICBob3Jpem9udGFsRGlyZWN0aW9uOiBBdCxcbiAgICAgIGluaXRpYWxUb3BNb3N0SXRlbUluZGV4OiBTdCxcbiAgICAgIHRvdGFsTGlzdEhlaWdodDoga3QsXG4gICAgICAuLi5wLFxuICAgICAgZW5kUmVhY2hlZDogWHQsXG4gICAgICBwcm9wc1JlYWR5OiBJLFxuICAgICAgcmFuZ2VDaGFuZ2VkOiB5dCxcbiAgICAgIHN0YXJ0UmVhY2hlZDogTXQsXG4gICAgICBzdGF0ZUNoYW5nZWQ6IHEsXG4gICAgICBzdGF0ZVJlc3RvcmVJblByb2dyZXNzOiBkdCxcbiAgICAgIC4uLmhcbiAgICB9O1xuICB9LFxuICBYKEtlLCBhdCwgYWUsIEtuLCBQdCwgamUsIFZ0KVxuKTtcbmZ1bmN0aW9uIG5vKHQsIGUsIG4pIHtcbiAgcmV0dXJuIGVlKDEsIENlKCh0ICsgbikgLyAoQ2UoZSkgKyBuKSkpO1xufVxuZnVuY3Rpb24gUm4odCwgZSwgbiwgbykge1xuICBjb25zdCB7IGhlaWdodDogciB9ID0gbjtcbiAgaWYgKHIgPT09IHZvaWQgMCB8fCBvLmxlbmd0aCA9PT0gMClcbiAgICByZXR1cm4geyBib3R0b206IDAsIHRvcDogMCB9O1xuICBjb25zdCBzID0gQWUodCwgZSwgbiwgb1swXS5pbmRleCk7XG4gIHJldHVybiB7IGJvdHRvbTogQWUodCwgZSwgbiwgb1tvLmxlbmd0aCAtIDFdLmluZGV4KSArIHIsIHRvcDogcyB9O1xufVxuZnVuY3Rpb24gQWUodCwgZSwgbiwgbykge1xuICBjb25zdCByID0gbm8odC53aWR0aCwgbi53aWR0aCwgZS5jb2x1bW4pLCBzID0gQ2UobyAvIHIpLCBpID0gcyAqIG4uaGVpZ2h0ICsgZWUoMCwgcyAtIDEpICogZS5yb3c7XG4gIHJldHVybiBpID4gMCA/IGkgKyBlLnJvdyA6IGk7XG59XG5jb25zdCBPciA9IC8qIEBfX1BVUkVfXyAqLyBVKCgpID0+IHtcbiAgY29uc3QgdCA9IHkoKFMpID0+IGBJdGVtICR7U31gKSwgZSA9IHkoe30pLCBuID0geShudWxsKSwgbyA9IHkoXCJ2aXJ0dW9zby1ncmlkLWl0ZW1cIiksIHIgPSB5KFwidmlydHVvc28tZ3JpZC1saXN0XCIpLCBzID0geShZZSksIGkgPSB5KFwiZGl2XCIpLCBsID0geShZdCksIGMgPSAoUywgcCA9IG51bGwpID0+IGN0KFxuICAgIHgoXG4gICAgICBlLFxuICAgICAgRSgobSkgPT4gbVtTXSksXG4gICAgICBZKClcbiAgICApLFxuICAgIHBcbiAgKSwgdSA9IHkoITEpLCBmID0geSghMSk7XG4gIHJldHVybiBGKEEoZiksIHUpLCB7XG4gICAgY29tcG9uZW50czogZSxcbiAgICBjb21wdXRlSXRlbUtleTogcyxcbiAgICBjb250ZXh0OiBuLFxuICAgIEZvb3RlckNvbXBvbmVudDogYyhcIkZvb3RlclwiKSxcbiAgICBIZWFkZXJDb21wb25lbnQ6IGMoXCJIZWFkZXJcIiksXG4gICAgaGVhZGVyRm9vdGVyVGFnOiBpLFxuICAgIGl0ZW1DbGFzc05hbWU6IG8sXG4gICAgSXRlbUNvbXBvbmVudDogYyhcIkl0ZW1cIiwgXCJkaXZcIiksXG4gICAgaXRlbUNvbnRlbnQ6IHQsXG4gICAgbGlzdENsYXNzTmFtZTogcixcbiAgICBMaXN0Q29tcG9uZW50OiBjKFwiTGlzdFwiLCBcImRpdlwiKSxcbiAgICByZWFkeVN0YXRlQ2hhbmdlZDogdSxcbiAgICByZXBvcnRSZWFkeVN0YXRlOiBmLFxuICAgIFNjcm9sbGVyQ29tcG9uZW50OiBjKFwiU2Nyb2xsZXJcIiwgXCJkaXZcIiksXG4gICAgc2Nyb2xsZXJSZWY6IGwsXG4gICAgU2Nyb2xsU2Vla1BsYWNlaG9sZGVyOiBjKFwiU2Nyb2xsU2Vla1BsYWNlaG9sZGVyXCIsIFwiZGl2XCIpXG4gIH07XG59KSwgRnIgPSAvKiBAX19QVVJFX18gKi8gVShcbiAgKFt0LCBlXSkgPT4gKHsgLi4udCwgLi4uZSB9KSxcbiAgWChCciwgT3IpXG4pLCBMciA9IC8qIEBfX1BVUkVfXyAqLyBILm1lbW8oZnVuY3Rpb24oKSB7XG4gIGNvbnN0IGUgPSBldChcImdyaWRTdGF0ZVwiKSwgbiA9IGV0KFwibGlzdENsYXNzTmFtZVwiKSwgbyA9IGV0KFwiaXRlbUNsYXNzTmFtZVwiKSwgciA9IGV0KFwiaXRlbUNvbnRlbnRcIiksIHMgPSBldChcImNvbXB1dGVJdGVtS2V5XCIpLCBpID0gZXQoXCJpc1NlZWtpbmdcIiksIGwgPSBJdChcInNjcm9sbEhlaWdodFwiKSwgYyA9IGV0KFwiSXRlbUNvbXBvbmVudFwiKSwgdSA9IGV0KFwiTGlzdENvbXBvbmVudFwiKSwgZiA9IGV0KFwiU2Nyb2xsU2Vla1BsYWNlaG9sZGVyXCIpLCBTID0gZXQoXCJjb250ZXh0XCIpLCBwID0gSXQoXCJpdGVtRGltZW5zaW9uc1wiKSwgbSA9IEl0KFwiZ2FwXCIpLCB3ID0gZXQoXCJsb2dcIiksIEkgPSBldChcInN0YXRlUmVzdG9yZUluUHJvZ3Jlc3NcIiksIEMgPSBJdChcInJlcG9ydFJlYWR5U3RhdGVcIiksIGcgPSBIdChcbiAgICBILnVzZU1lbW8oXG4gICAgICAoKSA9PiAoYSkgPT4ge1xuICAgICAgICBjb25zdCBUID0gYS5wYXJlbnRFbGVtZW50LnBhcmVudEVsZW1lbnQuc2Nyb2xsSGVpZ2h0O1xuICAgICAgICBsKFQpO1xuICAgICAgICBjb25zdCBiID0gYS5maXJzdENoaWxkO1xuICAgICAgICBpZiAoYikge1xuICAgICAgICAgIGNvbnN0IHsgaGVpZ2h0OiBoLCB3aWR0aDogZCB9ID0gYi5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgICBwKHsgaGVpZ2h0OiBoLCB3aWR0aDogZCB9KTtcbiAgICAgICAgfVxuICAgICAgICBtKHtcbiAgICAgICAgICBjb2x1bW46IEhuKFwiY29sdW1uLWdhcFwiLCBnZXRDb21wdXRlZFN0eWxlKGEpLmNvbHVtbkdhcCwgdyksXG4gICAgICAgICAgcm93OiBIbihcInJvdy1nYXBcIiwgZ2V0Q29tcHV0ZWRTdHlsZShhKS5yb3dHYXAsIHcpXG4gICAgICAgIH0pO1xuICAgICAgfSxcbiAgICAgIFtsLCBwLCBtLCB3XVxuICAgICksXG4gICAgITAsXG4gICAgITFcbiAgKTtcbiAgcmV0dXJuIFpuKCgpID0+IHtcbiAgICBlLml0ZW1IZWlnaHQgPiAwICYmIGUuaXRlbVdpZHRoID4gMCAmJiBDKCEwKTtcbiAgfSwgW2VdKSwgSSA/IG51bGwgOiAvKiBAX19QVVJFX18gKi8geihcbiAgICB1LFxuICAgIHtcbiAgICAgIGNsYXNzTmFtZTogbixcbiAgICAgIHJlZjogZyxcbiAgICAgIC4uLloodSwgUyksXG4gICAgICBcImRhdGEtdGVzdGlkXCI6IFwidmlydHVvc28taXRlbS1saXN0XCIsXG4gICAgICBzdHlsZTogeyBwYWRkaW5nQm90dG9tOiBlLm9mZnNldEJvdHRvbSwgcGFkZGluZ1RvcDogZS5vZmZzZXRUb3AgfSxcbiAgICAgIGNoaWxkcmVuOiBlLml0ZW1zLm1hcCgoYSkgPT4ge1xuICAgICAgICBjb25zdCBUID0gcyhhLmluZGV4LCBhLmRhdGEsIFMpO1xuICAgICAgICByZXR1cm4gaSA/IC8qIEBfX1BVUkVfXyAqLyB6KFxuICAgICAgICAgIGYsXG4gICAgICAgICAge1xuICAgICAgICAgICAgLi4uWihmLCBTKSxcbiAgICAgICAgICAgIGhlaWdodDogZS5pdGVtSGVpZ2h0LFxuICAgICAgICAgICAgaW5kZXg6IGEuaW5kZXgsXG4gICAgICAgICAgICB3aWR0aDogZS5pdGVtV2lkdGhcbiAgICAgICAgICB9LFxuICAgICAgICAgIFRcbiAgICAgICAgKSA6IC8qIEBfX1BVUkVfXyAqLyAkdChcbiAgICAgICAgICBjLFxuICAgICAgICAgIHtcbiAgICAgICAgICAgIC4uLlooYywgUyksXG4gICAgICAgICAgICBjbGFzc05hbWU6IG8sXG4gICAgICAgICAgICBcImRhdGEtaW5kZXhcIjogYS5pbmRleCxcbiAgICAgICAgICAgIGtleTogVFxuICAgICAgICAgIH0sXG4gICAgICAgICAgcihhLmluZGV4LCBhLmRhdGEsIFMpXG4gICAgICAgICk7XG4gICAgICB9KVxuICAgIH1cbiAgKTtcbn0pLCB6ciA9IEgubWVtbyhmdW5jdGlvbigpIHtcbiAgY29uc3QgZSA9IGV0KFwiSGVhZGVyQ29tcG9uZW50XCIpLCBuID0gSXQoXCJoZWFkZXJIZWlnaHRcIiksIG8gPSBldChcImhlYWRlckZvb3RlclRhZ1wiKSwgciA9IEh0KFxuICAgIEgudXNlTWVtbyhcbiAgICAgICgpID0+IChpKSA9PiB7XG4gICAgICAgIG4od3QoaSwgXCJoZWlnaHRcIikpO1xuICAgICAgfSxcbiAgICAgIFtuXVxuICAgICksXG4gICAgITAsXG4gICAgITFcbiAgKSwgcyA9IGV0KFwiY29udGV4dFwiKTtcbiAgcmV0dXJuIGUgPyAvKiBAX19QVVJFX18gKi8geihvLCB7IHJlZjogciwgY2hpbGRyZW46IC8qIEBfX1BVUkVfXyAqLyB6KGUsIHsgLi4uWihlLCBzKSB9KSB9KSA6IG51bGw7XG59KSwgVnIgPSBILm1lbW8oZnVuY3Rpb24oKSB7XG4gIGNvbnN0IGUgPSBldChcIkZvb3RlckNvbXBvbmVudFwiKSwgbiA9IEl0KFwiZm9vdGVySGVpZ2h0XCIpLCBvID0gZXQoXCJoZWFkZXJGb290ZXJUYWdcIiksIHIgPSBIdChcbiAgICBILnVzZU1lbW8oXG4gICAgICAoKSA9PiAoaSkgPT4ge1xuICAgICAgICBuKHd0KGksIFwiaGVpZ2h0XCIpKTtcbiAgICAgIH0sXG4gICAgICBbbl1cbiAgICApLFxuICAgICEwLFxuICAgICExXG4gICksIHMgPSBldChcImNvbnRleHRcIik7XG4gIHJldHVybiBlID8gLyogQF9fUFVSRV9fICovIHoobywgeyByZWY6IHIsIGNoaWxkcmVuOiAvKiBAX19QVVJFX18gKi8geihlLCB7IC4uLlooZSwgcykgfSkgfSkgOiBudWxsO1xufSksIFByID0gKHsgY2hpbGRyZW46IHQgfSkgPT4ge1xuICBjb25zdCBlID0gSC51c2VDb250ZXh0KFluKSwgbiA9IEl0KFwiaXRlbURpbWVuc2lvbnNcIiksIG8gPSBJdChcInZpZXdwb3J0RGltZW5zaW9uc1wiKSwgciA9IEh0KFxuICAgIEgudXNlTWVtbyhcbiAgICAgICgpID0+IChzKSA9PiB7XG4gICAgICAgIG8ocy5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSk7XG4gICAgICB9LFxuICAgICAgW29dXG4gICAgKSxcbiAgICAhMCxcbiAgICAhMVxuICApO1xuICByZXR1cm4gSC51c2VFZmZlY3QoKCkgPT4ge1xuICAgIGUgJiYgKG8oeyBoZWlnaHQ6IGUudmlld3BvcnRIZWlnaHQsIHdpZHRoOiBlLnZpZXdwb3J0V2lkdGggfSksIG4oeyBoZWlnaHQ6IGUuaXRlbUhlaWdodCwgd2lkdGg6IGUuaXRlbVdpZHRoIH0pKTtcbiAgfSwgW2UsIG8sIG5dKSwgLyogQF9fUFVSRV9fICovIHooXCJkaXZcIiwgeyByZWY6IHIsIHN0eWxlOiBadCghMSksIGNoaWxkcmVuOiB0IH0pO1xufSwgQXIgPSAoeyBjaGlsZHJlbjogdCB9KSA9PiB7XG4gIGNvbnN0IGUgPSBILnVzZUNvbnRleHQoWW4pLCBuID0gSXQoXCJ3aW5kb3dWaWV3cG9ydFJlY3RcIiksIG8gPSBJdChcIml0ZW1EaW1lbnNpb25zXCIpLCByID0gZXQoXCJjdXN0b21TY3JvbGxQYXJlbnRcIiksIHMgPSBHZShuLCByLCAhMSk7XG4gIHJldHVybiBILnVzZUVmZmVjdCgoKSA9PiB7XG4gICAgZSAmJiAobyh7IGhlaWdodDogZS5pdGVtSGVpZ2h0LCB3aWR0aDogZS5pdGVtV2lkdGggfSksIG4oeyBvZmZzZXRUb3A6IDAsIHZpc2libGVIZWlnaHQ6IGUudmlld3BvcnRIZWlnaHQsIHZpc2libGVXaWR0aDogZS52aWV3cG9ydFdpZHRoIH0pKTtcbiAgfSwgW2UsIG4sIG9dKSwgLyogQF9fUFVSRV9fICovIHooXCJkaXZcIiwgeyByZWY6IHMsIHN0eWxlOiBadCghMSksIGNoaWxkcmVuOiB0IH0pO1xufSwgTXIgPSAvKiBAX19QVVJFX18gKi8gSC5tZW1vKGZ1bmN0aW9uKHsgLi4uZSB9KSB7XG4gIGNvbnN0IG4gPSBldChcInVzZVdpbmRvd1Njcm9sbFwiKSwgbyA9IGV0KFwiY3VzdG9tU2Nyb2xsUGFyZW50XCIpLCByID0gbyB8fCBuID8gR3IgOiBfciwgcyA9IG8gfHwgbiA/IEFyIDogUHIsIGkgPSBldChcImNvbnRleHRcIik7XG4gIHJldHVybiAvKiBAX19QVVJFX18gKi8geihyLCB7IC4uLmUsIC4uLloociwgaSksIGNoaWxkcmVuOiAvKiBAX19QVVJFX18gKi8gS3QocywgeyBjaGlsZHJlbjogW1xuICAgIC8qIEBfX1BVUkVfXyAqLyB6KHpyLCB7fSksXG4gICAgLyogQF9fUFVSRV9fICovIHooTHIsIHt9KSxcbiAgICAvKiBAX19QVVJFX18gKi8geihWciwge30pXG4gIF0gfSkgfSk7XG59KSwge1xuICBDb21wb25lbnQ6IFdyLFxuICB1c2VFbWl0dGVyOiBvbyxcbiAgdXNlRW1pdHRlclZhbHVlOiBldCxcbiAgdXNlUHVibGlzaGVyOiBJdFxufSA9IC8qIEBfX1BVUkVfXyAqLyBxZShcbiAgRnIsXG4gIHtcbiAgICBldmVudHM6IHtcbiAgICAgIGF0Qm90dG9tU3RhdGVDaGFuZ2U6IFwiYXRCb3R0b21TdGF0ZUNoYW5nZVwiLFxuICAgICAgYXRUb3BTdGF0ZUNoYW5nZTogXCJhdFRvcFN0YXRlQ2hhbmdlXCIsXG4gICAgICBlbmRSZWFjaGVkOiBcImVuZFJlYWNoZWRcIixcbiAgICAgIGlzU2Nyb2xsaW5nOiBcImlzU2Nyb2xsaW5nXCIsXG4gICAgICByYW5nZUNoYW5nZWQ6IFwicmFuZ2VDaGFuZ2VkXCIsXG4gICAgICByZWFkeVN0YXRlQ2hhbmdlZDogXCJyZWFkeVN0YXRlQ2hhbmdlZFwiLFxuICAgICAgc3RhcnRSZWFjaGVkOiBcInN0YXJ0UmVhY2hlZFwiLFxuICAgICAgc3RhdGVDaGFuZ2VkOiBcInN0YXRlQ2hhbmdlZFwiXG4gICAgfSxcbiAgICBtZXRob2RzOiB7XG4gICAgICBzY3JvbGxCeTogXCJzY3JvbGxCeVwiLFxuICAgICAgc2Nyb2xsVG86IFwic2Nyb2xsVG9cIixcbiAgICAgIHNjcm9sbFRvSW5kZXg6IFwic2Nyb2xsVG9JbmRleFwiXG4gICAgfSxcbiAgICBvcHRpb25hbDoge1xuICAgICAgY29tcG9uZW50czogXCJjb21wb25lbnRzXCIsXG4gICAgICBjb21wdXRlSXRlbUtleTogXCJjb21wdXRlSXRlbUtleVwiLFxuICAgICAgY29udGV4dDogXCJjb250ZXh0XCIsXG4gICAgICBjdXN0b21TY3JvbGxQYXJlbnQ6IFwiY3VzdG9tU2Nyb2xsUGFyZW50XCIsXG4gICAgICBkYXRhOiBcImRhdGFcIixcbiAgICAgIGhlYWRlckZvb3RlclRhZzogXCJoZWFkZXJGb290ZXJUYWdcIixcbiAgICAgIGluY3JlYXNlVmlld3BvcnRCeTogXCJpbmNyZWFzZVZpZXdwb3J0QnlcIixcbiAgICAgIGluaXRpYWxJdGVtQ291bnQ6IFwiaW5pdGlhbEl0ZW1Db3VudFwiLFxuICAgICAgaW5pdGlhbFRvcE1vc3RJdGVtSW5kZXg6IFwiaW5pdGlhbFRvcE1vc3RJdGVtSW5kZXhcIixcbiAgICAgIGl0ZW1DbGFzc05hbWU6IFwiaXRlbUNsYXNzTmFtZVwiLFxuICAgICAgaXRlbUNvbnRlbnQ6IFwiaXRlbUNvbnRlbnRcIixcbiAgICAgIGxpc3RDbGFzc05hbWU6IFwibGlzdENsYXNzTmFtZVwiLFxuICAgICAgbG9nTGV2ZWw6IFwibG9nTGV2ZWxcIixcbiAgICAgIG92ZXJzY2FuOiBcIm92ZXJzY2FuXCIsXG4gICAgICByZXN0b3JlU3RhdGVGcm9tOiBcInJlc3RvcmVTdGF0ZUZyb21cIixcbiAgICAgIHNjcm9sbGVyUmVmOiBcInNjcm9sbGVyUmVmXCIsXG4gICAgICBzY3JvbGxTZWVrQ29uZmlndXJhdGlvbjogXCJzY3JvbGxTZWVrQ29uZmlndXJhdGlvblwiLFxuICAgICAgdG90YWxDb3VudDogXCJ0b3RhbENvdW50XCIsXG4gICAgICB1c2VXaW5kb3dTY3JvbGw6IFwidXNlV2luZG93U2Nyb2xsXCJcbiAgICB9XG4gIH0sXG4gIE1yXG4pLCBfciA9IC8qIEBfX1BVUkVfXyAqLyBaZSh7IHVzZUVtaXR0ZXI6IG9vLCB1c2VFbWl0dGVyVmFsdWU6IGV0LCB1c2VQdWJsaXNoZXI6IEl0IH0pLCBHciA9IC8qIEBfX1BVUkVfXyAqLyBYZSh7IHVzZUVtaXR0ZXI6IG9vLCB1c2VFbWl0dGVyVmFsdWU6IGV0LCB1c2VQdWJsaXNoZXI6IEl0IH0pO1xuZnVuY3Rpb24gSG4odCwgZSwgbikge1xuICByZXR1cm4gZSAhPT0gXCJub3JtYWxcIiAmJiAhKGUgIT0gbnVsbCAmJiBlLmVuZHNXaXRoKFwicHhcIikpICYmIG4oYCR7dH0gd2FzIG5vdCByZXNvbHZlZCB0byBwaXhlbCB2YWx1ZSBjb3JyZWN0bHlgLCBlLCBodC5XQVJOKSwgZSA9PT0gXCJub3JtYWxcIiA/IDAgOiBwYXJzZUludChlICE9IG51bGwgPyBlIDogXCIwXCIsIDEwKTtcbn1cbmNvbnN0IFlyID0gV3I7XG5leHBvcnQge1xuICBqciBhcyBHcm91cGVkVmlydHVvc28sXG4gIGh0IGFzIExvZ0xldmVsLFxuICBxciBhcyBUYWJsZVZpcnR1b3NvLFxuICBLciBhcyBWaXJ0dW9zbyxcbiAgWXIgYXMgVmlydHVvc29HcmlkLFxuICBZbiBhcyBWaXJ0dW9zb0dyaWRNb2NrQ29udGV4dCxcbiAgUmUgYXMgVmlydHVvc29Nb2NrQ29udGV4dFxufTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/react-virtuoso/dist/index.mjs\n"));

/***/ })

}]);