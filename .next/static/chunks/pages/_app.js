/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunk_N_E"] = self["webpackChunk_N_E"] || []).push([["pages/_app"],{

/***/ "./node_modules/next/dist/build/webpack/loaders/css-loader/src/index.js??ruleSet[1].rules[7].oneOf[12].use[1]!./node_modules/next/dist/build/webpack/loaders/postcss-loader/src/index.js??ruleSet[1].rules[7].oneOf[12].use[2]!./node_modules/react-toastify/dist/ReactToastify.css":
/*!******************************************************************************************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/next/dist/build/webpack/loaders/css-loader/src/index.js??ruleSet[1].rules[7].oneOf[12].use[1]!./node_modules/next/dist/build/webpack/loaders/postcss-loader/src/index.js??ruleSet[1].rules[7].oneOf[12].use[2]!./node_modules/react-toastify/dist/ReactToastify.css ***!
  \******************************************************************************************************************************************************************************************************************************************************************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _next_dist_build_webpack_loaders_css_loader_src_runtime_api_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../next/dist/build/webpack/loaders/css-loader/src/runtime/api.js */ \"./node_modules/next/dist/build/webpack/loaders/css-loader/src/runtime/api.js\");\n/* harmony import */ var _next_dist_build_webpack_loaders_css_loader_src_runtime_api_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_next_dist_build_webpack_loaders_css_loader_src_runtime_api_js__WEBPACK_IMPORTED_MODULE_0__);\n// Imports\n\nvar ___CSS_LOADER_EXPORT___ = _next_dist_build_webpack_loaders_css_loader_src_runtime_api_js__WEBPACK_IMPORTED_MODULE_0___default()(true);\n// Module\n___CSS_LOADER_EXPORT___.push([module.id, \":root {\\n  --toastify-color-light: #fff;\\n  --toastify-color-dark: #121212;\\n  --toastify-color-info: #3498db;\\n  --toastify-color-success: #07bc0c;\\n  --toastify-color-warning: #f1c40f;\\n  --toastify-color-error: hsl(6, 78%, 57%);\\n  --toastify-color-transparent: rgba(255, 255, 255, 0.7);\\n\\n  --toastify-icon-color-info: var(--toastify-color-info);\\n  --toastify-icon-color-success: var(--toastify-color-success);\\n  --toastify-icon-color-warning: var(--toastify-color-warning);\\n  --toastify-icon-color-error: var(--toastify-color-error);\\n\\n  --toastify-container-width: fit-content;\\n  --toastify-toast-width: 320px;\\n  --toastify-toast-offset: 16px;\\n  --toastify-toast-top: max(var(--toastify-toast-offset), env(safe-area-inset-top));\\n  --toastify-toast-right: max(var(--toastify-toast-offset), env(safe-area-inset-right));\\n  --toastify-toast-left: max(var(--toastify-toast-offset), env(safe-area-inset-left));\\n  --toastify-toast-bottom: max(var(--toastify-toast-offset), env(safe-area-inset-bottom));\\n  --toastify-toast-background: #fff;\\n  --toastify-toast-padding: 14px;\\n  --toastify-toast-min-height: 64px;\\n  --toastify-toast-max-height: 800px;\\n  --toastify-toast-bd-radius: 6px;\\n  --toastify-toast-shadow: 0px 4px 12px rgba(0, 0, 0, 0.1);\\n  --toastify-font-family: sans-serif;\\n  --toastify-z-index: 9999;\\n  --toastify-text-color-light: #757575;\\n  --toastify-text-color-dark: #fff;\\n\\n  /* Used only for colored theme */\\n  --toastify-text-color-info: #fff;\\n  --toastify-text-color-success: #fff;\\n  --toastify-text-color-warning: #fff;\\n  --toastify-text-color-error: #fff;\\n\\n  --toastify-spinner-color: #616161;\\n  --toastify-spinner-color-empty-area: #e0e0e0;\\n  --toastify-color-progress-light: linear-gradient(to right, #4cd964, #5ac8fa, #007aff, #34aadc, #5856d6, #ff2d55);\\n  --toastify-color-progress-dark: #bb86fc;\\n  --toastify-color-progress-info: var(--toastify-color-info);\\n  --toastify-color-progress-success: var(--toastify-color-success);\\n  --toastify-color-progress-warning: var(--toastify-color-warning);\\n  --toastify-color-progress-error: var(--toastify-color-error);\\n  /* used to control the opacity of the progress trail */\\n  --toastify-color-progress-bgo: 0.2;\\n}\\n\\n.Toastify__toast-container {\\n  z-index: var(--toastify-z-index);\\n  -webkit-transform: translate3d(0, 0, var(--toastify-z-index));\\n  position: fixed;\\n  width: var(--toastify-container-width);\\n  box-sizing: border-box;\\n  color: #fff;\\n  display: flex;\\n  flex-direction: column;\\n}\\n\\n.Toastify__toast-container--top-left {\\n  top: var(--toastify-toast-top);\\n  left: var(--toastify-toast-left);\\n}\\n.Toastify__toast-container--top-center {\\n  top: var(--toastify-toast-top);\\n  left: 50%;\\n  transform: translateX(-50%);\\n  align-items: center;\\n}\\n.Toastify__toast-container--top-right {\\n  top: var(--toastify-toast-top);\\n  right: var(--toastify-toast-right);\\n  align-items: end;\\n}\\n.Toastify__toast-container--bottom-left {\\n  bottom: var(--toastify-toast-bottom);\\n  left: var(--toastify-toast-left);\\n}\\n.Toastify__toast-container--bottom-center {\\n  bottom: var(--toastify-toast-bottom);\\n  left: 50%;\\n  transform: translateX(-50%);\\n  align-items: center;\\n}\\n.Toastify__toast-container--bottom-right {\\n  bottom: var(--toastify-toast-bottom);\\n  right: var(--toastify-toast-right);\\n  align-items: end;\\n}\\n\\n.Toastify__toast {\\n  --y: 0;\\n  position: relative;\\n  touch-action: none;\\n  width: var(--toastify-toast-width);\\n  min-height: var(--toastify-toast-min-height);\\n  box-sizing: border-box;\\n  margin-bottom: 1rem;\\n  padding: var(--toastify-toast-padding);\\n  border-radius: var(--toastify-toast-bd-radius);\\n  box-shadow: var(--toastify-toast-shadow);\\n  max-height: var(--toastify-toast-max-height);\\n  font-family: var(--toastify-font-family);\\n  /* webkit only issue #791 */\\n  z-index: 0;\\n  /* inner swag */\\n  display: flex;\\n  flex: 1 auto;\\n  align-items: center;\\n  word-break: break-word;\\n}\\n\\n@media only screen and (max-width: 480px) {\\n  .Toastify__toast-container {\\n    width: 100vw;\\n    left: env(safe-area-inset-left);\\n    margin: 0;\\n  }\\n  .Toastify__toast-container--top-left,\\n  .Toastify__toast-container--top-center,\\n  .Toastify__toast-container--top-right {\\n    top: env(safe-area-inset-top);\\n    transform: translateX(0);\\n  }\\n  .Toastify__toast-container--bottom-left,\\n  .Toastify__toast-container--bottom-center,\\n  .Toastify__toast-container--bottom-right {\\n    bottom: env(safe-area-inset-bottom);\\n    transform: translateX(0);\\n  }\\n  .Toastify__toast-container--rtl {\\n    right: env(safe-area-inset-right);\\n    left: initial;\\n  }\\n  .Toastify__toast {\\n    --toastify-toast-width: 100%;\\n    margin-bottom: 0;\\n    border-radius: 0;\\n  }\\n}\\n\\n.Toastify__toast-container[data-stacked='true'] {\\n  width: var(--toastify-toast-width);\\n}\\n\\n.Toastify__toast--stacked {\\n  position: absolute;\\n  width: 100%;\\n  transform: translate3d(0, var(--y), 0) scale(var(--s));\\n  transition: transform 0.3s;\\n}\\n\\n.Toastify__toast--stacked[data-collapsed] .Toastify__toast-body,\\n.Toastify__toast--stacked[data-collapsed] .Toastify__close-button {\\n  transition: opacity 0.1s;\\n}\\n\\n.Toastify__toast--stacked[data-collapsed='false'] {\\n  overflow: visible;\\n}\\n\\n.Toastify__toast--stacked[data-collapsed='true']:not(:last-child) > * {\\n  opacity: 0;\\n}\\n\\n.Toastify__toast--stacked:after {\\n  content: '';\\n  position: absolute;\\n  left: 0;\\n  right: 0;\\n  height: calc(var(--g) * 1px);\\n  bottom: 100%;\\n}\\n\\n.Toastify__toast--stacked[data-pos='top'] {\\n  top: 0;\\n}\\n\\n.Toastify__toast--stacked[data-pos='bot'] {\\n  bottom: 0;\\n}\\n\\n.Toastify__toast--stacked[data-pos='bot'].Toastify__toast--stacked:before {\\n  transform-origin: top;\\n}\\n\\n.Toastify__toast--stacked[data-pos='top'].Toastify__toast--stacked:before {\\n  transform-origin: bottom;\\n}\\n\\n.Toastify__toast--stacked:before {\\n  content: '';\\n  position: absolute;\\n  left: 0;\\n  right: 0;\\n  bottom: 0;\\n  height: 100%;\\n  transform: scaleY(3);\\n  z-index: -1;\\n}\\n\\n.Toastify__toast--rtl {\\n  direction: rtl;\\n}\\n\\n.Toastify__toast--close-on-click {\\n  cursor: pointer;\\n}\\n\\n.Toastify__toast-icon {\\n  margin-inline-end: 10px;\\n  width: 22px;\\n  flex-shrink: 0;\\n  display: flex;\\n}\\n\\n.Toastify--animate {\\n  animation-fill-mode: both;\\n  animation-duration: 0.5s;\\n}\\n\\n.Toastify--animate-icon {\\n  animation-fill-mode: both;\\n  animation-duration: 0.3s;\\n}\\n\\n.Toastify__toast-theme--dark {\\n  background: var(--toastify-color-dark);\\n  color: var(--toastify-text-color-dark);\\n}\\n\\n.Toastify__toast-theme--light {\\n  background: var(--toastify-color-light);\\n  color: var(--toastify-text-color-light);\\n}\\n\\n.Toastify__toast-theme--colored.Toastify__toast--default {\\n  background: var(--toastify-color-light);\\n  color: var(--toastify-text-color-light);\\n}\\n\\n.Toastify__toast-theme--colored.Toastify__toast--info {\\n  color: var(--toastify-text-color-info);\\n  background: var(--toastify-color-info);\\n}\\n\\n.Toastify__toast-theme--colored.Toastify__toast--success {\\n  color: var(--toastify-text-color-success);\\n  background: var(--toastify-color-success);\\n}\\n\\n.Toastify__toast-theme--colored.Toastify__toast--warning {\\n  color: var(--toastify-text-color-warning);\\n  background: var(--toastify-color-warning);\\n}\\n\\n.Toastify__toast-theme--colored.Toastify__toast--error {\\n  color: var(--toastify-text-color-error);\\n  background: var(--toastify-color-error);\\n}\\n\\n.Toastify__progress-bar-theme--light {\\n  background: var(--toastify-color-progress-light);\\n}\\n\\n.Toastify__progress-bar-theme--dark {\\n  background: var(--toastify-color-progress-dark);\\n}\\n\\n.Toastify__progress-bar--info {\\n  background: var(--toastify-color-progress-info);\\n}\\n\\n.Toastify__progress-bar--success {\\n  background: var(--toastify-color-progress-success);\\n}\\n\\n.Toastify__progress-bar--warning {\\n  background: var(--toastify-color-progress-warning);\\n}\\n\\n.Toastify__progress-bar--error {\\n  background: var(--toastify-color-progress-error);\\n}\\n\\n.Toastify__progress-bar-theme--colored.Toastify__progress-bar--info,\\n.Toastify__progress-bar-theme--colored.Toastify__progress-bar--success,\\n.Toastify__progress-bar-theme--colored.Toastify__progress-bar--warning,\\n.Toastify__progress-bar-theme--colored.Toastify__progress-bar--error {\\n  background: var(--toastify-color-transparent);\\n}\\n\\n.Toastify__close-button {\\n  color: #fff;\\n  position: absolute;\\n  top: 6px;\\n  right: 6px;\\n  background: transparent;\\n  outline: none;\\n  border: none;\\n  padding: 0;\\n  cursor: pointer;\\n  opacity: 0.7;\\n  transition: 0.3s ease;\\n  z-index: 1;\\n}\\n\\n.Toastify__toast--rtl .Toastify__close-button {\\n  left: 6px;\\n  right: unset;\\n}\\n\\n.Toastify__close-button--light {\\n  color: #000;\\n  opacity: 0.3;\\n}\\n\\n.Toastify__close-button > svg {\\n  fill: currentColor;\\n  height: 16px;\\n  width: 14px;\\n}\\n\\n.Toastify__close-button:hover,\\n.Toastify__close-button:focus {\\n  opacity: 1;\\n}\\n\\n@keyframes Toastify__trackProgress {\\n  0% {\\n    transform: scaleX(1);\\n  }\\n  100% {\\n    transform: scaleX(0);\\n  }\\n}\\n\\n.Toastify__progress-bar {\\n  position: absolute;\\n  bottom: 0;\\n  left: 0;\\n  width: 100%;\\n  height: 100%;\\n  z-index: 1;\\n  opacity: 0.7;\\n  transform-origin: left;\\n}\\n\\n.Toastify__progress-bar--animated {\\n  animation: Toastify__trackProgress linear 1 forwards;\\n}\\n\\n.Toastify__progress-bar--controlled {\\n  transition: transform 0.2s;\\n}\\n\\n.Toastify__progress-bar--rtl {\\n  right: 0;\\n  left: initial;\\n  transform-origin: right;\\n  border-bottom-left-radius: initial;\\n}\\n\\n.Toastify__progress-bar--wrp {\\n  position: absolute;\\n  overflow: hidden;\\n  bottom: 0;\\n  left: 0;\\n  width: 100%;\\n  height: 5px;\\n  border-bottom-left-radius: var(--toastify-toast-bd-radius);\\n  border-bottom-right-radius: var(--toastify-toast-bd-radius);\\n}\\n\\n.Toastify__progress-bar--wrp[data-hidden='true'] {\\n  opacity: 0;\\n}\\n\\n.Toastify__progress-bar--bg {\\n  opacity: var(--toastify-color-progress-bgo);\\n  width: 100%;\\n  height: 100%;\\n}\\n\\n.Toastify__spinner {\\n  width: 20px;\\n  height: 20px;\\n  box-sizing: border-box;\\n  border: 2px solid;\\n  border-radius: 100%;\\n  border-color: var(--toastify-spinner-color-empty-area);\\n  border-right-color: var(--toastify-spinner-color);\\n  animation: Toastify__spin 0.65s linear infinite;\\n}\\n\\n@keyframes Toastify__bounceInRight {\\n  from,\\n  60%,\\n  75%,\\n  90%,\\n  to {\\n    animation-timing-function: cubic-bezier(0.215, 0.61, 0.355, 1);\\n  }\\n  from {\\n    opacity: 0;\\n    transform: translate3d(3000px, 0, 0);\\n  }\\n  60% {\\n    opacity: 1;\\n    transform: translate3d(-25px, 0, 0);\\n  }\\n  75% {\\n    transform: translate3d(10px, 0, 0);\\n  }\\n  90% {\\n    transform: translate3d(-5px, 0, 0);\\n  }\\n  to {\\n    transform: none;\\n  }\\n}\\n\\n@keyframes Toastify__bounceOutRight {\\n  20% {\\n    opacity: 1;\\n    transform: translate3d(-20px, var(--y), 0);\\n  }\\n  to {\\n    opacity: 0;\\n    transform: translate3d(2000px, var(--y), 0);\\n  }\\n}\\n\\n@keyframes Toastify__bounceInLeft {\\n  from,\\n  60%,\\n  75%,\\n  90%,\\n  to {\\n    animation-timing-function: cubic-bezier(0.215, 0.61, 0.355, 1);\\n  }\\n  0% {\\n    opacity: 0;\\n    transform: translate3d(-3000px, 0, 0);\\n  }\\n  60% {\\n    opacity: 1;\\n    transform: translate3d(25px, 0, 0);\\n  }\\n  75% {\\n    transform: translate3d(-10px, 0, 0);\\n  }\\n  90% {\\n    transform: translate3d(5px, 0, 0);\\n  }\\n  to {\\n    transform: none;\\n  }\\n}\\n\\n@keyframes Toastify__bounceOutLeft {\\n  20% {\\n    opacity: 1;\\n    transform: translate3d(20px, var(--y), 0);\\n  }\\n  to {\\n    opacity: 0;\\n    transform: translate3d(-2000px, var(--y), 0);\\n  }\\n}\\n\\n@keyframes Toastify__bounceInUp {\\n  from,\\n  60%,\\n  75%,\\n  90%,\\n  to {\\n    animation-timing-function: cubic-bezier(0.215, 0.61, 0.355, 1);\\n  }\\n  from {\\n    opacity: 0;\\n    transform: translate3d(0, 3000px, 0);\\n  }\\n  60% {\\n    opacity: 1;\\n    transform: translate3d(0, -20px, 0);\\n  }\\n  75% {\\n    transform: translate3d(0, 10px, 0);\\n  }\\n  90% {\\n    transform: translate3d(0, -5px, 0);\\n  }\\n  to {\\n    transform: translate3d(0, 0, 0);\\n  }\\n}\\n\\n@keyframes Toastify__bounceOutUp {\\n  20% {\\n    transform: translate3d(0, calc(var(--y) - 10px), 0);\\n  }\\n  40%,\\n  45% {\\n    opacity: 1;\\n    transform: translate3d(0, calc(var(--y) + 20px), 0);\\n  }\\n  to {\\n    opacity: 0;\\n    transform: translate3d(0, -2000px, 0);\\n  }\\n}\\n\\n@keyframes Toastify__bounceInDown {\\n  from,\\n  60%,\\n  75%,\\n  90%,\\n  to {\\n    animation-timing-function: cubic-bezier(0.215, 0.61, 0.355, 1);\\n  }\\n  0% {\\n    opacity: 0;\\n    transform: translate3d(0, -3000px, 0);\\n  }\\n  60% {\\n    opacity: 1;\\n    transform: translate3d(0, 25px, 0);\\n  }\\n  75% {\\n    transform: translate3d(0, -10px, 0);\\n  }\\n  90% {\\n    transform: translate3d(0, 5px, 0);\\n  }\\n  to {\\n    transform: none;\\n  }\\n}\\n\\n@keyframes Toastify__bounceOutDown {\\n  20% {\\n    transform: translate3d(0, calc(var(--y) - 10px), 0);\\n  }\\n  40%,\\n  45% {\\n    opacity: 1;\\n    transform: translate3d(0, calc(var(--y) + 20px), 0);\\n  }\\n  to {\\n    opacity: 0;\\n    transform: translate3d(0, 2000px, 0);\\n  }\\n}\\n\\n.Toastify__bounce-enter--top-left,\\n.Toastify__bounce-enter--bottom-left {\\n  animation-name: Toastify__bounceInLeft;\\n}\\n\\n.Toastify__bounce-enter--top-right,\\n.Toastify__bounce-enter--bottom-right {\\n  animation-name: Toastify__bounceInRight;\\n}\\n\\n.Toastify__bounce-enter--top-center {\\n  animation-name: Toastify__bounceInDown;\\n}\\n\\n.Toastify__bounce-enter--bottom-center {\\n  animation-name: Toastify__bounceInUp;\\n}\\n\\n.Toastify__bounce-exit--top-left,\\n.Toastify__bounce-exit--bottom-left {\\n  animation-name: Toastify__bounceOutLeft;\\n}\\n\\n.Toastify__bounce-exit--top-right,\\n.Toastify__bounce-exit--bottom-right {\\n  animation-name: Toastify__bounceOutRight;\\n}\\n\\n.Toastify__bounce-exit--top-center {\\n  animation-name: Toastify__bounceOutUp;\\n}\\n\\n.Toastify__bounce-exit--bottom-center {\\n  animation-name: Toastify__bounceOutDown;\\n}\\n\\n@keyframes Toastify__zoomIn {\\n  from {\\n    opacity: 0;\\n    transform: scale3d(0.3, 0.3, 0.3);\\n  }\\n  50% {\\n    opacity: 1;\\n  }\\n}\\n\\n@keyframes Toastify__zoomOut {\\n  from {\\n    opacity: 1;\\n  }\\n  50% {\\n    opacity: 0;\\n    transform: translate3d(0, var(--y), 0) scale3d(0.3, 0.3, 0.3);\\n  }\\n  to {\\n    opacity: 0;\\n  }\\n}\\n\\n.Toastify__zoom-enter {\\n  animation-name: Toastify__zoomIn;\\n}\\n\\n.Toastify__zoom-exit {\\n  animation-name: Toastify__zoomOut;\\n}\\n\\n@keyframes Toastify__flipIn {\\n  from {\\n    transform: perspective(400px) rotate3d(1, 0, 0, 90deg);\\n    animation-timing-function: ease-in;\\n    opacity: 0;\\n  }\\n  40% {\\n    transform: perspective(400px) rotate3d(1, 0, 0, -20deg);\\n    animation-timing-function: ease-in;\\n  }\\n  60% {\\n    transform: perspective(400px) rotate3d(1, 0, 0, 10deg);\\n    opacity: 1;\\n  }\\n  80% {\\n    transform: perspective(400px) rotate3d(1, 0, 0, -5deg);\\n  }\\n  to {\\n    transform: perspective(400px);\\n  }\\n}\\n\\n@keyframes Toastify__flipOut {\\n  from {\\n    transform: translate3d(0, var(--y), 0) perspective(400px);\\n  }\\n  30% {\\n    transform: translate3d(0, var(--y), 0) perspective(400px) rotate3d(1, 0, 0, -20deg);\\n    opacity: 1;\\n  }\\n  to {\\n    transform: translate3d(0, var(--y), 0) perspective(400px) rotate3d(1, 0, 0, 90deg);\\n    opacity: 0;\\n  }\\n}\\n\\n.Toastify__flip-enter {\\n  animation-name: Toastify__flipIn;\\n}\\n\\n.Toastify__flip-exit {\\n  animation-name: Toastify__flipOut;\\n}\\n\\n@keyframes Toastify__slideInRight {\\n  from {\\n    transform: translate3d(110%, 0, 0);\\n    visibility: visible;\\n  }\\n  to {\\n    transform: translate3d(0, var(--y), 0);\\n  }\\n}\\n\\n@keyframes Toastify__slideInLeft {\\n  from {\\n    transform: translate3d(-110%, 0, 0);\\n    visibility: visible;\\n  }\\n  to {\\n    transform: translate3d(0, var(--y), 0);\\n  }\\n}\\n\\n@keyframes Toastify__slideInUp {\\n  from {\\n    transform: translate3d(0, 110%, 0);\\n    visibility: visible;\\n  }\\n  to {\\n    transform: translate3d(0, var(--y), 0);\\n  }\\n}\\n\\n@keyframes Toastify__slideInDown {\\n  from {\\n    transform: translate3d(0, -110%, 0);\\n    visibility: visible;\\n  }\\n  to {\\n    transform: translate3d(0, var(--y), 0);\\n  }\\n}\\n\\n@keyframes Toastify__slideOutRight {\\n  from {\\n    transform: translate3d(0, var(--y), 0);\\n  }\\n  to {\\n    visibility: hidden;\\n    transform: translate3d(110%, var(--y), 0);\\n  }\\n}\\n\\n@keyframes Toastify__slideOutLeft {\\n  from {\\n    transform: translate3d(0, var(--y), 0);\\n  }\\n  to {\\n    visibility: hidden;\\n    transform: translate3d(-110%, var(--y), 0);\\n  }\\n}\\n\\n@keyframes Toastify__slideOutDown {\\n  from {\\n    transform: translate3d(0, var(--y), 0);\\n  }\\n  to {\\n    visibility: hidden;\\n    transform: translate3d(0, 500px, 0);\\n  }\\n}\\n\\n@keyframes Toastify__slideOutUp {\\n  from {\\n    transform: translate3d(0, var(--y), 0);\\n  }\\n  to {\\n    visibility: hidden;\\n    transform: translate3d(0, -500px, 0);\\n  }\\n}\\n\\n.Toastify__slide-enter--top-left,\\n.Toastify__slide-enter--bottom-left {\\n  animation-name: Toastify__slideInLeft;\\n}\\n\\n.Toastify__slide-enter--top-right,\\n.Toastify__slide-enter--bottom-right {\\n  animation-name: Toastify__slideInRight;\\n}\\n\\n.Toastify__slide-enter--top-center {\\n  animation-name: Toastify__slideInDown;\\n}\\n\\n.Toastify__slide-enter--bottom-center {\\n  animation-name: Toastify__slideInUp;\\n}\\n\\n.Toastify__slide-exit--top-left,\\n.Toastify__slide-exit--bottom-left {\\n  animation-name: Toastify__slideOutLeft;\\n  animation-timing-function: ease-in;\\n  animation-duration: 0.3s;\\n}\\n\\n.Toastify__slide-exit--top-right,\\n.Toastify__slide-exit--bottom-right {\\n  animation-name: Toastify__slideOutRight;\\n  animation-timing-function: ease-in;\\n  animation-duration: 0.3s;\\n}\\n\\n.Toastify__slide-exit--top-center {\\n  animation-name: Toastify__slideOutUp;\\n  animation-timing-function: ease-in;\\n  animation-duration: 0.3s;\\n}\\n\\n.Toastify__slide-exit--bottom-center {\\n  animation-name: Toastify__slideOutDown;\\n  animation-timing-function: ease-in;\\n  animation-duration: 0.3s;\\n}\\n\\n@keyframes Toastify__spin {\\n  from {\\n    transform: rotate(0deg);\\n  }\\n  to {\\n    transform: rotate(360deg);\\n  }\\n}\\n\", \"\",{\"version\":3,\"sources\":[\"webpack://node_modules/react-toastify/dist/ReactToastify.css\"],\"names\":[],\"mappings\":\"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ACE,mCAAmC;EACrC;EACA;IACE,iCAAiC;EACnC;EACA;IACE,eAAe;EACjB;AACF;;AAEA;EACE;IACE,UAAU;IACV,yCAAyC;EAC3C;EACA;IACE,UAAU;IACV,4CAA4C;EAC9C;AACF;;AAEA;EACE;;;;;IAKE,8DAA8D;EAChE;EACA;IACE,UAAU;IACV,oCAAoC;EACtC;EACA;IACE,UAAU;IACV,mCAAmC;EACrC;EACA;IACE,kCAAkC;EACpC;EACA;IACE,kCAAkC;EACpC;EACA;IACE,+BAA+B;EACjC;AACF;;AAEA;EACE;IACE,mDAAmD;EACrD;EACA;;IAEE,UAAU;IACV,mDAAmD;EACrD;EACA;IACE,UAAU;IACV,qCAAqC;EACvC;AACF;;AAEA;EACE;;;;;IAKE,8DAA8D;EAChE;EACA;IACE,UAAU;IACV,qCAAqC;EACvC;EACA;IACE,UAAU;IACV,kCAAkC;EACpC;EACA;IACE,mCAAmC;EACrC;EACA;IACE,iCAAiC;EACnC;EACA;IACE,eAAe;EACjB;AACF;;AAEA;EACE;IACE,mDAAmD;EACrD;EACA;;IAEE,UAAU;IACV,mDAAmD;EACrD;EACA;IACE,UAAU;IACV,oCAAoC;EACtC;AACF;;AAEA;;EAEE,sCAAsC;AACxC;;AAEA;;EAEE,uCAAuC;AACzC;;AAEA;EACE,sCAAsC;AACxC;;AAEA;EACE,oCAAoC;AACtC;;AAEA;;EAEE,uCAAuC;AACzC;;AAEA;;EAEE,wCAAwC;AAC1C;;AAEA;EACE,qCAAqC;AACvC;;AAEA;EACE,uCAAuC;AACzC;;AAEA;EACE;IACE,UAAU;IACV,iCAAiC;EACnC;EACA;IACE,UAAU;EACZ;AACF;;AAEA;EACE;IACE,UAAU;EACZ;EACA;IACE,UAAU;IACV,6DAA6D;EAC/D;EACA;IACE,UAAU;EACZ;AACF;;AAEA;EACE,gCAAgC;AAClC;;AAEA;EACE,iCAAiC;AACnC;;AAEA;EACE;IACE,sDAAsD;IACtD,kCAAkC;IAClC,UAAU;EACZ;EACA;IACE,uDAAuD;IACvD,kCAAkC;EACpC;EACA;IACE,sDAAsD;IACtD,UAAU;EACZ;EACA;IACE,sDAAsD;EACxD;EACA;IACE,6BAA6B;EAC/B;AACF;;AAEA;EACE;IACE,yDAAyD;EAC3D;EACA;IACE,mFAAmF;IACnF,UAAU;EACZ;EACA;IACE,kFAAkF;IAClF,UAAU;EACZ;AACF;;AAEA;EACE,gCAAgC;AAClC;;AAEA;EACE,iCAAiC;AACnC;;AAEA;EACE;IACE,kCAAkC;IAClC,mBAAmB;EACrB;EACA;IACE,sCAAsC;EACxC;AACF;;AAEA;EACE;IACE,mCAAmC;IACnC,mBAAmB;EACrB;EACA;IACE,sCAAsC;EACxC;AACF;;AAEA;EACE;IACE,kCAAkC;IAClC,mBAAmB;EACrB;EACA;IACE,sCAAsC;EACxC;AACF;;AAEA;EACE;IACE,mCAAmC;IACnC,mBAAmB;EACrB;EACA;IACE,sCAAsC;EACxC;AACF;;AAEA;EACE;IACE,sCAAsC;EACxC;EACA;IACE,kBAAkB;IAClB,yCAAyC;EAC3C;AACF;;AAEA;EACE;IACE,sCAAsC;EACxC;EACA;IACE,kBAAkB;IAClB,0CAA0C;EAC5C;AACF;;AAEA;EACE;IACE,sCAAsC;EACxC;EACA;IACE,kBAAkB;IAClB,mCAAmC;EACrC;AACF;;AAEA;EACE;IACE,sCAAsC;EACxC;EACA;IACE,kBAAkB;IAClB,oCAAoC;EACtC;AACF;;AAEA;;EAEE,qCAAqC;AACvC;;AAEA;;EAEE,sCAAsC;AACxC;;AAEA;EACE,qCAAqC;AACvC;;AAEA;EACE,mCAAmC;AACrC;;AAEA;;EAEE,sCAAsC;EACtC,kCAAkC;EAClC,wBAAwB;AAC1B;;AAEA;;EAEE,uCAAuC;EACvC,kCAAkC;EAClC,wBAAwB;AAC1B;;AAEA;EACE,oCAAoC;EACpC,kCAAkC;EAClC,wBAAwB;AAC1B;;AAEA;EACE,sCAAsC;EACtC,kCAAkC;EAClC,wBAAwB;AAC1B;;AAEA;EACE;IACE,uBAAuB;EACzB;EACA;IACE,yBAAyB;EAC3B;AACF\",\"sourcesContent\":[\":root {\\n  --toastify-color-light: #fff;\\n  --toastify-color-dark: #121212;\\n  --toastify-color-info: #3498db;\\n  --toastify-color-success: #07bc0c;\\n  --toastify-color-warning: #f1c40f;\\n  --toastify-color-error: hsl(6, 78%, 57%);\\n  --toastify-color-transparent: rgba(255, 255, 255, 0.7);\\n\\n  --toastify-icon-color-info: var(--toastify-color-info);\\n  --toastify-icon-color-success: var(--toastify-color-success);\\n  --toastify-icon-color-warning: var(--toastify-color-warning);\\n  --toastify-icon-color-error: var(--toastify-color-error);\\n\\n  --toastify-container-width: fit-content;\\n  --toastify-toast-width: 320px;\\n  --toastify-toast-offset: 16px;\\n  --toastify-toast-top: max(var(--toastify-toast-offset), env(safe-area-inset-top));\\n  --toastify-toast-right: max(var(--toastify-toast-offset), env(safe-area-inset-right));\\n  --toastify-toast-left: max(var(--toastify-toast-offset), env(safe-area-inset-left));\\n  --toastify-toast-bottom: max(var(--toastify-toast-offset), env(safe-area-inset-bottom));\\n  --toastify-toast-background: #fff;\\n  --toastify-toast-padding: 14px;\\n  --toastify-toast-min-height: 64px;\\n  --toastify-toast-max-height: 800px;\\n  --toastify-toast-bd-radius: 6px;\\n  --toastify-toast-shadow: 0px 4px 12px rgba(0, 0, 0, 0.1);\\n  --toastify-font-family: sans-serif;\\n  --toastify-z-index: 9999;\\n  --toastify-text-color-light: #757575;\\n  --toastify-text-color-dark: #fff;\\n\\n  /* Used only for colored theme */\\n  --toastify-text-color-info: #fff;\\n  --toastify-text-color-success: #fff;\\n  --toastify-text-color-warning: #fff;\\n  --toastify-text-color-error: #fff;\\n\\n  --toastify-spinner-color: #616161;\\n  --toastify-spinner-color-empty-area: #e0e0e0;\\n  --toastify-color-progress-light: linear-gradient(to right, #4cd964, #5ac8fa, #007aff, #34aadc, #5856d6, #ff2d55);\\n  --toastify-color-progress-dark: #bb86fc;\\n  --toastify-color-progress-info: var(--toastify-color-info);\\n  --toastify-color-progress-success: var(--toastify-color-success);\\n  --toastify-color-progress-warning: var(--toastify-color-warning);\\n  --toastify-color-progress-error: var(--toastify-color-error);\\n  /* used to control the opacity of the progress trail */\\n  --toastify-color-progress-bgo: 0.2;\\n}\\n\\n.Toastify__toast-container {\\n  z-index: var(--toastify-z-index);\\n  -webkit-transform: translate3d(0, 0, var(--toastify-z-index));\\n  position: fixed;\\n  width: var(--toastify-container-width);\\n  box-sizing: border-box;\\n  color: #fff;\\n  display: flex;\\n  flex-direction: column;\\n}\\n\\n.Toastify__toast-container--top-left {\\n  top: var(--toastify-toast-top);\\n  left: var(--toastify-toast-left);\\n}\\n.Toastify__toast-container--top-center {\\n  top: var(--toastify-toast-top);\\n  left: 50%;\\n  transform: translateX(-50%);\\n  align-items: center;\\n}\\n.Toastify__toast-container--top-right {\\n  top: var(--toastify-toast-top);\\n  right: var(--toastify-toast-right);\\n  align-items: end;\\n}\\n.Toastify__toast-container--bottom-left {\\n  bottom: var(--toastify-toast-bottom);\\n  left: var(--toastify-toast-left);\\n}\\n.Toastify__toast-container--bottom-center {\\n  bottom: var(--toastify-toast-bottom);\\n  left: 50%;\\n  transform: translateX(-50%);\\n  align-items: center;\\n}\\n.Toastify__toast-container--bottom-right {\\n  bottom: var(--toastify-toast-bottom);\\n  right: var(--toastify-toast-right);\\n  align-items: end;\\n}\\n\\n.Toastify__toast {\\n  --y: 0;\\n  position: relative;\\n  touch-action: none;\\n  width: var(--toastify-toast-width);\\n  min-height: var(--toastify-toast-min-height);\\n  box-sizing: border-box;\\n  margin-bottom: 1rem;\\n  padding: var(--toastify-toast-padding);\\n  border-radius: var(--toastify-toast-bd-radius);\\n  box-shadow: var(--toastify-toast-shadow);\\n  max-height: var(--toastify-toast-max-height);\\n  font-family: var(--toastify-font-family);\\n  /* webkit only issue #791 */\\n  z-index: 0;\\n  /* inner swag */\\n  display: flex;\\n  flex: 1 auto;\\n  align-items: center;\\n  word-break: break-word;\\n}\\n\\n@media only screen and (max-width: 480px) {\\n  .Toastify__toast-container {\\n    width: 100vw;\\n    left: env(safe-area-inset-left);\\n    margin: 0;\\n  }\\n  .Toastify__toast-container--top-left,\\n  .Toastify__toast-container--top-center,\\n  .Toastify__toast-container--top-right {\\n    top: env(safe-area-inset-top);\\n    transform: translateX(0);\\n  }\\n  .Toastify__toast-container--bottom-left,\\n  .Toastify__toast-container--bottom-center,\\n  .Toastify__toast-container--bottom-right {\\n    bottom: env(safe-area-inset-bottom);\\n    transform: translateX(0);\\n  }\\n  .Toastify__toast-container--rtl {\\n    right: env(safe-area-inset-right);\\n    left: initial;\\n  }\\n  .Toastify__toast {\\n    --toastify-toast-width: 100%;\\n    margin-bottom: 0;\\n    border-radius: 0;\\n  }\\n}\\n\\n.Toastify__toast-container[data-stacked='true'] {\\n  width: var(--toastify-toast-width);\\n}\\n\\n.Toastify__toast--stacked {\\n  position: absolute;\\n  width: 100%;\\n  transform: translate3d(0, var(--y), 0) scale(var(--s));\\n  transition: transform 0.3s;\\n}\\n\\n.Toastify__toast--stacked[data-collapsed] .Toastify__toast-body,\\n.Toastify__toast--stacked[data-collapsed] .Toastify__close-button {\\n  transition: opacity 0.1s;\\n}\\n\\n.Toastify__toast--stacked[data-collapsed='false'] {\\n  overflow: visible;\\n}\\n\\n.Toastify__toast--stacked[data-collapsed='true']:not(:last-child) > * {\\n  opacity: 0;\\n}\\n\\n.Toastify__toast--stacked:after {\\n  content: '';\\n  position: absolute;\\n  left: 0;\\n  right: 0;\\n  height: calc(var(--g) * 1px);\\n  bottom: 100%;\\n}\\n\\n.Toastify__toast--stacked[data-pos='top'] {\\n  top: 0;\\n}\\n\\n.Toastify__toast--stacked[data-pos='bot'] {\\n  bottom: 0;\\n}\\n\\n.Toastify__toast--stacked[data-pos='bot'].Toastify__toast--stacked:before {\\n  transform-origin: top;\\n}\\n\\n.Toastify__toast--stacked[data-pos='top'].Toastify__toast--stacked:before {\\n  transform-origin: bottom;\\n}\\n\\n.Toastify__toast--stacked:before {\\n  content: '';\\n  position: absolute;\\n  left: 0;\\n  right: 0;\\n  bottom: 0;\\n  height: 100%;\\n  transform: scaleY(3);\\n  z-index: -1;\\n}\\n\\n.Toastify__toast--rtl {\\n  direction: rtl;\\n}\\n\\n.Toastify__toast--close-on-click {\\n  cursor: pointer;\\n}\\n\\n.Toastify__toast-icon {\\n  margin-inline-end: 10px;\\n  width: 22px;\\n  flex-shrink: 0;\\n  display: flex;\\n}\\n\\n.Toastify--animate {\\n  animation-fill-mode: both;\\n  animation-duration: 0.5s;\\n}\\n\\n.Toastify--animate-icon {\\n  animation-fill-mode: both;\\n  animation-duration: 0.3s;\\n}\\n\\n.Toastify__toast-theme--dark {\\n  background: var(--toastify-color-dark);\\n  color: var(--toastify-text-color-dark);\\n}\\n\\n.Toastify__toast-theme--light {\\n  background: var(--toastify-color-light);\\n  color: var(--toastify-text-color-light);\\n}\\n\\n.Toastify__toast-theme--colored.Toastify__toast--default {\\n  background: var(--toastify-color-light);\\n  color: var(--toastify-text-color-light);\\n}\\n\\n.Toastify__toast-theme--colored.Toastify__toast--info {\\n  color: var(--toastify-text-color-info);\\n  background: var(--toastify-color-info);\\n}\\n\\n.Toastify__toast-theme--colored.Toastify__toast--success {\\n  color: var(--toastify-text-color-success);\\n  background: var(--toastify-color-success);\\n}\\n\\n.Toastify__toast-theme--colored.Toastify__toast--warning {\\n  color: var(--toastify-text-color-warning);\\n  background: var(--toastify-color-warning);\\n}\\n\\n.Toastify__toast-theme--colored.Toastify__toast--error {\\n  color: var(--toastify-text-color-error);\\n  background: var(--toastify-color-error);\\n}\\n\\n.Toastify__progress-bar-theme--light {\\n  background: var(--toastify-color-progress-light);\\n}\\n\\n.Toastify__progress-bar-theme--dark {\\n  background: var(--toastify-color-progress-dark);\\n}\\n\\n.Toastify__progress-bar--info {\\n  background: var(--toastify-color-progress-info);\\n}\\n\\n.Toastify__progress-bar--success {\\n  background: var(--toastify-color-progress-success);\\n}\\n\\n.Toastify__progress-bar--warning {\\n  background: var(--toastify-color-progress-warning);\\n}\\n\\n.Toastify__progress-bar--error {\\n  background: var(--toastify-color-progress-error);\\n}\\n\\n.Toastify__progress-bar-theme--colored.Toastify__progress-bar--info,\\n.Toastify__progress-bar-theme--colored.Toastify__progress-bar--success,\\n.Toastify__progress-bar-theme--colored.Toastify__progress-bar--warning,\\n.Toastify__progress-bar-theme--colored.Toastify__progress-bar--error {\\n  background: var(--toastify-color-transparent);\\n}\\n\\n.Toastify__close-button {\\n  color: #fff;\\n  position: absolute;\\n  top: 6px;\\n  right: 6px;\\n  background: transparent;\\n  outline: none;\\n  border: none;\\n  padding: 0;\\n  cursor: pointer;\\n  opacity: 0.7;\\n  transition: 0.3s ease;\\n  z-index: 1;\\n}\\n\\n.Toastify__toast--rtl .Toastify__close-button {\\n  left: 6px;\\n  right: unset;\\n}\\n\\n.Toastify__close-button--light {\\n  color: #000;\\n  opacity: 0.3;\\n}\\n\\n.Toastify__close-button > svg {\\n  fill: currentColor;\\n  height: 16px;\\n  width: 14px;\\n}\\n\\n.Toastify__close-button:hover,\\n.Toastify__close-button:focus {\\n  opacity: 1;\\n}\\n\\n@keyframes Toastify__trackProgress {\\n  0% {\\n    transform: scaleX(1);\\n  }\\n  100% {\\n    transform: scaleX(0);\\n  }\\n}\\n\\n.Toastify__progress-bar {\\n  position: absolute;\\n  bottom: 0;\\n  left: 0;\\n  width: 100%;\\n  height: 100%;\\n  z-index: 1;\\n  opacity: 0.7;\\n  transform-origin: left;\\n}\\n\\n.Toastify__progress-bar--animated {\\n  animation: Toastify__trackProgress linear 1 forwards;\\n}\\n\\n.Toastify__progress-bar--controlled {\\n  transition: transform 0.2s;\\n}\\n\\n.Toastify__progress-bar--rtl {\\n  right: 0;\\n  left: initial;\\n  transform-origin: right;\\n  border-bottom-left-radius: initial;\\n}\\n\\n.Toastify__progress-bar--wrp {\\n  position: absolute;\\n  overflow: hidden;\\n  bottom: 0;\\n  left: 0;\\n  width: 100%;\\n  height: 5px;\\n  border-bottom-left-radius: var(--toastify-toast-bd-radius);\\n  border-bottom-right-radius: var(--toastify-toast-bd-radius);\\n}\\n\\n.Toastify__progress-bar--wrp[data-hidden='true'] {\\n  opacity: 0;\\n}\\n\\n.Toastify__progress-bar--bg {\\n  opacity: var(--toastify-color-progress-bgo);\\n  width: 100%;\\n  height: 100%;\\n}\\n\\n.Toastify__spinner {\\n  width: 20px;\\n  height: 20px;\\n  box-sizing: border-box;\\n  border: 2px solid;\\n  border-radius: 100%;\\n  border-color: var(--toastify-spinner-color-empty-area);\\n  border-right-color: var(--toastify-spinner-color);\\n  animation: Toastify__spin 0.65s linear infinite;\\n}\\n\\n@keyframes Toastify__bounceInRight {\\n  from,\\n  60%,\\n  75%,\\n  90%,\\n  to {\\n    animation-timing-function: cubic-bezier(0.215, 0.61, 0.355, 1);\\n  }\\n  from {\\n    opacity: 0;\\n    transform: translate3d(3000px, 0, 0);\\n  }\\n  60% {\\n    opacity: 1;\\n    transform: translate3d(-25px, 0, 0);\\n  }\\n  75% {\\n    transform: translate3d(10px, 0, 0);\\n  }\\n  90% {\\n    transform: translate3d(-5px, 0, 0);\\n  }\\n  to {\\n    transform: none;\\n  }\\n}\\n\\n@keyframes Toastify__bounceOutRight {\\n  20% {\\n    opacity: 1;\\n    transform: translate3d(-20px, var(--y), 0);\\n  }\\n  to {\\n    opacity: 0;\\n    transform: translate3d(2000px, var(--y), 0);\\n  }\\n}\\n\\n@keyframes Toastify__bounceInLeft {\\n  from,\\n  60%,\\n  75%,\\n  90%,\\n  to {\\n    animation-timing-function: cubic-bezier(0.215, 0.61, 0.355, 1);\\n  }\\n  0% {\\n    opacity: 0;\\n    transform: translate3d(-3000px, 0, 0);\\n  }\\n  60% {\\n    opacity: 1;\\n    transform: translate3d(25px, 0, 0);\\n  }\\n  75% {\\n    transform: translate3d(-10px, 0, 0);\\n  }\\n  90% {\\n    transform: translate3d(5px, 0, 0);\\n  }\\n  to {\\n    transform: none;\\n  }\\n}\\n\\n@keyframes Toastify__bounceOutLeft {\\n  20% {\\n    opacity: 1;\\n    transform: translate3d(20px, var(--y), 0);\\n  }\\n  to {\\n    opacity: 0;\\n    transform: translate3d(-2000px, var(--y), 0);\\n  }\\n}\\n\\n@keyframes Toastify__bounceInUp {\\n  from,\\n  60%,\\n  75%,\\n  90%,\\n  to {\\n    animation-timing-function: cubic-bezier(0.215, 0.61, 0.355, 1);\\n  }\\n  from {\\n    opacity: 0;\\n    transform: translate3d(0, 3000px, 0);\\n  }\\n  60% {\\n    opacity: 1;\\n    transform: translate3d(0, -20px, 0);\\n  }\\n  75% {\\n    transform: translate3d(0, 10px, 0);\\n  }\\n  90% {\\n    transform: translate3d(0, -5px, 0);\\n  }\\n  to {\\n    transform: translate3d(0, 0, 0);\\n  }\\n}\\n\\n@keyframes Toastify__bounceOutUp {\\n  20% {\\n    transform: translate3d(0, calc(var(--y) - 10px), 0);\\n  }\\n  40%,\\n  45% {\\n    opacity: 1;\\n    transform: translate3d(0, calc(var(--y) + 20px), 0);\\n  }\\n  to {\\n    opacity: 0;\\n    transform: translate3d(0, -2000px, 0);\\n  }\\n}\\n\\n@keyframes Toastify__bounceInDown {\\n  from,\\n  60%,\\n  75%,\\n  90%,\\n  to {\\n    animation-timing-function: cubic-bezier(0.215, 0.61, 0.355, 1);\\n  }\\n  0% {\\n    opacity: 0;\\n    transform: translate3d(0, -3000px, 0);\\n  }\\n  60% {\\n    opacity: 1;\\n    transform: translate3d(0, 25px, 0);\\n  }\\n  75% {\\n    transform: translate3d(0, -10px, 0);\\n  }\\n  90% {\\n    transform: translate3d(0, 5px, 0);\\n  }\\n  to {\\n    transform: none;\\n  }\\n}\\n\\n@keyframes Toastify__bounceOutDown {\\n  20% {\\n    transform: translate3d(0, calc(var(--y) - 10px), 0);\\n  }\\n  40%,\\n  45% {\\n    opacity: 1;\\n    transform: translate3d(0, calc(var(--y) + 20px), 0);\\n  }\\n  to {\\n    opacity: 0;\\n    transform: translate3d(0, 2000px, 0);\\n  }\\n}\\n\\n.Toastify__bounce-enter--top-left,\\n.Toastify__bounce-enter--bottom-left {\\n  animation-name: Toastify__bounceInLeft;\\n}\\n\\n.Toastify__bounce-enter--top-right,\\n.Toastify__bounce-enter--bottom-right {\\n  animation-name: Toastify__bounceInRight;\\n}\\n\\n.Toastify__bounce-enter--top-center {\\n  animation-name: Toastify__bounceInDown;\\n}\\n\\n.Toastify__bounce-enter--bottom-center {\\n  animation-name: Toastify__bounceInUp;\\n}\\n\\n.Toastify__bounce-exit--top-left,\\n.Toastify__bounce-exit--bottom-left {\\n  animation-name: Toastify__bounceOutLeft;\\n}\\n\\n.Toastify__bounce-exit--top-right,\\n.Toastify__bounce-exit--bottom-right {\\n  animation-name: Toastify__bounceOutRight;\\n}\\n\\n.Toastify__bounce-exit--top-center {\\n  animation-name: Toastify__bounceOutUp;\\n}\\n\\n.Toastify__bounce-exit--bottom-center {\\n  animation-name: Toastify__bounceOutDown;\\n}\\n\\n@keyframes Toastify__zoomIn {\\n  from {\\n    opacity: 0;\\n    transform: scale3d(0.3, 0.3, 0.3);\\n  }\\n  50% {\\n    opacity: 1;\\n  }\\n}\\n\\n@keyframes Toastify__zoomOut {\\n  from {\\n    opacity: 1;\\n  }\\n  50% {\\n    opacity: 0;\\n    transform: translate3d(0, var(--y), 0) scale3d(0.3, 0.3, 0.3);\\n  }\\n  to {\\n    opacity: 0;\\n  }\\n}\\n\\n.Toastify__zoom-enter {\\n  animation-name: Toastify__zoomIn;\\n}\\n\\n.Toastify__zoom-exit {\\n  animation-name: Toastify__zoomOut;\\n}\\n\\n@keyframes Toastify__flipIn {\\n  from {\\n    transform: perspective(400px) rotate3d(1, 0, 0, 90deg);\\n    animation-timing-function: ease-in;\\n    opacity: 0;\\n  }\\n  40% {\\n    transform: perspective(400px) rotate3d(1, 0, 0, -20deg);\\n    animation-timing-function: ease-in;\\n  }\\n  60% {\\n    transform: perspective(400px) rotate3d(1, 0, 0, 10deg);\\n    opacity: 1;\\n  }\\n  80% {\\n    transform: perspective(400px) rotate3d(1, 0, 0, -5deg);\\n  }\\n  to {\\n    transform: perspective(400px);\\n  }\\n}\\n\\n@keyframes Toastify__flipOut {\\n  from {\\n    transform: translate3d(0, var(--y), 0) perspective(400px);\\n  }\\n  30% {\\n    transform: translate3d(0, var(--y), 0) perspective(400px) rotate3d(1, 0, 0, -20deg);\\n    opacity: 1;\\n  }\\n  to {\\n    transform: translate3d(0, var(--y), 0) perspective(400px) rotate3d(1, 0, 0, 90deg);\\n    opacity: 0;\\n  }\\n}\\n\\n.Toastify__flip-enter {\\n  animation-name: Toastify__flipIn;\\n}\\n\\n.Toastify__flip-exit {\\n  animation-name: Toastify__flipOut;\\n}\\n\\n@keyframes Toastify__slideInRight {\\n  from {\\n    transform: translate3d(110%, 0, 0);\\n    visibility: visible;\\n  }\\n  to {\\n    transform: translate3d(0, var(--y), 0);\\n  }\\n}\\n\\n@keyframes Toastify__slideInLeft {\\n  from {\\n    transform: translate3d(-110%, 0, 0);\\n    visibility: visible;\\n  }\\n  to {\\n    transform: translate3d(0, var(--y), 0);\\n  }\\n}\\n\\n@keyframes Toastify__slideInUp {\\n  from {\\n    transform: translate3d(0, 110%, 0);\\n    visibility: visible;\\n  }\\n  to {\\n    transform: translate3d(0, var(--y), 0);\\n  }\\n}\\n\\n@keyframes Toastify__slideInDown {\\n  from {\\n    transform: translate3d(0, -110%, 0);\\n    visibility: visible;\\n  }\\n  to {\\n    transform: translate3d(0, var(--y), 0);\\n  }\\n}\\n\\n@keyframes Toastify__slideOutRight {\\n  from {\\n    transform: translate3d(0, var(--y), 0);\\n  }\\n  to {\\n    visibility: hidden;\\n    transform: translate3d(110%, var(--y), 0);\\n  }\\n}\\n\\n@keyframes Toastify__slideOutLeft {\\n  from {\\n    transform: translate3d(0, var(--y), 0);\\n  }\\n  to {\\n    visibility: hidden;\\n    transform: translate3d(-110%, var(--y), 0);\\n  }\\n}\\n\\n@keyframes Toastify__slideOutDown {\\n  from {\\n    transform: translate3d(0, var(--y), 0);\\n  }\\n  to {\\n    visibility: hidden;\\n    transform: translate3d(0, 500px, 0);\\n  }\\n}\\n\\n@keyframes Toastify__slideOutUp {\\n  from {\\n    transform: translate3d(0, var(--y), 0);\\n  }\\n  to {\\n    visibility: hidden;\\n    transform: translate3d(0, -500px, 0);\\n  }\\n}\\n\\n.Toastify__slide-enter--top-left,\\n.Toastify__slide-enter--bottom-left {\\n  animation-name: Toastify__slideInLeft;\\n}\\n\\n.Toastify__slide-enter--top-right,\\n.Toastify__slide-enter--bottom-right {\\n  animation-name: Toastify__slideInRight;\\n}\\n\\n.Toastify__slide-enter--top-center {\\n  animation-name: Toastify__slideInDown;\\n}\\n\\n.Toastify__slide-enter--bottom-center {\\n  animation-name: Toastify__slideInUp;\\n}\\n\\n.Toastify__slide-exit--top-left,\\n.Toastify__slide-exit--bottom-left {\\n  animation-name: Toastify__slideOutLeft;\\n  animation-timing-function: ease-in;\\n  animation-duration: 0.3s;\\n}\\n\\n.Toastify__slide-exit--top-right,\\n.Toastify__slide-exit--bottom-right {\\n  animation-name: Toastify__slideOutRight;\\n  animation-timing-function: ease-in;\\n  animation-duration: 0.3s;\\n}\\n\\n.Toastify__slide-exit--top-center {\\n  animation-name: Toastify__slideOutUp;\\n  animation-timing-function: ease-in;\\n  animation-duration: 0.3s;\\n}\\n\\n.Toastify__slide-exit--bottom-center {\\n  animation-name: Toastify__slideOutDown;\\n  animation-timing-function: ease-in;\\n  animation-duration: 0.3s;\\n}\\n\\n@keyframes Toastify__spin {\\n  from {\\n    transform: rotate(0deg);\\n  }\\n  to {\\n    transform: rotate(360deg);\\n  }\\n}\\n\"],\"sourceRoot\":\"\"}]);\n// Exports\n/* harmony default export */ __webpack_exports__[\"default\"] = (___CSS_LOADER_EXPORT___);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2J1aWxkL3dlYnBhY2svbG9hZGVycy9jc3MtbG9hZGVyL3NyYy9pbmRleC5qcz8/cnVsZVNldFsxXS5ydWxlc1s3XS5vbmVPZlsxMl0udXNlWzFdIS4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9idWlsZC93ZWJwYWNrL2xvYWRlcnMvcG9zdGNzcy1sb2FkZXIvc3JjL2luZGV4LmpzPz9ydWxlU2V0WzFdLnJ1bGVzWzddLm9uZU9mWzEyXS51c2VbMl0hLi9ub2RlX21vZHVsZXMvcmVhY3QtdG9hc3RpZnkvZGlzdC9SZWFjdFRvYXN0aWZ5LmNzcyIsIm1hcHBpbmdzIjoiOzs7QUFBQTtBQUM4RztBQUM5Ryw4QkFBOEIscUdBQTJCO0FBQ3pEO0FBQ0EsaURBQWlELGlDQUFpQyxtQ0FBbUMsbUNBQW1DLHNDQUFzQyxzQ0FBc0MsNkNBQTZDLDJEQUEyRCw2REFBNkQsaUVBQWlFLGlFQUFpRSw2REFBNkQsOENBQThDLGtDQUFrQyxrQ0FBa0Msc0ZBQXNGLDBGQUEwRix3RkFBd0YsNEZBQTRGLHNDQUFzQyxtQ0FBbUMsc0NBQXNDLHVDQUF1QyxvQ0FBb0MsNkRBQTZELHVDQUF1Qyw2QkFBNkIseUNBQXlDLHFDQUFxQyw0RUFBNEUsd0NBQXdDLHdDQUF3QyxzQ0FBc0Msd0NBQXdDLGlEQUFpRCxxSEFBcUgsNENBQTRDLCtEQUErRCxxRUFBcUUscUVBQXFFLGlFQUFpRSxrR0FBa0csR0FBRyxnQ0FBZ0MscUNBQXFDLGtFQUFrRSxvQkFBb0IsMkNBQTJDLDJCQUEyQixnQkFBZ0Isa0JBQWtCLDJCQUEyQixHQUFHLDBDQUEwQyxtQ0FBbUMscUNBQXFDLEdBQUcsMENBQTBDLG1DQUFtQyxjQUFjLGdDQUFnQyx3QkFBd0IsR0FBRyx5Q0FBeUMsbUNBQW1DLHVDQUF1QyxxQkFBcUIsR0FBRywyQ0FBMkMseUNBQXlDLHFDQUFxQyxHQUFHLDZDQUE2Qyx5Q0FBeUMsY0FBYyxnQ0FBZ0Msd0JBQXdCLEdBQUcsNENBQTRDLHlDQUF5Qyx1Q0FB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QUFLLFFBQVEsZ0NBQWdDLEtBQUssR0FBRyxTQUFTLG1IQUFtSCxZQUFZLGFBQWEsYUFBYSxhQUFhLGFBQWEsYUFBYSxjQUFjLGFBQWEsYUFBYSxhQUFhLGNBQWMsYUFBYSxhQUFhLGFBQWEsYUFBYSxhQUFhLGFBQWEsYUFBYSxhQUFhLGFBQWEsYUFBYSxhQUFhLGFBQWEsYUFBYSxhQUFhLGFBQWEsYUFBYSxjQUFjLGFBQWEsYUFBYSxhQUFhLGFBQWEsY0FBYyxhQUFhLGFBQWEsYUFBYSxhQUFhLGFBQWEsYUFBYSxhQUFhLGFBQWEsYUFBYSxhQUFhLE9BQU8sS0FBSyxZQUFZLGFBQWEsV0FBVyxZQUFZLGFBQWEsV0FBVyxVQUFVLFlBQVksT0FBTyxLQUFLLFlBQVksYUFBYSxNQUFNLEtBQUssWUFBWSxXQUFXLFlBQVksYUFBYSxNQUFNLEtBQUssWUFBWSxhQUFhLGFBQWEsTUFBTSxLQUFLLFlBQVksYUFBYSxNQUFNLEtBQUssWUFBWSxXQUFXLFlBQVksYUFBYSxNQUFNLEtBQUssWUFBWSxhQUFhLGFBQWEsT0FBTyxLQUFLLFVBQVUsWUFBWSxhQUFhLGFBQWEsYUFBYSxhQUFhLGFBQWEsYUFBYSxhQUFhLGFBQWEsYUFBYSxhQUFhLGFBQWEsV0FBVyxVQUFVLFVBQVUsVUFBVSxZQUFZLGFBQWEsT0FBTyxLQUFLLEtBQUssVUFBVSxZQUFZLFdBQVcsS0FBSyxPQUFPLFlBQVksYUFBYSxNQUFNLE9BQU8sWUFBWSxhQUFhLE1BQU0sS0FBSyxZQUFZLFdBQVcsS0FBSyxLQUFLLFlBQVksYUFBYSxhQUFhLE1BQU0sTUFBTSxLQUFLLFlBQVksT0FBTyxLQUFLLFlBQVksV0FBVyxZQUFZLGFBQWEsT0FBTyxNQUFNLFlBQVksT0FBTyxLQUFLLFlBQVksT0FBTyxLQUFLLFVBQVUsTUFBTSxLQUFLLFVBQVUsWUFBWSxXQUFXLFVBQVUsWUFBWSxXQUFXLE1BQU0sS0FBSyxVQUFVLE1BQU0sS0FBSyxVQUFVLE1BQU0sS0FBSyxZQUFZLE9BQU8sS0FBSyxZQUFZLE9BQU8sS0FBSyxVQUFVLFlBQVksV0FBVyxVQUFVLFVBQVUsVUFBVSxZQUFZLFdBQVcsTUFBTSxLQUFLLFVBQVUsT0FBTyxLQUFLLFVBQVUsT0FBTyxLQUFLLFlBQVksV0FBVyxVQUFVLFVBQVUsTUFBTSxLQUFLLFlBQVksYUFBYSxPQUFPLEtBQUssWUFBWSxhQUFhLE9BQU8sS0FBSyxZQUFZLGFBQWEsT0FBTyxLQUFLLFlBQVksYUFBYSxPQUFPLEtBQUssWUFBWSxhQUFhLE9BQU8sS0FBSyxZQUFZLGFBQWEsT0FBTyxLQUFLLFlBQVksYUFBYSxPQUFPLEtBQUssWUFBWSxhQUFhLE9BQU8sS0FBSyxZQUFZLGFBQWEsT0FBTyxLQUFLLFlBQVksT0FBTyxLQUFLLFlBQVksT0FBTyxLQUFLLFlBQVksT0FBTyxLQUFLLFlBQVksT0FBTyxLQUFLLFlBQVksT0FBTyxLQUFLLFlBQVksT0FBTyxRQUFRLFlBQVksT0FBTyxLQUFLLFVBQVUsWUFBWSxXQUFXLFVBQVUsWUFBWSxXQUFXLFVBQVUsVUFBVSxVQUFVLFVBQVUsWUFBWSxXQUFXLE1BQU0sS0FBSyxVQUFVLFVBQVUsTUFBTSxLQUFLLFVBQVUsVUFBVSxNQUFNLEtBQUssWUFBWSxXQUFXLFVBQVUsTUFBTSxNQUFNLFVBQVUsTUFBTSxLQUFLLEtBQUssWUFBWSxNQUFNLEtBQUssWUFBWSxNQUFNLE1BQU0sS0FBSyxZQUFZLFdBQVcsVUFBVSxVQUFVLFVBQVUsVUFBVSxVQUFVLFlBQVksT0FBTyxLQUFLLFlBQVksT0FBTyxLQUFLLFlBQVksT0FBTyxLQUFLLFVBQVUsVUFBVSxZQUFZLGFBQWEsT0FBTyxLQUFLLFlBQVksYUFBYSxXQUFXLFVBQVUsVUFBVSxVQUFVLFlBQVksYUFBYSxPQUFPLEtBQUssVUFBVSxNQUFNLEtBQUssWUFBWSxXQUFXLFVBQVUsTUFBTSxLQUFLLFVBQVUsVUFBVSxZQUFZLGFBQWEsYUFBYSxhQUFhLGFBQWEsYUFBYSxPQUFPLEtBQUssU0FBUyxZQUFZLE1BQU0sS0FBSyxVQUFVLFlBQVksTUFBTSxLQUFLLFVBQVUsWUFBWSxNQUFNLEtBQUssWUFBWSxNQUFNLEtBQUssWUFBWSxNQUFNLEtBQUssVUFBVSxNQUFNLE1BQU0sS0FBSyxLQUFLLFVBQVUsWUFBWSxNQUFNLEtBQUssVUFBVSxZQUFZLE1BQU0sTUFBTSxLQUFLLFNBQVMsWUFBWSxNQUFNLEtBQUssVUFBVSxZQUFZLE1BQU0sS0FBSyxVQUFVLFlBQVksTUFBTSxLQUFLLFlBQVksTUFBTSxLQUFLLFlBQVksTUFBTSxLQUFLLFVBQVUsTUFBTSxNQUFNLEtBQUssS0FBSyxVQUFVLFlBQVksTUFBTSxLQUFLLFVBQVUsWUFBWSxNQUFNLE1BQU0sS0FBSyxTQUFTLFlBQVksTUFBTSxLQUFLLFVBQVUsWUFBWSxNQUFNLEtBQUssVUFBVSxZQUFZLE1BQU0sS0FBSyxZQUFZLE1BQU0sS0FBSyxZQUFZLE1BQU0sS0FBSyxZQUFZLE1BQU0sTUFBTSxLQUFLLEtBQUssWUFBWSxNQUFNLE1BQU0sVUFBVSxZQUFZLE1BQU0sS0FBSyxVQUFVLFlBQVksTUFBTSxNQUFNLEtBQUssU0FBUyxZQUFZLE1BQU0sS0FBSyxVQUFVLFlBQVksTUFBTSxLQUFLLFVBQVUsWUFBWSxNQUFNLEtBQUssWUFBWSxNQUFNLEtBQUssWUFBWSxNQUFNLEtBQUssVUFBVSxNQUFNLE1BQU0sS0FBSyxLQUFLLFlBQVksTUFBTSxNQUFNLFVBQVUsWUFBWSxNQUFNLEtBQUssVUFBVSxZQUFZLE1BQU0sTUFBTSxNQUFNLFlBQVksT0FBTyxNQUFNLFlBQVksT0FBTyxLQUFLLFlBQVksT0FBTyxLQUFLLFlBQVksT0FBTyxNQUFNLFlBQVksT0FBTyxNQUFNLFlBQVksT0FBTyxLQUFLLFlBQVksT0FBTyxLQUFLLFlBQVksT0FBTyxLQUFLLEtBQUssVUFBVSxZQUFZLE1BQU0sS0FBSyxVQUFVLEtBQUssTUFBTSxLQUFLLEtBQUssVUFBVSxLQUFLLEtBQUssVUFBVSxZQUFZLE1BQU0sS0FBSyxVQUFVLEtBQUssTUFBTSxLQUFLLFlBQVksT0FBTyxLQUFLLFlBQVksT0FBTyxLQUFLLEtBQUssWUFBWSxhQUFhLFdBQVcsS0FBSyxLQUFLLFlBQVksYUFBYSxNQUFNLEtBQUssWUFBWSxXQUFXLEtB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dUNBQXVDLFVBQVUsNkNBQTZDLEtBQUssUUFBUSx5QkFBeUIsMENBQTBDLEtBQUssR0FBRyxxQ0FBcUMsVUFBVSw2Q0FBNkMsS0FBSyxRQUFRLHlCQUF5QiwyQ0FBMkMsS0FBSyxHQUFHLDRFQUE0RSwwQ0FBMEMsR0FBRyw4RUFBOEUsMkNBQTJDLEdBQUcsd0NBQXdDLDBDQUEwQyxHQUFHLDJDQUEyQyx3Q0FBd0MsR0FBRywwRUFBMEUsMkNBQTJDLHVDQUF1Qyw2QkFBNkIsR0FBRyw0RUFBNEUsNENBQTRDLHVDQUF1Qyw2QkFBNkIsR0FBRyx1Q0FBdUMseUNBQXlDLHVDQUF1Qyw2QkFBNkIsR0FBRywwQ0FBMEMsMkNBQTJDLHVDQUF1Qyw2QkFBNkIsR0FBRywrQkFBK0IsVUFBVSw4QkFBOEIsS0FBSyxRQUFRLGdDQUFnQyxLQUFLLEdBQUcscUJBQXFCO0FBQzl4eUM7QUFDQSwrREFBZSx1QkFBdUIsRUFBQyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvcmVhY3QtdG9hc3RpZnkvZGlzdC9SZWFjdFRvYXN0aWZ5LmNzcz8xZTg0Il0sInNvdXJjZXNDb250ZW50IjpbIi8vIEltcG9ydHNcbmltcG9ydCBfX19DU1NfTE9BREVSX0FQSV9JTVBPUlRfX18gZnJvbSBcIi4uLy4uL25leHQvZGlzdC9idWlsZC93ZWJwYWNrL2xvYWRlcnMvY3NzLWxvYWRlci9zcmMvcnVudGltZS9hcGkuanNcIjtcbnZhciBfX19DU1NfTE9BREVSX0VYUE9SVF9fXyA9IF9fX0NTU19MT0FERVJfQVBJX0lNUE9SVF9fXyh0cnVlKTtcbi8vIE1vZHVsZVxuX19fQ1NTX0xPQURFUl9FWFBPUlRfX18ucHVzaChbbW9kdWxlLmlkLCBcIjpyb290IHtcXG4gIC0tdG9hc3RpZnktY29sb3ItbGlnaHQ6ICNmZmY7XFxuICAtLXRvYXN0aWZ5LWNvbG9yLWRhcms6ICMxMjEyMTI7XFxuICAtLXRvYXN0aWZ5LWNvbG9yLWluZm86ICMzNDk4ZGI7XFxuICAtLXRvYXN0aWZ5LWNvbG9yLXN1Y2Nlc3M6ICMwN2JjMGM7XFxuICAtLXRvYXN0aWZ5LWNvbG9yLXdhcm5pbmc6ICNmMWM0MGY7XFxuICAtLXRvYXN0aWZ5LWNvbG9yLWVycm9yOiBoc2woNiwgNzglLCA1NyUpO1xcbiAgLS10b2FzdGlmeS1jb2xvci10cmFuc3BhcmVudDogcmdiYSgyNTUsIDI1NSwgMjU1LCAwLjcpO1xcblxcbiAgLS10b2FzdGlmeS1pY29uLWNvbG9yLWluZm86IHZhcigtLXRvYXN0aWZ5LWNvbG9yLWluZm8pO1xcbiAgLS10b2FzdGlmeS1pY29uLWNvbG9yLXN1Y2Nlc3M6IHZhcigtLXRvYXN0aWZ5LWNvbG9yLXN1Y2Nlc3MpO1xcbiAgLS10b2FzdGlmeS1pY29uLWNvbG9yLXdhcm5pbmc6IHZhcigtLXRvYXN0aWZ5LWNvbG9yLXdhcm5pbmcpO1xcbiAgLS10b2FzdGlmeS1pY29uLWNvbG9yLWVycm9yOiB2YXIoLS10b2FzdGlmeS1jb2xvci1lcnJvcik7XFxuXFxuICAtLXRvYXN0aWZ5LWNvbnRhaW5lci13aWR0aDogZml0LWNvbnRlbnQ7XFxuICAtLXRvYXN0aWZ5LXRvYXN0LXdpZHRoOiAzMjBweDtcXG4gIC0tdG9hc3RpZnktdG9hc3Qtb2Zmc2V0OiAxNnB4O1xcbiAgLS10b2FzdGlmeS10b2FzdC10b3A6IG1heCh2YXIoLS10b2FzdGlmeS10b2FzdC1vZmZzZXQpLCBlbnYoc2FmZS1hcmVhLWluc2V0LXRvcCkpO1xcbiAgLS10b2FzdGlmeS10b2FzdC1yaWdodDogbWF4KHZhcigtLXRvYXN0aWZ5LXRvYXN0LW9mZnNldCksIGVudihzYWZlLWFyZWEtaW5zZXQtcmlnaHQpKTtcXG4gIC0tdG9hc3RpZnktdG9hc3QtbGVmdDogbWF4KHZhcigtLXRvYXN0aWZ5LXRvYXN0LW9mZnNldCksIGVudihzYWZlLWFyZWEtaW5zZXQtbGVmdCkpO1xcbiAgLS10b2FzdGlmeS10b2FzdC1ib3R0b206IG1heCh2YXIoLS10b2FzdGlmeS10b2FzdC1vZmZzZXQpLCBlbnYoc2FmZS1hcmVhLWluc2V0LWJvdHRvbSkpO1xcbiAgLS10b2FzdGlmeS10b2FzdC1iYWNrZ3JvdW5kOiAjZmZmO1xcbiAgLS10b2FzdGlmeS10b2FzdC1wYWRkaW5nOiAxNHB4O1xcbiAgLS10b2FzdGlmeS10b2FzdC1taW4taGVpZ2h0OiA2NHB4O1xcbiAgLS10b2FzdGlmeS10b2FzdC1tYXgtaGVpZ2h0OiA4MDBweDtcXG4gIC0tdG9hc3RpZnktdG9hc3QtYmQtcmFkaXVzOiA2cHg7XFxuICAtLXRvYXN0aWZ5LXRvYXN0LXNoYWRvdzogMHB4IDRweCAxMnB4IHJnYmEoMCwgMCwgMCwgMC4xKTtcXG4gIC0tdG9hc3RpZnktZm9udC1mYW1pbHk6IHNhbnMtc2VyaWY7XFxuICAtLXRvYXN0aWZ5LXotaW5kZXg6IDk5OTk7XFxuICAtLXRvYXN0aWZ5LXRleHQtY29sb3ItbGlnaHQ6ICM3NTc1NzU7XFxuICAtLXRvYXN0aWZ5LXRleHQtY29sb3ItZGFyazogI2ZmZjtcXG5cXG4gIC8qIFVzZWQgb25seSBmb3IgY29sb3JlZCB0aGVtZSAqL1xcbiAgLS10b2FzdGlmeS10ZXh0LWNvbG9yLWluZm86ICNmZmY7XFxuICAtLXRvYXN0aWZ5LXRleHQtY29sb3Itc3VjY2VzczogI2ZmZjtcXG4gIC0tdG9hc3RpZnktdGV4dC1jb2xvci13YXJuaW5nOiAjZmZmO1xcbiAgLS10b2FzdGlmeS10ZXh0LWNvbG9yLWVycm9yOiAjZmZmO1xcblxcbiAgLS10b2FzdGlmeS1zcGlubmVyLWNvbG9yOiAjNjE2MTYxO1xcbiAgLS10b2FzdGlmeS1zcGlubmVyLWNvbG9yLWVtcHR5LWFyZWE6ICNlMGUwZTA7XFxuICAtLXRvYXN0aWZ5LWNvbG9yLXByb2dyZXNzLWxpZ2h0OiBsaW5lYXItZ3JhZGllbnQodG8gcmlnaHQsICM0Y2Q5NjQsICM1YWM4ZmEsICMwMDdhZmYsICMzNGFhZGMsICM1ODU2ZDYsICNmZjJkNTUpO1xcbiAgLS10b2FzdGlmeS1jb2xvci1wcm9ncmVzcy1kYXJrOiAjYmI4NmZjO1xcbiAgLS10b2FzdGlmeS1jb2xvci1wcm9ncmVzcy1pbmZvOiB2YXIoLS10b2FzdGlmeS1jb2xvci1pbmZvKTtcXG4gIC0tdG9hc3RpZnktY29sb3ItcHJvZ3Jlc3Mtc3VjY2VzczogdmFyKC0tdG9hc3RpZnktY29sb3Itc3VjY2Vzcyk7XFxuICAtLXRvYXN0aWZ5LWNvbG9yLXByb2dyZXNzLXdhcm5pbmc6IHZhcigtLXRvYXN0aWZ5LWNvbG9yLXdhcm5pbmcpO1xcbiAgLS10b2FzdGlmeS1jb2xvci1wcm9ncmVzcy1lcnJvcjogdmFyKC0tdG9hc3RpZnktY29sb3ItZXJyb3IpO1xcbiAgLyogdXNlZCB0byBjb250cm9sIHRoZSBvcGFjaXR5IG9mIHRoZSBwcm9ncmVzcyB0cmFpbCAqL1xcbiAgLS10b2FzdGlmeS1jb2xvci1wcm9ncmVzcy1iZ286IDAuMjtcXG59XFxuXFxuLlRvYXN0aWZ5X190b2FzdC1jb250YWluZXIge1xcbiAgei1pbmRleDogdmFyKC0tdG9hc3RpZnktei1pbmRleCk7XFxuICAtd2Via2l0LXRyYW5zZm9ybTogdHJhbnNsYXRlM2QoMCwgMCwgdmFyKC0tdG9hc3RpZnktei1pbmRleCkpO1xcbiAgcG9zaXRpb246IGZpeGVkO1xcbiAgd2lkdGg6IHZhcigtLXRvYXN0aWZ5LWNvbnRhaW5lci13aWR0aCk7XFxuICBib3gtc2l6aW5nOiBib3JkZXItYm94O1xcbiAgY29sb3I6ICNmZmY7XFxuICBkaXNwbGF5OiBmbGV4O1xcbiAgZmxleC1kaXJlY3Rpb246IGNvbHVtbjtcXG59XFxuXFxuLlRvYXN0aWZ5X190b2FzdC1jb250YWluZXItLXRvcC1sZWZ0IHtcXG4gIHRvcDogdmFyKC0tdG9hc3RpZnktdG9hc3QtdG9wKTtcXG4gIGxlZnQ6IHZhcigtLXRvYXN0aWZ5LXRvYXN0LWxlZnQpO1xcbn1cXG4uVG9hc3RpZnlfX3RvYXN0LWNvbnRhaW5lci0tdG9wLWNlbnRlciB7XFxuICB0b3A6IHZhcigtLXRvYXN0aWZ5LXRvYXN0LXRvcCk7XFxuICBsZWZ0OiA1MCU7XFxuICB0cmFuc2Zvcm06IHRyYW5zbGF0ZVgoLTUwJSk7XFxuICBhbGlnbi1pdGVtczogY2VudGVyO1xcbn1cXG4uVG9hc3RpZnlfX3RvYXN0LWNvbnRhaW5lci0tdG9wLXJpZ2h0IHtcXG4gIHRvcDogdmFyKC0tdG9hc3RpZnktdG9hc3QtdG9wKTtcXG4gIHJpZ2h0OiB2YXIoLS10b2FzdGlmeS10b2FzdC1yaWdodCk7XFxuICBhbGlnbi1pdGVtczogZW5kO1xcbn1cXG4uVG9hc3RpZnlfX3RvYXN0LWNvbnRhaW5lci0tYm90dG9tLWxlZnQge1xcbiAgYm90dG9tOiB2YXIoLS10b2FzdGlmeS10b2FzdC1ib3R0b20pO1xcbiAgbGVmdDogdmFyKC0tdG9hc3RpZnktdG9hc3QtbGVmdCk7XFxufVxcbi5Ub2FzdGlmeV9fdG9hc3QtY29udGFpbmVyLS1ib3R0b20tY2VudGVyIHtcXG4gIGJvdHRvbTogdmFyKC0tdG9hc3RpZnktdG9hc3QtYm90dG9tKTtcXG4gIGxlZnQ6IDUwJTtcXG4gIHRyYW5zZm9ybTogdHJhbnNsYXRlWCgtNTAlKTtcXG4gIGFsaWduLWl0ZW1zOiBjZW50ZXI7XFxufVxcbi5Ub2FzdGlmeV9fdG9hc3QtY29udGFpbmVyLS1ib3R0b20tcmlnaHQge1xcbiAgYm90dG9tOiB2YXIoLS10b2FzdGlmeS10b2FzdC1ib3R0b20pO1xcbiAgcmlnaHQ6IHZhcigtLXRvYXN0aWZ5LXRvYXN0LXJpZ2h0KTtcXG4gIGFsaWduLWl0ZW1zOiBlbmQ7XFxufVxcblxcbi5Ub2FzdGlmeV9fdG9hc3Qge1xcbiAgLS15OiAwO1xcbiAgcG9zaXRpb246IHJlbGF0aXZlO1xcbiAgdG91Y2gtYWN0aW9uOiBub25lO1xcbiAgd2lkdGg6IHZhcigtLXRvYXN0aWZ5LXRvYXN0LXdpZHRoKTtcXG4gIG1pbi1oZWlnaHQ6IHZhcigtLXRvYXN0aWZ5LXRvYXN0LW1pbi1oZWlnaHQpO1xcbiAgYm94LXNpemluZzogYm9yZGVyLWJveDtcXG4gIG1hcmdpbi1ib3R0b206IDFyZW07XFxuICBwYWRkaW5nOiB2YXIoLS10b2FzdGlmeS10b2FzdC1wYWRkaW5nKTtcXG4gIGJvcmRlci1yYWRpdXM6IHZhcigtLXRvYXN0aWZ5LXRvYXN0LWJkLXJhZGl1cyk7XFxuICBib3gtc2hhZG93OiB2YXIoLS10b2FzdGlmeS10b2FzdC1zaGFkb3cpO1xcbiAgbWF4LWhlaWdodDogdmFyKC0tdG9hc3RpZnktdG9hc3QtbWF4LWhlaWdodCk7XFxuICBmb250LWZhbWlseTogdmFyKC0tdG9hc3RpZnktZm9udC1mYW1pbHkpO1xcbiAgLyogd2Via2l0IG9ubHkgaXNzdWUgIzc5MSAqL1xcbiAgei1pbmRleDogMDtcXG4gIC8qIGlubmVyIHN3YWcgKi9cXG4gIGRpc3BsYXk6IGZsZXg7XFxuICBmbGV4OiAxIGF1dG87XFxuICBhbGlnbi1pdGVtczogY2VudGVyO1xcbiAgd29yZC1icmVhazogYnJlYWstd29yZDtcXG59XFxuXFxuQG1lZGlhIG9ubHkgc2NyZWVuIGFuZCAobWF4LXdpZHRoOiA0ODBweCkge1xcbiAgLlRvYXN0aWZ5X190b2FzdC1jb250YWluZXIge1xcbiAgICB3aWR0aDogMTAwdnc7XFxuICAgIGxlZnQ6IGVudihzYWZlLWFyZWEtaW5zZXQtbGVmdCk7XFxuICAgIG1hcmdpbjogMDtcXG4gIH1cXG4gIC5Ub2FzdGlmeV9fdG9hc3QtY29udGFpbmVyLS10b3AtbGVmdCxcXG4gIC5Ub2FzdGlmeV9fdG9hc3QtY29udGFpbmVyLS10b3AtY2VudGVyLFxcbiAgLlRvYXN0aWZ5X190b2FzdC1jb250YWluZXItLXRvcC1yaWdodCB7XFxuICAgIHRvcDogZW52KHNhZmUtYXJlYS1pbnNldC10b3ApO1xcbiAgICB0cmFuc2Zvcm06IHRyYW5zbGF0ZVgoMCk7XFxuICB9XFxuICAuVG9hc3RpZnlfX3RvYXN0LWNvbnRhaW5lci0tYm90dG9tLWxlZnQsXFxuICAuVG9hc3RpZnlfX3RvYXN0LWNvbnRhaW5lci0tYm90dG9tLWNlbnRlcixcXG4gIC5Ub2FzdGlmeV9fdG9hc3QtY29udGFpbmVyLS1ib3R0b20tcmlnaHQge1xcbiAgICBib3R0b206IGVudihzYWZlLWFyZWEtaW5zZXQtYm90dG9tKTtcXG4gICAgdHJhbnNmb3JtOiB0cmFuc2xhdGVYKDApO1xcbiAgfVxcbiAgLlRvYXN0aWZ5X190b2FzdC1jb250YWluZXItLXJ0bCB7XFxuICAgIHJpZ2h0OiBlbnYoc2FmZS1hcmVhLWluc2V0LXJpZ2h0KTtcXG4gICAgbGVmdDogaW5pdGlhbDtcXG4gIH1cXG4gIC5Ub2FzdGlmeV9fdG9hc3Qge1xcbiAgICAtLXRvYXN0aWZ5LXRvYXN0LXdpZHRoOiAxMDAlO1xcbiAgICBtYXJnaW4tYm90dG9tOiAwO1xcbiAgICBib3JkZXItcmFkaXVzOiAwO1xcbiAgfVxcbn1cXG5cXG4uVG9hc3RpZnlfX3RvYXN0LWNvbnRhaW5lcltkYXRhLXN0YWNrZWQ9J3RydWUnXSB7XFxuICB3aWR0aDogdmFyKC0tdG9hc3RpZnktdG9hc3Qtd2lkdGgpO1xcbn1cXG5cXG4uVG9hc3RpZnlfX3RvYXN0LS1zdGFja2VkIHtcXG4gIHBvc2l0aW9uOiBhYnNvbHV0ZTtcXG4gIHdpZHRoOiAxMDAlO1xcbiAgdHJhbnNmb3JtOiB0cmFuc2xhdGUzZCgwLCB2YXIoLS15KSwgMCkgc2NhbGUodmFyKC0tcykpO1xcbiAgdHJhbnNpdGlvbjogdHJhbnNmb3JtIDAuM3M7XFxufVxcblxcbi5Ub2FzdGlmeV9fdG9hc3QtLXN0YWNrZWRbZGF0YS1jb2xsYXBzZWRdIC5Ub2FzdGlmeV9fdG9hc3QtYm9keSxcXG4uVG9hc3RpZnlfX3RvYXN0LS1zdGFja2VkW2RhdGEtY29sbGFwc2VkXSAuVG9hc3RpZnlfX2Nsb3NlLWJ1dHRvbiB7XFxuICB0cmFuc2l0aW9uOiBvcGFjaXR5IDAuMXM7XFxufVxcblxcbi5Ub2FzdGlmeV9fdG9hc3QtLXN0YWNrZWRbZGF0YS1jb2xsYXBzZWQ9J2ZhbHNlJ10ge1xcbiAgb3ZlcmZsb3c6IHZpc2libGU7XFxufVxcblxcbi5Ub2FzdGlmeV9fdG9hc3QtLXN0YWNrZWRbZGF0YS1jb2xsYXBzZWQ9J3RydWUnXTpub3QoOmxhc3QtY2hpbGQpID4gKiB7XFxuICBvcGFjaXR5OiAwO1xcbn1cXG5cXG4uVG9hc3RpZnlfX3RvYXN0LS1zdGFja2VkOmFmdGVyIHtcXG4gIGNvbnRlbnQ6ICcnO1xcbiAgcG9zaXRpb246IGFic29sdXRlO1xcbiAgbGVmdDogMDtcXG4gIHJpZ2h0OiAwO1xcbiAgaGVpZ2h0OiBjYWxjKHZhcigtLWcpICogMXB4KTtcXG4gIGJvdHRvbTogMTAwJTtcXG59XFxuXFxuLlRvYXN0aWZ5X190b2FzdC0tc3RhY2tlZFtkYXRhLXBvcz0ndG9wJ10ge1xcbiAgdG9wOiAwO1xcbn1cXG5cXG4uVG9hc3RpZnlfX3RvYXN0LS1zdGFja2VkW2RhdGEtcG9zPSdib3QnXSB7XFxuICBib3R0b206IDA7XFxufVxcblxcbi5Ub2FzdGlmeV9fdG9hc3QtLXN0YWNrZWRbZGF0YS1wb3M9J2JvdCddLlRvYXN0aWZ5X190b2FzdC0tc3RhY2tlZDpiZWZvcmUge1xcbiAgdHJhbnNmb3JtLW9yaWdpbjogdG9wO1xcbn1cXG5cXG4uVG9hc3RpZnlfX3RvYXN0LS1zdGFja2VkW2RhdGEtcG9zPSd0b3AnXS5Ub2FzdGlmeV9fdG9hc3QtLXN0YWNrZWQ6YmVmb3JlIHtcXG4gIHRyYW5zZm9ybS1vcmlnaW46IGJvdHRvbTtcXG59XFxuXFxuLlRvYXN0aWZ5X190b2FzdC0tc3RhY2tlZDpiZWZvcmUge1xcbiAgY29udGVudDogJyc7XFxuICBwb3NpdGlvbjogYWJzb2x1dGU7XFxuICBsZWZ0OiAwO1xcbiAgcmlnaHQ6IDA7XFxuICBib3R0b206IDA7XFxuICBoZWlnaHQ6IDEwMCU7XFxuICB0cmFuc2Zvcm06IHNjYWxlWSgzKTtcXG4gIHotaW5kZXg6IC0xO1xcbn1cXG5cXG4uVG9hc3RpZnlfX3RvYXN0LS1ydGwge1xcbiAgZGlyZWN0aW9uOiBydGw7XFxufVxcblxcbi5Ub2FzdGlmeV9fdG9hc3QtLWNsb3NlLW9uLWNsaWNrIHtcXG4gIGN1cnNvcjogcG9pbnRlcjtcXG59XFxuXFxuLlRvYXN0aWZ5X190b2FzdC1pY29uIHtcXG4gIG1hcmdpbi1pbmxpbmUtZW5kOiAxMHB4O1xcbiAgd2lkdGg6IDIycHg7XFxuICBmbGV4LXNocmluazogMDtcXG4gIGRpc3BsYXk6IGZsZXg7XFxufVxcblxcbi5Ub2FzdGlmeS0tYW5pbWF0ZSB7XFxuICBhbmltYXRpb24tZmlsbC1tb2RlOiBib3RoO1xcbiAgYW5pbWF0aW9uLWR1cmF0aW9uOiAwLjVzO1xcbn1cXG5cXG4uVG9hc3RpZnktLWFuaW1hdGUtaWNvbiB7XFxuICBhbmltYXRpb24tZmlsbC1tb2RlOiBib3RoO1xcbiAgYW5pbWF0aW9uLWR1cmF0aW9uOiAwLjNzO1xcbn1cXG5cXG4uVG9hc3RpZnlfX3RvYXN0LXRoZW1lLS1kYXJrIHtcXG4gIGJhY2tncm91bmQ6IHZhcigtLXRvYXN0aWZ5LWNvbG9yLWRhcmspO1xcbiAgY29sb3I6IHZhcigtLXRvYXN0aWZ5LXRleHQtY29sb3ItZGFyayk7XFxufVxcblxcbi5Ub2FzdGlmeV9fdG9hc3QtdGhlbWUtLWxpZ2h0IHtcXG4gIGJhY2tncm91bmQ6IHZhcigtLXRvYXN0aWZ5LWNvbG9yLWxpZ2h0KTtcXG4gIGNvbG9yOiB2YXIoLS10b2FzdGlmeS10ZXh0LWNvbG9yLWxpZ2h0KTtcXG59XFxuXFxuLlRvYXN0aWZ5X190b2FzdC10aGVtZS0tY29sb3JlZC5Ub2FzdGlmeV9fdG9hc3QtLWRlZmF1bHQge1xcbiAgYmFja2dyb3VuZDogdmFyKC0tdG9hc3RpZnktY29sb3ItbGlnaHQpO1xcbiAgY29sb3I6IHZhcigtLXRvYXN0aWZ5LXRleHQtY29sb3ItbGlnaHQpO1xcbn1cXG5cXG4uVG9hc3RpZnlfX3RvYXN0LXRoZW1lLS1jb2xvcmVkLlRvYXN0aWZ5X190b2FzdC0taW5mbyB7XFxuICBjb2xvcjogdmFyKC0tdG9hc3RpZnktdGV4dC1jb2xvci1pbmZvKTtcXG4gIGJhY2tncm91bmQ6IHZhcigtLXRvYXN0aWZ5LWNvbG9yLWluZm8pO1xcbn1cXG5cXG4uVG9hc3RpZnlfX3RvYXN0LXRoZW1lLS1jb2xvcmVkLlRvYXN0aWZ5X190b2FzdC0tc3VjY2VzcyB7XFxuICBjb2xvcjogdmFyKC0tdG9hc3RpZnktdGV4dC1jb2xvci1zdWNjZXNzKTtcXG4gIGJhY2tncm91bmQ6IHZhcigtLXRvYXN0aWZ5LWNvbG9yLXN1Y2Nlc3MpO1xcbn1cXG5cXG4uVG9hc3RpZnlfX3RvYXN0LXRoZW1lLS1jb2xvcmVkLlRvYXN0aWZ5X190b2FzdC0td2FybmluZyB7XFxuICBjb2xvcjogdmFyKC0tdG9hc3RpZnktdGV4dC1jb2xvci13YXJuaW5nKTtcXG4gIGJhY2tncm91bmQ6IHZhcigtLXRvYXN0aWZ5LWNvbG9yLXdhcm5pbmcpO1xcbn1cXG5cXG4uVG9hc3RpZnlfX3RvYXN0LXRoZW1lLS1jb2xvcmVkLlRvYXN0aWZ5X190b2FzdC0tZXJyb3Ige1xcbiAgY29sb3I6IHZhcigtLXRvYXN0aWZ5LXRleHQtY29sb3ItZXJyb3IpO1xcbiAgYmFja2dyb3VuZDogdmFyKC0tdG9hc3RpZnktY29sb3ItZXJyb3IpO1xcbn1cXG5cXG4uVG9hc3RpZnlfX3Byb2dyZXNzLWJhci10aGVtZS0tbGlnaHQge1xcbiAgYmFja2dyb3VuZDogdmFyKC0tdG9hc3RpZnktY29sb3ItcHJvZ3Jlc3MtbGlnaHQpO1xcbn1cXG5cXG4uVG9hc3RpZnlfX3Byb2dyZXNzLWJhci10aGVtZS0tZGFyayB7XFxuICBiYWNrZ3JvdW5kOiB2YXIoLS10b2FzdGlmeS1jb2xvci1wcm9ncmVzcy1kYXJrKTtcXG59XFxuXFxuLlRvYXN0aWZ5X19wcm9ncmVzcy1iYXItLWluZm8ge1xcbiAgYmFja2dyb3VuZDogdmFyKC0tdG9hc3RpZnktY29sb3ItcHJvZ3Jlc3MtaW5mbyk7XFxufVxcblxcbi5Ub2FzdGlmeV9fcHJvZ3Jlc3MtYmFyLS1zdWNjZXNzIHtcXG4gIGJhY2tncm91bmQ6IHZhcigtLXRvYXN0aWZ5LWNvbG9yLXByb2dyZXNzLXN1Y2Nlc3MpO1xcbn1cXG5cXG4uVG9hc3RpZnlfX3Byb2dyZXNzLWJhci0td2FybmluZyB7XFxuICBiYWNrZ3JvdW5kOiB2YXIoLS10b2FzdGlmeS1jb2xvci1wcm9ncmVzcy13YXJuaW5nKTtcXG59XFxuXFxuLlRvYXN0aWZ5X19wcm9ncmVzcy1iYXItLWVycm9yIHtcXG4gIGJhY2tncm91bmQ6IHZhcigtLXRvYXN0aWZ5LWNvbG9yLXByb2dyZXNzLWVycm9yKTtcXG59XFxuXFxuLlRvYXN0aWZ5X19wcm9ncmVzcy1iYXItdGhlbWUtLWNvbG9yZWQuVG9hc3RpZnlfX3Byb2dyZXNzLWJhci0taW5mbyxcXG4uVG9hc3RpZnlfX3Byb2dyZXNzLWJhci10aGVtZS0tY29sb3JlZC5Ub2FzdGlmeV9fcHJvZ3Jlc3MtYmFyLS1zdWNjZXNzLFxcbi5Ub2FzdGlmeV9fcHJvZ3Jlc3MtYmFyLXRoZW1lLS1jb2xvcmVkLlRvYXN0aWZ5X19wcm9ncmVzcy1iYXItLXdhcm5pbmcsXFxuLlRvYXN0aWZ5X19wcm9ncmVzcy1iYXItdGhlbWUtLWNvbG9yZWQuVG9hc3RpZnlfX3Byb2dyZXNzLWJhci0tZXJyb3Ige1xcbiAgYmFja2dyb3VuZDogdmFyKC0tdG9hc3RpZnktY29sb3ItdHJhbnNwYXJlbnQpO1xcbn1cXG5cXG4uVG9hc3RpZnlfX2Nsb3NlLWJ1dHRvbiB7XFxuICBjb2xvcjogI2ZmZjtcXG4gIHBvc2l0aW9uOiBhYnNvbHV0ZTtcXG4gIHRvcDogNnB4O1xcbiAgcmlnaHQ6IDZweDtcXG4gIGJhY2tncm91bmQ6IHRyYW5zcGFyZW50O1xcbiAgb3V0bGluZTogbm9uZTtcXG4gIGJvcmRlcjogbm9uZTtcXG4gIHBhZGRpbmc6IDA7XFxuICBjdXJzb3I6IHBvaW50ZXI7XFxuICBvcGFjaXR5OiAwLjc7XFxuICB0cmFuc2l0aW9uOiAwLjNzIGVhc2U7XFxuICB6LWluZGV4OiAxO1xcbn1cXG5cXG4uVG9hc3RpZnlfX3RvYXN0LS1ydGwgLlRvYXN0aWZ5X19jbG9zZS1idXR0b24ge1xcbiAgbGVmdDogNnB4O1xcbiAgcmlnaHQ6IHVuc2V0O1xcbn1cXG5cXG4uVG9hc3RpZnlfX2Nsb3NlLWJ1dHRvbi0tbGlnaHQge1xcbiAgY29sb3I6ICMwMDA7XFxuICBvcGFjaXR5OiAwLjM7XFxufVxcblxcbi5Ub2FzdGlmeV9fY2xvc2UtYnV0dG9uID4gc3ZnIHtcXG4gIGZpbGw6IGN1cnJlbnRDb2xvcjtcXG4gIGhlaWdodDogMTZweDtcXG4gIHdpZHRoOiAxNHB4O1xcbn1cXG5cXG4uVG9hc3RpZnlfX2Nsb3NlLWJ1dHRvbjpob3ZlcixcXG4uVG9hc3RpZnlfX2Nsb3NlLWJ1dHRvbjpmb2N1cyB7XFxuICBvcGFjaXR5OiAxO1xcbn1cXG5cXG5Aa2V5ZnJhbWVzIFRvYXN0aWZ5X190cmFja1Byb2dyZXNzIHtcXG4gIDAlIHtcXG4gICAgdHJhbnNmb3JtOiBzY2FsZVgoMSk7XFxuICB9XFxuICAxMDAlIHtcXG4gICAgdHJhbnNmb3JtOiBzY2FsZVgoMCk7XFxuICB9XFxufVxcblxcbi5Ub2FzdGlmeV9fcHJvZ3Jlc3MtYmFyIHtcXG4gIHBvc2l0aW9uOiBhYnNvbHV0ZTtcXG4gIGJvdHRvbTogMDtcXG4gIGxlZnQ6IDA7XFxuICB3aWR0aDogMTAwJTtcXG4gIGhlaWdodDogMTAwJTtcXG4gIHotaW5kZXg6IDE7XFxuICBvcGFjaXR5OiAwLjc7XFxuICB0cmFuc2Zvcm0tb3JpZ2luOiBsZWZ0O1xcbn1cXG5cXG4uVG9hc3RpZnlfX3Byb2dyZXNzLWJhci0tYW5pbWF0ZWQge1xcbiAgYW5pbWF0aW9uOiBUb2FzdGlmeV9fdHJhY2tQcm9ncmVzcyBsaW5lYXIgMSBmb3J3YXJkcztcXG59XFxuXFxuLlRvYXN0aWZ5X19wcm9ncmVzcy1iYXItLWNvbnRyb2xsZWQge1xcbiAgdHJhbnNpdGlvbjogdHJhbnNmb3JtIDAuMnM7XFxufVxcblxcbi5Ub2FzdGlmeV9fcHJvZ3Jlc3MtYmFyLS1ydGwge1xcbiAgcmlnaHQ6IDA7XFxuICBsZWZ0OiBpbml0aWFsO1xcbiAgdHJhbnNmb3JtLW9yaWdpbjogcmlnaHQ7XFxuICBib3JkZXItYm90dG9tLWxlZnQtcmFkaXVzOiBpbml0aWFsO1xcbn1cXG5cXG4uVG9hc3RpZnlfX3Byb2dyZXNzLWJhci0td3JwIHtcXG4gIHBvc2l0aW9uOiBhYnNvbHV0ZTtcXG4gIG92ZXJmbG93OiBoaWRkZW47XFxuICBib3R0b206IDA7XFxuICBsZWZ0OiAwO1xcbiAgd2lkdGg6IDEwMCU7XFxuICBoZWlnaHQ6IDVweDtcXG4gIGJvcmRlci1ib3R0b20tbGVmdC1yYWRpdXM6IHZhcigtLXRvYXN0aWZ5LXRvYXN0LWJkLXJhZGl1cyk7XFxuICBib3JkZXItYm90dG9tLXJpZ2h0LXJhZGl1czogdmFyKC0tdG9hc3RpZnktdG9hc3QtYmQtcmFkaXVzKTtcXG59XFxuXFxuLlRvYXN0aWZ5X19wcm9ncmVzcy1iYXItLXdycFtkYXRhLWhpZGRlbj0ndHJ1ZSddIHtcXG4gIG9wYWNpdHk6IDA7XFxufVxcblxcbi5Ub2FzdGlmeV9fcHJvZ3Jlc3MtYmFyLS1iZyB7XFxuICBvcGFjaXR5OiB2YXIoLS10b2FzdGlmeS1jb2xvci1wcm9ncmVzcy1iZ28pO1xcbiAgd2lkdGg6IDEwMCU7XFxuICBoZWlnaHQ6IDEwMCU7XFxufVxcblxcbi5Ub2FzdGlmeV9fc3Bpbm5lciB7XFxuICB3aWR0aDogMjBweDtcXG4gIGhlaWdodDogMjBweDtcXG4gIGJveC1zaXppbmc6IGJvcmRlci1ib3g7XFxuICBib3JkZXI6IDJweCBzb2xpZDtcXG4gIGJvcmRlci1yYWRpdXM6IDEwMCU7XFxuICBib3JkZXItY29sb3I6IHZhcigtLXRvYXN0aWZ5LXNwaW5uZXItY29sb3ItZW1wdHktYXJlYSk7XFxuICBib3JkZXItcmlnaHQtY29sb3I6IHZhcigtLXRvYXN0aWZ5LXNwaW5uZXItY29sb3IpO1xcbiAgYW5pbWF0aW9uOiBUb2FzdGlmeV9fc3BpbiAwLjY1cyBsaW5lYXIgaW5maW5pdGU7XFxufVxcblxcbkBrZXlmcmFtZXMgVG9hc3RpZnlfX2JvdW5jZUluUmlnaHQge1xcbiAgZnJvbSxcXG4gIDYwJSxcXG4gIDc1JSxcXG4gIDkwJSxcXG4gIHRvIHtcXG4gICAgYW5pbWF0aW9uLXRpbWluZy1mdW5jdGlvbjogY3ViaWMtYmV6aWVyKDAuMjE1LCAwLjYxLCAwLjM1NSwgMSk7XFxuICB9XFxuICBmcm9tIHtcXG4gICAgb3BhY2l0eTogMDtcXG4gICAgdHJhbnNmb3JtOiB0cmFuc2xhdGUzZCgzMDAwcHgsIDAsIDApO1xcbiAgfVxcbiAgNjAlIHtcXG4gICAgb3BhY2l0eTogMTtcXG4gICAgdHJhbnNmb3JtOiB0cmFuc2xhdGUzZCgtMjVweCwgMCwgMCk7XFxuICB9XFxuICA3NSUge1xcbiAgICB0cmFuc2Zvcm06IHRyYW5zbGF0ZTNkKDEwcHgsIDAsIDApO1xcbiAgfVxcbiAgOTAlIHtcXG4gICAgdHJhbnNmb3JtOiB0cmFuc2xhdGUzZCgtNXB4LCAwLCAwKTtcXG4gIH1cXG4gIHRvIHtcXG4gICAgdHJhbnNmb3JtOiBub25lO1xcbiAgfVxcbn1cXG5cXG5Aa2V5ZnJhbWVzIFRvYXN0aWZ5X19ib3VuY2VPdXRSaWdodCB7XFxuICAyMCUge1xcbiAgICBvcGFjaXR5OiAxO1xcbiAgICB0cmFuc2Zvcm06IHRyYW5zbGF0ZTNkKC0yMHB4LCB2YXIoLS15KSwgMCk7XFxuICB9XFxuICB0byB7XFxuICAgIG9wYWNpdHk6IDA7XFxuICAgIHRyYW5zZm9ybTogdHJhbnNsYXRlM2QoMjAwMHB4LCB2YXIoLS15KSwgMCk7XFxuICB9XFxufVxcblxcbkBrZXlmcmFtZXMgVG9hc3RpZnlfX2JvdW5jZUluTGVmdCB7XFxuICBmcm9tLFxcbiAgNjAlLFxcbiAgNzUlLFxcbiAgOTAlLFxcbiAgdG8ge1xcbiAgICBhbmltYXRpb24tdGltaW5nLWZ1bmN0aW9uOiBjdWJpYy1iZXppZXIoMC4yMTUsIDAuNjEsIDAuMzU1LCAxKTtcXG4gIH1cXG4gIDAlIHtcXG4gICAgb3BhY2l0eTogMDtcXG4gICAgdHJhbnNmb3JtOiB0cmFuc2xhdGUzZCgtMzAwMHB4LCAwLCAwKTtcXG4gIH1cXG4gIDYwJSB7XFxuICAgIG9wYWNpdHk6IDE7XFxuICAgIHRyYW5zZm9ybTogdHJhbnNsYXRlM2QoMjVweCwgMCwgMCk7XFxuICB9XFxuICA3NSUge1xcbiAgICB0cmFuc2Zvcm06IHRyYW5zbGF0ZTNkKC0xMHB4LCAwLCAwKTtcXG4gIH1cXG4gIDkwJSB7XFxuICAgIHRyYW5zZm9ybTogdHJhbnNsYXRlM2QoNXB4LCAwLCAwKTtcXG4gIH1cXG4gIHRvIHtcXG4gICAgdHJhbnNmb3JtOiBub25lO1xcbiAgfVxcbn1cXG5cXG5Aa2V5ZnJhbWVzIFRvYXN0aWZ5X19ib3VuY2VPdXRMZWZ0IHtcXG4gIDIwJSB7XFxuICAgIG9wYWNpdHk6IDE7XFxuICAgIHRyYW5zZm9ybTogdHJhbnNsYXRlM2QoMjBweCwgdmFyKC0teSksIDApO1xcbiAgfVxcbiAgdG8ge1xcbiAgICBvcGFjaXR5OiAwO1xcbiAgICB0cmFuc2Zvcm06IHRyYW5zbGF0ZTNkKC0yMDAwcHgsIHZhcigtLXkpLCAwKTtcXG4gIH1cXG59XFxuXFxuQGtleWZyYW1lcyBUb2FzdGlmeV9fYm91bmNlSW5VcCB7XFxuICBmcm9tLFxcbiAgNjAlLFxcbiAgNzUlLFxcbiAgOTAlLFxcbiAgdG8ge1xcbiAgICBhbmltYXRpb24tdGltaW5nLWZ1bmN0aW9uOiBjdWJpYy1iZXppZXIoMC4yMTUsIDAuNjEsIDAuMzU1LCAxKTtcXG4gIH1cXG4gIGZyb20ge1xcbiAgICBvcGFjaXR5OiAwO1xcbiAgICB0cmFuc2Zvcm06IHRyYW5zbGF0ZTNkKDAsIDMwMDBweCwgMCk7XFxuICB9XFxuICA2MCUge1xcbiAgICBvcGFjaXR5OiAxO1xcbiAgICB0cmFuc2Zvcm06IHRyYW5zbGF0ZTNkKDAsIC0yMHB4LCAwKTtcXG4gIH1cXG4gIDc1JSB7XFxuICAgIHRyYW5zZm9ybTogdHJhbnNsYXRlM2QoMCwgMTBweCwgMCk7XFxuICB9XFxuICA5MCUge1xcbiAgICB0cmFuc2Zvcm06IHRyYW5zbGF0ZTNkKDAsIC01cHgsIDApO1xcbiAgfVxcbiAgdG8ge1xcbiAgICB0cmFuc2Zvcm06IHRyYW5zbGF0ZTNkKDAsIDAsIDApO1xcbiAgfVxcbn1cXG5cXG5Aa2V5ZnJhbWVzIFRvYXN0aWZ5X19ib3VuY2VPdXRVcCB7XFxuICAyMCUge1xcbiAgICB0cmFuc2Zvcm06IHRyYW5zbGF0ZTNkKDAsIGNhbGModmFyKC0teSkgLSAxMHB4KSwgMCk7XFxuICB9XFxuICA0MCUsXFxuICA0NSUge1xcbiAgICBvcGFjaXR5OiAxO1xcbiAgICB0cmFuc2Zvcm06IHRyYW5zbGF0ZTNkKDAsIGNhbGModmFyKC0teSkgKyAyMHB4KSwgMCk7XFxuICB9XFxuICB0byB7XFxuICAgIG9wYWNpdHk6IDA7XFxuICAgIHRyYW5zZm9ybTogdHJhbnNsYXRlM2QoMCwgLTIwMDBweCwgMCk7XFxuICB9XFxufVxcblxcbkBrZXlmcmFtZXMgVG9hc3RpZnlfX2JvdW5jZUluRG93biB7XFxuICBmcm9tLFxcbiAgNjAlLFxcbiAgNzUlLFxcbiAgOTAlLFxcbiAgdG8ge1xcbiAgICBhbmltYXRpb24tdGltaW5nLWZ1bmN0aW9uOiBjdWJpYy1iZXppZXIoMC4yMTUsIDAuNjEsIDAuMzU1LCAxKTtcXG4gIH1cXG4gIDAlIHtcXG4gICAgb3BhY2l0eTogMDtcXG4gICAgdHJhbnNmb3JtOiB0cmFuc2xhdGUzZCgwLCAtMzAwMHB4LCAwKTtcXG4gIH1cXG4gIDYwJSB7XFxuICAgIG9wYWNpdHk6IDE7XFxuICAgIHRyYW5zZm9ybTogdHJhbnNsYXRlM2QoMCwgMjVweCwgMCk7XFxuICB9XFxuICA3NSUge1xcbiAgICB0cmFuc2Zvcm06IHRyYW5zbGF0ZTNkKDAsIC0xMHB4LCAwKTtcXG4gIH1cXG4gIDkwJSB7XFxuICAgIHRyYW5zZm9ybTogdHJhbnNsYXRlM2QoMCwgNXB4LCAwKTtcXG4gIH1cXG4gIHRvIHtcXG4gICAgdHJhbnNmb3JtOiBub25lO1xcbiAgfVxcbn1cXG5cXG5Aa2V5ZnJhbWVzIFRvYXN0aWZ5X19ib3VuY2VPdXREb3duIHtcXG4gIDIwJSB7XFxuICAgIHRyYW5zZm9ybTogdHJhbnNsYXRlM2QoMCwgY2FsYyh2YXIoLS15KSAtIDEwcHgpLCAwKTtcXG4gIH1cXG4gIDQwJSxcXG4gIDQ1JSB7XFxuICAgIG9wYWNpdHk6IDE7XFxuICAgIHRyYW5zZm9ybTogdHJhbnNsYXRlM2QoMCwgY2FsYyh2YXIoLS15KSArIDIwcHgpLCAwKTtcXG4gIH1cXG4gIHRvIHtcXG4gICAgb3BhY2l0eTogMDtcXG4gICAgdHJhbnNmb3JtOiB0cmFuc2xhdGUzZCgwLCAyMDAwcHgsIDApO1xcbiAgfVxcbn1cXG5cXG4uVG9hc3RpZnlfX2JvdW5jZS1lbnRlci0tdG9wLWxlZnQsXFxuLlRvYXN0aWZ5X19ib3VuY2UtZW50ZXItLWJvdHRvbS1sZWZ0IHtcXG4gIGFuaW1hdGlvbi1uYW1lOiBUb2FzdGlmeV9fYm91bmNlSW5MZWZ0O1xcbn1cXG5cXG4uVG9hc3RpZnlfX2JvdW5jZS1lbnRlci0tdG9wLXJpZ2h0LFxcbi5Ub2FzdGlmeV9fYm91bmNlLWVudGVyLS1ib3R0b20tcmlnaHQge1xcbiAgYW5pbWF0aW9uLW5hbWU6IFRvYXN0aWZ5X19ib3VuY2VJblJpZ2h0O1xcbn1cXG5cXG4uVG9hc3RpZnlfX2JvdW5jZS1lbnRlci0tdG9wLWNlbnRlciB7XFxuICBhbmltYXRpb24tbmFtZTogVG9hc3RpZnlfX2JvdW5jZUluRG93bjtcXG59XFxuXFxuLlRvYXN0aWZ5X19ib3VuY2UtZW50ZXItLWJvdHRvbS1jZW50ZXIge1xcbiAgYW5pbWF0aW9uLW5hbWU6IFRvYXN0aWZ5X19ib3VuY2VJblVwO1xcbn1cXG5cXG4uVG9hc3RpZnlfX2JvdW5jZS1leGl0LS10b3AtbGVmdCxcXG4uVG9hc3RpZnlfX2JvdW5jZS1leGl0LS1ib3R0b20tbGVmdCB7XFxuICBhbmltYXRpb24tbmFtZTogVG9hc3RpZnlfX2JvdW5jZU91dExlZnQ7XFxufVxcblxcbi5Ub2FzdGlmeV9fYm91bmNlLWV4aXQtLXRvcC1yaWdodCxcXG4uVG9hc3RpZnlfX2JvdW5jZS1leGl0LS1ib3R0b20tcmlnaHQge1xcbiAgYW5pbWF0aW9uLW5hbWU6IFRvYXN0aWZ5X19ib3VuY2VPdXRSaWdodDtcXG59XFxuXFxuLlRvYXN0aWZ5X19ib3VuY2UtZXhpdC0tdG9wLWNlbnRlciB7XFxuICBhbmltYXRpb24tbmFtZTogVG9hc3RpZnlfX2JvdW5jZU91dFVwO1xcbn1cXG5cXG4uVG9hc3RpZnlfX2JvdW5jZS1leGl0LS1ib3R0b20tY2VudGVyIHtcXG4gIGFuaW1hdGlvbi1uYW1lOiBUb2FzdGlmeV9fYm91bmNlT3V0RG93bjtcXG59XFxuXFxuQGtleWZyYW1lcyBUb2FzdGlmeV9fem9vbUluIHtcXG4gIGZyb20ge1xcbiAgICBvcGFjaXR5OiAwO1xcbiAgICB0cmFuc2Zvcm06IHNjYWxlM2QoMC4zLCAwLjMsIDAuMyk7XFxuICB9XFxuICA1MCUge1xcbiAgICBvcGFjaXR5OiAxO1xcbiAgfVxcbn1cXG5cXG5Aa2V5ZnJhbWVzIFRvYXN0aWZ5X196b29tT3V0IHtcXG4gIGZyb20ge1xcbiAgICBvcGFjaXR5OiAxO1xcbiAgfVxcbiAgNTAlIHtcXG4gICAgb3BhY2l0eTogMDtcXG4gICAgdHJhbnNmb3JtOiB0cmFuc2xhdGUzZCgwLCB2YXIoLS15KSwgMCkgc2NhbGUzZCgwLjMsIDAuMywgMC4zKTtcXG4gIH1cXG4gIHRvIHtcXG4gICAgb3BhY2l0eTogMDtcXG4gIH1cXG59XFxuXFxuLlRvYXN0aWZ5X196b29tLWVudGVyIHtcXG4gIGFuaW1hdGlvbi1uYW1lOiBUb2FzdGlmeV9fem9vbUluO1xcbn1cXG5cXG4uVG9hc3RpZnlfX3pvb20tZXhpdCB7XFxuICBhbmltYXRpb24tbmFtZTogVG9hc3RpZnlfX3pvb21PdXQ7XFxufVxcblxcbkBrZXlmcmFtZXMgVG9hc3RpZnlfX2ZsaXBJbiB7XFxuICBmcm9tIHtcXG4gICAgdHJhbnNmb3JtOiBwZXJzcGVjdGl2ZSg0MDBweCkgcm90YXRlM2QoMSwgMCwgMCwgOTBkZWcpO1xcbiAgICBhbmltYXRpb24tdGltaW5nLWZ1bmN0aW9uOiBlYXNlLWluO1xcbiAgICBvcGFjaXR5OiAwO1xcbiAgfVxcbiAgNDAlIHtcXG4gICAgdHJhbnNmb3JtOiBwZXJzcGVjdGl2ZSg0MDBweCkgcm90YXRlM2QoMSwgMCwgMCwgLTIwZGVnKTtcXG4gICAgYW5pbWF0aW9uLXRpbWluZy1mdW5jdGlvbjogZWFzZS1pbjtcXG4gIH1cXG4gIDYwJSB7XFxuICAgIHRyYW5zZm9ybTogcGVyc3BlY3RpdmUoNDAwcHgpIHJvdGF0ZTNkKDEsIDAsIDAsIDEwZGVnKTtcXG4gICAgb3BhY2l0eTogMTtcXG4gIH1cXG4gIDgwJSB7XFxuICAgIHRyYW5zZm9ybTogcGVyc3BlY3RpdmUoNDAwcHgpIHJvdGF0ZTNkKDEsIDAsIDAsIC01ZGVnKTtcXG4gIH1cXG4gIHRvIHtcXG4gICAgdHJhbnNmb3JtOiBwZXJzcGVjdGl2ZSg0MDBweCk7XFxuICB9XFxufVxcblxcbkBrZXlmcmFtZXMgVG9hc3RpZnlfX2ZsaXBPdXQge1xcbiAgZnJvbSB7XFxuICAgIHRyYW5zZm9ybTogdHJhbnNsYXRlM2QoMCwgdmFyKC0teSksIDApIHBlcnNwZWN0aXZlKDQwMHB4KTtcXG4gIH1cXG4gIDMwJSB7XFxuICAgIHRyYW5zZm9ybTogdHJhbnNsYXRlM2QoMCwgdmFyKC0teSksIDApIHBlcnNwZWN0aXZlKDQwMHB4KSByb3RhdGUzZCgxLCAwLCAwLCAtMjBkZWcpO1xcbiAgICBvcGFjaXR5OiAxO1xcbiAgfVxcbiAgdG8ge1xcbiAgICB0cmFuc2Zvcm06IHRyYW5zbGF0ZTNkKDAsIHZhcigtLXkpLCAwKSBwZXJzcGVjdGl2ZSg0MDBweCkgcm90YXRlM2QoMSwgMCwgMCwgOTBkZWcpO1xcbiAgICBvcGFjaXR5OiAwO1xcbiAgfVxcbn1cXG5cXG4uVG9hc3RpZnlfX2ZsaXAtZW50ZXIge1xcbiAgYW5pbWF0aW9uLW5hbWU6IFRvYXN0aWZ5X19mbGlwSW47XFxufVxcblxcbi5Ub2FzdGlmeV9fZmxpcC1leGl0IHtcXG4gIGFuaW1hdGlvbi1uYW1lOiBUb2FzdGlmeV9fZmxpcE91dDtcXG59XFxuXFxuQGtleWZyYW1lcyBUb2FzdGlmeV9fc2xpZGVJblJpZ2h0IHtcXG4gIGZyb20ge1xcbiAgICB0cmFuc2Zvcm06IHRyYW5zbGF0ZTNkKDExMCUsIDAsIDApO1xcbiAgICB2aXNpYmlsaXR5OiB2aXNpYmxlO1xcbiAgfVxcbiAgdG8ge1xcbiAgICB0cmFuc2Zvcm06IHRyYW5zbGF0ZTNkKDAsIHZhcigtLXkpLCAwKTtcXG4gIH1cXG59XFxuXFxuQGtleWZyYW1lcyBUb2FzdGlmeV9fc2xpZGVJbkxlZnQge1xcbiAgZnJvbSB7XFxuICAgIHRyYW5zZm9ybTogdHJhbnNsYXRlM2QoLTExMCUsIDAsIDApO1xcbiAgICB2aXNpYmlsaXR5OiB2aXNpYmxlO1xcbiAgfVxcbiAgdG8ge1xcbiAgICB0cmFuc2Zvcm06IHRyYW5zbGF0ZTNkKDAsIHZhcigtLXkpLCAwKTtcXG4gIH1cXG59XFxuXFxuQGtleWZyYW1lcyBUb2FzdGlmeV9fc2xpZGVJblVwIHtcXG4gIGZyb20ge1xcbiAgICB0cmFuc2Zvcm06IHRyYW5zbGF0ZTNkKDAsIDExMCUsIDApO1xcbiAgICB2aXNpYmlsaXR5OiB2aXNpYmxlO1xcbiAgfVxcbiAgdG8ge1xcbiAgICB0cmFuc2Zvcm06IHRyYW5zbGF0ZTNkKDAsIHZhcigtLXkpLCAwKTtcXG4gIH1cXG59XFxuXFxuQGtleWZyYW1lcyBUb2FzdGlmeV9fc2xpZGVJbkRvd24ge1xcbiAgZnJvbSB7XFxuICAgIHRyYW5zZm9ybTogdHJhbnNsYXRlM2QoMCwgLTExMCUsIDApO1xcbiAgICB2aXNpYmlsaXR5OiB2aXNpYmxlO1xcbiAgfVxcbiAgdG8ge1xcbiAgICB0cmFuc2Zvcm06IHRyYW5zbGF0ZTNkKDAsIHZhcigtLXkpLCAwKTtcXG4gIH1cXG59XFxuXFxuQGtleWZyYW1lcyBUb2FzdGlmeV9fc2xpZGVPdXRSaWdodCB7XFxuICBmcm9tIHtcXG4gICAgdHJhbnNmb3JtOiB0cmFuc2xhdGUzZCgwLCB2YXIoLS15KSwgMCk7XFxuICB9XFxuICB0byB7XFxuICAgIHZpc2liaWxpdHk6IGhpZGRlbjtcXG4gICAgdHJhbnNmb3JtOiB0cmFuc2xhdGUzZCgxMTAlLCB2YXIoLS15KSwgMCk7XFxuICB9XFxufVxcblxcbkBrZXlmcmFtZXMgVG9hc3RpZnlfX3NsaWRlT3V0TGVmdCB7XFxuICBmcm9tIHtcXG4gICAgdHJhbnNmb3JtOiB0cmFuc2xhdGUzZCgwLCB2YXIoLS15KSwgMCk7XFxuICB9XFxuICB0byB7XFxuICAgIHZpc2liaWxpdHk6IGhpZGRlbjtcXG4gICAgdHJhbnNmb3JtOiB0cmFuc2xhdGUzZCgtMTEwJSwgdmFyKC0teSksIDApO1xcbiAgfVxcbn1cXG5cXG5Aa2V5ZnJhbWVzIFRvYXN0aWZ5X19zbGlkZU91dERvd24ge1xcbiAgZnJvbSB7XFxuICAgIHRyYW5zZm9ybTogdHJhbnNsYXRlM2QoMCwgdmFyKC0teSksIDApO1xcbiAgfVxcbiAgdG8ge1xcbiAgICB2aXNpYmlsaXR5OiBoaWRkZW47XFxuICAgIHRyYW5zZm9ybTogdHJhbnNsYXRlM2QoMCwgNTAwcHgsIDApO1xcbiAgfVxcbn1cXG5cXG5Aa2V5ZnJhbWVzIFRvYXN0aWZ5X19zbGlkZU91dFVwIHtcXG4gIGZyb20ge1xcbiAgICB0cmFuc2Zvcm06IHRyYW5zbGF0ZTNkKDAsIHZhcigtLXkpLCAwKTtcXG4gIH1cXG4gIHRvIHtcXG4gICAgdmlzaWJpbGl0eTogaGlkZGVuO1xcbiAgICB0cmFuc2Zvcm06IHRyYW5zbGF0ZTNkKDAsIC01MDBweCwgMCk7XFxuICB9XFxufVxcblxcbi5Ub2FzdGlmeV9fc2xpZGUtZW50ZXItLXRvcC1sZWZ0LFxcbi5Ub2FzdGlmeV9fc2xpZGUtZW50ZXItLWJvdHRvbS1sZWZ0IHtcXG4gIGFuaW1hdGlvbi1uYW1lOiBUb2FzdGlmeV9fc2xpZGVJbkxlZnQ7XFxufVxcblxcbi5Ub2FzdGlmeV9fc2xpZGUtZW50ZXItLXRvcC1yaWdodCxcXG4uVG9hc3RpZnlfX3NsaWRlLWVudGVyLS1ib3R0b20tcmlnaHQge1xcbiAgYW5pbWF0aW9uLW5hbWU6IFRvYXN0aWZ5X19zbGlkZUluUmlnaHQ7XFxufVxcblxcbi5Ub2FzdGlmeV9fc2xpZGUtZW50ZXItLXRvcC1jZW50ZXIge1xcbiAgYW5pbWF0aW9uLW5hbWU6IFRvYXN0aWZ5X19zbGlkZUluRG93bjtcXG59XFxuXFxuLlRvYXN0aWZ5X19zbGlkZS1lbnRlci0tYm90dG9tLWNlbnRlciB7XFxuICBhbmltYXRpb24tbmFtZTogVG9hc3RpZnlfX3NsaWRlSW5VcDtcXG59XFxuXFxuLlRvYXN0aWZ5X19zbGlkZS1leGl0LS10b3AtbGVmdCxcXG4uVG9hc3RpZnlfX3NsaWRlLWV4aXQtLWJvdHRvbS1sZWZ0IHtcXG4gIGFuaW1hdGlvbi1uYW1lOiBUb2FzdGlmeV9fc2xpZGVPdXRMZWZ0O1xcbiAgYW5pbWF0aW9uLXRpbWluZy1mdW5jdGlvbjogZWFzZS1pbjtcXG4gIGFuaW1hdGlvbi1kdXJhdGlvbjogMC4zcztcXG59XFxuXFxuLlRvYXN0aWZ5X19zbGlkZS1leGl0LS10b3AtcmlnaHQsXFxuLlRvYXN0aWZ5X19zbGlkZS1leGl0LS1ib3R0b20tcmlnaHQge1xcbiAgYW5pbWF0aW9uLW5hbWU6IFRvYXN0aWZ5X19zbGlkZU91dFJpZ2h0O1xcbiAgYW5pbWF0aW9uLXRpbWluZy1mdW5jdGlvbjogZWFzZS1pbjtcXG4gIGFuaW1hdGlvbi1kdXJhdGlvbjogMC4zcztcXG59XFxuXFxuLlRvYXN0aWZ5X19zbGlkZS1leGl0LS10b3AtY2VudGVyIHtcXG4gIGFuaW1hdGlvbi1uYW1lOiBUb2FzdGlmeV9fc2xpZGVPdXRVcDtcXG4gIGFuaW1hdGlvbi10aW1pbmctZnVuY3Rpb246IGVhc2UtaW47XFxuICBhbmltYXRpb24tZHVyYXRpb246IDAuM3M7XFxufVxcblxcbi5Ub2FzdGlmeV9fc2xpZGUtZXhpdC0tYm90dG9tLWNlbnRlciB7XFxuICBhbmltYXRpb24tbmFtZTogVG9hc3RpZnlfX3NsaWRlT3V0RG93bjtcXG4gIGFuaW1hdGlvbi10aW1pbmctZnVuY3Rpb246IGVhc2UtaW47XFxuICBhbmltYXRpb24tZHVyYXRpb246IDAuM3M7XFxufVxcblxcbkBrZXlmcmFtZXMgVG9hc3RpZnlfX3NwaW4ge1xcbiAgZnJvbSB7XFxuICAgIHRyYW5zZm9ybTogcm90YXRlKDBkZWcpO1xcbiAgfVxcbiAgdG8ge1xcbiAgICB0cmFuc2Zvcm06IHJvdGF0ZSgzNjBkZWcpO1xcbiAgfVxcbn1cXG5cIiwgXCJcIix7XCJ2ZXJzaW9uXCI6MyxcInNvdXJjZXNcIjpbXCJ3ZWJwYWNrOi8vbm9kZV9tb2R1bGVzL3JlYWN0LXRvYXN0aWZ5L2Rpc3QvUmVhY3RUb2FzdGlmeS5jc3NcIl0sXCJuYW1lc1wiOltdLFwibWFwcGluZ3NcIjpcIkFBQUE7RUFDRSw0QkFBNEI7RUFDNUIsOEJBQThCO0VBQzlCLDhCQUE4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c0M7RUFDeEM7RUFDQTtJQUNFLGtCQUFrQjtJQUNsQixtQ0FBbUM7RUFDckM7QUFDRjs7QUFFQTtFQUNFO0lBQ0Usc0NBQXNDO0VBQ3hDO0VBQ0E7SUFDRSxrQkFBa0I7SUFDbEIsb0NBQW9DO0VBQ3RDO0FBQ0Y7O0FBRUE7O0VBRUUscUNBQXFDO0FBQ3ZDOztBQUVBOztFQUVFLHNDQUFzQztBQUN4Qzs7QUFFQTtFQUNFLHFDQUFxQztBQUN2Qzs7QUFFQTtFQUNFLG1DQUFtQztBQUNyQzs7QUFFQTs7RUFFRSxzQ0FBc0M7RUFDdEMsa0NBQWtDO0VBQ2xDLHdCQUF3QjtBQUMxQjs7QUFFQTs7RUFFRSx1Q0FBdUM7RUFDdkMsa0NBQWtDO0VBQ2xDLHdCQUF3QjtBQUMxQjs7QUFFQTtFQUNFLG9DQUFvQztFQUNwQyxrQ0FBa0M7RUFDbEMsd0JBQXdCO0FBQzFCOztBQUVBO0VBQ0Usc0NBQXNDO0VBQ3RDLGtDQUFrQztFQUNsQyx3QkFBd0I7QUFDMUI7O0FBRUE7RUFDRTtJQUNFLHVCQUF1QjtFQUN6QjtFQUNBO0lBQ0UseUJBQXlCO0VBQzNCO0FBQ0ZcIixcInNvdXJjZXNDb250ZW50XCI6W1wiOnJvb3Qge1xcbiAgLS10b2FzdGlmeS1jb2xvci1saWdodDogI2ZmZjtcXG4gIC0tdG9hc3RpZnktY29sb3ItZGFyazogIzEyMTIxMjtcXG4gIC0tdG9hc3RpZnktY29sb3ItaW5mbzogIzM0OThkYjtcXG4gIC0tdG9hc3RpZnktY29sb3Itc3VjY2VzczogIzA3YmMwYztcXG4gIC0tdG9hc3RpZnktY29sb3Itd2FybmluZzogI2YxYzQwZjtcXG4gIC0tdG9hc3RpZnktY29sb3ItZXJyb3I6IGhzbCg2LCA3OCUsIDU3JSk7XFxuICAtLXRvYXN0aWZ5LWNvbG9yLXRyYW5zcGFyZW50OiByZ2JhKDI1NSwgMjU1LCAyNTUsIDAuNyk7XFxuXFxuICAtLXRvYXN0aWZ5LWljb24tY29sb3ItaW5mbzogdmFyKC0tdG9hc3RpZnktY29sb3ItaW5mbyk7XFxuICAtLXRvYXN0aWZ5LWljb24tY29sb3Itc3VjY2VzczogdmFyKC0tdG9hc3RpZnktY29sb3Itc3VjY2Vzcyk7XFxuICAtLXRvYXN0aWZ5LWljb24tY29sb3Itd2FybmluZzogdmFyKC0tdG9hc3RpZnktY29sb3Itd2FybmluZyk7XFxuICAtLXRvYXN0aWZ5LWljb24tY29sb3ItZXJyb3I6IHZhcigtLXRvYXN0aWZ5LWNvbG9yLWVycm9yKTtcXG5cXG4gIC0tdG9hc3RpZnktY29udGFpbmVyLXdpZHRoOiBmaXQtY29udGVudDtcXG4gIC0tdG9hc3RpZnktdG9hc3Qtd2lkdGg6IDMyMHB4O1xcbiAgLS10b2FzdGlmeS10b2FzdC1vZmZzZXQ6IDE2cHg7XFxuICAtLXRvYXN0aWZ5LXRvYXN0LXRvcDogbWF4KHZhcigtLXRvYXN0aWZ5LXRvYXN0LW9mZnNldCksIGVudihzYWZlLWFyZWEtaW5zZXQtdG9wKSk7XFxuICAtLXRvYXN0aWZ5LXRvYXN0LXJpZ2h0OiBtYXgodmFyKC0tdG9hc3RpZnktdG9hc3Qtb2Zmc2V0KSwgZW52KHNhZmUtYXJlYS1pbnNldC1yaWdodCkpO1xcbiAgLS10b2FzdGlmeS10b2FzdC1sZWZ0OiBtYXgodmFyKC0tdG9hc3RpZnktdG9hc3Qtb2Zmc2V0KSwgZW52KHNhZmUtYXJlYS1pbnNldC1sZWZ0KSk7XFxuICAtLXRvYXN0aWZ5LXRvYXN0LWJvdHRvbTogbWF4KHZhcigtLXRvYXN0aWZ5LXRvYXN0LW9mZnNldCksIGVudihzYWZlLWFyZWEtaW5zZXQtYm90dG9tKSk7XFxuICAtLXRvYXN0aWZ5LXRvYXN0LWJhY2tncm91bmQ6ICNmZmY7XFxuICAtLXRvYXN0aWZ5LXRvYXN0LXBhZGRpbmc6IDE0cHg7XFxuICAtLXRvYXN0aWZ5LXRvYXN0LW1pbi1oZWlnaHQ6IDY0cHg7XFxuICAtLXRvYXN0aWZ5LXRvYXN0LW1heC1oZWlnaHQ6IDgwMHB4O1xcbiAgLS10b2FzdGlmeS10b2FzdC1iZC1yYWRpdXM6IDZweDtcXG4gIC0tdG9hc3RpZnktdG9hc3Qtc2hhZG93OiAwcHggNHB4IDEycHggcmdiYSgwLCAwLCAwLCAwLjEpO1xcbiAgLS10b2FzdGlmeS1mb250LWZhbWlseTogc2Fucy1zZXJpZjtcXG4gIC0tdG9hc3RpZnktei1pbmRleDogOTk5OTtcXG4gIC0tdG9hc3RpZnktdGV4dC1jb2xvci1saWdodDogIzc1NzU3NTtcXG4gIC0tdG9hc3RpZnktdGV4dC1jb2xvci1kYXJrOiAjZmZmO1xcblxcbiAgLyogVXNlZCBvbmx5IGZvciBjb2xvcmVkIHRoZW1lICovXFxuICAtLXRvYXN0aWZ5LXRleHQtY29sb3ItaW5mbzogI2ZmZjtcXG4gIC0tdG9hc3RpZnktdGV4dC1jb2xvci1zdWNjZXNzOiAjZmZmO1xcbiAgLS10b2FzdGlmeS10ZXh0LWNvbG9yLXdhcm5pbmc6ICNmZmY7XFxuICAtLXRvYXN0aWZ5LXRleHQtY29sb3ItZXJyb3I6ICNmZmY7XFxuXFxuICAtLXRvYXN0aWZ5LXNwaW5uZXItY29sb3I6ICM2MTYxNjE7XFxuICAtLXRvYXN0aWZ5LXNwaW5uZXItY29sb3ItZW1wdHktYXJlYTogI2UwZTBlMDtcXG4gIC0tdG9hc3RpZnktY29sb3ItcHJvZ3Jlc3MtbGlnaHQ6IGxpbmVhci1ncmFkaWVudCh0byByaWdodCwgIzRjZDk2NCwgIzVhYzhmYSwgIzAwN2FmZiwgIzM0YWFkYywgIzU4NTZkNiwgI2ZmMmQ1NSk7XFxuICAtLXRvYXN0aWZ5LWNvbG9yLXByb2dyZXNzLWRhcms6ICNiYjg2ZmM7XFxuICAtLXRvYXN0aWZ5LWNvbG9yLXByb2dyZXNzLWluZm86IHZhcigtLXRvYXN0aWZ5LWNvbG9yLWluZm8pO1xcbiAgLS10b2FzdGlmeS1jb2xvci1wcm9ncmVzcy1zdWNjZXNzOiB2YXIoLS10b2FzdGlmeS1jb2xvci1zdWNjZXNzKTtcXG4gIC0tdG9hc3RpZnktY29sb3ItcHJvZ3Jlc3Mtd2FybmluZzogdmFyKC0tdG9hc3RpZnktY29sb3Itd2FybmluZyk7XFxuICAtLXRvYXN0aWZ5LWNvbG9yLXByb2dyZXNzLWVycm9yOiB2YXIoLS10b2FzdGlmeS1jb2xvci1lcnJvcik7XFxuICAvKiB1c2VkIHRvIGNvbnRyb2wgdGhlIG9wYWNpdHkgb2YgdGhlIHByb2dyZXNzIHRyYWlsICovXFxuICAtLXRvYXN0aWZ5LWNvbG9yLXByb2dyZXNzLWJnbzogMC4yO1xcbn1cXG5cXG4uVG9hc3RpZnlfX3RvYXN0LWNvbnRhaW5lciB7XFxuICB6LWluZGV4OiB2YXIoLS10b2FzdGlmeS16LWluZGV4KTtcXG4gIC13ZWJraXQtdHJhbnNmb3JtOiB0cmFuc2xhdGUzZCgwLCAwLCB2YXIoLS10b2FzdGlmeS16LWluZGV4KSk7XFxuICBwb3NpdGlvbjogZml4ZWQ7XFxuICB3aWR0aDogdmFyKC0tdG9hc3RpZnktY29udGFpbmVyLXdpZHRoKTtcXG4gIGJveC1zaXppbmc6IGJvcmRlci1ib3g7XFxuICBjb2xvcjogI2ZmZjtcXG4gIGRpc3BsYXk6IGZsZXg7XFxuICBmbGV4LWRpcmVjdGlvbjogY29sdW1uO1xcbn1cXG5cXG4uVG9hc3RpZnlfX3RvYXN0LWNvbnRhaW5lci0tdG9wLWxlZnQge1xcbiAgdG9wOiB2YXIoLS10b2FzdGlmeS10b2FzdC10b3ApO1xcbiAgbGVmdDogdmFyKC0tdG9hc3RpZnktdG9hc3QtbGVmdCk7XFxufVxcbi5Ub2FzdGlmeV9fdG9hc3QtY29udGFpbmVyLS10b3AtY2VudGVyIHtcXG4gIHRvcDogdmFyKC0tdG9hc3RpZnktdG9hc3QtdG9wKTtcXG4gIGxlZnQ6IDUwJTtcXG4gIHRyYW5zZm9ybTogdHJhbnNsYXRlWCgtNTAlKTtcXG4gIGFsaWduLWl0ZW1zOiBjZW50ZXI7XFxufVxcbi5Ub2FzdGlmeV9fdG9hc3QtY29udGFpbmVyLS10b3AtcmlnaHQge1xcbiAgdG9wOiB2YXIoLS10b2FzdGlmeS10b2FzdC10b3ApO1xcbiAgcmlnaHQ6IHZhcigtLXRvYXN0aWZ5LXRvYXN0LXJpZ2h0KTtcXG4gIGFsaWduLWl0ZW1zOiBlbmQ7XFxufVxcbi5Ub2FzdGlmeV9fdG9hc3QtY29udGFpbmVyLS1ib3R0b20tbGVmdCB7XFxuICBib3R0b206IHZhcigtLXRvYXN0aWZ5LXRvYXN0LWJvdHRvbSk7XFxuICBsZWZ0OiB2YXIoLS10b2FzdGlmeS10b2FzdC1sZWZ0KTtcXG59XFxuLlRvYXN0aWZ5X190b2FzdC1jb250YWluZXItLWJvdHRvbS1jZW50ZXIge1xcbiAgYm90dG9tOiB2YXIoLS10b2FzdGlmeS10b2FzdC1ib3R0b20pO1xcbiAgbGVmdDogNTAlO1xcbiAgdHJhbnNmb3JtOiB0cmFuc2xhdGVYKC01MCUpO1xcbiAgYWxpZ24taXRlbXM6IGNlbnRlcjtcXG59XFxuLlRvYXN0aWZ5X190b2FzdC1jb250YWluZXItLWJvdHRvbS1yaWdodCB7XFxuICBib3R0b206IHZhcigtLXRvYXN0aWZ5LXRvYXN0LWJvdHRvbSk7XFxuICByaWdodDogdmFyKC0tdG9hc3RpZnktdG9hc3QtcmlnaHQpO1xcbiAgYWxpZ24taXRlbXM6IGVuZDtcXG59XFxuXFxuLlRvYXN0aWZ5X190b2FzdCB7XFxuICAtLXk6IDA7XFxuICBwb3NpdGlvbjogcmVsYXRpdmU7XFxuICB0b3VjaC1hY3Rpb246IG5vbmU7XFxuICB3aWR0aDogdmFyKC0tdG9hc3RpZnktdG9hc3Qtd2lkdGgpO1xcbiAgbWluLWhlaWdodDogdmFyKC0tdG9hc3RpZnktdG9hc3QtbWluLWhlaWdodCk7XFxuICBib3gtc2l6aW5nOiBib3JkZXItYm94O1xcbiAgbWFyZ2luLWJvdHRvbTogMXJlbTtcXG4gIHBhZGRpbmc6IHZhcigtLXRvYXN0aWZ5LXRvYXN0LXBhZGRpbmcpO1xcbiAgYm9yZGVyLXJhZGl1czogdmFyKC0tdG9hc3RpZnktdG9hc3QtYmQtcmFkaXVzKTtcXG4gIGJveC1zaGFkb3c6IHZhcigtLXRvYXN0aWZ5LXRvYXN0LXNoYWRvdyk7XFxuICBtYXgtaGVpZ2h0OiB2YXIoLS10b2FzdGlmeS10b2FzdC1tYXgtaGVpZ2h0KTtcXG4gIGZvbnQtZmFtaWx5OiB2YXIoLS10b2FzdGlmeS1mb250LWZhbWlseSk7XFxuICAvKiB3ZWJraXQgb25seSBpc3N1ZSAjNzkxICovXFxuICB6LWluZGV4OiAwO1xcbiAgLyogaW5uZXIgc3dhZyAqL1xcbiAgZGlzcGxheTogZmxleDtcXG4gIGZsZXg6IDEgYXV0bztcXG4gIGFsaWduLWl0ZW1zOiBjZW50ZXI7XFxuICB3b3JkLWJyZWFrOiBicmVhay13b3JkO1xcbn1cXG5cXG5AbWVkaWEgb25seSBzY3JlZW4gYW5kIChtYXgtd2lkdGg6IDQ4MHB4KSB7XFxuICAuVG9hc3RpZnlfX3RvYXN0LWNvbnRhaW5lciB7XFxuICAgIHdpZHRoOiAxMDB2dztcXG4gICAgbGVmdDogZW52KHNhZmUtYXJlYS1pbnNldC1sZWZ0KTtcXG4gICAgbWFyZ2luOiAwO1xcbiAgfVxcbiAgLlRvYXN0aWZ5X190b2FzdC1jb250YWluZXItLXRvcC1sZWZ0LFxcbiAgLlRvYXN0aWZ5X190b2FzdC1jb250YWluZXItLXRvcC1jZW50ZXIsXFxuICAuVG9hc3RpZnlfX3RvYXN0LWNvbnRhaW5lci0tdG9wLXJpZ2h0IHtcXG4gICAgdG9wOiBlbnYoc2FmZS1hcmVhLWluc2V0LXRvcCk7XFxuICAgIHRyYW5zZm9ybTogdHJhbnNsYXRlWCgwKTtcXG4gIH1cXG4gIC5Ub2FzdGlmeV9fdG9hc3QtY29udGFpbmVyLS1ib3R0b20tbGVmdCxcXG4gIC5Ub2FzdGlmeV9fdG9hc3QtY29udGFpbmVyLS1ib3R0b20tY2VudGVyLFxcbiAgLlRvYXN0aWZ5X190b2FzdC1jb250YWluZXItLWJvdHRvbS1yaWdodCB7XFxuICAgIGJvdHRvbTogZW52KHNhZmUtYXJlYS1pbnNldC1ib3R0b20pO1xcbiAgICB0cmFuc2Zvcm06IHRyYW5zbGF0ZVgoMCk7XFxuICB9XFxuICAuVG9hc3RpZnlfX3RvYXN0LWNvbnRhaW5lci0tcnRsIHtcXG4gICAgcmlnaHQ6IGVudihzYWZlLWFyZWEtaW5zZXQtcmlnaHQpO1xcbiAgICBsZWZ0OiBpbml0aWFsO1xcbiAgfVxcbiAgLlRvYXN0aWZ5X190b2FzdCB7XFxuICAgIC0tdG9hc3RpZnktdG9hc3Qtd2lkdGg6IDEwMCU7XFxuICAgIG1hcmdpbi1ib3R0b206IDA7XFxuICAgIGJvcmRlci1yYWRpdXM6IDA7XFxuICB9XFxufVxcblxcbi5Ub2FzdGlmeV9fdG9hc3QtY29udGFpbmVyW2RhdGEtc3RhY2tlZD0ndHJ1ZSddIHtcXG4gIHdpZHRoOiB2YXIoLS10b2FzdGlmeS10b2FzdC13aWR0aCk7XFxufVxcblxcbi5Ub2FzdGlmeV9fdG9hc3QtLXN0YWNrZWQge1xcbiAgcG9zaXRpb246IGFic29sdXRlO1xcbiAgd2lkdGg6IDEwMCU7XFxuICB0cmFuc2Zvcm06IHRyYW5zbGF0ZTNkKDAsIHZhcigtLXkpLCAwKSBzY2FsZSh2YXIoLS1zKSk7XFxuICB0cmFuc2l0aW9uOiB0cmFuc2Zvcm0gMC4zcztcXG59XFxuXFxuLlRvYXN0aWZ5X190b2FzdC0tc3RhY2tlZFtkYXRhLWNvbGxhcHNlZF0gLlRvYXN0aWZ5X190b2FzdC1ib2R5LFxcbi5Ub2FzdGlmeV9fdG9hc3QtLXN0YWNrZWRbZGF0YS1jb2xsYXBzZWRdIC5Ub2FzdGlmeV9fY2xvc2UtYnV0dG9uIHtcXG4gIHRyYW5zaXRpb246IG9wYWNpdHkgMC4xcztcXG59XFxuXFxuLlRvYXN0aWZ5X190b2FzdC0tc3RhY2tlZFtkYXRhLWNvbGxhcHNlZD0nZmFsc2UnXSB7XFxuICBvdmVyZmxvdzogdmlzaWJsZTtcXG59XFxuXFxuLlRvYXN0aWZ5X190b2FzdC0tc3RhY2tlZFtkYXRhLWNvbGxhcHNlZD0ndHJ1ZSddOm5vdCg6bGFzdC1jaGlsZCkgPiAqIHtcXG4gIG9wYWNpdHk6IDA7XFxufVxcblxcbi5Ub2FzdGlmeV9fdG9hc3QtLXN0YWNrZWQ6YWZ0ZXIge1xcbiAgY29udGVudDogJyc7XFxuICBwb3NpdGlvbjogYWJzb2x1dGU7XFxuICBsZWZ0OiAwO1xcbiAgcmlnaHQ6IDA7XFxuICBoZWlnaHQ6IGNhbGModmFyKC0tZykgKiAxcHgpO1xcbiAgYm90dG9tOiAxMDAlO1xcbn1cXG5cXG4uVG9hc3RpZnlfX3RvYXN0LS1zdGFja2VkW2RhdGEtcG9zPSd0b3AnXSB7XFxuICB0b3A6IDA7XFxufVxcblxcbi5Ub2FzdGlmeV9fdG9hc3QtLXN0YWNrZWRbZGF0YS1wb3M9J2JvdCddIHtcXG4gIGJvdHRvbTogMDtcXG59XFxuXFxuLlRvYXN0aWZ5X190b2FzdC0tc3RhY2tlZFtkYXRhLXBvcz0nYm90J10uVG9hc3RpZnlfX3RvYXN0LS1zdGFja2VkOmJlZm9yZSB7XFxuICB0cmFuc2Zvcm0tb3JpZ2luOiB0b3A7XFxufVxcblxcbi5Ub2FzdGlmeV9fdG9hc3QtLXN0YWNrZWRbZGF0YS1wb3M9J3RvcCddLlRvYXN0aWZ5X190b2FzdC0tc3RhY2tlZDpiZWZvcmUge1xcbiAgdHJhbnNmb3JtLW9yaWdpbjogYm90dG9tO1xcbn1cXG5cXG4uVG9hc3RpZnlfX3RvYXN0LS1zdGFja2VkOmJlZm9yZSB7XFxuICBjb250ZW50OiAnJztcXG4gIHBvc2l0aW9uOiBhYnNvbHV0ZTtcXG4gIGxlZnQ6IDA7XFxuICByaWdodDogMDtcXG4gIGJvdHRvbTogMDtcXG4gIGhlaWdodDogMTAwJTtcXG4gIHRyYW5zZm9ybTogc2NhbGVZKDMpO1xcbiAgei1pbmRleDogLTE7XFxufVxcblxcbi5Ub2FzdGlmeV9fdG9hc3QtLXJ0bCB7XFxuICBkaXJlY3Rpb246IHJ0bDtcXG59XFxuXFxuLlRvYXN0aWZ5X190b2FzdC0tY2xvc2Utb24tY2xpY2sge1xcbiAgY3Vyc29yOiBwb2ludGVyO1xcbn1cXG5cXG4uVG9hc3RpZnlfX3RvYXN0LWljb24ge1xcbiAgbWFyZ2luLWlubGluZS1lbmQ6IDEwcHg7XFxuICB3aWR0aDogMjJweDtcXG4gIGZsZXgtc2hyaW5rOiAwO1xcbiAgZGlzcGxheTogZmxleDtcXG59XFxuXFxuLlRvYXN0aWZ5LS1hbmltYXRlIHtcXG4gIGFuaW1hdGlvbi1maWxsLW1vZGU6IGJvdGg7XFxuICBhbmltYXRpb24tZHVyYXRpb246IDAuNXM7XFxufVxcblxcbi5Ub2FzdGlmeS0tYW5pbWF0ZS1pY29uIHtcXG4gIGFuaW1hdGlvbi1maWxsLW1vZGU6IGJvdGg7XFxuICBhbmltYXRpb24tZHVyYXRpb246IDAuM3M7XFxufVxcblxcbi5Ub2FzdGlmeV9fdG9hc3QtdGhlbWUtLWRhcmsge1xcbiAgYmFja2dyb3VuZDogdmFyKC0tdG9hc3RpZnktY29sb3ItZGFyayk7XFxuICBjb2xvcjogdmFyKC0tdG9hc3RpZnktdGV4dC1jb2xvci1kYXJrKTtcXG59XFxuXFxuLlRvYXN0aWZ5X190b2FzdC10aGVtZS0tbGlnaHQge1xcbiAgYmFja2dyb3VuZDogdmFyKC0tdG9hc3RpZnktY29sb3ItbGlnaHQpO1xcbiAgY29sb3I6IHZhcigtLXRvYXN0aWZ5LXRleHQtY29sb3ItbGlnaHQpO1xcbn1cXG5cXG4uVG9hc3RpZnlfX3RvYXN0LXRoZW1lLS1jb2xvcmVkLlRvYXN0aWZ5X190b2FzdC0tZGVmYXVsdCB7XFxuICBiYWNrZ3JvdW5kOiB2YXIoLS10b2FzdGlmeS1jb2xvci1saWdodCk7XFxuICBjb2xvcjogdmFyKC0tdG9hc3RpZnktdGV4dC1jb2xvci1saWdodCk7XFxufVxcblxcbi5Ub2FzdGlmeV9fdG9hc3QtdGhlbWUtLWNvbG9yZWQuVG9hc3RpZnlfX3RvYXN0LS1pbmZvIHtcXG4gIGNvbG9yOiB2YXIoLS10b2FzdGlmeS10ZXh0LWNvbG9yLWluZm8pO1xcbiAgYmFja2dyb3VuZDogdmFyKC0tdG9hc3RpZnktY29sb3ItaW5mbyk7XFxufVxcblxcbi5Ub2FzdGlmeV9fdG9hc3QtdGhlbWUtLWNvbG9yZWQuVG9hc3RpZnlfX3RvYXN0LS1zdWNjZXNzIHtcXG4gIGNvbG9yOiB2YXIoLS10b2FzdGlmeS10ZXh0LWNvbG9yLXN1Y2Nlc3MpO1xcbiAgYmFja2dyb3VuZDogdmFyKC0tdG9hc3RpZnktY29sb3Itc3VjY2Vzcyk7XFxufVxcblxcbi5Ub2FzdGlmeV9fdG9hc3QtdGhlbWUtLWNvbG9yZWQuVG9hc3RpZnlfX3RvYXN0LS13YXJuaW5nIHtcXG4gIGNvbG9yOiB2YXIoLS10b2FzdGlmeS10ZXh0LWNvbG9yLXdhcm5pbmcpO1xcbiAgYmFja2dyb3VuZDogdmFyKC0tdG9hc3RpZnktY29sb3Itd2FybmluZyk7XFxufVxcblxcbi5Ub2FzdGlmeV9fdG9hc3QtdGhlbWUtLWNvbG9yZWQuVG9hc3RpZnlfX3RvYXN0LS1lcnJvciB7XFxuICBjb2xvcjogdmFyKC0tdG9hc3RpZnktdGV4dC1jb2xvci1lcnJvcik7XFxuICBiYWNrZ3JvdW5kOiB2YXIoLS10b2FzdGlmeS1jb2xvci1lcnJvcik7XFxufVxcblxcbi5Ub2FzdGlmeV9fcHJvZ3Jlc3MtYmFyLXRoZW1lLS1saWdodCB7XFxuICBiYWNrZ3JvdW5kOiB2YXIoLS10b2FzdGlmeS1jb2xvci1wcm9ncmVzcy1saWdodCk7XFxufVxcblxcbi5Ub2FzdGlmeV9fcHJvZ3Jlc3MtYmFyLXRoZW1lLS1kYXJrIHtcXG4gIGJhY2tncm91bmQ6IHZhcigtLXRvYXN0aWZ5LWNvbG9yLXByb2dyZXNzLWRhcmspO1xcbn1cXG5cXG4uVG9hc3RpZnlfX3Byb2dyZXNzLWJhci0taW5mbyB7XFxuICBiYWNrZ3JvdW5kOiB2YXIoLS10b2FzdGlmeS1jb2xvci1wcm9ncmVzcy1pbmZvKTtcXG59XFxuXFxuLlRvYXN0aWZ5X19wcm9ncmVzcy1iYXItLXN1Y2Nlc3Mge1xcbiAgYmFja2dyb3VuZDogdmFyKC0tdG9hc3RpZnktY29sb3ItcHJvZ3Jlc3Mtc3VjY2Vzcyk7XFxufVxcblxcbi5Ub2FzdGlmeV9fcHJvZ3Jlc3MtYmFyLS13YXJuaW5nIHtcXG4gIGJhY2tncm91bmQ6IHZhcigtLXRvYXN0aWZ5LWNvbG9yLXByb2dyZXNzLXdhcm5pbmcpO1xcbn1cXG5cXG4uVG9hc3RpZnlfX3Byb2dyZXNzLWJhci0tZXJyb3Ige1xcbiAgYmFja2dyb3VuZDogdmFyKC0tdG9hc3RpZnktY29sb3ItcHJvZ3Jlc3MtZXJyb3IpO1xcbn1cXG5cXG4uVG9hc3RpZnlfX3Byb2dyZXNzLWJhci10aGVtZS0tY29sb3JlZC5Ub2FzdGlmeV9fcHJvZ3Jlc3MtYmFyLS1pbmZvLFxcbi5Ub2FzdGlmeV9fcHJvZ3Jlc3MtYmFyLXRoZW1lLS1jb2xvcmVkLlRvYXN0aWZ5X19wcm9ncmVzcy1iYXItLXN1Y2Nlc3MsXFxuLlRvYXN0aWZ5X19wcm9ncmVzcy1iYXItdGhlbWUtLWNvbG9yZWQuVG9hc3RpZnlfX3Byb2dyZXNzLWJhci0td2FybmluZyxcXG4uVG9hc3RpZnlfX3Byb2dyZXNzLWJhci10aGVtZS0tY29sb3JlZC5Ub2FzdGlmeV9fcHJvZ3Jlc3MtYmFyLS1lcnJvciB7XFxuICBiYWNrZ3JvdW5kOiB2YXIoLS10b2FzdGlmeS1jb2xvci10cmFuc3BhcmVudCk7XFxufVxcblxcbi5Ub2FzdGlmeV9fY2xvc2UtYnV0dG9uIHtcXG4gIGNvbG9yOiAjZmZmO1xcbiAgcG9zaXRpb246IGFic29sdXRlO1xcbiAgdG9wOiA2cHg7XFxuICByaWdodDogNnB4O1xcbiAgYmFja2dyb3VuZDogdHJhbnNwYXJlbnQ7XFxuICBvdXRsaW5lOiBub25lO1xcbiAgYm9yZGVyOiBub25lO1xcbiAgcGFkZGluZzogMDtcXG4gIGN1cnNvcjogcG9pbnRlcjtcXG4gIG9wYWNpdHk6IDAuNztcXG4gIHRyYW5zaXRpb246IDAuM3MgZWFzZTtcXG4gIHotaW5kZXg6IDE7XFxufVxcblxcbi5Ub2FzdGlmeV9fdG9hc3QtLXJ0bCAuVG9hc3RpZnlfX2Nsb3NlLWJ1dHRvbiB7XFxuICBsZWZ0OiA2cHg7XFxuICByaWdodDogdW5zZXQ7XFxufVxcblxcbi5Ub2FzdGlmeV9fY2xvc2UtYnV0dG9uLS1saWdodCB7XFxuICBjb2xvcjogIzAwMDtcXG4gIG9wYWNpdHk6IDAuMztcXG59XFxuXFxuLlRvYXN0aWZ5X19jbG9zZS1idXR0b24gPiBzdmcge1xcbiAgZmlsbDogY3VycmVudENvbG9yO1xcbiAgaGVpZ2h0OiAxNnB4O1xcbiAgd2lkdGg6IDE0cHg7XFxufVxcblxcbi5Ub2FzdGlmeV9fY2xvc2UtYnV0dG9uOmhvdmVyLFxcbi5Ub2FzdGlmeV9fY2xvc2UtYnV0dG9uOmZvY3VzIHtcXG4gIG9wYWNpdHk6IDE7XFxufVxcblxcbkBrZXlmcmFtZXMgVG9hc3RpZnlfX3RyYWNrUHJvZ3Jlc3Mge1xcbiAgMCUge1xcbiAgICB0cmFuc2Zvcm06IHNjYWxlWCgxKTtcXG4gIH1cXG4gIDEwMCUge1xcbiAgICB0cmFuc2Zvcm06IHNjYWxlWCgwKTtcXG4gIH1cXG59XFxuXFxuLlRvYXN0aWZ5X19wcm9ncmVzcy1iYXIge1xcbiAgcG9zaXRpb246IGFic29sdXRlO1xcbiAgYm90dG9tOiAwO1xcbiAgbGVmdDogMDtcXG4gIHdpZHRoOiAxMDAlO1xcbiAgaGVpZ2h0OiAxMDAlO1xcbiAgei1pbmRleDogMTtcXG4gIG9wYWNpdHk6IDAuNztcXG4gIHRyYW5zZm9ybS1vcmlnaW46IGxlZnQ7XFxufVxcblxcbi5Ub2FzdGlmeV9fcHJvZ3Jlc3MtYmFyLS1hbmltYXRlZCB7XFxuICBhbmltYXRpb246IFRvYXN0aWZ5X190cmFja1Byb2dyZXNzIGxpbmVhciAxIGZvcndhcmRzO1xcbn1cXG5cXG4uVG9hc3RpZnlfX3Byb2dyZXNzLWJhci0tY29udHJvbGxlZCB7XFxuICB0cmFuc2l0aW9uOiB0cmFuc2Zvcm0gMC4ycztcXG59XFxuXFxuLlRvYXN0aWZ5X19wcm9ncmVzcy1iYXItLXJ0bCB7XFxuICByaWdodDogMDtcXG4gIGxlZnQ6IGluaXRpYWw7XFxuICB0cmFuc2Zvcm0tb3JpZ2luOiByaWdodDtcXG4gIGJvcmRlci1ib3R0b20tbGVmdC1yYWRpdXM6IGluaXRpYWw7XFxufVxcblxcbi5Ub2FzdGlmeV9fcHJvZ3Jlc3MtYmFyLS13cnAge1xcbiAgcG9zaXRpb246IGFic29sdXRlO1xcbiAgb3ZlcmZsb3c6IGhpZGRlbjtcXG4gIGJvdHRvbTogMDtcXG4gIGxlZnQ6IDA7XFxuICB3aWR0aDogMTAwJTtcXG4gIGhlaWdodDogNXB4O1xcbiAgYm9yZGVyLWJvdHRvbS1sZWZ0LXJhZGl1czogdmFyKC0tdG9hc3RpZnktdG9hc3QtYmQtcmFkaXVzKTtcXG4gIGJvcmRlci1ib3R0b20tcmlnaHQtcmFkaXVzOiB2YXIoLS10b2FzdGlmeS10b2FzdC1iZC1yYWRpdXMpO1xcbn1cXG5cXG4uVG9hc3RpZnlfX3Byb2dyZXNzLWJhci0td3JwW2RhdGEtaGlkZGVuPSd0cnVlJ10ge1xcbiAgb3BhY2l0eTogMDtcXG59XFxuXFxuLlRvYXN0aWZ5X19wcm9ncmVzcy1iYXItLWJnIHtcXG4gIG9wYWNpdHk6IHZhcigtLXRvYXN0aWZ5LWNvbG9yLXByb2dyZXNzLWJnbyk7XFxuICB3aWR0aDogMTAwJTtcXG4gIGhlaWdodDogMTAwJTtcXG59XFxuXFxuLlRvYXN0aWZ5X19zcGlubmVyIHtcXG4gIHdpZHRoOiAyMHB4O1xcbiAgaGVpZ2h0OiAyMHB4O1xcbiAgYm94LXNpemluZzogYm9yZGVyLWJveDtcXG4gIGJvcmRlcjogMnB4IHNvbGlkO1xcbiAgYm9yZGVyLXJhZGl1czogMTAwJTtcXG4gIGJvcmRlci1jb2xvcjogdmFyKC0tdG9hc3RpZnktc3Bpbm5lci1jb2xvci1lbXB0eS1hcmVhKTtcXG4gIGJvcmRlci1yaWdodC1jb2xvcjogdmFyKC0tdG9hc3RpZnktc3Bpbm5lci1jb2xvcik7XFxuICBhbmltYXRpb246IFRvYXN0aWZ5X19zcGluIDAuNjVzIGxpbmVhciBpbmZpbml0ZTtcXG59XFxuXFxuQGtleWZyYW1lcyBUb2FzdGlmeV9fYm91bmNlSW5SaWdodCB7XFxuICBmcm9tLFxcbiAgNjAlLFxcbiAgNzUlLFxcbiAgOTAlLFxcbiAgdG8ge1xcbiAgICBhbmltYXRpb24tdGltaW5nLWZ1bmN0aW9uOiBjdWJpYy1iZXppZXIoMC4yMTUsIDAuNjEsIDAuMzU1LCAxKTtcXG4gIH1cXG4gIGZyb20ge1xcbiAgICBvcGFjaXR5OiAwO1xcbiAgICB0cmFuc2Zvcm06IHRyYW5zbGF0ZTNkKDMwMDBweCwgMCwgMCk7XFxuICB9XFxuICA2MCUge1xcbiAgICBvcGFjaXR5OiAxO1xcbiAgICB0cmFuc2Zvcm06IHRyYW5zbGF0ZTNkKC0yNXB4LCAwLCAwKTtcXG4gIH1cXG4gIDc1JSB7XFxuICAgIHRyYW5zZm9ybTogdHJhbnNsYXRlM2QoMTBweCwgMCwgMCk7XFxuICB9XFxuICA5MCUge1xcbiAgICB0cmFuc2Zvcm06IHRyYW5zbGF0ZTNkKC01cHgsIDAsIDApO1xcbiAgfVxcbiAgdG8ge1xcbiAgICB0cmFuc2Zvcm06IG5vbmU7XFxuICB9XFxufVxcblxcbkBrZXlmcmFtZXMgVG9hc3RpZnlfX2JvdW5jZU91dFJpZ2h0IHtcXG4gIDIwJSB7XFxuICAgIG9wYWNpdHk6IDE7XFxuICAgIHRyYW5zZm9ybTogdHJhbnNsYXRlM2QoLTIwcHgsIHZhcigtLXkpLCAwKTtcXG4gIH1cXG4gIHRvIHtcXG4gICAgb3BhY2l0eTogMDtcXG4gICAgdHJhbnNmb3JtOiB0cmFuc2xhdGUzZCgyMDAwcHgsIHZhcigtLXkpLCAwKTtcXG4gIH1cXG59XFxuXFxuQGtleWZyYW1lcyBUb2FzdGlmeV9fYm91bmNlSW5MZWZ0IHtcXG4gIGZyb20sXFxuICA2MCUsXFxuICA3NSUsXFxuICA5MCUsXFxuICB0byB7XFxuICAgIGFuaW1hdGlvbi10aW1pbmctZnVuY3Rpb246IGN1YmljLWJlemllcigwLjIxNSwgMC42MSwgMC4zNTUsIDEpO1xcbiAgfVxcbiAgMCUge1xcbiAgICBvcGFjaXR5OiAwO1xcbiAgICB0cmFuc2Zvcm06IHRyYW5zbGF0ZTNkKC0zMDAwcHgsIDAsIDApO1xcbiAgfVxcbiAgNjAlIHtcXG4gICAgb3BhY2l0eTogMTtcXG4gICAgdHJhbnNmb3JtOiB0cmFuc2xhdGUzZCgyNXB4LCAwLCAwKTtcXG4gIH1cXG4gIDc1JSB7XFxuICAgIHRyYW5zZm9ybTogdHJhbnNsYXRlM2QoLTEwcHgsIDAsIDApO1xcbiAgfVxcbiAgOTAlIHtcXG4gICAgdHJhbnNmb3JtOiB0cmFuc2xhdGUzZCg1cHgsIDAsIDApO1xcbiAgfVxcbiAgdG8ge1xcbiAgICB0cmFuc2Zvcm06IG5vbmU7XFxuICB9XFxufVxcblxcbkBrZXlmcmFtZXMgVG9hc3RpZnlfX2JvdW5jZU91dExlZnQge1xcbiAgMjAlIHtcXG4gICAgb3BhY2l0eTogMTtcXG4gICAgdHJhbnNmb3JtOiB0cmFuc2xhdGUzZCgyMHB4LCB2YXIoLS15KSwgMCk7XFxuICB9XFxuICB0byB7XFxuICAgIG9wYWNpdHk6IDA7XFxuICAgIHRyYW5zZm9ybTogdHJhbnNsYXRlM2QoLTIwMDBweCwgdmFyKC0teSksIDApO1xcbiAgfVxcbn1cXG5cXG5Aa2V5ZnJhbWVzIFRvYXN0aWZ5X19ib3VuY2VJblVwIHtcXG4gIGZyb20sXFxuICA2MCUsXFxuICA3NSUsXFxuICA5MCUsXFxuICB0byB7XFxuICAgIGFuaW1hdGlvbi10aW1pbmctZnVuY3Rpb246IGN1YmljLWJlemllcigwLjIxNSwgMC42MSwgMC4zNTUsIDEpO1xcbiAgfVxcbiAgZnJvbSB7XFxuICAgIG9wYWNpdHk6IDA7XFxuICAgIHRyYW5zZm9ybTogdHJhbnNsYXRlM2QoMCwgMzAwMHB4LCAwKTtcXG4gIH1cXG4gIDYwJSB7XFxuICAgIG9wYWNpdHk6IDE7XFxuICAgIHRyYW5zZm9ybTogdHJhbnNsYXRlM2QoMCwgLTIwcHgsIDApO1xcbiAgfVxcbiAgNzUlIHtcXG4gICAgdHJhbnNmb3JtOiB0cmFuc2xhdGUzZCgwLCAxMHB4LCAwKTtcXG4gIH1cXG4gIDkwJSB7XFxuICAgIHRyYW5zZm9ybTogdHJhbnNsYXRlM2QoMCwgLTVweCwgMCk7XFxuICB9XFxuICB0byB7XFxuICAgIHRyYW5zZm9ybTogdHJhbnNsYXRlM2QoMCwgMCwgMCk7XFxuICB9XFxufVxcblxcbkBrZXlmcmFtZXMgVG9hc3RpZnlfX2JvdW5jZU91dFVwIHtcXG4gIDIwJSB7XFxuICAgIHRyYW5zZm9ybTogdHJhbnNsYXRlM2QoMCwgY2FsYyh2YXIoLS15KSAtIDEwcHgpLCAwKTtcXG4gIH1cXG4gIDQwJSxcXG4gIDQ1JSB7XFxuICAgIG9wYWNpdHk6IDE7XFxuICAgIHRyYW5zZm9ybTogdHJhbnNsYXRlM2QoMCwgY2FsYyh2YXIoLS15KSArIDIwcHgpLCAwKTtcXG4gIH1cXG4gIHRvIHtcXG4gICAgb3BhY2l0eTogMDtcXG4gICAgdHJhbnNmb3JtOiB0cmFuc2xhdGUzZCgwLCAtMjAwMHB4LCAwKTtcXG4gIH1cXG59XFxuXFxuQGtleWZyYW1lcyBUb2FzdGlmeV9fYm91bmNlSW5Eb3duIHtcXG4gIGZyb20sXFxuICA2MCUsXFxuICA3NSUsXFxuICA5MCUsXFxuICB0byB7XFxuICAgIGFuaW1hdGlvbi10aW1pbmctZnVuY3Rpb246IGN1YmljLWJlemllcigwLjIxNSwgMC42MSwgMC4zNTUsIDEpO1xcbiAgfVxcbiAgMCUge1xcbiAgICBvcGFjaXR5OiAwO1xcbiAgICB0cmFuc2Zvcm06IHRyYW5zbGF0ZTNkKDAsIC0zMDAwcHgsIDApO1xcbiAgfVxcbiAgNjAlIHtcXG4gICAgb3BhY2l0eTogMTtcXG4gICAgdHJhbnNmb3JtOiB0cmFuc2xhdGUzZCgwLCAyNXB4LCAwKTtcXG4gIH1cXG4gIDc1JSB7XFxuICAgIHRyYW5zZm9ybTogdHJhbnNsYXRlM2QoMCwgLTEwcHgsIDApO1xcbiAgfVxcbiAgOTAlIHtcXG4gICAgdHJhbnNmb3JtOiB0cmFuc2xhdGUzZCgwLCA1cHgsIDApO1xcbiAgfVxcbiAgdG8ge1xcbiAgICB0cmFuc2Zvcm06IG5vbmU7XFxuICB9XFxufVxcblxcbkBrZXlmcmFtZXMgVG9hc3RpZnlfX2JvdW5jZU91dERvd24ge1xcbiAgMjAlIHtcXG4gICAgdHJhbnNmb3JtOiB0cmFuc2xhdGUzZCgwLCBjYWxjKHZhcigtLXkpIC0gMTBweCksIDApO1xcbiAgfVxcbiAgNDAlLFxcbiAgNDUlIHtcXG4gICAgb3BhY2l0eTogMTtcXG4gICAgdHJhbnNmb3JtOiB0cmFuc2xhdGUzZCgwLCBjYWxjKHZhcigtLXkpICsgMjBweCksIDApO1xcbiAgfVxcbiAgdG8ge1xcbiAgICBvcGFjaXR5OiAwO1xcbiAgICB0cmFuc2Zvcm06IHRyYW5zbGF0ZTNkKDAsIDIwMDBweCwgMCk7XFxuICB9XFxufVxcblxcbi5Ub2FzdGlmeV9fYm91bmNlLWVudGVyLS10b3AtbGVmdCxcXG4uVG9hc3RpZnlfX2JvdW5jZS1lbnRlci0tYm90dG9tLWxlZnQge1xcbiAgYW5pbWF0aW9uLW5hbWU6IFRvYXN0aWZ5X19ib3VuY2VJbkxlZnQ7XFxufVxcblxcbi5Ub2FzdGlmeV9fYm91bmNlLWVudGVyLS10b3AtcmlnaHQsXFxuLlRvYXN0aWZ5X19ib3VuY2UtZW50ZXItLWJvdHRvbS1yaWdodCB7XFxuICBhbmltYXRpb24tbmFtZTogVG9hc3RpZnlfX2JvdW5jZUluUmlnaHQ7XFxufVxcblxcbi5Ub2FzdGlmeV9fYm91bmNlLWVudGVyLS10b3AtY2VudGVyIHtcXG4gIGFuaW1hdGlvbi1uYW1lOiBUb2FzdGlmeV9fYm91bmNlSW5Eb3duO1xcbn1cXG5cXG4uVG9hc3RpZnlfX2JvdW5jZS1lbnRlci0tYm90dG9tLWNlbnRlciB7XFxuICBhbmltYXRpb24tbmFtZTogVG9hc3RpZnlfX2JvdW5jZUluVXA7XFxufVxcblxcbi5Ub2FzdGlmeV9fYm91bmNlLWV4aXQtLXRvcC1sZWZ0LFxcbi5Ub2FzdGlmeV9fYm91bmNlLWV4aXQtLWJvdHRvbS1sZWZ0IHtcXG4gIGFuaW1hdGlvbi1uYW1lOiBUb2FzdGlmeV9fYm91bmNlT3V0TGVmdDtcXG59XFxuXFxuLlRvYXN0aWZ5X19ib3VuY2UtZXhpdC0tdG9wLXJpZ2h0LFxcbi5Ub2FzdGlmeV9fYm91bmNlLWV4aXQtLWJvdHRvbS1yaWdodCB7XFxuICBhbmltYXRpb24tbmFtZTogVG9hc3RpZnlfX2JvdW5jZU91dFJpZ2h0O1xcbn1cXG5cXG4uVG9hc3RpZnlfX2JvdW5jZS1leGl0LS10b3AtY2VudGVyIHtcXG4gIGFuaW1hdGlvbi1uYW1lOiBUb2FzdGlmeV9fYm91bmNlT3V0VXA7XFxufVxcblxcbi5Ub2FzdGlmeV9fYm91bmNlLWV4aXQtLWJvdHRvbS1jZW50ZXIge1xcbiAgYW5pbWF0aW9uLW5hbWU6IFRvYXN0aWZ5X19ib3VuY2VPdXREb3duO1xcbn1cXG5cXG5Aa2V5ZnJhbWVzIFRvYXN0aWZ5X196b29tSW4ge1xcbiAgZnJvbSB7XFxuICAgIG9wYWNpdHk6IDA7XFxuICAgIHRyYW5zZm9ybTogc2NhbGUzZCgwLjMsIDAuMywgMC4zKTtcXG4gIH1cXG4gIDUwJSB7XFxuICAgIG9wYWNpdHk6IDE7XFxuICB9XFxufVxcblxcbkBrZXlmcmFtZXMgVG9hc3RpZnlfX3pvb21PdXQge1xcbiAgZnJvbSB7XFxuICAgIG9wYWNpdHk6IDE7XFxuICB9XFxuICA1MCUge1xcbiAgICBvcGFjaXR5OiAwO1xcbiAgICB0cmFuc2Zvcm06IHRyYW5zbGF0ZTNkKDAsIHZhcigtLXkpLCAwKSBzY2FsZTNkKDAuMywgMC4zLCAwLjMpO1xcbiAgfVxcbiAgdG8ge1xcbiAgICBvcGFjaXR5OiAwO1xcbiAgfVxcbn1cXG5cXG4uVG9hc3RpZnlfX3pvb20tZW50ZXIge1xcbiAgYW5pbWF0aW9uLW5hbWU6IFRvYXN0aWZ5X196b29tSW47XFxufVxcblxcbi5Ub2FzdGlmeV9fem9vbS1leGl0IHtcXG4gIGFuaW1hdGlvbi1uYW1lOiBUb2FzdGlmeV9fem9vbU91dDtcXG59XFxuXFxuQGtleWZyYW1lcyBUb2FzdGlmeV9fZmxpcEluIHtcXG4gIGZyb20ge1xcbiAgICB0cmFuc2Zvcm06IHBlcnNwZWN0aXZlKDQwMHB4KSByb3RhdGUzZCgxLCAwLCAwLCA5MGRlZyk7XFxuICAgIGFuaW1hdGlvbi10aW1pbmctZnVuY3Rpb246IGVhc2UtaW47XFxuICAgIG9wYWNpdHk6IDA7XFxuICB9XFxuICA0MCUge1xcbiAgICB0cmFuc2Zvcm06IHBlcnNwZWN0aXZlKDQwMHB4KSByb3RhdGUzZCgxLCAwLCAwLCAtMjBkZWcpO1xcbiAgICBhbmltYXRpb24tdGltaW5nLWZ1bmN0aW9uOiBlYXNlLWluO1xcbiAgfVxcbiAgNjAlIHtcXG4gICAgdHJhbnNmb3JtOiBwZXJzcGVjdGl2ZSg0MDBweCkgcm90YXRlM2QoMSwgMCwgMCwgMTBkZWcpO1xcbiAgICBvcGFjaXR5OiAxO1xcbiAgfVxcbiAgODAlIHtcXG4gICAgdHJhbnNmb3JtOiBwZXJzcGVjdGl2ZSg0MDBweCkgcm90YXRlM2QoMSwgMCwgMCwgLTVkZWcpO1xcbiAgfVxcbiAgdG8ge1xcbiAgICB0cmFuc2Zvcm06IHBlcnNwZWN0aXZlKDQwMHB4KTtcXG4gIH1cXG59XFxuXFxuQGtleWZyYW1lcyBUb2FzdGlmeV9fZmxpcE91dCB7XFxuICBmcm9tIHtcXG4gICAgdHJhbnNmb3JtOiB0cmFuc2xhdGUzZCgwLCB2YXIoLS15KSwgMCkgcGVyc3BlY3RpdmUoNDAwcHgpO1xcbiAgfVxcbiAgMzAlIHtcXG4gICAgdHJhbnNmb3JtOiB0cmFuc2xhdGUzZCgwLCB2YXIoLS15KSwgMCkgcGVyc3BlY3RpdmUoNDAwcHgpIHJvdGF0ZTNkKDEsIDAsIDAsIC0yMGRlZyk7XFxuICAgIG9wYWNpdHk6IDE7XFxuICB9XFxuICB0byB7XFxuICAgIHRyYW5zZm9ybTogdHJhbnNsYXRlM2QoMCwgdmFyKC0teSksIDApIHBlcnNwZWN0aXZlKDQwMHB4KSByb3RhdGUzZCgxLCAwLCAwLCA5MGRlZyk7XFxuICAgIG9wYWNpdHk6IDA7XFxuICB9XFxufVxcblxcbi5Ub2FzdGlmeV9fZmxpcC1lbnRlciB7XFxuICBhbmltYXRpb24tbmFtZTogVG9hc3RpZnlfX2ZsaXBJbjtcXG59XFxuXFxuLlRvYXN0aWZ5X19mbGlwLWV4aXQge1xcbiAgYW5pbWF0aW9uLW5hbWU6IFRvYXN0aWZ5X19mbGlwT3V0O1xcbn1cXG5cXG5Aa2V5ZnJhbWVzIFRvYXN0aWZ5X19zbGlkZUluUmlnaHQge1xcbiAgZnJvbSB7XFxuICAgIHRyYW5zZm9ybTogdHJhbnNsYXRlM2QoMTEwJSwgMCwgMCk7XFxuICAgIHZpc2liaWxpdHk6IHZpc2libGU7XFxuICB9XFxuICB0byB7XFxuICAgIHRyYW5zZm9ybTogdHJhbnNsYXRlM2QoMCwgdmFyKC0teSksIDApO1xcbiAgfVxcbn1cXG5cXG5Aa2V5ZnJhbWVzIFRvYXN0aWZ5X19zbGlkZUluTGVmdCB7XFxuICBmcm9tIHtcXG4gICAgdHJhbnNmb3JtOiB0cmFuc2xhdGUzZCgtMTEwJSwgMCwgMCk7XFxuICAgIHZpc2liaWxpdHk6IHZpc2libGU7XFxuICB9XFxuICB0byB7XFxuICAgIHRyYW5zZm9ybTogdHJhbnNsYXRlM2QoMCwgdmFyKC0teSksIDApO1xcbiAgfVxcbn1cXG5cXG5Aa2V5ZnJhbWVzIFRvYXN0aWZ5X19zbGlkZUluVXAge1xcbiAgZnJvbSB7XFxuICAgIHRyYW5zZm9ybTogdHJhbnNsYXRlM2QoMCwgMTEwJSwgMCk7XFxuICAgIHZpc2liaWxpdHk6IHZpc2libGU7XFxuICB9XFxuICB0byB7XFxuICAgIHRyYW5zZm9ybTogdHJhbnNsYXRlM2QoMCwgdmFyKC0teSksIDApO1xcbiAgfVxcbn1cXG5cXG5Aa2V5ZnJhbWVzIFRvYXN0aWZ5X19zbGlkZUluRG93biB7XFxuICBmcm9tIHtcXG4gICAgdHJhbnNmb3JtOiB0cmFuc2xhdGUzZCgwLCAtMTEwJSwgMCk7XFxuICAgIHZpc2liaWxpdHk6IHZpc2libGU7XFxuICB9XFxuICB0byB7XFxuICAgIHRyYW5zZm9ybTogdHJhbnNsYXRlM2QoMCwgdmFyKC0teSksIDApO1xcbiAgfVxcbn1cXG5cXG5Aa2V5ZnJhbWVzIFRvYXN0aWZ5X19zbGlkZU91dFJpZ2h0IHtcXG4gIGZyb20ge1xcbiAgICB0cmFuc2Zvcm06IHRyYW5zbGF0ZTNkKDAsIHZhcigtLXkpLCAwKTtcXG4gIH1cXG4gIHRvIHtcXG4gICAgdmlzaWJpbGl0eTogaGlkZGVuO1xcbiAgICB0cmFuc2Zvcm06IHRyYW5zbGF0ZTNkKDExMCUsIHZhcigtLXkpLCAwKTtcXG4gIH1cXG59XFxuXFxuQGtleWZyYW1lcyBUb2FzdGlmeV9fc2xpZGVPdXRMZWZ0IHtcXG4gIGZyb20ge1xcbiAgICB0cmFuc2Zvcm06IHRyYW5zbGF0ZTNkKDAsIHZhcigtLXkpLCAwKTtcXG4gIH1cXG4gIHRvIHtcXG4gICAgdmlzaWJpbGl0eTogaGlkZGVuO1xcbiAgICB0cmFuc2Zvcm06IHRyYW5zbGF0ZTNkKC0xMTAlLCB2YXIoLS15KSwgMCk7XFxuICB9XFxufVxcblxcbkBrZXlmcmFtZXMgVG9hc3RpZnlfX3NsaWRlT3V0RG93biB7XFxuICBmcm9tIHtcXG4gICAgdHJhbnNmb3JtOiB0cmFuc2xhdGUzZCgwLCB2YXIoLS15KSwgMCk7XFxuICB9XFxuICB0byB7XFxuICAgIHZpc2liaWxpdHk6IGhpZGRlbjtcXG4gICAgdHJhbnNmb3JtOiB0cmFuc2xhdGUzZCgwLCA1MDBweCwgMCk7XFxuICB9XFxufVxcblxcbkBrZXlmcmFtZXMgVG9hc3RpZnlfX3NsaWRlT3V0VXAge1xcbiAgZnJvbSB7XFxuICAgIHRyYW5zZm9ybTogdHJhbnNsYXRlM2QoMCwgdmFyKC0teSksIDApO1xcbiAgfVxcbiAgdG8ge1xcbiAgICB2aXNpYmlsaXR5OiBoaWRkZW47XFxuICAgIHRyYW5zZm9ybTogdHJhbnNsYXRlM2QoMCwgLTUwMHB4LCAwKTtcXG4gIH1cXG59XFxuXFxuLlRvYXN0aWZ5X19zbGlkZS1lbnRlci0tdG9wLWxlZnQsXFxuLlRvYXN0aWZ5X19zbGlkZS1lbnRlci0tYm90dG9tLWxlZnQge1xcbiAgYW5pbWF0aW9uLW5hbWU6IFRvYXN0aWZ5X19zbGlkZUluTGVmdDtcXG59XFxuXFxuLlRvYXN0aWZ5X19zbGlkZS1lbnRlci0tdG9wLXJpZ2h0LFxcbi5Ub2FzdGlmeV9fc2xpZGUtZW50ZXItLWJvdHRvbS1yaWdodCB7XFxuICBhbmltYXRpb24tbmFtZTogVG9hc3RpZnlfX3NsaWRlSW5SaWdodDtcXG59XFxuXFxuLlRvYXN0aWZ5X19zbGlkZS1lbnRlci0tdG9wLWNlbnRlciB7XFxuICBhbmltYXRpb24tbmFtZTogVG9hc3RpZnlfX3NsaWRlSW5Eb3duO1xcbn1cXG5cXG4uVG9hc3RpZnlfX3NsaWRlLWVudGVyLS1ib3R0b20tY2VudGVyIHtcXG4gIGFuaW1hdGlvbi1uYW1lOiBUb2FzdGlmeV9fc2xpZGVJblVwO1xcbn1cXG5cXG4uVG9hc3RpZnlfX3NsaWRlLWV4aXQtLXRvcC1sZWZ0LFxcbi5Ub2FzdGlmeV9fc2xpZGUtZXhpdC0tYm90dG9tLWxlZnQge1xcbiAgYW5pbWF0aW9uLW5hbWU6IFRvYXN0aWZ5X19zbGlkZU91dExlZnQ7XFxuICBhbmltYXRpb24tdGltaW5nLWZ1bmN0aW9uOiBlYXNlLWluO1xcbiAgYW5pbWF0aW9uLWR1cmF0aW9uOiAwLjNzO1xcbn1cXG5cXG4uVG9hc3RpZnlfX3NsaWRlLWV4aXQtLXRvcC1yaWdodCxcXG4uVG9hc3RpZnlfX3NsaWRlLWV4aXQtLWJvdHRvbS1yaWdodCB7XFxuICBhbmltYXRpb24tbmFtZTogVG9hc3RpZnlfX3NsaWRlT3V0UmlnaHQ7XFxuICBhbmltYXRpb24tdGltaW5nLWZ1bmN0aW9uOiBlYXNlLWluO1xcbiAgYW5pbWF0aW9uLWR1cmF0aW9uOiAwLjNzO1xcbn1cXG5cXG4uVG9hc3RpZnlfX3NsaWRlLWV4aXQtLXRvcC1jZW50ZXIge1xcbiAgYW5pbWF0aW9uLW5hbWU6IFRvYXN0aWZ5X19zbGlkZU91dFVwO1xcbiAgYW5pbWF0aW9uLXRpbWluZy1mdW5jdGlvbjogZWFzZS1pbjtcXG4gIGFuaW1hdGlvbi1kdXJhdGlvbjogMC4zcztcXG59XFxuXFxuLlRvYXN0aWZ5X19zbGlkZS1leGl0LS1ib3R0b20tY2VudGVyIHtcXG4gIGFuaW1hdGlvbi1uYW1lOiBUb2FzdGlmeV9fc2xpZGVPdXREb3duO1xcbiAgYW5pbWF0aW9uLXRpbWluZy1mdW5jdGlvbjogZWFzZS1pbjtcXG4gIGFuaW1hdGlvbi1kdXJhdGlvbjogMC4zcztcXG59XFxuXFxuQGtleWZyYW1lcyBUb2FzdGlmeV9fc3BpbiB7XFxuICBmcm9tIHtcXG4gICAgdHJhbnNmb3JtOiByb3RhdGUoMGRlZyk7XFxuICB9XFxuICB0byB7XFxuICAgIHRyYW5zZm9ybTogcm90YXRlKDM2MGRlZyk7XFxuICB9XFxufVxcblwiXSxcInNvdXJjZVJvb3RcIjpcIlwifV0pO1xuLy8gRXhwb3J0c1xuZXhwb3J0IGRlZmF1bHQgX19fQ1NTX0xPQURFUl9FWFBPUlRfX187XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/next/dist/build/webpack/loaders/css-loader/src/index.js??ruleSet[1].rules[7].oneOf[12].use[1]!./node_modules/next/dist/build/webpack/loaders/postcss-loader/src/index.js??ruleSet[1].rules[7].oneOf[12].use[2]!./node_modules/react-toastify/dist/ReactToastify.css\n"));

/***/ }),

/***/ "./node_modules/next/dist/build/webpack/loaders/css-loader/src/index.js??ruleSet[1].rules[7].oneOf[14].use[1]!./node_modules/next/dist/build/webpack/loaders/postcss-loader/src/index.js??ruleSet[1].rules[7].oneOf[14].use[2]!./styles/globals.css":
/*!**********************************************************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/next/dist/build/webpack/loaders/css-loader/src/index.js??ruleSet[1].rules[7].oneOf[14].use[1]!./node_modules/next/dist/build/webpack/loaders/postcss-loader/src/index.js??ruleSet[1].rules[7].oneOf[14].use[2]!./styles/globals.css ***!
  \**********************************************************************************************************************************************************************************************************************************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _node_modules_next_dist_build_webpack_loaders_css_loader_src_runtime_api_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../node_modules/next/dist/build/webpack/loaders/css-loader/src/runtime/api.js */ \"./node_modules/next/dist/build/webpack/loaders/css-loader/src/runtime/api.js\");\n/* harmony import */ var _node_modules_next_dist_build_webpack_loaders_css_loader_src_runtime_api_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_next_dist_build_webpack_loaders_css_loader_src_runtime_api_js__WEBPACK_IMPORTED_MODULE_0__);\n// Imports\n\nvar ___CSS_LOADER_EXPORT___ = _node_modules_next_dist_build_webpack_loaders_css_loader_src_runtime_api_js__WEBPACK_IMPORTED_MODULE_0___default()(true);\n// Module\n___CSS_LOADER_EXPORT___.push([module.id, \"/*! tailwindcss v4.1.10 | MIT License | https://tailwindcss.com */\\n@import url('https://rsms.me/inter/inter.css');\\n@layer properties;\\n@layer theme, base, components, utilities;\\n@layer theme {\\n  :root, :host {\\n    --font-sans: ui-sans-serif, system-ui, sans-serif, \\\"Apple Color Emoji\\\",\\n      \\\"Segoe UI Emoji\\\", \\\"Segoe UI Symbol\\\", \\\"Noto Color Emoji\\\";\\n    --font-mono: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, \\\"Liberation Mono\\\",\\n      \\\"Courier New\\\", monospace;\\n    --color-red-50: oklch(97.1% 0.013 17.38);\\n    --color-red-200: oklch(88.5% 0.062 18.334);\\n    --color-red-500: oklch(63.7% 0.237 25.331);\\n    --color-red-600: oklch(57.7% 0.245 27.325);\\n    --color-red-700: oklch(50.5% 0.213 27.518);\\n    --color-yellow-100: oklch(97.3% 0.071 103.193);\\n    --color-yellow-300: oklch(90.5% 0.182 98.111);\\n    --color-yellow-400: oklch(85.2% 0.199 91.936);\\n    --color-yellow-800: oklch(47.6% 0.114 61.907);\\n    --color-green-100: oklch(96.2% 0.044 156.743);\\n    --color-green-300: oklch(87.1% 0.15 154.449);\\n    --color-green-500: oklch(72.3% 0.219 149.579);\\n    --color-green-700: oklch(52.7% 0.154 150.069);\\n    --color-blue-50: #EAF2FC;\\n    --color-blue-100: #D5E5F8;\\n    --color-blue-200: #A4C5F4;\\n    --color-blue-300: #7EABEF;\\n    --color-blue-400: #5F96EB;\\n    --color-blue-500: #4A86E8;\\n    --color-blue-600: #2A5DB0;\\n    --color-blue-700: #1E4484;\\n    --color-blue-800: #163366;\\n    --color-purple-300: oklch(82.7% 0.119 306.383);\\n    --color-purple-500: oklch(62.7% 0.265 303.9);\\n    --color-gray-50: #F5F8FA;\\n    --color-gray-100: #E9EFF5;\\n    --color-gray-200: #D9E2EC;\\n    --color-gray-300: #CBD5E0;\\n    --color-gray-400: #9FB3C8;\\n    --color-gray-500: #7D8FAF;\\n    --color-gray-600: #546785;\\n    --color-gray-700: #3D4B66;\\n    --color-gray-800: #2D3748;\\n    --color-gray-900: #1A202C;\\n    --color-black: #000;\\n    --color-white: #fff;\\n    --spacing: 0.25rem;\\n    --container-md: 28rem;\\n    --container-2xl: 42rem;\\n    --text-xs: 0.75rem;\\n    --text-xs--line-height: calc(1 / 0.75);\\n    --text-sm: 0.875rem;\\n    --text-sm--line-height: calc(1.25 / 0.875);\\n    --text-lg: 1.125rem;\\n    --text-lg--line-height: calc(1.75 / 1.125);\\n    --text-xl: 1.25rem;\\n    --text-xl--line-height: calc(1.75 / 1.25);\\n    --text-2xl: 1.5rem;\\n    --text-2xl--line-height: calc(2 / 1.5);\\n    --text-3xl: 1.875rem;\\n    --text-3xl--line-height: calc(2.25 / 1.875);\\n    --font-weight-light: 300;\\n    --font-weight-medium: 500;\\n    --font-weight-semibold: 600;\\n    --font-weight-bold: 700;\\n    --leading-tight: 1.25;\\n    --radius-sm: 0.25rem;\\n    --radius-md: 0.375rem;\\n    --radius-lg: 0.5rem;\\n    --radius-xl: 0.75rem;\\n    --ease-in-out: cubic-bezier(0.4, 0, 0.2, 1);\\n    --blur-sm: 8px;\\n    --default-transition-duration: 150ms;\\n    --default-transition-timing-function: cubic-bezier(0.4, 0, 0.2, 1);\\n    --default-font-family: var(--font-sans);\\n    --default-mono-font-family: var(--font-mono);\\n    --spacing-0: 0px;\\n    --spacing-1: 0.25rem;\\n    --spacing-2: 0.5rem;\\n    --spacing-3: 0.75rem;\\n    --spacing-4: 1rem;\\n    --spacing-5: 1.25rem;\\n    --spacing-6: 1.5rem;\\n    --spacing-8: 2rem;\\n    --spacing-10: 2.5rem;\\n    --font-family-sans: 'Inter var', sans-serif;\\n  }\\n}\\n@layer base {\\n  *, ::after, ::before, ::backdrop, ::file-selector-button {\\n    box-sizing: border-box;\\n    margin: 0;\\n    padding: 0;\\n    border: 0 solid;\\n  }\\n  html, :host {\\n    line-height: 1.5;\\n    -webkit-text-size-adjust: 100%;\\n    -moz-tab-size: 4;\\n      -o-tab-size: 4;\\n         tab-size: 4;\\n    font-family: var(--default-font-family, ui-sans-serif, system-ui, sans-serif, \\\"Apple Color Emoji\\\", \\\"Segoe UI Emoji\\\", \\\"Segoe UI Symbol\\\", \\\"Noto Color Emoji\\\");\\n    font-feature-settings: var(--default-font-feature-settings, normal);\\n    font-variation-settings: var(--default-font-variation-settings, normal);\\n    -webkit-tap-highlight-color: transparent;\\n  }\\n  hr {\\n    height: 0;\\n    color: inherit;\\n    border-top-width: 1px;\\n  }\\n  abbr:where([title]) {\\n    -webkit-text-decoration: underline dotted;\\n    text-decoration: underline dotted;\\n  }\\n  h1, h2, h3, h4, h5, h6 {\\n    font-size: inherit;\\n    font-weight: inherit;\\n  }\\n  a {\\n    color: inherit;\\n    -webkit-text-decoration: inherit;\\n    text-decoration: inherit;\\n  }\\n  b, strong {\\n    font-weight: bolder;\\n  }\\n  code, kbd, samp, pre {\\n    font-family: var(--default-mono-font-family, ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, \\\"Liberation Mono\\\", \\\"Courier New\\\", monospace);\\n    font-feature-settings: var(--default-mono-font-feature-settings, normal);\\n    font-variation-settings: var(--default-mono-font-variation-settings, normal);\\n    font-size: 1em;\\n  }\\n  small {\\n    font-size: 80%;\\n  }\\n  sub, sup {\\n    font-size: 75%;\\n    line-height: 0;\\n    position: relative;\\n    vertical-align: baseline;\\n  }\\n  sub {\\n    bottom: -0.25em;\\n  }\\n  sup {\\n    top: -0.5em;\\n  }\\n  table {\\n    text-indent: 0;\\n    border-color: inherit;\\n    border-collapse: collapse;\\n  }\\n  :-moz-focusring {\\n    outline: auto;\\n  }\\n  progress {\\n    vertical-align: baseline;\\n  }\\n  summary {\\n    display: list-item;\\n  }\\n  ol, ul, menu {\\n    list-style: none;\\n  }\\n  img, svg, video, canvas, audio, iframe, embed, object {\\n    display: block;\\n    vertical-align: middle;\\n  }\\n  img, video {\\n    max-width: 100%;\\n    height: auto;\\n  }\\n  button, input, select, optgroup, textarea, ::file-selector-button {\\n    font: inherit;\\n    font-feature-settings: inherit;\\n    font-variation-settings: inherit;\\n    letter-spacing: inherit;\\n    color: inherit;\\n    border-radius: 0;\\n    background-color: transparent;\\n    opacity: 1;\\n  }\\n  :where(select:is([multiple], [size])) optgroup {\\n    font-weight: bolder;\\n  }\\n  :where(select:is([multiple], [size])) optgroup option {\\n    padding-inline-start: 20px;\\n  }\\n  ::file-selector-button {\\n    margin-inline-end: 4px;\\n  }\\n  ::-moz-placeholder {\\n    opacity: 1;\\n  }\\n  ::placeholder {\\n    opacity: 1;\\n  }\\n  @supports (not (-webkit-appearance: -apple-pay-button))  or (contain-intrinsic-size: 1px) {\\n    ::-moz-placeholder {\\n      color: currentcolor;\\n      @supports (color: color-mix(in lab, red, red)) {\\n        color: color-mix(in oklab, currentcolor 50%, transparent);\\n      }\\n    }\\n    ::placeholder {\\n      color: currentcolor;\\n      @supports (color: color-mix(in lab, red, red)) {\\n        color: color-mix(in oklab, currentcolor 50%, transparent);\\n      }\\n    }\\n  }\\n  textarea {\\n    resize: vertical;\\n  }\\n  ::-webkit-search-decoration {\\n    -webkit-appearance: none;\\n  }\\n  ::-webkit-date-and-time-value {\\n    min-height: 1lh;\\n    text-align: inherit;\\n  }\\n  ::-webkit-datetime-edit {\\n    display: inline-flex;\\n  }\\n  ::-webkit-datetime-edit-fields-wrapper {\\n    padding: 0;\\n  }\\n  ::-webkit-datetime-edit, ::-webkit-datetime-edit-year-field, ::-webkit-datetime-edit-month-field, ::-webkit-datetime-edit-day-field, ::-webkit-datetime-edit-hour-field, ::-webkit-datetime-edit-minute-field, ::-webkit-datetime-edit-second-field, ::-webkit-datetime-edit-millisecond-field, ::-webkit-datetime-edit-meridiem-field {\\n    padding-block: 0;\\n  }\\n  :-moz-ui-invalid {\\n    box-shadow: none;\\n  }\\n  button, input:where([type=\\\"button\\\"], [type=\\\"reset\\\"], [type=\\\"submit\\\"]), ::file-selector-button {\\n    -webkit-appearance: button;\\n       -moz-appearance: button;\\n            appearance: button;\\n  }\\n  ::-webkit-inner-spin-button, ::-webkit-outer-spin-button {\\n    height: auto;\\n  }\\n  [hidden]:where(:not([hidden=\\\"until-found\\\"])) {\\n    display: none !important;\\n  }\\n}\\n@layer utilities {\\n  .pointer-events-none {\\n    pointer-events: none;\\n  }\\n  .collapse {\\n    visibility: collapse;\\n  }\\n  .invisible {\\n    visibility: hidden;\\n  }\\n  .visible {\\n    visibility: visible;\\n  }\\n  .absolute {\\n    position: absolute;\\n  }\\n  .fixed {\\n    position: fixed;\\n  }\\n  .relative {\\n    position: relative;\\n  }\\n  .static {\\n    position: static;\\n  }\\n  .sticky {\\n    position: sticky;\\n  }\\n  .inset-0 {\\n    inset: var(--spacing-0);\\n  }\\n  .top-0 {\\n    top: var(--spacing-0);\\n  }\\n  .top-1\\\\/2 {\\n    top: calc(1/2 * 100%);\\n  }\\n  .top-2 {\\n    top: var(--spacing-2);\\n  }\\n  .top-4 {\\n    top: var(--spacing-4);\\n  }\\n  .right-0 {\\n    right: var(--spacing-0);\\n  }\\n  .right-2 {\\n    right: var(--spacing-2);\\n  }\\n  .right-3 {\\n    right: var(--spacing-3);\\n  }\\n  .right-4 {\\n    right: var(--spacing-4);\\n  }\\n  .-bottom-1 {\\n    bottom: calc(var(--spacing-1) * -1);\\n  }\\n  .bottom-0 {\\n    bottom: var(--spacing-0);\\n  }\\n  .bottom-6 {\\n    bottom: var(--spacing-6);\\n  }\\n  .bottom-8 {\\n    bottom: var(--spacing-8);\\n  }\\n  .bottom-full {\\n    bottom: 100%;\\n  }\\n  .left-0 {\\n    left: var(--spacing-0);\\n  }\\n  .left-1\\\\/2 {\\n    left: calc(1/2 * 100%);\\n  }\\n  .z-10 {\\n    z-index: 10;\\n  }\\n  .z-20 {\\n    z-index: 20;\\n  }\\n  .z-30 {\\n    z-index: 30;\\n  }\\n  .z-50 {\\n    z-index: 50;\\n  }\\n  .container {\\n    width: 100%;\\n    @media (width >= 40rem) {\\n      max-width: 40rem;\\n    }\\n    @media (width >= 48rem) {\\n      max-width: 48rem;\\n    }\\n    @media (width >= 64rem) {\\n      max-width: 64rem;\\n    }\\n    @media (width >= 80rem) {\\n      max-width: 80rem;\\n    }\\n    @media (width >= 96rem) {\\n      max-width: 96rem;\\n    }\\n  }\\n  .mx-1 {\\n    margin-inline: var(--spacing-1);\\n  }\\n  .mt-1 {\\n    margin-top: var(--spacing-1);\\n  }\\n  .mt-2 {\\n    margin-top: var(--spacing-2);\\n  }\\n  .mt-4 {\\n    margin-top: var(--spacing-4);\\n  }\\n  .mt-6 {\\n    margin-top: var(--spacing-6);\\n  }\\n  .mt-8 {\\n    margin-top: var(--spacing-8);\\n  }\\n  .mt-auto {\\n    margin-top: auto;\\n  }\\n  .mr-1 {\\n    margin-right: var(--spacing-1);\\n  }\\n  .mr-2 {\\n    margin-right: var(--spacing-2);\\n  }\\n  .mb-1 {\\n    margin-bottom: var(--spacing-1);\\n  }\\n  .mb-2 {\\n    margin-bottom: var(--spacing-2);\\n  }\\n  .mb-3 {\\n    margin-bottom: var(--spacing-3);\\n  }\\n  .mb-4 {\\n    margin-bottom: var(--spacing-4);\\n  }\\n  .mb-6 {\\n    margin-bottom: var(--spacing-6);\\n  }\\n  .mb-8 {\\n    margin-bottom: var(--spacing-8);\\n  }\\n  .ml-1 {\\n    margin-left: var(--spacing-1);\\n  }\\n  .ml-2 {\\n    margin-left: var(--spacing-2);\\n  }\\n  .block {\\n    display: block;\\n  }\\n  .contents {\\n    display: contents;\\n  }\\n  .flex {\\n    display: flex;\\n  }\\n  .grid {\\n    display: grid;\\n  }\\n  .hidden {\\n    display: none;\\n  }\\n  .inline {\\n    display: inline;\\n  }\\n  .inline-block {\\n    display: inline-block;\\n  }\\n  .table {\\n    display: table;\\n  }\\n  .h-1 {\\n    height: var(--spacing-1);\\n  }\\n  .h-2 {\\n    height: var(--spacing-2);\\n  }\\n  .h-2\\\\.5 {\\n    height: calc(var(--spacing) * 2.5);\\n  }\\n  .h-3 {\\n    height: var(--spacing-3);\\n  }\\n  .h-4 {\\n    height: var(--spacing-4);\\n  }\\n  .h-5 {\\n    height: var(--spacing-5);\\n  }\\n  .h-6 {\\n    height: var(--spacing-6);\\n  }\\n  .h-8 {\\n    height: var(--spacing-8);\\n  }\\n  .h-10 {\\n    height: var(--spacing-10);\\n  }\\n  .h-24 {\\n    height: calc(var(--spacing) * 24);\\n  }\\n  .h-64 {\\n    height: calc(var(--spacing) * 64);\\n  }\\n  .h-full {\\n    height: 100%;\\n  }\\n  .h-screen {\\n    height: 100vh;\\n  }\\n  .max-h-32 {\\n    max-height: calc(var(--spacing) * 32);\\n  }\\n  .max-h-60 {\\n    max-height: calc(var(--spacing) * 60);\\n  }\\n  .max-h-\\\\[90vh\\\\] {\\n    max-height: 90vh;\\n  }\\n  .min-h-full {\\n    min-height: 100%;\\n  }\\n  .min-h-screen {\\n    min-height: 100vh;\\n  }\\n  .w-1 {\\n    width: var(--spacing-1);\\n  }\\n  .w-2\\\\.5 {\\n    width: calc(var(--spacing) * 2.5);\\n  }\\n  .w-3 {\\n    width: var(--spacing-3);\\n  }\\n  .w-4 {\\n    width: var(--spacing-4);\\n  }\\n  .w-5 {\\n    width: var(--spacing-5);\\n  }\\n  .w-6 {\\n    width: var(--spacing-6);\\n  }\\n  .w-8 {\\n    width: var(--spacing-8);\\n  }\\n  .w-10 {\\n    width: var(--spacing-10);\\n  }\\n  .w-11\\\\/12 {\\n    width: calc(11/12 * 100%);\\n  }\\n  .w-64 {\\n    width: calc(var(--spacing) * 64);\\n  }\\n  .w-full {\\n    width: 100%;\\n  }\\n  .max-w-2xl {\\n    max-width: var(--container-2xl);\\n  }\\n  .max-w-\\\\[80\\\\%\\\\] {\\n    max-width: 80%;\\n  }\\n  .max-w-\\\\[calc\\\\(100\\\\%-2rem\\\\)\\\\] {\\n    max-width: calc(100% - 2rem);\\n  }\\n  .max-w-full {\\n    max-width: 100%;\\n  }\\n  .max-w-md {\\n    max-width: var(--container-md);\\n  }\\n  .flex-1 {\\n    flex: 1;\\n  }\\n  .flex-shrink-0 {\\n    flex-shrink: 0;\\n  }\\n  .shrink-0 {\\n    flex-shrink: 0;\\n  }\\n  .flex-grow {\\n    flex-grow: 1;\\n  }\\n  .-translate-x-1\\\\/2 {\\n    --tw-translate-x: calc(calc(1/2 * 100%) * -1);\\n    translate: var(--tw-translate-x) var(--tw-translate-y);\\n  }\\n  .-translate-y-1\\\\/2 {\\n    --tw-translate-y: calc(calc(1/2 * 100%) * -1);\\n    translate: var(--tw-translate-x) var(--tw-translate-y);\\n  }\\n  .translate-y-0 {\\n    --tw-translate-y: var(--spacing-0);\\n    translate: var(--tw-translate-x) var(--tw-translate-y);\\n  }\\n  .translate-y-4 {\\n    --tw-translate-y: var(--spacing-4);\\n    translate: var(--tw-translate-x) var(--tw-translate-y);\\n  }\\n  .scale-95 {\\n    --tw-scale-x: 95%;\\n    --tw-scale-y: 95%;\\n    --tw-scale-z: 95%;\\n    scale: var(--tw-scale-x) var(--tw-scale-y);\\n  }\\n  .scale-100 {\\n    --tw-scale-x: 100%;\\n    --tw-scale-y: 100%;\\n    --tw-scale-z: 100%;\\n    scale: var(--tw-scale-x) var(--tw-scale-y);\\n  }\\n  .rotate-180 {\\n    rotate: 180deg;\\n  }\\n  .transform {\\n    transform: var(--tw-rotate-x,) var(--tw-rotate-y,) var(--tw-rotate-z,) var(--tw-skew-x,) var(--tw-skew-y,);\\n  }\\n  .cursor-not-allowed {\\n    cursor: not-allowed;\\n  }\\n  .cursor-pointer {\\n    cursor: pointer;\\n  }\\n  .resize {\\n    resize: both;\\n  }\\n  .resize-none {\\n    resize: none;\\n  }\\n  .list-disc {\\n    list-style-type: disc;\\n  }\\n  .appearance-none {\\n    -webkit-appearance: none;\\n       -moz-appearance: none;\\n            appearance: none;\\n  }\\n  .grid-cols-2 {\\n    grid-template-columns: repeat(2, minmax(0, 1fr));\\n  }\\n  .flex-col {\\n    flex-direction: column;\\n  }\\n  .flex-row {\\n    flex-direction: row;\\n  }\\n  .flex-wrap {\\n    flex-wrap: wrap;\\n  }\\n  .items-baseline {\\n    align-items: baseline;\\n  }\\n  .items-center {\\n    align-items: center;\\n  }\\n  .justify-between {\\n    justify-content: space-between;\\n  }\\n  .justify-center {\\n    justify-content: center;\\n  }\\n  .justify-end {\\n    justify-content: flex-end;\\n  }\\n  .gap-1 {\\n    gap: var(--spacing-1);\\n  }\\n  .gap-2 {\\n    gap: var(--spacing-2);\\n  }\\n  .gap-3 {\\n    gap: var(--spacing-3);\\n  }\\n  .gap-4 {\\n    gap: var(--spacing-4);\\n  }\\n  .-space-y-1 {\\n    :where(& > :not(:last-child)) {\\n      --tw-space-y-reverse: 0;\\n      margin-block-start: calc(calc(var(--spacing-1) * -1) * var(--tw-space-y-reverse));\\n      margin-block-end: calc(calc(var(--spacing-1) * -1) * calc(1 - var(--tw-space-y-reverse)));\\n    }\\n  }\\n  .space-y-1 {\\n    :where(& > :not(:last-child)) {\\n      --tw-space-y-reverse: 0;\\n      margin-block-start: calc(var(--spacing-1) * var(--tw-space-y-reverse));\\n      margin-block-end: calc(var(--spacing-1) * calc(1 - var(--tw-space-y-reverse)));\\n    }\\n  }\\n  .space-y-2 {\\n    :where(& > :not(:last-child)) {\\n      --tw-space-y-reverse: 0;\\n      margin-block-start: calc(var(--spacing-2) * var(--tw-space-y-reverse));\\n      margin-block-end: calc(var(--spacing-2) * calc(1 - var(--tw-space-y-reverse)));\\n    }\\n  }\\n  .space-y-4 {\\n    :where(& > :not(:last-child)) {\\n      --tw-space-y-reverse: 0;\\n      margin-block-start: calc(var(--spacing-4) * var(--tw-space-y-reverse));\\n      margin-block-end: calc(var(--spacing-4) * calc(1 - var(--tw-space-y-reverse)));\\n    }\\n  }\\n  .space-x-2 {\\n    :where(& > :not(:last-child)) {\\n      --tw-space-x-reverse: 0;\\n      margin-inline-start: calc(var(--spacing-2) * var(--tw-space-x-reverse));\\n      margin-inline-end: calc(var(--spacing-2) * calc(1 - var(--tw-space-x-reverse)));\\n    }\\n  }\\n  .space-x-4 {\\n    :where(& > :not(:last-child)) {\\n      --tw-space-x-reverse: 0;\\n      margin-inline-start: calc(var(--spacing-4) * var(--tw-space-x-reverse));\\n      margin-inline-end: calc(var(--spacing-4) * calc(1 - var(--tw-space-x-reverse)));\\n    }\\n  }\\n  .truncate {\\n    overflow: hidden;\\n    text-overflow: ellipsis;\\n    white-space: nowrap;\\n  }\\n  .overflow-auto {\\n    overflow: auto;\\n  }\\n  .overflow-hidden {\\n    overflow: hidden;\\n  }\\n  .overflow-x-hidden {\\n    overflow-x: hidden;\\n  }\\n  .overflow-y-auto {\\n    overflow-y: auto;\\n  }\\n  .rounded {\\n    border-radius: 0.25rem;\\n  }\\n  .rounded-full {\\n    border-radius: calc(infinity * 1px);\\n  }\\n  .rounded-lg {\\n    border-radius: var(--radius-lg);\\n  }\\n  .rounded-md {\\n    border-radius: var(--radius-md);\\n  }\\n  .rounded-sm {\\n    border-radius: var(--radius-sm);\\n  }\\n  .rounded-xl {\\n    border-radius: var(--radius-xl);\\n  }\\n  .rounded-l-md {\\n    border-top-left-radius: var(--radius-md);\\n    border-bottom-left-radius: var(--radius-md);\\n  }\\n  .rounded-r-md {\\n    border-top-right-radius: var(--radius-md);\\n    border-bottom-right-radius: var(--radius-md);\\n  }\\n  .border {\\n    border-style: var(--tw-border-style);\\n    border-width: 1px;\\n  }\\n  .border-0 {\\n    border-style: var(--tw-border-style);\\n    border-width: 0px;\\n  }\\n  .border-2 {\\n    border-style: var(--tw-border-style);\\n    border-width: 2px;\\n  }\\n  .border-t {\\n    border-top-style: var(--tw-border-style);\\n    border-top-width: 1px;\\n  }\\n  .border-r {\\n    border-right-style: var(--tw-border-style);\\n    border-right-width: 1px;\\n  }\\n  .border-b {\\n    border-bottom-style: var(--tw-border-style);\\n    border-bottom-width: 1px;\\n  }\\n  .border-b-2 {\\n    border-bottom-style: var(--tw-border-style);\\n    border-bottom-width: 2px;\\n  }\\n  .border-dashed {\\n    --tw-border-style: dashed;\\n    border-style: dashed;\\n  }\\n  .border-blue-100 {\\n    border-color: var(--color-blue-100);\\n  }\\n  .border-blue-200 {\\n    border-color: var(--color-blue-200);\\n  }\\n  .border-blue-300 {\\n    border-color: var(--color-blue-300);\\n  }\\n  .border-blue-500 {\\n    border-color: var(--color-blue-500);\\n  }\\n  .border-gray-100 {\\n    border-color: var(--color-gray-100);\\n  }\\n  .border-gray-200 {\\n    border-color: var(--color-gray-200);\\n  }\\n  .border-gray-700 {\\n    border-color: var(--color-gray-700);\\n  }\\n  .border-red-200 {\\n    border-color: var(--color-red-200);\\n  }\\n  .border-white {\\n    border-color: var(--color-white);\\n  }\\n  .border-yellow-300 {\\n    border-color: var(--color-yellow-300);\\n  }\\n  .bg-black {\\n    background-color: var(--color-black);\\n  }\\n  .bg-black\\\\/0 {\\n    background-color: color-mix(in srgb, #000 0%, transparent);\\n    @supports (color: color-mix(in lab, red, red)) {\\n      background-color: color-mix(in oklab, var(--color-black) 0%, transparent);\\n    }\\n  }\\n  .bg-black\\\\/30 {\\n    background-color: color-mix(in srgb, #000 30%, transparent);\\n    @supports (color: color-mix(in lab, red, red)) {\\n      background-color: color-mix(in oklab, var(--color-black) 30%, transparent);\\n    }\\n  }\\n  .bg-blue-50 {\\n    background-color: var(--color-blue-50);\\n  }\\n  .bg-blue-100 {\\n    background-color: var(--color-blue-100);\\n  }\\n  .bg-blue-500 {\\n    background-color: var(--color-blue-500);\\n  }\\n  .bg-blue-600 {\\n    background-color: var(--color-blue-600);\\n  }\\n  .bg-blue-700 {\\n    background-color: var(--color-blue-700);\\n  }\\n  .bg-gray-50 {\\n    background-color: var(--color-gray-50);\\n  }\\n  .bg-gray-100 {\\n    background-color: var(--color-gray-100);\\n  }\\n  .bg-gray-200 {\\n    background-color: var(--color-gray-200);\\n  }\\n  .bg-gray-800 {\\n    background-color: var(--color-gray-800);\\n  }\\n  .bg-green-100 {\\n    background-color: var(--color-green-100);\\n  }\\n  .bg-green-500 {\\n    background-color: var(--color-green-500);\\n  }\\n  .bg-purple-500 {\\n    background-color: var(--color-purple-500);\\n  }\\n  .bg-red-50 {\\n    background-color: var(--color-red-50);\\n  }\\n  .bg-red-600 {\\n    background-color: var(--color-red-600);\\n  }\\n  .bg-transparent {\\n    background-color: transparent;\\n  }\\n  .bg-white {\\n    background-color: var(--color-white);\\n  }\\n  .bg-white\\\\/80 {\\n    background-color: color-mix(in srgb, #fff 80%, transparent);\\n    @supports (color: color-mix(in lab, red, red)) {\\n      background-color: color-mix(in oklab, var(--color-white) 80%, transparent);\\n    }\\n  }\\n  .bg-white\\\\/90 {\\n    background-color: color-mix(in srgb, #fff 90%, transparent);\\n    @supports (color: color-mix(in lab, red, red)) {\\n      background-color: color-mix(in oklab, var(--color-white) 90%, transparent);\\n    }\\n  }\\n  .bg-yellow-100 {\\n    background-color: var(--color-yellow-100);\\n  }\\n  .bg-yellow-400 {\\n    background-color: var(--color-yellow-400);\\n  }\\n  .bg-gradient-to-r {\\n    --tw-gradient-position: to right in oklab;\\n    background-image: linear-gradient(var(--tw-gradient-stops));\\n  }\\n  .from-blue-300 {\\n    --tw-gradient-from: var(--color-blue-300);\\n    --tw-gradient-stops: var(--tw-gradient-via-stops, var(--tw-gradient-position), var(--tw-gradient-from) var(--tw-gradient-from-position), var(--tw-gradient-to) var(--tw-gradient-to-position));\\n  }\\n  .from-blue-500 {\\n    --tw-gradient-from: var(--color-blue-500);\\n    --tw-gradient-stops: var(--tw-gradient-via-stops, var(--tw-gradient-position), var(--tw-gradient-from) var(--tw-gradient-from-position), var(--tw-gradient-to) var(--tw-gradient-to-position));\\n  }\\n  .from-green-300 {\\n    --tw-gradient-from: var(--color-green-300);\\n    --tw-gradient-stops: var(--tw-gradient-via-stops, var(--tw-gradient-position), var(--tw-gradient-from) var(--tw-gradient-from-position), var(--tw-gradient-to) var(--tw-gradient-to-position));\\n  }\\n  .from-purple-300 {\\n    --tw-gradient-from: var(--color-purple-300);\\n    --tw-gradient-stops: var(--tw-gradient-via-stops, var(--tw-gradient-position), var(--tw-gradient-from) var(--tw-gradient-from-position), var(--tw-gradient-to) var(--tw-gradient-to-position));\\n  }\\n  .to-blue-300 {\\n    --tw-gradient-to: var(--color-blue-300);\\n    --tw-gradient-stops: var(--tw-gradient-via-stops, var(--tw-gradient-position), var(--tw-gradient-from) var(--tw-gradient-from-position), var(--tw-gradient-to) var(--tw-gradient-to-position));\\n  }\\n  .to-blue-500 {\\n    --tw-gradient-to: var(--color-blue-500);\\n    --tw-gradient-stops: var(--tw-gradient-via-stops, var(--tw-gradient-position), var(--tw-gradient-from) var(--tw-gradient-from-position), var(--tw-gradient-to) var(--tw-gradient-to-position));\\n  }\\n  .to-green-500 {\\n    --tw-gradient-to: var(--color-green-500);\\n    --tw-gradient-stops: var(--tw-gradient-via-stops, var(--tw-gradient-position), var(--tw-gradient-from) var(--tw-gradient-from-position), var(--tw-gradient-to) var(--tw-gradient-to-position));\\n  }\\n  .to-purple-500 {\\n    --tw-gradient-to: var(--color-purple-500);\\n    --tw-gradient-stops: var(--tw-gradient-via-stops, var(--tw-gradient-position), var(--tw-gradient-from) var(--tw-gradient-from-position), var(--tw-gradient-to) var(--tw-gradient-to-position));\\n  }\\n  .p-1 {\\n    padding: var(--spacing-1);\\n  }\\n  .p-2 {\\n    padding: var(--spacing-2);\\n  }\\n  .p-3 {\\n    padding: var(--spacing-3);\\n  }\\n  .p-4 {\\n    padding: var(--spacing-4);\\n  }\\n  .p-6 {\\n    padding: var(--spacing-6);\\n  }\\n  .p-8 {\\n    padding: var(--spacing-8);\\n  }\\n  .px-0\\\\.5 {\\n    padding-inline: calc(var(--spacing) * 0.5);\\n  }\\n  .px-1 {\\n    padding-inline: var(--spacing-1);\\n  }\\n  .px-2 {\\n    padding-inline: var(--spacing-2);\\n  }\\n  .px-3 {\\n    padding-inline: var(--spacing-3);\\n  }\\n  .px-4 {\\n    padding-inline: var(--spacing-4);\\n  }\\n  .px-6 {\\n    padding-inline: var(--spacing-6);\\n  }\\n  .py-0\\\\.5 {\\n    padding-block: calc(var(--spacing) * 0.5);\\n  }\\n  .py-1 {\\n    padding-block: var(--spacing-1);\\n  }\\n  .py-1\\\\.5 {\\n    padding-block: calc(var(--spacing) * 1.5);\\n  }\\n  .py-2 {\\n    padding-block: var(--spacing-2);\\n  }\\n  .py-3 {\\n    padding-block: var(--spacing-3);\\n  }\\n  .py-4 {\\n    padding-block: var(--spacing-4);\\n  }\\n  .py-px {\\n    padding-block: 1px;\\n  }\\n  .pt-1\\\\.5 {\\n    padding-top: calc(var(--spacing) * 1.5);\\n  }\\n  .pt-2 {\\n    padding-top: var(--spacing-2);\\n  }\\n  .pt-4 {\\n    padding-top: var(--spacing-4);\\n  }\\n  .pt-8 {\\n    padding-top: var(--spacing-8);\\n  }\\n  .pt-10 {\\n    padding-top: var(--spacing-10);\\n  }\\n  .pr-4 {\\n    padding-right: var(--spacing-4);\\n  }\\n  .pr-8 {\\n    padding-right: var(--spacing-8);\\n  }\\n  .pb-2 {\\n    padding-bottom: var(--spacing-2);\\n  }\\n  .pb-4 {\\n    padding-bottom: var(--spacing-4);\\n  }\\n  .pb-8 {\\n    padding-bottom: var(--spacing-8);\\n  }\\n  .pb-10 {\\n    padding-bottom: var(--spacing-10);\\n  }\\n  .pl-5 {\\n    padding-left: var(--spacing-5);\\n  }\\n  .pl-8 {\\n    padding-left: var(--spacing-8);\\n  }\\n  .text-center {\\n    text-align: center;\\n  }\\n  .text-left {\\n    text-align: left;\\n  }\\n  .text-right {\\n    text-align: right;\\n  }\\n  .font-mono {\\n    font-family: var(--font-mono);\\n  }\\n  .text-2xl {\\n    font-size: var(--text-2xl);\\n    line-height: var(--tw-leading, var(--text-2xl--line-height));\\n  }\\n  .text-3xl {\\n    font-size: var(--text-3xl);\\n    line-height: var(--tw-leading, var(--text-3xl--line-height));\\n  }\\n  .text-lg {\\n    font-size: var(--text-lg);\\n    line-height: var(--tw-leading, var(--text-lg--line-height));\\n  }\\n  .text-sm {\\n    font-size: var(--text-sm);\\n    line-height: var(--tw-leading, var(--text-sm--line-height));\\n  }\\n  .text-xl {\\n    font-size: var(--text-xl);\\n    line-height: var(--tw-leading, var(--text-xl--line-height));\\n  }\\n  .text-xs {\\n    font-size: var(--text-xs);\\n    line-height: var(--tw-leading, var(--text-xs--line-height));\\n  }\\n  .text-\\\\[0\\\\.6rem\\\\] {\\n    font-size: 0.6rem;\\n  }\\n  .text-\\\\[0\\\\.65rem\\\\] {\\n    font-size: 0.65rem;\\n  }\\n  .text-\\\\[0\\\\.75rem\\\\] {\\n    font-size: 0.75rem;\\n  }\\n  .text-\\\\[8px\\\\] {\\n    font-size: 8px;\\n  }\\n  .text-\\\\[10px\\\\] {\\n    font-size: 10px;\\n  }\\n  .leading-none {\\n    --tw-leading: 1;\\n    line-height: 1;\\n  }\\n  .leading-tight {\\n    --tw-leading: var(--leading-tight);\\n    line-height: var(--leading-tight);\\n  }\\n  .font-bold {\\n    --tw-font-weight: var(--font-weight-bold);\\n    font-weight: var(--font-weight-bold);\\n  }\\n  .font-light {\\n    --tw-font-weight: var(--font-weight-light);\\n    font-weight: var(--font-weight-light);\\n  }\\n  .font-medium {\\n    --tw-font-weight: var(--font-weight-medium);\\n    font-weight: var(--font-weight-medium);\\n  }\\n  .font-semibold {\\n    --tw-font-weight: var(--font-weight-semibold);\\n    font-weight: var(--font-weight-semibold);\\n  }\\n  .whitespace-normal {\\n    white-space: normal;\\n  }\\n  .whitespace-nowrap {\\n    white-space: nowrap;\\n  }\\n  .text-blue-400 {\\n    color: var(--color-blue-400);\\n  }\\n  .text-blue-500 {\\n    color: var(--color-blue-500);\\n  }\\n  .text-blue-600 {\\n    color: var(--color-blue-600);\\n  }\\n  .text-blue-700 {\\n    color: var(--color-blue-700);\\n  }\\n  .text-blue-800 {\\n    color: var(--color-blue-800);\\n  }\\n  .text-gray-400 {\\n    color: var(--color-gray-400);\\n  }\\n  .text-gray-500 {\\n    color: var(--color-gray-500);\\n  }\\n  .text-gray-600 {\\n    color: var(--color-gray-600);\\n  }\\n  .text-gray-700 {\\n    color: var(--color-gray-700);\\n  }\\n  .text-gray-800 {\\n    color: var(--color-gray-800);\\n  }\\n  .text-gray-900 {\\n    color: var(--color-gray-900);\\n  }\\n  .text-green-700 {\\n    color: var(--color-green-700);\\n  }\\n  .text-red-600 {\\n    color: var(--color-red-600);\\n  }\\n  .text-white {\\n    color: var(--color-white);\\n  }\\n  .text-yellow-800 {\\n    color: var(--color-yellow-800);\\n  }\\n  .capitalize {\\n    text-transform: capitalize;\\n  }\\n  .lowercase {\\n    text-transform: lowercase;\\n  }\\n  .uppercase {\\n    text-transform: uppercase;\\n  }\\n  .italic {\\n    font-style: italic;\\n  }\\n  .ordinal {\\n    --tw-ordinal: ordinal;\\n    font-variant-numeric: var(--tw-ordinal,) var(--tw-slashed-zero,) var(--tw-numeric-figure,) var(--tw-numeric-spacing,) var(--tw-numeric-fraction,);\\n  }\\n  .line-through {\\n    text-decoration-line: line-through;\\n  }\\n  .overline {\\n    text-decoration-line: overline;\\n  }\\n  .underline {\\n    text-decoration-line: underline;\\n  }\\n  .opacity-0 {\\n    opacity: 0%;\\n  }\\n  .opacity-50 {\\n    opacity: 50%;\\n  }\\n  .opacity-100 {\\n    opacity: 100%;\\n  }\\n  .shadow {\\n    --tw-shadow: 0 1px 3px 0 var(--tw-shadow-color, rgb(0 0 0 / 0.1)), 0 1px 2px -1px var(--tw-shadow-color, rgb(0 0 0 / 0.1));\\n    box-shadow: var(--tw-inset-shadow), var(--tw-inset-ring-shadow), var(--tw-ring-offset-shadow), var(--tw-ring-shadow), var(--tw-shadow);\\n  }\\n  .shadow-inner {\\n    --tw-shadow: inset 0 2px 4px 0 var(--tw-shadow-color, rgb(0 0 0 / 0.05));\\n    box-shadow: var(--tw-inset-shadow), var(--tw-inset-ring-shadow), var(--tw-ring-offset-shadow), var(--tw-ring-shadow), var(--tw-shadow);\\n  }\\n  .shadow-lg {\\n    --tw-shadow: 0 10px 15px -3px var(--tw-shadow-color, rgb(0 0 0 / 0.1)), 0 4px 6px -4px var(--tw-shadow-color, rgb(0 0 0 / 0.1));\\n    box-shadow: var(--tw-inset-shadow), var(--tw-inset-ring-shadow), var(--tw-ring-offset-shadow), var(--tw-ring-shadow), var(--tw-shadow);\\n  }\\n  .shadow-md {\\n    --tw-shadow: 0 4px 6px -1px var(--tw-shadow-color, rgb(0 0 0 / 0.1)), 0 2px 4px -2px var(--tw-shadow-color, rgb(0 0 0 / 0.1));\\n    box-shadow: var(--tw-inset-shadow), var(--tw-inset-ring-shadow), var(--tw-ring-offset-shadow), var(--tw-ring-shadow), var(--tw-shadow);\\n  }\\n  .shadow-sm {\\n    --tw-shadow: 0 1px 3px 0 var(--tw-shadow-color, rgb(0 0 0 / 0.1)), 0 1px 2px -1px var(--tw-shadow-color, rgb(0 0 0 / 0.1));\\n    box-shadow: var(--tw-inset-shadow), var(--tw-inset-ring-shadow), var(--tw-ring-offset-shadow), var(--tw-ring-shadow), var(--tw-shadow);\\n  }\\n  .shadow-xl {\\n    --tw-shadow: 0 20px 25px -5px var(--tw-shadow-color, rgb(0 0 0 / 0.1)), 0 8px 10px -6px var(--tw-shadow-color, rgb(0 0 0 / 0.1));\\n    box-shadow: var(--tw-inset-shadow), var(--tw-inset-ring-shadow), var(--tw-ring-offset-shadow), var(--tw-ring-shadow), var(--tw-shadow);\\n  }\\n  .ring {\\n    --tw-ring-shadow: var(--tw-ring-inset,) 0 0 0 calc(1px + var(--tw-ring-offset-width)) var(--tw-ring-color, currentcolor);\\n    box-shadow: var(--tw-inset-shadow), var(--tw-inset-ring-shadow), var(--tw-ring-offset-shadow), var(--tw-ring-shadow), var(--tw-shadow);\\n  }\\n  .outline {\\n    outline-style: var(--tw-outline-style);\\n    outline-width: 1px;\\n  }\\n  .blur {\\n    --tw-blur: blur(8px);\\n    filter: var(--tw-blur,) var(--tw-brightness,) var(--tw-contrast,) var(--tw-grayscale,) var(--tw-hue-rotate,) var(--tw-invert,) var(--tw-saturate,) var(--tw-sepia,) var(--tw-drop-shadow,);\\n  }\\n  .grayscale {\\n    --tw-grayscale: grayscale(100%);\\n    filter: var(--tw-blur,) var(--tw-brightness,) var(--tw-contrast,) var(--tw-grayscale,) var(--tw-hue-rotate,) var(--tw-invert,) var(--tw-saturate,) var(--tw-sepia,) var(--tw-drop-shadow,);\\n  }\\n  .invert {\\n    --tw-invert: invert(100%);\\n    filter: var(--tw-blur,) var(--tw-brightness,) var(--tw-contrast,) var(--tw-grayscale,) var(--tw-hue-rotate,) var(--tw-invert,) var(--tw-saturate,) var(--tw-sepia,) var(--tw-drop-shadow,);\\n  }\\n  .filter {\\n    filter: var(--tw-blur,) var(--tw-brightness,) var(--tw-contrast,) var(--tw-grayscale,) var(--tw-hue-rotate,) var(--tw-invert,) var(--tw-saturate,) var(--tw-sepia,) var(--tw-drop-shadow,);\\n  }\\n  .backdrop-blur-sm {\\n    --tw-backdrop-blur: blur(var(--blur-sm));\\n    -webkit-backdrop-filter: var(--tw-backdrop-blur,) var(--tw-backdrop-brightness,) var(--tw-backdrop-contrast,) var(--tw-backdrop-grayscale,) var(--tw-backdrop-hue-rotate,) var(--tw-backdrop-invert,) var(--tw-backdrop-opacity,) var(--tw-backdrop-saturate,) var(--tw-backdrop-sepia,);\\n    backdrop-filter: var(--tw-backdrop-blur,) var(--tw-backdrop-brightness,) var(--tw-backdrop-contrast,) var(--tw-backdrop-grayscale,) var(--tw-backdrop-hue-rotate,) var(--tw-backdrop-invert,) var(--tw-backdrop-opacity,) var(--tw-backdrop-saturate,) var(--tw-backdrop-sepia,);\\n  }\\n  .transition {\\n    transition-property: color, background-color, border-color, outline-color, text-decoration-color, fill, stroke, --tw-gradient-from, --tw-gradient-via, --tw-gradient-to, opacity, box-shadow, transform, translate, scale, rotate, filter, -webkit-backdrop-filter, backdrop-filter, display, visibility, content-visibility, overlay, pointer-events;\\n    transition-timing-function: var(--tw-ease, var(--default-transition-timing-function));\\n    transition-duration: var(--tw-duration, var(--default-transition-duration));\\n  }\\n  .transition-all {\\n    transition-property: all;\\n    transition-timing-function: var(--tw-ease, var(--default-transition-timing-function));\\n    transition-duration: var(--tw-duration, var(--default-transition-duration));\\n  }\\n  .transition-colors {\\n    transition-property: color, background-color, border-color, outline-color, text-decoration-color, fill, stroke, --tw-gradient-from, --tw-gradient-via, --tw-gradient-to;\\n    transition-timing-function: var(--tw-ease, var(--default-transition-timing-function));\\n    transition-duration: var(--tw-duration, var(--default-transition-duration));\\n  }\\n  .transition-opacity {\\n    transition-property: opacity;\\n    transition-timing-function: var(--tw-ease, var(--default-transition-timing-function));\\n    transition-duration: var(--tw-duration, var(--default-transition-duration));\\n  }\\n  .transition-transform {\\n    transition-property: transform, translate, scale, rotate;\\n    transition-timing-function: var(--tw-ease, var(--default-transition-timing-function));\\n    transition-duration: var(--tw-duration, var(--default-transition-duration));\\n  }\\n  .duration-150 {\\n    --tw-duration: 150ms;\\n    transition-duration: 150ms;\\n  }\\n  .duration-200 {\\n    --tw-duration: 200ms;\\n    transition-duration: 200ms;\\n  }\\n  .duration-300 {\\n    --tw-duration: 300ms;\\n    transition-duration: 300ms;\\n  }\\n  .ease-in-out {\\n    --tw-ease: var(--ease-in-out);\\n    transition-timing-function: var(--ease-in-out);\\n  }\\n  .outline-none {\\n    --tw-outline-style: none;\\n    outline-style: none;\\n  }\\n  .select-none {\\n    -webkit-user-select: none;\\n    -moz-user-select: none;\\n         user-select: none;\\n  }\\n  .group-hover\\\\:visible {\\n    &:is(:where(.group):hover *) {\\n      @media (hover: hover) {\\n        visibility: visible;\\n      }\\n    }\\n  }\\n  .group-hover\\\\:opacity-100 {\\n    &:is(:where(.group):hover *) {\\n      @media (hover: hover) {\\n        opacity: 100%;\\n      }\\n    }\\n  }\\n  .hover\\\\:scale-110 {\\n    &:hover {\\n      @media (hover: hover) {\\n        --tw-scale-x: 110%;\\n        --tw-scale-y: 110%;\\n        --tw-scale-z: 110%;\\n        scale: var(--tw-scale-x) var(--tw-scale-y);\\n      }\\n    }\\n  }\\n  .hover\\\\:border-blue-200 {\\n    &:hover {\\n      @media (hover: hover) {\\n        border-color: var(--color-blue-200);\\n      }\\n    }\\n  }\\n  .hover\\\\:border-blue-400 {\\n    &:hover {\\n      @media (hover: hover) {\\n        border-color: var(--color-blue-400);\\n      }\\n    }\\n  }\\n  .hover\\\\:bg-blue-50 {\\n    &:hover {\\n      @media (hover: hover) {\\n        background-color: var(--color-blue-50);\\n      }\\n    }\\n  }\\n  .hover\\\\:bg-blue-200 {\\n    &:hover {\\n      @media (hover: hover) {\\n        background-color: var(--color-blue-200);\\n      }\\n    }\\n  }\\n  .hover\\\\:bg-blue-600 {\\n    &:hover {\\n      @media (hover: hover) {\\n        background-color: var(--color-blue-600);\\n      }\\n    }\\n  }\\n  .hover\\\\:bg-blue-700 {\\n    &:hover {\\n      @media (hover: hover) {\\n        background-color: var(--color-blue-700);\\n      }\\n    }\\n  }\\n  .hover\\\\:bg-gray-50 {\\n    &:hover {\\n      @media (hover: hover) {\\n        background-color: var(--color-gray-50);\\n      }\\n    }\\n  }\\n  .hover\\\\:bg-gray-100 {\\n    &:hover {\\n      @media (hover: hover) {\\n        background-color: var(--color-gray-100);\\n      }\\n    }\\n  }\\n  .hover\\\\:bg-gray-200 {\\n    &:hover {\\n      @media (hover: hover) {\\n        background-color: var(--color-gray-200);\\n      }\\n    }\\n  }\\n  .hover\\\\:bg-gray-300 {\\n    &:hover {\\n      @media (hover: hover) {\\n        background-color: var(--color-gray-300);\\n      }\\n    }\\n  }\\n  .hover\\\\:bg-red-700 {\\n    &:hover {\\n      @media (hover: hover) {\\n        background-color: var(--color-red-700);\\n      }\\n    }\\n  }\\n  .hover\\\\:text-blue-500 {\\n    &:hover {\\n      @media (hover: hover) {\\n        color: var(--color-blue-500);\\n      }\\n    }\\n  }\\n  .hover\\\\:text-blue-600 {\\n    &:hover {\\n      @media (hover: hover) {\\n        color: var(--color-blue-600);\\n      }\\n    }\\n  }\\n  .hover\\\\:text-blue-800 {\\n    &:hover {\\n      @media (hover: hover) {\\n        color: var(--color-blue-800);\\n      }\\n    }\\n  }\\n  .hover\\\\:text-gray-600 {\\n    &:hover {\\n      @media (hover: hover) {\\n        color: var(--color-gray-600);\\n      }\\n    }\\n  }\\n  .hover\\\\:text-gray-700 {\\n    &:hover {\\n      @media (hover: hover) {\\n        color: var(--color-gray-700);\\n      }\\n    }\\n  }\\n  .hover\\\\:text-red-500 {\\n    &:hover {\\n      @media (hover: hover) {\\n        color: var(--color-red-500);\\n      }\\n    }\\n  }\\n  .hover\\\\:opacity-100 {\\n    &:hover {\\n      @media (hover: hover) {\\n        opacity: 100%;\\n      }\\n    }\\n  }\\n  .hover\\\\:shadow {\\n    &:hover {\\n      @media (hover: hover) {\\n        --tw-shadow: 0 1px 3px 0 var(--tw-shadow-color, rgb(0 0 0 / 0.1)), 0 1px 2px -1px var(--tw-shadow-color, rgb(0 0 0 / 0.1));\\n        box-shadow: var(--tw-inset-shadow), var(--tw-inset-ring-shadow), var(--tw-ring-offset-shadow), var(--tw-ring-shadow), var(--tw-shadow);\\n      }\\n    }\\n  }\\n  .hover\\\\:shadow-md {\\n    &:hover {\\n      @media (hover: hover) {\\n        --tw-shadow: 0 4px 6px -1px var(--tw-shadow-color, rgb(0 0 0 / 0.1)), 0 2px 4px -2px var(--tw-shadow-color, rgb(0 0 0 / 0.1));\\n        box-shadow: var(--tw-inset-shadow), var(--tw-inset-ring-shadow), var(--tw-ring-offset-shadow), var(--tw-ring-shadow), var(--tw-shadow);\\n      }\\n    }\\n  }\\n  .hover\\\\:shadow-sm {\\n    &:hover {\\n      @media (hover: hover) {\\n        --tw-shadow: 0 1px 3px 0 var(--tw-shadow-color, rgb(0 0 0 / 0.1)), 0 1px 2px -1px var(--tw-shadow-color, rgb(0 0 0 / 0.1));\\n        box-shadow: var(--tw-inset-shadow), var(--tw-inset-ring-shadow), var(--tw-ring-offset-shadow), var(--tw-ring-shadow), var(--tw-shadow);\\n      }\\n    }\\n  }\\n  .focus\\\\:bg-blue-50 {\\n    &:focus {\\n      background-color: var(--color-blue-50);\\n    }\\n  }\\n  .focus\\\\:ring-1 {\\n    &:focus {\\n      --tw-ring-shadow: var(--tw-ring-inset,) 0 0 0 calc(1px + var(--tw-ring-offset-width)) var(--tw-ring-color, currentcolor);\\n      box-shadow: var(--tw-inset-shadow), var(--tw-inset-ring-shadow), var(--tw-ring-offset-shadow), var(--tw-ring-shadow), var(--tw-shadow);\\n    }\\n  }\\n  .focus\\\\:ring-2 {\\n    &:focus {\\n      --tw-ring-shadow: var(--tw-ring-inset,) 0 0 0 calc(2px + var(--tw-ring-offset-width)) var(--tw-ring-color, currentcolor);\\n      box-shadow: var(--tw-inset-shadow), var(--tw-inset-ring-shadow), var(--tw-ring-offset-shadow), var(--tw-ring-shadow), var(--tw-shadow);\\n    }\\n  }\\n  .focus\\\\:ring-blue-300 {\\n    &:focus {\\n      --tw-ring-color: var(--color-blue-300);\\n    }\\n  }\\n  .focus\\\\:ring-blue-500 {\\n    &:focus {\\n      --tw-ring-color: var(--color-blue-500);\\n    }\\n  }\\n  .focus\\\\:ring-red-500 {\\n    &:focus {\\n      --tw-ring-color: var(--color-red-500);\\n    }\\n  }\\n  .focus\\\\:outline-none {\\n    &:focus {\\n      --tw-outline-style: none;\\n      outline-style: none;\\n    }\\n  }\\n  .sm\\\\:grid-cols-4 {\\n    @media (width >= 40rem) {\\n      grid-template-columns: repeat(4, minmax(0, 1fr));\\n    }\\n  }\\n  .sm\\\\:p-8 {\\n    @media (width >= 40rem) {\\n      padding: var(--spacing-8);\\n    }\\n  }\\n  .md\\\\:grid-cols-3 {\\n    @media (width >= 48rem) {\\n      grid-template-columns: repeat(3, minmax(0, 1fr));\\n    }\\n  }\\n  .md\\\\:grid-cols-6 {\\n    @media (width >= 48rem) {\\n      grid-template-columns: repeat(6, minmax(0, 1fr));\\n    }\\n  }\\n  .lg\\\\:grid-cols-4 {\\n    @media (width >= 64rem) {\\n      grid-template-columns: repeat(4, minmax(0, 1fr));\\n    }\\n  }\\n  .lg\\\\:grid-cols-8 {\\n    @media (width >= 64rem) {\\n      grid-template-columns: repeat(8, minmax(0, 1fr));\\n    }\\n  }\\n  .xl\\\\:grid-cols-5 {\\n    @media (width >= 80rem) {\\n      grid-template-columns: repeat(5, minmax(0, 1fr));\\n    }\\n  }\\n  .xl\\\\:grid-cols-10 {\\n    @media (width >= 80rem) {\\n      grid-template-columns: repeat(10, minmax(0, 1fr));\\n    }\\n  }\\n}\\nhtml {\\n  font-feature-settings: \\\"cv02\\\", \\\"cv03\\\", \\\"cv04\\\", \\\"cv11\\\";\\n  font-family: var(--font-family-sans);\\n}\\nbody {\\n  background-color: var(--color-gray-50);\\n  color: var(--color-gray-900);\\n  margin: 0;\\n  padding: 0;\\n}\\n@utilities {\\n  .slider-track {\\n    height: 4px;\\n    background: linear-gradient(90deg, #4A86E8, #A4C5F4);\\n    border-radius: 2px;\\n  }\\n  .slider-thumb {\\n    width: 16px;\\n    height: 16px;\\n    background: #2A5DB0;\\n    border-radius: 50%;\\n    border: 2px solid white;\\n    box-shadow: 0 0 5px rgba(0, 0, 0, 0.2);\\n    cursor: pointer;\\n    transition: transform 0.15s ease;\\n  }\\n  .slider-thumb:hover {\\n    transform: scale(1.2);\\n  }\\n}\\n@property --tw-translate-x {\\n  syntax: \\\"*\\\";\\n  inherits: false;\\n  initial-value: 0;\\n}\\n@property --tw-translate-y {\\n  syntax: \\\"*\\\";\\n  inherits: false;\\n  initial-value: 0;\\n}\\n@property --tw-translate-z {\\n  syntax: \\\"*\\\";\\n  inherits: false;\\n  initial-value: 0;\\n}\\n@property --tw-scale-x {\\n  syntax: \\\"*\\\";\\n  inherits: false;\\n  initial-value: 1;\\n}\\n@property --tw-scale-y {\\n  syntax: \\\"*\\\";\\n  inherits: false;\\n  initial-value: 1;\\n}\\n@property --tw-scale-z {\\n  syntax: \\\"*\\\";\\n  inherits: false;\\n  initial-value: 1;\\n}\\n@property --tw-rotate-x {\\n  syntax: \\\"*\\\";\\n  inherits: false;\\n}\\n@property --tw-rotate-y {\\n  syntax: \\\"*\\\";\\n  inherits: false;\\n}\\n@property --tw-rotate-z {\\n  syntax: \\\"*\\\";\\n  inherits: false;\\n}\\n@property --tw-skew-x {\\n  syntax: \\\"*\\\";\\n  inherits: false;\\n}\\n@property --tw-skew-y {\\n  syntax: \\\"*\\\";\\n  inherits: false;\\n}\\n@property --tw-space-y-reverse {\\n  syntax: \\\"*\\\";\\n  inherits: false;\\n  initial-value: 0;\\n}\\n@property --tw-space-x-reverse {\\n  syntax: \\\"*\\\";\\n  inherits: false;\\n  initial-value: 0;\\n}\\n@property --tw-border-style {\\n  syntax: \\\"*\\\";\\n  inherits: false;\\n  initial-value: solid;\\n}\\n@property --tw-gradient-position {\\n  syntax: \\\"*\\\";\\n  inherits: false;\\n}\\n@property --tw-gradient-from {\\n  syntax: \\\"<color>\\\";\\n  inherits: false;\\n  initial-value: #0000;\\n}\\n@property --tw-gradient-via {\\n  syntax: \\\"<color>\\\";\\n  inherits: false;\\n  initial-value: #0000;\\n}\\n@property --tw-gradient-to {\\n  syntax: \\\"<color>\\\";\\n  inherits: false;\\n  initial-value: #0000;\\n}\\n@property --tw-gradient-stops {\\n  syntax: \\\"*\\\";\\n  inherits: false;\\n}\\n@property --tw-gradient-via-stops {\\n  syntax: \\\"*\\\";\\n  inherits: false;\\n}\\n@property --tw-gradient-from-position {\\n  syntax: \\\"<length-percentage>\\\";\\n  inherits: false;\\n  initial-value: 0%;\\n}\\n@property --tw-gradient-via-position {\\n  syntax: \\\"<length-percentage>\\\";\\n  inherits: false;\\n  initial-value: 50%;\\n}\\n@property --tw-gradient-to-position {\\n  syntax: \\\"<length-percentage>\\\";\\n  inherits: false;\\n  initial-value: 100%;\\n}\\n@property --tw-leading {\\n  syntax: \\\"*\\\";\\n  inherits: false;\\n}\\n@property --tw-font-weight {\\n  syntax: \\\"*\\\";\\n  inherits: false;\\n}\\n@property --tw-ordinal {\\n  syntax: \\\"*\\\";\\n  inherits: false;\\n}\\n@property --tw-slashed-zero {\\n  syntax: \\\"*\\\";\\n  inherits: false;\\n}\\n@property --tw-numeric-figure {\\n  syntax: \\\"*\\\";\\n  inherits: false;\\n}\\n@property --tw-numeric-spacing {\\n  syntax: \\\"*\\\";\\n  inherits: false;\\n}\\n@property --tw-numeric-fraction {\\n  syntax: \\\"*\\\";\\n  inherits: false;\\n}\\n@property --tw-shadow {\\n  syntax: \\\"*\\\";\\n  inherits: false;\\n  initial-value: 0 0 #0000;\\n}\\n@property --tw-shadow-color {\\n  syntax: \\\"*\\\";\\n  inherits: false;\\n}\\n@property --tw-shadow-alpha {\\n  syntax: \\\"<percentage>\\\";\\n  inherits: false;\\n  initial-value: 100%;\\n}\\n@property --tw-inset-shadow {\\n  syntax: \\\"*\\\";\\n  inherits: false;\\n  initial-value: 0 0 #0000;\\n}\\n@property --tw-inset-shadow-color {\\n  syntax: \\\"*\\\";\\n  inherits: false;\\n}\\n@property --tw-inset-shadow-alpha {\\n  syntax: \\\"<percentage>\\\";\\n  inherits: false;\\n  initial-value: 100%;\\n}\\n@property --tw-ring-color {\\n  syntax: \\\"*\\\";\\n  inherits: false;\\n}\\n@property --tw-ring-shadow {\\n  syntax: \\\"*\\\";\\n  inherits: false;\\n  initial-value: 0 0 #0000;\\n}\\n@property --tw-inset-ring-color {\\n  syntax: \\\"*\\\";\\n  inherits: false;\\n}\\n@property --tw-inset-ring-shadow {\\n  syntax: \\\"*\\\";\\n  inherits: false;\\n  initial-value: 0 0 #0000;\\n}\\n@property --tw-ring-inset {\\n  syntax: \\\"*\\\";\\n  inherits: false;\\n}\\n@property --tw-ring-offset-width {\\n  syntax: \\\"<length>\\\";\\n  inherits: false;\\n  initial-value: 0px;\\n}\\n@property --tw-ring-offset-color {\\n  syntax: \\\"*\\\";\\n  inherits: false;\\n  initial-value: #fff;\\n}\\n@property --tw-ring-offset-shadow {\\n  syntax: \\\"*\\\";\\n  inherits: false;\\n  initial-value: 0 0 #0000;\\n}\\n@property --tw-outline-style {\\n  syntax: \\\"*\\\";\\n  inherits: false;\\n  initial-value: solid;\\n}\\n@property --tw-blur {\\n  syntax: \\\"*\\\";\\n  inherits: false;\\n}\\n@property --tw-brightness {\\n  syntax: \\\"*\\\";\\n  inherits: false;\\n}\\n@property --tw-contrast {\\n  syntax: \\\"*\\\";\\n  inherits: false;\\n}\\n@property --tw-grayscale {\\n  syntax: \\\"*\\\";\\n  inherits: false;\\n}\\n@property --tw-hue-rotate {\\n  syntax: \\\"*\\\";\\n  inherits: false;\\n}\\n@property --tw-invert {\\n  syntax: \\\"*\\\";\\n  inherits: false;\\n}\\n@property --tw-opacity {\\n  syntax: \\\"*\\\";\\n  inherits: false;\\n}\\n@property --tw-saturate {\\n  syntax: \\\"*\\\";\\n  inherits: false;\\n}\\n@property --tw-sepia {\\n  syntax: \\\"*\\\";\\n  inherits: false;\\n}\\n@property --tw-drop-shadow {\\n  syntax: \\\"*\\\";\\n  inherits: false;\\n}\\n@property --tw-drop-shadow-color {\\n  syntax: \\\"*\\\";\\n  inherits: false;\\n}\\n@property --tw-drop-shadow-alpha {\\n  syntax: \\\"<percentage>\\\";\\n  inherits: false;\\n  initial-value: 100%;\\n}\\n@property --tw-drop-shadow-size {\\n  syntax: \\\"*\\\";\\n  inherits: false;\\n}\\n@property --tw-backdrop-blur {\\n  syntax: \\\"*\\\";\\n  inherits: false;\\n}\\n@property --tw-backdrop-brightness {\\n  syntax: \\\"*\\\";\\n  inherits: false;\\n}\\n@property --tw-backdrop-contrast {\\n  syntax: \\\"*\\\";\\n  inherits: false;\\n}\\n@property --tw-backdrop-grayscale {\\n  syntax: \\\"*\\\";\\n  inherits: false;\\n}\\n@property --tw-backdrop-hue-rotate {\\n  syntax: \\\"*\\\";\\n  inherits: false;\\n}\\n@property --tw-backdrop-invert {\\n  syntax: \\\"*\\\";\\n  inherits: false;\\n}\\n@property --tw-backdrop-opacity {\\n  syntax: \\\"*\\\";\\n  inherits: false;\\n}\\n@property --tw-backdrop-saturate {\\n  syntax: \\\"*\\\";\\n  inherits: false;\\n}\\n@property --tw-backdrop-sepia {\\n  syntax: \\\"*\\\";\\n  inherits: false;\\n}\\n@property --tw-duration {\\n  syntax: \\\"*\\\";\\n  inherits: false;\\n}\\n@property --tw-ease {\\n  syntax: \\\"*\\\";\\n  inherits: false;\\n}\\n@layer properties {\\n  @supports ((-webkit-hyphens: none) and (not (margin-trim: inline))) or ((-moz-orient: inline) and (not (color:rgb(from red r g b)))) {\\n    *, ::before, ::after, ::backdrop {\\n      --tw-translate-x: 0;\\n      --tw-translate-y: 0;\\n      --tw-translate-z: 0;\\n      --tw-scale-x: 1;\\n      --tw-scale-y: 1;\\n      --tw-scale-z: 1;\\n      --tw-rotate-x: initial;\\n      --tw-rotate-y: initial;\\n      --tw-rotate-z: initial;\\n      --tw-skew-x: initial;\\n      --tw-skew-y: initial;\\n      --tw-space-y-reverse: 0;\\n      --tw-space-x-reverse: 0;\\n      --tw-border-style: solid;\\n      --tw-gradient-position: initial;\\n      --tw-gradient-from: #0000;\\n      --tw-gradient-via: #0000;\\n      --tw-gradient-to: #0000;\\n      --tw-gradient-stops: initial;\\n      --tw-gradient-via-stops: initial;\\n      --tw-gradient-from-position: 0%;\\n      --tw-gradient-via-position: 50%;\\n      --tw-gradient-to-position: 100%;\\n      --tw-leading: initial;\\n      --tw-font-weight: initial;\\n      --tw-ordinal: initial;\\n      --tw-slashed-zero: initial;\\n      --tw-numeric-figure: initial;\\n      --tw-numeric-spacing: initial;\\n      --tw-numeric-fraction: initial;\\n      --tw-shadow: 0 0 #0000;\\n      --tw-shadow-color: initial;\\n      --tw-shadow-alpha: 100%;\\n      --tw-inset-shadow: 0 0 #0000;\\n      --tw-inset-shadow-color: initial;\\n      --tw-inset-shadow-alpha: 100%;\\n      --tw-ring-color: initial;\\n      --tw-ring-shadow: 0 0 #0000;\\n      --tw-inset-ring-color: initial;\\n      --tw-inset-ring-shadow: 0 0 #0000;\\n      --tw-ring-inset: initial;\\n      --tw-ring-offset-width: 0px;\\n      --tw-ring-offset-color: #fff;\\n      --tw-ring-offset-shadow: 0 0 #0000;\\n      --tw-outline-style: solid;\\n      --tw-blur: initial;\\n      --tw-brightness: initial;\\n      --tw-contrast: initial;\\n      --tw-grayscale: initial;\\n      --tw-hue-rotate: initial;\\n      --tw-invert: initial;\\n      --tw-opacity: initial;\\n      --tw-saturate: initial;\\n      --tw-sepia: initial;\\n      --tw-drop-shadow: initial;\\n      --tw-drop-shadow-color: initial;\\n      --tw-drop-shadow-alpha: 100%;\\n      --tw-drop-shadow-size: initial;\\n      --tw-backdrop-blur: initial;\\n      --tw-backdrop-brightness: initial;\\n      --tw-backdrop-contrast: initial;\\n      --tw-backdrop-grayscale: initial;\\n      --tw-backdrop-hue-rotate: initial;\\n      --tw-backdrop-invert: initial;\\n      --tw-backdrop-opacity: initial;\\n      --tw-backdrop-saturate: initial;\\n      --tw-backdrop-sepia: initial;\\n      --tw-duration: initial;\\n      --tw-ease: initial;\\n    }\\n  }\\n}\\n\", \"\",{\"version\":3,\"sources\":[\"<no source>\",\"webpack://styles/globals.css\",\"webpack://node_modules/tailwindcss/index.css\"],\"names\":[],\"mappings\":\"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\",\"sourcesContent\":[null,\"@import url('https://rsms.me/inter/inter.css');\\n@import \\\"tailwindcss\\\";\\n\\n@theme {\\n  /* Цвета темы */\\n  --color-blue-50: #EAF2FC;\\n  --color-blue-100: #D5E5F8;\\n  --color-blue-200: #A4C5F4;\\n  --color-blue-300: #7EABEF;\\n  --color-blue-400: #5F96EB;\\n  --color-blue-500: #4A86E8;\\n  --color-blue-600: #2A5DB0;\\n  --color-blue-700: #1E4484;\\n  --color-blue-800: #163366;\\n  --color-blue-900: #0E2244;\\n  \\n  /* Светло-голубая цветовая схема */\\n  --color-primary-50: #EAF2FC;\\n  --color-primary-100: #D5E5F8;\\n  --color-primary-200: #A4C5F4;\\n  --color-primary-300: #7EABEF;\\n  --color-primary-400: #5F96EB;\\n  --color-primary-500: #4A86E8;\\n  --color-primary-600: #2A5DB0;\\n  --color-primary-700: #1E4484;\\n  --color-primary-800: #163366;\\n  --color-primary-900: #0E2244;\\n  \\n  /* Функциональные цвета */\\n  --color-success: #66B2FF;\\n  --color-warning: #FFB366;\\n  --color-error: #FF6666;\\n  --color-info: #8CD9FF;\\n  \\n  /* Нейтральные цвета */\\n  --color-gray-50: #F5F8FA;\\n  --color-gray-100: #E9EFF5;\\n  --color-gray-200: #D9E2EC;\\n  --color-gray-300: #CBD5E0;\\n  --color-gray-400: #9FB3C8;\\n  --color-gray-500: #7D8FAF;\\n  --color-gray-600: #546785;\\n  --color-gray-700: #3D4B66;\\n  --color-gray-800: #2D3748;\\n  --color-gray-900: #1A202C;\\n  \\n  /* Размеры и отступы */\\n  --spacing-0: 0px;\\n  --spacing-1: 0.25rem;\\n  --spacing-2: 0.5rem;\\n  --spacing-3: 0.75rem;\\n  --spacing-4: 1rem;\\n  --spacing-5: 1.25rem;\\n  --spacing-6: 1.5rem;\\n  --spacing-8: 2rem;\\n  --spacing-10: 2.5rem;\\n  --spacing-12: 3rem;\\n  --spacing-16: 4rem;\\n  --spacing-20: 5rem;\\n  \\n  /* Другие переменные */\\n  --font-family-sans: 'Inter var', sans-serif;\\n  --shadow-soft: 0 2px 15px -3px rgba(74, 134, 232, 0.15), 0 10px 20px -2px rgba(74, 134, 232, 0.08);\\n  --shadow-card: 0 5px 15px rgba(74, 134, 232, 0.08);\\n  --shadow-dropdown: 0 10px 25px -5px rgba(74, 134, 232, 0.15);\\n  --border-radius-sm: 0.25rem;\\n  --border-radius-md: 0.5rem;\\n  --border-radius-lg: 0.75rem;\\n  --border-radius-xl: 1rem;\\n  --border-radius-2xl: 1.5rem;\\n  --border-radius-4xl: 2rem;\\n  \\n  /* Переходы и анимации */\\n  --transition-fast: 0.15s ease;\\n  --transition-normal: 0.3s ease;\\n  --transition-slow: 0.5s ease;\\n}\\n\\n/* Базовые стили */\\nhtml {\\n  font-feature-settings: \\\"cv02\\\", \\\"cv03\\\", \\\"cv04\\\", \\\"cv11\\\";\\n  font-family: var(--font-family-sans);\\n}\\n\\nbody {\\n  background-color: var(--color-gray-50);\\n  color: var(--color-gray-900);\\n  margin: 0;\\n  padding: 0;\\n}\\n\\n/* Добавляем несколько глобальных утилитарных классов */\\n@utilities {\\n  /* Слайдер с кастомными стилями */\\n  .slider-track {\\n    height: 4px;\\n    background: linear-gradient(90deg, #4A86E8, #A4C5F4);\\n    border-radius: 2px;\\n  }\\n\\n  .slider-thumb {\\n    width: 16px;\\n    height: 16px;\\n    background: #2A5DB0;\\n    border-radius: 50%;\\n    border: 2px solid white;\\n    box-shadow: 0 0 5px rgba(0, 0, 0, 0.2);\\n    cursor: pointer;\\n    transition: transform 0.15s ease;\\n  }\\n\\n  .slider-thumb:hover {\\n    transform: scale(1.2);\\n  }\\n}\\n\",\"@layer theme, base, components, utilities;\\n\\n@layer theme {\\n  @theme default {\\n    --font-sans:\\n      ui-sans-serif, system-ui, sans-serif, \\\"Apple Color Emoji\\\",\\n      \\\"Segoe UI Emoji\\\", \\\"Segoe UI Symbol\\\", \\\"Noto Color Emoji\\\";\\n    --font-serif: ui-serif, Georgia, Cambria, \\\"Times New Roman\\\", Times, serif;\\n    --font-mono:\\n      ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, \\\"Liberation Mono\\\",\\n      \\\"Courier New\\\", monospace;\\n\\n    --color-red-50: oklch(97.1% 0.013 17.38);\\n    --color-red-100: oklch(93.6% 0.032 17.717);\\n    --color-red-200: oklch(88.5% 0.062 18.334);\\n    --color-red-300: oklch(80.8% 0.114 19.571);\\n    --color-red-400: oklch(70.4% 0.191 22.216);\\n    --color-red-500: oklch(63.7% 0.237 25.331);\\n    --color-red-600: oklch(57.7% 0.245 27.325);\\n    --color-red-700: oklch(50.5% 0.213 27.518);\\n    --color-red-800: oklch(44.4% 0.177 26.899);\\n    --color-red-900: oklch(39.6% 0.141 25.723);\\n    --color-red-950: oklch(25.8% 0.092 26.042);\\n\\n    --color-orange-50: oklch(98% 0.016 73.684);\\n    --color-orange-100: oklch(95.4% 0.038 75.164);\\n    --color-orange-200: oklch(90.1% 0.076 70.697);\\n    --color-orange-300: oklch(83.7% 0.128 66.29);\\n    --color-orange-400: oklch(75% 0.183 55.934);\\n    --color-orange-500: oklch(70.5% 0.213 47.604);\\n    --color-orange-600: oklch(64.6% 0.222 41.116);\\n    --color-orange-700: oklch(55.3% 0.195 38.402);\\n    --color-orange-800: oklch(47% 0.157 37.304);\\n    --color-orange-900: oklch(40.8% 0.123 38.172);\\n    --color-orange-950: oklch(26.6% 0.079 36.259);\\n\\n    --color-amber-50: oklch(98.7% 0.022 95.277);\\n    --color-amber-100: oklch(96.2% 0.059 95.617);\\n    --color-amber-200: oklch(92.4% 0.12 95.746);\\n    --color-amber-300: oklch(87.9% 0.169 91.605);\\n    --color-amber-400: oklch(82.8% 0.189 84.429);\\n    --color-amber-500: oklch(76.9% 0.188 70.08);\\n    --color-amber-600: oklch(66.6% 0.179 58.318);\\n    --color-amber-700: oklch(55.5% 0.163 48.998);\\n    --color-amber-800: oklch(47.3% 0.137 46.201);\\n    --color-amber-900: oklch(41.4% 0.112 45.904);\\n    --color-amber-950: oklch(27.9% 0.077 45.635);\\n\\n    --color-yellow-50: oklch(98.7% 0.026 102.212);\\n    --color-yellow-100: oklch(97.3% 0.071 103.193);\\n    --color-yellow-200: oklch(94.5% 0.129 101.54);\\n    --color-yellow-300: oklch(90.5% 0.182 98.111);\\n    --color-yellow-400: oklch(85.2% 0.199 91.936);\\n    --color-yellow-500: oklch(79.5% 0.184 86.047);\\n    --color-yellow-600: oklch(68.1% 0.162 75.834);\\n    --color-yellow-700: oklch(55.4% 0.135 66.442);\\n    --color-yellow-800: oklch(47.6% 0.114 61.907);\\n    --color-yellow-900: oklch(42.1% 0.095 57.708);\\n    --color-yellow-950: oklch(28.6% 0.066 53.813);\\n\\n    --color-lime-50: oklch(98.6% 0.031 120.757);\\n    --color-lime-100: oklch(96.7% 0.067 122.328);\\n    --color-lime-200: oklch(93.8% 0.127 124.321);\\n    --color-lime-300: oklch(89.7% 0.196 126.665);\\n    --color-lime-400: oklch(84.1% 0.238 128.85);\\n    --color-lime-500: oklch(76.8% 0.233 130.85);\\n    --color-lime-600: oklch(64.8% 0.2 131.684);\\n    --color-lime-700: oklch(53.2% 0.157 131.589);\\n    --color-lime-800: oklch(45.3% 0.124 130.933);\\n    --color-lime-900: oklch(40.5% 0.101 131.063);\\n    --color-lime-950: oklch(27.4% 0.072 132.109);\\n\\n    --color-green-50: oklch(98.2% 0.018 155.826);\\n    --color-green-100: oklch(96.2% 0.044 156.743);\\n    --color-green-200: oklch(92.5% 0.084 155.995);\\n    --color-green-300: oklch(87.1% 0.15 154.449);\\n    --color-green-400: oklch(79.2% 0.209 151.711);\\n    --color-green-500: oklch(72.3% 0.219 149.579);\\n    --color-green-600: oklch(62.7% 0.194 149.214);\\n    --color-green-700: oklch(52.7% 0.154 150.069);\\n    --color-green-800: oklch(44.8% 0.119 151.328);\\n    --color-green-900: oklch(39.3% 0.095 152.535);\\n    --color-green-950: oklch(26.6% 0.065 152.934);\\n\\n    --color-emerald-50: oklch(97.9% 0.021 166.113);\\n    --color-emerald-100: oklch(95% 0.052 163.051);\\n    --color-emerald-200: oklch(90.5% 0.093 164.15);\\n    --color-emerald-300: oklch(84.5% 0.143 164.978);\\n    --color-emerald-400: oklch(76.5% 0.177 163.223);\\n    --color-emerald-500: oklch(69.6% 0.17 162.48);\\n    --color-emerald-600: oklch(59.6% 0.145 163.225);\\n    --color-emerald-700: oklch(50.8% 0.118 165.612);\\n    --color-emerald-800: oklch(43.2% 0.095 166.913);\\n    --color-emerald-900: oklch(37.8% 0.077 168.94);\\n    --color-emerald-950: oklch(26.2% 0.051 172.552);\\n\\n    --color-teal-50: oklch(98.4% 0.014 180.72);\\n    --color-teal-100: oklch(95.3% 0.051 180.801);\\n    --color-teal-200: oklch(91% 0.096 180.426);\\n    --color-teal-300: oklch(85.5% 0.138 181.071);\\n    --color-teal-400: oklch(77.7% 0.152 181.912);\\n    --color-teal-500: oklch(70.4% 0.14 182.503);\\n    --color-teal-600: oklch(60% 0.118 184.704);\\n    --color-teal-700: oklch(51.1% 0.096 186.391);\\n    --color-teal-800: oklch(43.7% 0.078 188.216);\\n    --color-teal-900: oklch(38.6% 0.063 188.416);\\n    --color-teal-950: oklch(27.7% 0.046 192.524);\\n\\n    --color-cyan-50: oklch(98.4% 0.019 200.873);\\n    --color-cyan-100: oklch(95.6% 0.045 203.388);\\n    --color-cyan-200: oklch(91.7% 0.08 205.041);\\n    --color-cyan-300: oklch(86.5% 0.127 207.078);\\n    --color-cyan-400: oklch(78.9% 0.154 211.53);\\n    --color-cyan-500: oklch(71.5% 0.143 215.221);\\n    --color-cyan-600: oklch(60.9% 0.126 221.723);\\n    --color-cyan-700: oklch(52% 0.105 223.128);\\n    --color-cyan-800: oklch(45% 0.085 224.283);\\n    --color-cyan-900: oklch(39.8% 0.07 227.392);\\n    --color-cyan-950: oklch(30.2% 0.056 229.695);\\n\\n    --color-sky-50: oklch(97.7% 0.013 236.62);\\n    --color-sky-100: oklch(95.1% 0.026 236.824);\\n    --color-sky-200: oklch(90.1% 0.058 230.902);\\n    --color-sky-300: oklch(82.8% 0.111 230.318);\\n    --color-sky-400: oklch(74.6% 0.16 232.661);\\n    --color-sky-500: oklch(68.5% 0.169 237.323);\\n    --color-sky-600: oklch(58.8% 0.158 241.966);\\n    --color-sky-700: oklch(50% 0.134 242.749);\\n    --color-sky-800: oklch(44.3% 0.11 240.79);\\n    --color-sky-900: oklch(39.1% 0.09 240.876);\\n    --color-sky-950: oklch(29.3% 0.066 243.157);\\n\\n    --color-blue-50: oklch(97% 0.014 254.604);\\n    --color-blue-100: oklch(93.2% 0.032 255.585);\\n    --color-blue-200: oklch(88.2% 0.059 254.128);\\n    --color-blue-300: oklch(80.9% 0.105 251.813);\\n    --color-blue-400: oklch(70.7% 0.165 254.624);\\n    --color-blue-500: oklch(62.3% 0.214 259.815);\\n    --color-blue-600: oklch(54.6% 0.245 262.881);\\n    --color-blue-700: oklch(48.8% 0.243 264.376);\\n    --color-blue-800: oklch(42.4% 0.199 265.638);\\n    --color-blue-900: oklch(37.9% 0.146 265.522);\\n    --color-blue-950: oklch(28.2% 0.091 267.935);\\n\\n    --color-indigo-50: oklch(96.2% 0.018 272.314);\\n    --color-indigo-100: oklch(93% 0.034 272.788);\\n    --color-indigo-200: oklch(87% 0.065 274.039);\\n    --color-indigo-300: oklch(78.5% 0.115 274.713);\\n    --color-indigo-400: oklch(67.3% 0.182 276.935);\\n    --color-indigo-500: oklch(58.5% 0.233 277.117);\\n    --color-indigo-600: oklch(51.1% 0.262 276.966);\\n    --color-indigo-700: oklch(45.7% 0.24 277.023);\\n    --color-indigo-800: oklch(39.8% 0.195 277.366);\\n    --color-indigo-900: oklch(35.9% 0.144 278.697);\\n    --color-indigo-950: oklch(25.7% 0.09 281.288);\\n\\n    --color-violet-50: oklch(96.9% 0.016 293.756);\\n    --color-violet-100: oklch(94.3% 0.029 294.588);\\n    --color-violet-200: oklch(89.4% 0.057 293.283);\\n    --color-violet-300: oklch(81.1% 0.111 293.571);\\n    --color-violet-400: oklch(70.2% 0.183 293.541);\\n    --color-violet-500: oklch(60.6% 0.25 292.717);\\n    --color-violet-600: oklch(54.1% 0.281 293.009);\\n    --color-violet-700: oklch(49.1% 0.27 292.581);\\n    --color-violet-800: oklch(43.2% 0.232 292.759);\\n    --color-violet-900: oklch(38% 0.189 293.745);\\n    --color-violet-950: oklch(28.3% 0.141 291.089);\\n\\n    --color-purple-50: oklch(97.7% 0.014 308.299);\\n    --color-purple-100: oklch(94.6% 0.033 307.174);\\n    --color-purple-200: oklch(90.2% 0.063 306.703);\\n    --color-purple-300: oklch(82.7% 0.119 306.383);\\n    --color-purple-400: oklch(71.4% 0.203 305.504);\\n    --color-purple-500: oklch(62.7% 0.265 303.9);\\n    --color-purple-600: oklch(55.8% 0.288 302.321);\\n    --color-purple-700: oklch(49.6% 0.265 301.924);\\n    --color-purple-800: oklch(43.8% 0.218 303.724);\\n    --color-purple-900: oklch(38.1% 0.176 304.987);\\n    --color-purple-950: oklch(29.1% 0.149 302.717);\\n\\n    --color-fuchsia-50: oklch(97.7% 0.017 320.058);\\n    --color-fuchsia-100: oklch(95.2% 0.037 318.852);\\n    --color-fuchsia-200: oklch(90.3% 0.076 319.62);\\n    --color-fuchsia-300: oklch(83.3% 0.145 321.434);\\n    --color-fuchsia-400: oklch(74% 0.238 322.16);\\n    --color-fuchsia-500: oklch(66.7% 0.295 322.15);\\n    --color-fuchsia-600: oklch(59.1% 0.293 322.896);\\n    --color-fuchsia-700: oklch(51.8% 0.253 323.949);\\n    --color-fuchsia-800: oklch(45.2% 0.211 324.591);\\n    --color-fuchsia-900: oklch(40.1% 0.17 325.612);\\n    --color-fuchsia-950: oklch(29.3% 0.136 325.661);\\n\\n    --color-pink-50: oklch(97.1% 0.014 343.198);\\n    --color-pink-100: oklch(94.8% 0.028 342.258);\\n    --color-pink-200: oklch(89.9% 0.061 343.231);\\n    --color-pink-300: oklch(82.3% 0.12 346.018);\\n    --color-pink-400: oklch(71.8% 0.202 349.761);\\n    --color-pink-500: oklch(65.6% 0.241 354.308);\\n    --color-pink-600: oklch(59.2% 0.249 0.584);\\n    --color-pink-700: oklch(52.5% 0.223 3.958);\\n    --color-pink-800: oklch(45.9% 0.187 3.815);\\n    --color-pink-900: oklch(40.8% 0.153 2.432);\\n    --color-pink-950: oklch(28.4% 0.109 3.907);\\n\\n    --color-rose-50: oklch(96.9% 0.015 12.422);\\n    --color-rose-100: oklch(94.1% 0.03 12.58);\\n    --color-rose-200: oklch(89.2% 0.058 10.001);\\n    --color-rose-300: oklch(81% 0.117 11.638);\\n    --color-rose-400: oklch(71.2% 0.194 13.428);\\n    --color-rose-500: oklch(64.5% 0.246 16.439);\\n    --color-rose-600: oklch(58.6% 0.253 17.585);\\n    --color-rose-700: oklch(51.4% 0.222 16.935);\\n    --color-rose-800: oklch(45.5% 0.188 13.697);\\n    --color-rose-900: oklch(41% 0.159 10.272);\\n    --color-rose-950: oklch(27.1% 0.105 12.094);\\n\\n    --color-slate-50: oklch(98.4% 0.003 247.858);\\n    --color-slate-100: oklch(96.8% 0.007 247.896);\\n    --color-slate-200: oklch(92.9% 0.013 255.508);\\n    --color-slate-300: oklch(86.9% 0.022 252.894);\\n    --color-slate-400: oklch(70.4% 0.04 256.788);\\n    --color-slate-500: oklch(55.4% 0.046 257.417);\\n    --color-slate-600: oklch(44.6% 0.043 257.281);\\n    --color-slate-700: oklch(37.2% 0.044 257.287);\\n    --color-slate-800: oklch(27.9% 0.041 260.031);\\n    --color-slate-900: oklch(20.8% 0.042 265.755);\\n    --color-slate-950: oklch(12.9% 0.042 264.695);\\n\\n    --color-gray-50: oklch(98.5% 0.002 247.839);\\n    --color-gray-100: oklch(96.7% 0.003 264.542);\\n    --color-gray-200: oklch(92.8% 0.006 264.531);\\n    --color-gray-300: oklch(87.2% 0.01 258.338);\\n    --color-gray-400: oklch(70.7% 0.022 261.325);\\n    --color-gray-500: oklch(55.1% 0.027 264.364);\\n    --color-gray-600: oklch(44.6% 0.03 256.802);\\n    --color-gray-700: oklch(37.3% 0.034 259.733);\\n    --color-gray-800: oklch(27.8% 0.033 256.848);\\n    --color-gray-900: oklch(21% 0.034 264.665);\\n    --color-gray-950: oklch(13% 0.028 261.692);\\n\\n    --color-zinc-50: oklch(98.5% 0 0);\\n    --color-zinc-100: oklch(96.7% 0.001 286.375);\\n    --color-zinc-200: oklch(92% 0.004 286.32);\\n    --color-zinc-300: oklch(87.1% 0.006 286.286);\\n    --color-zinc-400: oklch(70.5% 0.015 286.067);\\n    --color-zinc-500: oklch(55.2% 0.016 285.938);\\n    --color-zinc-600: oklch(44.2% 0.017 285.786);\\n    --color-zinc-700: oklch(37% 0.013 285.805);\\n    --color-zinc-800: oklch(27.4% 0.006 286.033);\\n    --color-zinc-900: oklch(21% 0.006 285.885);\\n    --color-zinc-950: oklch(14.1% 0.005 285.823);\\n\\n    --color-neutral-50: oklch(98.5% 0 0);\\n    --color-neutral-100: oklch(97% 0 0);\\n    --color-neutral-200: oklch(92.2% 0 0);\\n    --color-neutral-300: oklch(87% 0 0);\\n    --color-neutral-400: oklch(70.8% 0 0);\\n    --color-neutral-500: oklch(55.6% 0 0);\\n    --color-neutral-600: oklch(43.9% 0 0);\\n    --color-neutral-700: oklch(37.1% 0 0);\\n    --color-neutral-800: oklch(26.9% 0 0);\\n    --color-neutral-900: oklch(20.5% 0 0);\\n    --color-neutral-950: oklch(14.5% 0 0);\\n\\n    --color-stone-50: oklch(98.5% 0.001 106.423);\\n    --color-stone-100: oklch(97% 0.001 106.424);\\n    --color-stone-200: oklch(92.3% 0.003 48.717);\\n    --color-stone-300: oklch(86.9% 0.005 56.366);\\n    --color-stone-400: oklch(70.9% 0.01 56.259);\\n    --color-stone-500: oklch(55.3% 0.013 58.071);\\n    --color-stone-600: oklch(44.4% 0.011 73.639);\\n    --color-stone-700: oklch(37.4% 0.01 67.558);\\n    --color-stone-800: oklch(26.8% 0.007 34.298);\\n    --color-stone-900: oklch(21.6% 0.006 56.043);\\n    --color-stone-950: oklch(14.7% 0.004 49.25);\\n\\n    --color-black: #000;\\n    --color-white: #fff;\\n\\n    --spacing: 0.25rem;\\n\\n    --breakpoint-sm: 40rem;\\n    --breakpoint-md: 48rem;\\n    --breakpoint-lg: 64rem;\\n    --breakpoint-xl: 80rem;\\n    --breakpoint-2xl: 96rem;\\n\\n    --container-3xs: 16rem;\\n    --container-2xs: 18rem;\\n    --container-xs: 20rem;\\n    --container-sm: 24rem;\\n    --container-md: 28rem;\\n    --container-lg: 32rem;\\n    --container-xl: 36rem;\\n    --container-2xl: 42rem;\\n    --container-3xl: 48rem;\\n    --container-4xl: 56rem;\\n    --container-5xl: 64rem;\\n    --container-6xl: 72rem;\\n    --container-7xl: 80rem;\\n\\n    --text-xs: 0.75rem;\\n    --text-xs--line-height: calc(1 / 0.75);\\n    --text-sm: 0.875rem;\\n    --text-sm--line-height: calc(1.25 / 0.875);\\n    --text-base: 1rem;\\n    --text-base--line-height: calc(1.5 / 1);\\n    --text-lg: 1.125rem;\\n    --text-lg--line-height: calc(1.75 / 1.125);\\n    --text-xl: 1.25rem;\\n    --text-xl--line-height: calc(1.75 / 1.25);\\n    --text-2xl: 1.5rem;\\n    --text-2xl--line-height: calc(2 / 1.5);\\n    --text-3xl: 1.875rem;\\n    --text-3xl--line-height: calc(2.25 / 1.875);\\n    --text-4xl: 2.25rem;\\n    --text-4xl--line-height: calc(2.5 / 2.25);\\n    --text-5xl: 3rem;\\n    --text-5xl--line-height: 1;\\n    --text-6xl: 3.75rem;\\n    --text-6xl--line-height: 1;\\n    --text-7xl: 4.5rem;\\n    --text-7xl--line-height: 1;\\n    --text-8xl: 6rem;\\n    --text-8xl--line-height: 1;\\n    --text-9xl: 8rem;\\n    --text-9xl--line-height: 1;\\n\\n    --font-weight-thin: 100;\\n    --font-weight-extralight: 200;\\n    --font-weight-light: 300;\\n    --font-weight-normal: 400;\\n    --font-weight-medium: 500;\\n    --font-weight-semibold: 600;\\n    --font-weight-bold: 700;\\n    --font-weight-extrabold: 800;\\n    --font-weight-black: 900;\\n\\n    --tracking-tighter: -0.05em;\\n    --tracking-tight: -0.025em;\\n    --tracking-normal: 0em;\\n    --tracking-wide: 0.025em;\\n    --tracking-wider: 0.05em;\\n    --tracking-widest: 0.1em;\\n\\n    --leading-tight: 1.25;\\n    --leading-snug: 1.375;\\n    --leading-normal: 1.5;\\n    --leading-relaxed: 1.625;\\n    --leading-loose: 2;\\n\\n    --radius-xs: 0.125rem;\\n    --radius-sm: 0.25rem;\\n    --radius-md: 0.375rem;\\n    --radius-lg: 0.5rem;\\n    --radius-xl: 0.75rem;\\n    --radius-2xl: 1rem;\\n    --radius-3xl: 1.5rem;\\n    --radius-4xl: 2rem;\\n\\n    --shadow-2xs: 0 1px rgb(0 0 0 / 0.05);\\n    --shadow-xs: 0 1px 2px 0 rgb(0 0 0 / 0.05);\\n    --shadow-sm: 0 1px 3px 0 rgb(0 0 0 / 0.1), 0 1px 2px -1px rgb(0 0 0 / 0.1);\\n    --shadow-md:\\n      0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);\\n    --shadow-lg:\\n      0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1);\\n    --shadow-xl:\\n      0 20px 25px -5px rgb(0 0 0 / 0.1), 0 8px 10px -6px rgb(0 0 0 / 0.1);\\n    --shadow-2xl: 0 25px 50px -12px rgb(0 0 0 / 0.25);\\n\\n    --inset-shadow-2xs: inset 0 1px rgb(0 0 0 / 0.05);\\n    --inset-shadow-xs: inset 0 1px 1px rgb(0 0 0 / 0.05);\\n    --inset-shadow-sm: inset 0 2px 4px rgb(0 0 0 / 0.05);\\n\\n    --drop-shadow-xs: 0 1px 1px rgb(0 0 0 / 0.05);\\n    --drop-shadow-sm: 0 1px 2px rgb(0 0 0 / 0.15);\\n    --drop-shadow-md: 0 3px 3px rgb(0 0 0 / 0.12);\\n    --drop-shadow-lg: 0 4px 4px rgb(0 0 0 / 0.15);\\n    --drop-shadow-xl: 0 9px 7px rgb(0 0 0 / 0.1);\\n    --drop-shadow-2xl: 0 25px 25px rgb(0 0 0 / 0.15);\\n\\n    --text-shadow-2xs: 0px 1px 0px rgb(0 0 0 / 0.15);\\n    --text-shadow-xs: 0px 1px 1px rgb(0 0 0 / 0.2);\\n    --text-shadow-sm:\\n      0px 1px 0px rgb(0 0 0 / 0.075), 0px 1px 1px rgb(0 0 0 / 0.075),\\n      0px 2px 2px rgb(0 0 0 / 0.075);\\n    --text-shadow-md:\\n      0px 1px 1px rgb(0 0 0 / 0.1), 0px 1px 2px rgb(0 0 0 / 0.1),\\n      0px 2px 4px rgb(0 0 0 / 0.1);\\n    --text-shadow-lg:\\n      0px 1px 2px rgb(0 0 0 / 0.1), 0px 3px 2px rgb(0 0 0 / 0.1),\\n      0px 4px 8px rgb(0 0 0 / 0.1);\\n\\n    --ease-in: cubic-bezier(0.4, 0, 1, 1);\\n    --ease-out: cubic-bezier(0, 0, 0.2, 1);\\n    --ease-in-out: cubic-bezier(0.4, 0, 0.2, 1);\\n\\n    --animate-spin: spin 1s linear infinite;\\n    --animate-ping: ping 1s cubic-bezier(0, 0, 0.2, 1) infinite;\\n    --animate-pulse: pulse 2s cubic-bezier(0.4, 0, 0.6, 1) infinite;\\n    --animate-bounce: bounce 1s infinite;\\n\\n    @keyframes spin {\\n      to {\\n        transform: rotate(360deg);\\n      }\\n    }\\n\\n    @keyframes ping {\\n      75%,\\n      100% {\\n        transform: scale(2);\\n        opacity: 0;\\n      }\\n    }\\n\\n    @keyframes pulse {\\n      50% {\\n        opacity: 0.5;\\n      }\\n    }\\n\\n    @keyframes bounce {\\n      0%,\\n      100% {\\n        transform: translateY(-25%);\\n        animation-timing-function: cubic-bezier(0.8, 0, 1, 1);\\n      }\\n\\n      50% {\\n        transform: none;\\n        animation-timing-function: cubic-bezier(0, 0, 0.2, 1);\\n      }\\n    }\\n\\n    --blur-xs: 4px;\\n    --blur-sm: 8px;\\n    --blur-md: 12px;\\n    --blur-lg: 16px;\\n    --blur-xl: 24px;\\n    --blur-2xl: 40px;\\n    --blur-3xl: 64px;\\n\\n    --perspective-dramatic: 100px;\\n    --perspective-near: 300px;\\n    --perspective-normal: 500px;\\n    --perspective-midrange: 800px;\\n    --perspective-distant: 1200px;\\n\\n    --aspect-video: 16 / 9;\\n\\n    --default-transition-duration: 150ms;\\n    --default-transition-timing-function: cubic-bezier(0.4, 0, 0.2, 1);\\n    --default-font-family: --theme(--font-sans, initial);\\n    --default-font-feature-settings: --theme(\\n      --font-sans--font-feature-settings,\\n      initial\\n    );\\n    --default-font-variation-settings: --theme(\\n      --font-sans--font-variation-settings,\\n      initial\\n    );\\n    --default-mono-font-family: --theme(--font-mono, initial);\\n    --default-mono-font-feature-settings: --theme(\\n      --font-mono--font-feature-settings,\\n      initial\\n    );\\n    --default-mono-font-variation-settings: --theme(\\n      --font-mono--font-variation-settings,\\n      initial\\n    );\\n  }\\n\\n  /* Deprecated */\\n  @theme default inline reference {\\n    --blur: 8px;\\n    --shadow: 0 1px 3px 0 rgb(0 0 0 / 0.1), 0 1px 2px -1px rgb(0 0 0 / 0.1);\\n    --shadow-inner: inset 0 2px 4px 0 rgb(0 0 0 / 0.05);\\n    --drop-shadow: 0 1px 2px rgb(0 0 0 / 0.1), 0 1px 1px rgb(0 0 0 / 0.06);\\n    --radius: 0.25rem;\\n    --max-width-prose: 65ch;\\n  }\\n}\\n\\n@layer base {\\n  /*\\n  1. Prevent padding and border from affecting element width. (https://github.com/mozdevs/cssremedy/issues/4)\\n  2. Remove default margins and padding\\n  3. Reset all borders.\\n*/\\n\\n  *,\\n  ::after,\\n  ::before,\\n  ::backdrop,\\n  ::file-selector-button {\\n    box-sizing: border-box; /* 1 */\\n    margin: 0; /* 2 */\\n    padding: 0; /* 2 */\\n    border: 0 solid; /* 3 */\\n  }\\n\\n  /*\\n  1. Use a consistent sensible line-height in all browsers.\\n  2. Prevent adjustments of font size after orientation changes in iOS.\\n  3. Use a more readable tab size.\\n  4. Use the user's configured `sans` font-family by default.\\n  5. Use the user's configured `sans` font-feature-settings by default.\\n  6. Use the user's configured `sans` font-variation-settings by default.\\n  7. Disable tap highlights on iOS.\\n*/\\n\\n  html,\\n  :host {\\n    line-height: 1.5; /* 1 */\\n    -webkit-text-size-adjust: 100%; /* 2 */\\n    tab-size: 4; /* 3 */\\n    font-family: --theme(\\n      --default-font-family,\\n      ui-sans-serif,\\n      system-ui,\\n      sans-serif,\\n      \\\"Apple Color Emoji\\\",\\n      \\\"Segoe UI Emoji\\\",\\n      \\\"Segoe UI Symbol\\\",\\n      \\\"Noto Color Emoji\\\"\\n    ); /* 4 */\\n    font-feature-settings: --theme(\\n      --default-font-feature-settings,\\n      normal\\n    ); /* 5 */\\n    font-variation-settings: --theme(\\n      --default-font-variation-settings,\\n      normal\\n    ); /* 6 */\\n    -webkit-tap-highlight-color: transparent; /* 7 */\\n  }\\n\\n  /*\\n  1. Add the correct height in Firefox.\\n  2. Correct the inheritance of border color in Firefox. (https://bugzilla.mozilla.org/show_bug.cgi?id=190655)\\n  3. Reset the default border style to a 1px solid border.\\n*/\\n\\n  hr {\\n    height: 0; /* 1 */\\n    color: inherit; /* 2 */\\n    border-top-width: 1px; /* 3 */\\n  }\\n\\n  /*\\n  Add the correct text decoration in Chrome, Edge, and Safari.\\n*/\\n\\n  abbr:where([title]) {\\n    -webkit-text-decoration: underline dotted;\\n    text-decoration: underline dotted;\\n  }\\n\\n  /*\\n  Remove the default font size and weight for headings.\\n*/\\n\\n  h1,\\n  h2,\\n  h3,\\n  h4,\\n  h5,\\n  h6 {\\n    font-size: inherit;\\n    font-weight: inherit;\\n  }\\n\\n  /*\\n  Reset links to optimize for opt-in styling instead of opt-out.\\n*/\\n\\n  a {\\n    color: inherit;\\n    -webkit-text-decoration: inherit;\\n    text-decoration: inherit;\\n  }\\n\\n  /*\\n  Add the correct font weight in Edge and Safari.\\n*/\\n\\n  b,\\n  strong {\\n    font-weight: bolder;\\n  }\\n\\n  /*\\n  1. Use the user's configured `mono` font-family by default.\\n  2. Use the user's configured `mono` font-feature-settings by default.\\n  3. Use the user's configured `mono` font-variation-settings by default.\\n  4. Correct the odd `em` font sizing in all browsers.\\n*/\\n\\n  code,\\n  kbd,\\n  samp,\\n  pre {\\n    font-family: --theme(\\n      --default-mono-font-family,\\n      ui-monospace,\\n      SFMono-Regular,\\n      Menlo,\\n      Monaco,\\n      Consolas,\\n      \\\"Liberation Mono\\\",\\n      \\\"Courier New\\\",\\n      monospace\\n    ); /* 1 */\\n    font-feature-settings: --theme(\\n      --default-mono-font-feature-settings,\\n      normal\\n    ); /* 2 */\\n    font-variation-settings: --theme(\\n      --default-mono-font-variation-settings,\\n      normal\\n    ); /* 3 */\\n    font-size: 1em; /* 4 */\\n  }\\n\\n  /*\\n  Add the correct font size in all browsers.\\n*/\\n\\n  small {\\n    font-size: 80%;\\n  }\\n\\n  /*\\n  Prevent `sub` and `sup` elements from affecting the line height in all browsers.\\n*/\\n\\n  sub,\\n  sup {\\n    font-size: 75%;\\n    line-height: 0;\\n    position: relative;\\n    vertical-align: baseline;\\n  }\\n\\n  sub {\\n    bottom: -0.25em;\\n  }\\n\\n  sup {\\n    top: -0.5em;\\n  }\\n\\n  /*\\n  1. Remove text indentation from table contents in Chrome and Safari. (https://bugs.chromium.org/p/chromium/issues/detail?id=999088, https://bugs.webkit.org/show_bug.cgi?id=201297)\\n  2. Correct table border color inheritance in all Chrome and Safari. (https://bugs.chromium.org/p/chromium/issues/detail?id=935729, https://bugs.webkit.org/show_bug.cgi?id=195016)\\n  3. Remove gaps between table borders by default.\\n*/\\n\\n  table {\\n    text-indent: 0; /* 1 */\\n    border-color: inherit; /* 2 */\\n    border-collapse: collapse; /* 3 */\\n  }\\n\\n  /*\\n  Use the modern Firefox focus style for all focusable elements.\\n*/\\n\\n  :-moz-focusring {\\n    outline: auto;\\n  }\\n\\n  /*\\n  Add the correct vertical alignment in Chrome and Firefox.\\n*/\\n\\n  progress {\\n    vertical-align: baseline;\\n  }\\n\\n  /*\\n  Add the correct display in Chrome and Safari.\\n*/\\n\\n  summary {\\n    display: list-item;\\n  }\\n\\n  /*\\n  Make lists unstyled by default.\\n*/\\n\\n  ol,\\n  ul,\\n  menu {\\n    list-style: none;\\n  }\\n\\n  /*\\n  1. Make replaced elements `display: block` by default. (https://github.com/mozdevs/cssremedy/issues/14)\\n  2. Add `vertical-align: middle` to align replaced elements more sensibly by default. (https://github.com/jensimmons/cssremedy/issues/14#issuecomment-634934210)\\n      This can trigger a poorly considered lint error in some tools but is included by design.\\n*/\\n\\n  img,\\n  svg,\\n  video,\\n  canvas,\\n  audio,\\n  iframe,\\n  embed,\\n  object {\\n    display: block; /* 1 */\\n    vertical-align: middle; /* 2 */\\n  }\\n\\n  /*\\n  Constrain images and videos to the parent width and preserve their intrinsic aspect ratio. (https://github.com/mozdevs/cssremedy/issues/14)\\n*/\\n\\n  img,\\n  video {\\n    max-width: 100%;\\n    height: auto;\\n  }\\n\\n  /*\\n  1. Inherit font styles in all browsers.\\n  2. Remove border radius in all browsers.\\n  3. Remove background color in all browsers.\\n  4. Ensure consistent opacity for disabled states in all browsers.\\n*/\\n\\n  button,\\n  input,\\n  select,\\n  optgroup,\\n  textarea,\\n  ::file-selector-button {\\n    font: inherit; /* 1 */\\n    font-feature-settings: inherit; /* 1 */\\n    font-variation-settings: inherit; /* 1 */\\n    letter-spacing: inherit; /* 1 */\\n    color: inherit; /* 1 */\\n    border-radius: 0; /* 2 */\\n    background-color: transparent; /* 3 */\\n    opacity: 1; /* 4 */\\n  }\\n\\n  /*\\n  Restore default font weight.\\n*/\\n\\n  :where(select:is([multiple], [size])) optgroup {\\n    font-weight: bolder;\\n  }\\n\\n  /*\\n  Restore indentation.\\n*/\\n\\n  :where(select:is([multiple], [size])) optgroup option {\\n    padding-inline-start: 20px;\\n  }\\n\\n  /*\\n  Restore space after button.\\n*/\\n\\n  ::file-selector-button {\\n    margin-inline-end: 4px;\\n  }\\n\\n  /*\\n  Reset the default placeholder opacity in Firefox. (https://github.com/tailwindlabs/tailwindcss/issues/3300)\\n*/\\n\\n  ::placeholder {\\n    opacity: 1;\\n  }\\n\\n  /*\\n  Set the default placeholder color to a semi-transparent version of the current text color in browsers that do not\\n  crash when using `color-mix(…)` with `currentcolor`. (https://github.com/tailwindlabs/tailwindcss/issues/17194)\\n*/\\n\\n  @supports (not (-webkit-appearance: -apple-pay-button)) /* Not Safari */ or\\n    (contain-intrinsic-size: 1px) /* Safari 17+ */ {\\n    ::placeholder {\\n      color: color-mix(in oklab, currentcolor 50%, transparent);\\n    }\\n  }\\n\\n  /*\\n  Prevent resizing textareas horizontally by default.\\n*/\\n\\n  textarea {\\n    resize: vertical;\\n  }\\n\\n  /*\\n  Remove the inner padding in Chrome and Safari on macOS.\\n*/\\n\\n  ::-webkit-search-decoration {\\n    -webkit-appearance: none;\\n  }\\n\\n  /*\\n  1. Ensure date/time inputs have the same height when empty in iOS Safari.\\n  2. Ensure text alignment can be changed on date/time inputs in iOS Safari.\\n*/\\n\\n  ::-webkit-date-and-time-value {\\n    min-height: 1lh; /* 1 */\\n    text-align: inherit; /* 2 */\\n  }\\n\\n  /*\\n  Prevent height from changing on date/time inputs in macOS Safari when the input is set to `display: block`.\\n*/\\n\\n  ::-webkit-datetime-edit {\\n    display: inline-flex;\\n  }\\n\\n  /*\\n  Remove excess padding from pseudo-elements in date/time inputs to ensure consistent height across browsers.\\n*/\\n\\n  ::-webkit-datetime-edit-fields-wrapper {\\n    padding: 0;\\n  }\\n\\n  ::-webkit-datetime-edit,\\n  ::-webkit-datetime-edit-year-field,\\n  ::-webkit-datetime-edit-month-field,\\n  ::-webkit-datetime-edit-day-field,\\n  ::-webkit-datetime-edit-hour-field,\\n  ::-webkit-datetime-edit-minute-field,\\n  ::-webkit-datetime-edit-second-field,\\n  ::-webkit-datetime-edit-millisecond-field,\\n  ::-webkit-datetime-edit-meridiem-field {\\n    padding-block: 0;\\n  }\\n\\n  /*\\n  Remove the additional `:invalid` styles in Firefox. (https://github.com/mozilla/gecko-dev/blob/2f9eacd9d3d995c937b4251a5557d95d494c9be1/layout/style/res/forms.css#L728-L737)\\n*/\\n\\n  :-moz-ui-invalid {\\n    box-shadow: none;\\n  }\\n\\n  /*\\n  Correct the inability to style the border radius in iOS Safari.\\n*/\\n\\n  button,\\n  input:where([type=\\\"button\\\"], [type=\\\"reset\\\"], [type=\\\"submit\\\"]),\\n  ::file-selector-button {\\n    appearance: button;\\n  }\\n\\n  /*\\n  Correct the cursor style of increment and decrement buttons in Safari.\\n*/\\n\\n  ::-webkit-inner-spin-button,\\n  ::-webkit-outer-spin-button {\\n    height: auto;\\n  }\\n\\n  /*\\n  Make elements with the HTML hidden attribute stay hidden by default.\\n*/\\n\\n  [hidden]:where(:not([hidden=\\\"until-found\\\"])) {\\n    display: none !important;\\n  }\\n}\\n\\n@layer utilities {\\n  @tailwind utilities;\\n}\\n\"],\"sourceRoot\":\"\"}]);\n// Exports\n/* harmony default export */ __webpack_exports__[\"default\"] = (___CSS_LOADER_EXPORT___);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2J1aWxkL3dlYnBhY2svbG9hZGVycy9jc3MtbG9hZGVyL3NyYy9pbmRleC5qcz8/cnVsZVNldFsxXS5ydWxlc1s3XS5vbmVPZlsxNF0udXNlWzFdIS4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9idWlsZC93ZWJwYWNrL2xvYWRlcnMvcG9zdGNzcy1sb2FkZXIvc3JjL2luZGV4LmpzPz9ydWxlU2V0WzFdLnJ1bGVzWzddLm9uZU9mWzE0XS51c2VbMl0hLi9zdHlsZXMvZ2xvYmFscy5jc3MiLCJtYXBwaW5ncyI6Ijs7O0FBQUE7QUFDd0g7QUFDeEgsOEJBQThCLGtIQUEyQjtBQUN6RDtBQUNBLDZKQUE2SixvQkFBb0IsNENBQTRDLGdCQUFnQixrQkFBa0IscUpBQXFKLGlJQUFpSSwrQ0FBK0MsaURBQWlELGlEQUFpRCxpREFBaUQsaURBQWlELHFEQUFxRCxvREFBb0Qsb0RBQW9ELG9EQUFvRCxvREFBb0QsbURBQW1ELG9EQUFvRCxvREFBb0QsK0JBQStCLGdDQUFnQyxnQ0FBZ0MsZ0NBQWdDLGdDQUFnQyxnQ0FBZ0MsZ0NBQWdDLGdDQUFnQyxnQ0FBZ0MscURBQXFELG1EQUFtRCwrQkFBK0IsZ0NBQWdDLGdDQUFnQyxnQ0FBZ0MsZ0NBQWdDLGdDQUFnQyxnQ0FBZ0MsZ0NBQWdDLGdDQUFnQyxnQ0FBZ0MsMEJBQTBCLDBCQUEwQix5QkFBeUIsNEJBQTRCLDZCQUE2Qix5QkFBeUIsNkNBQTZDLDBCQUEwQixpREFBaUQsMEJBQTBCLGlEQUFpRCx5QkFBeUIsZ0RBQWdELHlCQUF5Qiw2Q0FBNkMsMkJBQTJCLGtEQUFrRCwrQkFBK0IsZ0NBQWdDLGtDQUFrQyw4QkFBOEIsNEJBQTRCLDJCQUEyQiw0QkFBNEIsMEJBQTBCLDJCQUEyQixrREFBa0QscUJBQXFCLDJDQUEyQyx5RUFBeUUsOENBQThDLG1EQUFtRCx1QkFBdUIsMkJBQTJCLDBCQUEwQiwyQkFBMkIsd0JBQXdCLDJCQUEyQiwwQkFBMEIsd0JBQXdCLDJCQUEyQixrREFB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QWEsYUFBYSxhQUFhLGFBQWEsYUFBYSxhQUFhLGNBQWMsWUFBWSxZQUFZLGFBQWEsYUFBYSxhQUFhLGNBQWMsYUFBYSxhQUFhLGFBQWEsYUFBYSxhQUFhLGFBQWEsYUFBYSxhQUFhLGFBQWEsT0FBTyxLQUFLLE1BQU0sS0FBSyxZQUFZLFdBQVcsVUFBVSxVQUFVLEtBQUssT0FBTyxZQUFZLGFBQWEsWUFBWSxVQUFVLFVBQVUsV0FBVyxXQUFXLFdBQVcsWUFBWSxPQUFPLE1BQU0sVUFBVSxVQUFVLFlBQVksTUFBTSxLQUFLLFlBQVksYUFBYSxLQUFLLE1BQU0sWUFBWSxhQUFhLE1BQU0sS0FBSyxVQUFVLFlBQVksYUFBYSxNQUFNLEtBQUssWUFBWSxLQUFLLEtBQUssV0FBVyxXQUFXLFdBQVcsVUFBVSxNQUFNLE1BQU0sVUFBVSxLQUFLLEtBQUssVUFBVSxVQUFVLFlBQVksYUFBYSxNQUFNLEtBQUssVUFBVSxLQUFLLEtBQUssVUFBVSxLQUFLLEtBQUssVUFBVSxZQUFZLGFBQWEsTUFBTSxLQUFLLFVBQVUsS0FBSyxNQUFNLFlBQVksTUFBTSxLQUFLLFlBQVksS0FBSyxLQUFLLFlBQVksS0FBSyxLQUFLLFVBQVUsWUFBWSxNQUFNLEtBQUssVUFBVSxVQUFVLEtBQUssS0FBSyxVQUFVLFlBQVksYUFBYSxhQUFhLFdBQVcsWUFBWSxhQUFhLFdBQVcsS0FBSyxNQUFNLFlBQVksTUFBTSxNQUFNLFlBQVksTUFBTSxNQUFNLFlBQVksS0FBSyxNQUFNLFVBQVUsS0FBSyxLQUFLLFVBQVUsS0FBSyxLQUFLLEtBQUssWUFBWSxNQUFNLFlBQVksS0FBSyxNQUFNLEtBQUssWUFBWSxNQUFNLFlBQVksS0FBSyxNQUFNLE1BQU0sTUFBTSxZQUFZLEtBQUssS0FBSyxZQUFZLEtBQUssTUFBTSxVQUFVLFlBQVksS0FBSyxNQUFNLFlBQVksS0FBSyxNQUFNLFVBQVUsTUFBTSxNQUFNLFlBQVksTUFBTSxNQUFNLFlBQVksS0FBSyxNQUFNLFlBQVksYUFBYSxhQUFhLEtBQUssTUFBTSxVQUFVLEtBQUssTUFBTSxZQUFZLE1BQU0sT0FBTyxNQUFNLEtBQUssWUFBWSxLQUFLLE1BQU0sWUFBWSxLQUFLLE1BQU0sWUFBWSxLQUFLLE1BQU0sWUFBWSxLQUFLLE1BQU0sWUFBWSxLQUFLLE1BQU0sV0FBVyxLQUFLLE1BQU0sWUFBWSxLQUFLLE1BQU0sWUFBWSxLQUFLLE1BQU0sWUFBWSxLQUFLLE1BQU0sWUFBWSxLQUFLLE1BQU0sWUFBWSxLQUFLLE1BQU0sWUFBWSxLQUFLLE1BQU0sWUFBWSxLQUFLLE1BQU0sWUFBWSxLQUFLLE1BQU0sWUFBWSxLQUFLLE1BQU0sWUFBWSxLQUFLLE1BQU0sWUFBWSxLQUFLLE1BQU0sWUFBWSxLQUFLLE1BQU0sWUFBWSxLQUFLLE1BQU0sWUFBWSxLQUFLLE1BQU0sWUFBWSxLQUFLLE1BQU0sWUFBWSxLQUFLLE1BQU0sV0FBVyxLQUFLLE1BQU0sWUFBWSxLQUFLLE1BQU0sWUFBWSxLQUFLLE1BQU0sV0FBVyxLQUFLLE1BQU0sV0FBVyxLQUFLLE1BQU0sV0FBVyxLQUFLLE1BQU0sV0FBVyxLQUFLLE1BQU0sV0FBVyxNQUFNLFlBQVksS0FBSyxNQUFNLFlBQVksS0FBSyxNQUFNLFlBQVksS0FBSyxNQUFNLFlBQVksS0FBSyxNQUFNLFlBQVksS0FBSyxLQUFLLE1BQU0sWUFBWSxLQUFLLE1BQU0sWUFBWSxLQUFLLE1BQU0sWUFBWSxLQUFLLE1BQU0sWUFBWSxLQUFLLE1BQU0sWUFBWSxLQUFLLE1BQU0sWUFBWSxLQUFLLE1BQU0sWUFBWSxLQUFLLE1BQU0sWUFBWSxLQUFLLE1BQU0sWUFBWSxLQUFLLE1BQU0sWUFBWSxLQUFLLE1BQU0sWUFBWSxLQUFLLE1BQU0sWUFBWSxLQUFLLE1BQU0sWUFBWSxLQUFLLE1BQU0sWUFBWSxLQUFLLE1BQU0sWUFBWSxLQUFLLE1BQU0sWUFBWSxLQUFLLE1BQU0sWUFBWSxLQUFLLE1BQU0sV0FBVyxLQUFLLE1BQU0sWUFBWSxLQUFLLE1BQU0sV0FBVyxLQUFLLE1BQU0sV0FBVyxLQUFLLE1BQU0sV0FBVyxLQUFLLE1BQU0sV0FBVyxLQUFLLE1BQU0sWUFBWSxLQUFLLE1BQU0sV0FBVyxLQUFLLE1BQU0sWUFBWSxLQUFLLE1BQU0sWUFBWSxLQUFLLE1BQU0sWUFBWSxLQUFLLE1BQU0sWUFBWSxLQUFLLE1BQU0sWUFBWSxLQUFLLE1BQU0sWUFBWSxLQUFLLE1BQU0sWUFBWSxLQUFLLE1BQU0sWUFBWSxLQUFLLE1BQU0sWUFBWSxLQUFLLE1BQU0sWUFBWSxLQUFLLE1BQU0sWUFBWSxLQUFLLE1BQU0sV0FBVyxLQUFLLE1BQU0sV0FBVyxLQUFLLE1BQU0sWUFBWSxLQUFLLE1BQU0sWUFBWSxLQUFLLE1BQU0sWUFBWSxLQUFLLE1BQU0sWUFBWSxLQUFLLE1BQU0sWUFBWSxLQUFLLE1BQU0sWUFBWSxLQUFLLE1BQU0sWUFBWSxLQUFLLE1BQU0sWUFBWSxLQUFLLE1BQU0sWUFBWSxLQUFLLE1BQU0sWUFBWSxLQUFLLE1BQU0sWUFBWSxLQUFLLE1BQU0sWUFBWSxLQUFLLE1BQU0sWUFBWSxLQUFLLE1BQU0sWUFBWSxLQUFLLE1BQU0sWUFBWSxLQUFLLE1BQU0sV0FBVyxLQUFLLE1BQU0sWUFBWSxLQUFLLE1BQU0sV0FBVyxLQUFLLE1BQU0sWUFBWSxLQUFLLE1BQU0sV0FBVyxLQUFLLE1BQU0sWUFBWSxLQUFLLE1BQU0sV0FBVyxLQUFLLE1BQU0sV0FBVyxLQUFLLE1BQU0sV0FBVyxLQUFLLE1BQU0sV0FBVyxLQUFLLE1BQU0sWUFBWSxhQUFhLEtBQUssTUFBTSxZQUFZLGFBQWEsS0FBSyxNQUFNLFlBQVksYUFBYSxLQUFLLE1BQU0sWUFBWSxhQUFhLEtBQUssTUFBTSxZQUFZLGFBQWEsYUFBYSxhQUFhLEtBQUssTUFBTSxZQUFZLGFBQWEsYUFBYSxhQUFhLEtBQUssTUFBTSxXQUFXLEtBQUssTUFBTSxZQUFZLEtBQUssTUFBTSxZQUFZLEtBQUssTUFBTSxXQUFXLEtBQUssTUFBTSxXQUFXLEtBQUssTUFBTSxXQUFXLEtBQUssTUFBTSxZQUFZLEtBQUssTUFBTSxZQUFZLGFBQWEsYUFBYSxLQUFLLE1BQU0sWUFBWSxLQUFLLE1BQU0sWUFBWSxLQUFLLE1BQU0sWUFBWSxLQUFLLE1BQU0sV0FBVyxLQUFLLE1BQU0sWUFBWSxLQUFLLE1BQU0sWUFBWSxLQUFLLE1BQU0sWUFBWSxLQUFLLE1BQU0sWUFBWSxLQUFLLE1BQU0sWUFBWSxLQUFLLE1BQU0sWUFBWSxLQUFLLE1BQU0sWUFBWSxLQUFLLE1BQU0sWUFBWSxLQUFLLE1BQU0sWUFBWSxLQUFLLE1BQU0sS0FBSyxZQUFZLGFBQWEsYUFBYSxLQUFLLEtBQUssTUFBTSxLQUFLLFlBQVksYUFBYSxhQUFhLEtBQUssS0FBSyxNQUFNLEtBQUssWUFBWSxhQUFhLGFBQWEsS0FBSyxLQUFLLE1BQU0sS0FBSyxZQUFZLGFBQWEsYUFBYSxLQUFLLEtBQUssTUFBTSxLQUFLLFlBQVksYUFBYSxhQUFhLEtBQUssS0FBSyxNQUFNLEtBQUssWUFBWSxhQUFhLGFBQWEsS0FBSyxLQUFLLE1BQU0sWUFBWSxhQUFhLGFBQWEsS0FBSyxNQUFNLFdBQVcsS0FBSyxNQUFNLFlBQVksS0FBSyxNQUFNLFlBQVksS0FBSyxNQUFNLFlBQVksS0FBSyxNQUFNLFlBQVksS0FBSyxNQUFNLFlBQVksS0FBSyxNQUFNLFlBQVksS0FBSyxNQUFNLFlBQVksS0FBSyxNQUFNLFlBQVksS0FBSyxNQUFNLFlBQVksS0FBSyxNQUFNLFlBQVksYUFBYSxLQUFLLE1BQU0sWUFBWSxhQUFhLEtBQUssTUFBTSxZQUFZLGFBQWEsS0FBSyxNQUFNLFlBQVksYUFBYSxLQUFLLE1BQU0sWUFBWSxhQUFhLEtBQUssTUFBTSxZQUFZLGFBQWEsS0FBSyxNQUFNLFlBQVksYUFBYSxLQUFLLE1BQU0sWUFBWSxhQUFhLEtBQUssTUFBTSxZQUFZLGFBQWEsS0FBSyxNQUFNLFlBQVksYUFBYSxLQUFLLE1BQU0sWUFBWSxLQUFLLE1BQU0sWUFBWSxLQUFLLE1BQU0sWUFBWSxLQUFLLE1BQU0sWUFBWSxLQUFLLE1BQU0sWUFBWSxLQUFLLE1BQU0sWUFBWSxLQUFLLE1BQU0sWUFBWSxLQUFLLE1BQU0sWUFBWSxLQUFLLE1BQU0sWUFBWSxLQUFLLE1BQU0sWUFBWSxLQUFLLE1BQU0sWUFBWSxLQUFLLE1BQU0sWUFBWSxNQUFNLFlBQVksS0FBSyxLQUFLLE1BQU0sWUFBWSxNQUFNLFlBQVksS0FBSyxLQUFLLE1BQU0sWUFBWSxLQUFLLE1BQU0sWUFBWSxLQUFLLE1BQU0sWUFBWSxLQUFLLE1BQU0sWUFBWSxLQUFLLE1BQU0sWUFBWSxLQUFLLE1BQU0sWUFBWSxLQUFLLE1BQU0sWUFBWSxLQUFLLE1BQU0sWUFBWSxLQUFLLE1BQU0sWUFBWSxLQUFLLE1BQU0sWUFBWSxLQUFLLE1BQU0sWUFBWSxLQUFLLE1BQU0sWUFBWSxLQUFLLE1BQU0sWUFBWSxLQUFLLE1BQU0sWUFBWSxLQUFLLE1BQU0sWUFBWSxLQUFLLE1BQU0sWUFBWSxLQUFLLE1BQU0sWUFBWSxNQUFNLFlBQVksS0FBSyxLQUFLLE1BQU0sWUFBWSxNQUFNLFlBQVksS0FBSyxLQUFLLE1BQU0sWUFBWSxLQUFLLE1BQU0sWUFBWSxLQUFLLE1BQU0sWUFBWSxhQUFhLEtBQUssTUFBTSxZQUFZLGFBQWEsS0FBSyxNQUFNLFlBQVksYUFBYSxLQUFLLE1BQU0sWUFBWSxhQUFhLEtBQUssTUFBTSxZQUFZLGFBQWEsS0FBSyxNQUFNLFlBQVksYUFBYSxLQUFLLE1BQU0sWUFBWSxhQUFhLEtBQUssTUFBTSxZQUFZLGFBQWEsS0FBSyxNQUFNLFlBQVksYUFBYSxLQUFLLE1BQU0sWUFBWSxLQUFLLE1BQU0sWUFBWSxLQUFLLE1BQU0sWUFBWSxLQUFLLE1BQU0sWUFBWSxLQUFLLE1BQU0sWUFBWSxLQUFLLE1BQU0sWUFBWSxLQUFLLE1BQU0sWUFBWSxLQUFLLE1BQU0sWUFBWSxLQUFLLE1BQU0sWUFBWSxLQUFLLE1BQU0sWUFBWSxLQUFLLE1BQU0sWUFBWSxLQUFLLE1BQU0sWUFBWSxLQUFLLE1BQU0sWUFBWSxLQUFLLE1BQU0sWUFBWSxLQUFLLE1BQU0sWUFBWSxLQUFLLE1BQU0sWUFBWSxLQUFLLE1BQU0sWUFBWSxLQUFLLE1BQU0sWUFBWSxLQUFLLE1BQU0sWUFBWSxLQUFLLE1BQU0sWUFBWSxLQUFLLE1BQU0sWUFBWSxLQUFLLE1BQU0sWUFBWSxLQUFLLE1BQU0sWUFBWSxLQUFLLE1BQU0sWUFBWSxLQUFLLE1BQU0sWUFBWSxLQUFLLE1BQU0sWUFBWSxLQUFLLE1BQU0sWUFBWSxLQUFLLE1BQU0sWUFBWSxLQUFLLE1BQU0sWUFBWSxLQUFLLE1BQU0sWUFBWSxLQUFLLE1BQU0sWUFBWSxLQUFLLE1BQU0sWUFBWSxLQUFLLE1BQU0sWUFBWSxLQUFLLE1BQU0sWUFBWSxLQUFLLE1BQU0sWUFBWSxLQUFLLE1BQU0sWUFBWSxLQUFLLE1BQU0sWUFBWSxhQUFhLEtBQUssTUFBTSxZQUFZLGFBQWEsS0FBSyxNQUFNLFlBQVksYUFBYSxLQUFLLE1BQU0sWUFBWSxhQUFhLEtBQUssTUFBTSxZQUFZLGFBQWEsS0FBSyxNQUFNLFlBQVksYUFBYSxLQUFLLE1BQU0sWUFBWSxLQUFLLE1BQU0sWUFBWSxLQUFLLE1BQU0sWUFBWSxLQUFLLE1BQU0sV0FBVyxLQUFLLE1BQU0sV0FBVyxLQUFLLE1BQU0sV0FBVyxZQUFZLEtBQUssTUFBTSxZQUFZLGFBQWEsS0FBSyxNQUFNLFlBQVksYUFBYSxLQUFLLE1BQU0sWUFBWSxhQUFhLEtBQUssTUFBTSxZQUFZLGFBQWEsS0FBSyxNQUFNLFlBQVksYUFBYSxLQUFLLE1BQU0sWUFBWSxLQUFLLE1BQU0sWUFBWSxLQUFLLE1BQU0sWUFBWSxLQUFLLE1BQU0sWUFBWSxLQUFLLE1BQU0sWUFBWSxLQUFLLE1BQU0sWUFBWSxLQUFLLE1BQU0sWUFBWSxLQUFLLE1BQU0sWUFBWSxLQUFLLE1BQU0sWUFBWSxLQUFLLE1BQU0sWUFBWSxLQUFLLE1BQU0sWUFBWSxLQUFLLE1BQU0sWUFBWSxLQUFLLE1BQU0sWUFBWSxLQUFLLE1BQU0sWUFBWSxLQUFLLE1BQU0sWUFBWSxLQUFLLE1BQU0sWUFBWSxLQUFLLE1BQU0sWUFBWSxLQUFLLE1BQU0sWUFBWSxLQUFLLE1BQU0sWUFBWSxLQUFLLE1BQU0sWUFBWSxLQUFLLE1BQU0sWUFBWSxLQUFLLE1BQU0sWUFBWSxhQUFhLEtBQUssTUFBTSxZQUFZLEtBQUssTUFBTSxZQUFZLEtBQUssTUFBTSxZQUFZLEtBQUssTUFBTSxXQUFXLEtBQUssTUFBTSxXQUFXLEtBQUssTUFBTSxXQUFXLEtBQUssTUFBTSxZQUFZLGFBQWEsS0FBSyxNQUFNLFlBQVksYUFBYSxLQUFLLE1BQU0sWUFBWSxhQUFhLEtBQUssTUFBTSxZQUFZLGFBQWEsS0FBSyxNQUFNLFlBQVksYUFBYSxLQUFLLE1BQU0sWUFBWSxhQUFhLEtBQUssTUFBTSxZQUFZLGFBQWEsS0FBSyxNQUFNLFlBQVksYUFBYSxLQUFLLE1BQU0sWUFBWSxhQUFhLEtBQUssTUFBTSxZQUFZLGFBQWEsS0FBSyxNQUFNLFlBQVksYUFBYSxLQUFLLE1BQU0sWUFBWSxLQUFLLE1BQU0sWUFBWSxhQUFhLGFBQWEsS0FBSyxNQUFNLFlBQVksYUFBYSxhQUFhLEtBQUssTUFBTSxZQUFZLGFBQWEsYUFBYSxLQUFLLE1BQU0sWUFBWSxhQUFhLGFBQWEsS0FBSyxNQUFNLFlBQVksYUFBYSxhQUFhLEtBQUssTUFBTSxZQUFZLGFBQWEsYUFBYSxLQUFLLE1BQU0sWUFBWSxhQUFhLEtBQUssTUFBTSxZQUFZLGFBQWEsS0FBSyxNQUFNLFlBQVksYUFBYSxLQUFLLE1BQU0sWUFBWSxhQUFhLEtBQUssTUFBTSxZQUFZLGFBQWEsS0FBSyxNQUFNLFlBQVksYUFBYSxhQUFhLEtBQUssTUFBTSxLQUFLLEtBQUssWUFBWSxLQUFLLEtBQUssS0FBSyxNQUFNLEtBQUssS0FBSyxXQUFXLEtBQUssS0FBSyxLQUFLLE1BQU0sS0FBSyxLQUFLLFlBQVksYUFBYSxhQUFhLGFBQWEsS0FBSyxLQUFLLEtBQUssTUFBTSxLQUFLLEtBQUssWUFBWSxLQUFLLEtBQUssS0FBSyxNQUFNLEtBQUssS0FBSyxZQUFZLEtBQUssS0FBSyxLQUFLLE1BQU0sS0FBSyxLQUFLLFlBQVksS0FBSyxLQUFLLEtBQUssTUFBTSxLQUFLLEtBQUssWUFBWSxLQUFLLEtBQUssS0FBSyxNQUFNLEtBQUssS0FBSyxZQUFZLEtBQUssS0FBSyxLQUFLLE1BQU0sS0FBSyxLQUFLLFlBQVksS0FBSyxLQUFLLEtBQUssTUFBTSxLQUFLLEtBQUssWUFBWSxLQUFLLEtBQUssS0FBSyxNQUFNLEtBQUssS0FBSyxZQUFZLEtBQUssS0FBSyxLQUFLLE1BQU0sS0FBSyxLQUFLLFlBQVksS0FBSyxLQUFLLEtBQUssTUFBTSxLQUFLLEtBQUssWUFBWSxLQUFLLEtBQUssS0FBSyxNQUFNLEtBQUssS0FBSyxZQUFZLEtBQUssS0FBSyxLQUFLLE1BQU0sS0FBSyxLQUFLLFlBQVksS0FBSyxLQUFLLEtBQUssTUFBTSxLQUFLLEtBQUssWUFBWSxLQUFLLEtBQUssS0FBSyxNQUFNLEtBQUssS0FBSyxZQUFZLEtBQUssS0FBSyxLQUFLLE1BQU0sS0FBSyxLQUFLLFlBQVksS0FBSyxLQUFLLEtBQUssTUFBTSxLQUFLLEtBQUssWUFBWSxLQUFLLEtBQUssS0FBSyxNQUFNLEtBQUssS0FBSyxZQUFZLEtBQUssS0FBSyxLQUFLLE1BQU0sS0FBSyxLQUFLLFdBQVcsS0FBSyxLQUFLLEtBQUssTUFBTSxLQUFLLEtBQUssWUFBWSxhQUFhLEtBQUssS0FBSyxLQUFLLE1BQU0sS0FBSyxLQUFLLFlBQVksYUFBYSxLQUFLLEtBQUssS0FBSyxNQUFNLEtBQUssS0FBSyxZQUFZLGFBQWEsS0FBSyxLQUFLLEtBQUssTUFBTSxLQUFLLFlBQVksS0FBSyxLQUFLLE1BQU0sS0FBSyxZQUFZLGFBQWEsS0FBSyxLQUFLLE1BQU0sS0FBSyxZQUFZLGFBQWEsS0FBSyxLQUFLLE1BQU0sS0FBSyxZQUFZLEtBQUssS0FBSyxNQUFNLEtBQUssWUFBWSxLQUFLLEtBQUssTUFBTSxLQUFLLFlBQVksS0FBSyxLQUFLLE1BQU0sS0FBSyxZQUFZLGFBQWEsS0FBSyxLQUFLLE1BQU0sS0FBSyxZQUFZLEtBQUssS0FBSyxNQUFNLEtBQUssWUFBWSxLQUFLLEtBQUssTUFBTSxLQUFLLFlBQVksS0FBSyxLQUFLLE1BQU0sS0FBSyxZQUFZLEtBQUssS0FBSyxNQUFNLEtBQUssWUFBWSxLQUFLLEtBQUssTUFBTSxLQUFLLFlBQVksS0FBSyxLQUFLLE1BQU0sS0FBSyxZQUFZLEtBQUssS0FBSyxNQUFNLEtBQUssWUFBWSxLQUFLLEtBQUssS0FBSyxRQUFRLFlBQVksYUFBYSxNQUFNLEtBQUssWUFBWSxhQUFhLFdBQVcsVUFBVSxLQUFLLEtBQUssS0FBSyxVQUFVLFlBQVksYUFBYSxNQUFNLEtBQUssVUFBVSxVQUFVLFlBQVksYUFBYSxhQUFhLGFBQWEsWUFBWSxhQUFhLE1BQU0sS0FBSyxZQUFZLE1BQU0sS0FBSyxPQUFPLFdBQVcsWUFBWSxhQUFhLEtBQUssTUFBTSxXQUFXLFlBQVksYUFBYSxLQUFLLE1BQU0sV0FBVyxZQUFZLGFBQWEsS0FBSyxNQUFNLFdBQVcsWUFBWSxhQUFhLEtBQUssTUFBTSxXQUFXLFlBQVksYUFBYSxLQUFLLE1BQU0sV0FBVyxZQUFZLGFBQWEsS0FBSyxNQUFNLFdBQVcsWUFBWSxLQUFLLE1BQU0sV0FBVyxZQUFZLEtBQUssTUFBTSxXQUFXLFlBQVksS0FBSyxNQUFNLFdBQVcsWUFBWSxLQUFLLE1BQU0sV0FBVyxZQUFZLEtBQUssTUFBTSxXQUFXLFlBQVksYUFBYSxLQUFLLE1BQU0sV0FBVyxZQUFZLGFBQWEsS0FBSyxNQUFNLFdBQVcsWUFBWSxhQUFhLEtBQUssTUFBTSxXQUFXLFlBQVksS0FBSyxNQUFNLFlBQVksWUFBWSxhQUFhLEtBQUssTUFBTSxZQUFZLFlBQVksYUFBYSxLQUFLLE1BQU0sWUFBWSxZQUFZLGFBQWEsS0FBSyxNQUFNLFdBQVcsWUFBWSxLQUFLLE1BQU0sV0FBVyxZQUFZLEtBQUssTUFBTSxZQUFZLFlBQVksYUFBYSxLQUFLLE1BQU0sWUFBWSxZQUFZLGFBQWEsS0FBSyxNQUFNLFlBQVksWUFBWSxhQUFhLEtBQUssTUFBTSxXQUFXLFlBQVksS0FBSyxNQUFNLFdBQVcsWUFBWSxLQUFLLE1BQU0sV0FBVyxZQUFZLEtBQUssTUFBTSxXQUFXLFlBQVksS0FBSyxNQUFNLFdBQVcsWUFBWSxLQUFLLE1BQU0sV0FBVyxZQUFZLEtBQUssTUFBTSxXQUFXLFlBQVksS0FBSyxNQUFNLFdBQVcsWUFBWSxhQUFhLEtBQUssTUFBTSxXQUFXLFlBQVksS0FBSyxNQUFNLFlBQVksWUFBWSxhQUFhLEtBQUssTUFBTSxXQUFXLFlBQVksYUFBYSxLQUFLLE1BQU0sV0FBVyxZQUFZLEtBQUssTUFBTSxZQUFZLFlBQVksYUFBYSxLQUFLLE1BQU0sV0FBVyxZQUFZLEtBQUssTUFBTSxXQUFXLFlBQVksYUFBYSxLQUFLLE1BQU0sV0FBVyxZQUFZLEtBQUssTUFBTSxXQUFXLFlBQVksYUFBYSxLQUFLLE1BQU0sV0FBVyxZQUFZLEtBQUssTUFBTSxZQUFZLFlBQVksYUFBYSxLQUFLLE1BQU0sV0FBVyxZQUFZLGFBQWEsS0FBSyxNQUFNLFdBQVcsWUFBWSxhQUFhLEtBQUssTUFBTSxXQUFXLFlBQVksYUFBYSxLQUFLLE1BQU0sV0FBVyxZQUFZLEtBQUssTUFBTSxXQUFXLFlBQVksS0FBSyxNQUFNLFdBQVcsWUFBWSxLQUFLLE1BQU0sV0FBVyxZQUFZLEtBQUssTUFBTSxXQUFXLFlBQVksS0FBSyxNQUFNLFdBQVcsWUFBWSxLQUFLLE1BQU0sV0FBVyxZQUFZLEtBQUssTUFBTSxXQUFXLFlBQVksS0FBSyxNQUFNLFdBQVcsWUFBWSxLQUFLLE1BQU0sV0FBVyxZQUFZLEtBQUssTUFBTSxXQUFXLFlBQVksS0FBSyxNQUFNLFlBQVksWUFBWSxhQUFhLEtBQUssTUFBTSxXQUFXLFlBQVksS0FBSyxNQUFNLFdBQVcsWUFBWSxLQUFLLE1BQU0sV0FBVyxZQUFZLEtBQUssTUFBTSxXQUFXLFlBQVksS0FBSyxNQUFNLFdBQVcsWUFBWSxLQUFLLE1BQU0sV0FBVyxZQUFZLEtBQUssTUFBTSxXQUFXLFlBQVksS0FBSyxNQUFNLFdBQVcsWUFBWSxLQUFLLE1BQU0sV0FBVyxZQUFZLEtBQUssTUFBTSxXQUFXLFlBQVksS0FBSyxNQUFNLFdBQVcsWUFBWSxLQUFLLE1BQU0sV0FBVyxZQUFZLEtBQUssTUFBTSxLQUFLLEtBQUssWUFBWSxhQUFhLGFBQWEsWUFBWSxZQUFZLFlBQVksYUFBYSxhQUFhLGFBQWEsYUFBYSxhQUFhLGFBQWEsYUFBYSxhQUFhLGFBQWEsYUFBYSxhQUFhLGFBQWEsYUFBYSxhQUFhLGFBQWEsYUFBYSxhQUFhLGFBQWEsYUFBYSxhQUFhLGFBQWEsYUFBYSxhQUFhLGFBQWEsYUFBYSxhQUFhLGFBQWEsYUFBYSxhQUFhLGFBQWEsYUFBYSxhQUFhLGFBQWEsYUFBYSxhQUFhLGFBQWEsYUFBYSxhQUFhLGFBQWEsYUFBYSxhQUFhLGFBQWEsYUFBYSxhQUFhLGFBQWEsYUFBYSxhQUFhLGFBQWEsYUFBYSxhQUFhLGFBQWEsYUFBYSxhQUFhLGFBQWEsYUFBYSxhQUFhLGFBQWEsYUFBYSxhQUFhLGFBQWEsYUFBYSxhQUFhLGFBQWEsS0FBSyxLQUFLLDZFQUE2RSwwQkFBMEIsWUFBWSxpREFBaUQsOEJBQThCLDhCQUE4Qiw4QkFBOEIsOEJBQThCLDhCQUE4Qiw4QkFBOEIsOEJBQThCLDhCQUE4Qiw4QkFBOEIsMkVBQTJFLGlDQUFpQyxpQ0FBaUMsaUNBQWlDLGlDQUFpQyxpQ0FBaUMsaUNBQWlDLGlDQUFpQyxpQ0FBaUMsaUNBQWlDLCtEQUErRCw2QkFBNkIsMkJBQTJCLDBCQUEwQiw0REFBNEQsOEJBQThCLDhCQUE4Qiw4QkFBOEIsOEJBQThCLDhCQUE4Qiw4QkFBOEIsOEJBQThCLDhCQUE4Qiw4QkFBOEIsb0RBQW9ELHlCQUF5Qix3QkFBd0IseUJBQXlCLHNCQUFzQix5QkFBeUIsd0JBQXdCLHNCQUFzQix5QkFBeUIsdUJBQXVCLHVCQUF1Qix1QkFBdUIsK0VBQStFLHVHQUF1Ryx1REFBdUQsaUVBQWlFLGdDQUFnQywrQkFBK0IsZ0NBQWdDLDZCQUE2QixnQ0FBZ0MsOEJBQThCLG1FQUFtRSxtQ0FBbUMsaUNBQWlDLEdBQUcsK0JBQStCLGtFQUFrRSx5Q0FBeUMsR0FBRyxVQUFVLDJDQUEyQyxpQ0FBaUMsY0FBYyxlQUFlLEdBQUcsMEVBQTBFLHlEQUF5RCxrQkFBa0IsMkRBQTJELHlCQUF5QixLQUFLLHFCQUFxQixrQkFBa0IsbUJBQW1CLDBCQUEwQix5QkFBeUIsOEJBQThCLDZDQUE2QyxzQkFBc0IsdUNBQXVDLEtBQUssMkJBQTJCLDRCQUE0QixLQUFLLEdBQUcsK0NBQStDLGtCQUFrQixvQkFBb0IsNEpBQTRKLGtGQUFrRix3SUFBd0ksaURBQWlELGlEQUFpRCxpREFBaUQsaURBQWlELGlEQUFpRCxpREFBaUQsaURBQWlELGlEQUFpRCxpREFBaUQsaURBQWlELGlEQUFpRCxtREFBbUQsb0RBQW9ELG9EQUFvRCxtREFBbUQsa0RBQWtELG9EQUFvRCxvREFBb0Qsb0RBQW9ELGtEQUFrRCxvREFBb0Qsb0RBQW9ELG9EQUFvRCxtREFBbUQsa0RBQWtELG1EQUFtRCxtREFBbUQsa0RBQWtELG1EQUFtRCxtREFBbUQsbURBQW1ELG1EQUFtRCxtREFBbUQsc0RBQXNELHFEQUFxRCxvREFBb0Qsb0RBQW9ELG9EQUFvRCxvREFBb0Qsb0RBQW9ELG9EQUFvRCxvREFBb0Qsb0RBQW9ELG9EQUFvRCxvREFBb0QsbURBQW1ELG1EQUFtRCxtREFBbUQsa0RBQWtELGtEQUFrRCxpREFBaUQsbURBQW1ELG1EQUFtRCxtREFBbUQsbURBQW1ELHFEQUFxRCxvREFBb0Qsb0RBQW9ELG1EQUFtRCxvREFBb0Qsb0RBQW9ELG9EQUFvRCxvREFBb0Qsb0RBQW9ELG9EQUFvRCxvREFBb0QsdURBQXVELG9EQUFvRCxxREFBcUQsc0RBQXNELHNEQUFzRCxvREFBb0Qsc0RBQXNELHNEQUFzRCxzREFBc0QscURBQXFELHNEQUFzRCxtREFBbUQsbURBQW1ELGlEQUFpRCxtREFBbUQsbURBQW1ELGtEQUFrRCxpREFBaUQsbURBQW1ELG1EQUFtRCxtREFBbUQsbURBQW1ELG9EQUFvRCxtREFBbUQsa0RBQWtELG1EQUFtRCxrREFBa0QsbURBQW1ELG1EQUFtRCxpREFBaUQsaURBQWlELGtEQUFrRCxtREFBbUQsa0RBQWtELGtEQUFrRCxrREFBa0Qsa0RBQWtELGlEQUFpRCxrREFBa0Qsa0RBQWtELGdEQUFnRCxnREFBZ0QsaURBQWlELGtEQUFrRCxrREFBa0QsbURBQW1ELG1EQUFtRCxtREFBbUQsbURBQW1ELG1EQUFtRCxtREFBbUQsbURBQW1ELG1EQUFtRCxtREFBbUQsbURBQW1ELHNEQUFzRCxtREFBbUQsbURBQW1ELHFEQUFxRCxx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S0FBSyx5S0FBeUssaUJBQWlCLEtBQUssc1dBQXNXLHVCQUF1QixLQUFLLHFOQUFxTix1QkFBdUIsS0FBSyxnTUFBZ00seUJBQXlCLEtBQUsseUpBQXlKLG1CQUFtQixLQUFLLDBJQUEwSSwrQkFBK0IsS0FBSyxHQUFHLHNCQUFzQix3QkFBd0IsR0FBRyxxQkFBcUI7QUFDMWg5RjtBQUNBLCtEQUFlLHVCQUF1QixFQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL3N0eWxlcy9nbG9iYWxzLmNzcz84YzUzIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIEltcG9ydHNcbmltcG9ydCBfX19DU1NfTE9BREVSX0FQSV9JTVBPUlRfX18gZnJvbSBcIi4uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvYnVpbGQvd2VicGFjay9sb2FkZXJzL2Nzcy1sb2FkZXIvc3JjL3J1bnRpbWUvYXBpLmpzXCI7XG52YXIgX19fQ1NTX0xPQURFUl9FWFBPUlRfX18gPSBfX19DU1NfTE9BREVSX0FQSV9JTVBPUlRfX18odHJ1ZSk7XG4vLyBNb2R1bGVcbl9fX0NTU19MT0FERVJfRVhQT1JUX19fLnB1c2goW21vZHVsZS5pZCwgXCIvKiEgdGFpbHdpbmRjc3MgdjQuMS4xMCB8IE1JVCBMaWNlbnNlIHwgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20gKi9cXG5AaW1wb3J0IHVybCgnaHR0cHM6Ly9yc21zLm1lL2ludGVyL2ludGVyLmNzcycpO1xcbkBsYXllciBwcm9wZXJ0aWVzO1xcbkBsYXllciB0aGVtZSwgYmFzZSwgY29tcG9uZW50cywgdXRpbGl0aWVzO1xcbkBsYXllciB0aGVtZSB7XFxuICA6cm9vdCwgOmhvc3Qge1xcbiAgICAtLWZvbnQtc2FuczogdWktc2Fucy1zZXJpZiwgc3lzdGVtLXVpLCBzYW5zLXNlcmlmLCBcXFwiQXBwbGUgQ29sb3IgRW1vamlcXFwiLFxcbiAgICAgIFxcXCJTZWdvZSBVSSBFbW9qaVxcXCIsIFxcXCJTZWdvZSBVSSBTeW1ib2xcXFwiLCBcXFwiTm90byBDb2xvciBFbW9qaVxcXCI7XFxuICAgIC0tZm9udC1tb25vOiB1aS1tb25vc3BhY2UsIFNGTW9uby1SZWd1bGFyLCBNZW5sbywgTW9uYWNvLCBDb25zb2xhcywgXFxcIkxpYmVyYXRpb24gTW9ub1xcXCIsXFxuICAgICAgXFxcIkNvdXJpZXIgTmV3XFxcIiwgbW9ub3NwYWNlO1xcbiAgICAtLWNvbG9yLXJlZC01MDogb2tsY2goOTcuMSUgMC4wMTMgMTcuMzgpO1xcbiAgICAtLWNvbG9yLXJlZC0yMDA6IG9rbGNoKDg4LjUlIDAuMDYyIDE4LjMzNCk7XFxuICAgIC0tY29sb3ItcmVkLTUwMDogb2tsY2goNjMuNyUgMC4yMzcgMjUuMzMxKTtcXG4gICAgLS1jb2xvci1yZWQtNjAwOiBva2xjaCg1Ny43JSAwLjI0NSAyNy4zMjUpO1xcbiAgICAtLWNvbG9yLXJlZC03MDA6IG9rbGNoKDUwLjUlIDAuMjEzIDI3LjUxOCk7XFxuICAgIC0tY29sb3IteWVsbG93LTEwMDogb2tsY2goOTcuMyUgMC4wNzEgMTAzLjE5Myk7XFxuICAgIC0tY29sb3IteWVsbG93LTMwMDogb2tsY2goOTAuNSUgMC4xODIgOTguMTExKTtcXG4gICAgLS1jb2xvci15ZWxsb3ctNDAwOiBva2xjaCg4NS4yJSAwLjE5OSA5MS45MzYpO1xcbiAgICAtLWNvbG9yLXllbGxvdy04MDA6IG9rbGNoKDQ3LjYlIDAuMTE0IDYxLjkwNyk7XFxuICAgIC0tY29sb3ItZ3JlZW4tMTAwOiBva2xjaCg5Ni4yJSAwLjA0NCAxNTYuNzQzKTtcXG4gICAgLS1jb2xvci1ncmVlbi0zMDA6IG9rbGNoKDg3LjElIDAuMTUgMTU0LjQ0OSk7XFxuICAgIC0tY29sb3ItZ3JlZW4tNTAwOiBva2xjaCg3Mi4zJSAwLjIxOSAxNDkuNTc5KTtcXG4gICAgLS1jb2xvci1ncmVlbi03MDA6IG9rbGNoKDUyLjclIDAuMTU0IDE1MC4wNjkpO1xcbiAgICAtLWNvbG9yLWJsdWUtNTA6ICNFQUYyRkM7XFxuICAgIC0tY29sb3ItYmx1ZS0xMDA6ICNENUU1Rjg7XFxuICAgIC0tY29sb3ItYmx1ZS0yMDA6ICNBNEM1RjQ7XFxuICAgIC0tY29sb3ItYmx1ZS0zMDA6ICM3RUFCRUY7XFxuICAgIC0tY29sb3ItYmx1ZS00MDA6ICM1Rjk2RUI7XFxuICAgIC0tY29sb3ItYmx1ZS01MDA6ICM0QTg2RTg7XFxuICAgIC0tY29sb3ItYmx1ZS02MDA6ICMyQTVEQjA7XFxuICAgIC0tY29sb3ItYmx1ZS03MDA6ICMxRTQ0ODQ7XFxuICAgIC0tY29sb3ItYmx1ZS04MDA6ICMxNjMzNjY7XFxuICAgIC0tY29sb3ItcHVycGxlLTMwMDogb2tsY2goODIuNyUgMC4xMTkgMzA2LjM4Myk7XFxuICAgIC0tY29sb3ItcHVycGxlLTUwMDogb2tsY2goNjIuNyUgMC4yNjUgMzAzLjkpO1xcbiAgICAtLWNvbG9yLWdyYXktNTA6ICNGNUY4RkE7XFxuICAgIC0tY29sb3ItZ3JheS0xMDA6ICNFOUVGRjU7XFxuICAgIC0tY29sb3ItZ3JheS0yMDA6ICNEOUUyRUM7XFxuICAgIC0tY29sb3ItZ3JheS0zMDA6ICNDQkQ1RTA7XFxuICAgIC0tY29sb3ItZ3JheS00MDA6ICM5RkIzQzg7XFxuICAgIC0tY29sb3ItZ3JheS01MDA6ICM3RDhGQUY7XFxuICAgIC0tY29sb3ItZ3JheS02MDA6ICM1NDY3ODU7XFxuICAgIC0tY29sb3ItZ3JheS03MDA6ICMzRDRCNjY7XFxuICAgIC0tY29sb3ItZ3JheS04MDA6ICMyRDM3NDg7XFxuICAgIC0tY29sb3ItZ3JheS05MDA6ICMxQTIwMkM7XFxuICAgIC0tY29sb3ItYmxhY2s6ICMwMDA7XFxuICAgIC0tY29sb3Itd2hpdGU6ICNmZmY7XFxuICAgIC0tc3BhY2luZzogMC4yNXJlbTtcXG4gICAgLS1jb250YWluZXItbWQ6IDI4cmVtO1xcbiAgICAtLWNvbnRhaW5lci0yeGw6IDQycmVtO1xcbiAgICAtLXRleHQteHM6IDAuNzVyZW07XFxuICAgIC0tdGV4dC14cy0tbGluZS1oZWlnaHQ6IGNhbGMoMSAvIDAuNzUpO1xcbiAgICAtLXRleHQtc206IDAuODc1cmVtO1xcbiAgICAtLXRleHQtc20tLWxpbmUtaGVpZ2h0OiBjYWxjKDEuMjUgLyAwLjg3NSk7XFxuICAgIC0tdGV4dC1sZzogMS4xMjVyZW07XFxuICAgIC0tdGV4dC1sZy0tbGluZS1oZWlnaHQ6IGNhbGMoMS43NSAvIDEuMTI1KTtcXG4gICAgLS10ZXh0LXhsOiAxLjI1cmVtO1xcbiAgICAtLXRleHQteGwtLWxpbmUtaGVpZ2h0OiBjYWxjKDEuNzUgLyAxLjI1KTtcXG4gICAgLS10ZXh0LTJ4bDogMS41cmVtO1xcbiAgICAtLXRleHQtMnhsLS1saW5lLWhlaWdodDogY2FsYygyIC8gMS41KTtcXG4gICAgLS10ZXh0LTN4bDogMS44NzVyZW07XFxuICAgIC0tdGV4dC0zeGwtLWxpbmUtaGVpZ2h0OiBjYWxjKDIuMjUgLyAxLjg3NSk7XFxuICAgIC0tZm9udC13ZWlnaHQtbGlnaHQ6IDMwMDtcXG4gICAgLS1mb250LXdlaWdodC1tZWRpdW06IDUwMDtcXG4gICAgLS1mb250LXdlaWdodC1zZW1pYm9sZDogNjAwO1xcbiAgICAtLWZvbnQtd2VpZ2h0LWJvbGQ6IDcwMDtcXG4gICAgLS1sZWFkaW5nLXRpZ2h0OiAxLjI1O1xcbiAgICAtLXJhZGl1cy1zbTogMC4yNXJlbTtcXG4gICAgLS1yYWRpdXMtbWQ6IDAuMzc1cmVtO1xcbiAgICAtLXJhZGl1cy1sZzogMC41cmVtO1xcbiAgICAtLXJhZGl1cy14bDogMC43NXJlbTtcXG4gICAgLS1lYXNlLWluLW91dDogY3ViaWMtYmV6aWVyKDAuNCwgMCwgMC4yLCAxKTtcXG4gICAgLS1ibHVyLXNtOiA4cHg7XFxuICAgIC0tZGVmYXVsdC10cmFuc2l0aW9uLWR1cmF0aW9uOiAxNTBtcztcXG4gICAgLS1kZWZhdWx0LXRyYW5zaXRpb24tdGltaW5nLWZ1bmN0aW9uOiBjdWJpYy1iZXppZXIoMC40LCAwLCAwLjIsIDEpO1xcbiAgICAtLWRlZmF1bHQtZm9udC1mYW1pbHk6IHZhcigtLWZvbnQtc2Fucyk7XFxuICAgIC0tZGVmYXVsdC1tb25vLWZvbnQtZmFtaWx5OiB2YXIoLS1mb250LW1vbm8pO1xcbiAgICAtLXNwYWNpbmctMDogMHB4O1xcbiAgICAtLXNwYWNpbmctMTogMC4yNXJlbTtcXG4gICAgLS1zcGFjaW5nLTI6IDAuNXJlbTtcXG4gICAgLS1zcGFjaW5nLTM6IDAuNzVyZW07XFxuICAgIC0tc3BhY2luZy00OiAxcmVtO1xcbiAgICAtLXNwYWNpbmctNTogMS4yNXJlbTtcXG4gICAgLS1zcGFjaW5nLTY6IDEuNXJlbTtcXG4gICAgLS1zcGFjaW5nLTg6IDJyZW07XFxuICAgIC0tc3BhY2luZy0xMDogMi41cmVtO1xcbiAgICAtLWZvbnQtZmFtaWx5LXNhbnM6ICdJbnRlciB2YXInLCBzYW5zLXNlcmlmO1xcbiAgfVxcbn1cXG5AbGF5ZXIgYmFzZSB7XFxuICAqLCA6OmFmdGVyLCA6OmJlZm9yZSwgOjpiYWNrZHJvcCwgOjpmaWxlLXNlbGVjdG9yLWJ1dHRvbiB7XFxuICAgIGJveC1zaXppbmc6IGJvcmRlci1ib3g7XFxuICAgIG1hcmdpbjogMDtcXG4gICAgcGFkZGluZzogMDtcXG4gICAgYm9yZGVyOiAwIHNvbGlkO1xcbiAgfVxcbiAgaHRtbCwgOmhvc3Qge1xcbiAgICBsaW5lLWhlaWdodDogMS41O1xcbiAgICAtd2Via2l0LXRleHQtc2l6ZS1hZGp1c3Q6IDEwMCU7XFxuICAgIC1tb3otdGFiLXNpemU6IDQ7XFxuICAgICAgLW8tdGFiLXNpemU6IDQ7XFxuICAgICAgICAgdGFiLXNpemU6IDQ7XFxuICAgIGZvbnQtZmFtaWx5OiB2YXIoLS1kZWZhdWx0LWZvbnQtZmFtaWx5LCB1aS1zYW5zLXNlcmlmLCBzeXN0ZW0tdWksIHNhbnMtc2VyaWYsIFxcXCJBcHBsZSBDb2xvciBFbW9qaVxcXCIsIFxcXCJTZWdvZSBVSSBFbW9qaVxcXCIsIFxcXCJTZWdvZSBVSSBTeW1ib2xcXFwiLCBcXFwiTm90byBDb2xvciBFbW9qaVxcXCIpO1xcbiAgICBmb250LWZlYXR1cmUtc2V0dGluZ3M6IHZhcigtLWRlZmF1bHQtZm9udC1mZWF0dXJlLXNldHRpbmdzLCBub3JtYWwpO1xcbiAgICBmb250LXZhcmlhdGlvbi1zZXR0aW5nczogdmFyKC0tZGVmYXVsdC1mb250LXZhcmlhdGlvbi1zZXR0aW5ncywgbm9ybWFsKTtcXG4gICAgLXdlYmtpdC10YXAtaGlnaGxpZ2h0LWNvbG9yOiB0cmFuc3BhcmVudDtcXG4gIH1cXG4gIGhyIHtcXG4gICAgaGVpZ2h0OiAwO1xcbiAgICBjb2xvcjogaW5oZXJpdDtcXG4gICAgYm9yZGVyLXRvcC13aWR0aDogMXB4O1xcbiAgfVxcbiAgYWJicjp3aGVyZShbdGl0bGVdKSB7XFxuICAgIC13ZWJraXQtdGV4dC1kZWNvcmF0aW9uOiB1bmRlcmxpbmUgZG90dGVkO1xcbiAgICB0ZXh0LWRlY29yYXRpb246IHVuZGVybGluZSBkb3R0ZWQ7XFxuICB9XFxuICBoMSwgaDIsIGgzLCBoNCwgaDUsIGg2IHtcXG4gICAgZm9udC1zaXplOiBpbmhlcml0O1xcbiAgICBmb250LXdlaWdodDogaW5oZXJpdDtcXG4gIH1cXG4gIGEge1xcbiAgICBjb2xvcjogaW5oZXJpdDtcXG4gICAgLXdlYmtpdC10ZXh0LWRlY29yYXRpb246IGluaGVyaXQ7XFxuICAgIHRleHQtZGVjb3JhdGlvbjogaW5oZXJpdDtcXG4gIH1cXG4gIGIsIHN0cm9uZyB7XFxuICAgIGZvbnQtd2VpZ2h0OiBib2xkZXI7XFxuICB9XFxuICBjb2RlLCBrYmQsIHNhbXAsIHByZSB7XFxuICAgIGZvbnQtZmFtaWx5OiB2YXIoLS1kZWZhdWx0LW1vbm8tZm9udC1mYW1pbHksIHVpLW1vbm9zcGFjZSwgU0ZNb25vLVJlZ3VsYXIsIE1lbmxvLCBNb25hY28sIENvbnNvbGFzLCBcXFwiTGliZXJhdGlvbiBNb25vXFxcIiwgXFxcIkNvdXJpZXIgTmV3XFxcIiwgbW9ub3NwYWNlKTtcXG4gICAgZm9udC1mZWF0dXJlLXNldHRpbmdzOiB2YXIoLS1kZWZhdWx0LW1vbm8tZm9udC1mZWF0dXJlLXNldHRpbmdzLCBub3JtYWwpO1xcbiAgICBmb250LXZhcmlhdGlvbi1zZXR0aW5nczogdmFyKC0tZGVmYXVsdC1tb25vLWZvbnQtdmFyaWF0aW9uLXNldHRpbmdzLCBub3JtYWwpO1xcbiAgICBmb250LXNpemU6IDFlbTtcXG4gIH1cXG4gIHNtYWxsIHtcXG4gICAgZm9udC1zaXplOiA4MCU7XFxuICB9XFxuICBzdWIsIHN1cCB7XFxuICAgIGZvbnQtc2l6ZTogNzUlO1xcbiAgICBsaW5lLWhlaWdodDogMDtcXG4gICAgcG9zaXRpb246IHJlbGF0aXZlO1xcbiAgICB2ZXJ0aWNhbC1hbGlnbjogYmFzZWxpbmU7XFxuICB9XFxuICBzdWIge1xcbiAgICBib3R0b206IC0wLjI1ZW07XFxuICB9XFxuICBzdXAge1xcbiAgICB0b3A6IC0wLjVlbTtcXG4gIH1cXG4gIHRhYmxlIHtcXG4gICAgdGV4dC1pbmRlbnQ6IDA7XFxuICAgIGJvcmRlci1jb2xvcjogaW5oZXJpdDtcXG4gICAgYm9yZGVyLWNvbGxhcHNlOiBjb2xsYXBzZTtcXG4gIH1cXG4gIDotbW96LWZvY3VzcmluZyB7XFxuICAgIG91dGxpbmU6IGF1dG87XFxuICB9XFxuICBwcm9ncmVzcyB7XFxuICAgIHZlcnRpY2FsLWFsaWduOiBiYXNlbGluZTtcXG4gIH1cXG4gIHN1bW1hcnkge1xcbiAgICBkaXNwbGF5OiBsaXN0LWl0ZW07XFxuICB9XFxuICBvbCwgdWwsIG1lbnUge1xcbiAgICBsaXN0LXN0eWxlOiBub25lO1xcbiAgfVxcbiAgaW1nLCBzdmcsIHZpZGVvLCBjYW52YXMsIGF1ZGlvLCBpZnJhbWUsIGVtYmVkLCBvYmplY3Qge1xcbiAgICBkaXNwbGF5OiBibG9jaztcXG4gICAgdmVydGljYWwtYWxpZ246IG1pZGRsZTtcXG4gIH1cXG4gIGltZywgdmlkZW8ge1xcbiAgICBtYXgtd2lkdGg6IDEwMCU7XFxuICAgIGhlaWdodDogYXV0bztcXG4gIH1cXG4gIGJ1dHRvbiwgaW5wdXQsIHNlbGVjdCwgb3B0Z3JvdXAsIHRleHRhcmVhLCA6OmZpbGUtc2VsZWN0b3ItYnV0dG9uIHtcXG4gICAgZm9udDogaW5oZXJpdDtcXG4gICAgZm9udC1mZWF0dXJlLXNldHRpbmdzOiBpbmhlcml0O1xcbiAgICBmb250LXZhcmlhdGlvbi1zZXR0aW5nczogaW5oZXJpdDtcXG4gICAgbGV0dGVyLXNwYWNpbmc6IGluaGVyaXQ7XFxuICAgIGNvbG9yOiBpbmhlcml0O1xcbiAgICBib3JkZXItcmFkaXVzOiAwO1xcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiB0cmFuc3BhcmVudDtcXG4gICAgb3BhY2l0eTogMTtcXG4gIH1cXG4gIDp3aGVyZShzZWxlY3Q6aXMoW211bHRpcGxlXSwgW3NpemVdKSkgb3B0Z3JvdXAge1xcbiAgICBmb250LXdlaWdodDogYm9sZGVyO1xcbiAgfVxcbiAgOndoZXJlKHNlbGVjdDppcyhbbXVsdGlwbGVdLCBbc2l6ZV0pKSBvcHRncm91cCBvcHRpb24ge1xcbiAgICBwYWRkaW5nLWlubGluZS1zdGFydDogMjBweDtcXG4gIH1cXG4gIDo6ZmlsZS1zZWxlY3Rvci1idXR0b24ge1xcbiAgICBtYXJnaW4taW5saW5lLWVuZDogNHB4O1xcbiAgfVxcbiAgOjotbW96LXBsYWNlaG9sZGVyIHtcXG4gICAgb3BhY2l0eTogMTtcXG4gIH1cXG4gIDo6cGxhY2Vob2xkZXIge1xcbiAgICBvcGFjaXR5OiAxO1xcbiAgfVxcbiAgQHN1cHBvcnRzIChub3QgKC13ZWJraXQtYXBwZWFyYW5jZTogLWFwcGxlLXBheS1idXR0b24pKSAgb3IgKGNvbnRhaW4taW50cmluc2ljLXNpemU6IDFweCkge1xcbiAgICA6Oi1tb3otcGxhY2Vob2xkZXIge1xcbiAgICAgIGNvbG9yOiBjdXJyZW50Y29sb3I7XFxuICAgICAgQHN1cHBvcnRzIChjb2xvcjogY29sb3ItbWl4KGluIGxhYiwgcmVkLCByZWQpKSB7XFxuICAgICAgICBjb2xvcjogY29sb3ItbWl4KGluIG9rbGFiLCBjdXJyZW50Y29sb3IgNTAlLCB0cmFuc3BhcmVudCk7XFxuICAgICAgfVxcbiAgICB9XFxuICAgIDo6cGxhY2Vob2xkZXIge1xcbiAgICAgIGNvbG9yOiBjdXJyZW50Y29sb3I7XFxuICAgICAgQHN1cHBvcnRzIChjb2xvcjogY29sb3ItbWl4KGluIGxhYiwgcmVkLCByZWQpKSB7XFxuICAgICAgICBjb2xvcjogY29sb3ItbWl4KGluIG9rbGFiLCBjdXJyZW50Y29sb3IgNTAlLCB0cmFuc3BhcmVudCk7XFxuICAgICAgfVxcbiAgICB9XFxuICB9XFxuICB0ZXh0YXJlYSB7XFxuICAgIHJlc2l6ZTogdmVydGljYWw7XFxuICB9XFxuICA6Oi13ZWJraXQtc2VhcmNoLWRlY29yYXRpb24ge1xcbiAgICAtd2Via2l0LWFwcGVhcmFuY2U6IG5vbmU7XFxuICB9XFxuICA6Oi13ZWJraXQtZGF0ZS1hbmQtdGltZS12YWx1ZSB7XFxuICAgIG1pbi1oZWlnaHQ6IDFsaDtcXG4gICAgdGV4dC1hbGlnbjogaW5oZXJpdDtcXG4gIH1cXG4gIDo6LXdlYmtpdC1kYXRldGltZS1lZGl0IHtcXG4gICAgZGlzcGxheTogaW5saW5lLWZsZXg7XFxuICB9XFxuICA6Oi13ZWJraXQtZGF0ZXRpbWUtZWRpdC1maWVsZHMtd3JhcHBlciB7XFxuICAgIHBhZGRpbmc6IDA7XFxuICB9XFxuICA6Oi13ZWJraXQtZGF0ZXRpbWUtZWRpdCwgOjotd2Via2l0LWRhdGV0aW1lLWVkaXQteWVhci1maWVsZCwgOjotd2Via2l0LWRhdGV0aW1lLWVkaXQtbW9udGgtZmllbGQsIDo6LXdlYmtpdC1kYXRldGltZS1lZGl0LWRheS1maWVsZCwgOjotd2Via2l0LWRhdGV0aW1lLWVkaXQtaG91ci1maWVsZCwgOjotd2Via2l0LWRhdGV0aW1lLWVkaXQtbWludXRlLWZpZWxkLCA6Oi13ZWJraXQtZGF0ZXRpbWUtZWRpdC1zZWNvbmQtZmllbGQsIDo6LXdlYmtpdC1kYXRldGltZS1lZGl0LW1pbGxpc2Vjb25kLWZpZWxkLCA6Oi13ZWJraXQtZGF0ZXRpbWUtZWRpdC1tZXJpZGllbS1maWVsZCB7XFxuICAgIHBhZGRpbmctYmxvY2s6IDA7XFxuICB9XFxuICA6LW1vei11aS1pbnZhbGlkIHtcXG4gICAgYm94LXNoYWRvdzogbm9uZTtcXG4gIH1cXG4gIGJ1dHRvbiwgaW5wdXQ6d2hlcmUoW3R5cGU9XFxcImJ1dHRvblxcXCJdLCBbdHlwZT1cXFwicmVzZXRcXFwiXSwgW3R5cGU9XFxcInN1Ym1pdFxcXCJdKSwgOjpmaWxlLXNlbGVjdG9yLWJ1dHRvbiB7XFxuICAgIC13ZWJraXQtYXBwZWFyYW5jZTogYnV0dG9uO1xcbiAgICAgICAtbW96LWFwcGVhcmFuY2U6IGJ1dHRvbjtcXG4gICAgICAgICAgICBhcHBlYXJhbmNlOiBidXR0b247XFxuICB9XFxuICA6Oi13ZWJraXQtaW5uZXItc3Bpbi1idXR0b24sIDo6LXdlYmtpdC1vdXRlci1zcGluLWJ1dHRvbiB7XFxuICAgIGhlaWdodDogYXV0bztcXG4gIH1cXG4gIFtoaWRkZW5dOndoZXJlKDpub3QoW2hpZGRlbj1cXFwidW50aWwtZm91bmRcXFwiXSkpIHtcXG4gICAgZGlzcGxheTogbm9uZSAhaW1wb3J0YW50O1xcbiAgfVxcbn1cXG5AbGF5ZXIgdXRpbGl0aWVzIHtcXG4gIC5wb2ludGVyLWV2ZW50cy1ub25lIHtcXG4gICAgcG9pbnRlci1ldmVudHM6IG5vbmU7XFxuICB9XFxuICAuY29sbGFwc2Uge1xcbiAgICB2aXNpYmlsaXR5OiBjb2xsYXBzZTtcXG4gIH1cXG4gIC5pbnZpc2libGUge1xcbiAgICB2aXNpYmlsaXR5OiBoaWRkZW47XFxuICB9XFxuICAudmlzaWJsZSB7XFxuICAgIHZpc2liaWxpdHk6IHZpc2libGU7XFxuICB9XFxuICAuYWJzb2x1dGUge1xcbiAgICBwb3NpdGlvbjogYWJzb2x1dGU7XFxuICB9XFxuICAuZml4ZWQge1xcbiAgICBwb3NpdGlvbjogZml4ZWQ7XFxuICB9XFxuICAucmVsYXRpdmUge1xcbiAgICBwb3NpdGlvbjogcmVsYXRpdmU7XFxuICB9XFxuICAuc3RhdGljIHtcXG4gICAgcG9zaXRpb246IHN0YXRpYztcXG4gIH1cXG4gIC5zdGlja3kge1xcbiAgICBwb3NpdGlvbjogc3RpY2t5O1xcbiAgfVxcbiAgLmluc2V0LTAge1xcbiAgICBpbnNldDogdmFyKC0tc3BhY2luZy0wKTtcXG4gIH1cXG4gIC50b3AtMCB7XFxuICAgIHRvcDogdmFyKC0tc3BhY2luZy0wKTtcXG4gIH1cXG4gIC50b3AtMVxcXFwvMiB7XFxuICAgIHRvcDogY2FsYygxLzIgKiAxMDAlKTtcXG4gIH1cXG4gIC50b3AtMiB7XFxuICAgIHRvcDogdmFyKC0tc3BhY2luZy0yKTtcXG4gIH1cXG4gIC50b3AtNCB7XFxuICAgIHRvcDogdmFyKC0tc3BhY2luZy00KTtcXG4gIH1cXG4gIC5yaWdodC0wIHtcXG4gICAgcmlnaHQ6IHZhcigtLXNwYWNpbmctMCk7XFxuICB9XFxuICAucmlnaHQtMiB7XFxuICAgIHJpZ2h0OiB2YXIoLS1zcGFjaW5nLTIpO1xcbiAgfVxcbiAgLnJpZ2h0LTMge1xcbiAgICByaWdodDogdmFyKC0tc3BhY2luZy0zKTtcXG4gIH1cXG4gIC5yaWdodC00IHtcXG4gICAgcmlnaHQ6IHZhcigtLXNwYWNpbmctNCk7XFxuICB9XFxuICAuLWJvdHRvbS0xIHtcXG4gICAgYm90dG9tOiBjYWxjKHZhcigtLXNwYWNpbmctMSkgKiAtMSk7XFxuICB9XFxuICAuYm90dG9tLTAge1xcbiAgICBib3R0b206IHZhcigtLXNwYWNpbmctMCk7XFxuICB9XFxuICAuYm90dG9tLTYge1xcbiAgICBib3R0b206IHZhcigtLXNwYWNpbmctNik7XFxuICB9XFxuICAuYm90dG9tLTgge1xcbiAgICBib3R0b206IHZhcigtLXNwYWNpbmctOCk7XFxuICB9XFxuICAuYm90dG9tLWZ1bGwge1xcbiAgICBib3R0b206IDEwMCU7XFxuICB9XFxuICAubGVmdC0wIHtcXG4gICAgbGVmdDogdmFyKC0tc3BhY2luZy0wKTtcXG4gIH1cXG4gIC5sZWZ0LTFcXFxcLzIge1xcbiAgICBsZWZ0OiBjYWxjKDEvMiAqIDEwMCUpO1xcbiAgfVxcbiAgLnotMTAge1xcbiAgICB6LWluZGV4OiAxMDtcXG4gIH1cXG4gIC56LTIwIHtcXG4gICAgei1pbmRleDogMjA7XFxuICB9XFxuICAuei0zMCB7XFxuICAgIHotaW5kZXg6IDMwO1xcbiAgfVxcbiAgLnotNTAge1xcbiAgICB6LWluZGV4OiA1MDtcXG4gIH1cXG4gIC5jb250YWluZXIge1xcbiAgICB3aWR0aDogMTAwJTtcXG4gICAgQG1lZGlhICh3aWR0aCA+PSA0MHJlbSkge1xcbiAgICAgIG1heC13aWR0aDogNDByZW07XFxuICAgIH1cXG4gICAgQG1lZGlhICh3aWR0aCA+PSA0OHJlbSkge1xcbiAgICAgIG1heC13aWR0aDogNDhyZW07XFxuICAgIH1cXG4gICAgQG1lZGlhICh3aWR0aCA+PSA2NHJlbSkge1xcbiAgICAgIG1heC13aWR0aDogNjRyZW07XFxuICAgIH1cXG4gICAgQG1lZGlhICh3aWR0aCA+PSA4MHJlbSkge1xcbiAgICAgIG1heC13aWR0aDogODByZW07XFxuICAgIH1cXG4gICAgQG1lZGlhICh3aWR0aCA+PSA5NnJlbSkge1xcbiAgICAgIG1heC13aWR0aDogOTZyZW07XFxuICAgIH1cXG4gIH1cXG4gIC5teC0xIHtcXG4gICAgbWFyZ2luLWlubGluZTogdmFyKC0tc3BhY2luZy0xKTtcXG4gIH1cXG4gIC5tdC0xIHtcXG4gICAgbWFyZ2luLXRvcDogdmFyKC0tc3BhY2luZy0xKTtcXG4gIH1cXG4gIC5tdC0yIHtcXG4gICAgbWFyZ2luLXRvcDogdmFyKC0tc3BhY2luZy0yKTtcXG4gIH1cXG4gIC5tdC00IHtcXG4gICAgbWFyZ2luLXRvcDogdmFyKC0tc3BhY2luZy00KTtcXG4gIH1cXG4gIC5tdC02IHtcXG4gICAgbWFyZ2luLXRvcDogdmFyKC0tc3BhY2luZy02KTtcXG4gIH1cXG4gIC5tdC04IHtcXG4gICAgbWFyZ2luLXRvcDogdmFyKC0tc3BhY2luZy04KTtcXG4gIH1cXG4gIC5tdC1hdXRvIHtcXG4gICAgbWFyZ2luLXRvcDogYXV0bztcXG4gIH1cXG4gIC5tci0xIHtcXG4gICAgbWFyZ2luLXJpZ2h0OiB2YXIoLS1zcGFjaW5nLTEpO1xcbiAgfVxcbiAgLm1yLTIge1xcbiAgICBtYXJnaW4tcmlnaHQ6IHZhcigtLXNwYWNpbmctMik7XFxuICB9XFxuICAubWItMSB7XFxuICAgIG1hcmdpbi1ib3R0b206IHZhcigtLXNwYWNpbmctMSk7XFxuICB9XFxuICAubWItMiB7XFxuICAgIG1hcmdpbi1ib3R0b206IHZhcigtLXNwYWNpbmctMik7XFxuICB9XFxuICAubWItMyB7XFxuICAgIG1hcmdpbi1ib3R0b206IHZhcigtLXNwYWNpbmctMyk7XFxuICB9XFxuICAubWItNCB7XFxuICAgIG1hcmdpbi1ib3R0b206IHZhcigtLXNwYWNpbmctNCk7XFxuICB9XFxuICAubWItNiB7XFxuICAgIG1hcmdpbi1ib3R0b206IHZhcigtLXNwYWNpbmctNik7XFxuICB9XFxuICAubWItOCB7XFxuICAgIG1hcmdpbi1ib3R0b206IHZhcigtLXNwYWNpbmctOCk7XFxuICB9XFxuICAubWwtMSB7XFxuICAgIG1hcmdpbi1sZWZ0OiB2YXIoLS1zcGFjaW5nLTEpO1xcbiAgfVxcbiAgLm1sLTIge1xcbiAgICBtYXJnaW4tbGVmdDogdmFyKC0tc3BhY2luZy0yKTtcXG4gIH1cXG4gIC5ibG9jayB7XFxuICAgIGRpc3BsYXk6IGJsb2NrO1xcbiAgfVxcbiAgLmNvbnRlbnRzIHtcXG4gICAgZGlzcGxheTogY29udGVudHM7XFxuICB9XFxuICAuZmxleCB7XFxuICAgIGRpc3BsYXk6IGZsZXg7XFxuICB9XFxuICAuZ3JpZCB7XFxuICAgIGRpc3BsYXk6IGdyaWQ7XFxuICB9XFxuICAuaGlkZGVuIHtcXG4gICAgZGlzcGxheTogbm9uZTtcXG4gIH1cXG4gIC5pbmxpbmUge1xcbiAgICBkaXNwbGF5OiBpbmxpbmU7XFxuICB9XFxuICAuaW5saW5lLWJsb2NrIHtcXG4gICAgZGlzcGxheTogaW5saW5lLWJsb2NrO1xcbiAgfVxcbiAgLnRhYmxlIHtcXG4gICAgZGlzcGxheTogdGFibGU7XFxuICB9XFxuICAuaC0xIHtcXG4gICAgaGVpZ2h0OiB2YXIoLS1zcGFjaW5nLTEpO1xcbiAgfVxcbiAgLmgtMiB7XFxuICAgIGhlaWdodDogdmFyKC0tc3BhY2luZy0yKTtcXG4gIH1cXG4gIC5oLTJcXFxcLjUge1xcbiAgICBoZWlnaHQ6IGNhbGModmFyKC0tc3BhY2luZykgKiAyLjUpO1xcbiAgfVxcbiAgLmgtMyB7XFxuICAgIGhlaWdodDogdmFyKC0tc3BhY2luZy0zKTtcXG4gIH1cXG4gIC5oLTQge1xcbiAgICBoZWlnaHQ6IHZhcigtLXNwYWNpbmctNCk7XFxuICB9XFxuICAuaC01IHtcXG4gICAgaGVpZ2h0OiB2YXIoLS1zcGFjaW5nLTUpO1xcbiAgfVxcbiAgLmgtNiB7XFxuICAgIGhlaWdodDogdmFyKC0tc3BhY2luZy02KTtcXG4gIH1cXG4gIC5oLTgge1xcbiAgICBoZWlnaHQ6IHZhcigtLXNwYWNpbmctOCk7XFxuICB9XFxuICAuaC0xMCB7XFxuICAgIGhlaWdodDogdmFyKC0tc3BhY2luZy0xMCk7XFxuICB9XFxuICAuaC0yNCB7XFxuICAgIGhlaWdodDogY2FsYyh2YXIoLS1zcGFjaW5nKSAqIDI0KTtcXG4gIH1cXG4gIC5oLTY0IHtcXG4gICAgaGVpZ2h0OiBjYWxjKHZhcigtLXNwYWNpbmcpICogNjQpO1xcbiAgfVxcbiAgLmgtZnVsbCB7XFxuICAgIGhlaWdodDogMTAwJTtcXG4gIH1cXG4gIC5oLXNjcmVlbiB7XFxuICAgIGhlaWdodDogMTAwdmg7XFxuICB9XFxuICAubWF4LWgtMzIge1xcbiAgICBtYXgtaGVpZ2h0OiBjYWxjKHZhcigtLXNwYWNpbmcpICogMzIpO1xcbiAgfVxcbiAgLm1heC1oLTYwIHtcXG4gICAgbWF4LWhlaWdodDogY2FsYyh2YXIoLS1zcGFjaW5nKSAqIDYwKTtcXG4gIH1cXG4gIC5tYXgtaC1cXFxcWzkwdmhcXFxcXSB7XFxuICAgIG1heC1oZWlnaHQ6IDkwdmg7XFxuICB9XFxuICAubWluLWgtZnVsbCB7XFxuICAgIG1pbi1oZWlnaHQ6IDEwMCU7XFxuICB9XFxuICAubWluLWgtc2NyZWVuIHtcXG4gICAgbWluLWhlaWdodDogMTAwdmg7XFxuICB9XFxuICAudy0xIHtcXG4gICAgd2lkdGg6IHZhcigtLXNwYWNpbmctMSk7XFxuICB9XFxuICAudy0yXFxcXC41IHtcXG4gICAgd2lkdGg6IGNhbGModmFyKC0tc3BhY2luZykgKiAyLjUpO1xcbiAgfVxcbiAgLnctMyB7XFxuICAgIHdpZHRoOiB2YXIoLS1zcGFjaW5nLTMpO1xcbiAgfVxcbiAgLnctNCB7XFxuICAgIHdpZHRoOiB2YXIoLS1zcGFjaW5nLTQpO1xcbiAgfVxcbiAgLnctNSB7XFxuICAgIHdpZHRoOiB2YXIoLS1zcGFjaW5nLTUpO1xcbiAgfVxcbiAgLnctNiB7XFxuICAgIHdpZHRoOiB2YXIoLS1zcGFjaW5nLTYpO1xcbiAgfVxcbiAgLnctOCB7XFxuICAgIHdpZHRoOiB2YXIoLS1zcGFjaW5nLTgpO1xcbiAgfVxcbiAgLnctMTAge1xcbiAgICB3aWR0aDogdmFyKC0tc3BhY2luZy0xMCk7XFxuICB9XFxuICAudy0xMVxcXFwvMTIge1xcbiAgICB3aWR0aDogY2FsYygxMS8xMiAqIDEwMCUpO1xcbiAgfVxcbiAgLnctNjQge1xcbiAgICB3aWR0aDogY2FsYyh2YXIoLS1zcGFjaW5nKSAqIDY0KTtcXG4gIH1cXG4gIC53LWZ1bGwge1xcbiAgICB3aWR0aDogMTAwJTtcXG4gIH1cXG4gIC5tYXgtdy0yeGwge1xcbiAgICBtYXgtd2lkdGg6IHZhcigtLWNvbnRhaW5lci0yeGwpO1xcbiAgfVxcbiAgLm1heC13LVxcXFxbODBcXFxcJVxcXFxdIHtcXG4gICAgbWF4LXdpZHRoOiA4MCU7XFxuICB9XFxuICAubWF4LXctXFxcXFtjYWxjXFxcXCgxMDBcXFxcJS0ycmVtXFxcXClcXFxcXSB7XFxuICAgIG1heC13aWR0aDogY2FsYygxMDAlIC0gMnJlbSk7XFxuICB9XFxuICAubWF4LXctZnVsbCB7XFxuICAgIG1heC13aWR0aDogMTAwJTtcXG4gIH1cXG4gIC5tYXgtdy1tZCB7XFxuICAgIG1heC13aWR0aDogdmFyKC0tY29udGFpbmVyLW1kKTtcXG4gIH1cXG4gIC5mbGV4LTEge1xcbiAgICBmbGV4OiAxO1xcbiAgfVxcbiAgLmZsZXgtc2hyaW5rLTAge1xcbiAgICBmbGV4LXNocmluazogMDtcXG4gIH1cXG4gIC5zaHJpbmstMCB7XFxuICAgIGZsZXgtc2hyaW5rOiAwO1xcbiAgfVxcbiAgLmZsZXgtZ3JvdyB7XFxuICAgIGZsZXgtZ3JvdzogMTtcXG4gIH1cXG4gIC4tdHJhbnNsYXRlLXgtMVxcXFwvMiB7XFxuICAgIC0tdHctdHJhbnNsYXRlLXg6IGNhbGMoY2FsYygxLzIgKiAxMDAlKSAqIC0xKTtcXG4gICAgdHJhbnNsYXRlOiB2YXIoLS10dy10cmFuc2xhdGUteCkgdmFyKC0tdHctdHJhbnNsYXRlLXkpO1xcbiAgfVxcbiAgLi10cmFuc2xhdGUteS0xXFxcXC8yIHtcXG4gICAgLS10dy10cmFuc2xhdGUteTogY2FsYyhjYWxjKDEvMiAqIDEwMCUpICogLTEpO1xcbiAgICB0cmFuc2xhdGU6IHZhcigtLXR3LXRyYW5zbGF0ZS14KSB2YXIoLS10dy10cmFuc2xhdGUteSk7XFxuICB9XFxuICAudHJhbnNsYXRlLXktMCB7XFxuICAgIC0tdHctdHJhbnNsYXRlLXk6IHZhcigtLXNwYWNpbmctMCk7XFxuICAgIHRyYW5zbGF0ZTogdmFyKC0tdHctdHJhbnNsYXRlLXgpIHZhcigtLXR3LXRyYW5zbGF0ZS15KTtcXG4gIH1cXG4gIC50cmFuc2xhdGUteS00IHtcXG4gICAgLS10dy10cmFuc2xhdGUteTogdmFyKC0tc3BhY2luZy00KTtcXG4gICAgdHJhbnNsYXRlOiB2YXIoLS10dy10cmFuc2xhdGUteCkgdmFyKC0tdHctdHJhbnNsYXRlLXkpO1xcbiAgfVxcbiAgLnNjYWxlLTk1IHtcXG4gICAgLS10dy1zY2FsZS14OiA5NSU7XFxuICAgIC0tdHctc2NhbGUteTogOTUlO1xcbiAgICAtLXR3LXNjYWxlLXo6IDk1JTtcXG4gICAgc2NhbGU6IHZhcigtLXR3LXNjYWxlLXgpIHZhcigtLXR3LXNjYWxlLXkpO1xcbiAgfVxcbiAgLnNjYWxlLTEwMCB7XFxuICAgIC0tdHctc2NhbGUteDogMTAwJTtcXG4gICAgLS10dy1zY2FsZS15OiAxMDAlO1xcbiAgICAtLXR3LXNjYWxlLXo6IDEwMCU7XFxuICAgIHNjYWxlOiB2YXIoLS10dy1zY2FsZS14KSB2YXIoLS10dy1zY2FsZS15KTtcXG4gIH1cXG4gIC5yb3RhdGUtMTgwIHtcXG4gICAgcm90YXRlOiAxODBkZWc7XFxuICB9XFxuICAudHJhbnNmb3JtIHtcXG4gICAgdHJhbnNmb3JtOiB2YXIoLS10dy1yb3RhdGUteCwpIHZhcigtLXR3LXJvdGF0ZS15LCkgdmFyKC0tdHctcm90YXRlLXosKSB2YXIoLS10dy1za2V3LXgsKSB2YXIoLS10dy1za2V3LXksKTtcXG4gIH1cXG4gIC5jdXJzb3Itbm90LWFsbG93ZWQge1xcbiAgICBjdXJzb3I6IG5vdC1hbGxvd2VkO1xcbiAgfVxcbiAgLmN1cnNvci1wb2ludGVyIHtcXG4gICAgY3Vyc29yOiBwb2ludGVyO1xcbiAgfVxcbiAgLnJlc2l6ZSB7XFxuICAgIHJlc2l6ZTogYm90aDtcXG4gIH1cXG4gIC5yZXNpemUtbm9uZSB7XFxuICAgIHJlc2l6ZTogbm9uZTtcXG4gIH1cXG4gIC5saXN0LWRpc2Mge1xcbiAgICBsaXN0LXN0eWxlLXR5cGU6IGRpc2M7XFxuICB9XFxuICAuYXBwZWFyYW5jZS1ub25lIHtcXG4gICAgLXdlYmtpdC1hcHBlYXJhbmNlOiBub25lO1xcbiAgICAgICAtbW96LWFwcGVhcmFuY2U6IG5vbmU7XFxuICAgICAgICAgICAgYXBwZWFyYW5jZTogbm9uZTtcXG4gIH1cXG4gIC5ncmlkLWNvbHMtMiB7XFxuICAgIGdyaWQtdGVtcGxhdGUtY29sdW1uczogcmVwZWF0KDIsIG1pbm1heCgwLCAxZnIpKTtcXG4gIH1cXG4gIC5mbGV4LWNvbCB7XFxuICAgIGZsZXgtZGlyZWN0aW9uOiBjb2x1bW47XFxuICB9XFxuICAuZmxleC1yb3cge1xcbiAgICBmbGV4LWRpcmVjdGlvbjogcm93O1xcbiAgfVxcbiAgLmZsZXgtd3JhcCB7XFxuICAgIGZsZXgtd3JhcDogd3JhcDtcXG4gIH1cXG4gIC5pdGVtcy1iYXNlbGluZSB7XFxuICAgIGFsaWduLWl0ZW1zOiBiYXNlbGluZTtcXG4gIH1cXG4gIC5pdGVtcy1jZW50ZXIge1xcbiAgICBhbGlnbi1pdGVtczogY2VudGVyO1xcbiAgfVxcbiAgLmp1c3RpZnktYmV0d2VlbiB7XFxuICAgIGp1c3RpZnktY29udGVudDogc3BhY2UtYmV0d2VlbjtcXG4gIH1cXG4gIC5qdXN0aWZ5LWNlbnRlciB7XFxuICAgIGp1c3RpZnktY29udGVudDogY2VudGVyO1xcbiAgfVxcbiAgLmp1c3RpZnktZW5kIHtcXG4gICAganVzdGlmeS1jb250ZW50OiBmbGV4LWVuZDtcXG4gIH1cXG4gIC5nYXAtMSB7XFxuICAgIGdhcDogdmFyKC0tc3BhY2luZy0xKTtcXG4gIH1cXG4gIC5nYXAtMiB7XFxuICAgIGdhcDogdmFyKC0tc3BhY2luZy0yKTtcXG4gIH1cXG4gIC5nYXAtMyB7XFxuICAgIGdhcDogdmFyKC0tc3BhY2luZy0zKTtcXG4gIH1cXG4gIC5nYXAtNCB7XFxuICAgIGdhcDogdmFyKC0tc3BhY2luZy00KTtcXG4gIH1cXG4gIC4tc3BhY2UteS0xIHtcXG4gICAgOndoZXJlKCYgPiA6bm90KDpsYXN0LWNoaWxkKSkge1xcbiAgICAgIC0tdHctc3BhY2UteS1yZXZlcnNlOiAwO1xcbiAgICAgIG1hcmdpbi1ibG9jay1zdGFydDogY2FsYyhjYWxjKHZhcigtLXNwYWNpbmctMSkgKiAtMSkgKiB2YXIoLS10dy1zcGFjZS15LXJldmVyc2UpKTtcXG4gICAgICBtYXJnaW4tYmxvY2stZW5kOiBjYWxjKGNhbGModmFyKC0tc3BhY2luZy0xKSAqIC0xKSAqIGNhbGMoMSAtIHZhcigtLXR3LXNwYWNlLXktcmV2ZXJzZSkpKTtcXG4gICAgfVxcbiAgfVxcbiAgLnNwYWNlLXktMSB7XFxuICAgIDp3aGVyZSgmID4gOm5vdCg6bGFzdC1jaGlsZCkpIHtcXG4gICAgICAtLXR3LXNwYWNlLXktcmV2ZXJzZTogMDtcXG4gICAgICBtYXJnaW4tYmxvY2stc3RhcnQ6IGNhbGModmFyKC0tc3BhY2luZy0xKSAqIHZhcigtLXR3LXNwYWNlLXktcmV2ZXJzZSkpO1xcbiAgICAgIG1hcmdpbi1ibG9jay1lbmQ6IGNhbGModmFyKC0tc3BhY2luZy0xKSAqIGNhbGMoMSAtIHZhcigtLXR3LXNwYWNlLXktcmV2ZXJzZSkpKTtcXG4gICAgfVxcbiAgfVxcbiAgLnNwYWNlLXktMiB7XFxuICAgIDp3aGVyZSgmID4gOm5vdCg6bGFzdC1jaGlsZCkpIHtcXG4gICAgICAtLXR3LXNwYWNlLXktcmV2ZXJzZTogMDtcXG4gICAgICBtYXJnaW4tYmxvY2stc3RhcnQ6IGNhbGModmFyKC0tc3BhY2luZy0yKSAqIHZhcigtLXR3LXNwYWNlLXktcmV2ZXJzZSkpO1xcbiAgICAgIG1hcmdpbi1ibG9jay1lbmQ6IGNhbGModmFyKC0tc3BhY2luZy0yKSAqIGNhbGMoMSAtIHZhcigtLXR3LXNwYWNlLXktcmV2ZXJzZSkpKTtcXG4gICAgfVxcbiAgfVxcbiAgLnNwYWNlLXktNCB7XFxuICAgIDp3aGVyZSgmID4gOm5vdCg6bGFzdC1jaGlsZCkpIHtcXG4gICAgICAtLXR3LXNwYWNlLXktcmV2ZXJzZTogMDtcXG4gICAgICBtYXJnaW4tYmxvY2stc3RhcnQ6IGNhbGModmFyKC0tc3BhY2luZy00KSAqIHZhcigtLXR3LXNwYWNlLXktcmV2ZXJzZSkpO1xcbiAgICAgIG1hcmdpbi1ibG9jay1lbmQ6IGNhbGModmFyKC0tc3BhY2luZy00KSAqIGNhbGMoMSAtIHZhcigtLXR3LXNwYWNlLXktcmV2ZXJzZSkpKTtcXG4gICAgfVxcbiAgfVxcbiAgLnNwYWNlLXgtMiB7XFxuICAgIDp3aGVyZSgmID4gOm5vdCg6bGFzdC1jaGlsZCkpIHtcXG4gICAgICAtLXR3LXNwYWNlLXgtcmV2ZXJzZTogMDtcXG4gICAgICBtYXJnaW4taW5saW5lLXN0YXJ0OiBjYWxjKHZhcigtLXNwYWNpbmctMikgKiB2YXIoLS10dy1zcGFjZS14LXJldmVyc2UpKTtcXG4gICAgICBtYXJnaW4taW5saW5lLWVuZDogY2FsYyh2YXIoLS1zcGFjaW5nLTIpICogY2FsYygxIC0gdmFyKC0tdHctc3BhY2UteC1yZXZlcnNlKSkpO1xcbiAgICB9XFxuICB9XFxuICAuc3BhY2UteC00IHtcXG4gICAgOndoZXJlKCYgPiA6bm90KDpsYXN0LWNoaWxkKSkge1xcbiAgICAgIC0tdHctc3BhY2UteC1yZXZlcnNlOiAwO1xcbiAgICAgIG1hcmdpbi1pbmxpbmUtc3RhcnQ6IGNhbGModmFyKC0tc3BhY2luZy00KSAqIHZhcigtLXR3LXNwYWNlLXgtcmV2ZXJzZSkpO1xcbiAgICAgIG1hcmdpbi1pbmxpbmUtZW5kOiBjYWxjKHZhcigtLXNwYWNpbmctNCkgKiBjYWxjKDEgLSB2YXIoLS10dy1zcGFjZS14LXJldmVyc2UpKSk7XFxuICAgIH1cXG4gIH1cXG4gIC50cnVuY2F0ZSB7XFxuICAgIG92ZXJmbG93OiBoaWRkZW47XFxuICAgIHRleHQtb3ZlcmZsb3c6IGVsbGlwc2lzO1xcbiAgICB3aGl0ZS1zcGFjZTogbm93cmFwO1xcbiAgfVxcbiAgLm92ZXJmbG93LWF1dG8ge1xcbiAgICBvdmVyZmxvdzogYXV0bztcXG4gIH1cXG4gIC5vdmVyZmxvdy1oaWRkZW4ge1xcbiAgICBvdmVyZmxvdzogaGlkZGVuO1xcbiAgfVxcbiAgLm92ZXJmbG93LXgtaGlkZGVuIHtcXG4gICAgb3ZlcmZsb3cteDogaGlkZGVuO1xcbiAgfVxcbiAgLm92ZXJmbG93LXktYXV0byB7XFxuICAgIG92ZXJmbG93LXk6IGF1dG87XFxuICB9XFxuICAucm91bmRlZCB7XFxuICAgIGJvcmRlci1yYWRpdXM6IDAuMjVyZW07XFxuICB9XFxuICAucm91bmRlZC1mdWxsIHtcXG4gICAgYm9yZGVyLXJhZGl1czogY2FsYyhpbmZpbml0eSAqIDFweCk7XFxuICB9XFxuICAucm91bmRlZC1sZyB7XFxuICAgIGJvcmRlci1yYWRpdXM6IHZhcigtLXJhZGl1cy1sZyk7XFxuICB9XFxuICAucm91bmRlZC1tZCB7XFxuICAgIGJvcmRlci1yYWRpdXM6IHZhcigtLXJhZGl1cy1tZCk7XFxuICB9XFxuICAucm91bmRlZC1zbSB7XFxuICAgIGJvcmRlci1yYWRpdXM6IHZhcigtLXJhZGl1cy1zbSk7XFxuICB9XFxuICAucm91bmRlZC14bCB7XFxuICAgIGJvcmRlci1yYWRpdXM6IHZhcigtLXJhZGl1cy14bCk7XFxuICB9XFxuICAucm91bmRlZC1sLW1kIHtcXG4gICAgYm9yZGVyLXRvcC1sZWZ0LXJhZGl1czogdmFyKC0tcmFkaXVzLW1kKTtcXG4gICAgYm9yZGVyLWJvdHRvbS1sZWZ0LXJhZGl1czogdmFyKC0tcmFkaXVzLW1kKTtcXG4gIH1cXG4gIC5yb3VuZGVkLXItbWQge1xcbiAgICBib3JkZXItdG9wLXJpZ2h0LXJhZGl1czogdmFyKC0tcmFkaXVzLW1kKTtcXG4gICAgYm9yZGVyLWJvdHRvbS1yaWdodC1yYWRpdXM6IHZhcigtLXJhZGl1cy1tZCk7XFxuICB9XFxuICAuYm9yZGVyIHtcXG4gICAgYm9yZGVyLXN0eWxlOiB2YXIoLS10dy1ib3JkZXItc3R5bGUpO1xcbiAgICBib3JkZXItd2lkdGg6IDFweDtcXG4gIH1cXG4gIC5ib3JkZXItMCB7XFxuICAgIGJvcmRlci1zdHlsZTogdmFyKC0tdHctYm9yZGVyLXN0eWxlKTtcXG4gICAgYm9yZGVyLXdpZHRoOiAwcHg7XFxuICB9XFxuICAuYm9yZGVyLTIge1xcbiAgICBib3JkZXItc3R5bGU6IHZhcigtLXR3LWJvcmRlci1zdHlsZSk7XFxuICAgIGJvcmRlci13aWR0aDogMnB4O1xcbiAgfVxcbiAgLmJvcmRlci10IHtcXG4gICAgYm9yZGVyLXRvcC1zdHlsZTogdmFyKC0tdHctYm9yZGVyLXN0eWxlKTtcXG4gICAgYm9yZGVyLXRvcC13aWR0aDogMXB4O1xcbiAgfVxcbiAgLmJvcmRlci1yIHtcXG4gICAgYm9yZGVyLXJpZ2h0LXN0eWxlOiB2YXIoLS10dy1ib3JkZXItc3R5bGUpO1xcbiAgICBib3JkZXItcmlnaHQtd2lkdGg6IDFweDtcXG4gIH1cXG4gIC5ib3JkZXItYiB7XFxuICAgIGJvcmRlci1ib3R0b20tc3R5bGU6IHZhcigtLXR3LWJvcmRlci1zdHlsZSk7XFxuICAgIGJvcmRlci1ib3R0b20td2lkdGg6IDFweDtcXG4gIH1cXG4gIC5ib3JkZXItYi0yIHtcXG4gICAgYm9yZGVyLWJvdHRvbS1zdHlsZTogdmFyKC0tdHctYm9yZGVyLXN0eWxlKTtcXG4gICAgYm9yZGVyLWJvdHRvbS13aWR0aDogMnB4O1xcbiAgfVxcbiAgLmJvcmRlci1kYXNoZWQge1xcbiAgICAtLXR3LWJvcmRlci1zdHlsZTogZGFzaGVkO1xcbiAgICBib3JkZXItc3R5bGU6IGRhc2hlZDtcXG4gIH1cXG4gIC5ib3JkZXItYmx1ZS0xMDAge1xcbiAgICBib3JkZXItY29sb3I6IHZhcigtLWNvbG9yLWJsdWUtMTAwKTtcXG4gIH1cXG4gIC5ib3JkZXItYmx1ZS0yMDAge1xcbiAgICBib3JkZXItY29sb3I6IHZhcigtLWNvbG9yLWJsdWUtMjAwKTtcXG4gIH1cXG4gIC5ib3JkZXItYmx1ZS0zMDAge1xcbiAgICBib3JkZXItY29sb3I6IHZhcigtLWNvbG9yLWJsdWUtMzAwKTtcXG4gIH1cXG4gIC5ib3JkZXItYmx1ZS01MDAge1xcbiAgICBib3JkZXItY29sb3I6IHZhcigtLWNvbG9yLWJsdWUtNTAwKTtcXG4gIH1cXG4gIC5ib3JkZXItZ3JheS0xMDAge1xcbiAgICBib3JkZXItY29sb3I6IHZhcigtLWNvbG9yLWdyYXktMTAwKTtcXG4gIH1cXG4gIC5ib3JkZXItZ3JheS0yMDAge1xcbiAgICBib3JkZXItY29sb3I6IHZhcigtLWNvbG9yLWdyYXktMjAwKTtcXG4gIH1cXG4gIC5ib3JkZXItZ3JheS03MDAge1xcbiAgICBib3JkZXItY29sb3I6IHZhcigtLWNvbG9yLWdyYXktNzAwKTtcXG4gIH1cXG4gIC5ib3JkZXItcmVkLTIwMCB7XFxuICAgIGJvcmRlci1jb2xvcjogdmFyKC0tY29sb3ItcmVkLTIwMCk7XFxuICB9XFxuICAuYm9yZGVyLXdoaXRlIHtcXG4gICAgYm9yZGVyLWNvbG9yOiB2YXIoLS1jb2xvci13aGl0ZSk7XFxuICB9XFxuICAuYm9yZGVyLXllbGxvdy0zMDAge1xcbiAgICBib3JkZXItY29sb3I6IHZhcigtLWNvbG9yLXllbGxvdy0zMDApO1xcbiAgfVxcbiAgLmJnLWJsYWNrIHtcXG4gICAgYmFja2dyb3VuZC1jb2xvcjogdmFyKC0tY29sb3ItYmxhY2spO1xcbiAgfVxcbiAgLmJnLWJsYWNrXFxcXC8wIHtcXG4gICAgYmFja2dyb3VuZC1jb2xvcjogY29sb3ItbWl4KGluIHNyZ2IsICMwMDAgMCUsIHRyYW5zcGFyZW50KTtcXG4gICAgQHN1cHBvcnRzIChjb2xvcjogY29sb3ItbWl4KGluIGxhYiwgcmVkLCByZWQpKSB7XFxuICAgICAgYmFja2dyb3VuZC1jb2xvcjogY29sb3ItbWl4KGluIG9rbGFiLCB2YXIoLS1jb2xvci1ibGFjaykgMCUsIHRyYW5zcGFyZW50KTtcXG4gICAgfVxcbiAgfVxcbiAgLmJnLWJsYWNrXFxcXC8zMCB7XFxuICAgIGJhY2tncm91bmQtY29sb3I6IGNvbG9yLW1peChpbiBzcmdiLCAjMDAwIDMwJSwgdHJhbnNwYXJlbnQpO1xcbiAgICBAc3VwcG9ydHMgKGNvbG9yOiBjb2xvci1taXgoaW4gbGFiLCByZWQsIHJlZCkpIHtcXG4gICAgICBiYWNrZ3JvdW5kLWNvbG9yOiBjb2xvci1taXgoaW4gb2tsYWIsIHZhcigtLWNvbG9yLWJsYWNrKSAzMCUsIHRyYW5zcGFyZW50KTtcXG4gICAgfVxcbiAgfVxcbiAgLmJnLWJsdWUtNTAge1xcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiB2YXIoLS1jb2xvci1ibHVlLTUwKTtcXG4gIH1cXG4gIC5iZy1ibHVlLTEwMCB7XFxuICAgIGJhY2tncm91bmQtY29sb3I6IHZhcigtLWNvbG9yLWJsdWUtMTAwKTtcXG4gIH1cXG4gIC5iZy1ibHVlLTUwMCB7XFxuICAgIGJhY2tncm91bmQtY29sb3I6IHZhcigtLWNvbG9yLWJsdWUtNTAwKTtcXG4gIH1cXG4gIC5iZy1ibHVlLTYwMCB7XFxuICAgIGJhY2tncm91bmQtY29sb3I6IHZhcigtLWNvbG9yLWJsdWUtNjAwKTtcXG4gIH1cXG4gIC5iZy1ibHVlLTcwMCB7XFxuICAgIGJhY2tncm91bmQtY29sb3I6IHZhcigtLWNvbG9yLWJsdWUtNzAwKTtcXG4gIH1cXG4gIC5iZy1ncmF5LTUwIHtcXG4gICAgYmFja2dyb3VuZC1jb2xvcjogdmFyKC0tY29sb3ItZ3JheS01MCk7XFxuICB9XFxuICAuYmctZ3JheS0xMDAge1xcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiB2YXIoLS1jb2xvci1ncmF5LTEwMCk7XFxuICB9XFxuICAuYmctZ3JheS0yMDAge1xcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiB2YXIoLS1jb2xvci1ncmF5LTIwMCk7XFxuICB9XFxuICAuYmctZ3JheS04MDAge1xcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiB2YXIoLS1jb2xvci1ncmF5LTgwMCk7XFxuICB9XFxuICAuYmctZ3JlZW4tMTAwIHtcXG4gICAgYmFja2dyb3VuZC1jb2xvcjogdmFyKC0tY29sb3ItZ3JlZW4tMTAwKTtcXG4gIH1cXG4gIC5iZy1ncmVlbi01MDAge1xcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiB2YXIoLS1jb2xvci1ncmVlbi01MDApO1xcbiAgfVxcbiAgLmJnLXB1cnBsZS01MDAge1xcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiB2YXIoLS1jb2xvci1wdXJwbGUtNTAwKTtcXG4gIH1cXG4gIC5iZy1yZWQtNTAge1xcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiB2YXIoLS1jb2xvci1yZWQtNTApO1xcbiAgfVxcbiAgLmJnLXJlZC02MDAge1xcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiB2YXIoLS1jb2xvci1yZWQtNjAwKTtcXG4gIH1cXG4gIC5iZy10cmFuc3BhcmVudCB7XFxuICAgIGJhY2tncm91bmQtY29sb3I6IHRyYW5zcGFyZW50O1xcbiAgfVxcbiAgLmJnLXdoaXRlIHtcXG4gICAgYmFja2dyb3VuZC1jb2xvcjogdmFyKC0tY29sb3Itd2hpdGUpO1xcbiAgfVxcbiAgLmJnLXdoaXRlXFxcXC84MCB7XFxuICAgIGJhY2tncm91bmQtY29sb3I6IGNvbG9yLW1peChpbiBzcmdiLCAjZmZmIDgwJSwgdHJhbnNwYXJlbnQpO1xcbiAgICBAc3VwcG9ydHMgKGNvbG9yOiBjb2xvci1taXgoaW4gbGFiLCByZWQsIHJlZCkpIHtcXG4gICAgICBiYWNrZ3JvdW5kLWNvbG9yOiBjb2xvci1taXgoaW4gb2tsYWIsIHZhcigtLWNvbG9yLXdoaXRlKSA4MCUsIHRyYW5zcGFyZW50KTtcXG4gICAgfVxcbiAgfVxcbiAgLmJnLXdoaXRlXFxcXC85MCB7XFxuICAgIGJhY2tncm91bmQtY29sb3I6IGNvbG9yLW1peChpbiBzcmdiLCAjZmZmIDkwJSwgdHJhbnNwYXJlbnQpO1xcbiAgICBAc3VwcG9ydHMgKGNvbG9yOiBjb2xvci1taXgoaW4gbGFiLCByZWQsIHJlZCkpIHtcXG4gICAgICBiYWNrZ3JvdW5kLWNvbG9yOiBjb2xvci1taXgoaW4gb2tsYWIsIHZhcigtLWNvbG9yLXdoaXRlKSA5MCUsIHRyYW5zcGFyZW50KTtcXG4gICAgfVxcbiAgfVxcbiAgLmJnLXllbGxvdy0xMDAge1xcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiB2YXIoLS1jb2xvci15ZWxsb3ctMTAwKTtcXG4gIH1cXG4gIC5iZy15ZWxsb3ctNDAwIHtcXG4gICAgYmFja2dyb3VuZC1jb2xvcjogdmFyKC0tY29sb3IteWVsbG93LTQwMCk7XFxuICB9XFxuICAuYmctZ3JhZGllbnQtdG8tciB7XFxuICAgIC0tdHctZ3JhZGllbnQtcG9zaXRpb246IHRvIHJpZ2h0IGluIG9rbGFiO1xcbiAgICBiYWNrZ3JvdW5kLWltYWdlOiBsaW5lYXItZ3JhZGllbnQodmFyKC0tdHctZ3JhZGllbnQtc3RvcHMpKTtcXG4gIH1cXG4gIC5mcm9tLWJsdWUtMzAwIHtcXG4gICAgLS10dy1ncmFkaWVudC1mcm9tOiB2YXIoLS1jb2xvci1ibHVlLTMwMCk7XFxuICAgIC0tdHctZ3JhZGllbnQtc3RvcHM6IHZhcigtLXR3LWdyYWRpZW50LXZpYS1zdG9wcywgdmFyKC0tdHctZ3JhZGllbnQtcG9zaXRpb24pLCB2YXIoLS10dy1ncmFkaWVudC1mcm9tKSB2YXIoLS10dy1ncmFkaWVudC1mcm9tLXBvc2l0aW9uKSwgdmFyKC0tdHctZ3JhZGllbnQtdG8pIHZhcigtLXR3LWdyYWRpZW50LXRvLXBvc2l0aW9uKSk7XFxuICB9XFxuICAuZnJvbS1ibHVlLTUwMCB7XFxuICAgIC0tdHctZ3JhZGllbnQtZnJvbTogdmFyKC0tY29sb3ItYmx1ZS01MDApO1xcbiAgICAtLXR3LWdyYWRpZW50LXN0b3BzOiB2YXIoLS10dy1ncmFkaWVudC12aWEtc3RvcHMsIHZhcigtLXR3LWdyYWRpZW50LXBvc2l0aW9uKSwgdmFyKC0tdHctZ3JhZGllbnQtZnJvbSkgdmFyKC0tdHctZ3JhZGllbnQtZnJvbS1wb3NpdGlvbiksIHZhcigtLXR3LWdyYWRpZW50LXRvKSB2YXIoLS10dy1ncmFkaWVudC10by1wb3NpdGlvbikpO1xcbiAgfVxcbiAgLmZyb20tZ3JlZW4tMzAwIHtcXG4gICAgLS10dy1ncmFkaWVudC1mcm9tOiB2YXIoLS1jb2xvci1ncmVlbi0zMDApO1xcbiAgICAtLXR3LWdyYWRpZW50LXN0b3BzOiB2YXIoLS10dy1ncmFkaWVudC12aWEtc3RvcHMsIHZhcigtLXR3LWdyYWRpZW50LXBvc2l0aW9uKSwgdmFyKC0tdHctZ3JhZGllbnQtZnJvbSkgdmFyKC0tdHctZ3JhZGllbnQtZnJvbS1wb3NpdGlvbiksIHZhcigtLXR3LWdyYWRpZW50LXRvKSB2YXIoLS10dy1ncmFkaWVudC10by1wb3NpdGlvbikpO1xcbiAgfVxcbiAgLmZyb20tcHVycGxlLTMwMCB7XFxuICAgIC0tdHctZ3JhZGllbnQtZnJvbTogdmFyKC0tY29sb3ItcHVycGxlLTMwMCk7XFxuICAgIC0tdHctZ3JhZGllbnQtc3RvcHM6IHZhcigtLXR3LWdyYWRpZW50LXZpYS1zdG9wcywgdmFyKC0tdHctZ3JhZGllbnQtcG9zaXRpb24pLCB2YXIoLS10dy1ncmFkaWVudC1mcm9tKSB2YXIoLS10dy1ncmFkaWVudC1mcm9tLXBvc2l0aW9uKSwgdmFyKC0tdHctZ3JhZGllbnQtdG8pIHZhcigtLXR3LWdyYWRpZW50LXRvLXBvc2l0aW9uKSk7XFxuICB9XFxuICAudG8tYmx1ZS0zMDAge1xcbiAgICAtLXR3LWdyYWRpZW50LXRvOiB2YXIoLS1jb2xvci1ibHVlLTMwMCk7XFxuICAgIC0tdHctZ3JhZGllbnQtc3RvcHM6IHZhcigtLXR3LWdyYWRpZW50LXZpYS1zdG9wcywgdmFyKC0tdHctZ3JhZGllbnQtcG9zaXRpb24pLCB2YXIoLS10dy1ncmFkaWVudC1mcm9tKSB2YXIoLS10dy1ncmFkaWVudC1mcm9tLXBvc2l0aW9uKSwgdmFyKC0tdHctZ3JhZGllbnQtdG8pIHZhcigtLXR3LWdyYWRpZW50LXRvLXBvc2l0aW9uKSk7XFxuICB9XFxuICAudG8tYmx1ZS01MDAge1xcbiAgICAtLXR3LWdyYWRpZW50LXRvOiB2YXIoLS1jb2xvci1ibHVlLTUwMCk7XFxuICAgIC0tdHctZ3JhZGllbnQtc3RvcHM6IHZhcigtLXR3LWdyYWRpZW50LXZpYS1zdG9wcywgdmFyKC0tdHctZ3JhZGllbnQtcG9zaXRpb24pLCB2YXIoLS10dy1ncmFkaWVudC1mcm9tKSB2YXIoLS10dy1ncmFkaWVudC1mcm9tLXBvc2l0aW9uKSwgdmFyKC0tdHctZ3JhZGllbnQtdG8pIHZhcigtLXR3LWdyYWRpZW50LXRvLXBvc2l0aW9uKSk7XFxuICB9XFxuICAudG8tZ3JlZW4tNTAwIHtcXG4gICAgLS10dy1ncmFkaWVudC10bzogdmFyKC0tY29sb3ItZ3JlZW4tNTAwKTtcXG4gICAgLS10dy1ncmFkaWVudC1zdG9wczogdmFyKC0tdHctZ3JhZGllbnQtdmlhLXN0b3BzLCB2YXIoLS10dy1ncmFkaWVudC1wb3NpdGlvbiksIHZhcigtLXR3LWdyYWRpZW50LWZyb20pIHZhcigtLXR3LWdyYWRpZW50LWZyb20tcG9zaXRpb24pLCB2YXIoLS10dy1ncmFkaWVudC10bykgdmFyKC0tdHctZ3JhZGllbnQtdG8tcG9zaXRpb24pKTtcXG4gIH1cXG4gIC50by1wdXJwbGUtNTAwIHtcXG4gICAgLS10dy1ncmFkaWVudC10bzogdmFyKC0tY29sb3ItcHVycGxlLTUwMCk7XFxuICAgIC0tdHctZ3JhZGllbnQtc3RvcHM6IHZhcigtLXR3LWdyYWRpZW50LXZpYS1zdG9wcywgdmFyKC0tdHctZ3JhZGllbnQtcG9zaXRpb24pLCB2YXIoLS10dy1ncmFkaWVudC1mcm9tKSB2YXIoLS10dy1ncmFkaWVudC1mcm9tLXBvc2l0aW9uKSwgdmFyKC0tdHctZ3JhZGllbnQtdG8pIHZhcigtLXR3LWdyYWRpZW50LXRvLXBvc2l0aW9uKSk7XFxuICB9XFxuICAucC0xIHtcXG4gICAgcGFkZGluZzogdmFyKC0tc3BhY2luZy0xKTtcXG4gIH1cXG4gIC5wLTIge1xcbiAgICBwYWRkaW5nOiB2YXIoLS1zcGFjaW5nLTIpO1xcbiAgfVxcbiAgLnAtMyB7XFxuICAgIHBhZGRpbmc6IHZhcigtLXNwYWNpbmctMyk7XFxuICB9XFxuICAucC00IHtcXG4gICAgcGFkZGluZzogdmFyKC0tc3BhY2luZy00KTtcXG4gIH1cXG4gIC5wLTYge1xcbiAgICBwYWRkaW5nOiB2YXIoLS1zcGFjaW5nLTYpO1xcbiAgfVxcbiAgLnAtOCB7XFxuICAgIHBhZGRpbmc6IHZhcigtLXNwYWNpbmctOCk7XFxuICB9XFxuICAucHgtMFxcXFwuNSB7XFxuICAgIHBhZGRpbmctaW5saW5lOiBjYWxjKHZhcigtLXNwYWNpbmcpICogMC41KTtcXG4gIH1cXG4gIC5weC0xIHtcXG4gICAgcGFkZGluZy1pbmxpbmU6IHZhcigtLXNwYWNpbmctMSk7XFxuICB9XFxuICAucHgtMiB7XFxuICAgIHBhZGRpbmctaW5saW5lOiB2YXIoLS1zcGFjaW5nLTIpO1xcbiAgfVxcbiAgLnB4LTMge1xcbiAgICBwYWRkaW5nLWlubGluZTogdmFyKC0tc3BhY2luZy0zKTtcXG4gIH1cXG4gIC5weC00IHtcXG4gICAgcGFkZGluZy1pbmxpbmU6IHZhcigtLXNwYWNpbmctNCk7XFxuICB9XFxuICAucHgtNiB7XFxuICAgIHBhZGRpbmctaW5saW5lOiB2YXIoLS1zcGFjaW5nLTYpO1xcbiAgfVxcbiAgLnB5LTBcXFxcLjUge1xcbiAgICBwYWRkaW5nLWJsb2NrOiBjYWxjKHZhcigtLXNwYWNpbmcpICogMC41KTtcXG4gIH1cXG4gIC5weS0xIHtcXG4gICAgcGFkZGluZy1ibG9jazogdmFyKC0tc3BhY2luZy0xKTtcXG4gIH1cXG4gIC5weS0xXFxcXC41IHtcXG4gICAgcGFkZGluZy1ibG9jazogY2FsYyh2YXIoLS1zcGFjaW5nKSAqIDEuNSk7XFxuICB9XFxuICAucHktMiB7XFxuICAgIHBhZGRpbmctYmxvY2s6IHZhcigtLXNwYWNpbmctMik7XFxuICB9XFxuICAucHktMyB7XFxuICAgIHBhZGRpbmctYmxvY2s6IHZhcigtLXNwYWNpbmctMyk7XFxuICB9XFxuICAucHktNCB7XFxuICAgIHBhZGRpbmctYmxvY2s6IHZhcigtLXNwYWNpbmctNCk7XFxuICB9XFxuICAucHktcHgge1xcbiAgICBwYWRkaW5nLWJsb2NrOiAxcHg7XFxuICB9XFxuICAucHQtMVxcXFwuNSB7XFxuICAgIHBhZGRpbmctdG9wOiBjYWxjKHZhcigtLXNwYWNpbmcpICogMS41KTtcXG4gIH1cXG4gIC5wdC0yIHtcXG4gICAgcGFkZGluZy10b3A6IHZhcigtLXNwYWNpbmctMik7XFxuICB9XFxuICAucHQtNCB7XFxuICAgIHBhZGRpbmctdG9wOiB2YXIoLS1zcGFjaW5nLTQpO1xcbiAgfVxcbiAgLnB0LTgge1xcbiAgICBwYWRkaW5nLXRvcDogdmFyKC0tc3BhY2luZy04KTtcXG4gIH1cXG4gIC5wdC0xMCB7XFxuICAgIHBhZGRpbmctdG9wOiB2YXIoLS1zcGFjaW5nLTEwKTtcXG4gIH1cXG4gIC5wci00IHtcXG4gICAgcGFkZGluZy1yaWdodDogdmFyKC0tc3BhY2luZy00KTtcXG4gIH1cXG4gIC5wci04IHtcXG4gICAgcGFkZGluZy1yaWdodDogdmFyKC0tc3BhY2luZy04KTtcXG4gIH1cXG4gIC5wYi0yIHtcXG4gICAgcGFkZGluZy1ib3R0b206IHZhcigtLXNwYWNpbmctMik7XFxuICB9XFxuICAucGItNCB7XFxuICAgIHBhZGRpbmctYm90dG9tOiB2YXIoLS1zcGFjaW5nLTQpO1xcbiAgfVxcbiAgLnBiLTgge1xcbiAgICBwYWRkaW5nLWJvdHRvbTogdmFyKC0tc3BhY2luZy04KTtcXG4gIH1cXG4gIC5wYi0xMCB7XFxuICAgIHBhZGRpbmctYm90dG9tOiB2YXIoLS1zcGFjaW5nLTEwKTtcXG4gIH1cXG4gIC5wbC01IHtcXG4gICAgcGFkZGluZy1sZWZ0OiB2YXIoLS1zcGFjaW5nLTUpO1xcbiAgfVxcbiAgLnBsLTgge1xcbiAgICBwYWRkaW5nLWxlZnQ6IHZhcigtLXNwYWNpbmctOCk7XFxuICB9XFxuICAudGV4dC1jZW50ZXIge1xcbiAgICB0ZXh0LWFsaWduOiBjZW50ZXI7XFxuICB9XFxuICAudGV4dC1sZWZ0IHtcXG4gICAgdGV4dC1hbGlnbjogbGVmdDtcXG4gIH1cXG4gIC50ZXh0LXJpZ2h0IHtcXG4gICAgdGV4dC1hbGlnbjogcmlnaHQ7XFxuICB9XFxuICAuZm9udC1tb25vIHtcXG4gICAgZm9udC1mYW1pbHk6IHZhcigtLWZvbnQtbW9ubyk7XFxuICB9XFxuICAudGV4dC0yeGwge1xcbiAgICBmb250LXNpemU6IHZhcigtLXRleHQtMnhsKTtcXG4gICAgbGluZS1oZWlnaHQ6IHZhcigtLXR3LWxlYWRpbmcsIHZhcigtLXRleHQtMnhsLS1saW5lLWhlaWdodCkpO1xcbiAgfVxcbiAgLnRleHQtM3hsIHtcXG4gICAgZm9udC1zaXplOiB2YXIoLS10ZXh0LTN4bCk7XFxuICAgIGxpbmUtaGVpZ2h0OiB2YXIoLS10dy1sZWFkaW5nLCB2YXIoLS10ZXh0LTN4bC0tbGluZS1oZWlnaHQpKTtcXG4gIH1cXG4gIC50ZXh0LWxnIHtcXG4gICAgZm9udC1zaXplOiB2YXIoLS10ZXh0LWxnKTtcXG4gICAgbGluZS1oZWlnaHQ6IHZhcigtLXR3LWxlYWRpbmcsIHZhcigtLXRleHQtbGctLWxpbmUtaGVpZ2h0KSk7XFxuICB9XFxuICAudGV4dC1zbSB7XFxuICAgIGZvbnQtc2l6ZTogdmFyKC0tdGV4dC1zbSk7XFxuICAgIGxpbmUtaGVpZ2h0OiB2YXIoLS10dy1sZWFkaW5nLCB2YXIoLS10ZXh0LXNtLS1saW5lLWhlaWdodCkpO1xcbiAgfVxcbiAgLnRleHQteGwge1xcbiAgICBmb250LXNpemU6IHZhcigtLXRleHQteGwpO1xcbiAgICBsaW5lLWhlaWdodDogdmFyKC0tdHctbGVhZGluZywgdmFyKC0tdGV4dC14bC0tbGluZS1oZWlnaHQpKTtcXG4gIH1cXG4gIC50ZXh0LXhzIHtcXG4gICAgZm9udC1zaXplOiB2YXIoLS10ZXh0LXhzKTtcXG4gICAgbGluZS1oZWlnaHQ6IHZhcigtLXR3LWxlYWRpbmcsIHZhcigtLXRleHQteHMtLWxpbmUtaGVpZ2h0KSk7XFxuICB9XFxuICAudGV4dC1cXFxcWzBcXFxcLjZyZW1cXFxcXSB7XFxuICAgIGZvbnQtc2l6ZTogMC42cmVtO1xcbiAgfVxcbiAgLnRleHQtXFxcXFswXFxcXC42NXJlbVxcXFxdIHtcXG4gICAgZm9udC1zaXplOiAwLjY1cmVtO1xcbiAgfVxcbiAgLnRleHQtXFxcXFswXFxcXC43NXJlbVxcXFxdIHtcXG4gICAgZm9udC1zaXplOiAwLjc1cmVtO1xcbiAgfVxcbiAgLnRleHQtXFxcXFs4cHhcXFxcXSB7XFxuICAgIGZvbnQtc2l6ZTogOHB4O1xcbiAgfVxcbiAgLnRleHQtXFxcXFsxMHB4XFxcXF0ge1xcbiAgICBmb250LXNpemU6IDEwcHg7XFxuICB9XFxuICAubGVhZGluZy1ub25lIHtcXG4gICAgLS10dy1sZWFkaW5nOiAxO1xcbiAgICBsaW5lLWhlaWdodDogMTtcXG4gIH1cXG4gIC5sZWFkaW5nLXRpZ2h0IHtcXG4gICAgLS10dy1sZWFkaW5nOiB2YXIoLS1sZWFkaW5nLXRpZ2h0KTtcXG4gICAgbGluZS1oZWlnaHQ6IHZhcigtLWxlYWRpbmctdGlnaHQpO1xcbiAgfVxcbiAgLmZvbnQtYm9sZCB7XFxuICAgIC0tdHctZm9udC13ZWlnaHQ6IHZhcigtLWZvbnQtd2VpZ2h0LWJvbGQpO1xcbiAgICBmb250LXdlaWdodDogdmFyKC0tZm9udC13ZWlnaHQtYm9sZCk7XFxuICB9XFxuICAuZm9udC1saWdodCB7XFxuICAgIC0tdHctZm9udC13ZWlnaHQ6IHZhcigtLWZvbnQtd2VpZ2h0LWxpZ2h0KTtcXG4gICAgZm9udC13ZWlnaHQ6IHZhcigtLWZvbnQtd2VpZ2h0LWxpZ2h0KTtcXG4gIH1cXG4gIC5mb250LW1lZGl1bSB7XFxuICAgIC0tdHctZm9udC13ZWlnaHQ6IHZhcigtLWZvbnQtd2VpZ2h0LW1lZGl1bSk7XFxuICAgIGZvbnQtd2VpZ2h0OiB2YXIoLS1mb250LXdlaWdodC1tZWRpdW0pO1xcbiAgfVxcbiAgLmZvbnQtc2VtaWJvbGQge1xcbiAgICAtLXR3LWZvbnQtd2VpZ2h0OiB2YXIoLS1mb250LXdlaWdodC1zZW1pYm9sZCk7XFxuICAgIGZvbnQtd2VpZ2h0OiB2YXIoLS1mb250LXdlaWdodC1zZW1pYm9sZCk7XFxuICB9XFxuICAud2hpdGVzcGFjZS1ub3JtYWwge1xcbiAgICB3aGl0ZS1zcGFjZTogbm9ybWFsO1xcbiAgfVxcbiAgLndoaXRlc3BhY2Utbm93cmFwIHtcXG4gICAgd2hpdGUtc3BhY2U6IG5vd3JhcDtcXG4gIH1cXG4gIC50ZXh0LWJsdWUtNDAwIHtcXG4gICAgY29sb3I6IHZhcigtLWNvbG9yLWJsdWUtNDAwKTtcXG4gIH1cXG4gIC50ZXh0LWJsdWUtNTAwIHtcXG4gICAgY29sb3I6IHZhcigtLWNvbG9yLWJsdWUtNTAwKTtcXG4gIH1cXG4gIC50ZXh0LWJsdWUtNjAwIHtcXG4gICAgY29sb3I6IHZhcigtLWNvbG9yLWJsdWUtNjAwKTtcXG4gIH1cXG4gIC50ZXh0LWJsdWUtNzAwIHtcXG4gICAgY29sb3I6IHZhcigtLWNvbG9yLWJsdWUtNzAwKTtcXG4gIH1cXG4gIC50ZXh0LWJsdWUtODAwIHtcXG4gICAgY29sb3I6IHZhcigtLWNvbG9yLWJsdWUtODAwKTtcXG4gIH1cXG4gIC50ZXh0LWdyYXktNDAwIHtcXG4gICAgY29sb3I6IHZhcigtLWNvbG9yLWdyYXktNDAwKTtcXG4gIH1cXG4gIC50ZXh0LWdyYXktNTAwIHtcXG4gICAgY29sb3I6IHZhcigtLWNvbG9yLWdyYXktNTAwKTtcXG4gIH1cXG4gIC50ZXh0LWdyYXktNjAwIHtcXG4gICAgY29sb3I6IHZhcigtLWNvbG9yLWdyYXktNjAwKTtcXG4gIH1cXG4gIC50ZXh0LWdyYXktNzAwIHtcXG4gICAgY29sb3I6IHZhcigtLWNvbG9yLWdyYXktNzAwKTtcXG4gIH1cXG4gIC50ZXh0LWdyYXktODAwIHtcXG4gICAgY29sb3I6IHZhcigtLWNvbG9yLWdyYXktODAwKTtcXG4gIH1cXG4gIC50ZXh0LWdyYXktOTAwIHtcXG4gICAgY29sb3I6IHZhcigtLWNvbG9yLWdyYXktOTAwKTtcXG4gIH1cXG4gIC50ZXh0LWdyZWVuLTcwMCB7XFxuICAgIGNvbG9yOiB2YXIoLS1jb2xvci1ncmVlbi03MDApO1xcbiAgfVxcbiAgLnRleHQtcmVkLTYwMCB7XFxuICAgIGNvbG9yOiB2YXIoLS1jb2xvci1yZWQtNjAwKTtcXG4gIH1cXG4gIC50ZXh0LXdoaXRlIHtcXG4gICAgY29sb3I6IHZhcigtLWNvbG9yLXdoaXRlKTtcXG4gIH1cXG4gIC50ZXh0LXllbGxvdy04MDAge1xcbiAgICBjb2xvcjogdmFyKC0tY29sb3IteWVsbG93LTgwMCk7XFxuICB9XFxuICAuY2FwaXRhbGl6ZSB7XFxuICAgIHRleHQtdHJhbnNmb3JtOiBjYXBpdGFsaXplO1xcbiAgfVxcbiAgLmxvd2VyY2FzZSB7XFxuICAgIHRleHQtdHJhbnNmb3JtOiBsb3dlcmNhc2U7XFxuICB9XFxuICAudXBwZXJjYXNlIHtcXG4gICAgdGV4dC10cmFuc2Zvcm06IHVwcGVyY2FzZTtcXG4gIH1cXG4gIC5pdGFsaWMge1xcbiAgICBmb250LXN0eWxlOiBpdGFsaWM7XFxuICB9XFxuICAub3JkaW5hbCB7XFxuICAgIC0tdHctb3JkaW5hbDogb3JkaW5hbDtcXG4gICAgZm9udC12YXJpYW50LW51bWVyaWM6IHZhcigtLXR3LW9yZGluYWwsKSB2YXIoLS10dy1zbGFzaGVkLXplcm8sKSB2YXIoLS10dy1udW1lcmljLWZpZ3VyZSwpIHZhcigtLXR3LW51bWVyaWMtc3BhY2luZywpIHZhcigtLXR3LW51bWVyaWMtZnJhY3Rpb24sKTtcXG4gIH1cXG4gIC5saW5lLXRocm91Z2gge1xcbiAgICB0ZXh0LWRlY29yYXRpb24tbGluZTogbGluZS10aHJvdWdoO1xcbiAgfVxcbiAgLm92ZXJsaW5lIHtcXG4gICAgdGV4dC1kZWNvcmF0aW9uLWxpbmU6IG92ZXJsaW5lO1xcbiAgfVxcbiAgLnVuZGVybGluZSB7XFxuICAgIHRleHQtZGVjb3JhdGlvbi1saW5lOiB1bmRlcmxpbmU7XFxuICB9XFxuICAub3BhY2l0eS0wIHtcXG4gICAgb3BhY2l0eTogMCU7XFxuICB9XFxuICAub3BhY2l0eS01MCB7XFxuICAgIG9wYWNpdHk6IDUwJTtcXG4gIH1cXG4gIC5vcGFjaXR5LTEwMCB7XFxuICAgIG9wYWNpdHk6IDEwMCU7XFxuICB9XFxuICAuc2hhZG93IHtcXG4gICAgLS10dy1zaGFkb3c6IDAgMXB4IDNweCAwIHZhcigtLXR3LXNoYWRvdy1jb2xvciwgcmdiKDAgMCAwIC8gMC4xKSksIDAgMXB4IDJweCAtMXB4IHZhcigtLXR3LXNoYWRvdy1jb2xvciwgcmdiKDAgMCAwIC8gMC4xKSk7XFxuICAgIGJveC1zaGFkb3c6IHZhcigtLXR3LWluc2V0LXNoYWRvdyksIHZhcigtLXR3LWluc2V0LXJpbmctc2hhZG93KSwgdmFyKC0tdHctcmluZy1vZmZzZXQtc2hhZG93KSwgdmFyKC0tdHctcmluZy1zaGFkb3cpLCB2YXIoLS10dy1zaGFkb3cpO1xcbiAgfVxcbiAgLnNoYWRvdy1pbm5lciB7XFxuICAgIC0tdHctc2hhZG93OiBpbnNldCAwIDJweCA0cHggMCB2YXIoLS10dy1zaGFkb3ctY29sb3IsIHJnYigwIDAgMCAvIDAuMDUpKTtcXG4gICAgYm94LXNoYWRvdzogdmFyKC0tdHctaW5zZXQtc2hhZG93KSwgdmFyKC0tdHctaW5zZXQtcmluZy1zaGFkb3cpLCB2YXIoLS10dy1yaW5nLW9mZnNldC1zaGFkb3cpLCB2YXIoLS10dy1yaW5nLXNoYWRvdyksIHZhcigtLXR3LXNoYWRvdyk7XFxuICB9XFxuICAuc2hhZG93LWxnIHtcXG4gICAgLS10dy1zaGFkb3c6IDAgMTBweCAxNXB4IC0zcHggdmFyKC0tdHctc2hhZG93LWNvbG9yLCByZ2IoMCAwIDAgLyAwLjEpKSwgMCA0cHggNnB4IC00cHggdmFyKC0tdHctc2hhZG93LWNvbG9yLCByZ2IoMCAwIDAgLyAwLjEpKTtcXG4gICAgYm94LXNoYWRvdzogdmFyKC0tdHctaW5zZXQtc2hhZG93KSwgdmFyKC0tdHctaW5zZXQtcmluZy1zaGFkb3cpLCB2YXIoLS10dy1yaW5nLW9mZnNldC1zaGFkb3cpLCB2YXIoLS10dy1yaW5nLXNoYWRvdyksIHZhcigtLXR3LXNoYWRvdyk7XFxuICB9XFxuICAuc2hhZG93LW1kIHtcXG4gICAgLS10dy1zaGFkb3c6IDAgNHB4IDZweCAtMXB4IHZhcigtLXR3LXNoYWRvdy1jb2xvciwgcmdiKDAgMCAwIC8gMC4xKSksIDAgMnB4IDRweCAtMnB4IHZhcigtLXR3LXNoYWRvdy1jb2xvciwgcmdiKDAgMCAwIC8gMC4xKSk7XFxuICAgIGJveC1zaGFkb3c6IHZhcigtLXR3LWluc2V0LXNoYWRvdyksIHZhcigtLXR3LWluc2V0LXJpbmctc2hhZG93KSwgdmFyKC0tdHctcmluZy1vZmZzZXQtc2hhZG93KSwgdmFyKC0tdHctcmluZy1zaGFkb3cpLCB2YXIoLS10dy1zaGFkb3cpO1xcbiAgfVxcbiAgLnNoYWRvdy1zbSB7XFxuICAgIC0tdHctc2hhZG93OiAwIDFweCAzcHggMCB2YXIoLS10dy1zaGFkb3ctY29sb3IsIHJnYigwIDAgMCAvIDAuMSkpLCAwIDFweCAycHggLTFweCB2YXIoLS10dy1zaGFkb3ctY29sb3IsIHJnYigwIDAgMCAvIDAuMSkpO1xcbiAgICBib3gtc2hhZG93OiB2YXIoLS10dy1pbnNldC1zaGFkb3cpLCB2YXIoLS10dy1pbnNldC1yaW5nLXNoYWRvdyksIHZhcigtLXR3LXJpbmctb2Zmc2V0LXNoYWRvdyksIHZhcigtLXR3LXJpbmctc2hhZG93KSwgdmFyKC0tdHctc2hhZG93KTtcXG4gIH1cXG4gIC5zaGFkb3cteGwge1xcbiAgICAtLXR3LXNoYWRvdzogMCAyMHB4IDI1cHggLTVweCB2YXIoLS10dy1zaGFkb3ctY29sb3IsIHJnYigwIDAgMCAvIDAuMSkpLCAwIDhweCAxMHB4IC02cHggdmFyKC0tdHctc2hhZG93LWNvbG9yLCByZ2IoMCAwIDAgLyAwLjEpKTtcXG4gICAgYm94LXNoYWRvdzogdmFyKC0tdHctaW5zZXQtc2hhZG93KSwgdmFyKC0tdHctaW5zZXQtcmluZy1zaGFkb3cpLCB2YXIoLS10dy1yaW5nLW9mZnNldC1zaGFkb3cpLCB2YXIoLS10dy1yaW5nLXNoYWRvdyksIHZhcigtLXR3LXNoYWRvdyk7XFxuICB9XFxuICAucmluZyB7XFxuICAgIC0tdHctcmluZy1zaGFkb3c6IHZhcigtLXR3LXJpbmctaW5zZXQsKSAwIDAgMCBjYWxjKDFweCArIHZhcigtLXR3LXJpbmctb2Zmc2V0LXdpZHRoKSkgdmFyKC0tdHctcmluZy1jb2xvciwgY3VycmVudGNvbG9yKTtcXG4gICAgYm94LXNoYWRvdzogdmFyKC0tdHctaW5zZXQtc2hhZG93KSwgdmFyKC0tdHctaW5zZXQtcmluZy1zaGFkb3cpLCB2YXIoLS10dy1yaW5nLW9mZnNldC1zaGFkb3cpLCB2YXIoLS10dy1yaW5nLXNoYWRvdyksIHZhcigtLXR3LXNoYWRvdyk7XFxuICB9XFxuICAub3V0bGluZSB7XFxuICAgIG91dGxpbmUtc3R5bGU6IHZhcigtLXR3LW91dGxpbmUtc3R5bGUpO1xcbiAgICBvdXRsaW5lLXdpZHRoOiAxcHg7XFxuICB9XFxuICAuYmx1ciB7XFxuICAgIC0tdHctYmx1cjogYmx1cig4cHgpO1xcbiAgICBmaWx0ZXI6IHZhcigtLXR3LWJsdXIsKSB2YXIoLS10dy1icmlnaHRuZXNzLCkgdmFyKC0tdHctY29udHJhc3QsKSB2YXIoLS10dy1ncmF5c2NhbGUsKSB2YXIoLS10dy1odWUtcm90YXRlLCkgdmFyKC0tdHctaW52ZXJ0LCkgdmFyKC0tdHctc2F0dXJhdGUsKSB2YXIoLS10dy1zZXBpYSwpIHZhcigtLXR3LWRyb3Atc2hhZG93LCk7XFxuICB9XFxuICAuZ3JheXNjYWxlIHtcXG4gICAgLS10dy1ncmF5c2NhbGU6IGdyYXlzY2FsZSgxMDAlKTtcXG4gICAgZmlsdGVyOiB2YXIoLS10dy1ibHVyLCkgdmFyKC0tdHctYnJpZ2h0bmVzcywpIHZhcigtLXR3LWNvbnRyYXN0LCkgdmFyKC0tdHctZ3JheXNjYWxlLCkgdmFyKC0tdHctaHVlLXJvdGF0ZSwpIHZhcigtLXR3LWludmVydCwpIHZhcigtLXR3LXNhdHVyYXRlLCkgdmFyKC0tdHctc2VwaWEsKSB2YXIoLS10dy1kcm9wLXNoYWRvdywpO1xcbiAgfVxcbiAgLmludmVydCB7XFxuICAgIC0tdHctaW52ZXJ0OiBpbnZlcnQoMTAwJSk7XFxuICAgIGZpbHRlcjogdmFyKC0tdHctYmx1ciwpIHZhcigtLXR3LWJyaWdodG5lc3MsKSB2YXIoLS10dy1jb250cmFzdCwpIHZhcigtLXR3LWdyYXlzY2FsZSwpIHZhcigtLXR3LWh1ZS1yb3RhdGUsKSB2YXIoLS10dy1pbnZlcnQsKSB2YXIoLS10dy1zYXR1cmF0ZSwpIHZhcigtLXR3LXNlcGlhLCkgdmFyKC0tdHctZHJvcC1zaGFkb3csKTtcXG4gIH1cXG4gIC5maWx0ZXIge1xcbiAgICBmaWx0ZXI6IHZhcigtLXR3LWJsdXIsKSB2YXIoLS10dy1icmlnaHRuZXNzLCkgdmFyKC0tdHctY29udHJhc3QsKSB2YXIoLS10dy1ncmF5c2NhbGUsKSB2YXIoLS10dy1odWUtcm90YXRlLCkgdmFyKC0tdHctaW52ZXJ0LCkgdmFyKC0tdHctc2F0dXJhdGUsKSB2YXIoLS10dy1zZXBpYSwpIHZhcigtLXR3LWRyb3Atc2hhZG93LCk7XFxuICB9XFxuICAuYmFja2Ryb3AtYmx1ci1zbSB7XFxuICAgIC0tdHctYmFja2Ryb3AtYmx1cjogYmx1cih2YXIoLS1ibHVyLXNtKSk7XFxuICAgIC13ZWJraXQtYmFja2Ryb3AtZmlsdGVyOiB2YXIoLS10dy1iYWNrZHJvcC1ibHVyLCkgdmFyKC0tdHctYmFja2Ryb3AtYnJpZ2h0bmVzcywpIHZhcigtLXR3LWJhY2tkcm9wLWNvbnRyYXN0LCkgdmFyKC0tdHctYmFja2Ryb3AtZ3JheXNjYWxlLCkgdmFyKC0tdHctYmFja2Ryb3AtaHVlLXJvdGF0ZSwpIHZhcigtLXR3LWJhY2tkcm9wLWludmVydCwpIHZhcigtLXR3LWJhY2tkcm9wLW9wYWNpdHksKSB2YXIoLS10dy1iYWNrZHJvcC1zYXR1cmF0ZSwpIHZhcigtLXR3LWJhY2tkcm9wLXNlcGlhLCk7XFxuICAgIGJhY2tkcm9wLWZpbHRlcjogdmFyKC0tdHctYmFja2Ryb3AtYmx1ciwpIHZhcigtLXR3LWJhY2tkcm9wLWJyaWdodG5lc3MsKSB2YXIoLS10dy1iYWNrZHJvcC1jb250cmFzdCwpIHZhcigtLXR3LWJhY2tkcm9wLWdyYXlzY2FsZSwpIHZhcigtLXR3LWJhY2tkcm9wLWh1ZS1yb3RhdGUsKSB2YXIoLS10dy1iYWNrZHJvcC1pbnZlcnQsKSB2YXIoLS10dy1iYWNrZHJvcC1vcGFjaXR5LCkgdmFyKC0tdHctYmFja2Ryb3Atc2F0dXJhdGUsKSB2YXIoLS10dy1iYWNrZHJvcC1zZXBpYSwpO1xcbiAgfVxcbiAgLnRyYW5zaXRpb24ge1xcbiAgICB0cmFuc2l0aW9uLXByb3BlcnR5OiBjb2xvciwgYmFja2dyb3VuZC1jb2xvciwgYm9yZGVyLWNvbG9yLCBvdXRsaW5lLWNvbG9yLCB0ZXh0LWRlY29yYXRpb24tY29sb3IsIGZpbGwsIHN0cm9rZSwgLS10dy1ncmFkaWVudC1mcm9tLCAtLXR3LWdyYWRpZW50LXZpYSwgLS10dy1ncmFkaWVudC10bywgb3BhY2l0eSwgYm94LXNoYWRvdywgdHJhbnNmb3JtLCB0cmFuc2xhdGUsIHNjYWxlLCByb3RhdGUsIGZpbHRlciwgLXdlYmtpdC1iYWNrZHJvcC1maWx0ZXIsIGJhY2tkcm9wLWZpbHRlciwgZGlzcGxheSwgdmlzaWJpbGl0eSwgY29udGVudC12aXNpYmlsaXR5LCBvdmVybGF5LCBwb2ludGVyLWV2ZW50cztcXG4gICAgdHJhbnNpdGlvbi10aW1pbmctZnVuY3Rpb246IHZhcigtLXR3LWVhc2UsIHZhcigtLWRlZmF1bHQtdHJhbnNpdGlvbi10aW1pbmctZnVuY3Rpb24pKTtcXG4gICAgdHJhbnNpdGlvbi1kdXJhdGlvbjogdmFyKC0tdHctZHVyYXRpb24sIHZhcigtLWRlZmF1bHQtdHJhbnNpdGlvbi1kdXJhdGlvbikpO1xcbiAgfVxcbiAgLnRyYW5zaXRpb24tYWxsIHtcXG4gICAgdHJhbnNpdGlvbi1wcm9wZXJ0eTogYWxsO1xcbiAgICB0cmFuc2l0aW9uLXRpbWluZy1mdW5jdGlvbjogdmFyKC0tdHctZWFzZSwgdmFyKC0tZGVmYXVsdC10cmFuc2l0aW9uLXRpbWluZy1mdW5jdGlvbikpO1xcbiAgICB0cmFuc2l0aW9uLWR1cmF0aW9uOiB2YXIoLS10dy1kdXJhdGlvbiwgdmFyKC0tZGVmYXVsdC10cmFuc2l0aW9uLWR1cmF0aW9uKSk7XFxuICB9XFxuICAudHJhbnNpdGlvbi1jb2xvcnMge1xcbiAgICB0cmFuc2l0aW9uLXByb3BlcnR5OiBjb2xvciwgYmFja2dyb3VuZC1jb2xvciwgYm9yZGVyLWNvbG9yLCBvdXRsaW5lLWNvbG9yLCB0ZXh0LWRlY29yYXRpb24tY29sb3IsIGZpbGwsIHN0cm9rZSwgLS10dy1ncmFkaWVudC1mcm9tLCAtLXR3LWdyYWRpZW50LXZpYSwgLS10dy1ncmFkaWVudC10bztcXG4gICAgdHJhbnNpdGlvbi10aW1pbmctZnVuY3Rpb246IHZhcigtLXR3LWVhc2UsIHZhcigtLWRlZmF1bHQtdHJhbnNpdGlvbi10aW1pbmctZnVuY3Rpb24pKTtcXG4gICAgdHJhbnNpdGlvbi1kdXJhdGlvbjogdmFyKC0tdHctZHVyYXRpb24sIHZhcigtLWRlZmF1bHQtdHJhbnNpdGlvbi1kdXJhdGlvbikpO1xcbiAgfVxcbiAgLnRyYW5zaXRpb24tb3BhY2l0eSB7XFxuICAgIHRyYW5zaXRpb24tcHJvcGVydHk6IG9wYWNpdHk7XFxuICAgIHRyYW5zaXRpb24tdGltaW5nLWZ1bmN0aW9uOiB2YXIoLS10dy1lYXNlLCB2YXIoLS1kZWZhdWx0LXRyYW5zaXRpb24tdGltaW5nLWZ1bmN0aW9uKSk7XFxuICAgIHRyYW5zaXRpb24tZHVyYXRpb246IHZhcigtLXR3LWR1cmF0aW9uLCB2YXIoLS1kZWZhdWx0LXRyYW5zaXRpb24tZHVyYXRpb24pKTtcXG4gIH1cXG4gIC50cmFuc2l0aW9uLXRyYW5zZm9ybSB7XFxuICAgIHRyYW5zaXRpb24tcHJvcGVydHk6IHRyYW5zZm9ybSwgdHJhbnNsYXRlLCBzY2FsZSwgcm90YXRlO1xcbiAgICB0cmFuc2l0aW9uLXRpbWluZy1mdW5jdGlvbjogdmFyKC0tdHctZWFzZSwgdmFyKC0tZGVmYXVsdC10cmFuc2l0aW9uLXRpbWluZy1mdW5jdGlvbikpO1xcbiAgICB0cmFuc2l0aW9uLWR1cmF0aW9uOiB2YXIoLS10dy1kdXJhdGlvbiwgdmFyKC0tZGVmYXVsdC10cmFuc2l0aW9uLWR1cmF0aW9uKSk7XFxuICB9XFxuICAuZHVyYXRpb24tMTUwIHtcXG4gICAgLS10dy1kdXJhdGlvbjogMTUwbXM7XFxuICAgIHRyYW5zaXRpb24tZHVyYXRpb246IDE1MG1zO1xcbiAgfVxcbiAgLmR1cmF0aW9uLTIwMCB7XFxuICAgIC0tdHctZHVyYXRpb246IDIwMG1zO1xcbiAgICB0cmFuc2l0aW9uLWR1cmF0aW9uOiAyMDBtcztcXG4gIH1cXG4gIC5kdXJhdGlvbi0zMDAge1xcbiAgICAtLXR3LWR1cmF0aW9uOiAzMDBtcztcXG4gICAgdHJhbnNpdGlvbi1kdXJhdGlvbjogMzAwbXM7XFxuICB9XFxuICAuZWFzZS1pbi1vdXQge1xcbiAgICAtLXR3LWVhc2U6IHZhcigtLWVhc2UtaW4tb3V0KTtcXG4gICAgdHJhbnNpdGlvbi10aW1pbmctZnVuY3Rpb246IHZhcigtLWVhc2UtaW4tb3V0KTtcXG4gIH1cXG4gIC5vdXRsaW5lLW5vbmUge1xcbiAgICAtLXR3LW91dGxpbmUtc3R5bGU6IG5vbmU7XFxuICAgIG91dGxpbmUtc3R5bGU6IG5vbmU7XFxuICB9XFxuICAuc2VsZWN0LW5vbmUge1xcbiAgICAtd2Via2l0LXVzZXItc2VsZWN0OiBub25lO1xcbiAgICAtbW96LXVzZXItc2VsZWN0OiBub25lO1xcbiAgICAgICAgIHVzZXItc2VsZWN0OiBub25lO1xcbiAgfVxcbiAgLmdyb3VwLWhvdmVyXFxcXDp2aXNpYmxlIHtcXG4gICAgJjppcyg6d2hlcmUoLmdyb3VwKTpob3ZlciAqKSB7XFxuICAgICAgQG1lZGlhIChob3ZlcjogaG92ZXIpIHtcXG4gICAgICAgIHZpc2liaWxpdHk6IHZpc2libGU7XFxuICAgICAgfVxcbiAgICB9XFxuICB9XFxuICAuZ3JvdXAtaG92ZXJcXFxcOm9wYWNpdHktMTAwIHtcXG4gICAgJjppcyg6d2hlcmUoLmdyb3VwKTpob3ZlciAqKSB7XFxuICAgICAgQG1lZGlhIChob3ZlcjogaG92ZXIpIHtcXG4gICAgICAgIG9wYWNpdHk6IDEwMCU7XFxuICAgICAgfVxcbiAgICB9XFxuICB9XFxuICAuaG92ZXJcXFxcOnNjYWxlLTExMCB7XFxuICAgICY6aG92ZXIge1xcbiAgICAgIEBtZWRpYSAoaG92ZXI6IGhvdmVyKSB7XFxuICAgICAgICAtLXR3LXNjYWxlLXg6IDExMCU7XFxuICAgICAgICAtLXR3LXNjYWxlLXk6IDExMCU7XFxuICAgICAgICAtLXR3LXNjYWxlLXo6IDExMCU7XFxuICAgICAgICBzY2FsZTogdmFyKC0tdHctc2NhbGUteCkgdmFyKC0tdHctc2NhbGUteSk7XFxuICAgICAgfVxcbiAgICB9XFxuICB9XFxuICAuaG92ZXJcXFxcOmJvcmRlci1ibHVlLTIwMCB7XFxuICAgICY6aG92ZXIge1xcbiAgICAgIEBtZWRpYSAoaG92ZXI6IGhvdmVyKSB7XFxuICAgICAgICBib3JkZXItY29sb3I6IHZhcigtLWNvbG9yLWJsdWUtMjAwKTtcXG4gICAgICB9XFxuICAgIH1cXG4gIH1cXG4gIC5ob3ZlclxcXFw6Ym9yZGVyLWJsdWUtNDAwIHtcXG4gICAgJjpob3ZlciB7XFxuICAgICAgQG1lZGlhIChob3ZlcjogaG92ZXIpIHtcXG4gICAgICAgIGJvcmRlci1jb2xvcjogdmFyKC0tY29sb3ItYmx1ZS00MDApO1xcbiAgICAgIH1cXG4gICAgfVxcbiAgfVxcbiAgLmhvdmVyXFxcXDpiZy1ibHVlLTUwIHtcXG4gICAgJjpob3ZlciB7XFxuICAgICAgQG1lZGlhIChob3ZlcjogaG92ZXIpIHtcXG4gICAgICAgIGJhY2tncm91bmQtY29sb3I6IHZhcigtLWNvbG9yLWJsdWUtNTApO1xcbiAgICAgIH1cXG4gICAgfVxcbiAgfVxcbiAgLmhvdmVyXFxcXDpiZy1ibHVlLTIwMCB7XFxuICAgICY6aG92ZXIge1xcbiAgICAgIEBtZWRpYSAoaG92ZXI6IGhvdmVyKSB7XFxuICAgICAgICBiYWNrZ3JvdW5kLWNvbG9yOiB2YXIoLS1jb2xvci1ibHVlLTIwMCk7XFxuICAgICAgfVxcbiAgICB9XFxuICB9XFxuICAuaG92ZXJcXFxcOmJnLWJsdWUtNjAwIHtcXG4gICAgJjpob3ZlciB7XFxuICAgICAgQG1lZGlhIChob3ZlcjogaG92ZXIpIHtcXG4gICAgICAgIGJhY2tncm91bmQtY29sb3I6IHZhcigtLWNvbG9yLWJsdWUtNjAwKTtcXG4gICAgICB9XFxuICAgIH1cXG4gIH1cXG4gIC5ob3ZlclxcXFw6YmctYmx1ZS03MDAge1xcbiAgICAmOmhvdmVyIHtcXG4gICAgICBAbWVkaWEgKGhvdmVyOiBob3Zlcikge1xcbiAgICAgICAgYmFja2dyb3VuZC1jb2xvcjogdmFyKC0tY29sb3ItYmx1ZS03MDApO1xcbiAgICAgIH1cXG4gICAgfVxcbiAgfVxcbiAgLmhvdmVyXFxcXDpiZy1ncmF5LTUwIHtcXG4gICAgJjpob3ZlciB7XFxuICAgICAgQG1lZGlhIChob3ZlcjogaG92ZXIpIHtcXG4gICAgICAgIGJhY2tncm91bmQtY29sb3I6IHZhcigtLWNvbG9yLWdyYXktNTApO1xcbiAgICAgIH1cXG4gICAgfVxcbiAgfVxcbiAgLmhvdmVyXFxcXDpiZy1ncmF5LTEwMCB7XFxuICAgICY6aG92ZXIge1xcbiAgICAgIEBtZWRpYSAoaG92ZXI6IGhvdmVyKSB7XFxuICAgICAgICBiYWNrZ3JvdW5kLWNvbG9yOiB2YXIoLS1jb2xvci1ncmF5LTEwMCk7XFxuICAgICAgfVxcbiAgICB9XFxuICB9XFxuICAuaG92ZXJcXFxcOmJnLWdyYXktMjAwIHtcXG4gICAgJjpob3ZlciB7XFxuICAgICAgQG1lZGlhIChob3ZlcjogaG92ZXIpIHtcXG4gICAgICAgIGJhY2tncm91bmQtY29sb3I6IHZhcigtLWNvbG9yLWdyYXktMjAwKTtcXG4gICAgICB9XFxuICAgIH1cXG4gIH1cXG4gIC5ob3ZlclxcXFw6YmctZ3JheS0zMDAge1xcbiAgICAmOmhvdmVyIHtcXG4gICAgICBAbWVkaWEgKGhvdmVyOiBob3Zlcikge1xcbiAgICAgICAgYmFja2dyb3VuZC1jb2xvcjogdmFyKC0tY29sb3ItZ3JheS0zMDApO1xcbiAgICAgIH1cXG4gICAgfVxcbiAgfVxcbiAgLmhvdmVyXFxcXDpiZy1yZWQtNzAwIHtcXG4gICAgJjpob3ZlciB7XFxuICAgICAgQG1lZGlhIChob3ZlcjogaG92ZXIpIHtcXG4gICAgICAgIGJhY2tncm91bmQtY29sb3I6IHZhcigtLWNvbG9yLXJlZC03MDApO1xcbiAgICAgIH1cXG4gICAgfVxcbiAgfVxcbiAgLmhvdmVyXFxcXDp0ZXh0LWJsdWUtNTAwIHtcXG4gICAgJjpob3ZlciB7XFxuICAgICAgQG1lZGlhIChob3ZlcjogaG92ZXIpIHtcXG4gICAgICAgIGNvbG9yOiB2YXIoLS1jb2xvci1ibHVlLTUwMCk7XFxuICAgICAgfVxcbiAgICB9XFxuICB9XFxuICAuaG92ZXJcXFxcOnRleHQtYmx1ZS02MDAge1xcbiAgICAmOmhvdmVyIHtcXG4gICAgICBAbWVkaWEgKGhvdmVyOiBob3Zlcikge1xcbiAgICAgICAgY29sb3I6IHZhcigtLWNvbG9yLWJsdWUtNjAwKTtcXG4gICAgICB9XFxuICAgIH1cXG4gIH1cXG4gIC5ob3ZlclxcXFw6dGV4dC1ibHVlLTgwMCB7XFxuICAgICY6aG92ZXIge1xcbiAgICAgIEBtZWRpYSAoaG92ZXI6IGhvdmVyKSB7XFxuICAgICAgICBjb2xvcjogdmFyKC0tY29sb3ItYmx1ZS04MDApO1xcbiAgICAgIH1cXG4gICAgfVxcbiAgfVxcbiAgLmhvdmVyXFxcXDp0ZXh0LWdyYXktNjAwIHtcXG4gICAgJjpob3ZlciB7XFxuICAgICAgQG1lZGlhIChob3ZlcjogaG92ZXIpIHtcXG4gICAgICAgIGNvbG9yOiB2YXIoLS1jb2xvci1ncmF5LTYwMCk7XFxuICAgICAgfVxcbiAgICB9XFxuICB9XFxuICAuaG92ZXJcXFxcOnRleHQtZ3JheS03MDAge1xcbiAgICAmOmhvdmVyIHtcXG4gICAgICBAbWVkaWEgKGhvdmVyOiBob3Zlcikge1xcbiAgICAgICAgY29sb3I6IHZhcigtLWNvbG9yLWdyYXktNzAwKTtcXG4gICAgICB9XFxuICAgIH1cXG4gIH1cXG4gIC5ob3ZlclxcXFw6dGV4dC1yZWQtNTAwIHtcXG4gICAgJjpob3ZlciB7XFxuICAgICAgQG1lZGlhIChob3ZlcjogaG92ZXIpIHtcXG4gICAgICAgIGNvbG9yOiB2YXIoLS1jb2xvci1yZWQtNTAwKTtcXG4gICAgICB9XFxuICAgIH1cXG4gIH1cXG4gIC5ob3ZlclxcXFw6b3BhY2l0eS0xMDAge1xcbiAgICAmOmhvdmVyIHtcXG4gICAgICBAbWVkaWEgKGhvdmVyOiBob3Zlcikge1xcbiAgICAgICAgb3BhY2l0eTogMTAwJTtcXG4gICAgICB9XFxuICAgIH1cXG4gIH1cXG4gIC5ob3ZlclxcXFw6c2hhZG93IHtcXG4gICAgJjpob3ZlciB7XFxuICAgICAgQG1lZGlhIChob3ZlcjogaG92ZXIpIHtcXG4gICAgICAgIC0tdHctc2hhZG93OiAwIDFweCAzcHggMCB2YXIoLS10dy1zaGFkb3ctY29sb3IsIHJnYigwIDAgMCAvIDAuMSkpLCAwIDFweCAycHggLTFweCB2YXIoLS10dy1zaGFkb3ctY29sb3IsIHJnYigwIDAgMCAvIDAuMSkpO1xcbiAgICAgICAgYm94LXNoYWRvdzogdmFyKC0tdHctaW5zZXQtc2hhZG93KSwgdmFyKC0tdHctaW5zZXQtcmluZy1zaGFkb3cpLCB2YXIoLS10dy1yaW5nLW9mZnNldC1zaGFkb3cpLCB2YXIoLS10dy1yaW5nLXNoYWRvdyksIHZhcigtLXR3LXNoYWRvdyk7XFxuICAgICAgfVxcbiAgICB9XFxuICB9XFxuICAuaG92ZXJcXFxcOnNoYWRvdy1tZCB7XFxuICAgICY6aG92ZXIge1xcbiAgICAgIEBtZWRpYSAoaG92ZXI6IGhvdmVyKSB7XFxuICAgICAgICAtLXR3LXNoYWRvdzogMCA0cHggNnB4IC0xcHggdmFyKC0tdHctc2hhZG93LWNvbG9yLCByZ2IoMCAwIDAgLyAwLjEpKSwgMCAycHggNHB4IC0ycHggdmFyKC0tdHctc2hhZG93LWNvbG9yLCByZ2IoMCAwIDAgLyAwLjEpKTtcXG4gICAgICAgIGJveC1zaGFkb3c6IHZhcigtLXR3LWluc2V0LXNoYWRvdyksIHZhcigtLXR3LWluc2V0LXJpbmctc2hhZG93KSwgdmFyKC0tdHctcmluZy1vZmZzZXQtc2hhZG93KSwgdmFyKC0tdHctcmluZy1zaGFkb3cpLCB2YXIoLS10dy1zaGFkb3cpO1xcbiAgICAgIH1cXG4gICAgfVxcbiAgfVxcbiAgLmhvdmVyXFxcXDpzaGFkb3ctc20ge1xcbiAgICAmOmhvdmVyIHtcXG4gICAgICBAbWVkaWEgKGhvdmVyOiBob3Zlcikge1xcbiAgICAgICAgLS10dy1zaGFkb3c6IDAgMXB4IDNweCAwIHZhcigtLXR3LXNoYWRvdy1jb2xvciwgcmdiKDAgMCAwIC8gMC4xKSksIDAgMXB4IDJweCAtMXB4IHZhcigtLXR3LXNoYWRvdy1jb2xvciwgcmdiKDAgMCAwIC8gMC4xKSk7XFxuICAgICAgICBib3gtc2hhZG93OiB2YXIoLS10dy1pbnNldC1zaGFkb3cpLCB2YXIoLS10dy1pbnNldC1yaW5nLXNoYWRvdyksIHZhcigtLXR3LXJpbmctb2Zmc2V0LXNoYWRvdyksIHZhcigtLXR3LXJpbmctc2hhZG93KSwgdmFyKC0tdHctc2hhZG93KTtcXG4gICAgICB9XFxuICAgIH1cXG4gIH1cXG4gIC5mb2N1c1xcXFw6YmctYmx1ZS01MCB7XFxuICAgICY6Zm9jdXMge1xcbiAgICAgIGJhY2tncm91bmQtY29sb3I6IHZhcigtLWNvbG9yLWJsdWUtNTApO1xcbiAgICB9XFxuICB9XFxuICAuZm9jdXNcXFxcOnJpbmctMSB7XFxuICAgICY6Zm9jdXMge1xcbiAgICAgIC0tdHctcmluZy1zaGFkb3c6IHZhcigtLXR3LXJpbmctaW5zZXQsKSAwIDAgMCBjYWxjKDFweCArIHZhcigtLXR3LXJpbmctb2Zmc2V0LXdpZHRoKSkgdmFyKC0tdHctcmluZy1jb2xvciwgY3VycmVudGNvbG9yKTtcXG4gICAgICBib3gtc2hhZG93OiB2YXIoLS10dy1pbnNldC1zaGFkb3cpLCB2YXIoLS10dy1pbnNldC1yaW5nLXNoYWRvdyksIHZhcigtLXR3LXJpbmctb2Zmc2V0LXNoYWRvdyksIHZhcigtLXR3LXJpbmctc2hhZG93KSwgdmFyKC0tdHctc2hhZG93KTtcXG4gICAgfVxcbiAgfVxcbiAgLmZvY3VzXFxcXDpyaW5nLTIge1xcbiAgICAmOmZvY3VzIHtcXG4gICAgICAtLXR3LXJpbmctc2hhZG93OiB2YXIoLS10dy1yaW5nLWluc2V0LCkgMCAwIDAgY2FsYygycHggKyB2YXIoLS10dy1yaW5nLW9mZnNldC13aWR0aCkpIHZhcigtLXR3LXJpbmctY29sb3IsIGN1cnJlbnRjb2xvcik7XFxuICAgICAgYm94LXNoYWRvdzogdmFyKC0tdHctaW5zZXQtc2hhZG93KSwgdmFyKC0tdHctaW5zZXQtcmluZy1zaGFkb3cpLCB2YXIoLS10dy1yaW5nLW9mZnNldC1zaGFkb3cpLCB2YXIoLS10dy1yaW5nLXNoYWRvdyksIHZhcigtLXR3LXNoYWRvdyk7XFxuICAgIH1cXG4gIH1cXG4gIC5mb2N1c1xcXFw6cmluZy1ibHVlLTMwMCB7XFxuICAgICY6Zm9jdXMge1xcbiAgICAgIC0tdHctcmluZy1jb2xvcjogdmFyKC0tY29sb3ItYmx1ZS0zMDApO1xcbiAgICB9XFxuICB9XFxuICAuZm9jdXNcXFxcOnJpbmctYmx1ZS01MDAge1xcbiAgICAmOmZvY3VzIHtcXG4gICAgICAtLXR3LXJpbmctY29sb3I6IHZhcigtLWNvbG9yLWJsdWUtNTAwKTtcXG4gICAgfVxcbiAgfVxcbiAgLmZvY3VzXFxcXDpyaW5nLXJlZC01MDAge1xcbiAgICAmOmZvY3VzIHtcXG4gICAgICAtLXR3LXJpbmctY29sb3I6IHZhcigtLWNvbG9yLXJlZC01MDApO1xcbiAgICB9XFxuICB9XFxuICAuZm9jdXNcXFxcOm91dGxpbmUtbm9uZSB7XFxuICAgICY6Zm9jdXMge1xcbiAgICAgIC0tdHctb3V0bGluZS1zdHlsZTogbm9uZTtcXG4gICAgICBvdXRsaW5lLXN0eWxlOiBub25lO1xcbiAgICB9XFxuICB9XFxuICAuc21cXFxcOmdyaWQtY29scy00IHtcXG4gICAgQG1lZGlhICh3aWR0aCA+PSA0MHJlbSkge1xcbiAgICAgIGdyaWQtdGVtcGxhdGUtY29sdW1uczogcmVwZWF0KDQsIG1pbm1heCgwLCAxZnIpKTtcXG4gICAgfVxcbiAgfVxcbiAgLnNtXFxcXDpwLTgge1xcbiAgICBAbWVkaWEgKHdpZHRoID49IDQwcmVtKSB7XFxuICAgICAgcGFkZGluZzogdmFyKC0tc3BhY2luZy04KTtcXG4gICAgfVxcbiAgfVxcbiAgLm1kXFxcXDpncmlkLWNvbHMtMyB7XFxuICAgIEBtZWRpYSAod2lkdGggPj0gNDhyZW0pIHtcXG4gICAgICBncmlkLXRlbXBsYXRlLWNvbHVtbnM6IHJlcGVhdCgzLCBtaW5tYXgoMCwgMWZyKSk7XFxuICAgIH1cXG4gIH1cXG4gIC5tZFxcXFw6Z3JpZC1jb2xzLTYge1xcbiAgICBAbWVkaWEgKHdpZHRoID49IDQ4cmVtKSB7XFxuICAgICAgZ3JpZC10ZW1wbGF0ZS1jb2x1bW5zOiByZXBlYXQoNiwgbWlubWF4KDAsIDFmcikpO1xcbiAgICB9XFxuICB9XFxuICAubGdcXFxcOmdyaWQtY29scy00IHtcXG4gICAgQG1lZGlhICh3aWR0aCA+PSA2NHJlbSkge1xcbiAgICAgIGdyaWQtdGVtcGxhdGUtY29sdW1uczogcmVwZWF0KDQsIG1pbm1heCgwLCAxZnIpKTtcXG4gICAgfVxcbiAgfVxcbiAgLmxnXFxcXDpncmlkLWNvbHMtOCB7XFxuICAgIEBtZWRpYSAod2lkdGggPj0gNjRyZW0pIHtcXG4gICAgICBncmlkLXRlbXBsYXRlLWNvbHVtbnM6IHJlcGVhdCg4LCBtaW5tYXgoMCwgMWZyKSk7XFxuICAgIH1cXG4gIH1cXG4gIC54bFxcXFw6Z3JpZC1jb2xzLTUge1xcbiAgICBAbWVkaWEgKHdpZHRoID49IDgwcmVtKSB7XFxuICAgICAgZ3JpZC10ZW1wbGF0ZS1jb2x1bW5zOiByZXBlYXQoNSwgbWlubWF4KDAsIDFmcikpO1xcbiAgICB9XFxuICB9XFxuICAueGxcXFxcOmdyaWQtY29scy0xMCB7XFxuICAgIEBtZWRpYSAod2lkdGggPj0gODByZW0pIHtcXG4gICAgICBncmlkLXRlbXBsYXRlLWNvbHVtbnM6IHJlcGVhdCgxMCwgbWlubWF4KDAsIDFmcikpO1xcbiAgICB9XFxuICB9XFxufVxcbmh0bWwge1xcbiAgZm9udC1mZWF0dXJlLXNldHRpbmdzOiBcXFwiY3YwMlxcXCIsIFxcXCJjdjAzXFxcIiwgXFxcImN2MDRcXFwiLCBcXFwiY3YxMVxcXCI7XFxuICBmb250LWZhbWlseTogdmFyKC0tZm9udC1mYW1pbHktc2Fucyk7XFxufVxcbmJvZHkge1xcbiAgYmFja2dyb3VuZC1jb2xvcjogdmFyKC0tY29sb3ItZ3JheS01MCk7XFxuICBjb2xvcjogdmFyKC0tY29sb3ItZ3JheS05MDApO1xcbiAgbWFyZ2luOiAwO1xcbiAgcGFkZGluZzogMDtcXG59XFxuQHV0aWxpdGllcyB7XFxuICAuc2xpZGVyLXRyYWNrIHtcXG4gICAgaGVpZ2h0OiA0cHg7XFxuICAgIGJhY2tncm91bmQ6IGxpbmVhci1ncmFkaWVudCg5MGRlZywgIzRBODZFOCwgI0E0QzVGNCk7XFxuICAgIGJvcmRlci1yYWRpdXM6IDJweDtcXG4gIH1cXG4gIC5zbGlkZXItdGh1bWIge1xcbiAgICB3aWR0aDogMTZweDtcXG4gICAgaGVpZ2h0OiAxNnB4O1xcbiAgICBiYWNrZ3JvdW5kOiAjMkE1REIwO1xcbiAgICBib3JkZXItcmFkaXVzOiA1MCU7XFxuICAgIGJvcmRlcjogMnB4IHNvbGlkIHdoaXRlO1xcbiAgICBib3gtc2hhZG93OiAwIDAgNXB4IHJnYmEoMCwgMCwgMCwgMC4yKTtcXG4gICAgY3Vyc29yOiBwb2ludGVyO1xcbiAgICB0cmFuc2l0aW9uOiB0cmFuc2Zvcm0gMC4xNXMgZWFzZTtcXG4gIH1cXG4gIC5zbGlkZXItdGh1bWI6aG92ZXIge1xcbiAgICB0cmFuc2Zvcm06IHNjYWxlKDEuMik7XFxuICB9XFxufVxcbkBwcm9wZXJ0eSAtLXR3LXRyYW5zbGF0ZS14IHtcXG4gIHN5bnRheDogXFxcIipcXFwiO1xcbiAgaW5oZXJpdHM6IGZhbHNlO1xcbiAgaW5pdGlhbC12YWx1ZTogMDtcXG59XFxuQHByb3BlcnR5IC0tdHctdHJhbnNsYXRlLXkge1xcbiAgc3ludGF4OiBcXFwiKlxcXCI7XFxuICBpbmhlcml0czogZmFsc2U7XFxuICBpbml0aWFsLXZhbHVlOiAwO1xcbn1cXG5AcHJvcGVydHkgLS10dy10cmFuc2xhdGUteiB7XFxuICBzeW50YXg6IFxcXCIqXFxcIjtcXG4gIGluaGVyaXRzOiBmYWxzZTtcXG4gIGluaXRpYWwtdmFsdWU6IDA7XFxufVxcbkBwcm9wZXJ0eSAtLXR3LXNjYWxlLXgge1xcbiAgc3ludGF4OiBcXFwiKlxcXCI7XFxuICBpbmhlcml0czogZmFsc2U7XFxuICBpbml0aWFsLXZhbHVlOiAxO1xcbn1cXG5AcHJvcGVydHkgLS10dy1zY2FsZS15IHtcXG4gIHN5bnRheDogXFxcIipcXFwiO1xcbiAgaW5oZXJpdHM6IGZhbHNlO1xcbiAgaW5pdGlhbC12YWx1ZTogMTtcXG59XFxuQHByb3BlcnR5IC0tdHctc2NhbGUteiB7XFxuICBzeW50YXg6IFxcXCIqXFxcIjtcXG4gIGluaGVyaXRzOiBmYWxzZTtcXG4gIGluaXRpYWwtdmFsdWU6IDE7XFxufVxcbkBwcm9wZXJ0eSAtLXR3LXJvdGF0ZS14IHtcXG4gIHN5bnRheDogXFxcIipcXFwiO1xcbiAgaW5oZXJpdHM6IGZhbHNlO1xcbn1cXG5AcHJvcGVydHkgLS10dy1yb3RhdGUteSB7XFxuICBzeW50YXg6IFxcXCIqXFxcIjtcXG4gIGluaGVyaXRzOiBmYWxzZTtcXG59XFxuQHByb3BlcnR5IC0tdHctcm90YXRlLXoge1xcbiAgc3ludGF4OiBcXFwiKlxcXCI7XFxuICBpbmhlcml0czogZmFsc2U7XFxufVxcbkBwcm9wZXJ0eSAtLXR3LXNrZXcteCB7XFxuICBzeW50YXg6IFxcXCIqXFxcIjtcXG4gIGluaGVyaXRzOiBmYWxzZTtcXG59XFxuQHByb3BlcnR5IC0tdHctc2tldy15IHtcXG4gIHN5bnRheDogXFxcIipcXFwiO1xcbiAgaW5oZXJpdHM6IGZhbHNlO1xcbn1cXG5AcHJvcGVydHkgLS10dy1zcGFjZS15LXJldmVyc2Uge1xcbiAgc3ludGF4OiBcXFwiKlxcXCI7XFxuICBpbmhlcml0czogZmFsc2U7XFxuICBpbml0aWFsLXZhbHVlOiAwO1xcbn1cXG5AcHJvcGVydHkgLS10dy1zcGFjZS14LXJldmVyc2Uge1xcbiAgc3ludGF4OiBcXFwiKlxcXCI7XFxuICBpbmhlcml0czogZmFsc2U7XFxuICBpbml0aWFsLXZhbHVlOiAwO1xcbn1cXG5AcHJvcGVydHkgLS10dy1ib3JkZXItc3R5bGUge1xcbiAgc3ludGF4OiBcXFwiKlxcXCI7XFxuICBpbmhlcml0czogZmFsc2U7XFxuICBpbml0aWFsLXZhbHVlOiBzb2xpZDtcXG59XFxuQHByb3BlcnR5IC0tdHctZ3JhZGllbnQtcG9zaXRpb24ge1xcbiAgc3ludGF4OiBcXFwiKlxcXCI7XFxuICBpbmhlcml0czogZmFsc2U7XFxufVxcbkBwcm9wZXJ0eSAtLXR3LWdyYWRpZW50LWZyb20ge1xcbiAgc3ludGF4OiBcXFwiPGNvbG9yPlxcXCI7XFxuICBpbmhlcml0czogZmFsc2U7XFxuICBpbml0aWFsLXZhbHVlOiAjMDAwMDtcXG59XFxuQHByb3BlcnR5IC0tdHctZ3JhZGllbnQtdmlhIHtcXG4gIHN5bnRheDogXFxcIjxjb2xvcj5cXFwiO1xcbiAgaW5oZXJpdHM6IGZhbHNlO1xcbiAgaW5pdGlhbC12YWx1ZTogIzAwMDA7XFxufVxcbkBwcm9wZXJ0eSAtLXR3LWdyYWRpZW50LXRvIHtcXG4gIHN5bnRheDogXFxcIjxjb2xvcj5cXFwiO1xcbiAgaW5oZXJpdHM6IGZhbHNlO1xcbiAgaW5pdGlhbC12YWx1ZTogIzAwMDA7XFxufVxcbkBwcm9wZXJ0eSAtLXR3LWdyYWRpZW50LXN0b3BzIHtcXG4gIHN5bnRheDogXFxcIipcXFwiO1xcbiAgaW5oZXJpdHM6IGZhbHNlO1xcbn1cXG5AcHJvcGVydHkgLS10dy1ncmFkaWVudC12aWEtc3RvcHMge1xcbiAgc3ludGF4OiBcXFwiKlxcXCI7XFxuICBpbmhlcml0czogZmFsc2U7XFxufVxcbkBwcm9wZXJ0eSAtLXR3LWdyYWRpZW50LWZyb20tcG9zaXRpb24ge1xcbiAgc3ludGF4OiBcXFwiPGxlbmd0aC1wZXJjZW50YWdlPlxcXCI7XFxuICBpbmhlcml0czogZmFsc2U7XFxuICBpbml0aWFsLXZhbHVlOiAwJTtcXG59XFxuQHByb3BlcnR5IC0tdHctZ3JhZGllbnQtdmlhLXBvc2l0aW9uIHtcXG4gIHN5bnRheDogXFxcIjxsZW5ndGgtcGVyY2VudGFnZT5cXFwiO1xcbiAgaW5oZXJpdHM6IGZhbHNlO1xcbiAgaW5pdGlhbC12YWx1ZTogNTAlO1xcbn1cXG5AcHJvcGVydHkgLS10dy1ncmFkaWVudC10by1wb3NpdGlvbiB7XFxuICBzeW50YXg6IFxcXCI8bGVuZ3RoLXBlcmNlbnRhZ2U+XFxcIjtcXG4gIGluaGVyaXRzOiBmYWxzZTtcXG4gIGluaXRpYWwtdmFsdWU6IDEwMCU7XFxufVxcbkBwcm9wZXJ0eSAtLXR3LWxlYWRpbmcge1xcbiAgc3ludGF4OiBcXFwiKlxcXCI7XFxuICBpbmhlcml0czogZmFsc2U7XFxufVxcbkBwcm9wZXJ0eSAtLXR3LWZvbnQtd2VpZ2h0IHtcXG4gIHN5bnRheDogXFxcIipcXFwiO1xcbiAgaW5oZXJpdHM6IGZhbHNlO1xcbn1cXG5AcHJvcGVydHkgLS10dy1vcmRpbmFsIHtcXG4gIHN5bnRheDogXFxcIipcXFwiO1xcbiAgaW5oZXJpdHM6IGZhbHNlO1xcbn1cXG5AcHJvcGVydHkgLS10dy1zbGFzaGVkLXplcm8ge1xcbiAgc3ludGF4OiBcXFwiKlxcXCI7XFxuICBpbmhlcml0czogZmFsc2U7XFxufVxcbkBwcm9wZXJ0eSAtLXR3LW51bWVyaWMtZmlndXJlIHtcXG4gIHN5bnRheDogXFxcIipcXFwiO1xcbiAgaW5oZXJpdHM6IGZhbHNlO1xcbn1cXG5AcHJvcGVydHkgLS10dy1udW1lcmljLXNwYWNpbmcge1xcbiAgc3ludGF4OiBcXFwiKlxcXCI7XFxuICBpbmhlcml0czogZmFsc2U7XFxufVxcbkBwcm9wZXJ0eSAtLXR3LW51bWVyaWMtZnJhY3Rpb24ge1xcbiAgc3ludGF4OiBcXFwiKlxcXCI7XFxuICBpbmhlcml0czogZmFsc2U7XFxufVxcbkBwcm9wZXJ0eSAtLXR3LXNoYWRvdyB7XFxuICBzeW50YXg6IFxcXCIqXFxcIjtcXG4gIGluaGVyaXRzOiBmYWxzZTtcXG4gIGluaXRpYWwtdmFsdWU6IDAgMCAjMDAwMDtcXG59XFxuQHByb3BlcnR5IC0tdHctc2hhZG93LWNvbG9yIHtcXG4gIHN5bnRheDogXFxcIipcXFwiO1xcbiAgaW5oZXJpdHM6IGZhbHNlO1xcbn1cXG5AcHJvcGVydHkgLS10dy1zaGFkb3ctYWxwaGEge1xcbiAgc3ludGF4OiBcXFwiPHBlcmNlbnRhZ2U+XFxcIjtcXG4gIGluaGVyaXRzOiBmYWxzZTtcXG4gIGluaXRpYWwtdmFsdWU6IDEwMCU7XFxufVxcbkBwcm9wZXJ0eSAtLXR3LWluc2V0LXNoYWRvdyB7XFxuICBzeW50YXg6IFxcXCIqXFxcIjtcXG4gIGluaGVyaXRzOiBmYWxzZTtcXG4gIGluaXRpYWwtdmFsdWU6IDAgMCAjMDAwMDtcXG59XFxuQHByb3BlcnR5IC0tdHctaW5zZXQtc2hhZG93LWNvbG9yIHtcXG4gIHN5bnRheDogXFxcIipcXFwiO1xcbiAgaW5oZXJpdHM6IGZhbHNlO1xcbn1cXG5AcHJvcGVydHkgLS10dy1pbnNldC1zaGFkb3ctYWxwaGEge1xcbiAgc3ludGF4OiBcXFwiPHBlcmNlbnRhZ2U+XFxcIjtcXG4gIGluaGVyaXRzOiBmYWxzZTtcXG4gIGluaXRpYWwtdmFsdWU6IDEwMCU7XFxufVxcbkBwcm9wZXJ0eSAtLXR3LXJpbmctY29sb3Ige1xcbiAgc3ludGF4OiBcXFwiKlxcXCI7XFxuICBpbmhlcml0czogZmFsc2U7XFxufVxcbkBwcm9wZXJ0eSAtLXR3LXJpbmctc2hhZG93IHtcXG4gIHN5bnRheDogXFxcIipcXFwiO1xcbiAgaW5oZXJpdHM6IGZhbHNlO1xcbiAgaW5pdGlhbC12YWx1ZTogMCAwICMwMDAwO1xcbn1cXG5AcHJvcGVydHkgLS10dy1pbnNldC1yaW5nLWNvbG9yIHtcXG4gIHN5bnRheDogXFxcIipcXFwiO1xcbiAgaW5oZXJpdHM6IGZhbHNlO1xcbn1cXG5AcHJvcGVydHkgLS10dy1pbnNldC1yaW5nLXNoYWRvdyB7XFxuICBzeW50YXg6IFxcXCIqXFxcIjtcXG4gIGluaGVyaXRzOiBmYWxzZTtcXG4gIGluaXRpYWwtdmFsdWU6IDAgMCAjMDAwMDtcXG59XFxuQHByb3BlcnR5IC0tdHctcmluZy1pbnNldCB7XFxuICBzeW50YXg6IFxcXCIqXFxcIjtcXG4gIGluaGVyaXRzOiBmYWxzZTtcXG59XFxuQHByb3BlcnR5IC0tdHctcmluZy1vZmZzZXQtd2lkdGgge1xcbiAgc3ludGF4OiBcXFwiPGxlbmd0aD5cXFwiO1xcbiAgaW5oZXJpdHM6IGZhbHNlO1xcbiAgaW5pdGlhbC12YWx1ZTogMHB4O1xcbn1cXG5AcHJvcGVydHkgLS10dy1yaW5nLW9mZnNldC1jb2xvciB7XFxuICBzeW50YXg6IFxcXCIqXFxcIjtcXG4gIGluaGVyaXRzOiBmYWxzZTtcXG4gIGluaXRpYWwtdmFsdWU6ICNmZmY7XFxufVxcbkBwcm9wZXJ0eSAtLXR3LXJpbmctb2Zmc2V0LXNoYWRvdyB7XFxuICBzeW50YXg6IFxcXCIqXFxcIjtcXG4gIGluaGVyaXRzOiBmYWxzZTtcXG4gIGluaXRpYWwtdmFsdWU6IDAgMCAjMDAwMDtcXG59XFxuQHByb3BlcnR5IC0tdHctb3V0bGluZS1zdHlsZSB7XFxuICBzeW50YXg6IFxcXCIqXFxcIjtcXG4gIGluaGVyaXRzOiBmYWxzZTtcXG4gIGluaXRpYWwtdmFsdWU6IHNvbGlkO1xcbn1cXG5AcHJvcGVydHkgLS10dy1ibHVyIHtcXG4gIHN5bnRheDogXFxcIipcXFwiO1xcbiAgaW5oZXJpdHM6IGZhbHNlO1xcbn1cXG5AcHJvcGVydHkgLS10dy1icmlnaHRuZXNzIHtcXG4gIHN5bnRheDogXFxcIipcXFwiO1xcbiAgaW5oZXJpdHM6IGZhbHNlO1xcbn1cXG5AcHJvcGVydHkgLS10dy1jb250cmFzdCB7XFxuICBzeW50YXg6IFxcXCIqXFxcIjtcXG4gIGluaGVyaXRzOiBmYWxzZTtcXG59XFxuQHByb3BlcnR5IC0tdHctZ3JheXNjYWxlIHtcXG4gIHN5bnRheDogXFxcIipcXFwiO1xcbiAgaW5oZXJpdHM6IGZhbHNlO1xcbn1cXG5AcHJvcGVydHkgLS10dy1odWUtcm90YXRlIHtcXG4gIHN5bnRheDogXFxcIipcXFwiO1xcbiAgaW5oZXJpdHM6IGZhbHNlO1xcbn1cXG5AcHJvcGVydHkgLS10dy1pbnZlcnQge1xcbiAgc3ludGF4OiBcXFwiKlxcXCI7XFxuICBpbmhlcml0czogZmFsc2U7XFxufVxcbkBwcm9wZXJ0eSAtLXR3LW9wYWNpdHkge1xcbiAgc3ludGF4OiBcXFwiKlxcXCI7XFxuICBpbmhlcml0czogZmFsc2U7XFxufVxcbkBwcm9wZXJ0eSAtLXR3LXNhdHVyYXRlIHtcXG4gIHN5bnRheDogXFxcIipcXFwiO1xcbiAgaW5oZXJpdHM6IGZhbHNlO1xcbn1cXG5AcHJvcGVydHkgLS10dy1zZXBpYSB7XFxuICBzeW50YXg6IFxcXCIqXFxcIjtcXG4gIGluaGVyaXRzOiBmYWxzZTtcXG59XFxuQHByb3BlcnR5IC0tdHctZHJvcC1zaGFkb3cge1xcbiAgc3ludGF4OiBcXFwiKlxcXCI7XFxuICBpbmhlcml0czogZmFsc2U7XFxufVxcbkBwcm9wZXJ0eSAtLXR3LWRyb3Atc2hhZG93LWNvbG9yIHtcXG4gIHN5bnRheDogXFxcIipcXFwiO1xcbiAgaW5oZXJpdHM6IGZhbHNlO1xcbn1cXG5AcHJvcGVydHkgLS10dy1kcm9wLXNoYWRvdy1hbHBoYSB7XFxuICBzeW50YXg6IFxcXCI8cGVyY2VudGFnZT5cXFwiO1xcbiAgaW5oZXJpdHM6IGZhbHNlO1xcbiAgaW5pdGlhbC12YWx1ZTogMTAwJTtcXG59XFxuQHByb3BlcnR5IC0tdHctZHJvcC1zaGFkb3ctc2l6ZSB7XFxuICBzeW50YXg6IFxcXCIqXFxcIjtcXG4gIGluaGVyaXRzOiBmYWxzZTtcXG59XFxuQHByb3BlcnR5IC0tdHctYmFja2Ryb3AtYmx1ciB7XFxuICBzeW50YXg6IFxcXCIqXFxcIjtcXG4gIGluaGVyaXRzOiBmYWxzZTtcXG59XFxuQHByb3BlcnR5IC0tdHctYmFja2Ryb3AtYnJpZ2h0bmVzcyB7XFxuICBzeW50YXg6IFxcXCIqXFxcIjtcXG4gIGluaGVyaXRzOiBmYWxzZTtcXG59XFxuQHByb3BlcnR5IC0tdHctYmFja2Ryb3AtY29udHJhc3Qge1xcbiAgc3ludGF4OiBcXFwiKlxcXCI7XFxuICBpbmhlcml0czogZmFsc2U7XFxufVxcbkBwcm9wZXJ0eSAtLXR3LWJhY2tkcm9wLWdyYXlzY2FsZSB7XFxuICBzeW50YXg6IFxcXCIqXFxcIjtcXG4gIGluaGVyaXRzOiBmYWxzZTtcXG59XFxuQHByb3BlcnR5IC0tdHctYmFja2Ryb3AtaHVlLXJvdGF0ZSB7XFxuICBzeW50YXg6IFxcXCIqXFxcIjtcXG4gIGluaGVyaXRzOiBmYWxzZTtcXG59XFxuQHByb3BlcnR5IC0tdHctYmFja2Ryb3AtaW52ZXJ0IHtcXG4gIHN5bnRheDogXFxcIipcXFwiO1xcbiAgaW5oZXJpdHM6IGZhbHNlO1xcbn1cXG5AcHJvcGVydHkgLS10dy1iYWNrZHJvcC1vcGFjaXR5IHtcXG4gIHN5bnRheDogXFxcIipcXFwiO1xcbiAgaW5oZXJpdHM6IGZhbHNlO1xcbn1cXG5AcHJvcGVydHkgLS10dy1iYWNrZHJvcC1zYXR1cmF0ZSB7XFxuICBzeW50YXg6IFxcXCIqXFxcIjtcXG4gIGluaGVyaXRzOiBmYWxzZTtcXG59XFxuQHByb3BlcnR5IC0tdHctYmFja2Ryb3Atc2VwaWEge1xcbiAgc3ludGF4OiBcXFwiKlxcXCI7XFxuICBpbmhlcml0czogZmFsc2U7XFxufVxcbkBwcm9wZXJ0eSAtLXR3LWR1cmF0aW9uIHtcXG4gIHN5bnRheDogXFxcIipcXFwiO1xcbiAgaW5oZXJpdHM6IGZhbHNlO1xcbn1cXG5AcHJvcGVydHkgLS10dy1lYXNlIHtcXG4gIHN5bnRheDogXFxcIipcXFwiO1xcbiAgaW5oZXJpdHM6IGZhbHNlO1xcbn1cXG5AbGF5ZXIgcHJvcGVydGllcyB7XFxuICBAc3VwcG9ydHMgKCgtd2Via2l0LWh5cGhlbnM6IG5vbmUpIGFuZCAobm90IChtYXJnaW4tdHJpbTogaW5saW5lKSkpIG9yICgoLW1vei1vcmllbnQ6IGlubGluZSkgYW5kIChub3QgKGNvbG9yOnJnYihmcm9tIHJlZCByIGcgYikpKSkge1xcbiAgICAqLCA6OmJlZm9yZSwgOjphZnRlciwgOjpiYWNrZHJvcCB7XFxuICAgICAgLS10dy10cmFuc2xhdGUteDogMDtcXG4gICAgICAtLXR3LXRyYW5zbGF0ZS15OiAwO1xcbiAgICAgIC0tdHctdHJhbnNsYXRlLXo6IDA7XFxuICAgICAgLS10dy1zY2FsZS14OiAxO1xcbiAgICAgIC0tdHctc2NhbGUteTogMTtcXG4gICAgICAtLXR3LXNjYWxlLXo6IDE7XFxuICAgICAgLS10dy1yb3RhdGUteDogaW5pdGlhbDtcXG4gICAgICAtLXR3LXJvdGF0ZS15OiBpbml0aWFsO1xcbiAgICAgIC0tdHctcm90YXRlLXo6IGluaXRpYWw7XFxuICAgICAgLS10dy1za2V3LXg6IGluaXRpYWw7XFxuICAgICAgLS10dy1za2V3LXk6IGluaXRpYWw7XFxuICAgICAgLS10dy1zcGFjZS15LXJldmVyc2U6IDA7XFxuICAgICAgLS10dy1zcGFjZS14LXJldmVyc2U6IDA7XFxuICAgICAgLS10dy1ib3JkZXItc3R5bGU6IHNvbGlkO1xcbiAgICAgIC0tdHctZ3JhZGllbnQtcG9zaXRpb246IGluaXRpYWw7XFxuICAgICAgLS10dy1ncmFkaWVudC1mcm9tOiAjMDAwMDtcXG4gICAgICAtLXR3LWdyYWRpZW50LXZpYTogIzAwMDA7XFxuICAgICAgLS10dy1ncmFkaWVudC10bzogIzAwMDA7XFxuICAgICAgLS10dy1ncmFkaWVudC1zdG9wczogaW5pdGlhbDtcXG4gICAgICAtLXR3LWdyYWRpZW50LXZpYS1zdG9wczogaW5pdGlhbDtcXG4gICAgICAtLXR3LWdyYWRpZW50LWZyb20tcG9zaXRpb246IDAlO1xcbiAgICAgIC0tdHctZ3JhZGllbnQtdmlhLXBvc2l0aW9uOiA1MCU7XFxuICAgICAgLS10dy1ncmFkaWVudC10by1wb3NpdGlvbjogMTAwJTtcXG4gICAgICAtLXR3LWxlYWRpbmc6IGluaXRpYWw7XFxuICAgICAgLS10dy1mb250LXdlaWdodDogaW5pdGlhbDtcXG4gICAgICAtLXR3LW9yZGluYWw6IGluaXRpYWw7XFxuICAgICAgLS10dy1zbGFzaGVkLXplcm86IGluaXRpYWw7XFxuICAgICAgLS10dy1udW1lcmljLWZpZ3VyZTogaW5pdGlhbDtcXG4gICAgICAtLXR3LW51bWVyaWMtc3BhY2luZzogaW5pdGlhbDtcXG4gICAgICAtLXR3LW51bWVyaWMtZnJhY3Rpb246IGluaXRpYWw7XFxuICAgICAgLS10dy1zaGFkb3c6IDAgMCAjMDAwMDtcXG4gICAgICAtLXR3LXNoYWRvdy1jb2xvcjogaW5pdGlhbDtcXG4gICAgICAtLXR3LXNoYWRvdy1hbHBoYTogMTAwJTtcXG4gICAgICAtLXR3LWluc2V0LXNoYWRvdzogMCAwICMwMDAwO1xcbiAgICAgIC0tdHctaW5zZXQtc2hhZG93LWNvbG9yOiBpbml0aWFsO1xcbiAgICAgIC0tdHctaW5zZXQtc2hhZG93LWFscGhhOiAxMDAlO1xcbiAgICAgIC0tdHctcmluZy1jb2xvcjogaW5pdGlhbDtcXG4gICAgICAtLXR3LXJpbmctc2hhZG93OiAwIDAgIzAwMDA7XFxuICAgICAgLS10dy1pbnNldC1yaW5nLWNvbG9yOiBpbml0aWFsO1xcbiAgICAgIC0tdHctaW5zZXQtcmluZy1zaGFkb3c6IDAgMCAjMDAwMDtcXG4gICAgICAtLXR3LXJpbmctaW5zZXQ6IGluaXRpYWw7XFxuICAgICAgLS10dy1yaW5nLW9mZnNldC13aWR0aDogMHB4O1xcbiAgICAgIC0tdHctcmluZy1vZmZzZXQtY29sb3I6ICNmZmY7XFxuICAgICAgLS10dy1yaW5nLW9mZnNldC1zaGFkb3c6IDAgMCAjMDAwMDtcXG4gICAgICAtLXR3LW91dGxpbmUtc3R5bGU6IHNvbGlkO1xcbiAgICAgIC0tdHctYmx1cjogaW5pdGlhbDtcXG4gICAgICAtLXR3LWJyaWdodG5lc3M6IGluaXRpYWw7XFxuICAgICAgLS10dy1jb250cmFzdDogaW5pdGlhbDtcXG4gICAgICAtLXR3LWdyYXlzY2FsZTogaW5pdGlhbDtcXG4gICAgICAtLXR3LWh1ZS1yb3RhdGU6IGluaXRpYWw7XFxuICAgICAgLS10dy1pbnZlcnQ6IGluaXRpYWw7XFxuICAgICAgLS10dy1vcGFjaXR5OiBpbml0aWFsO1xcbiAgICAgIC0tdHctc2F0dXJhdGU6IGluaXRpYWw7XFxuICAgICAgLS10dy1zZXBpYTogaW5pdGlhbDtcXG4gICAgICAtLXR3LWRyb3Atc2hhZG93OiBpbml0aWFsO1xcbiAgICAgIC0tdHctZHJvcC1zaGFkb3ctY29sb3I6IGluaXRpYWw7XFxuICAgICAgLS10dy1kcm9wLXNoYWRvdy1hbHBoYTogMTAwJTtcXG4gICAgICAtLXR3LWRyb3Atc2hhZG93LXNpemU6IGluaXRpYWw7XFxuICAgICAgLS10dy1iYWNrZHJvcC1ibHVyOiBpbml0aWFsO1xcbiAgICAgIC0tdHctYmFja2Ryb3AtYnJpZ2h0bmVzczogaW5pdGlhbDtcXG4gICAgICAtLXR3LWJhY2tkcm9wLWNvbnRyYXN0OiBpbml0aWFsO1xcbiAgICAgIC0tdHctYmFja2Ryb3AtZ3JheXNjYWxlOiBpbml0aWFsO1xcbiAgICAgIC0tdHctYmFja2Ryb3AtaHVlLXJvdGF0ZTogaW5pdGlhbDtcXG4gICAgICAtLXR3LWJhY2tkcm9wLWludmVydDogaW5pdGlhbDtcXG4gICAgICAtLXR3LWJhY2tkcm9wLW9wYWNpdHk6IGluaXRpYWw7XFxuICAgICAgLS10dy1iYWNrZHJvcC1zYXR1cmF0ZTogaW5pdGlhbDtcXG4gICAgICAtLXR3LWJhY2tkcm9wLXNlcGlhOiBpbml0aWFsO1xcbiAgICAgIC0tdHctZHVyYXRpb246IGluaXRpYWw7XFxuICAgICAgLS10dy1lYXNlOiBpbml0aWFsO1xcbiAgICB9XFxuICB9XFxufVxcblwiLCBcIlwiLHtcInZlcnNpb25cIjozLFwic291cmNlc1wiOltcIjxubyBzb3VyY2U+XCIsXCJ3ZWJwYWNrOi8vc3R5bGVzL2dsb2JhbHMuY3NzXCIsXCJ3ZWJwYWNrOi8vbm9kZV9tb2R1bGVzL3RhaWx3aW5kY3NzL2luZGV4LmNzc1wiXSxcIm5hbWVzXCI6W10sXCJtYXBwaW5nc1wiOlwiQUFBQSxrRUFBQTtBQ0FBLDhDQUErQztBQ3MzQjdDLGlCQUFtQjtBQXQzQnJCLHlDQUF5QztBQUV6QztFQUNFO0lBQ0U7NkRBRXlEO0lBRXpEOzhCQUUwQjtJQUUxQix3Q0FBd0M7SUFFeEMsMENBQTBDO0lBRzFDLDBDQUEwQztJQUMxQywwQ0FBMEM7SUFDMUMsMENBQTBDO0lBOEIxQyw4Q0FBOEM7SUFFOUMsNkNBQTZDO0lBQzdDLDZDQUE2QztJQUk3Qyw2Q0FBNkM7SUFpQjdDLDZDQUE2QztJQUU3Qyw0Q0FBNEM7SUFFNUMsNkNBQTZDO0lBRTdDLDZDQUE2QztJRDFFL0Msd0JBQXlCO0lBQ3pCLHlCQUEwQjtJQUMxQix5QkFBMEI7SUFDMUIseUJBQTBCO0lBQzFCLHlCQUEwQjtJQUMxQix5QkFBMEI7SUFDMUIseUJBQTBCO0lBQzFCLHlCQUEwQjtJQUMxQix5QkFBMEI7SUM4SnhCLDhDQUE4QztJQUU5Qyw0Q0FBNEM7SUQxSTlDLHdCQUF5QjtJQUN6Qix5QkFBMEI7SUFDMUIseUJBQTBCO0lBQzFCLHlCQUEwQjtJQUMxQix5QkFBMEI7SUFDMUIseUJBQTBCO0lBQzFCLHlCQUEwQjtJQUMxQix5QkFBMEI7SUFDMUIseUJBQTBCO0lBQzFCLHlCQUEwQjtJQ3dPeEIsbUJBQW1CO0lBQ25CLG1CQUFtQjtJQUVuQixrQkFBa0I7SUFZbEIscUJBQXFCO0lBR3JCLHNCQUFzQjtJQU90QixrQkFBa0I7SUFDbEIsc0NBQXNDO0lBQ3RDLG1CQUFtQjtJQUNuQiwwQ0FBMEM7SUFHMUMsbUJBQW1CO0lBQ25CLDBDQUEwQztJQUMxQyxrQkFBa0I7SUFD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QUFBO0VBQW5CO0lBQUE7TUFBQTtRQUFBLGFBQW1CO01BQUE7SUFBQTtFQUFBO0VBQW5CO0lBQUE7TUFBQTtRQUFBLGtCQUFtQjtRQUFuQixrQkFBbUI7UUFBbkIsa0JBQW1CO1FBQW5CLDBDQUFtQjtNQUFBO0lBQUE7RUFBQTtFQUFuQjtJQUFBO01BQUE7UUFBQSxtQ0FBbUI7TUFBQTtJQUFBO0VBQUE7RUFBbkI7SUFBQTtNQUFBO1FBQUEsbUNBQW1CO01BQUE7SUFBQTtFQUFBO0VBQW5CO0lBQUE7TUFBQTtRQUFBLHNDQUFtQjtNQUFBO0lBQUE7RUFBQTtFQUFuQjtJQUFBO01BQUE7UUFBQSx1Q0FBbUI7TUFBQTtJQUFBO0VBQUE7RUFBbkI7SUFBQTtNQUFBO1FBQUEsdUNBQW1CO01BQUE7SUFBQTtFQUFBO0VBQW5CO0lBQUE7TUFBQTtRQUFBLHVDQUFtQjtNQUFBO0lBQUE7RUFBQTtFQUFuQjtJQUFBO01BQUE7UUFBQSxzQ0FBbUI7TUFBQTtJQUFBO0VBQUE7RUFBbkI7SUFBQTtNQUFBO1FBQUEsdUNBQW1CO01BQUE7SUFBQTtFQUFBO0VBQW5CO0lBQUE7TUFBQTtRQUFBLHVDQUFtQjtNQUFBO0lBQUE7RUFBQTtFQUFuQjtJQUFBO01BQUE7UUFBQSx1Q0FBbUI7TUFBQTtJQUFBO0VBQUE7RUFBbkI7SUFBQTtNQUFBO1FBQUEsc0NBQW1CO01BQUE7SUFBQTtFQUFBO0VBQW5CO0lBQUE7TUFBQTtRQUFBLDRCQUFtQjtNQUFBO0lBQUE7RUFBQTtFQUFuQjtJQUFBO01BQUE7UUFBQSw0QkFBbUI7TUFBQTtJQUFBO0VBQUE7RUFBbkI7SUFBQTtNQUFBO1FBQUEsNEJBQW1CO01BQUE7SUFBQTtFQUFBO0VBQW5CO0lBQUE7TUFBQTtRQUFBLDRCQUFtQjtNQUFBO0lBQUE7RUFBQTtFQUFuQjtJQUFBO01BQUE7UUFBQSw0QkFBbUI7TUFBQTtJQUFBO0VBQUE7RUFBbkI7SUFBQTtNQUFBO1FBQUEsMkJBQW1CO01BQUE7SUFBQTtFQUFBO0VBQW5CO0lBQUE7TUFBQTtRQUFBLGFBQW1CO01BQUE7SUFBQTtFQUFB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O0VBQUEsV0FBbUI7RUFBbkIsZUFBbUI7QUFBQTtBQUFuQjtFQUFBLDZCQUFtQjtFQUFuQixlQUFtQjtFQUFuQixpQkFBbUI7QUFBQTtBQUFuQjtFQUFBLDZCQUFtQjtFQUFuQixlQUFtQjtFQUFuQixrQkFBbUI7QUFBQTtBQUFuQjtFQUFBLDZCQUFtQjtFQUFuQixlQUFtQjtFQUFuQixtQkFBbUI7QUFBQTtBQUFuQjtFQUFBLFdBQW1CO0VBQW5CLGVBQW1CO0FBQUE7QUFBbkI7RUFBQSxXQUFtQjtFQUFuQixlQUFtQjtBQUFBO0FBQW5CO0VBQUEsV0FBbUI7RUFBbkIsZUFBbUI7QUFBQTtBQUFuQjtFQUFBLFdBQW1CO0VBQW5CLGVBQW1CO0FBQUE7QUFBbkI7RUFBQSxXQUFtQjtFQUFuQixlQUFtQjtBQUFBO0FBQW5CO0VBQUEsV0FBbUI7RUFBbkIsZUFBbUI7QUFBQTtBQUFuQjtFQUFBLFdBQW1CO0VBQW5CLGVBQW1CO0FBQUE7QUFBbkI7RUFBQSxXQUFtQjtFQUFuQixlQUFtQjtFQUFuQix3QkFBbUI7QUFBQTtBQUFuQjtFQUFBLFdBQW1CO0VBQW5CLGVBQW1CO0FBQUE7QUFBbkI7RUFBQSxzQkFBbUI7RUFBbkIsZUFBbUI7RUFBbkIsbUJBQW1CO0FBQUE7QUFBbkI7RUFBQSxXQUFtQjtFQUFuQixlQUFtQjtFQUFuQix3QkFBbUI7QUFBQTtBQUFuQjtFQUFBLFdBQW1CO0VBQW5CLGVBQW1CO0FBQUE7QUFBbkI7RUFBQSxzQkFBbUI7RUFBbkIsZUFBbUI7RUFBbkIsbUJBQW1CO0FBQUE7QUFBbkI7RUFBQSxXQUFtQjtFQUFuQixlQUFtQjtBQUFBO0FBQW5CO0VBQUEsV0FBbUI7RUFBbkIsZUFBbUI7RUFBbkIsd0JBQW1CO0FBQUE7QUFBbkI7RUFBQSxXQUFtQjtFQUFuQixlQUFtQjtBQUFBO0FBQW5CO0VBQUEsV0FBbUI7RUFBbkIsZUFBbUI7RUFBbkIsd0JBQW1CO0FBQUE7QUFBbkI7RUFBQSxXQUFtQjtFQUFuQixlQUFtQjtBQUFBO0FBQW5CO0VBQUEsa0JBQW1CO0VBQW5CLGVBQW1CO0VBQW5CLGtCQUFtQjtBQUFBO0FBQW5CO0VBQUEsV0FBbUI7RUFBbkIsZUFBbUI7RUFBbkIsbUJBQW1CO0FBQUE7QUFBbkI7RUFBQSxXQUFtQjtFQUFuQixlQUFtQjtFQUFuQix3QkFBbUI7QUFBQTtBQUFuQjtFQUFBLFdBQW1CO0VBQW5CLGVBQW1CO0VBQW5CLG9CQUFtQjtBQUFBO0FBQW5CO0VBQUEsV0FBbUI7RUFBbkIsZUFBbUI7QUFBQTtBQUFuQjtFQUFBLFdBQW1CO0VBQW5CLGVBQW1CO0FBQUE7QUFBbkI7RUFBQSxXQUFtQjtFQUFuQixlQUFtQjtBQUFBO0FBQW5CO0VBQUEsV0FBbUI7RUFBbkIsZUFBbUI7QUFBQTtBQUFuQjtFQUFBLFdBQW1CO0VBQW5CLGVBQW1CO0FBQUE7QUFBbkI7RUFBQSxXQUFtQjtFQUFuQixlQUFtQjtBQUFBO0FBQW5CO0VBQUEsV0FBbUI7RUFBbkIsZUFBbUI7QUFBQTtBQUFuQjtFQUFBLFdBQW1CO0VBQW5CLGVBQW1CO0FBQUE7QUFBbkI7RUFBQSxXQUFtQjtFQUFuQixlQUFtQjtBQUFBO0FBQW5CO0VBQUEsV0FBbUI7RUFBbkIsZUFBbUI7QUFBQTtBQUFuQjtFQUFBLFdBQW1CO0VBQW5CLGVBQW1CO0FBQUE7QUFBbkI7RUFBQSxzQkFBbUI7RUFBbkIsZUFBbUI7RUFBbkIsbUJBQW1CO0FBQUE7QUFBbkI7RUFBQSxXQUFtQjtFQUFuQixlQUFtQjtBQUFBO0FBQW5CO0VBQUEsV0FBbUI7RUFBbkIsZUFBbUI7QUFBQTtBQUFuQjtFQUFBLFdBQW1CO0VBQW5CLGVBQW1CO0FBQUE7QUFBbkI7RUFBQSxXQUFtQjtFQUFuQixlQUFtQjtBQUFBO0FBQW5CO0VBQUEsV0FBbUI7RUFBbkIsZUFBbUI7QUFBQTtBQUFuQjtFQUFBLFdBQW1CO0VBQW5CLGVBQW1CO0FBQUE7QUFBbkI7RUFBQSxXQUFtQjtFQUFuQixlQUFtQjtBQUFBO0FBQW5CO0VBQUEsV0FBbUI7RUFBbkIsZUFBbUI7QUFBQTtBQUFuQjtFQUFBLFdBQW1CO0VBQW5CLGVBQW1CO0FBQUE7QUFBbkI7RUFBQSxXQUFtQjtFQUFuQixlQUFtQjtBQUFBO0FBQW5CO0VBQUEsV0FBbUI7RUFBbkIsZUFBbUI7QUFBQTtBQUFuQjtFQUFBLFdBQW1CO0VBQW5CLGVBQW1CO0FBQUE7QUFBbkI7RUFBQTtJQUFBO01BQUEsbUJBQW1CO01BQW5CLG1CQUFtQjtNQUFuQixtQkFBbUI7TUFBbkIsZUFBbUI7TUFBbkIsZUFBbUI7TUFBbkIsZUFBbUI7TUFBbkIsc0JBQW1CO01BQW5CLHNCQUFtQjtNQUFuQixzQkFBbUI7TUFBbkIsb0JBQW1CO01BQW5CLG9CQUFtQjtNQUFuQix1QkFBbUI7TUFBbkIsdUJBQW1CO01BQW5CLHdCQUFtQjtNQUFuQiwrQkFBbUI7TUFBbkIseUJBQW1CO01BQW5CLHdCQUFtQjtNQUFuQix1QkFBbUI7TUFBbkIsNEJBQW1CO01BQW5CLGdDQUFtQjtNQUFuQiwrQkFBbUI7TUFBbkIsK0JBQW1CO01BQW5CLCtCQUFtQjtNQUFuQixxQkFBbUI7TUFBbkIseUJBQW1CO01BQW5CLHFCQUFtQjtNQUFuQiwwQkFBbUI7TUFBbkIsNEJBQW1CO01BQW5CLDZCQUFtQjtNQUFuQiw4QkFBbUI7TUFBbkIsc0JBQW1CO01BQW5CLDBCQUFtQjtNQUFuQix1QkFBbUI7TUFBbkIsNEJBQW1CO01BQW5CLGdDQUFtQjtNQUFuQiw2QkFBbUI7TUFBbkIsd0JBQW1CO01BQW5CLDJCQUFtQjtNQUFuQiw4QkFBbUI7TUFBbkIsaUNBQW1CO01BQW5CLHdCQUFtQjtNQUFuQiwyQkFBbUI7TUFBbkIsNEJBQW1CO01BQW5CLGtDQUFtQjtNQUFuQix5QkFBbUI7TUFBbkIsa0JBQW1CO01BQW5CLHdCQUFtQjtNQUFuQixzQkFBbUI7TUFBbkIsdUJBQW1CO01BQW5CLHdCQUFtQjtNQUFuQixvQkFBbUI7TUFBbkIscUJBQW1CO01BQW5CLHNCQUFtQjtNQUFuQixtQkFBbUI7TUFBbkIseUJBQW1CO01BQW5CLCtCQUFtQjtNQUFuQiw0QkFBbUI7TUFBbkIsOEJBQW1CO01BQW5CLDJCQUFtQjtNQUFuQixpQ0FBbUI7TUFBbkIsK0JBQW1CO01BQW5CLGdDQUFtQjtNQUFuQixpQ0FBbUI7TUFBbkIsNkJBQW1CO01BQW5CLDhCQUFtQjtNQUFuQiwrQkFBbUI7TUFBbkIsNEJBQW1CO01BQW5CLHNCQUFtQjtNQUFuQixrQkFBbUI7SUFBQTtFQUFBO0FBQUFcIixcInNvdXJjZXNDb250ZW50XCI6W251bGwsXCJAaW1wb3J0IHVybCgnaHR0cHM6Ly9yc21zLm1lL2ludGVyL2ludGVyLmNzcycpO1xcbkBpbXBvcnQgXFxcInRhaWx3aW5kY3NzXFxcIjtcXG5cXG5AdGhlbWUge1xcbiAgLyog0KbQstC10YLQsCDRgtC10LzRiyAqL1xcbiAgLS1jb2xvci1ibHVlLTUwOiAjRUFGMkZDO1xcbiAgLS1jb2xvci1ibHVlLTEwMDogI0Q1RTVGODtcXG4gIC0tY29sb3ItYmx1ZS0yMDA6ICNBNEM1RjQ7XFxuICAtLWNvbG9yLWJsdWUtMzAwOiAjN0VBQkVGO1xcbiAgLS1jb2xvci1ibHVlLTQwMDogIzVGOTZFQjtcXG4gIC0tY29sb3ItYmx1ZS01MDA6ICM0QTg2RTg7XFxuICAtLWNvbG9yLWJsdWUtNjAwOiAjMkE1REIwO1xcbiAgLS1jb2xvci1ibHVlLTcwMDogIzFFNDQ4NDtcXG4gIC0tY29sb3ItYmx1ZS04MDA6ICMxNjMzNjY7XFxuICAtLWNvbG9yLWJsdWUtOTAwOiAjMEUyMjQ0O1xcbiAgXFxuICAvKiDQodCy0LXRgtC70L4t0LPQvtC70YPQsdCw0Y8g0YbQstC10YLQvtCy0LDRjyDRgdGF0LXQvNCwICovXFxuICAtLWNvbG9yLXByaW1hcnktNTA6ICNFQUYyRkM7XFxuICAtLWNvbG9yLXByaW1hcnktMTAwOiAjRDVFNUY4O1xcbiAgLS1jb2xvci1wcmltYXJ5LTIwMDogI0E0QzVGNDtcXG4gIC0tY29sb3ItcHJpbWFyeS0zMDA6ICM3RUFCRUY7XFxuICAtLWNvbG9yLXByaW1hcnktNDAwOiAjNUY5NkVCO1xcbiAgLS1jb2xvci1wcmltYXJ5LTUwMDogIzRBODZFODtcXG4gIC0tY29sb3ItcHJpbWFyeS02MDA6ICMyQTVEQjA7XFxuICAtLWNvbG9yLXByaW1hcnktNzAwOiAjMUU0NDg0O1xcbiAgLS1jb2xvci1wcmltYXJ5LTgwMDogIzE2MzM2NjtcXG4gIC0tY29sb3ItcHJpbWFyeS05MDA6ICMwRTIyNDQ7XFxuICBcXG4gIC8qINCk0YPQvdC60YbQuNC+0L3QsNC70YzQvdGL0LUg0YbQstC10YLQsCAqL1xcbiAgLS1jb2xvci1zdWNjZXNzOiAjNjZCMkZGO1xcbiAgLS1jb2xvci13YXJuaW5nOiAjRkZCMzY2O1xcbiAgLS1jb2xvci1lcnJvcjogI0ZGNjY2NjtcXG4gIC0tY29sb3ItaW5mbzogIzhDRDlGRjtcXG4gIFxcbiAgLyog0J3QtdC50YLRgNCw0LvRjNC90YvQtSDRhtCy0LXRgtCwICovXFxuICAtLWNvbG9yLWdyYXktNTA6ICNGNUY4RkE7XFxuICAtLWNvbG9yLWdyYXktMTAwOiAjRTlFRkY1O1xcbiAgLS1jb2xvci1ncmF5LTIwMDogI0Q5RTJFQztcXG4gIC0tY29sb3ItZ3JheS0zMDA6ICNDQkQ1RTA7XFxuICAtLWNvbG9yLWdyYXktNDAwOiAjOUZCM0M4O1xcbiAgLS1jb2xvci1ncmF5LTUwMDogIzdEOEZBRjtcXG4gIC0tY29sb3ItZ3JheS02MDA6ICM1NDY3ODU7XFxuICAtLWNvbG9yLWdyYXktNzAwOiAjM0Q0QjY2O1xcbiAgLS1jb2xvci1ncmF5LTgwMDogIzJEMzc0ODtcXG4gIC0tY29sb3ItZ3JheS05MDA6ICMxQTIwMkM7XFxuICBcXG4gIC8qINCg0LDQt9C80LXRgNGLINC4INC+0YLRgdGC0YPQv9GLICovXFxuICAtLXNwYWNpbmctMDogMHB4O1xcbiAgLS1zcGFjaW5nLTE6IDAuMjVyZW07XFxuICAtLXNwYWNpbmctMjogMC41cmVtO1xcbiAgLS1zcGFjaW5nLTM6IDAuNzVyZW07XFxuICAtLXNwYWNpbmctNDogMXJlbTtcXG4gIC0tc3BhY2luZy01OiAxLjI1cmVtO1xcbiAgLS1zcGFjaW5nLTY6IDEuNXJlbTtcXG4gIC0tc3BhY2luZy04OiAycmVtO1xcbiAgLS1zcGFjaW5nLTEwOiAyLjVyZW07XFxuICAtLXNwYWNpbmctMTI6IDNyZW07XFxuICAtLXNwYWNpbmctMTY6IDRyZW07XFxuICAtLXNwYWNpbmctMjA6IDVyZW07XFxuICBcXG4gIC8qINCU0YDRg9Cz0LjQtSDQv9C10YDQtdC80LXQvdC90YvQtSAqL1xcbiAgLS1mb250LWZhbWlseS1zYW5zOiAnSW50ZXIgdmFyJywgc2Fucy1zZXJpZjtcXG4gIC0tc2hhZG93LXNvZnQ6IDAgMnB4IDE1cHggLTNweCByZ2JhKDc0LCAxMzQsIDIzMiwgMC4xNSksIDAgMTBweCAyMHB4IC0ycHggcmdiYSg3NCwgMTM0LCAyMzIsIDAuMDgpO1xcbiAgLS1zaGFkb3ctY2FyZDogMCA1cHggMTVweCByZ2JhKDc0LCAxMzQsIDIzMiwgMC4wOCk7XFxuICAtLXNoYWRvdy1kcm9wZG93bjogMCAxMHB4IDI1cHggLTVweCByZ2JhKDc0LCAxMzQsIDIzMiwgMC4xNSk7XFxuICAtLWJvcmRlci1yYWRpdXMtc206IDAuMjVyZW07XFxuICAtLWJvcmRlci1yYWRpdXMtbWQ6IDAuNXJlbTtcXG4gIC0tYm9yZGVyLXJhZGl1cy1sZzogMC43NXJlbTtcXG4gIC0tYm9yZGVyLXJhZGl1cy14bDogMXJlbTtcXG4gIC0tYm9yZGVyLXJhZGl1cy0yeGw6IDEuNXJlbTtcXG4gIC0tYm9yZGVyLXJhZGl1cy00eGw6IDJyZW07XFxuICBcXG4gIC8qINCf0LXRgNC10YXQvtC00Ysg0Lgg0LDQvdC40LzQsNGG0LjQuCAqL1xcbiAgLS10cmFuc2l0aW9uLWZhc3Q6IDAuMTVzIGVhc2U7XFxuICAtLXRyYW5zaXRpb24tbm9ybWFsOiAwLjNzIGVhc2U7XFxuICAtLXRyYW5zaXRpb24tc2xvdzogMC41cyBlYXNlO1xcbn1cXG5cXG4vKiDQkdCw0LfQvtCy0YvQtSDRgdGC0LjQu9C4ICovXFxuaHRtbCB7XFxuICBmb250LWZlYXR1cmUtc2V0dGluZ3M6IFxcXCJjdjAyXFxcIiwgXFxcImN2MDNcXFwiLCBcXFwiY3YwNFxcXCIsIFxcXCJjdjExXFxcIjtcXG4gIGZvbnQtZmFtaWx5OiB2YXIoLS1mb250LWZhbWlseS1zYW5zKTtcXG59XFxuXFxuYm9keSB7XFxuICBiYWNrZ3JvdW5kLWNvbG9yOiB2YXIoLS1jb2xvci1ncmF5LTUwKTtcXG4gIGNvbG9yOiB2YXIoLS1jb2xvci1ncmF5LTkwMCk7XFxuICBtYXJnaW46IDA7XFxuICBwYWRkaW5nOiAwO1xcbn1cXG5cXG4vKiDQlNC+0LHQsNCy0LvRj9C10Lwg0L3QtdGB0LrQvtC70YzQutC+INCz0LvQvtCx0LDQu9GM0L3Ri9GFINGD0YLQuNC70LjRgtCw0YDQvdGL0YUg0LrQu9Cw0YHRgdC+0LIgKi9cXG5AdXRpbGl0aWVzIHtcXG4gIC8qINCh0LvQsNC50LTQtdGAINGBINC60LDRgdGC0L7QvNC90YvQvNC4INGB0YLQuNC70Y/QvNC4ICovXFxuICAuc2xpZGVyLXRyYWNrIHtcXG4gICAgaGVpZ2h0OiA0cHg7XFxuICAgIGJhY2tncm91bmQ6IGxpbmVhci1ncmFkaWVudCg5MGRlZywgIzRBODZFOCwgI0E0QzVGNCk7XFxuICAgIGJvcmRlci1yYWRpdXM6IDJweDtcXG4gIH1cXG5cXG4gIC5zbGlkZXItdGh1bWIge1xcbiAgICB3aWR0aDogMTZweDtcXG4gICAgaGVpZ2h0OiAxNnB4O1xcbiAgICBiYWNrZ3JvdW5kOiAjMkE1REIwO1xcbiAgICBib3JkZXItcmFkaXVzOiA1MCU7XFxuICAgIGJvcmRlcjogMnB4IHNvbGlkIHdoaXRlO1xcbiAgICBib3gtc2hhZG93OiAwIDAgNXB4IHJnYmEoMCwgMCwgMCwgMC4yKTtcXG4gICAgY3Vyc29yOiBwb2ludGVyO1xcbiAgICB0cmFuc2l0aW9uOiB0cmFuc2Zvcm0gMC4xNXMgZWFzZTtcXG4gIH1cXG5cXG4gIC5zbGlkZXItdGh1bWI6aG92ZXIge1xcbiAgICB0cmFuc2Zvcm06IHNjYWxlKDEuMik7XFxuICB9XFxufVxcblwiLFwiQGxheWVyIHRoZW1lLCBiYXNlLCBjb21wb25lbnRzLCB1dGlsaXRpZXM7XFxuXFxuQGxheWVyIHRoZW1lIHtcXG4gIEB0aGVtZSBkZWZhdWx0IHtcXG4gICAgLS1mb250LXNhbnM6XFxuICAgICAgdWktc2Fucy1zZXJpZiwgc3lzdGVtLXVpLCBzYW5zLXNlcmlmLCBcXFwiQXBwbGUgQ29sb3IgRW1vamlcXFwiLFxcbiAgICAgIFxcXCJTZWdvZSBVSSBFbW9qaVxcXCIsIFxcXCJTZWdvZSBVSSBTeW1ib2xcXFwiLCBcXFwiTm90byBDb2xvciBFbW9qaVxcXCI7XFxuICAgIC0tZm9udC1zZXJpZjogdWktc2VyaWYsIEdlb3JnaWEsIENhbWJyaWEsIFxcXCJUaW1lcyBOZXcgUm9tYW5cXFwiLCBUaW1lcywgc2VyaWY7XFxuICAgIC0tZm9udC1tb25vOlxcbiAgICAgIHVpLW1vbm9zcGFjZSwgU0ZNb25vLVJlZ3VsYXIsIE1lbmxvLCBNb25hY28sIENvbnNvbGFzLCBcXFwiTGliZXJhdGlvbiBNb25vXFxcIixcXG4gICAgICBcXFwiQ291cmllciBOZXdcXFwiLCBtb25vc3BhY2U7XFxuXFxuICAgIC0tY29sb3ItcmVkLTUwOiBva2xjaCg5Ny4xJSAwLjAxMyAxNy4zOCk7XFxuICAgIC0tY29sb3ItcmVkLTEwMDogb2tsY2goOTMuNiUgMC4wMzIgMTcuNzE3KTtcXG4gICAgLS1jb2xvci1yZWQtMjAwOiBva2xjaCg4OC41JSAwLjA2MiAxOC4zMzQpO1xcbiAgICAtLWNvbG9yLXJlZC0zMDA6IG9rbGNoKDgwLjglIDAuMTE0IDE5LjU3MSk7XFxuICAgIC0tY29sb3ItcmVkLTQwMDogb2tsY2goNzAuNCUgMC4xOTEgMjIuMjE2KTtcXG4gICAgLS1jb2xvci1yZWQtNTAwOiBva2xjaCg2My43JSAwLjIzNyAyNS4zMzEpO1xcbiAgICAtLWNvbG9yLXJlZC02MDA6IG9rbGNoKDU3LjclIDAuMjQ1IDI3LjMyNSk7XFxuICAgIC0tY29sb3ItcmVkLTcwMDogb2tsY2goNTAuNSUgMC4yMTMgMjcuNTE4KTtcXG4gICAgLS1jb2xvci1yZWQtODAwOiBva2xjaCg0NC40JSAwLjE3NyAyNi44OTkpO1xcbiAgICAtLWNvbG9yLXJlZC05MDA6IG9rbGNoKDM5LjYlIDAuMTQxIDI1LjcyMyk7XFxuICAgIC0tY29sb3ItcmVkLTk1MDogb2tsY2goMjUuOCUgMC4wOTIgMjYuMDQyKTtcXG5cXG4gICAgLS1jb2xvci1vcmFuZ2UtNTA6IG9rbGNoKDk4JSAwLjAxNiA3My42ODQpO1xcbiAgICAtLWNvbG9yLW9yYW5nZS0xMDA6IG9rbGNoKDk1LjQlIDAuMDM4IDc1LjE2NCk7XFxuICAgIC0tY29sb3Itb3JhbmdlLTIwMDogb2tsY2goOTAuMSUgMC4wNzYgNzAuNjk3KTtcXG4gICAgLS1jb2xvci1vcmFuZ2UtMzAwOiBva2xjaCg4My43JSAwLjEyOCA2Ni4yOSk7XFxuICAgIC0tY29sb3Itb3JhbmdlLTQwMDogb2tsY2goNzUlIDAuMTgzIDU1LjkzNCk7XFxuICAgIC0tY29sb3Itb3JhbmdlLTUwMDogb2tsY2goNzAuNSUgMC4yMTMgNDcuNjA0KTtcXG4gICAgLS1jb2xvci1vcmFuZ2UtNjAwOiBva2xjaCg2NC42JSAwLjIyMiA0MS4xMTYpO1xcbiAgICAtLWNvbG9yLW9yYW5nZS03MDA6IG9rbGNoKDU1LjMlIDAuMTk1IDM4LjQwMik7XFxuICAgIC0tY29sb3Itb3JhbmdlLTgwMDogb2tsY2goNDclIDAuMTU3IDM3LjMwNCk7XFxuICAgIC0tY29sb3Itb3JhbmdlLTkwMDogb2tsY2goNDAuOCUgMC4xMjMgMzguMTcyKTtcXG4gICAgLS1jb2xvci1vcmFuZ2UtOTUwOiBva2xjaCgyNi42JSAwLjA3OSAzNi4yNTkpO1xcblxcbiAgICAtLWNvbG9yLWFtYmVyLTUwOiBva2xjaCg5OC43JSAwLjAyMiA5NS4yNzcpO1xcbiAgICAtLWNvbG9yLWFtYmVyLTEwMDogb2tsY2goOTYuMiUgMC4wNTkgOTUuNjE3KTtcXG4gICAgLS1jb2xvci1hbWJlci0yMDA6IG9rbGNoKDkyLjQlIDAuMTIgOTUuNzQ2KTtcXG4gICAgLS1jb2xvci1hbWJlci0zMDA6IG9rbGNoKDg3LjklIDAuMTY5IDkxLjYwNSk7XFxuICAgIC0tY29sb3ItYW1iZXItNDAwOiBva2xjaCg4Mi44JSAwLjE4OSA4NC40MjkpO1xcbiAgICAtLWNvbG9yLWFtYmVyLTUwMDogb2tsY2goNzYuOSUgMC4xODggNzAuMDgpO1xcbiAgICAtLWNvbG9yLWFtYmVyLTYwMDogb2tsY2goNjYuNiUgMC4xNzkgNTguMzE4KTtcXG4gICAgLS1jb2xvci1hbWJlci03MDA6IG9rbGNoKDU1LjUlIDAuMTYzIDQ4Ljk5OCk7XFxuICAgIC0tY29sb3ItYW1iZXItODAwOiBva2xjaCg0Ny4zJSAwLjEzNyA0Ni4yMDEpO1xcbiAgICAtLWNvbG9yLWFtYmVyLTkwMDogb2tsY2goNDEuNCUgMC4xMTIgNDUuOTA0KTtcXG4gICAgLS1jb2xvci1hbWJlci05NTA6IG9rbGNoKDI3LjklIDAuMDc3IDQ1LjYzNSk7XFxuXFxuICAgIC0tY29sb3IteWVsbG93LTUwOiBva2xjaCg5OC43JSAwLjAyNiAxMDIuMjEyKTtcXG4gICAgLS1jb2xvci15ZWxsb3ctMTAwOiBva2xjaCg5Ny4zJSAwLjA3MSAxMDMuMTkzKTtcXG4gICAgLS1jb2xvci15ZWxsb3ctMjAwOiBva2xjaCg5NC41JSAwLjEyOSAxMDEuNTQpO1xcbiAgICAtLWNvbG9yLXllbGxvdy0zMDA6IG9rbGNoKDkwLjUlIDAuMTgyIDk4LjExMSk7XFxuICAgIC0tY29sb3IteWVsbG93LTQwMDogb2tsY2goODUuMiUgMC4xOTkgOTEuOTM2KTtcXG4gICAgLS1jb2xvci15ZWxsb3ctNTAwOiBva2xjaCg3OS41JSAwLjE4NCA4Ni4wNDcpO1xcbiAgICAtLWNvbG9yLXllbGxvdy02MDA6IG9rbGNoKDY4LjElIDAuMTYyIDc1LjgzNCk7XFxuICAgIC0tY29sb3IteWVsbG93LTcwMDogb2tsY2goNTUuNCUgMC4xMzUgNjYuNDQyKTtcXG4gICAgLS1jb2xvci15ZWxsb3ctODAwOiBva2xjaCg0Ny42JSAwLjExNCA2MS45MDcpO1xcbiAgICAtLWNvbG9yLXllbGxvdy05MDA6IG9rbGNoKDQyLjElIDAuMDk1IDU3LjcwOCk7XFxuICAgIC0tY29sb3IteWVsbG93LTk1MDogb2tsY2goMjguNiUgMC4wNjYgNTMuODEzKTtcXG5cXG4gICAgLS1jb2xvci1saW1lLTUwOiBva2xjaCg5OC42JSAwLjAzMSAxMjAuNzU3KTtcXG4gICAgLS1jb2xvci1saW1lLTEwMDogb2tsY2goOTYuNyUgMC4wNjcgMTIyLjMyOCk7XFxuICAgIC0tY29sb3ItbGltZS0yMDA6IG9rbGNoKDkzLjglIDAuMTI3IDEyNC4zMjEpO1xcbiAgICAtLWNvbG9yLWxpbWUtMzAwOiBva2xjaCg4OS43JSAwLjE5NiAxMjYuNjY1KTtcXG4gICAgLS1jb2xvci1saW1lLTQwMDogb2tsY2goODQuMSUgMC4yMzggMTI4Ljg1KTtcXG4gICAgLS1jb2xvci1saW1lLTUwMDogb2tsY2goNzYuOCUgMC4yMzMgMTMwLjg1KTtcXG4gICAgLS1jb2xvci1saW1lLTYwMDogb2tsY2goNjQuOCUgMC4yIDEzMS42ODQpO1xcbiAgICAtLWNvbG9yLWxpbWUtNzAwOiBva2xjaCg1My4yJSAwLjE1NyAxMzEuNTg5KTtcXG4gICAgLS1jb2xvci1saW1lLTgwMDogb2tsY2goNDUuMyUgMC4xMjQgMTMwLjkzMyk7XFxuICAgIC0tY29sb3ItbGltZS05MDA6IG9rbGNoKDQwLjUlIDAuMTAxIDEzMS4wNjMpO1xcbiAgICAtLWNvbG9yLWxpbWUtOTUwOiBva2xjaCgyNy40JSAwLjA3MiAxMzIuMTA5KTtcXG5cXG4gICAgLS1jb2xvci1ncmVlbi01MDogb2tsY2goOTguMiUgMC4wMTggMTU1LjgyNik7XFxuICAgIC0tY29sb3ItZ3JlZW4tMTAwOiBva2xjaCg5Ni4yJSAwLjA0NCAxNTYuNzQzKTtcXG4gICAgLS1jb2xvci1ncmVlbi0yMDA6IG9rbGNoKDkyLjUlIDAuMDg0IDE1NS45OTUpO1xcbiAgICAtLWNvbG9yLWdyZWVuLTMwMDogb2tsY2goODcuMSUgMC4xNSAxNTQuNDQ5KTtcXG4gICAgLS1jb2xvci1ncmVlbi00MDA6IG9rbGNoKDc5LjIlIDAuMjA5IDE1MS43MTEpO1xcbiAgICAtLWNvbG9yLWdyZWVuLTUwMDogb2tsY2goNzIuMyUgMC4yMTkgMTQ5LjU3OSk7XFxuICAgIC0tY29sb3ItZ3JlZW4tNjAwOiBva2xjaCg2Mi43JSAwLjE5NCAxNDkuMjE0KTtcXG4gICAgLS1jb2xvci1ncmVlbi03MDA6IG9rbGNoKDUyLjclIDAuMTU0IDE1MC4wNjkpO1xcbiAgICAtLWNvbG9yLWdyZWVuLTgwMDogb2tsY2goNDQuOCUgMC4xMTkgMTUxLjMyOCk7XFxuICAgIC0tY29sb3ItZ3JlZW4tOTAwOiBva2xjaCgzOS4zJSAwLjA5NSAxNTIuNTM1KTtcXG4gICAgLS1jb2xvci1ncmVlbi05NTA6IG9rbGNoKDI2LjYlIDAuMDY1IDE1Mi45MzQpO1xcblxcbiAgICAtLWNvbG9yLWVtZXJhbGQtNTA6IG9rbGNoKDk3LjklIDAuMDIxIDE2Ni4xMTMpO1xcbiAgICAtLWNvbG9yLWVtZXJhbGQtMTAwOiBva2xjaCg5NSUgMC4wNTIgMTYzLjA1MSk7XFxuICAgIC0tY29sb3ItZW1lcmFsZC0yMDA6IG9rbGNoKDkwLjUlIDAuMDkzIDE2NC4xNSk7XFxuICAgIC0tY29sb3ItZW1lcmFsZC0zMDA6IG9rbGNoKDg0LjUlIDAuMTQzIDE2NC45NzgpO1xcbiAgICAtLWNvbG9yLWVtZXJhbGQtNDAwOiBva2xjaCg3Ni41JSAwLjE3NyAxNjMuMjIzKTtcXG4gICAgLS1jb2xvci1lbWVyYWxkLTUwMDogb2tsY2goNjkuNiUgMC4xNyAxNjIuNDgpO1xcbiAgICAtLWNvbG9yLWVtZXJhbGQtNjAwOiBva2xjaCg1OS42JSAwLjE0NSAxNjMuMjI1KTtcXG4gICAgLS1jb2xvci1lbWVyYWxkLTcwMDogb2tsY2goNTAuOCUgMC4xMTggMTY1LjYxMik7XFxuICAgIC0tY29sb3ItZW1lcmFsZC04MDA6IG9rbGNoKDQzLjIlIDAuMDk1IDE2Ni45MTMpO1xcbiAgICAtLWNvbG9yLWVtZXJhbGQtOTAwOiBva2xjaCgzNy44JSAwLjA3NyAxNjguOTQpO1xcbiAgICAtLWNvbG9yLWVtZXJhbGQtOTUwOiBva2xjaCgyNi4yJSAwLjA1MSAxNzIuNTUyKTtcXG5cXG4gICAgLS1jb2xvci10ZWFsLTUwOiBva2xjaCg5OC40JSAwLjAxNCAxODAuNzIpO1xcbiAgICAtLWNvbG9yLXRlYWwtMTAwOiBva2xjaCg5NS4zJSAwLjA1MSAxODAuODAxKTtcXG4gICAgLS1jb2xvci10ZWFsLTIwMDogb2tsY2goOTElIDAuMDk2IDE4MC40MjYpO1xcbiAgICAtLWNvbG9yLXRlYWwtMzAwOiBva2xjaCg4NS41JSAwLjEzOCAxODEuMDcxKTtcXG4gICAgLS1jb2xvci10ZWFsLTQwMDogb2tsY2goNzcuNyUgMC4xNTIgMTgxLjkxMik7XFxuICAgIC0tY29sb3ItdGVhbC01MDA6IG9rbGNoKDcwLjQlIDAuMTQgMTgyLjUwMyk7XFxuICAgIC0tY29sb3ItdGVhbC02MDA6IG9rbGNoKDYwJSAwLjExOCAxODQuNzA0KTtcXG4gICAgLS1jb2xvci10ZWFsLTcwMDogb2tsY2goNTEuMSUgMC4wOTYgMTg2LjM5MSk7XFxuICAgIC0tY29sb3ItdGVhbC04MDA6IG9rbGNoKDQzLjclIDAuMDc4IDE4OC4yMTYpO1xcbiAgICAtLWNvbG9yLXRlYWwtOTAwOiBva2xjaCgzOC42JSAwLjA2MyAxODguNDE2KTtcXG4gICAgLS1jb2xvci10ZWFsLTk1MDogb2tsY2goMjcuNyUgMC4wNDYgMTkyLjUyNCk7XFxuXFxuICAgIC0tY29sb3ItY3lhbi01MDogb2tsY2goOTguNCUgMC4wMTkgMjAwLjg3Myk7XFxuICAgIC0tY29sb3ItY3lhbi0xMDA6IG9rbGNoKDk1LjYlIDAuMDQ1IDIwMy4zODgpO1xcbiAgICAtLWNvbG9yLWN5YW4tMjAwOiBva2xjaCg5MS43JSAwLjA4IDIwNS4wNDEpO1xcbiAgICAtLWNvbG9yLWN5YW4tMzAwOiBva2xjaCg4Ni41JSAwLjEyNyAyMDcuMDc4KTtcXG4gICAgLS1jb2xvci1jeWFuLTQwMDogb2tsY2goNzguOSUgMC4xNTQgMjExLjUzKTtcXG4gICAgLS1jb2xvci1jeWFuLTUwMDogb2tsY2goNzEuNSUgMC4xNDMgMjE1LjIyMSk7XFxuICAgIC0tY29sb3ItY3lhbi02MDA6IG9rbGNoKDYwLjklIDAuMTI2IDIyMS43MjMpO1xcbiAgICAtLWNvbG9yLWN5YW4tNzAwOiBva2xjaCg1MiUgMC4xMDUgMjIzLjEyOCk7XFxuICAgIC0tY29sb3ItY3lhbi04MDA6IG9rbGNoKDQ1JSAwLjA4NSAyMjQuMjgzKTtcXG4gICAgLS1jb2xvci1jeWFuLTkwMDogb2tsY2goMzkuOCUgMC4wNyAyMjcuMzkyKTtcXG4gICAgLS1jb2xvci1jeWFuLTk1MDogb2tsY2goMzAuMiUgMC4wNTYgMjI5LjY5NSk7XFxuXFxuICAgIC0tY29sb3Itc2t5LTUwOiBva2xjaCg5Ny43JSAwLjAxMyAyMzYuNjIpO1xcbiAgICAtLWNvbG9yLXNreS0xMDA6IG9rbGNoKDk1LjElIDAuMDI2IDIzNi44MjQpO1xcbiAgICAtLWNvbG9yLXNreS0yMDA6IG9rbGNoKDkwLjElIDAuMDU4IDIzMC45MDIpO1xcbiAgICAtLWNvbG9yLXNreS0zMDA6IG9rbGNoKDgyLjglIDAuMTExIDIzMC4zMTgpO1xcbiAgICAtLWNvbG9yLXNreS00MDA6IG9rbGNoKDc0LjYlIDAuMTYgMjMyLjY2MSk7XFxuICAgIC0tY29sb3Itc2t5LTUwMDogb2tsY2goNjguNSUgMC4xNjkgMjM3LjMyMyk7XFxuICAgIC0tY29sb3Itc2t5LTYwMDogb2tsY2goNTguOCUgMC4xNTggMjQxLjk2Nik7XFxuICAgIC0tY29sb3Itc2t5LTcwMDogb2tsY2goNTAlIDAuMTM0IDI0Mi43NDkpO1xcbiAgICAtLWNvbG9yLXNreS04MDA6IG9rbGNoKDQ0LjMlIDAuMTEgMjQwLjc5KTtcXG4gICAgLS1jb2xvci1za3ktOTAwOiBva2xjaCgzOS4xJSAwLjA5IDI0MC44NzYpO1xcbiAgICAtLWNvbG9yLXNreS05NTA6IG9rbGNoKDI5LjMlIDAuMDY2IDI0My4xNTcpO1xcblxcbiAgICAtLWNvbG9yLWJsdWUtNTA6IG9rbGNoKDk3JSAwLjAxNCAyNTQuNjA0KTtcXG4gICAgLS1jb2xvci1ibHVlLTEwMDogb2tsY2goOTMuMiUgMC4wMzIgMjU1LjU4NSk7XFxuICAgIC0tY29sb3ItYmx1ZS0yMDA6IG9rbGNoKDg4LjIlIDAuMDU5IDI1NC4xMjgpO1xcbiAgICAtLWNvbG9yLWJsdWUtMzAwOiBva2xjaCg4MC45JSAwLjEwNSAyNTEuODEzKTtcXG4gICAgLS1jb2xvci1ibHVlLTQwMDogb2tsY2goNzAuNyUgMC4xNjUgMjU0LjYyNCk7XFxuICAgIC0tY29sb3ItYmx1ZS01MDA6IG9rbGNoKDYyLjMlIDAuMjE0IDI1OS44MTUpO1xcbiAgICAtLWNvbG9yLWJsdWUtNjAwOiBva2xjaCg1NC42JSAwLjI0NSAyNjIuODgxKTtcXG4gICAgLS1jb2xvci1ibHVlLTcwMDogb2tsY2goNDguOCUgMC4yNDMgMjY0LjM3Nik7XFxuICAgIC0tY29sb3ItYmx1ZS04MDA6IG9rbGNoKDQyLjQlIDAuMTk5IDI2NS42MzgpO1xcbiAgICAtLWNvbG9yLWJsdWUtOTAwOiBva2xjaCgzNy45JSAwLjE0NiAyNjUuNTIyKTtcXG4gICAgLS1jb2xvci1ibHVlLTk1MDogb2tsY2goMjguMiUgMC4wOTEgMjY3LjkzNSk7XFxuXFxuICAgIC0tY29sb3ItaW5kaWdvLTUwOiBva2xjaCg5Ni4yJSAwLjAxOCAyNzIuMzE0KTtcXG4gICAgLS1jb2xvci1pbmRpZ28tMTAwOiBva2xjaCg5MyUgMC4wMzQgMjcyLjc4OCk7XFxuICAgIC0tY29sb3ItaW5kaWdvLTIwMDogb2tsY2goODclIDAuMDY1IDI3NC4wMzkpO1xcbiAgICAtLWNvbG9yLWluZGlnby0zMDA6IG9rbGNoKDc4LjUlIDAuMTE1IDI3NC43MTMpO1xcbiAgICAtLWNvbG9yLWluZGlnby00MDA6IG9rbGNoKDY3LjMlIDAuMTgyIDI3Ni45MzUpO1xcbiAgICAtLWNvbG9yLWluZGlnby01MDA6IG9rbGNoKDU4LjUlIDAuMjMzIDI3Ny4xMTcpO1xcbiAgICAtLWNvbG9yLWluZGlnby02MDA6IG9rbGNoKDUxLjElIDAuMjYyIDI3Ni45NjYpO1xcbiAgICAtLWNvbG9yLWluZGlnby03MDA6IG9rbGNoKDQ1LjclIDAuMjQgMjc3LjAyMyk7XFxuICAgIC0tY29sb3ItaW5kaWdvLTgwMDogb2tsY2goMzkuOCUgMC4xOTUgMjc3LjM2Nik7XFxuICAgIC0tY29sb3ItaW5kaWdvLTkwMDogb2tsY2goMzUuOSUgMC4xNDQgMjc4LjY5Nyk7XFxuICAgIC0tY29sb3ItaW5kaWdvLTk1MDogb2tsY2goMjUuNyUgMC4wOSAyODEuMjg4KTtcXG5cXG4gICAgLS1jb2xvci12aW9sZXQtNTA6IG9rbGNoKDk2LjklIDAuMDE2IDI5My43NTYpO1xcbiAgICAtLWNvbG9yLXZpb2xldC0xMDA6IG9rbGNoKDk0LjMlIDAuMDI5IDI5NC41ODgpO1xcbiAgICAtLWNvbG9yLXZpb2xldC0yMDA6IG9rbGNoKDg5LjQlIDAuMDU3IDI5My4yODMpO1xcbiAgICAtLWNvbG9yLXZpb2xldC0zMDA6IG9rbGNoKDgxLjElIDAuMTExIDI5My41NzEpO1xcbiAgICAtLWNvbG9yLXZpb2xldC00MDA6IG9rbGNoKDcwLjIlIDAuMTgzIDI5My41NDEpO1xcbiAgICAtLWNvbG9yLXZpb2xldC01MDA6IG9rbGNoKDYwLjYlIDAuMjUgMjkyLjcxNyk7XFxuICAgIC0tY29sb3ItdmlvbGV0LTYwMDogb2tsY2goNTQuMSUgMC4yODEgMjkzLjAwOSk7XFxuICAgIC0tY29sb3ItdmlvbGV0LTcwMDogb2tsY2goNDkuMSUgMC4yNyAyOTIuNTgxKTtcXG4gICAgLS1jb2xvci12aW9sZXQtODAwOiBva2xjaCg0My4yJSAwLjIzMiAyOTIuNzU5KTtcXG4gICAgLS1jb2xvci12aW9sZXQtOTAwOiBva2xjaCgzOCUgMC4xODkgMjkzLjc0NSk7XFxuICAgIC0tY29sb3ItdmlvbGV0LTk1MDogb2tsY2goMjguMyUgMC4xNDEgMjkxLjA4OSk7XFxuXFxuICAgIC0tY29sb3ItcHVycGxlLTUwOiBva2xjaCg5Ny43JSAwLjAxNCAzMDguMjk5KTtcXG4gICAgLS1jb2xvci1wdXJwbGUtMTAwOiBva2xjaCg5NC42JSAwLjAzMyAzMDcuMTc0KTtcXG4gICAgLS1jb2xvci1wdXJwbGUtMjAwOiBva2xjaCg5MC4yJSAwLjA2MyAzMDYuNzAzKTtcXG4gICAgLS1jb2xvci1wdXJwbGUtMzAwOiBva2xjaCg4Mi43JSAwLjExOSAzMDYuMzgzKTtcXG4gICAgLS1jb2xvci1wdXJwbGUtNDAwOiBva2xjaCg3MS40JSAwLjIwMyAzMDUuNTA0KTtcXG4gICAgLS1jb2xvci1wdXJwbGUtNTAwOiBva2xjaCg2Mi43JSAwLjI2NSAzMDMuOSk7XFxuICAgIC0tY29sb3ItcHVycGxlLTYwMDogb2tsY2goNTUuOCUgMC4yODggMzAyLjMyMSk7XFxuICAgIC0tY29sb3ItcHVycGxlLTcwMDogb2tsY2goNDkuNiUgMC4yNjUgMzAxLjkyNCk7XFxuICAgIC0tY29sb3ItcHVycGxlLTgwMDogb2tsY2goNDMuOCUgMC4yMTggMzAzLjcyNCk7XFxuICAgIC0tY29sb3ItcHVycGxlLTkwMDogb2tsY2goMzguMSUgMC4xNzYgMzA0Ljk4Nyk7XFxuICAgIC0tY29sb3ItcHVycGxlLTk1MDogb2tsY2goMjkuMSUgMC4xNDkgMzAyLjcxNyk7XFxuXFxuICAgIC0tY29sb3ItZnVjaHNpYS01MDogb2tsY2goOTcuNyUgMC4wMTcgMzIwLjA1OCk7XFxuICAgIC0tY29sb3ItZnVjaHNpYS0xMDA6IG9rbGNoKDk1LjIlIDAuMDM3IDMxOC44NTIpO1xcbiAgICAtLWNvbG9yLWZ1Y2hzaWEtMjAwOiBva2xjaCg5MC4zJSAwLjA3NiAzMTkuNjIpO1xcbiAgICAtLWNvbG9yLWZ1Y2hzaWEtMzAwOiBva2xjaCg4My4zJSAwLjE0NSAzMjEuNDM0KTtcXG4gICAgLS1jb2xvci1mdWNoc2lhLTQwMDogb2tsY2goNzQlIDAuMjM4IDMyMi4xNik7XFxuICAgIC0tY29sb3ItZnVjaHNpYS01MDA6IG9rbGNoKDY2LjclIDAuMjk1IDMyMi4xNSk7XFxuICAgIC0tY29sb3ItZnVjaHNpYS02MDA6IG9rbGNoKDU5LjElIDAuMjkzIDMyMi44OTYpO1xcbiAgICAtLWNvbG9yLWZ1Y2hzaWEtNzAwOiBva2xjaCg1MS44JSAwLjI1MyAzMjMuOTQ5KTtcXG4gICAgLS1jb2xvci1mdWNoc2lhLTgwMDogb2tsY2goNDUuMiUgMC4yMTEgMzI0LjU5MSk7XFxuICAgIC0tY29sb3ItZnVjaHNpYS05MDA6IG9rbGNoKDQwLjElIDAuMTcgMzI1LjYxMik7XFxuICAgIC0tY29sb3ItZnVjaHNpYS05NTA6IG9rbGNoKDI5LjMlIDAuMTM2IDMyNS42NjEpO1xcblxcbiAgICAtLWNvbG9yLXBpbmstNTA6IG9rbGNoKDk3LjElIDAuMDE0IDM0My4xOTgpO1xcbiAgICAtLWNvbG9yLXBpbmstMTAwOiBva2xjaCg5NC44JSAwLjAyOCAzNDIuMjU4KTtcXG4gICAgLS1jb2xvci1waW5rLTIwMDogb2tsY2goODkuOSUgMC4wNjEgMzQzLjIzMSk7XFxuICAgIC0tY29sb3ItcGluay0zMDA6IG9rbGNoKDgyLjMlIDAuMTIgMzQ2LjAxOCk7XFxuICAgIC0tY29sb3ItcGluay00MDA6IG9rbGNoKDcxLjglIDAuMjAyIDM0OS43NjEpO1xcbiAgICAtLWNvbG9yLXBpbmstNTAwOiBva2xjaCg2NS42JSAwLjI0MSAzNTQuMzA4KTtcXG4gICAgLS1jb2xvci1waW5rLTYwMDogb2tsY2goNTkuMiUgMC4yNDkgMC41ODQpO1xcbiAgICAtLWNvbG9yLXBpbmstNzAwOiBva2xjaCg1Mi41JSAwLjIyMyAzLjk1OCk7XFxuICAgIC0tY29sb3ItcGluay04MDA6IG9rbGNoKDQ1LjklIDAuMTg3IDMuODE1KTtcXG4gICAgLS1jb2xvci1waW5rLTkwMDogb2tsY2goNDAuOCUgMC4xNTMgMi40MzIpO1xcbiAgICAtLWNvbG9yLXBpbmstOTUwOiBva2xjaCgyOC40JSAwLjEwOSAzLjkwNyk7XFxuXFxuICAgIC0tY29sb3Itcm9zZS01MDogb2tsY2goOTYuOSUgMC4wMTUgMTIuNDIyKTtcXG4gICAgLS1jb2xvci1yb3NlLTEwMDogb2tsY2goOTQuMSUgMC4wMyAxMi41OCk7XFxuICAgIC0tY29sb3Itcm9zZS0yMDA6IG9rbGNoKDg5LjIlIDAuMDU4IDEwLjAwMSk7XFxuICAgIC0tY29sb3Itcm9zZS0zMDA6IG9rbGNoKDgxJSAwLjExNyAxMS42MzgpO1xcbiAgICAtLWNvbG9yLXJvc2UtNDAwOiBva2xjaCg3MS4yJSAwLjE5NCAxMy40MjgpO1xcbiAgICAtLWNvbG9yLXJvc2UtNTAwOiBva2xjaCg2NC41JSAwLjI0NiAxNi40MzkpO1xcbiAgICAtLWNvbG9yLXJvc2UtNjAwOiBva2xjaCg1OC42JSAwLjI1MyAxNy41ODUpO1xcbiAgICAtLWNvbG9yLXJvc2UtNzAwOiBva2xjaCg1MS40JSAwLjIyMiAxNi45MzUpO1xcbiAgICAtLWNvbG9yLXJvc2UtODAwOiBva2xjaCg0NS41JSAwLjE4OCAxMy42OTcpO1xcbiAgICAtLWNvbG9yLXJvc2UtOTAwOiBva2xjaCg0MSUgMC4xNTkgMTAuMjcyKTtcXG4gICAgLS1jb2xvci1yb3NlLTk1MDogb2tsY2goMjcuMSUgMC4xMDUgMTIuMDk0KTtcXG5cXG4gICAgLS1jb2xvci1zbGF0ZS01MDogb2tsY2goOTguNCUgMC4wMDMgMjQ3Ljg1OCk7XFxuICAgIC0tY29sb3Itc2xhdGUtMTAwOiBva2xjaCg5Ni44JSAwLjAwNyAyNDcuODk2KTtcXG4gICAgLS1jb2xvci1zbGF0ZS0yMDA6IG9rbGNoKDkyLjklIDAuMDEzIDI1NS41MDgpO1xcbiAgICAtLWNvbG9yLXNsYXRlLTMwMDogb2tsY2goODYuOSUgMC4wMjIgMjUyLjg5NCk7XFxuICAgIC0tY29sb3Itc2xhdGUtNDAwOiBva2xjaCg3MC40JSAwLjA0IDI1Ni43ODgpO1xcbiAgICAtLWNvbG9yLXNsYXRlLTUwMDogb2tsY2goNTUuNCUgMC4wNDYgMjU3LjQxNyk7XFxuICAgIC0tY29sb3Itc2xhdGUtNjAwOiBva2xjaCg0NC42JSAwLjA0MyAyNTcuMjgxKTtcXG4gICAgLS1jb2xvci1zbGF0ZS03MDA6IG9rbGNoKDM3LjIlIDAuMDQ0IDI1Ny4yODcpO1xcbiAgICAtLWNvbG9yLXNsYXRlLTgwMDogb2tsY2goMjcuOSUgMC4wNDEgMjYwLjAzMSk7XFxuICAgIC0tY29sb3Itc2xhdGUtOTAwOiBva2xjaCgyMC44JSAwLjA0MiAyNjUuNzU1KTtcXG4gICAgLS1jb2xvci1zbGF0ZS05NTA6IG9rbGNoKDEyLjklIDAuMDQyIDI2NC42OTUpO1xcblxcbiAgICAtLWNvbG9yLWdyYXktNTA6IG9rbGNoKDk4LjUlIDAuMDAyIDI0Ny44MzkpO1xcbiAgICAtLWNvbG9yLWdyYXktMTAwOiBva2xjaCg5Ni43JSAwLjAwMyAyNjQuNTQyKTtcXG4gICAgLS1jb2xvci1ncmF5LTIwMDogb2tsY2goOTIuOCUgMC4wMDYgMjY0LjUzMSk7XFxuICAgIC0tY29sb3ItZ3JheS0zMDA6IG9rbGNoKDg3LjIlIDAuMDEgMjU4LjMzOCk7XFxuICAgIC0tY29sb3ItZ3JheS00MDA6IG9rbGNoKDcwLjclIDAuMDIyIDI2MS4zMjUpO1xcbiAgICAtLWNvbG9yLWdyYXktNTAwOiBva2xjaCg1NS4xJSAwLjAyNyAyNjQuMzY0KTtcXG4gICAgLS1jb2xvci1ncmF5LTYwMDogb2tsY2goNDQuNiUgMC4wMyAyNTYuODAyKTtcXG4gICAgLS1jb2xvci1ncmF5LTcwMDogb2tsY2goMzcuMyUgMC4wMzQgMjU5LjczMyk7XFxuICAgIC0tY29sb3ItZ3JheS04MDA6IG9rbGNoKDI3LjglIDAuMDMzIDI1Ni44NDgpO1xcbiAgICAtLWNvbG9yLWdyYXktOTAwOiBva2xjaCgyMSUgMC4wMzQgMjY0LjY2NSk7XFxuICAgIC0tY29sb3ItZ3JheS05NTA6IG9rbGNoKDEzJSAwLjAyOCAyNjEuNjkyKTtcXG5cXG4gICAgLS1jb2xvci16aW5jLTUwOiBva2xjaCg5OC41JSAwIDApO1xcbiAgICAtLWNvbG9yLXppbmMtMTAwOiBva2xjaCg5Ni43JSAwLjAwMSAyODYuMzc1KTtcXG4gICAgLS1jb2xvci16aW5jLTIwMDogb2tsY2goOTIlIDAuMDA0IDI4Ni4zMik7XFxuICAgIC0tY29sb3ItemluYy0zMDA6IG9rbGNoKDg3LjElIDAuMDA2IDI4Ni4yODYpO1xcbiAgICAtLWNvbG9yLXppbmMtNDAwOiBva2xjaCg3MC41JSAwLjAxNSAyODYuMDY3KTtcXG4gICAgLS1jb2xvci16aW5jLTUwMDogb2tsY2goNTUuMiUgMC4wMTYgMjg1LjkzOCk7XFxuICAgIC0tY29sb3ItemluYy02MDA6IG9rbGNoKDQ0LjIlIDAuMDE3IDI4NS43ODYpO1xcbiAgICAtLWNvbG9yLXppbmMtNzAwOiBva2xjaCgzNyUgMC4wMTMgMjg1LjgwNSk7XFxuICAgIC0tY29sb3ItemluYy04MDA6IG9rbGNoKDI3LjQlIDAuMDA2IDI4Ni4wMzMpO1xcbiAgICAtLWNvbG9yLXppbmMtOTAwOiBva2xjaCgyMSUgMC4wMDYgMjg1Ljg4NSk7XFxuICAgIC0tY29sb3ItemluYy05NTA6IG9rbGNoKDE0LjElIDAuMDA1IDI4NS44MjMpO1xcblxcbiAgICAtLWNvbG9yLW5ldXRyYWwtNTA6IG9rbGNoKDk4LjUlIDAgMCk7XFxuICAgIC0tY29sb3ItbmV1dHJhbC0xMDA6IG9rbGNoKDk3JSAwIDApO1xcbiAgICAtLWNvbG9yLW5ldXRyYWwtMjAwOiBva2xjaCg5Mi4yJSAwIDApO1xcbiAgICAtLWNvbG9yLW5ldXRyYWwtMzAwOiBva2xjaCg4NyUgMCAwKTtcXG4gICAgLS1jb2xvci1uZXV0cmFsLTQwMDogb2tsY2goNzAuOCUgMCAwKTtcXG4gICAgLS1jb2xvci1uZXV0cmFsLTUwMDogb2tsY2goNTUuNiUgMCAwKTtcXG4gICAgLS1jb2xvci1uZXV0cmFsLTYwMDogb2tsY2goNDMuOSUgMCAwKTtcXG4gICAgLS1jb2xvci1uZXV0cmFsLTcwMDogb2tsY2goMzcuMSUgMCAwKTtcXG4gICAgLS1jb2xvci1uZXV0cmFsLTgwMDogb2tsY2goMjYuOSUgMCAwKTtcXG4gICAgLS1jb2xvci1uZXV0cmFsLTkwMDogb2tsY2goMjAuNSUgMCAwKTtcXG4gICAgLS1jb2xvci1uZXV0cmFsLTk1MDogb2tsY2goMTQuNSUgMCAwKTtcXG5cXG4gICAgLS1jb2xvci1zdG9uZS01MDogb2tsY2goOTguNSUgMC4wMDEgMTA2LjQyMyk7XFxuICAgIC0tY29sb3Itc3RvbmUtMTAwOiBva2xjaCg5NyUgMC4wMDEgMTA2LjQyNCk7XFxuICAgIC0tY29sb3Itc3RvbmUtMjAwOiBva2xjaCg5Mi4zJSAwLjAwMyA0OC43MTcpO1xcbiAgICAtLWNvbG9yLXN0b25lLTMwMDogb2tsY2goODYuOSUgMC4wMDUgNTYuMzY2KTtcXG4gICAgLS1jb2xvci1zdG9uZS00MDA6IG9rbGNoKDcwLjklIDAuMDEgNTYuMjU5KTtcXG4gICAgLS1jb2xvci1zdG9uZS01MDA6IG9rbGNoKDU1LjMlIDAuMDEzIDU4LjA3MSk7XFxuICAgIC0tY29sb3Itc3RvbmUtNjAwOiBva2xjaCg0NC40JSAwLjAxMSA3My42MzkpO1xcbiAgICAtLWNvbG9yLXN0b25lLTcwMDogb2tsY2goMzcuNCUgMC4wMSA2Ny41NTgpO1xcbiAgICAtLWNvbG9yLXN0b25lLTgwMDogb2tsY2goMjYuOCUgMC4wMDcgMzQuMjk4KTtcXG4gICAgLS1jb2xvci1zdG9uZS05MDA6IG9rbGNoKDIxLjYlIDAuMDA2IDU2LjA0Myk7XFxuICAgIC0tY29sb3Itc3RvbmUtOTUwOiBva2xjaCgxNC43JSAwLjAwNCA0OS4yNSk7XFxuXFxuICAgIC0tY29sb3ItYmxhY2s6ICMwMDA7XFxuICAgIC0tY29sb3Itd2hpdGU6ICNmZmY7XFxuXFxuICAgIC0tc3BhY2luZzogMC4yNXJlbTtcXG5cXG4gICAgLS1icmVha3BvaW50LXNtOiA0MHJlbTtcXG4gICAgLS1icmVha3BvaW50LW1kOiA0OHJlbTtcXG4gICAgLS1icmVha3BvaW50LWxnOiA2NHJlbTtcXG4gICAgLS1icmVha3BvaW50LXhsOiA4MHJlbTtcXG4gICAgLS1icmVha3BvaW50LTJ4bDogOTZyZW07XFxuXFxuICAgIC0tY29udGFpbmVyLTN4czogMTZyZW07XFxuICAgIC0tY29udGFpbmVyLTJ4czogMThyZW07XFxuICAgIC0tY29udGFpbmVyLXhzOiAyMHJlbTtcXG4gICAgLS1jb250YWluZXItc206IDI0cmVtO1xcbiAgICAtLWNvbnRhaW5lci1tZDogMjhyZW07XFxuICAgIC0tY29udGFpbmVyLWxnOiAzMnJlbTtcXG4gICAgLS1jb250YWluZXIteGw6IDM2cmVtO1xcbiAgICAtLWNvbnRhaW5lci0yeGw6IDQycmVtO1xcbiAgICAtLWNvbnRhaW5lci0zeGw6IDQ4cmVtO1xcbiAgICAtLWNvbnRhaW5lci00eGw6IDU2cmVtO1xcbiAgICAtLWNvbnRhaW5lci01eGw6IDY0cmVtO1xcbiAgICAtLWNvbnRhaW5lci02eGw6IDcycmVtO1xcbiAgICAtLWNvbnRhaW5lci03eGw6IDgwcmVtO1xcblxcbiAgICAtLXRleHQteHM6IDAuNzVyZW07XFxuICAgIC0tdGV4dC14cy0tbGluZS1oZWlnaHQ6IGNhbGMoMSAvIDAuNzUpO1xcbiAgICAtLXRleHQtc206IDAuODc1cmVtO1xcbiAgICAtLXRleHQtc20tLWxpbmUtaGVpZ2h0OiBjYWxjKDEuMjUgLyAwLjg3NSk7XFxuICAgIC0tdGV4dC1iYXNlOiAxcmVtO1xcbiAgICAtLXRleHQtYmFzZS0tbGluZS1oZWlnaHQ6IGNhbGMoMS41IC8gMSk7XFxuICAgIC0tdGV4dC1sZzogMS4xMjVyZW07XFxuICAgIC0tdGV4dC1sZy0tbGluZS1oZWlnaHQ6IGNhbGMoMS43NSAvIDEuMTI1KTtcXG4gICAgLS10ZXh0LXhsOiAxLjI1cmVtO1xcbiAgICAtLXRleHQteGwtLWxpbmUtaGVpZ2h0OiBjYWxjKDEuNzUgLyAxLjI1KTtcXG4gICAgLS10ZXh0LTJ4bDogMS41cmVtO1xcbiAgICAtLXRleHQtMnhsLS1saW5lLWhlaWdodDogY2FsYygyIC8gMS41KTtcXG4gICAgLS10ZXh0LTN4bDogMS44NzVyZW07XFxuICAgIC0tdGV4dC0zeGwtLWxpbmUtaGVpZ2h0OiBjYWxjKDIuMjUgLyAxLjg3NSk7XFxuICAgIC0tdGV4dC00eGw6IDIuMjVyZW07XFxuICAgIC0tdGV4dC00eGwtLWxpbmUtaGVpZ2h0OiBjYWxjKDIuNSAvIDIuMjUpO1xcbiAgICAtLXRleHQtNXhsOiAzcmVtO1xcbiAgICAtLXRleHQtNXhsLS1saW5lLWhlaWdodDogMTtcXG4gICAgLS10ZXh0LTZ4bDogMy43NXJlbTtcXG4gICAgLS10ZXh0LTZ4bC0tbGluZS1oZWlnaHQ6IDE7XFxuICAgIC0tdGV4dC03eGw6IDQuNXJlbTtcXG4gICAgLS10ZXh0LTd4bC0tbGluZS1oZWlnaHQ6IDE7XFxuICAgIC0tdGV4dC04eGw6IDZyZW07XFxuICAgIC0tdGV4dC04eGwtLWxpbmUtaGVpZ2h0OiAxO1xcbiAgICAtLXRleHQtOXhsOiA4cmVtO1xcbiAgICAtLXRleHQtOXhsLS1saW5lLWhlaWdodDogMTtcXG5cXG4gICAgLS1mb250LXdlaWdodC10aGluOiAxMDA7XFxuICAgIC0tZm9udC13ZWlnaHQtZXh0cmFsaWdodDogMjAwO1xcbiAgICAtLWZvbnQtd2VpZ2h0LWxpZ2h0OiAzMDA7XFxuICAgIC0tZm9udC13ZWlnaHQtbm9ybWFsOiA0MDA7XFxuICAgIC0tZm9udC13ZWlnaHQtbWVkaXVtOiA1MDA7XFxuICAgIC0tZm9udC13ZWlnaHQtc2VtaWJvbGQ6IDYwMDtcXG4gICAgLS1mb250LXdlaWdodC1ib2xkOiA3MDA7XFxuICAgIC0tZm9udC13ZWlnaHQtZXh0cmFib2xkOiA4MDA7XFxuICAgIC0tZm9udC13ZWlnaHQtYmxhY2s6IDkwMDtcXG5cXG4gICAgLS10cmFja2luZy10aWdodGVyOiAtMC4wNWVtO1xcbiAgICAtLXRyYWNraW5nLXRpZ2h0OiAtMC4wMjVlbTtcXG4gICAgLS10cmFja2luZy1ub3JtYWw6IDBlbTtcXG4gICAgLS10cmFja2luZy13aWRlOiAwLjAyNWVtO1xcbiAgICAtLXRyYWNraW5nLXdpZGVyOiAwLjA1ZW07XFxuICAgIC0tdHJhY2tpbmctd2lkZXN0OiAwLjFlbTtcXG5cXG4gICAgLS1sZWFkaW5nLXRpZ2h0OiAxLjI1O1xcbiAgICAtLWxlYWRpbmctc251ZzogMS4zNzU7XFxuICAgIC0tbGVhZGluZy1ub3JtYWw6IDEuNTtcXG4gICAgLS1sZWFkaW5nLXJlbGF4ZWQ6IDEuNjI1O1xcbiAgICAtLWxlYWRpbmctbG9vc2U6IDI7XFxuXFxuICAgIC0tcmFkaXVzLXhzOiAwLjEyNXJlbTtcXG4gICAgLS1yYWRpdXMtc206IDAuMjVyZW07XFxuICAgIC0tcmFkaXVzLW1kOiAwLjM3NXJlbTtcXG4gICAgLS1yYWRpdXMtbGc6IDAuNXJlbTtcXG4gICAgLS1yYWRpdXMteGw6IDAuNzVyZW07XFxuICAgIC0tcmFkaXVzLTJ4bDogMXJlbTtcXG4gICAgLS1yYWRpdXMtM3hsOiAxLjVyZW07XFxuICAgIC0tcmFkaXVzLTR4bDogMnJlbTtcXG5cXG4gICAgLS1zaGFkb3ctMnhzOiAwIDFweCByZ2IoMCAwIDAgLyAwLjA1KTtcXG4gICAgLS1zaGFkb3cteHM6IDAgMXB4IDJweCAwIHJnYigwIDAgMCAvIDAuMDUpO1xcbiAgICAtLXNoYWRvdy1zbTogMCAxcHggM3B4IDAgcmdiKDAgMCAwIC8gMC4xKSwgMCAxcHggMnB4IC0xcHggcmdiKDAgMCAwIC8gMC4xKTtcXG4gICAgLS1zaGFkb3ctbWQ6XFxuICAgICAgMCA0cHggNnB4IC0xcHggcmdiKDAgMCAwIC8gMC4xKSwgMCAycHggNHB4IC0ycHggcmdiKDAgMCAwIC8gMC4xKTtcXG4gICAgLS1zaGFkb3ctbGc6XFxuICAgICAgMCAxMHB4IDE1cHggLTNweCByZ2IoMCAwIDAgLyAwLjEpLCAwIDRweCA2cHggLTRweCByZ2IoMCAwIDAgLyAwLjEpO1xcbiAgICAtLXNoYWRvdy14bDpcXG4gICAgICAwIDIwcHggMjVweCAtNXB4IHJnYigwIDAgMCAvIDAuMSksIDAgOHB4IDEwcHggLTZweCByZ2IoMCAwIDAgLyAwLjEpO1xcbiAgICAtLXNoYWRvdy0yeGw6IDAgMjVweCA1MHB4IC0xMnB4IHJnYigwIDAgMCAvIDAuMjUpO1xcblxcbiAgICAtLWluc2V0LXNoYWRvdy0yeHM6IGluc2V0IDAgMXB4IHJnYigwIDAgMCAvIDAuMDUpO1xcbiAgICAtLWluc2V0LXNoYWRvdy14czogaW5zZXQgMCAxcHggMXB4IHJnYigwIDAgMCAvIDAuMDUpO1xcbiAgICAtLWluc2V0LXNoYWRvdy1zbTogaW5zZXQgMCAycHggNHB4IHJnYigwIDAgMCAvIDAuMDUpO1xcblxcbiAgICAtLWRyb3Atc2hhZG93LXhzOiAwIDFweCAxcHggcmdiKDAgMCAwIC8gMC4wNSk7XFxuICAgIC0tZHJvcC1zaGFkb3ctc206IDAgMXB4IDJweCByZ2IoMCAwIDAgLyAwLjE1KTtcXG4gICAgLS1kcm9wLXNoYWRvdy1tZDogMCAzcHggM3B4IHJnYigwIDAgMCAvIDAuMTIpO1xcbiAgICAtLWRyb3Atc2hhZG93LWxnOiAwIDRweCA0cHggcmdiKDAgMCAwIC8gMC4xNSk7XFxuICAgIC0tZHJvcC1zaGFkb3cteGw6IDAgOXB4IDdweCByZ2IoMCAwIDAgLyAwLjEpO1xcbiAgICAtLWRyb3Atc2hhZG93LTJ4bDogMCAyNXB4IDI1cHggcmdiKDAgMCAwIC8gMC4xNSk7XFxuXFxuICAgIC0tdGV4dC1zaGFkb3ctMnhzOiAwcHggMXB4IDBweCByZ2IoMCAwIDAgLyAwLjE1KTtcXG4gICAgLS10ZXh0LXNoYWRvdy14czogMHB4IDFweCAxcHggcmdiKDAgMCAwIC8gMC4yKTtcXG4gICAgLS10ZXh0LXNoYWRvdy1zbTpcXG4gICAgICAwcHggMXB4IDBweCByZ2IoMCAwIDAgLyAwLjA3NSksIDBweCAxcHggMXB4IHJnYigwIDAgMCAvIDAuMDc1KSxcXG4gICAgICAwcHggMnB4IDJweCByZ2IoMCAwIDAgLyAwLjA3NSk7XFxuICAgIC0tdGV4dC1zaGFkb3ctbWQ6XFxuICAgICAgMHB4IDFweCAxcHggcmdiKDAgMCAwIC8gMC4xKSwgMHB4IDFweCAycHggcmdiKDAgMCAwIC8gMC4xKSxcXG4gICAgICAwcHggMnB4IDRweCByZ2IoMCAwIDAgLyAwLjEpO1xcbiAgICAtLXRleHQtc2hhZG93LWxnOlxcbiAgICAgIDBweCAxcHggMnB4IHJnYigwIDAgMCAvIDAuMSksIDBweCAzcHggMnB4IHJnYigwIDAgMCAvIDAuMSksXFxuICAgICAgMHB4IDRweCA4cHggcmdiKDAgMCAwIC8gMC4xKTtcXG5cXG4gICAgLS1lYXNlLWluOiBjdWJpYy1iZXppZXIoMC40LCAwLCAxLCAxKTtcXG4gICAgLS1lYXNlLW91dDogY3ViaWMtYmV6aWVyKDAsIDAsIDAuMiwgMSk7XFxuICAgIC0tZWFzZS1pbi1vdXQ6IGN1YmljLWJlemllcigwLjQsIDAsIDAuMiwgMSk7XFxuXFxuICAgIC0tYW5pbWF0ZS1zcGluOiBzcGluIDFzIGxpbmVhciBpbmZpbml0ZTtcXG4gICAgLS1hbmltYXRlLXBpbmc6IHBpbmcgMXMgY3ViaWMtYmV6aWVyKDAsIDAsIDAuMiwgMSkgaW5maW5pdGU7XFxuICAgIC0tYW5pbWF0ZS1wdWxzZTogcHVsc2UgMnMgY3ViaWMtYmV6aWVyKDAuNCwgMCwgMC42LCAxKSBpbmZpbml0ZTtcXG4gICAgLS1hbmltYXRlLWJvdW5jZTogYm91bmNlIDFzIGluZmluaXRlO1xcblxcbiAgICBAa2V5ZnJhbWVzIHNwaW4ge1xcbiAgICAgIHRvIHtcXG4gICAgICAgIHRyYW5zZm9ybTogcm90YXRlKDM2MGRlZyk7XFxuICAgICAgfVxcbiAgICB9XFxuXFxuICAgIEBrZXlmcmFtZXMgcGluZyB7XFxuICAgICAgNzUlLFxcbiAgICAgIDEwMCUge1xcbiAgICAgICAgdHJhbnNmb3JtOiBzY2FsZSgyKTtcXG4gICAgICAgIG9wYWNpdHk6IDA7XFxuICAgICAgfVxcbiAgICB9XFxuXFxuICAgIEBrZXlmcmFtZXMgcHVsc2Uge1xcbiAgICAgIDUwJSB7XFxuICAgICAgICBvcGFjaXR5OiAwLjU7XFxuICAgICAgfVxcbiAgICB9XFxuXFxuICAgIEBrZXlmcmFtZXMgYm91bmNlIHtcXG4gICAgICAwJSxcXG4gICAgICAxMDAlIHtcXG4gICAgICAgIHRyYW5zZm9ybTogdHJhbnNsYXRlWSgtMjUlKTtcXG4gICAgICAgIGFuaW1hdGlvbi10aW1pbmctZnVuY3Rpb246IGN1YmljLWJlemllcigwLjgsIDAsIDEsIDEpO1xcbiAgICAgIH1cXG5cXG4gICAgICA1MCUge1xcbiAgICAgICAgdHJhbnNmb3JtOiBub25lO1xcbiAgICAgICAgYW5pbWF0aW9uLXRpbWluZy1mdW5jdGlvbjogY3ViaWMtYmV6aWVyKDAsIDAsIDAuMiwgMSk7XFxuICAgICAgfVxcbiAgICB9XFxuXFxuICAgIC0tYmx1ci14czogNHB4O1xcbiAgICAtLWJsdXItc206IDhweDtcXG4gICAgLS1ibHVyLW1kOiAxMnB4O1xcbiAgICAtLWJsdXItbGc6IDE2cHg7XFxuICAgIC0tYmx1ci14bDogMjRweDtcXG4gICAgLS1ibHVyLTJ4bDogNDBweDtcXG4gICAgLS1ibHVyLTN4bDogNjRweDtcXG5cXG4gICAgLS1wZXJzcGVjdGl2ZS1kcmFtYXRpYzogMTAwcHg7XFxuICAgIC0tcGVyc3BlY3RpdmUtbmVhcjogMzAwcHg7XFxuICAgIC0tcGVyc3BlY3RpdmUtbm9ybWFsOiA1MDBweDtcXG4gICAgLS1wZXJzcGVjdGl2ZS1taWRyYW5nZTogODAwcHg7XFxuICAgIC0tcGVyc3BlY3RpdmUtZGlzdGFudDogMTIwMHB4O1xcblxcbiAgICAtLWFzcGVjdC12aWRlbzogMTYgLyA5O1xcblxcbiAgICAtLWRlZmF1bHQtdHJhbnNpdGlvbi1kdXJhdGlvbjogMTUwbXM7XFxuICAgIC0tZGVmYXVsdC10cmFuc2l0aW9uLXRpbWluZy1mdW5jdGlvbjogY3ViaWMtYmV6aWVyKDAuNCwgMCwgMC4yLCAxKTtcXG4gICAgLS1kZWZhdWx0LWZvbnQtZmFtaWx5OiAtLXRoZW1lKC0tZm9udC1zYW5zLCBpbml0aWFsKTtcXG4gICAgLS1kZWZhdWx0LWZvbnQtZmVhdHVyZS1zZXR0aW5nczogLS10aGVtZShcXG4gICAgICAtLWZvbnQtc2Fucy0tZm9udC1mZWF0dXJlLXNldHRpbmdzLFxcbiAgICAgIGluaXRpYWxcXG4gICAgKTtcXG4gICAgLS1kZWZhdWx0LWZvbnQtdmFyaWF0aW9uLXNldHRpbmdzOiAtLXRoZW1lKFxcbiAgICAgIC0tZm9udC1zYW5zLS1mb250LXZhcmlhdGlvbi1zZXR0aW5ncyxcXG4gICAgICBpbml0aWFsXFxuICAgICk7XFxuICAgIC0tZGVmYXVsdC1tb25vLWZvbnQtZmFtaWx5OiAtLXRoZW1lKC0tZm9udC1tb25vLCBpbml0aWFsKTtcXG4gICAgLS1kZWZhdWx0LW1vbm8tZm9udC1mZWF0dXJlLXNldHRpbmdzOiAtLXRoZW1lKFxcbiAgICAgIC0tZm9udC1tb25vLS1mb250LWZlYXR1cmUtc2V0dGluZ3MsXFxuICAgICAgaW5pdGlhbFxcbiAgICApO1xcbiAgICAtLWRlZmF1bHQtbW9uby1mb250LXZhcmlhdGlvbi1zZXR0aW5nczogLS10aGVtZShcXG4gICAgICAtLWZvbnQtbW9uby0tZm9udC12YXJpYXRpb24tc2V0dGluZ3MsXFxuICAgICAgaW5pdGlhbFxcbiAgICApO1xcbiAgfVxcblxcbiAgLyogRGVwcmVjYXRlZCAqL1xcbiAgQHRoZW1lIGRlZmF1bHQgaW5saW5lIHJlZmVyZW5jZSB7XFxuICAgIC0tYmx1cjogOHB4O1xcbiAgICAtLXNoYWRvdzogMCAxcHggM3B4IDAgcmdiKDAgMCAwIC8gMC4xKSwgMCAxcHggMnB4IC0xcHggcmdiKDAgMCAwIC8gMC4xKTtcXG4gICAgLS1zaGFkb3ctaW5uZXI6IGluc2V0IDAgMnB4IDRweCAwIHJnYigwIDAgMCAvIDAuMDUpO1xcbiAgICAtLWRyb3Atc2hhZG93OiAwIDFweCAycHggcmdiKDAgMCAwIC8gMC4xKSwgMCAxcHggMXB4IHJnYigwIDAgMCAvIDAuMDYpO1xcbiAgICAtLXJhZGl1czogMC4yNXJlbTtcXG4gICAgLS1tYXgtd2lkdGgtcHJvc2U6IDY1Y2g7XFxuICB9XFxufVxcblxcbkBsYXllciBiYXNlIHtcXG4gIC8qXFxuICAxLiBQcmV2ZW50IHBhZGRpbmcgYW5kIGJvcmRlciBmcm9tIGFmZmVjdGluZyBlbGVtZW50IHdpZHRoLiAoaHR0cHM6Ly9naXRodWIuY29tL21vemRldnMvY3NzcmVtZWR5L2lzc3Vlcy80KVxcbiAgMi4gUmVtb3ZlIGRlZmF1bHQgbWFyZ2lucyBhbmQgcGFkZGluZ1xcbiAgMy4gUmVzZXQgYWxsIGJvcmRlcnMuXFxuKi9cXG5cXG4gICosXFxuICA6OmFmdGVyLFxcbiAgOjpiZWZvcmUsXFxuICA6OmJhY2tkcm9wLFxcbiAgOjpmaWxlLXNlbGVjdG9yLWJ1dHRvbiB7XFxuICAgIGJveC1zaXppbmc6IGJvcmRlci1ib3g7IC8qIDEgKi9cXG4gICAgbWFyZ2luOiAwOyAvKiAyICovXFxuICAgIHBhZGRpbmc6IDA7IC8qIDIgKi9cXG4gICAgYm9yZGVyOiAwIHNvbGlkOyAvKiAzICovXFxuICB9XFxuXFxuICAvKlxcbiAgMS4gVXNlIGEgY29uc2lzdGVudCBzZW5zaWJsZSBsaW5lLWhlaWdodCBpbiBhbGwgYnJvd3NlcnMuXFxuICAyLiBQcmV2ZW50IGFkanVzdG1lbnRzIG9mIGZvbnQgc2l6ZSBhZnRlciBvcmllbnRhdGlvbiBjaGFuZ2VzIGluIGlPUy5cXG4gIDMuIFVzZSBhIG1vcmUgcmVhZGFibGUgdGFiIHNpemUuXFxuICA0LiBVc2UgdGhlIHVzZXIncyBjb25maWd1cmVkIGBzYW5zYCBmb250LWZhbWlseSBieSBkZWZhdWx0LlxcbiAgNS4gVXNlIHRoZSB1c2VyJ3MgY29uZmlndXJlZCBgc2Fuc2AgZm9udC1mZWF0dXJlLXNldHRpbmdzIGJ5IGRlZmF1bHQuXFxuICA2LiBVc2UgdGhlIHVzZXIncyBjb25maWd1cmVkIGBzYW5zYCBmb250LXZhcmlhdGlvbi1zZXR0aW5ncyBieSBkZWZhdWx0LlxcbiAgNy4gRGlzYWJsZSB0YXAgaGlnaGxpZ2h0cyBvbiBpT1MuXFxuKi9cXG5cXG4gIGh0bWwsXFxuICA6aG9zdCB7XFxuICAgIGxpbmUtaGVpZ2h0OiAxLjU7IC8qIDEgKi9cXG4gICAgLXdlYmtpdC10ZXh0LXNpemUtYWRqdXN0OiAxMDAlOyAvKiAyICovXFxuICAgIHRhYi1zaXplOiA0OyAvKiAzICovXFxuICAgIGZvbnQtZmFtaWx5OiAtLXRoZW1lKFxcbiAgICAgIC0tZGVmYXVsdC1mb250LWZhbWlseSxcXG4gICAgICB1aS1zYW5zLXNlcmlmLFxcbiAgICAgIHN5c3RlbS11aSxcXG4gICAgICBzYW5zLXNlcmlmLFxcbiAgICAgIFxcXCJBcHBsZSBDb2xvciBFbW9qaVxcXCIsXFxuICAgICAgXFxcIlNlZ29lIFVJIEVtb2ppXFxcIixcXG4gICAgICBcXFwiU2Vnb2UgVUkgU3ltYm9sXFxcIixcXG4gICAgICBcXFwiTm90byBDb2xvciBFbW9qaVxcXCJcXG4gICAgKTsgLyogNCAqL1xcbiAgICBmb250LWZlYXR1cmUtc2V0dGluZ3M6IC0tdGhlbWUoXFxuICAgICAgLS1kZWZhdWx0LWZvbnQtZmVhdHVyZS1zZXR0aW5ncyxcXG4gICAgICBub3JtYWxcXG4gICAgKTsgLyogNSAqL1xcbiAgICBmb250LXZhcmlhdGlvbi1zZXR0aW5nczogLS10aGVtZShcXG4gICAgICAtLWRlZmF1bHQtZm9udC12YXJpYXRpb24tc2V0dGluZ3MsXFxuICAgICAgbm9ybWFsXFxuICAgICk7IC8qIDYgKi9cXG4gICAgLXdlYmtpdC10YXAtaGlnaGxpZ2h0LWNvbG9yOiB0cmFuc3BhcmVudDsgLyogNyAqL1xcbiAgfVxcblxcbiAgLypcXG4gIDEuIEFkZCB0aGUgY29ycmVjdCBoZWlnaHQgaW4gRmlyZWZveC5cXG4gIDIuIENvcnJlY3QgdGhlIGluaGVyaXRhbmNlIG9mIGJvcmRlciBjb2xvciBpbiBGaXJlZm94LiAoaHR0cHM6Ly9idWd6aWxsYS5tb3ppbGxhLm9yZy9zaG93X2J1Zy5jZ2k/aWQ9MTkwNjU1KVxcbiAgMy4gUmVzZXQgdGhlIGRlZmF1bHQgYm9yZGVyIHN0eWxlIHRvIGEgMXB4IHNvbGlkIGJvcmRlci5cXG4qL1xcblxcbiAgaHIge1xcbiAgICBoZWlnaHQ6IDA7IC8qIDEgKi9cXG4gICAgY29sb3I6IGluaGVyaXQ7IC8qIDIgKi9cXG4gICAgYm9yZGVyLXRvcC13aWR0aDogMXB4OyAvKiAzICovXFxuICB9XFxuXFxuICAvKlxcbiAgQWRkIHRoZSBjb3JyZWN0IHRleHQgZGVjb3JhdGlvbiBpbiBDaHJvbWUsIEVkZ2UsIGFuZCBTYWZhcmkuXFxuKi9cXG5cXG4gIGFiYnI6d2hlcmUoW3RpdGxlXSkge1xcbiAgICAtd2Via2l0LXRleHQtZGVjb3JhdGlvbjogdW5kZXJsaW5lIGRvdHRlZDtcXG4gICAgdGV4dC1kZWNvcmF0aW9uOiB1bmRlcmxpbmUgZG90dGVkO1xcbiAgfVxcblxcbiAgLypcXG4gIFJlbW92ZSB0aGUgZGVmYXVsdCBmb250IHNpemUgYW5kIHdlaWdodCBmb3IgaGVhZGluZ3MuXFxuKi9cXG5cXG4gIGgxLFxcbiAgaDIsXFxuICBoMyxcXG4gIGg0LFxcbiAgaDUsXFxuICBoNiB7XFxuICAgIGZvbnQtc2l6ZTogaW5oZXJpdDtcXG4gICAgZm9udC13ZWlnaHQ6IGluaGVyaXQ7XFxuICB9XFxuXFxuICAvKlxcbiAgUmVzZXQgbGlua3MgdG8gb3B0aW1pemUgZm9yIG9wdC1pbiBzdHlsaW5nIGluc3RlYWQgb2Ygb3B0LW91dC5cXG4qL1xcblxcbiAgYSB7XFxuICAgIGNvbG9yOiBpbmhlcml0O1xcbiAgICAtd2Via2l0LXRleHQtZGVjb3JhdGlvbjogaW5oZXJpdDtcXG4gICAgdGV4dC1kZWNvcmF0aW9uOiBpbmhlcml0O1xcbiAgfVxcblxcbiAgLypcXG4gIEFkZCB0aGUgY29ycmVjdCBmb250IHdlaWdodCBpbiBFZGdlIGFuZCBTYWZhcmkuXFxuKi9cXG5cXG4gIGIsXFxuICBzdHJvbmcge1xcbiAgICBmb250LXdlaWdodDogYm9sZGVyO1xcbiAgfVxcblxcbiAgLypcXG4gIDEuIFVzZSB0aGUgdXNlcidzIGNvbmZpZ3VyZWQgYG1vbm9gIGZvbnQtZmFtaWx5IGJ5IGRlZmF1bHQuXFxuICAyLiBVc2UgdGhlIHVzZXIncyBjb25maWd1cmVkIGBtb25vYCBmb250LWZlYXR1cmUtc2V0dGluZ3MgYnkgZGVmYXVsdC5cXG4gIDMuIFVzZSB0aGUgdXNlcidzIGNvbmZpZ3VyZWQgYG1vbm9gIGZvbnQtdmFyaWF0aW9uLXNldHRpbmdzIGJ5IGRlZmF1bHQuXFxuICA0LiBDb3JyZWN0IHRoZSBvZGQgYGVtYCBmb250IHNpemluZyBpbiBhbGwgYnJvd3NlcnMuXFxuKi9cXG5cXG4gIGNvZGUsXFxuICBrYmQsXFxuICBzYW1wLFxcbiAgcHJlIHtcXG4gICAgZm9udC1mYW1pbHk6IC0tdGhlbWUoXFxuICAgICAgLS1kZWZhdWx0LW1vbm8tZm9udC1mYW1pbHksXFxuICAgICAgdWktbW9ub3NwYWNlLFxcbiAgICAgIFNGTW9uby1SZWd1bGFyLFxcbiAgICAgIE1lbmxvLFxcbiAgICAgIE1vbmFjbyxcXG4gICAgICBDb25zb2xhcyxcXG4gICAgICBcXFwiTGliZXJhdGlvbiBNb25vXFxcIixcXG4gICAgICBcXFwiQ291cmllciBOZXdcXFwiLFxcbiAgICAgIG1vbm9zcGFjZVxcbiAgICApOyAvKiAxICovXFxuICAgIGZvbnQtZmVhdHVyZS1zZXR0aW5nczogLS10aGVtZShcXG4gICAgICAtLWRlZmF1bHQtbW9uby1mb250LWZlYXR1cmUtc2V0dGluZ3MsXFxuICAgICAgbm9ybWFsXFxuICAgICk7IC8qIDIgKi9cXG4gICAgZm9udC12YXJpYXRpb24tc2V0dGluZ3M6IC0tdGhlbWUoXFxuICAgICAgLS1kZWZhdWx0LW1vbm8tZm9udC12YXJpYXRpb24tc2V0dGluZ3MsXFxuICAgICAgbm9ybWFsXFxuICAgICk7IC8qIDMgKi9cXG4gICAgZm9udC1zaXplOiAxZW07IC8qIDQgKi9cXG4gIH1cXG5cXG4gIC8qXFxuICBBZGQgdGhlIGNvcnJlY3QgZm9udCBzaXplIGluIGFsbCBicm93c2Vycy5cXG4qL1xcblxcbiAgc21hbGwge1xcbiAgICBmb250LXNpemU6IDgwJTtcXG4gIH1cXG5cXG4gIC8qXFxuICBQcmV2ZW50IGBzdWJgIGFuZCBgc3VwYCBlbGVtZW50cyBmcm9tIGFmZmVjdGluZyB0aGUgbGluZSBoZWlnaHQgaW4gYWxsIGJyb3dzZXJzLlxcbiovXFxuXFxuICBzdWIsXFxuICBzdXAge1xcbiAgICBmb250LXNpemU6IDc1JTtcXG4gICAgbGluZS1oZWlnaHQ6IDA7XFxuICAgIHBvc2l0aW9uOiByZWxhdGl2ZTtcXG4gICAgdmVydGljYWwtYWxpZ246IGJhc2VsaW5lO1xcbiAgfVxcblxcbiAgc3ViIHtcXG4gICAgYm90dG9tOiAtMC4yNWVtO1xcbiAgfVxcblxcbiAgc3VwIHtcXG4gICAgdG9wOiAtMC41ZW07XFxuICB9XFxuXFxuICAvKlxcbiAgMS4gUmVtb3ZlIHRleHQgaW5kZW50YXRpb24gZnJvbSB0YWJsZSBjb250ZW50cyBpbiBDaHJvbWUgYW5kIFNhZmFyaS4gKGh0dHBzOi8vYnVncy5jaHJvbWl1bS5vcmcvcC9jaHJvbWl1bS9pc3N1ZXMvZGV0YWlsP2lkPTk5OTA4OCwgaHR0cHM6Ly9idWdzLndlYmtpdC5vcmcvc2hvd19idWcuY2dpP2lkPTIwMTI5NylcXG4gIDIuIENvcnJlY3QgdGFibGUgYm9yZGVyIGNvbG9yIGluaGVyaXRhbmNlIGluIGFsbCBDaHJvbWUgYW5kIFNhZmFyaS4gKGh0dHBzOi8vYnVncy5jaHJvbWl1bS5vcmcvcC9jaHJvbWl1bS9pc3N1ZXMvZGV0YWlsP2lkPTkzNTcyOSwgaHR0cHM6Ly9idWdzLndlYmtpdC5vcmcvc2hvd19idWcuY2dpP2lkPTE5NTAxNilcXG4gIDMuIFJlbW92ZSBnYXBzIGJldHdlZW4gdGFibGUgYm9yZGVycyBieSBkZWZhdWx0LlxcbiovXFxuXFxuICB0YWJsZSB7XFxuICAgIHRleHQtaW5kZW50OiAwOyAvKiAxICovXFxuICAgIGJvcmRlci1jb2xvcjogaW5oZXJpdDsgLyogMiAqL1xcbiAgICBib3JkZXItY29sbGFwc2U6IGNvbGxhcHNlOyAvKiAzICovXFxuICB9XFxuXFxuICAvKlxcbiAgVXNlIHRoZSBtb2Rlcm4gRmlyZWZveCBmb2N1cyBzdHlsZSBmb3IgYWxsIGZvY3VzYWJsZSBlbGVtZW50cy5cXG4qL1xcblxcbiAgOi1tb3otZm9jdXNyaW5nIHtcXG4gICAgb3V0bGluZTogYXV0bztcXG4gIH1cXG5cXG4gIC8qXFxuICBBZGQgdGhlIGNvcnJlY3QgdmVydGljYWwgYWxpZ25tZW50IGluIENocm9tZSBhbmQgRmlyZWZveC5cXG4qL1xcblxcbiAgcHJvZ3Jlc3Mge1xcbiAgICB2ZXJ0aWNhbC1hbGlnbjogYmFzZWxpbmU7XFxuICB9XFxuXFxuICAvKlxcbiAgQWRkIHRoZSBjb3JyZWN0IGRpc3BsYXkgaW4gQ2hyb21lIGFuZCBTYWZhcmkuXFxuKi9cXG5cXG4gIHN1bW1hcnkge1xcbiAgICBkaXNwbGF5OiBsaXN0LWl0ZW07XFxuICB9XFxuXFxuICAvKlxcbiAgTWFrZSBsaXN0cyB1bnN0eWxlZCBieSBkZWZhdWx0LlxcbiovXFxuXFxuICBvbCxcXG4gIHVsLFxcbiAgbWVudSB7XFxuICAgIGxpc3Qtc3R5bGU6IG5vbmU7XFxuICB9XFxuXFxuICAvKlxcbiAgMS4gTWFrZSByZXBsYWNlZCBlbGVtZW50cyBgZGlzcGxheTogYmxvY2tgIGJ5IGRlZmF1bHQuIChodHRwczovL2dpdGh1Yi5jb20vbW96ZGV2cy9jc3NyZW1lZHkvaXNzdWVzLzE0KVxcbiAgMi4gQWRkIGB2ZXJ0aWNhbC1hbGlnbjogbWlkZGxlYCB0byBhbGlnbiByZXBsYWNlZCBlbGVtZW50cyBtb3JlIHNlbnNpYmx5IGJ5IGRlZmF1bHQuIChodHRwczovL2dpdGh1Yi5jb20vamVuc2ltbW9ucy9jc3NyZW1lZHkvaXNzdWVzLzE0I2lzc3VlY29tbWVudC02MzQ5MzQyMTApXFxuICAgICAgVGhpcyBjYW4gdHJpZ2dlciBhIHBvb3JseSBjb25zaWRlcmVkIGxpbnQgZXJyb3IgaW4gc29tZSB0b29scyBidXQgaXMgaW5jbHVkZWQgYnkgZGVzaWduLlxcbiovXFxuXFxuICBpbWcsXFxuICBzdmcsXFxuICB2aWRlbyxcXG4gIGNhbnZhcyxcXG4gIGF1ZGlvLFxcbiAgaWZyYW1lLFxcbiAgZW1iZWQsXFxuICBvYmplY3Qge1xcbiAgICBkaXNwbGF5OiBibG9jazsgLyogMSAqL1xcbiAgICB2ZXJ0aWNhbC1hbGlnbjogbWlkZGxlOyAvKiAyICovXFxuICB9XFxuXFxuICAvKlxcbiAgQ29uc3RyYWluIGltYWdlcyBhbmQgdmlkZW9zIHRvIHRoZSBwYXJlbnQgd2lkdGggYW5kIHByZXNlcnZlIHRoZWlyIGludHJpbnNpYyBhc3BlY3QgcmF0aW8uIChodHRwczovL2dpdGh1Yi5jb20vbW96ZGV2cy9jc3NyZW1lZHkvaXNzdWVzLzE0KVxcbiovXFxuXFxuICBpbWcsXFxuICB2aWRlbyB7XFxuICAgIG1heC13aWR0aDogMTAwJTtcXG4gICAgaGVpZ2h0OiBhdXRvO1xcbiAgfVxcblxcbiAgLypcXG4gIDEuIEluaGVyaXQgZm9udCBzdHlsZXMgaW4gYWxsIGJyb3dzZXJzLlxcbiAgMi4gUmVtb3ZlIGJvcmRlciByYWRpdXMgaW4gYWxsIGJyb3dzZXJzLlxcbiAgMy4gUmVtb3ZlIGJhY2tncm91bmQgY29sb3IgaW4gYWxsIGJyb3dzZXJzLlxcbiAgNC4gRW5zdXJlIGNvbnNpc3RlbnQgb3BhY2l0eSBmb3IgZGlzYWJsZWQgc3RhdGVzIGluIGFsbCBicm93c2Vycy5cXG4qL1xcblxcbiAgYnV0dG9uLFxcbiAgaW5wdXQsXFxuICBzZWxlY3QsXFxuICBvcHRncm91cCxcXG4gIHRleHRhcmVhLFxcbiAgOjpmaWxlLXNlbGVjdG9yLWJ1dHRvbiB7XFxuICAgIGZvbnQ6IGluaGVyaXQ7IC8qIDEgKi9cXG4gICAgZm9udC1mZWF0dXJlLXNldHRpbmdzOiBpbmhlcml0OyAvKiAxICovXFxuICAgIGZvbnQtdmFyaWF0aW9uLXNldHRpbmdzOiBpbmhlcml0OyAvKiAxICovXFxuICAgIGxldHRlci1zcGFjaW5nOiBpbmhlcml0OyAvKiAxICovXFxuICAgIGNvbG9yOiBpbmhlcml0OyAvKiAxICovXFxuICAgIGJvcmRlci1yYWRpdXM6IDA7IC8qIDIgKi9cXG4gICAgYmFja2dyb3VuZC1jb2xvcjogdHJhbnNwYXJlbnQ7IC8qIDMgKi9cXG4gICAgb3BhY2l0eTogMTsgLyogNCAqL1xcbiAgfVxcblxcbiAgLypcXG4gIFJlc3RvcmUgZGVmYXVsdCBmb250IHdlaWdodC5cXG4qL1xcblxcbiAgOndoZXJlKHNlbGVjdDppcyhbbXVsdGlwbGVdLCBbc2l6ZV0pKSBvcHRncm91cCB7XFxuICAgIGZvbnQtd2VpZ2h0OiBib2xkZXI7XFxuICB9XFxuXFxuICAvKlxcbiAgUmVzdG9yZSBpbmRlbnRhdGlvbi5cXG4qL1xcblxcbiAgOndoZXJlKHNlbGVjdDppcyhbbXVsdGlwbGVdLCBbc2l6ZV0pKSBvcHRncm91cCBvcHRpb24ge1xcbiAgICBwYWRkaW5nLWlubGluZS1zdGFydDogMjBweDtcXG4gIH1cXG5cXG4gIC8qXFxuICBSZXN0b3JlIHNwYWNlIGFmdGVyIGJ1dHRvbi5cXG4qL1xcblxcbiAgOjpmaWxlLXNlbGVjdG9yLWJ1dHRvbiB7XFxuICAgIG1hcmdpbi1pbmxpbmUtZW5kOiA0cHg7XFxuICB9XFxuXFxuICAvKlxcbiAgUmVzZXQgdGhlIGRlZmF1bHQgcGxhY2Vob2xkZXIgb3BhY2l0eSBpbiBGaXJlZm94LiAoaHR0cHM6Ly9naXRodWIuY29tL3RhaWx3aW5kbGFicy90YWlsd2luZGNzcy9pc3N1ZXMvMzMwMClcXG4qL1xcblxcbiAgOjpwbGFjZWhvbGRlciB7XFxuICAgIG9wYWNpdHk6IDE7XFxuICB9XFxuXFxuICAvKlxcbiAgU2V0IHRoZSBkZWZhdWx0IHBsYWNlaG9sZGVyIGNvbG9yIHRvIGEgc2VtaS10cmFuc3BhcmVudCB2ZXJzaW9uIG9mIHRoZSBjdXJyZW50IHRleHQgY29sb3IgaW4gYnJvd3NlcnMgdGhhdCBkbyBub3RcXG4gIGNyYXNoIHdoZW4gdXNpbmcgYGNvbG9yLW1peCjigKYpYCB3aXRoIGBjdXJyZW50Y29sb3JgLiAoaHR0cHM6Ly9naXRodWIuY29tL3RhaWx3aW5kbGFicy90YWlsd2luZGNzcy9pc3N1ZXMvMTcxOTQpXFxuKi9cXG5cXG4gIEBzdXBwb3J0cyAobm90ICgtd2Via2l0LWFwcGVhcmFuY2U6IC1hcHBsZS1wYXktYnV0dG9uKSkgLyogTm90IFNhZmFyaSAqLyBvclxcbiAgICAoY29udGFpbi1pbnRyaW5zaWMtc2l6ZTogMXB4KSAvKiBTYWZhcmkgMTcrICovIHtcXG4gICAgOjpwbGFjZWhvbGRlciB7XFxuICAgICAgY29sb3I6IGNvbG9yLW1peChpbiBva2xhYiwgY3VycmVudGNvbG9yIDUwJSwgdHJhbnNwYXJlbnQpO1xcbiAgICB9XFxuICB9XFxuXFxuICAvKlxcbiAgUHJldmVudCByZXNpemluZyB0ZXh0YXJlYXMgaG9yaXpvbnRhbGx5IGJ5IGRlZmF1bHQuXFxuKi9cXG5cXG4gIHRleHRhcmVhIHtcXG4gICAgcmVzaXplOiB2ZXJ0aWNhbDtcXG4gIH1cXG5cXG4gIC8qXFxuICBSZW1vdmUgdGhlIGlubmVyIHBhZGRpbmcgaW4gQ2hyb21lIGFuZCBTYWZhcmkgb24gbWFjT1MuXFxuKi9cXG5cXG4gIDo6LXdlYmtpdC1zZWFyY2gtZGVjb3JhdGlvbiB7XFxuICAgIC13ZWJraXQtYXBwZWFyYW5jZTogbm9uZTtcXG4gIH1cXG5cXG4gIC8qXFxuICAxLiBFbnN1cmUgZGF0ZS90aW1lIGlucHV0cyBoYXZlIHRoZSBzYW1lIGhlaWdodCB3aGVuIGVtcHR5IGluIGlPUyBTYWZhcmkuXFxuICAyLiBFbnN1cmUgdGV4dCBhbGlnbm1lbnQgY2FuIGJlIGNoYW5nZWQgb24gZGF0ZS90aW1lIGlucHV0cyBpbiBpT1MgU2FmYXJpLlxcbiovXFxuXFxuICA6Oi13ZWJraXQtZGF0ZS1hbmQtdGltZS12YWx1ZSB7XFxuICAgIG1pbi1oZWlnaHQ6IDFsaDsgLyogMSAqL1xcbiAgICB0ZXh0LWFsaWduOiBpbmhlcml0OyAvKiAyICovXFxuICB9XFxuXFxuICAvKlxcbiAgUHJldmVudCBoZWlnaHQgZnJvbSBjaGFuZ2luZyBvbiBkYXRlL3RpbWUgaW5wdXRzIGluIG1hY09TIFNhZmFyaSB3aGVuIHRoZSBpbnB1dCBpcyBzZXQgdG8gYGRpc3BsYXk6IGJsb2NrYC5cXG4qL1xcblxcbiAgOjotd2Via2l0LWRhdGV0aW1lLWVkaXQge1xcbiAgICBkaXNwbGF5OiBpbmxpbmUtZmxleDtcXG4gIH1cXG5cXG4gIC8qXFxuICBSZW1vdmUgZXhjZXNzIHBhZGRpbmcgZnJvbSBwc2V1ZG8tZWxlbWVudHMgaW4gZGF0ZS90aW1lIGlucHV0cyB0byBlbnN1cmUgY29uc2lzdGVudCBoZWlnaHQgYWNyb3NzIGJyb3dzZXJzLlxcbiovXFxuXFxuICA6Oi13ZWJraXQtZGF0ZXRpbWUtZWRpdC1maWVsZHMtd3JhcHBlciB7XFxuICAgIHBhZGRpbmc6IDA7XFxuICB9XFxuXFxuICA6Oi13ZWJraXQtZGF0ZXRpbWUtZWRpdCxcXG4gIDo6LXdlYmtpdC1kYXRldGltZS1lZGl0LXllYXItZmllbGQsXFxuICA6Oi13ZWJraXQtZGF0ZXRpbWUtZWRpdC1tb250aC1maWVsZCxcXG4gIDo6LXdlYmtpdC1kYXRldGltZS1lZGl0LWRheS1maWVsZCxcXG4gIDo6LXdlYmtpdC1kYXRldGltZS1lZGl0LWhvdXItZmllbGQsXFxuICA6Oi13ZWJraXQtZGF0ZXRpbWUtZWRpdC1taW51dGUtZmllbGQsXFxuICA6Oi13ZWJraXQtZGF0ZXRpbWUtZWRpdC1zZWNvbmQtZmllbGQsXFxuICA6Oi13ZWJraXQtZGF0ZXRpbWUtZWRpdC1taWxsaXNlY29uZC1maWVsZCxcXG4gIDo6LXdlYmtpdC1kYXRldGltZS1lZGl0LW1lcmlkaWVtLWZpZWxkIHtcXG4gICAgcGFkZGluZy1ibG9jazogMDtcXG4gIH1cXG5cXG4gIC8qXFxuICBSZW1vdmUgdGhlIGFkZGl0aW9uYWwgYDppbnZhbGlkYCBzdHlsZXMgaW4gRmlyZWZveC4gKGh0dHBzOi8vZ2l0aHViLmNvbS9tb3ppbGxhL2dlY2tvLWRldi9ibG9iLzJmOWVhY2Q5ZDNkOTk1YzkzN2I0MjUxYTU1NTdkOTVkNDk0YzliZTEvbGF5b3V0L3N0eWxlL3Jlcy9mb3Jtcy5jc3MjTDcyOC1MNzM3KVxcbiovXFxuXFxuICA6LW1vei11aS1pbnZhbGlkIHtcXG4gICAgYm94LXNoYWRvdzogbm9uZTtcXG4gIH1cXG5cXG4gIC8qXFxuICBDb3JyZWN0IHRoZSBpbmFiaWxpdHkgdG8gc3R5bGUgdGhlIGJvcmRlciByYWRpdXMgaW4gaU9TIFNhZmFyaS5cXG4qL1xcblxcbiAgYnV0dG9uLFxcbiAgaW5wdXQ6d2hlcmUoW3R5cGU9XFxcImJ1dHRvblxcXCJdLCBbdHlwZT1cXFwicmVzZXRcXFwiXSwgW3R5cGU9XFxcInN1Ym1pdFxcXCJdKSxcXG4gIDo6ZmlsZS1zZWxlY3Rvci1idXR0b24ge1xcbiAgICBhcHBlYXJhbmNlOiBidXR0b247XFxuICB9XFxuXFxuICAvKlxcbiAgQ29ycmVjdCB0aGUgY3Vyc29yIHN0eWxlIG9mIGluY3JlbWVudCBhbmQgZGVjcmVtZW50IGJ1dHRvbnMgaW4gU2FmYXJpLlxcbiovXFxuXFxuICA6Oi13ZWJraXQtaW5uZXItc3Bpbi1idXR0b24sXFxuICA6Oi13ZWJraXQtb3V0ZXItc3Bpbi1idXR0b24ge1xcbiAgICBoZWlnaHQ6IGF1dG87XFxuICB9XFxuXFxuICAvKlxcbiAgTWFrZSBlbGVtZW50cyB3aXRoIHRoZSBIVE1MIGhpZGRlbiBhdHRyaWJ1dGUgc3RheSBoaWRkZW4gYnkgZGVmYXVsdC5cXG4qL1xcblxcbiAgW2hpZGRlbl06d2hlcmUoOm5vdChbaGlkZGVuPVxcXCJ1bnRpbC1mb3VuZFxcXCJdKSkge1xcbiAgICBkaXNwbGF5OiBub25lICFpbXBvcnRhbnQ7XFxuICB9XFxufVxcblxcbkBsYXllciB1dGlsaXRpZXMge1xcbiAgQHRhaWx3aW5kIHV0aWxpdGllcztcXG59XFxuXCJdLFwic291cmNlUm9vdFwiOlwiXCJ9XSk7XG4vLyBFeHBvcnRzXG5leHBvcnQgZGVmYXVsdCBfX19DU1NfTE9BREVSX0VYUE9SVF9fXztcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/next/dist/build/webpack/loaders/css-loader/src/index.js??ruleSet[1].rules[7].oneOf[14].use[1]!./node_modules/next/dist/build/webpack/loaders/postcss-loader/src/index.js??ruleSet[1].rules[7].oneOf[14].use[2]!./styles/globals.css\n"));

/***/ }),

/***/ "./node_modules/next/dist/build/webpack/loaders/css-loader/src/runtime/api.js":
/*!************************************************************************************!*\
  !*** ./node_modules/next/dist/build/webpack/loaders/css-loader/src/runtime/api.js ***!
  \************************************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("/*\n  MIT License http://www.opensource.org/licenses/mit-license.php\n  Author Tobias Koppers @sokra\n*/ // css base code, injected by the css-loader\n// eslint-disable-next-line func-names\n\nmodule.exports = function(useSourceMap) {\n    var list = [] // return the list of modules as css string\n    ;\n    list.toString = function toString() {\n        return this.map(function(item) {\n            // eslint-disable-next-line @typescript-eslint/no-use-before-define\n            var content = cssWithMappingToString(item, useSourceMap);\n            if (item[2]) {\n                return \"@media \".concat(item[2], \" {\").concat(content, \"}\");\n            }\n            return content;\n        }).join(\"\");\n    } // import a list of modules into the list\n    ;\n    // eslint-disable-next-line func-names\n    // @ts-expect-error TODO: fix type\n    list.i = function(modules, mediaQuery, dedupe) {\n        if (typeof modules === \"string\") {\n            // eslint-disable-next-line no-param-reassign\n            modules = [\n                [\n                    null,\n                    modules,\n                    \"\"\n                ]\n            ];\n        }\n        var alreadyImportedModules = {};\n        if (dedupe) {\n            for(var i = 0; i < this.length; i++){\n                // eslint-disable-next-line prefer-destructuring\n                var id = this[i][0];\n                if (id != null) {\n                    alreadyImportedModules[id] = true;\n                }\n            }\n        }\n        for(var _i = 0; _i < modules.length; _i++){\n            var item = [].concat(modules[_i]);\n            if (dedupe && alreadyImportedModules[item[0]]) {\n                continue;\n            }\n            if (mediaQuery) {\n                if (!item[2]) {\n                    item[2] = mediaQuery;\n                } else {\n                    item[2] = \"\".concat(mediaQuery, \" and \").concat(item[2]);\n                }\n            }\n            list.push(item);\n        }\n    };\n    return list;\n};\nfunction cssWithMappingToString(item, useSourceMap) {\n    var content = item[1] || \"\" // eslint-disable-next-line prefer-destructuring\n    ;\n    var cssMapping = item[3];\n    if (!cssMapping) {\n        return content;\n    }\n    if (useSourceMap && typeof btoa === \"function\") {\n        // eslint-disable-next-line @typescript-eslint/no-use-before-define\n        var sourceMapping = toComment(cssMapping);\n        var sourceURLs = cssMapping.sources.map(function(source) {\n            return \"/*# sourceURL=\".concat(cssMapping.sourceRoot || \"\").concat(source, \" */\");\n        });\n        return [\n            content\n        ].concat(sourceURLs).concat([\n            sourceMapping\n        ]).join(\"\\n\");\n    }\n    return [\n        content\n    ].join(\"\\n\");\n} // Adapted from convert-source-map (MIT)\nfunction toComment(sourceMap) {\n    // eslint-disable-next-line no-undef\n    var base64 = btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap))));\n    var data = \"sourceMappingURL=data:application/json;charset=utf-8;base64,\".concat(base64);\n    return \"/*# \".concat(data, \" */\");\n}\n\n//# sourceMappingURL=api.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2J1aWxkL3dlYnBhY2svbG9hZGVycy9jc3MtbG9hZGVyL3NyYy9ydW50aW1lL2FwaS5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ2E7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0RBQW9ELHFCQUFxQjtBQUN6RTtBQUNBO0FBQ0EsU0FBUztBQUNULE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixpQkFBaUI7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IscUJBQXFCO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBLHVEQUF1RCxjQUFjO0FBQ3JFO0FBQ0E7O0FBRUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9idWlsZC93ZWJwYWNrL2xvYWRlcnMvY3NzLWxvYWRlci9zcmMvcnVudGltZS9hcGkuanM/Y2E0ZCJdLCJzb3VyY2VzQ29udGVudCI6WyIvKlxuICBNSVQgTGljZW5zZSBodHRwOi8vd3d3Lm9wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL21pdC1saWNlbnNlLnBocFxuICBBdXRob3IgVG9iaWFzIEtvcHBlcnMgQHNva3JhXG4qLyAvLyBjc3MgYmFzZSBjb2RlLCBpbmplY3RlZCBieSB0aGUgY3NzLWxvYWRlclxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGZ1bmMtbmFtZXNcblwidXNlIHN0cmljdFwiO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbih1c2VTb3VyY2VNYXApIHtcbiAgICB2YXIgbGlzdCA9IFtdIC8vIHJldHVybiB0aGUgbGlzdCBvZiBtb2R1bGVzIGFzIGNzcyBzdHJpbmdcbiAgICA7XG4gICAgbGlzdC50b1N0cmluZyA9IGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5tYXAoZnVuY3Rpb24oaXRlbSkge1xuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11c2UtYmVmb3JlLWRlZmluZVxuICAgICAgICAgICAgdmFyIGNvbnRlbnQgPSBjc3NXaXRoTWFwcGluZ1RvU3RyaW5nKGl0ZW0sIHVzZVNvdXJjZU1hcCk7XG4gICAgICAgICAgICBpZiAoaXRlbVsyXSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBcIkBtZWRpYSBcIi5jb25jYXQoaXRlbVsyXSwgXCIge1wiKS5jb25jYXQoY29udGVudCwgXCJ9XCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGNvbnRlbnQ7XG4gICAgICAgIH0pLmpvaW4oXCJcIik7XG4gICAgfSAvLyBpbXBvcnQgYSBsaXN0IG9mIG1vZHVsZXMgaW50byB0aGUgbGlzdFxuICAgIDtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZnVuYy1uYW1lc1xuICAgIC8vIEB0cy1leHBlY3QtZXJyb3IgVE9ETzogZml4IHR5cGVcbiAgICBsaXN0LmkgPSBmdW5jdGlvbihtb2R1bGVzLCBtZWRpYVF1ZXJ5LCBkZWR1cGUpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBtb2R1bGVzID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcGFyYW0tcmVhc3NpZ25cbiAgICAgICAgICAgIG1vZHVsZXMgPSBbXG4gICAgICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgICAgICBudWxsLFxuICAgICAgICAgICAgICAgICAgICBtb2R1bGVzLFxuICAgICAgICAgICAgICAgICAgICBcIlwiXG4gICAgICAgICAgICAgICAgXVxuICAgICAgICAgICAgXTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgYWxyZWFkeUltcG9ydGVkTW9kdWxlcyA9IHt9O1xuICAgICAgICBpZiAoZGVkdXBlKSB7XG4gICAgICAgICAgICBmb3IodmFyIGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkrKyl7XG4gICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHByZWZlci1kZXN0cnVjdHVyaW5nXG4gICAgICAgICAgICAgICAgdmFyIGlkID0gdGhpc1tpXVswXTtcbiAgICAgICAgICAgICAgICBpZiAoaWQgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBhbHJlYWR5SW1wb3J0ZWRNb2R1bGVzW2lkXSA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGZvcih2YXIgX2kgPSAwOyBfaSA8IG1vZHVsZXMubGVuZ3RoOyBfaSsrKXtcbiAgICAgICAgICAgIHZhciBpdGVtID0gW10uY29uY2F0KG1vZHVsZXNbX2ldKTtcbiAgICAgICAgICAgIGlmIChkZWR1cGUgJiYgYWxyZWFkeUltcG9ydGVkTW9kdWxlc1tpdGVtWzBdXSkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG1lZGlhUXVlcnkpIHtcbiAgICAgICAgICAgICAgICBpZiAoIWl0ZW1bMl0pIHtcbiAgICAgICAgICAgICAgICAgICAgaXRlbVsyXSA9IG1lZGlhUXVlcnk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaXRlbVsyXSA9IFwiXCIuY29uY2F0KG1lZGlhUXVlcnksIFwiIGFuZCBcIikuY29uY2F0KGl0ZW1bMl0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxpc3QucHVzaChpdGVtKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIGxpc3Q7XG59O1xuZnVuY3Rpb24gY3NzV2l0aE1hcHBpbmdUb1N0cmluZyhpdGVtLCB1c2VTb3VyY2VNYXApIHtcbiAgICB2YXIgY29udGVudCA9IGl0ZW1bMV0gfHwgXCJcIiAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcHJlZmVyLWRlc3RydWN0dXJpbmdcbiAgICA7XG4gICAgdmFyIGNzc01hcHBpbmcgPSBpdGVtWzNdO1xuICAgIGlmICghY3NzTWFwcGluZykge1xuICAgICAgICByZXR1cm4gY29udGVudDtcbiAgICB9XG4gICAgaWYgKHVzZVNvdXJjZU1hcCAmJiB0eXBlb2YgYnRvYSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdXNlLWJlZm9yZS1kZWZpbmVcbiAgICAgICAgdmFyIHNvdXJjZU1hcHBpbmcgPSB0b0NvbW1lbnQoY3NzTWFwcGluZyk7XG4gICAgICAgIHZhciBzb3VyY2VVUkxzID0gY3NzTWFwcGluZy5zb3VyY2VzLm1hcChmdW5jdGlvbihzb3VyY2UpIHtcbiAgICAgICAgICAgIHJldHVybiBcIi8qIyBzb3VyY2VVUkw9XCIuY29uY2F0KGNzc01hcHBpbmcuc291cmNlUm9vdCB8fCBcIlwiKS5jb25jYXQoc291cmNlLCBcIiAqL1wiKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICBjb250ZW50XG4gICAgICAgIF0uY29uY2F0KHNvdXJjZVVSTHMpLmNvbmNhdChbXG4gICAgICAgICAgICBzb3VyY2VNYXBwaW5nXG4gICAgICAgIF0pLmpvaW4oXCJcXG5cIik7XG4gICAgfVxuICAgIHJldHVybiBbXG4gICAgICAgIGNvbnRlbnRcbiAgICBdLmpvaW4oXCJcXG5cIik7XG59IC8vIEFkYXB0ZWQgZnJvbSBjb252ZXJ0LXNvdXJjZS1tYXAgKE1JVClcbmZ1bmN0aW9uIHRvQ29tbWVudChzb3VyY2VNYXApIHtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdW5kZWZcbiAgICB2YXIgYmFzZTY0ID0gYnRvYSh1bmVzY2FwZShlbmNvZGVVUklDb21wb25lbnQoSlNPTi5zdHJpbmdpZnkoc291cmNlTWFwKSkpKTtcbiAgICB2YXIgZGF0YSA9IFwic291cmNlTWFwcGluZ1VSTD1kYXRhOmFwcGxpY2F0aW9uL2pzb247Y2hhcnNldD11dGYtODtiYXNlNjQsXCIuY29uY2F0KGJhc2U2NCk7XG4gICAgcmV0dXJuIFwiLyojIFwiLmNvbmNhdChkYXRhLCBcIiAqL1wiKTtcbn1cblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YXBpLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/next/dist/build/webpack/loaders/css-loader/src/runtime/api.js\n"));

/***/ }),

/***/ "./node_modules/next/dist/build/webpack/loaders/next-client-pages-loader.js?absolutePagePath=private-next-pages%2F_app&page=%2F_app!":
/*!*******************************************************************************************************************************************!*\
  !*** ./node_modules/next/dist/build/webpack/loaders/next-client-pages-loader.js?absolutePagePath=private-next-pages%2F_app&page=%2F_app! ***!
  \*******************************************************************************************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("\n    (window.__NEXT_P = window.__NEXT_P || []).push([\n      \"/_app\",\n      function () {\n        return __webpack_require__(/*! private-next-pages/_app */ \"./pages/_app.jsx\");\n      }\n    ]);\n    if(true) {\n      module.hot.dispose(function () {\n        window.__NEXT_P.push([\"/_app\"])\n      });\n    }\n  //# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2J1aWxkL3dlYnBhY2svbG9hZGVycy9uZXh0LWNsaWVudC1wYWdlcy1sb2FkZXIuanM/YWJzb2x1dGVQYWdlUGF0aD1wcml2YXRlLW5leHQtcGFnZXMlMkZfYXBwJnBhZ2U9JTJGX2FwcCEiLCJtYXBwaW5ncyI6IjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsbUJBQU8sQ0FBQyxpREFBeUI7QUFDaEQ7QUFDQTtBQUNBLE9BQU8sSUFBVTtBQUNqQixNQUFNLFVBQVU7QUFDaEI7QUFDQSxPQUFPO0FBQ1A7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvPzY3ODIiXSwic291cmNlc0NvbnRlbnQiOlsiXG4gICAgKHdpbmRvdy5fX05FWFRfUCA9IHdpbmRvdy5fX05FWFRfUCB8fCBbXSkucHVzaChbXG4gICAgICBcIi9fYXBwXCIsXG4gICAgICBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiByZXF1aXJlKFwicHJpdmF0ZS1uZXh0LXBhZ2VzL19hcHBcIik7XG4gICAgICB9XG4gICAgXSk7XG4gICAgaWYobW9kdWxlLmhvdCkge1xuICAgICAgbW9kdWxlLmhvdC5kaXNwb3NlKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgd2luZG93Ll9fTkVYVF9QLnB1c2goW1wiL19hcHBcIl0pXG4gICAgICB9KTtcbiAgICB9XG4gICJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/next/dist/build/webpack/loaders/next-client-pages-loader.js?absolutePagePath=private-next-pages%2F_app&page=%2F_app!\n"));

/***/ }),

/***/ "./node_modules/react-toastify/dist/ReactToastify.css":
/*!************************************************************!*\
  !*** ./node_modules/react-toastify/dist/ReactToastify.css ***!
  \************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("var api = __webpack_require__(/*! !../../next/dist/build/webpack/loaders/next-style-loader/runtime/injectStylesIntoStyleTag.js */ \"./node_modules/next/dist/build/webpack/loaders/next-style-loader/runtime/injectStylesIntoStyleTag.js\");\n            var content = __webpack_require__(/*! !!../../next/dist/build/webpack/loaders/css-loader/src/index.js??ruleSet[1].rules[7].oneOf[12].use[1]!../../next/dist/build/webpack/loaders/postcss-loader/src/index.js??ruleSet[1].rules[7].oneOf[12].use[2]!./ReactToastify.css */ \"./node_modules/next/dist/build/webpack/loaders/css-loader/src/index.js??ruleSet[1].rules[7].oneOf[12].use[1]!./node_modules/next/dist/build/webpack/loaders/postcss-loader/src/index.js??ruleSet[1].rules[7].oneOf[12].use[2]!./node_modules/react-toastify/dist/ReactToastify.css\");\n\n            content = content.__esModule ? content.default : content;\n\n            if (typeof content === 'string') {\n              content = [[module.id, content, '']];\n            }\n\nvar options = {};\n\noptions.insert = function(element) {\n                    // By default, style-loader injects CSS into the bottom\n                    // of <head>. This causes ordering problems between dev\n                    // and prod. To fix this, we render a <noscript> tag as\n                    // an anchor for the styles to be placed before. These\n                    // styles will be applied _before_ <style jsx global>.\n                    // These elements should always exist. If they do not,\n                    // this code should fail.\n                    var anchorElement = document.querySelector(\"#__next_css__DO_NOT_USE__\");\n                    var parentNode = anchorElement.parentNode// Normally <head>\n                    ;\n                    // Each style tag should be placed right before our\n                    // anchor. By inserting before and not after, we do not\n                    // need to track the last inserted element.\n                    parentNode.insertBefore(element, anchorElement);\n                };\noptions.singleton = false;\n\nvar update = api(content, options);\n\n\nif (true) {\n  if (!content.locals || module.hot.invalidate) {\n    var isEqualLocals = function isEqualLocals(a, b, isNamedExport) {\n    if (!a && b || a && !b) {\n        return false;\n    }\n    let p;\n    for(p in a){\n        if (isNamedExport && p === \"default\") {\n            continue;\n        }\n        if (a[p] !== b[p]) {\n            return false;\n        }\n    }\n    for(p in b){\n        if (isNamedExport && p === \"default\") {\n            continue;\n        }\n        if (!a[p]) {\n            return false;\n        }\n    }\n    return true;\n};\n    var oldLocals = content.locals;\n\n    module.hot.accept(\n      /*! !!../../next/dist/build/webpack/loaders/css-loader/src/index.js??ruleSet[1].rules[7].oneOf[12].use[1]!../../next/dist/build/webpack/loaders/postcss-loader/src/index.js??ruleSet[1].rules[7].oneOf[12].use[2]!./ReactToastify.css */ \"./node_modules/next/dist/build/webpack/loaders/css-loader/src/index.js??ruleSet[1].rules[7].oneOf[12].use[1]!./node_modules/next/dist/build/webpack/loaders/postcss-loader/src/index.js??ruleSet[1].rules[7].oneOf[12].use[2]!./node_modules/react-toastify/dist/ReactToastify.css\",\n      function () {\n        content = __webpack_require__(/*! !!../../next/dist/build/webpack/loaders/css-loader/src/index.js??ruleSet[1].rules[7].oneOf[12].use[1]!../../next/dist/build/webpack/loaders/postcss-loader/src/index.js??ruleSet[1].rules[7].oneOf[12].use[2]!./ReactToastify.css */ \"./node_modules/next/dist/build/webpack/loaders/css-loader/src/index.js??ruleSet[1].rules[7].oneOf[12].use[1]!./node_modules/next/dist/build/webpack/loaders/postcss-loader/src/index.js??ruleSet[1].rules[7].oneOf[12].use[2]!./node_modules/react-toastify/dist/ReactToastify.css\");\n\n              content = content.__esModule ? content.default : content;\n\n              if (typeof content === 'string') {\n                content = [[module.id, content, '']];\n              }\n\n              if (!isEqualLocals(oldLocals, content.locals)) {\n                module.hot.invalidate();\n\n                return;\n              }\n\n              oldLocals = content.locals;\n\n              update(content);\n      }\n    )\n  }\n\n  module.hot.dispose(function() {\n    update();\n  });\n}\n\nmodule.exports = content.locals || {};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcmVhY3QtdG9hc3RpZnkvZGlzdC9SZWFjdFRvYXN0aWZ5LmNzcyIsIm1hcHBpbmdzIjoiQUFBQSxVQUFVLG1CQUFPLENBQUMsME1BQThGO0FBQ2hILDBCQUEwQixtQkFBTyxDQUFDLDZmQUFtTzs7QUFFclE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7OztBQUdBLElBQUksSUFBVTtBQUNkLHlCQUF5QixVQUFVO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxJQUFJLGlCQUFpQjtBQUNyQixNQUFNLDZmQUFtTztBQUN6TztBQUNBLGtCQUFrQixtQkFBTyxDQUFDLDZmQUFtTzs7QUFFN1A7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZ0JBQWdCLFVBQVU7O0FBRTFCO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsRUFBRSxVQUFVO0FBQ1o7QUFDQSxHQUFHO0FBQ0g7O0FBRUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL3JlYWN0LXRvYXN0aWZ5L2Rpc3QvUmVhY3RUb2FzdGlmeS5jc3M/NGQwOSJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgYXBpID0gcmVxdWlyZShcIiEuLi8uLi9uZXh0L2Rpc3QvYnVpbGQvd2VicGFjay9sb2FkZXJzL25leHQtc3R5bGUtbG9hZGVyL3J1bnRpbWUvaW5qZWN0U3R5bGVzSW50b1N0eWxlVGFnLmpzXCIpO1xuICAgICAgICAgICAgdmFyIGNvbnRlbnQgPSByZXF1aXJlKFwiISEuLi8uLi9uZXh0L2Rpc3QvYnVpbGQvd2VicGFjay9sb2FkZXJzL2Nzcy1sb2FkZXIvc3JjL2luZGV4LmpzPz9ydWxlU2V0WzFdLnJ1bGVzWzddLm9uZU9mWzEyXS51c2VbMV0hLi4vLi4vbmV4dC9kaXN0L2J1aWxkL3dlYnBhY2svbG9hZGVycy9wb3N0Y3NzLWxvYWRlci9zcmMvaW5kZXguanM/P3J1bGVTZXRbMV0ucnVsZXNbN10ub25lT2ZbMTJdLnVzZVsyXSEuL1JlYWN0VG9hc3RpZnkuY3NzXCIpO1xuXG4gICAgICAgICAgICBjb250ZW50ID0gY29udGVudC5fX2VzTW9kdWxlID8gY29udGVudC5kZWZhdWx0IDogY29udGVudDtcblxuICAgICAgICAgICAgaWYgKHR5cGVvZiBjb250ZW50ID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICBjb250ZW50ID0gW1ttb2R1bGUuaWQsIGNvbnRlbnQsICcnXV07XG4gICAgICAgICAgICB9XG5cbnZhciBvcHRpb25zID0ge307XG5cbm9wdGlvbnMuaW5zZXJ0ID0gZnVuY3Rpb24oZWxlbWVudCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBCeSBkZWZhdWx0LCBzdHlsZS1sb2FkZXIgaW5qZWN0cyBDU1MgaW50byB0aGUgYm90dG9tXG4gICAgICAgICAgICAgICAgICAgIC8vIG9mIDxoZWFkPi4gVGhpcyBjYXVzZXMgb3JkZXJpbmcgcHJvYmxlbXMgYmV0d2VlbiBkZXZcbiAgICAgICAgICAgICAgICAgICAgLy8gYW5kIHByb2QuIFRvIGZpeCB0aGlzLCB3ZSByZW5kZXIgYSA8bm9zY3JpcHQ+IHRhZyBhc1xuICAgICAgICAgICAgICAgICAgICAvLyBhbiBhbmNob3IgZm9yIHRoZSBzdHlsZXMgdG8gYmUgcGxhY2VkIGJlZm9yZS4gVGhlc2VcbiAgICAgICAgICAgICAgICAgICAgLy8gc3R5bGVzIHdpbGwgYmUgYXBwbGllZCBfYmVmb3JlXyA8c3R5bGUganN4IGdsb2JhbD4uXG4gICAgICAgICAgICAgICAgICAgIC8vIFRoZXNlIGVsZW1lbnRzIHNob3VsZCBhbHdheXMgZXhpc3QuIElmIHRoZXkgZG8gbm90LFxuICAgICAgICAgICAgICAgICAgICAvLyB0aGlzIGNvZGUgc2hvdWxkIGZhaWwuXG4gICAgICAgICAgICAgICAgICAgIHZhciBhbmNob3JFbGVtZW50ID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihcIiNfX25leHRfY3NzX19ET19OT1RfVVNFX19cIik7XG4gICAgICAgICAgICAgICAgICAgIHZhciBwYXJlbnROb2RlID0gYW5jaG9yRWxlbWVudC5wYXJlbnROb2RlLy8gTm9ybWFsbHkgPGhlYWQ+XG4gICAgICAgICAgICAgICAgICAgIDtcbiAgICAgICAgICAgICAgICAgICAgLy8gRWFjaCBzdHlsZSB0YWcgc2hvdWxkIGJlIHBsYWNlZCByaWdodCBiZWZvcmUgb3VyXG4gICAgICAgICAgICAgICAgICAgIC8vIGFuY2hvci4gQnkgaW5zZXJ0aW5nIGJlZm9yZSBhbmQgbm90IGFmdGVyLCB3ZSBkbyBub3RcbiAgICAgICAgICAgICAgICAgICAgLy8gbmVlZCB0byB0cmFjayB0aGUgbGFzdCBpbnNlcnRlZCBlbGVtZW50LlxuICAgICAgICAgICAgICAgICAgICBwYXJlbnROb2RlLmluc2VydEJlZm9yZShlbGVtZW50LCBhbmNob3JFbGVtZW50KTtcbiAgICAgICAgICAgICAgICB9O1xub3B0aW9ucy5zaW5nbGV0b24gPSBmYWxzZTtcblxudmFyIHVwZGF0ZSA9IGFwaShjb250ZW50LCBvcHRpb25zKTtcblxuXG5pZiAobW9kdWxlLmhvdCkge1xuICBpZiAoIWNvbnRlbnQubG9jYWxzIHx8IG1vZHVsZS5ob3QuaW52YWxpZGF0ZSkge1xuICAgIHZhciBpc0VxdWFsTG9jYWxzID0gZnVuY3Rpb24gaXNFcXVhbExvY2FscyhhLCBiLCBpc05hbWVkRXhwb3J0KSB7XG4gICAgaWYgKCFhICYmIGIgfHwgYSAmJiAhYikge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGxldCBwO1xuICAgIGZvcihwIGluIGEpe1xuICAgICAgICBpZiAoaXNOYW1lZEV4cG9ydCAmJiBwID09PSBcImRlZmF1bHRcIikge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGFbcF0gIT09IGJbcF0pIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBmb3IocCBpbiBiKXtcbiAgICAgICAgaWYgKGlzTmFtZWRFeHBvcnQgJiYgcCA9PT0gXCJkZWZhdWx0XCIpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmICghYVtwXSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xufTtcbiAgICB2YXIgb2xkTG9jYWxzID0gY29udGVudC5sb2NhbHM7XG5cbiAgICBtb2R1bGUuaG90LmFjY2VwdChcbiAgICAgIFwiISEuLi8uLi9uZXh0L2Rpc3QvYnVpbGQvd2VicGFjay9sb2FkZXJzL2Nzcy1sb2FkZXIvc3JjL2luZGV4LmpzPz9ydWxlU2V0WzFdLnJ1bGVzWzddLm9uZU9mWzEyXS51c2VbMV0hLi4vLi4vbmV4dC9kaXN0L2J1aWxkL3dlYnBhY2svbG9hZGVycy9wb3N0Y3NzLWxvYWRlci9zcmMvaW5kZXguanM/P3J1bGVTZXRbMV0ucnVsZXNbN10ub25lT2ZbMTJdLnVzZVsyXSEuL1JlYWN0VG9hc3RpZnkuY3NzXCIsXG4gICAgICBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGNvbnRlbnQgPSByZXF1aXJlKFwiISEuLi8uLi9uZXh0L2Rpc3QvYnVpbGQvd2VicGFjay9sb2FkZXJzL2Nzcy1sb2FkZXIvc3JjL2luZGV4LmpzPz9ydWxlU2V0WzFdLnJ1bGVzWzddLm9uZU9mWzEyXS51c2VbMV0hLi4vLi4vbmV4dC9kaXN0L2J1aWxkL3dlYnBhY2svbG9hZGVycy9wb3N0Y3NzLWxvYWRlci9zcmMvaW5kZXguanM/P3J1bGVTZXRbMV0ucnVsZXNbN10ub25lT2ZbMTJdLnVzZVsyXSEuL1JlYWN0VG9hc3RpZnkuY3NzXCIpO1xuXG4gICAgICAgICAgICAgIGNvbnRlbnQgPSBjb250ZW50Ll9fZXNNb2R1bGUgPyBjb250ZW50LmRlZmF1bHQgOiBjb250ZW50O1xuXG4gICAgICAgICAgICAgIGlmICh0eXBlb2YgY29udGVudCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICBjb250ZW50ID0gW1ttb2R1bGUuaWQsIGNvbnRlbnQsICcnXV07XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBpZiAoIWlzRXF1YWxMb2NhbHMob2xkTG9jYWxzLCBjb250ZW50LmxvY2FscykpIHtcbiAgICAgICAgICAgICAgICBtb2R1bGUuaG90LmludmFsaWRhdGUoKTtcblxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIG9sZExvY2FscyA9IGNvbnRlbnQubG9jYWxzO1xuXG4gICAgICAgICAgICAgIHVwZGF0ZShjb250ZW50KTtcbiAgICAgIH1cbiAgICApXG4gIH1cblxuICBtb2R1bGUuaG90LmRpc3Bvc2UoZnVuY3Rpb24oKSB7XG4gICAgdXBkYXRlKCk7XG4gIH0pO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNvbnRlbnQubG9jYWxzIHx8IHt9OyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/react-toastify/dist/ReactToastify.css\n"));

/***/ }),

/***/ "./styles/globals.css":
/*!****************************!*\
  !*** ./styles/globals.css ***!
  \****************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("var api = __webpack_require__(/*! !../node_modules/next/dist/build/webpack/loaders/next-style-loader/runtime/injectStylesIntoStyleTag.js */ \"./node_modules/next/dist/build/webpack/loaders/next-style-loader/runtime/injectStylesIntoStyleTag.js\");\n            var content = __webpack_require__(/*! !!../node_modules/next/dist/build/webpack/loaders/css-loader/src/index.js??ruleSet[1].rules[7].oneOf[14].use[1]!../node_modules/next/dist/build/webpack/loaders/postcss-loader/src/index.js??ruleSet[1].rules[7].oneOf[14].use[2]!./globals.css */ \"./node_modules/next/dist/build/webpack/loaders/css-loader/src/index.js??ruleSet[1].rules[7].oneOf[14].use[1]!./node_modules/next/dist/build/webpack/loaders/postcss-loader/src/index.js??ruleSet[1].rules[7].oneOf[14].use[2]!./styles/globals.css\");\n\n            content = content.__esModule ? content.default : content;\n\n            if (typeof content === 'string') {\n              content = [[module.id, content, '']];\n            }\n\nvar options = {};\n\noptions.insert = function(element) {\n                    // By default, style-loader injects CSS into the bottom\n                    // of <head>. This causes ordering problems between dev\n                    // and prod. To fix this, we render a <noscript> tag as\n                    // an anchor for the styles to be placed before. These\n                    // styles will be applied _before_ <style jsx global>.\n                    // These elements should always exist. If they do not,\n                    // this code should fail.\n                    var anchorElement = document.querySelector(\"#__next_css__DO_NOT_USE__\");\n                    var parentNode = anchorElement.parentNode// Normally <head>\n                    ;\n                    // Each style tag should be placed right before our\n                    // anchor. By inserting before and not after, we do not\n                    // need to track the last inserted element.\n                    parentNode.insertBefore(element, anchorElement);\n                };\noptions.singleton = false;\n\nvar update = api(content, options);\n\n\nif (true) {\n  if (!content.locals || module.hot.invalidate) {\n    var isEqualLocals = function isEqualLocals(a, b, isNamedExport) {\n    if (!a && b || a && !b) {\n        return false;\n    }\n    let p;\n    for(p in a){\n        if (isNamedExport && p === \"default\") {\n            continue;\n        }\n        if (a[p] !== b[p]) {\n            return false;\n        }\n    }\n    for(p in b){\n        if (isNamedExport && p === \"default\") {\n            continue;\n        }\n        if (!a[p]) {\n            return false;\n        }\n    }\n    return true;\n};\n    var oldLocals = content.locals;\n\n    module.hot.accept(\n      /*! !!../node_modules/next/dist/build/webpack/loaders/css-loader/src/index.js??ruleSet[1].rules[7].oneOf[14].use[1]!../node_modules/next/dist/build/webpack/loaders/postcss-loader/src/index.js??ruleSet[1].rules[7].oneOf[14].use[2]!./globals.css */ \"./node_modules/next/dist/build/webpack/loaders/css-loader/src/index.js??ruleSet[1].rules[7].oneOf[14].use[1]!./node_modules/next/dist/build/webpack/loaders/postcss-loader/src/index.js??ruleSet[1].rules[7].oneOf[14].use[2]!./styles/globals.css\",\n      function () {\n        content = __webpack_require__(/*! !!../node_modules/next/dist/build/webpack/loaders/css-loader/src/index.js??ruleSet[1].rules[7].oneOf[14].use[1]!../node_modules/next/dist/build/webpack/loaders/postcss-loader/src/index.js??ruleSet[1].rules[7].oneOf[14].use[2]!./globals.css */ \"./node_modules/next/dist/build/webpack/loaders/css-loader/src/index.js??ruleSet[1].rules[7].oneOf[14].use[1]!./node_modules/next/dist/build/webpack/loaders/postcss-loader/src/index.js??ruleSet[1].rules[7].oneOf[14].use[2]!./styles/globals.css\");\n\n              content = content.__esModule ? content.default : content;\n\n              if (typeof content === 'string') {\n                content = [[module.id, content, '']];\n              }\n\n              if (!isEqualLocals(oldLocals, content.locals)) {\n                module.hot.invalidate();\n\n                return;\n              }\n\n              oldLocals = content.locals;\n\n              update(content);\n      }\n    )\n  }\n\n  module.hot.dispose(function() {\n    update();\n  });\n}\n\nmodule.exports = content.locals || {};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zdHlsZXMvZ2xvYmFscy5jc3MiLCJtYXBwaW5ncyI6IkFBQUEsVUFBVSxtQkFBTyxDQUFDLG9OQUF3RztBQUMxSCwwQkFBMEIsbUJBQU8sQ0FBQywyZUFBaVA7O0FBRW5SOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7QUFHQSxJQUFJLElBQVU7QUFDZCx5QkFBeUIsVUFBVTtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsSUFBSSxpQkFBaUI7QUFDckIsTUFBTSwyZUFBaVA7QUFDdlA7QUFDQSxrQkFBa0IsbUJBQU8sQ0FBQywyZUFBaVA7O0FBRTNROztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGdCQUFnQixVQUFVOztBQUUxQjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEVBQUUsVUFBVTtBQUNaO0FBQ0EsR0FBRztBQUNIOztBQUVBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL3N0eWxlcy9nbG9iYWxzLmNzcz83MGE0Il0sInNvdXJjZXNDb250ZW50IjpbInZhciBhcGkgPSByZXF1aXJlKFwiIS4uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvYnVpbGQvd2VicGFjay9sb2FkZXJzL25leHQtc3R5bGUtbG9hZGVyL3J1bnRpbWUvaW5qZWN0U3R5bGVzSW50b1N0eWxlVGFnLmpzXCIpO1xuICAgICAgICAgICAgdmFyIGNvbnRlbnQgPSByZXF1aXJlKFwiISEuLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2J1aWxkL3dlYnBhY2svbG9hZGVycy9jc3MtbG9hZGVyL3NyYy9pbmRleC5qcz8/cnVsZVNldFsxXS5ydWxlc1s3XS5vbmVPZlsxNF0udXNlWzFdIS4uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvYnVpbGQvd2VicGFjay9sb2FkZXJzL3Bvc3Rjc3MtbG9hZGVyL3NyYy9pbmRleC5qcz8/cnVsZVNldFsxXS5ydWxlc1s3XS5vbmVPZlsxNF0udXNlWzJdIS4vZ2xvYmFscy5jc3NcIik7XG5cbiAgICAgICAgICAgIGNvbnRlbnQgPSBjb250ZW50Ll9fZXNNb2R1bGUgPyBjb250ZW50LmRlZmF1bHQgOiBjb250ZW50O1xuXG4gICAgICAgICAgICBpZiAodHlwZW9mIGNvbnRlbnQgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgIGNvbnRlbnQgPSBbW21vZHVsZS5pZCwgY29udGVudCwgJyddXTtcbiAgICAgICAgICAgIH1cblxudmFyIG9wdGlvbnMgPSB7fTtcblxub3B0aW9ucy5pbnNlcnQgPSBmdW5jdGlvbihlbGVtZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIEJ5IGRlZmF1bHQsIHN0eWxlLWxvYWRlciBpbmplY3RzIENTUyBpbnRvIHRoZSBib3R0b21cbiAgICAgICAgICAgICAgICAgICAgLy8gb2YgPGhlYWQ+LiBUaGlzIGNhdXNlcyBvcmRlcmluZyBwcm9ibGVtcyBiZXR3ZWVuIGRldlxuICAgICAgICAgICAgICAgICAgICAvLyBhbmQgcHJvZC4gVG8gZml4IHRoaXMsIHdlIHJlbmRlciBhIDxub3NjcmlwdD4gdGFnIGFzXG4gICAgICAgICAgICAgICAgICAgIC8vIGFuIGFuY2hvciBmb3IgdGhlIHN0eWxlcyB0byBiZSBwbGFjZWQgYmVmb3JlLiBUaGVzZVxuICAgICAgICAgICAgICAgICAgICAvLyBzdHlsZXMgd2lsbCBiZSBhcHBsaWVkIF9iZWZvcmVfIDxzdHlsZSBqc3ggZ2xvYmFsPi5cbiAgICAgICAgICAgICAgICAgICAgLy8gVGhlc2UgZWxlbWVudHMgc2hvdWxkIGFsd2F5cyBleGlzdC4gSWYgdGhleSBkbyBub3QsXG4gICAgICAgICAgICAgICAgICAgIC8vIHRoaXMgY29kZSBzaG91bGQgZmFpbC5cbiAgICAgICAgICAgICAgICAgICAgdmFyIGFuY2hvckVsZW1lbnQgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKFwiI19fbmV4dF9jc3NfX0RPX05PVF9VU0VfX1wiKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHBhcmVudE5vZGUgPSBhbmNob3JFbGVtZW50LnBhcmVudE5vZGUvLyBOb3JtYWxseSA8aGVhZD5cbiAgICAgICAgICAgICAgICAgICAgO1xuICAgICAgICAgICAgICAgICAgICAvLyBFYWNoIHN0eWxlIHRhZyBzaG91bGQgYmUgcGxhY2VkIHJpZ2h0IGJlZm9yZSBvdXJcbiAgICAgICAgICAgICAgICAgICAgLy8gYW5jaG9yLiBCeSBpbnNlcnRpbmcgYmVmb3JlIGFuZCBub3QgYWZ0ZXIsIHdlIGRvIG5vdFxuICAgICAgICAgICAgICAgICAgICAvLyBuZWVkIHRvIHRyYWNrIHRoZSBsYXN0IGluc2VydGVkIGVsZW1lbnQuXG4gICAgICAgICAgICAgICAgICAgIHBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKGVsZW1lbnQsIGFuY2hvckVsZW1lbnQpO1xuICAgICAgICAgICAgICAgIH07XG5vcHRpb25zLnNpbmdsZXRvbiA9IGZhbHNlO1xuXG52YXIgdXBkYXRlID0gYXBpKGNvbnRlbnQsIG9wdGlvbnMpO1xuXG5cbmlmIChtb2R1bGUuaG90KSB7XG4gIGlmICghY29udGVudC5sb2NhbHMgfHwgbW9kdWxlLmhvdC5pbnZhbGlkYXRlKSB7XG4gICAgdmFyIGlzRXF1YWxMb2NhbHMgPSBmdW5jdGlvbiBpc0VxdWFsTG9jYWxzKGEsIGIsIGlzTmFtZWRFeHBvcnQpIHtcbiAgICBpZiAoIWEgJiYgYiB8fCBhICYmICFiKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgbGV0IHA7XG4gICAgZm9yKHAgaW4gYSl7XG4gICAgICAgIGlmIChpc05hbWVkRXhwb3J0ICYmIHAgPT09IFwiZGVmYXVsdFwiKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYVtwXSAhPT0gYltwXSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuICAgIGZvcihwIGluIGIpe1xuICAgICAgICBpZiAoaXNOYW1lZEV4cG9ydCAmJiBwID09PSBcImRlZmF1bHRcIikge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFhW3BdKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG59O1xuICAgIHZhciBvbGRMb2NhbHMgPSBjb250ZW50LmxvY2FscztcblxuICAgIG1vZHVsZS5ob3QuYWNjZXB0KFxuICAgICAgXCIhIS4uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvYnVpbGQvd2VicGFjay9sb2FkZXJzL2Nzcy1sb2FkZXIvc3JjL2luZGV4LmpzPz9ydWxlU2V0WzFdLnJ1bGVzWzddLm9uZU9mWzE0XS51c2VbMV0hLi4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9idWlsZC93ZWJwYWNrL2xvYWRlcnMvcG9zdGNzcy1sb2FkZXIvc3JjL2luZGV4LmpzPz9ydWxlU2V0WzFdLnJ1bGVzWzddLm9uZU9mWzE0XS51c2VbMl0hLi9nbG9iYWxzLmNzc1wiLFxuICAgICAgZnVuY3Rpb24gKCkge1xuICAgICAgICBjb250ZW50ID0gcmVxdWlyZShcIiEhLi4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9idWlsZC93ZWJwYWNrL2xvYWRlcnMvY3NzLWxvYWRlci9zcmMvaW5kZXguanM/P3J1bGVTZXRbMV0ucnVsZXNbN10ub25lT2ZbMTRdLnVzZVsxXSEuLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2J1aWxkL3dlYnBhY2svbG9hZGVycy9wb3N0Y3NzLWxvYWRlci9zcmMvaW5kZXguanM/P3J1bGVTZXRbMV0ucnVsZXNbN10ub25lT2ZbMTRdLnVzZVsyXSEuL2dsb2JhbHMuY3NzXCIpO1xuXG4gICAgICAgICAgICAgIGNvbnRlbnQgPSBjb250ZW50Ll9fZXNNb2R1bGUgPyBjb250ZW50LmRlZmF1bHQgOiBjb250ZW50O1xuXG4gICAgICAgICAgICAgIGlmICh0eXBlb2YgY29udGVudCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICBjb250ZW50ID0gW1ttb2R1bGUuaWQsIGNvbnRlbnQsICcnXV07XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBpZiAoIWlzRXF1YWxMb2NhbHMob2xkTG9jYWxzLCBjb250ZW50LmxvY2FscykpIHtcbiAgICAgICAgICAgICAgICBtb2R1bGUuaG90LmludmFsaWRhdGUoKTtcblxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIG9sZExvY2FscyA9IGNvbnRlbnQubG9jYWxzO1xuXG4gICAgICAgICAgICAgIHVwZGF0ZShjb250ZW50KTtcbiAgICAgIH1cbiAgICApXG4gIH1cblxuICBtb2R1bGUuaG90LmRpc3Bvc2UoZnVuY3Rpb24oKSB7XG4gICAgdXBkYXRlKCk7XG4gIH0pO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNvbnRlbnQubG9jYWxzIHx8IHt9OyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./styles/globals.css\n"));

/***/ }),

/***/ "./node_modules/next/dist/build/webpack/loaders/next-style-loader/runtime/injectStylesIntoStyleTag.js":
/*!************************************************************************************************************!*\
  !*** ./node_modules/next/dist/build/webpack/loaders/next-style-loader/runtime/injectStylesIntoStyleTag.js ***!
  \************************************************************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nconst isOldIE = function isOldIE() {\n    let memo;\n    return function memorize() {\n        if (typeof memo === \"undefined\") {\n            // Test for IE <= 9 as proposed by Browserhacks\n            // @see http://browserhacks.com/#hack-e71d8692f65334173fee715c222cb805\n            // Tests for existence of standard globals is to allow style-loader\n            // to operate correctly into non-standard environments\n            // @see https://github.com/webpack-contrib/style-loader/issues/177\n            memo = Boolean(window && document && document.all && !window.atob);\n        }\n        return memo;\n    };\n}();\nconst getTargetElement = function() {\n    const memo = {};\n    return function memorize(target) {\n        if (typeof memo[target] === \"undefined\") {\n            let styleTarget = document.querySelector(target);\n            // Special case to return head of iframe instead of iframe itself\n            if (window.HTMLIFrameElement && styleTarget instanceof window.HTMLIFrameElement) {\n                try {\n                    // This will throw an exception if access to iframe is blocked\n                    // due to cross-origin restrictions\n                    styleTarget = styleTarget.contentDocument.head;\n                } catch (e) {\n                    // istanbul ignore next\n                    styleTarget = null;\n                }\n            }\n            memo[target] = styleTarget;\n        }\n        return memo[target];\n    };\n}();\nconst stylesInDom = [];\nfunction getIndexByIdentifier(identifier) {\n    let result = -1;\n    for(let i = 0; i < stylesInDom.length; i++){\n        if (stylesInDom[i].identifier === identifier) {\n            result = i;\n            break;\n        }\n    }\n    return result;\n}\nfunction modulesToDom(list, options) {\n    const idCountMap = {};\n    const identifiers = [];\n    for(let i = 0; i < list.length; i++){\n        const item = list[i];\n        const id = options.base ? item[0] + options.base : item[0];\n        const count = idCountMap[id] || 0;\n        const identifier = id + \" \" + count.toString();\n        idCountMap[id] = count + 1;\n        const index = getIndexByIdentifier(identifier);\n        const obj = {\n            css: item[1],\n            media: item[2],\n            sourceMap: item[3]\n        };\n        if (index !== -1) {\n            stylesInDom[index].references++;\n            stylesInDom[index].updater(obj);\n        } else {\n            stylesInDom.push({\n                identifier: identifier,\n                // eslint-disable-next-line @typescript-eslint/no-use-before-define\n                updater: addStyle(obj, options),\n                references: 1\n            });\n        }\n        identifiers.push(identifier);\n    }\n    return identifiers;\n}\nfunction insertStyleElement(options) {\n    const style = document.createElement(\"style\");\n    const attributes = options.attributes || {};\n    if (typeof attributes.nonce === \"undefined\") {\n        const nonce = // eslint-disable-next-line no-undef\n         true ? __webpack_require__.nc : 0;\n        if (nonce) {\n            attributes.nonce = nonce;\n        }\n    }\n    Object.keys(attributes).forEach(function(key) {\n        style.setAttribute(key, attributes[key]);\n    });\n    if (typeof options.insert === \"function\") {\n        options.insert(style);\n    } else {\n        const target = getTargetElement(options.insert || \"head\");\n        if (!target) {\n            throw new Error(\"Couldn't find a style target. This probably means that the value for the 'insert' parameter is invalid.\");\n        }\n        target.appendChild(style);\n    }\n    return style;\n}\nfunction removeStyleElement(style) {\n    // istanbul ignore if\n    if (style.parentNode === null) {\n        return false;\n    }\n    style.parentNode.removeChild(style);\n}\n/* istanbul ignore next  */ const replaceText = function replaceText() {\n    const textStore = [];\n    return function replace(index, replacement) {\n        textStore[index] = replacement;\n        return textStore.filter(Boolean).join(\"\\n\");\n    };\n}();\nfunction applyToSingletonTag(style, index, remove, obj) {\n    const css = remove ? \"\" : obj.media ? \"@media \" + obj.media + \" {\" + obj.css + \"}\" : obj.css;\n    // For old IE\n    /* istanbul ignore if  */ if (style.styleSheet) {\n        style.styleSheet.cssText = replaceText(index, css);\n    } else {\n        const cssNode = document.createTextNode(css);\n        const childNodes = style.childNodes;\n        if (childNodes[index]) {\n            style.removeChild(childNodes[index]);\n        }\n        if (childNodes.length) {\n            style.insertBefore(cssNode, childNodes[index]);\n        } else {\n            style.appendChild(cssNode);\n        }\n    }\n}\nfunction applyToTag(style, _options, obj) {\n    let css = obj.css;\n    const media = obj.media;\n    const sourceMap = obj.sourceMap;\n    if (media) {\n        style.setAttribute(\"media\", media);\n    } else {\n        style.removeAttribute(\"media\");\n    }\n    if (sourceMap && typeof btoa !== \"undefined\") {\n        css += \"\\n/*# sourceMappingURL=data:application/json;base64,\" + btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))) + \" */\";\n    }\n    // For old IE\n    /* istanbul ignore if  */ if (style.styleSheet) {\n        style.styleSheet.cssText = css;\n    } else {\n        while(style.firstChild){\n            style.removeChild(style.firstChild);\n        }\n        style.appendChild(document.createTextNode(css));\n    }\n}\nlet singleton = null;\nlet singletonCounter = 0;\nfunction addStyle(obj, options) {\n    let style;\n    let update;\n    let remove;\n    if (options.singleton) {\n        const styleIndex = singletonCounter++;\n        style = singleton || (singleton = insertStyleElement(options));\n        update = applyToSingletonTag.bind(null, style, styleIndex, false);\n        remove = applyToSingletonTag.bind(null, style, styleIndex, true);\n    } else {\n        style = insertStyleElement(options);\n        update = applyToTag.bind(null, style, options);\n        remove = function() {\n            removeStyleElement(style);\n        };\n    }\n    update(obj);\n    return function updateStyle(newObj) {\n        if (newObj) {\n            if (newObj.css === obj.css && newObj.media === obj.media && newObj.sourceMap === obj.sourceMap) {\n                return;\n            }\n            update(obj = newObj);\n        } else {\n            remove();\n        }\n    };\n}\nmodule.exports = function(list, options) {\n    options = options || {};\n    // Force single-tag solution on IE6-9, which has a hard limit on the # of <style>\n    // tags it will allow on a page\n    if (!options.singleton && typeof options.singleton !== \"boolean\") {\n        options.singleton = isOldIE();\n    }\n    list = list || [];\n    let lastIdentifiers = modulesToDom(list, options);\n    return function update(newList) {\n        newList = newList || [];\n        if (Object.prototype.toString.call(newList) !== \"[object Array]\") {\n            return;\n        }\n        for(let i = 0; i < lastIdentifiers.length; i++){\n            const identifier = lastIdentifiers[i];\n            const index = getIndexByIdentifier(identifier);\n            stylesInDom[index].references--;\n        }\n        const newLastIdentifiers = modulesToDom(newList, options);\n        for(let i = 0; i < lastIdentifiers.length; i++){\n            const identifier = lastIdentifiers[i];\n            const index = getIndexByIdentifier(identifier);\n            if (stylesInDom[index].references === 0) {\n                stylesInDom[index].updater();\n                stylesInDom.splice(index, 1);\n            }\n        }\n        lastIdentifiers = newLastIdentifiers;\n    };\n};\n\n//# sourceMappingURL=injectStylesIntoStyleTag.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2J1aWxkL3dlYnBhY2svbG9hZGVycy9uZXh0LXN0eWxlLWxvYWRlci9ydW50aW1lL2luamVjdFN0eWxlc0ludG9TdHlsZVRhZy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsd0JBQXdCO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLGlCQUFpQjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLEtBQXdDLEdBQUcsc0JBQWlCLEdBQUcsQ0FBSTtBQUMzRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQSxxRUFBcUUsZ0JBQWdCO0FBQ3JGO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSw2REFBNkQ7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsNEJBQTRCO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsNEJBQTRCO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvYnVpbGQvd2VicGFjay9sb2FkZXJzL25leHQtc3R5bGUtbG9hZGVyL3J1bnRpbWUvaW5qZWN0U3R5bGVzSW50b1N0eWxlVGFnLmpzPzI2ZWQiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5jb25zdCBpc09sZElFID0gZnVuY3Rpb24gaXNPbGRJRSgpIHtcbiAgICBsZXQgbWVtbztcbiAgICByZXR1cm4gZnVuY3Rpb24gbWVtb3JpemUoKSB7XG4gICAgICAgIGlmICh0eXBlb2YgbWVtbyA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgICAgLy8gVGVzdCBmb3IgSUUgPD0gOSBhcyBwcm9wb3NlZCBieSBCcm93c2VyaGFja3NcbiAgICAgICAgICAgIC8vIEBzZWUgaHR0cDovL2Jyb3dzZXJoYWNrcy5jb20vI2hhY2stZTcxZDg2OTJmNjUzMzQxNzNmZWU3MTVjMjIyY2I4MDVcbiAgICAgICAgICAgIC8vIFRlc3RzIGZvciBleGlzdGVuY2Ugb2Ygc3RhbmRhcmQgZ2xvYmFscyBpcyB0byBhbGxvdyBzdHlsZS1sb2FkZXJcbiAgICAgICAgICAgIC8vIHRvIG9wZXJhdGUgY29ycmVjdGx5IGludG8gbm9uLXN0YW5kYXJkIGVudmlyb25tZW50c1xuICAgICAgICAgICAgLy8gQHNlZSBodHRwczovL2dpdGh1Yi5jb20vd2VicGFjay1jb250cmliL3N0eWxlLWxvYWRlci9pc3N1ZXMvMTc3XG4gICAgICAgICAgICBtZW1vID0gQm9vbGVhbih3aW5kb3cgJiYgZG9jdW1lbnQgJiYgZG9jdW1lbnQuYWxsICYmICF3aW5kb3cuYXRvYik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1lbW87XG4gICAgfTtcbn0oKTtcbmNvbnN0IGdldFRhcmdldEVsZW1lbnQgPSBmdW5jdGlvbigpIHtcbiAgICBjb25zdCBtZW1vID0ge307XG4gICAgcmV0dXJuIGZ1bmN0aW9uIG1lbW9yaXplKHRhcmdldCkge1xuICAgICAgICBpZiAodHlwZW9mIG1lbW9bdGFyZ2V0XSA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgICAgbGV0IHN0eWxlVGFyZ2V0ID0gZG9jdW1lbnQucXVlcnlTZWxlY3Rvcih0YXJnZXQpO1xuICAgICAgICAgICAgLy8gU3BlY2lhbCBjYXNlIHRvIHJldHVybiBoZWFkIG9mIGlmcmFtZSBpbnN0ZWFkIG9mIGlmcmFtZSBpdHNlbGZcbiAgICAgICAgICAgIGlmICh3aW5kb3cuSFRNTElGcmFtZUVsZW1lbnQgJiYgc3R5bGVUYXJnZXQgaW5zdGFuY2VvZiB3aW5kb3cuSFRNTElGcmFtZUVsZW1lbnQpIHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAvLyBUaGlzIHdpbGwgdGhyb3cgYW4gZXhjZXB0aW9uIGlmIGFjY2VzcyB0byBpZnJhbWUgaXMgYmxvY2tlZFxuICAgICAgICAgICAgICAgICAgICAvLyBkdWUgdG8gY3Jvc3Mtb3JpZ2luIHJlc3RyaWN0aW9uc1xuICAgICAgICAgICAgICAgICAgICBzdHlsZVRhcmdldCA9IHN0eWxlVGFyZ2V0LmNvbnRlbnREb2N1bWVudC5oZWFkO1xuICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gaXN0YW5idWwgaWdub3JlIG5leHRcbiAgICAgICAgICAgICAgICAgICAgc3R5bGVUYXJnZXQgPSBudWxsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG1lbW9bdGFyZ2V0XSA9IHN0eWxlVGFyZ2V0O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtZW1vW3RhcmdldF07XG4gICAgfTtcbn0oKTtcbmNvbnN0IHN0eWxlc0luRG9tID0gW107XG5mdW5jdGlvbiBnZXRJbmRleEJ5SWRlbnRpZmllcihpZGVudGlmaWVyKSB7XG4gICAgbGV0IHJlc3VsdCA9IC0xO1xuICAgIGZvcihsZXQgaSA9IDA7IGkgPCBzdHlsZXNJbkRvbS5sZW5ndGg7IGkrKyl7XG4gICAgICAgIGlmIChzdHlsZXNJbkRvbVtpXS5pZGVudGlmaWVyID09PSBpZGVudGlmaWVyKSB7XG4gICAgICAgICAgICByZXN1bHQgPSBpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIG1vZHVsZXNUb0RvbShsaXN0LCBvcHRpb25zKSB7XG4gICAgY29uc3QgaWRDb3VudE1hcCA9IHt9O1xuICAgIGNvbnN0IGlkZW50aWZpZXJzID0gW107XG4gICAgZm9yKGxldCBpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyBpKyspe1xuICAgICAgICBjb25zdCBpdGVtID0gbGlzdFtpXTtcbiAgICAgICAgY29uc3QgaWQgPSBvcHRpb25zLmJhc2UgPyBpdGVtWzBdICsgb3B0aW9ucy5iYXNlIDogaXRlbVswXTtcbiAgICAgICAgY29uc3QgY291bnQgPSBpZENvdW50TWFwW2lkXSB8fCAwO1xuICAgICAgICBjb25zdCBpZGVudGlmaWVyID0gaWQgKyBcIiBcIiArIGNvdW50LnRvU3RyaW5nKCk7XG4gICAgICAgIGlkQ291bnRNYXBbaWRdID0gY291bnQgKyAxO1xuICAgICAgICBjb25zdCBpbmRleCA9IGdldEluZGV4QnlJZGVudGlmaWVyKGlkZW50aWZpZXIpO1xuICAgICAgICBjb25zdCBvYmogPSB7XG4gICAgICAgICAgICBjc3M6IGl0ZW1bMV0sXG4gICAgICAgICAgICBtZWRpYTogaXRlbVsyXSxcbiAgICAgICAgICAgIHNvdXJjZU1hcDogaXRlbVszXVxuICAgICAgICB9O1xuICAgICAgICBpZiAoaW5kZXggIT09IC0xKSB7XG4gICAgICAgICAgICBzdHlsZXNJbkRvbVtpbmRleF0ucmVmZXJlbmNlcysrO1xuICAgICAgICAgICAgc3R5bGVzSW5Eb21baW5kZXhdLnVwZGF0ZXIob2JqKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHN0eWxlc0luRG9tLnB1c2goe1xuICAgICAgICAgICAgICAgIGlkZW50aWZpZXI6IGlkZW50aWZpZXIsXG4gICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11c2UtYmVmb3JlLWRlZmluZVxuICAgICAgICAgICAgICAgIHVwZGF0ZXI6IGFkZFN0eWxlKG9iaiwgb3B0aW9ucyksXG4gICAgICAgICAgICAgICAgcmVmZXJlbmNlczogMVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWRlbnRpZmllcnMucHVzaChpZGVudGlmaWVyKTtcbiAgICB9XG4gICAgcmV0dXJuIGlkZW50aWZpZXJzO1xufVxuZnVuY3Rpb24gaW5zZXJ0U3R5bGVFbGVtZW50KG9wdGlvbnMpIHtcbiAgICBjb25zdCBzdHlsZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJzdHlsZVwiKTtcbiAgICBjb25zdCBhdHRyaWJ1dGVzID0gb3B0aW9ucy5hdHRyaWJ1dGVzIHx8IHt9O1xuICAgIGlmICh0eXBlb2YgYXR0cmlidXRlcy5ub25jZSA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICBjb25zdCBub25jZSA9IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bmRlZlxuICAgICAgICB0eXBlb2YgX193ZWJwYWNrX25vbmNlX18gIT09IFwidW5kZWZpbmVkXCIgPyBfX3dlYnBhY2tfbm9uY2VfXyA6IG51bGw7XG4gICAgICAgIGlmIChub25jZSkge1xuICAgICAgICAgICAgYXR0cmlidXRlcy5ub25jZSA9IG5vbmNlO1xuICAgICAgICB9XG4gICAgfVxuICAgIE9iamVjdC5rZXlzKGF0dHJpYnV0ZXMpLmZvckVhY2goZnVuY3Rpb24oa2V5KSB7XG4gICAgICAgIHN0eWxlLnNldEF0dHJpYnV0ZShrZXksIGF0dHJpYnV0ZXNba2V5XSk7XG4gICAgfSk7XG4gICAgaWYgKHR5cGVvZiBvcHRpb25zLmluc2VydCA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIG9wdGlvbnMuaW5zZXJ0KHN0eWxlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCB0YXJnZXQgPSBnZXRUYXJnZXRFbGVtZW50KG9wdGlvbnMuaW5zZXJ0IHx8IFwiaGVhZFwiKTtcbiAgICAgICAgaWYgKCF0YXJnZXQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNvdWxkbid0IGZpbmQgYSBzdHlsZSB0YXJnZXQuIFRoaXMgcHJvYmFibHkgbWVhbnMgdGhhdCB0aGUgdmFsdWUgZm9yIHRoZSAnaW5zZXJ0JyBwYXJhbWV0ZXIgaXMgaW52YWxpZC5cIik7XG4gICAgICAgIH1cbiAgICAgICAgdGFyZ2V0LmFwcGVuZENoaWxkKHN0eWxlKTtcbiAgICB9XG4gICAgcmV0dXJuIHN0eWxlO1xufVxuZnVuY3Rpb24gcmVtb3ZlU3R5bGVFbGVtZW50KHN0eWxlKSB7XG4gICAgLy8gaXN0YW5idWwgaWdub3JlIGlmXG4gICAgaWYgKHN0eWxlLnBhcmVudE5vZGUgPT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBzdHlsZS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHN0eWxlKTtcbn1cbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICAqLyBjb25zdCByZXBsYWNlVGV4dCA9IGZ1bmN0aW9uIHJlcGxhY2VUZXh0KCkge1xuICAgIGNvbnN0IHRleHRTdG9yZSA9IFtdO1xuICAgIHJldHVybiBmdW5jdGlvbiByZXBsYWNlKGluZGV4LCByZXBsYWNlbWVudCkge1xuICAgICAgICB0ZXh0U3RvcmVbaW5kZXhdID0gcmVwbGFjZW1lbnQ7XG4gICAgICAgIHJldHVybiB0ZXh0U3RvcmUuZmlsdGVyKEJvb2xlYW4pLmpvaW4oXCJcXG5cIik7XG4gICAgfTtcbn0oKTtcbmZ1bmN0aW9uIGFwcGx5VG9TaW5nbGV0b25UYWcoc3R5bGUsIGluZGV4LCByZW1vdmUsIG9iaikge1xuICAgIGNvbnN0IGNzcyA9IHJlbW92ZSA/IFwiXCIgOiBvYmoubWVkaWEgPyBcIkBtZWRpYSBcIiArIG9iai5tZWRpYSArIFwiIHtcIiArIG9iai5jc3MgKyBcIn1cIiA6IG9iai5jc3M7XG4gICAgLy8gRm9yIG9sZCBJRVxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAgKi8gaWYgKHN0eWxlLnN0eWxlU2hlZXQpIHtcbiAgICAgICAgc3R5bGUuc3R5bGVTaGVldC5jc3NUZXh0ID0gcmVwbGFjZVRleHQoaW5kZXgsIGNzcyk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3QgY3NzTm9kZSA9IGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKGNzcyk7XG4gICAgICAgIGNvbnN0IGNoaWxkTm9kZXMgPSBzdHlsZS5jaGlsZE5vZGVzO1xuICAgICAgICBpZiAoY2hpbGROb2Rlc1tpbmRleF0pIHtcbiAgICAgICAgICAgIHN0eWxlLnJlbW92ZUNoaWxkKGNoaWxkTm9kZXNbaW5kZXhdKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY2hpbGROb2Rlcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHN0eWxlLmluc2VydEJlZm9yZShjc3NOb2RlLCBjaGlsZE5vZGVzW2luZGV4XSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzdHlsZS5hcHBlbmRDaGlsZChjc3NOb2RlKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmZ1bmN0aW9uIGFwcGx5VG9UYWcoc3R5bGUsIF9vcHRpb25zLCBvYmopIHtcbiAgICBsZXQgY3NzID0gb2JqLmNzcztcbiAgICBjb25zdCBtZWRpYSA9IG9iai5tZWRpYTtcbiAgICBjb25zdCBzb3VyY2VNYXAgPSBvYmouc291cmNlTWFwO1xuICAgIGlmIChtZWRpYSkge1xuICAgICAgICBzdHlsZS5zZXRBdHRyaWJ1dGUoXCJtZWRpYVwiLCBtZWRpYSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgc3R5bGUucmVtb3ZlQXR0cmlidXRlKFwibWVkaWFcIik7XG4gICAgfVxuICAgIGlmIChzb3VyY2VNYXAgJiYgdHlwZW9mIGJ0b2EgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgY3NzICs9IFwiXFxuLyojIHNvdXJjZU1hcHBpbmdVUkw9ZGF0YTphcHBsaWNhdGlvbi9qc29uO2Jhc2U2NCxcIiArIGJ0b2EodW5lc2NhcGUoZW5jb2RlVVJJQ29tcG9uZW50KEpTT04uc3RyaW5naWZ5KHNvdXJjZU1hcCkpKSkgKyBcIiAqL1wiO1xuICAgIH1cbiAgICAvLyBGb3Igb2xkIElFXG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICAqLyBpZiAoc3R5bGUuc3R5bGVTaGVldCkge1xuICAgICAgICBzdHlsZS5zdHlsZVNoZWV0LmNzc1RleHQgPSBjc3M7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgd2hpbGUoc3R5bGUuZmlyc3RDaGlsZCl7XG4gICAgICAgICAgICBzdHlsZS5yZW1vdmVDaGlsZChzdHlsZS5maXJzdENoaWxkKTtcbiAgICAgICAgfVxuICAgICAgICBzdHlsZS5hcHBlbmRDaGlsZChkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShjc3MpKTtcbiAgICB9XG59XG5sZXQgc2luZ2xldG9uID0gbnVsbDtcbmxldCBzaW5nbGV0b25Db3VudGVyID0gMDtcbmZ1bmN0aW9uIGFkZFN0eWxlKG9iaiwgb3B0aW9ucykge1xuICAgIGxldCBzdHlsZTtcbiAgICBsZXQgdXBkYXRlO1xuICAgIGxldCByZW1vdmU7XG4gICAgaWYgKG9wdGlvbnMuc2luZ2xldG9uKSB7XG4gICAgICAgIGNvbnN0IHN0eWxlSW5kZXggPSBzaW5nbGV0b25Db3VudGVyKys7XG4gICAgICAgIHN0eWxlID0gc2luZ2xldG9uIHx8IChzaW5nbGV0b24gPSBpbnNlcnRTdHlsZUVsZW1lbnQob3B0aW9ucykpO1xuICAgICAgICB1cGRhdGUgPSBhcHBseVRvU2luZ2xldG9uVGFnLmJpbmQobnVsbCwgc3R5bGUsIHN0eWxlSW5kZXgsIGZhbHNlKTtcbiAgICAgICAgcmVtb3ZlID0gYXBwbHlUb1NpbmdsZXRvblRhZy5iaW5kKG51bGwsIHN0eWxlLCBzdHlsZUluZGV4LCB0cnVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBzdHlsZSA9IGluc2VydFN0eWxlRWxlbWVudChvcHRpb25zKTtcbiAgICAgICAgdXBkYXRlID0gYXBwbHlUb1RhZy5iaW5kKG51bGwsIHN0eWxlLCBvcHRpb25zKTtcbiAgICAgICAgcmVtb3ZlID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZW1vdmVTdHlsZUVsZW1lbnQoc3R5bGUpO1xuICAgICAgICB9O1xuICAgIH1cbiAgICB1cGRhdGUob2JqKTtcbiAgICByZXR1cm4gZnVuY3Rpb24gdXBkYXRlU3R5bGUobmV3T2JqKSB7XG4gICAgICAgIGlmIChuZXdPYmopIHtcbiAgICAgICAgICAgIGlmIChuZXdPYmouY3NzID09PSBvYmouY3NzICYmIG5ld09iai5tZWRpYSA9PT0gb2JqLm1lZGlhICYmIG5ld09iai5zb3VyY2VNYXAgPT09IG9iai5zb3VyY2VNYXApIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB1cGRhdGUob2JqID0gbmV3T2JqKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlbW92ZSgpO1xuICAgICAgICB9XG4gICAgfTtcbn1cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24obGlzdCwgb3B0aW9ucykge1xuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgIC8vIEZvcmNlIHNpbmdsZS10YWcgc29sdXRpb24gb24gSUU2LTksIHdoaWNoIGhhcyBhIGhhcmQgbGltaXQgb24gdGhlICMgb2YgPHN0eWxlPlxuICAgIC8vIHRhZ3MgaXQgd2lsbCBhbGxvdyBvbiBhIHBhZ2VcbiAgICBpZiAoIW9wdGlvbnMuc2luZ2xldG9uICYmIHR5cGVvZiBvcHRpb25zLnNpbmdsZXRvbiAhPT0gXCJib29sZWFuXCIpIHtcbiAgICAgICAgb3B0aW9ucy5zaW5nbGV0b24gPSBpc09sZElFKCk7XG4gICAgfVxuICAgIGxpc3QgPSBsaXN0IHx8IFtdO1xuICAgIGxldCBsYXN0SWRlbnRpZmllcnMgPSBtb2R1bGVzVG9Eb20obGlzdCwgb3B0aW9ucyk7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIHVwZGF0ZShuZXdMaXN0KSB7XG4gICAgICAgIG5ld0xpc3QgPSBuZXdMaXN0IHx8IFtdO1xuICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG5ld0xpc3QpICE9PSBcIltvYmplY3QgQXJyYXldXCIpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBmb3IobGV0IGkgPSAwOyBpIDwgbGFzdElkZW50aWZpZXJzLmxlbmd0aDsgaSsrKXtcbiAgICAgICAgICAgIGNvbnN0IGlkZW50aWZpZXIgPSBsYXN0SWRlbnRpZmllcnNbaV07XG4gICAgICAgICAgICBjb25zdCBpbmRleCA9IGdldEluZGV4QnlJZGVudGlmaWVyKGlkZW50aWZpZXIpO1xuICAgICAgICAgICAgc3R5bGVzSW5Eb21baW5kZXhdLnJlZmVyZW5jZXMtLTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBuZXdMYXN0SWRlbnRpZmllcnMgPSBtb2R1bGVzVG9Eb20obmV3TGlzdCwgb3B0aW9ucyk7XG4gICAgICAgIGZvcihsZXQgaSA9IDA7IGkgPCBsYXN0SWRlbnRpZmllcnMubGVuZ3RoOyBpKyspe1xuICAgICAgICAgICAgY29uc3QgaWRlbnRpZmllciA9IGxhc3RJZGVudGlmaWVyc1tpXTtcbiAgICAgICAgICAgIGNvbnN0IGluZGV4ID0gZ2V0SW5kZXhCeUlkZW50aWZpZXIoaWRlbnRpZmllcik7XG4gICAgICAgICAgICBpZiAoc3R5bGVzSW5Eb21baW5kZXhdLnJlZmVyZW5jZXMgPT09IDApIHtcbiAgICAgICAgICAgICAgICBzdHlsZXNJbkRvbVtpbmRleF0udXBkYXRlcigpO1xuICAgICAgICAgICAgICAgIHN0eWxlc0luRG9tLnNwbGljZShpbmRleCwgMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgbGFzdElkZW50aWZpZXJzID0gbmV3TGFzdElkZW50aWZpZXJzO1xuICAgIH07XG59O1xuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmplY3RTdHlsZXNJbnRvU3R5bGVUYWcuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/next/dist/build/webpack/loaders/next-style-loader/runtime/injectStylesIntoStyleTag.js\n"));

/***/ }),

/***/ "./contexts/FontContext.js":
/*!*********************************!*\
  !*** ./contexts/FontContext.js ***!
  \*********************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   FontProvider: function() { return /* binding */ FontProvider; },\n/* harmony export */   useFontContext: function() { return /* binding */ useFontContext; }\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"./node_modules/react/jsx-dev-runtime.js\");\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"./node_modules/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _hooks_useFontManager__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../hooks/useFontManager */ \"./hooks/useFontManager.js\");\n\nvar _s = $RefreshSig$(), _s1 = $RefreshSig$();\n\n\n// 1. Создаем контекст\nconst FontContext = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_1__.createContext)(null);\n// 2. Создаем провайдер\nconst FontProvider = (param)=>{\n    let { children } = param;\n    _s();\n    // Вызываем хук useFontManager один раз здесь\n    const fontManagerData = (0,_hooks_useFontManager__WEBPACK_IMPORTED_MODULE_2__.useFontManager)();\n    // Передаем все возвращаемые значения хука через value провайдера\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(FontContext.Provider, {\n        value: fontManagerData,\n        children: children\n    }, void 0, false, {\n        fileName: \"/Users/igormocalov/Desktop/Font/contexts/FontContext.js\",\n        lineNumber: 14,\n        columnNumber: 5\n    }, undefined);\n};\n_s(FontProvider, \"VbO4DRlCBqhbjBFqMjncFgIKnsw=\", false, function() {\n    return [\n        _hooks_useFontManager__WEBPACK_IMPORTED_MODULE_2__.useFontManager\n    ];\n});\n_c = FontProvider;\n// 3. Создаем кастомный хук для удобного доступа к контексту\nconst useFontContext = ()=>{\n    _s1();\n    const context = (0,react__WEBPACK_IMPORTED_MODULE_1__.useContext)(FontContext);\n    if (!context) {\n        // Эта ошибка сработает, если компонент, использующий useFontContext,\n        // не будет обернут в FontProvider\n        throw new Error(\"useFontContext must be used within a FontProvider\");\n    }\n    return context;\n};\n_s1(useFontContext, \"b9L3QQ+jgeyIrH0NfHrJ8nn7VMU=\");\nvar _c;\n$RefreshReg$(_c, \"FontProvider\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9jb250ZXh0cy9Gb250Q29udGV4dC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7QUFBeUQ7QUFDQTtBQUV6RCxzQkFBc0I7QUFDdEIsTUFBTUksNEJBQWNILG9EQUFhQSxDQUFDO0FBRWxDLHVCQUF1QjtBQUNoQixNQUFNSSxlQUFlO1FBQUMsRUFBRUMsUUFBUSxFQUFFOztJQUN2Qyw2Q0FBNkM7SUFDN0MsTUFBTUMsa0JBQWtCSixxRUFBY0E7SUFFdEMsaUVBQWlFO0lBQ2pFLHFCQUNFLDhEQUFDQyxZQUFZSSxRQUFRO1FBQUNDLE9BQU9GO2tCQUMxQkQ7Ozs7OztBQUdQLEVBQUU7R0FWV0Q7O1FBRWFGLGlFQUFjQTs7O0tBRjNCRTtBQVliLDREQUE0RDtBQUNyRCxNQUFNSyxpQkFBaUI7O0lBQzVCLE1BQU1DLFVBQVVULGlEQUFVQSxDQUFDRTtJQUMzQixJQUFJLENBQUNPLFNBQVM7UUFDWixxRUFBcUU7UUFDckUsa0NBQWtDO1FBQ2xDLE1BQU0sSUFBSUMsTUFBTTtJQUNsQjtJQUNBLE9BQU9EO0FBQ1QsRUFBRTtJQVJXRCIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9jb250ZXh0cy9Gb250Q29udGV4dC5qcz80MmQ2Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBSZWFjdCwgeyBjcmVhdGVDb250ZXh0LCB1c2VDb250ZXh0IH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IHsgdXNlRm9udE1hbmFnZXIgfSBmcm9tICcuLi9ob29rcy91c2VGb250TWFuYWdlcic7XG5cbi8vIDEuINCh0L7Qt9C00LDQtdC8INC60L7QvdGC0LXQutGB0YJcbmNvbnN0IEZvbnRDb250ZXh0ID0gY3JlYXRlQ29udGV4dChudWxsKTtcblxuLy8gMi4g0KHQvtC30LTQsNC10Lwg0L/RgNC+0LLQsNC50LTQtdGAXG5leHBvcnQgY29uc3QgRm9udFByb3ZpZGVyID0gKHsgY2hpbGRyZW4gfSkgPT4ge1xuICAvLyDQktGL0LfRi9Cy0LDQtdC8INGF0YPQuiB1c2VGb250TWFuYWdlciDQvtC00LjQvSDRgNCw0Lcg0LfQtNC10YHRjFxuICBjb25zdCBmb250TWFuYWdlckRhdGEgPSB1c2VGb250TWFuYWdlcigpO1xuXG4gIC8vINCf0LXRgNC10LTQsNC10Lwg0LLRgdC1INCy0L7Qt9Cy0YDQsNGJ0LDQtdC80YvQtSDQt9C90LDRh9C10L3QuNGPINGF0YPQutCwINGH0LXRgNC10LcgdmFsdWUg0L/RgNC+0LLQsNC50LTQtdGA0LBcbiAgcmV0dXJuIChcbiAgICA8Rm9udENvbnRleHQuUHJvdmlkZXIgdmFsdWU9e2ZvbnRNYW5hZ2VyRGF0YX0+XG4gICAgICB7Y2hpbGRyZW59XG4gICAgPC9Gb250Q29udGV4dC5Qcm92aWRlcj5cbiAgKTtcbn07XG5cbi8vIDMuINCh0L7Qt9C00LDQtdC8INC60LDRgdGC0L7QvNC90YvQuSDRhdGD0Log0LTQu9GPINGD0LTQvtCx0L3QvtCz0L4g0LTQvtGB0YLRg9C/0LAg0Log0LrQvtC90YLQtdC60YHRgtGDXG5leHBvcnQgY29uc3QgdXNlRm9udENvbnRleHQgPSAoKSA9PiB7XG4gIGNvbnN0IGNvbnRleHQgPSB1c2VDb250ZXh0KEZvbnRDb250ZXh0KTtcbiAgaWYgKCFjb250ZXh0KSB7XG4gICAgLy8g0K3RgtCwINC+0YjQuNCx0LrQsCDRgdGA0LDQsdC+0YLQsNC10YIsINC10YHQu9C4INC60L7QvNC/0L7QvdC10L3Rgiwg0LjRgdC/0L7Qu9GM0LfRg9GO0YnQuNC5IHVzZUZvbnRDb250ZXh0LFxuICAgIC8vINC90LUg0LHRg9C00LXRgiDQvtCx0LXRgNC90YPRgiDQsiBGb250UHJvdmlkZXJcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3VzZUZvbnRDb250ZXh0IG11c3QgYmUgdXNlZCB3aXRoaW4gYSBGb250UHJvdmlkZXInKTtcbiAgfVxuICByZXR1cm4gY29udGV4dDtcbn07ICJdLCJuYW1lcyI6WyJSZWFjdCIsImNyZWF0ZUNvbnRleHQiLCJ1c2VDb250ZXh0IiwidXNlRm9udE1hbmFnZXIiLCJGb250Q29udGV4dCIsIkZvbnRQcm92aWRlciIsImNoaWxkcmVuIiwiZm9udE1hbmFnZXJEYXRhIiwiUHJvdmlkZXIiLCJ2YWx1ZSIsInVzZUZvbnRDb250ZXh0IiwiY29udGV4dCIsIkVycm9yIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./contexts/FontContext.js\n"));

/***/ }),

/***/ "./contexts/SettingsContext.js":
/*!*************************************!*\
  !*** ./contexts/SettingsContext.js ***!
  \*************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   SettingsProvider: function() { return /* binding */ SettingsProvider; },\n/* harmony export */   useSettings: function() { return /* binding */ useSettings; }\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"./node_modules/react/jsx-dev-runtime.js\");\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"./node_modules/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n\nvar _s = $RefreshSig$(), _s1 = $RefreshSig$();\n\n// Создаем контекст\nconst SettingsContext = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_1__.createContext)();\n// <<< Ключи для localStorage >>>\nconst LOCAL_STORAGE_KEYS = {\n    BACKGROUND_COLOR: \"backgroundColor\",\n    TEXT_COLOR: \"textColor\",\n    FONT_SIZE: \"fontSize\",\n    LINE_HEIGHT: \"lineHeight\",\n    LETTER_SPACING: \"letterSpacing\",\n    VIEW_MODE: \"viewMode\",\n    TEXT_DIRECTION: \"textDirection\",\n    TEXT_ALIGNMENT: \"textAlignment\",\n    TEXT_CASE: \"textCase\",\n    TEXT_CENTER: \"textCenter\",\n    TEXT_FILL: \"textFill\"\n};\n// <<< Дефолтные значения >>>\nconst DEFAULT_SETTINGS = {\n    TEXT: \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789\",\n    FONT_SIZE: 150,\n    LINE_HEIGHT: 1.05,\n    LETTER_SPACING: 0,\n    TEXT_COLOR: \"#000000\",\n    BACKGROUND_COLOR: \"#FFFFFF\",\n    VIEW_MODE: \"plain\",\n    TEXT_DIRECTION: \"ltr\",\n    TEXT_ALIGNMENT: \"left\",\n    TEXT_CASE: \"uppercase\",\n    TEXT_CENTER: false,\n    TEXT_FILL: false\n};\n// <<< Функция для безопасного чтения из localStorage >>>\nconst getLocalStorageItem = (key, defaultValue)=>{\n    if (true) {\n        try {\n            const item = localStorage.getItem(key);\n            return item ? JSON.parse(item) : defaultValue;\n        } catch (error) {\n            console.error(\"Ошибка чтения localStorage для ключа \".concat(key, \":\"), error);\n            return defaultValue;\n        }\n    } else {}\n};\n// <<< Функция для безопасной записи в localStorage >>>\nconst setLocalStorageItem = (key, value)=>{\n    if (true) {\n        try {\n            localStorage.setItem(key, JSON.stringify(value));\n        } catch (error) {\n            console.error(\"Ошибка записи в localStorage для ключа \".concat(key, \":\"), error);\n        }\n    }\n};\n// Создаем провайдер контекста\nconst SettingsProvider = (param)=>{\n    let { children } = param;\n    _s();\n    // Состояние для отслеживания клиентской стороны (предотвращение гидратации)\n    const [isClient, setIsClient] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false);\n    // Переносим состояния из pages/index.jsx\n    const [text, setText] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(DEFAULT_SETTINGS.TEXT); // Текст не храним в LS пока\n    const [fontSize, setFontSize] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(DEFAULT_SETTINGS.FONT_SIZE); // Инициализируем дефолтом\n    const [lineHeight, setLineHeight] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(DEFAULT_SETTINGS.LINE_HEIGHT);\n    const [letterSpacing, setLetterSpacing] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(DEFAULT_SETTINGS.LETTER_SPACING);\n    const [textColor, setTextColor] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(DEFAULT_SETTINGS.TEXT_COLOR);\n    const [backgroundColor, setBackgroundColor] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(DEFAULT_SETTINGS.BACKGROUND_COLOR);\n    const [viewMode, setViewMode] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(DEFAULT_SETTINGS.VIEW_MODE);\n    const [textDirection, setTextDirection] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(DEFAULT_SETTINGS.TEXT_DIRECTION);\n    const [textAlignment, setTextAlignment] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(DEFAULT_SETTINGS.TEXT_ALIGNMENT);\n    const [textCase, setTextCase] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(DEFAULT_SETTINGS.TEXT_CASE);\n    const [textCenter, setTextCenter] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(DEFAULT_SETTINGS.TEXT_CENTER);\n    const [textFill, setTextFill] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(DEFAULT_SETTINGS.TEXT_FILL);\n    // Эффект для инициализации клиентской стороны и загрузки из localStorage\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        setIsClient(true);\n        // Загружаем значения из localStorage только на клиенте\n        setFontSize(getLocalStorageItem(LOCAL_STORAGE_KEYS.FONT_SIZE, DEFAULT_SETTINGS.FONT_SIZE));\n        setLineHeight(getLocalStorageItem(LOCAL_STORAGE_KEYS.LINE_HEIGHT, DEFAULT_SETTINGS.LINE_HEIGHT));\n        setLetterSpacing(getLocalStorageItem(LOCAL_STORAGE_KEYS.LETTER_SPACING, DEFAULT_SETTINGS.LETTER_SPACING));\n        setTextColor(getLocalStorageItem(LOCAL_STORAGE_KEYS.TEXT_COLOR, DEFAULT_SETTINGS.TEXT_COLOR));\n        setBackgroundColor(getLocalStorageItem(LOCAL_STORAGE_KEYS.BACKGROUND_COLOR, DEFAULT_SETTINGS.BACKGROUND_COLOR));\n        setViewMode(getLocalStorageItem(LOCAL_STORAGE_KEYS.VIEW_MODE, DEFAULT_SETTINGS.VIEW_MODE));\n        setTextDirection(getLocalStorageItem(LOCAL_STORAGE_KEYS.TEXT_DIRECTION, DEFAULT_SETTINGS.TEXT_DIRECTION));\n        setTextAlignment(getLocalStorageItem(LOCAL_STORAGE_KEYS.TEXT_ALIGNMENT, DEFAULT_SETTINGS.TEXT_ALIGNMENT));\n        setTextCase(getLocalStorageItem(LOCAL_STORAGE_KEYS.TEXT_CASE, DEFAULT_SETTINGS.TEXT_CASE));\n        setTextCenter(getLocalStorageItem(LOCAL_STORAGE_KEYS.TEXT_CENTER, DEFAULT_SETTINGS.TEXT_CENTER));\n        setTextFill(getLocalStorageItem(LOCAL_STORAGE_KEYS.TEXT_FILL, DEFAULT_SETTINGS.TEXT_FILL));\n    }, []);\n    // <<< useEffects для сохранения в localStorage (только после клиентской инициализации) >>>\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        if (isClient) setLocalStorageItem(LOCAL_STORAGE_KEYS.BACKGROUND_COLOR, backgroundColor);\n    }, [\n        backgroundColor,\n        isClient\n    ]);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        if (isClient) setLocalStorageItem(LOCAL_STORAGE_KEYS.TEXT_COLOR, textColor);\n    }, [\n        textColor,\n        isClient\n    ]);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        if (isClient) setLocalStorageItem(LOCAL_STORAGE_KEYS.FONT_SIZE, fontSize);\n    }, [\n        fontSize,\n        isClient\n    ]);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        if (isClient) setLocalStorageItem(LOCAL_STORAGE_KEYS.LINE_HEIGHT, lineHeight);\n    }, [\n        lineHeight,\n        isClient\n    ]);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        if (isClient) setLocalStorageItem(LOCAL_STORAGE_KEYS.LETTER_SPACING, letterSpacing);\n    }, [\n        letterSpacing,\n        isClient\n    ]);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        if (isClient) setLocalStorageItem(LOCAL_STORAGE_KEYS.VIEW_MODE, viewMode);\n    }, [\n        viewMode,\n        isClient\n    ]);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        if (isClient) setLocalStorageItem(LOCAL_STORAGE_KEYS.TEXT_DIRECTION, textDirection);\n    }, [\n        textDirection,\n        isClient\n    ]);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        if (isClient) setLocalStorageItem(LOCAL_STORAGE_KEYS.TEXT_ALIGNMENT, textAlignment);\n    }, [\n        textAlignment,\n        isClient\n    ]);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        if (isClient) setLocalStorageItem(LOCAL_STORAGE_KEYS.TEXT_CASE, textCase);\n    }, [\n        textCase,\n        isClient\n    ]);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        if (isClient) setLocalStorageItem(LOCAL_STORAGE_KEYS.TEXT_CENTER, textCenter);\n    }, [\n        textCenter,\n        isClient\n    ]);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        if (isClient) setLocalStorageItem(LOCAL_STORAGE_KEYS.TEXT_FILL, textFill);\n    }, [\n        textFill,\n        isClient\n    ]);\n    // <<< Функция сброса настроек >>>\n    const resetSettings = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)(()=>{\n        setText(DEFAULT_SETTINGS.TEXT);\n        setFontSize(DEFAULT_SETTINGS.FONT_SIZE);\n        setLineHeight(DEFAULT_SETTINGS.LINE_HEIGHT);\n        setLetterSpacing(DEFAULT_SETTINGS.LETTER_SPACING);\n        setTextColor(DEFAULT_SETTINGS.TEXT_COLOR);\n        setBackgroundColor(DEFAULT_SETTINGS.BACKGROUND_COLOR);\n        setViewMode(DEFAULT_SETTINGS.VIEW_MODE);\n        setTextDirection(DEFAULT_SETTINGS.TEXT_DIRECTION);\n        setTextAlignment(DEFAULT_SETTINGS.TEXT_ALIGNMENT);\n        setTextCase(DEFAULT_SETTINGS.TEXT_CASE);\n        setTextCenter(DEFAULT_SETTINGS.TEXT_CENTER);\n        setTextFill(DEFAULT_SETTINGS.TEXT_FILL);\n        // Очищаем localStorage\n        Object.values(LOCAL_STORAGE_KEYS).forEach((key)=>{\n            if (true) localStorage.removeItem(key);\n        });\n        console.log(\"[SettingsContext] Настройки сброшены к дефолтным и localStorage очищен.\");\n    }, []); // Нет зависимостей, т.к. используем только сеттеры и константы\n    // Значение, которое будет передано через контекст\n    const value = {\n        text,\n        setText,\n        fontSize,\n        setFontSize,\n        lineHeight,\n        setLineHeight,\n        letterSpacing,\n        setLetterSpacing,\n        textColor,\n        setTextColor,\n        backgroundColor,\n        setBackgroundColor,\n        viewMode,\n        setViewMode,\n        textDirection,\n        setTextDirection,\n        textAlignment,\n        setTextAlignment,\n        textCase,\n        setTextCase,\n        textCenter,\n        setTextCenter,\n        textFill,\n        setTextFill,\n        resetSettings\n    };\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(SettingsContext.Provider, {\n        value: value,\n        children: children\n    }, void 0, false, {\n        fileName: \"/Users/igormocalov/Desktop/Font/contexts/SettingsContext.js\",\n        lineNumber: 166,\n        columnNumber: 5\n    }, undefined);\n};\n_s(SettingsProvider, \"YnrUVmiCb+GQ+Ym0iKxGMQc1Brc=\");\n_c = SettingsProvider;\n// Хук для удобного использования контекста\nconst useSettings = ()=>{\n    _s1();\n    const context = (0,react__WEBPACK_IMPORTED_MODULE_1__.useContext)(SettingsContext);\n    if (context === undefined) {\n        throw new Error(\"useSettings must be used within a SettingsProvider\");\n    }\n    return context;\n};\n_s1(useSettings, \"b9L3QQ+jgeyIrH0NfHrJ8nn7VMU=\");\nvar _c;\n$RefreshReg$(_c, \"SettingsProvider\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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WUFBWUMsV0FBVztRQUN6QixNQUFNLElBQUlDLE1BQU07SUFDbEI7SUFDQSxPQUFPRjtBQUNULEVBQUU7SUFOV0QiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vY29udGV4dHMvU2V0dGluZ3NDb250ZXh0LmpzP2RhZDIiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IFJlYWN0LCB7IGNyZWF0ZUNvbnRleHQsIHVzZVN0YXRlLCB1c2VDb250ZXh0LCB1c2VFZmZlY3QsIHVzZUNhbGxiYWNrIH0gZnJvbSAncmVhY3QnO1xuXG4vLyDQodC+0LfQtNCw0LXQvCDQutC+0L3RgtC10LrRgdGCXG5jb25zdCBTZXR0aW5nc0NvbnRleHQgPSBjcmVhdGVDb250ZXh0KCk7XG5cbi8vIDw8PCDQmtC70Y7Rh9C4INC00LvRjyBsb2NhbFN0b3JhZ2UgPj4+XG5jb25zdCBMT0NBTF9TVE9SQUdFX0tFWVMgPSB7XG4gIEJBQ0tHUk9VTkRfQ09MT1I6ICdiYWNrZ3JvdW5kQ29sb3InLFxuICBURVhUX0NPTE9SOiAndGV4dENvbG9yJyxcbiAgRk9OVF9TSVpFOiAnZm9udFNpemUnLFxuICBMSU5FX0hFSUdIVDogJ2xpbmVIZWlnaHQnLFxuICBMRVRURVJfU1BBQ0lORzogJ2xldHRlclNwYWNpbmcnLFxuICBWSUVXX01PREU6ICd2aWV3TW9kZScsXG4gIFRFWFRfRElSRUNUSU9OOiAndGV4dERpcmVjdGlvbicsXG4gIFRFWFRfQUxJR05NRU5UOiAndGV4dEFsaWdubWVudCcsXG4gIFRFWFRfQ0FTRTogJ3RleHRDYXNlJyxcbiAgVEVYVF9DRU5URVI6ICd0ZXh0Q2VudGVyJyxcbiAgVEVYVF9GSUxMOiAndGV4dEZpbGwnXG4gIC8vINCU0L7QsdCw0LLRjNGC0LUg0LTRgNGD0LPQuNC1INC60LvRjtGH0Lgg0L/RgNC4INC90LXQvtCx0YXQvtC00LjQvNC+0YHRgtC4XG59O1xuXG4vLyA8PDwg0JTQtdGE0L7Qu9GC0L3Ri9C1INC30L3QsNGH0LXQvdC40Y8gPj4+XG5jb25zdCBERUZBVUxUX1NFVFRJTkdTID0ge1xuICBURVhUOiAnQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejAxMjM0NTY3ODknLFxuICBGT05UX1NJWkU6IDE1MCxcbiAgTElORV9IRUlHSFQ6IDEuMDUsXG4gIExFVFRFUl9TUEFDSU5HOiAwLFxuICBURVhUX0NPTE9SOiAnIzAwMDAwMCcsXG4gIEJBQ0tHUk9VTkRfQ09MT1I6ICcjRkZGRkZGJyxcbiAgVklFV19NT0RFOiAncGxhaW4nLFxuICBURVhUX0RJUkVDVElPTjogJ2x0cicsXG4gIFRFWFRfQUxJR05NRU5UOiAnbGVmdCcsXG4gIFRFWFRfQ0FTRTogJ3VwcGVyY2FzZScsXG4gIFRFWFRfQ0VOVEVSOiBmYWxzZSxcbiAgVEVYVF9GSUxMOiBmYWxzZVxufTtcblxuLy8gPDw8INCk0YPQvdC60YbQuNGPINC00LvRjyDQsdC10LfQvtC/0LDRgdC90L7Qs9C+INGH0YLQtdC90LjRjyDQuNC3IGxvY2FsU3RvcmFnZSA+Pj5cbmNvbnN0IGdldExvY2FsU3RvcmFnZUl0ZW0gPSAoa2V5LCBkZWZhdWx0VmFsdWUpID0+IHtcbiAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnKSB7IC8vINCj0LHQtdC00LjQvNGB0Y8sINGH0YLQviBsb2NhbFN0b3JhZ2Ug0LTQvtGB0YLRg9C/0LXQvSAo0L3QtSDQvdCwINGB0LXRgNCy0LXRgNC1KVxuICAgIHRyeSB7XG4gICAgICBjb25zdCBpdGVtID0gbG9jYWxTdG9yYWdlLmdldEl0ZW0oa2V5KTtcbiAgICAgIHJldHVybiBpdGVtID8gSlNPTi5wYXJzZShpdGVtKSA6IGRlZmF1bHRWYWx1ZTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcihg0J7RiNC40LHQutCwINGH0YLQtdC90LjRjyBsb2NhbFN0b3JhZ2Ug0LTQu9GPINC60LvRjtGH0LAgJHtrZXl9OmAsIGVycm9yKTtcbiAgICAgIHJldHVybiBkZWZhdWx0VmFsdWU7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGRlZmF1bHRWYWx1ZTtcbiAgfVxufTtcblxuLy8gPDw8INCk0YPQvdC60YbQuNGPINC00LvRjyDQsdC10LfQvtC/0LDRgdC90L7QuSDQt9Cw0L/QuNGB0Lgg0LIgbG9jYWxTdG9yYWdlID4+PlxuY29uc3Qgc2V0TG9jYWxTdG9yYWdlSXRlbSA9IChrZXksIHZhbHVlKSA9PiB7XG4gICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICB0cnkge1xuICAgICAgICAgICBsb2NhbFN0b3JhZ2Uuc2V0SXRlbShrZXksIEpTT04uc3RyaW5naWZ5KHZhbHVlKSk7XG4gICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgY29uc29sZS5lcnJvcihg0J7RiNC40LHQutCwINC30LDQv9C40YHQuCDQsiBsb2NhbFN0b3JhZ2Ug0LTQu9GPINC60LvRjtGH0LAgJHtrZXl9OmAsIGVycm9yKTtcbiAgICAgICB9XG4gICB9XG59O1xuXG4vLyDQodC+0LfQtNCw0LXQvCDQv9GA0L7QstCw0LnQtNC10YAg0LrQvtC90YLQtdC60YHRgtCwXG5leHBvcnQgY29uc3QgU2V0dGluZ3NQcm92aWRlciA9ICh7IGNoaWxkcmVuIH0pID0+IHtcbiAgLy8g0KHQvtGB0YLQvtGP0L3QuNC1INC00LvRjyDQvtGC0YHQu9C10LbQuNCy0LDQvdC40Y8g0LrQu9C40LXQvdGC0YHQutC+0Lkg0YHRgtC+0YDQvtC90YsgKNC/0YDQtdC00L7RgtCy0YDQsNGJ0LXQvdC40LUg0LPQuNC00YDQsNGC0LDRhtC40LgpXG4gIGNvbnN0IFtpc0NsaWVudCwgc2V0SXNDbGllbnRdID0gdXNlU3RhdGUoZmFsc2UpO1xuICBcbiAgLy8g0J/QtdGA0LXQvdC+0YHQuNC8INGB0L7RgdGC0L7Rj9C90LjRjyDQuNC3IHBhZ2VzL2luZGV4LmpzeFxuICBjb25zdCBbdGV4dCwgc2V0VGV4dF0gPSB1c2VTdGF0ZShERUZBVUxUX1NFVFRJTkdTLlRFWFQpOyAvLyDQotC10LrRgdGCINC90LUg0YXRgNCw0L3QuNC8INCyIExTINC/0L7QutCwXG4gIGNvbnN0IFtmb250U2l6ZSwgc2V0Rm9udFNpemVdID0gdXNlU3RhdGUoREVGQVVMVF9TRVRUSU5HUy5GT05UX1NJWkUpOyAvLyDQmNC90LjRhtC40LDQu9C40LfQuNGA0YPQtdC8INC00LXRhNC+0LvRgtC+0LxcbiAgY29uc3QgW2xpbmVIZWlnaHQsIHNldExpbmVIZWlnaHRdID0gdXNlU3RhdGUoREVGQVVMVF9TRVRUSU5HUy5MSU5FX0hFSUdIVCk7XG4gIGNvbnN0IFtsZXR0ZXJTcGFjaW5nLCBzZXRMZXR0ZXJTcGFjaW5nXSA9IHVzZVN0YXRlKERFRkFVTFRfU0VUVElOR1MuTEVUVEVSX1NQQUNJTkcpO1xuICBjb25zdCBbdGV4dENvbG9yLCBzZXRUZXh0Q29sb3JdID0gdXNlU3RhdGUoREVGQVVMVF9TRVRUSU5HUy5URVhUX0NPTE9SKTtcbiAgY29uc3QgW2JhY2tncm91bmRDb2xvciwgc2V0QmFja2dyb3VuZENvbG9yXSA9IHVzZVN0YXRlKERFRkFVTFRfU0VUVElOR1MuQkFDS0dST1VORF9DT0xPUik7XG4gIGNvbnN0IFt2aWV3TW9kZSwgc2V0Vmlld01vZGVdID0gdXNlU3RhdGUoREVGQVVMVF9TRVRUSU5HUy5WSUVXX01PREUpO1xuICBjb25zdCBbdGV4dERpcmVjdGlvbiwgc2V0VGV4dERpcmVjdGlvbl0gPSB1c2VTdGF0ZShERUZBVUxUX1NFVFRJTkdTLlRFWFRfRElSRUNUSU9OKTtcbiAgY29uc3QgW3RleHRBbGlnbm1lbnQsIHNldFRleHRBbGlnbm1lbnRdID0gdXNlU3RhdGUoREVGQVVMVF9TRVRUSU5HUy5URVhUX0FMSUdOTUVOVCk7XG4gIGNvbnN0IFt0ZXh0Q2FzZSwgc2V0VGV4dENhc2VdID0gdXNlU3RhdGUoREVGQVVMVF9TRVRUSU5HUy5URVhUX0NBU0UpO1xuICBjb25zdCBbdGV4dENlbnRlciwgc2V0VGV4dENlbnRlcl0gPSB1c2VTdGF0ZShERUZBVUxUX1NFVFRJTkdTLlRFWFRfQ0VOVEVSKTtcbiAgY29uc3QgW3RleHRGaWxsLCBzZXRUZXh0RmlsbF0gPSB1c2VTdGF0ZShERUZBVUxUX1NFVFRJTkdTLlRFWFRfRklMTCk7XG4gIFxuICAvLyDQrdGE0YTQtdC60YIg0LTQu9GPINC40L3QuNGG0LjQsNC70LjQt9Cw0YbQuNC4INC60LvQuNC10L3RgtGB0LrQvtC5INGB0YLQvtGA0L7QvdGLINC4INC30LDQs9GA0YPQt9C60Lgg0LjQtyBsb2NhbFN0b3JhZ2VcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBzZXRJc0NsaWVudCh0cnVlKTtcbiAgICBcbiAgICAvLyDQl9Cw0LPRgNGD0LbQsNC10Lwg0LfQvdCw0YfQtdC90LjRjyDQuNC3IGxvY2FsU3RvcmFnZSDRgtC+0LvRjNC60L4g0L3QsCDQutC70LjQtdC90YLQtVxuICAgIHNldEZvbnRTaXplKGdldExvY2FsU3RvcmFnZUl0ZW0oTE9DQUxfU1RPUkFHRV9LRVlTLkZPTlRfU0laRSwgREVGQVVMVF9TRVRUSU5HUy5GT05UX1NJWkUpKTtcbiAgICBzZXRMaW5lSGVpZ2h0KGdldExvY2FsU3RvcmFnZUl0ZW0oTE9DQUxfU1RPUkFHRV9LRVlTLkxJTkVfSEVJR0hULCBERUZBVUxUX1NFVFRJTkdTLkxJTkVfSEVJR0hUKSk7XG4gICAgc2V0TGV0dGVyU3BhY2luZyhnZXRMb2NhbFN0b3JhZ2VJdGVtKExPQ0FMX1NUT1JBR0VfS0VZUy5MRVRURVJfU1BBQ0lORywgREVGQVVMVF9TRVRUSU5HUy5MRVRURVJfU1BBQ0lORykpO1xuICAgIHNldFRleHRDb2xvcihnZXRMb2NhbFN0b3JhZ2VJdGVtKExPQ0FMX1NUT1JBR0VfS0VZUy5URVhUX0NPTE9SLCBERUZBVUxUX1NFVFRJTkdTLlRFWFRfQ09MT1IpKTtcbiAgICBzZXRCYWNrZ3JvdW5kQ29sb3IoZ2V0TG9jYWxTdG9yYWdlSXRlbShMT0NBTF9TVE9SQUdFX0tFWVMuQkFDS0dST1VORF9DT0xPUiwgREVGQVVMVF9TRVRUSU5HUy5CQUNLR1JPVU5EX0NPTE9SKSk7XG4gICAgc2V0Vmlld01vZGUoZ2V0TG9jYWxTdG9yYWdlSXRlbShMT0NBTF9TVE9SQUdFX0tFWVMuVklFV19NT0RFLCBERUZBVUxUX1NFVFRJTkdTLlZJRVdfTU9ERSkpO1xuICAgIHNldFRleHREaXJlY3Rpb24oZ2V0TG9jYWxTdG9yYWdlSXRlbShMT0NBTF9TVE9SQUdFX0tFWVMuVEVYVF9ESVJFQ1RJT04sIERFRkFVTFRfU0VUVElOR1MuVEVYVF9ESVJFQ1RJT04pKTtcbiAgICBzZXRUZXh0QWxpZ25tZW50KGdldExvY2FsU3RvcmFnZUl0ZW0oTE9DQUxfU1RPUkFHRV9LRVlTLlRFWFRfQUxJR05NRU5ULCBERUZBVUxUX1NFVFRJTkdTLlRFWFRfQUxJR05NRU5UKSk7XG4gICAgc2V0VGV4dENhc2UoZ2V0TG9jYWxTdG9yYWdlSXRlbShMT0NBTF9TVE9SQUdFX0tFWVMuVEVYVF9DQVNFLCBERUZBVUxUX1NFVFRJTkdTLlRFWFRfQ0FTRSkpO1xuICAgIHNldFRleHRDZW50ZXIoZ2V0TG9jYWxTdG9yYWdlSXRlbShMT0NBTF9TVE9SQUdFX0tFWVMuVEVYVF9DRU5URVIsIERFRkFVTFRfU0VUVElOR1MuVEVYVF9DRU5URVIpKTtcbiAgICBzZXRUZXh0RmlsbChnZXRMb2NhbFN0b3JhZ2VJdGVtKExPQ0FMX1NUT1JBR0VfS0VZUy5URVhUX0ZJTEwsIERFRkFVTFRfU0VUVElOR1MuVEVYVF9GSUxMKSk7XG4gIH0sIFtdKTtcblxuICAvLyA8PDwgdXNlRWZmZWN0cyDQtNC70Y8g0YHQvtGF0YDQsNC90LXQvdC40Y8g0LIgbG9jYWxTdG9yYWdlICjRgtC+0LvRjNC60L4g0L/QvtGB0LvQtSDQutC70LjQtdC90YLRgdC60L7QuSDQuNC90LjRhtC40LDQu9C40LfQsNGG0LjQuCkgPj4+XG4gIHVzZUVmZmVjdCgoKSA9PiB7IGlmIChpc0NsaWVudCkgc2V0TG9jYWxTdG9yYWdlSXRlbShMT0NBTF9TVE9SQUdFX0tFWVMuQkFDS0dST1VORF9DT0xPUiwgYmFja2dyb3VuZENvbG9yKTsgfSwgW2JhY2tncm91bmRDb2xvciwgaXNDbGllbnRdKTtcbiAgdXNlRWZmZWN0KCgpID0+IHsgaWYgKGlzQ2xpZW50KSBzZXRMb2NhbFN0b3JhZ2VJdGVtKExPQ0FMX1NUT1JBR0VfS0VZUy5URVhUX0NPTE9SLCB0ZXh0Q29sb3IpOyB9LCBbdGV4dENvbG9yLCBpc0NsaWVudF0pO1xuICB1c2VFZmZlY3QoKCkgPT4geyBpZiAoaXNDbGllbnQpIHNldExvY2FsU3RvcmFnZUl0ZW0oTE9DQUxfU1RPUkFHRV9LRVlTLkZPTlRfU0laRSwgZm9udFNpemUpOyB9LCBbZm9udFNpemUsIGlzQ2xpZW50XSk7XG4gIHVzZUVmZmVjdCgoKSA9PiB7IGlmIChpc0NsaWVudCkgc2V0TG9jYWxTdG9yYWdlSXRlbShMT0NBTF9TVE9SQUdFX0tFWVMuTElORV9IRUlHSFQsIGxpbmVIZWlnaHQpOyB9LCBbbGluZUhlaWdodCwgaXNDbGllbnRdKTtcbiAgdXNlRWZmZWN0KCgpID0+IHsgaWYgKGlzQ2xpZW50KSBzZXRMb2NhbFN0b3JhZ2VJdGVtKExPQ0FMX1NUT1JBR0VfS0VZUy5MRVRURVJfU1BBQ0lORywgbGV0dGVyU3BhY2luZyk7IH0sIFtsZXR0ZXJTcGFjaW5nLCBpc0NsaWVudF0pO1xuICB1c2VFZmZlY3QoKCkgPT4geyBpZiAoaXNDbGllbnQpIHNldExvY2FsU3RvcmFnZUl0ZW0oTE9DQUxfU1RPUkFHRV9LRVlTLlZJRVdfTU9ERSwgdmlld01vZGUpOyB9LCBbdmlld01vZGUsIGlzQ2xpZW50XSk7XG4gIHVzZUVmZmVjdCgoKSA9PiB7IGlmIChpc0NsaWVudCkgc2V0TG9jYWxTdG9yYWdlSXRlbShMT0NBTF9TVE9SQUdFX0tFWVMuVEVYVF9ESVJFQ1RJT04sIHRleHREaXJlY3Rpb24pOyB9LCBbdGV4dERpcmVjdGlvbiwgaXNDbGllbnRdKTtcbiAgdXNlRWZmZWN0KCgpID0+IHsgaWYgKGlzQ2xpZW50KSBzZXRMb2NhbFN0b3JhZ2VJdGVtKExPQ0FMX1NUT1JBR0VfS0VZUy5URVhUX0FMSUdOTUVOVCwgdGV4dEFsaWdubWVudCk7IH0sIFt0ZXh0QWxpZ25tZW50LCBpc0NsaWVudF0pO1xuICB1c2VFZmZlY3QoKCkgPT4geyBpZiAoaXNDbGllbnQpIHNldExvY2FsU3RvcmFnZUl0ZW0oTE9DQUxfU1RPUkFHRV9LRVlTLlRFWFRfQ0FTRSwgdGV4dENhc2UpOyB9LCBbdGV4dENhc2UsIGlzQ2xpZW50XSk7XG4gIHVzZUVmZmVjdCgoKSA9PiB7IGlmIChpc0NsaWVudCkgc2V0TG9jYWxTdG9yYWdlSXRlbShMT0NBTF9TVE9SQUdFX0tFWVMuVEVYVF9DRU5URVIsIHRleHRDZW50ZXIpOyB9LCBbdGV4dENlbnRlciwgaXNDbGllbnRdKTtcbiAgdXNlRWZmZWN0KCgpID0+IHsgaWYgKGlzQ2xpZW50KSBzZXRMb2NhbFN0b3JhZ2VJdGVtKExPQ0FMX1NUT1JBR0VfS0VZUy5URVhUX0ZJTEwsIHRleHRGaWxsKTsgfSwgW3RleHRGaWxsLCBpc0NsaWVudF0pO1xuXG4gIC8vIDw8PCDQpNGD0L3QutGG0LjRjyDRgdCx0YDQvtGB0LAg0L3QsNGB0YLRgNC+0LXQuiA+Pj5cbiAgY29uc3QgcmVzZXRTZXR0aW5ncyA9IHVzZUNhbGxiYWNrKCgpID0+IHtcbiAgICBzZXRUZXh0KERFRkFVTFRfU0VUVElOR1MuVEVYVCk7XG4gICAgc2V0Rm9udFNpemUoREVGQVVMVF9TRVRUSU5HUy5GT05UX1NJWkUpO1xuICAgIHNldExpbmVIZWlnaHQoREVGQVVMVF9TRVRUSU5HUy5MSU5FX0hFSUdIVCk7XG4gICAgc2V0TGV0dGVyU3BhY2luZyhERUZBVUxUX1NFVFRJTkdTLkxFVFRFUl9TUEFDSU5HKTtcbiAgICBzZXRUZXh0Q29sb3IoREVGQVVMVF9TRVRUSU5HUy5URVhUX0NPTE9SKTtcbiAgICBzZXRCYWNrZ3JvdW5kQ29sb3IoREVGQVVMVF9TRVRUSU5HUy5CQUNLR1JPVU5EX0NPTE9SKTtcbiAgICBzZXRWaWV3TW9kZShERUZBVUxUX1NFVFRJTkdTLlZJRVdfTU9ERSk7XG4gICAgc2V0VGV4dERpcmVjdGlvbihERUZBVUxUX1NFVFRJTkdTLlRFWFRfRElSRUNUSU9OKTtcbiAgICBzZXRUZXh0QWxpZ25tZW50KERFRkFVTFRfU0VUVElOR1MuVEVYVF9BTElHTk1FTlQpO1xuICAgIHNldFRleHRDYXNlKERFRkFVTFRfU0VUVElOR1MuVEVYVF9DQVNFKTtcbiAgICBzZXRUZXh0Q2VudGVyKERFRkFVTFRfU0VUVElOR1MuVEVYVF9DRU5URVIpO1xuICAgIHNldFRleHRGaWxsKERFRkFVTFRfU0VUVElOR1MuVEVYVF9GSUxMKTtcblxuICAgIC8vINCe0YfQuNGJ0LDQtdC8IGxvY2FsU3RvcmFnZVxuICAgIE9iamVjdC52YWx1ZXMoTE9DQUxfU1RPUkFHRV9LRVlTKS5mb3JFYWNoKGtleSA9PiB7XG4gICAgICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcpIGxvY2FsU3RvcmFnZS5yZW1vdmVJdGVtKGtleSk7XG4gICAgfSk7XG4gICAgY29uc29sZS5sb2coJ1tTZXR0aW5nc0NvbnRleHRdINCd0LDRgdGC0YDQvtC50LrQuCDRgdCx0YDQvtGI0LXQvdGLINC6INC00LXRhNC+0LvRgtC90YvQvCDQuCBsb2NhbFN0b3JhZ2Ug0L7Rh9C40YnQtdC9LicpO1xuICB9LCBbXSk7IC8vINCd0LXRgiDQt9Cw0LLQuNGB0LjQvNC+0YHRgtC10LksINGCLtC6LiDQuNGB0L/QvtC70YzQt9GD0LXQvCDRgtC+0LvRjNC60L4g0YHQtdGC0YLQtdGA0Ysg0Lgg0LrQvtC90YHRgtCw0L3RgtGLXG5cbiAgLy8g0JfQvdCw0YfQtdC90LjQtSwg0LrQvtGC0L7RgNC+0LUg0LHRg9C00LXRgiDQv9C10YDQtdC00LDQvdC+INGH0LXRgNC10Lcg0LrQvtC90YLQtdC60YHRglxuICBjb25zdCB2YWx1ZSA9IHtcbiAgICB0ZXh0LFxuICAgIHNldFRleHQsXG4gICAgZm9udFNpemUsXG4gICAgc2V0Rm9udFNpemUsXG4gICAgbGluZUhlaWdodCxcbiAgICBzZXRMaW5lSGVpZ2h0LFxuICAgIGxldHRlclNwYWNpbmcsXG4gICAgc2V0TGV0dGVyU3BhY2luZyxcbiAgICB0ZXh0Q29sb3IsXG4gICAgc2V0VGV4dENvbG9yLFxuICAgIGJhY2tncm91bmRDb2xvcixcbiAgICBzZXRCYWNrZ3JvdW5kQ29sb3IsXG4gICAgdmlld01vZGUsXG4gICAgc2V0Vmlld01vZGUsXG4gICAgdGV4dERpcmVjdGlvbixcbiAgICBzZXRUZXh0RGlyZWN0aW9uLFxuICAgIHRleHRBbGlnbm1lbnQsXG4gICAgc2V0VGV4dEFsaWdubWVudCxcbiAgICB0ZXh0Q2FzZSxcbiAgICBzZXRUZXh0Q2FzZSxcbiAgICB0ZXh0Q2VudGVyLFxuICAgIHNldFRleHRDZW50ZXIsXG4gICAgdGV4dEZpbGwsXG4gICAgc2V0VGV4dEZpbGwsXG4gICAgcmVzZXRTZXR0aW5ncyxcbiAgfTtcblxuICByZXR1cm4gKFxuICAgIDxTZXR0aW5nc0NvbnRleHQuUHJvdmlkZXIgdmFsdWU9e3ZhbHVlfT5cbiAgICAgIHtjaGlsZHJlbn1cbiAgICA8L1NldHRpbmdzQ29udGV4dC5Qcm92aWRlcj5cbiAgKTtcbn07XG5cbi8vINCl0YPQuiDQtNC70Y8g0YPQtNC+0LHQvdC+0LPQviDQuNGB0L/QvtC70YzQt9C+0LLQsNC90LjRjyDQutC+0L3RgtC10LrRgdGC0LBcbmV4cG9ydCBjb25zdCB1c2VTZXR0aW5ncyA9ICgpID0+IHtcbiAgY29uc3QgY29udGV4dCA9IHVzZUNvbnRleHQoU2V0dGluZ3NDb250ZXh0KTtcbiAgaWYgKGNvbnRleHQgPT09IHVuZGVmaW5lZCkge1xuICAgIHRocm93IG5ldyBFcnJvcigndXNlU2V0dGluZ3MgbXVzdCBiZSB1c2VkIHdpdGhpbiBhIFNldHRpbmdzUHJvdmlkZXInKTtcbiAgfVxuICByZXR1cm4gY29udGV4dDtcbn07ICJdLCJuYW1lcyI6WyJSZWFjdCIsImNyZWF0ZUNvbnRleHQiLCJ1c2VTdGF0ZSIsInVzZUNvbnRleHQiLCJ1c2VFZmZlY3QiLCJ1c2VDYWxsYmFjayIsIlNldHRpbmdzQ29udGV4dCIsIkxPQ0FMX1NUT1JBR0VfS0VZUyIsIkJBQ0tHUk9VTkRfQ09MT1IiLCJURVhUX0NPTE9SIiwiRk9OVF9TSVpFIiwiTElORV9IRUlHSFQiLCJMRVRURVJfU1BBQ0lORyIsIlZJRVdfTU9ERSIsIlRFWFRfRElSRUNUSU9OIiwiVEVYVF9BTElHTk1FTlQiLCJURVhUX0NBU0UiLCJURVhUX0NFTlRFUiIsIlRFWFRfRklMTCIsIkRFRkFVTFRfU0VUVElOR1MiLCJURVhUIiwiZ2V0TG9jYWxTdG9yYWdlSXRlbSIsImtleSIsImRlZmF1bHRWYWx1ZSIsIml0ZW0iLCJsb2NhbFN0b3JhZ2UiLCJnZXRJdGVtIiwiSlNPTiIsInBhcnNlIiwiZXJyb3IiLCJjb25zb2xlIiwic2V0TG9jYWxTdG9yYWdlSXRlbSIsInZhbHVlIiwic2V0SXRlbSIsInN0cmluZ2lmeSIsIlNldHRpbmdzUHJvdmlkZXIiLCJjaGlsZHJlbiIsImlzQ2xpZW50Iiwic2V0SXNDbGllbnQiLCJ0ZXh0Iiwic2V0VGV4dCIsImZvbnRTaXplIiwic2V0Rm9udFNpemUiLCJsaW5lSGVpZ2h0Iiwic2V0TGluZUhlaWdodCIsImxldHRlclNwYWNpbmciLCJzZXRMZXR0ZXJTcGFjaW5nIiwidGV4dENvbG9yIiwic2V0VGV4dENvbG9yIiwiYmFja2dyb3VuZENvbG9yIiwic2V0QmFja2dyb3VuZENvbG9yIiwidmlld01vZGUiLCJzZXRWaWV3TW9kZSIsInRleHREaXJlY3Rpb24iLCJzZXRUZXh0RGlyZWN0aW9uIiwidGV4dEFsaWdubWVudCIsInNldFRleHRBbGlnbm1lbnQiLCJ0ZXh0Q2FzZSIsInNldFRleHRDYXNlIiwidGV4dENlbnRlciIsInNldFRleHRDZW50ZXIiLCJ0ZXh0RmlsbCIsInNldFRleHRGaWxsIiwicmVzZXRTZXR0aW5ncyIsIk9iamVjdCIsInZhbHVlcyIsImZvckVhY2giLCJyZW1vdmVJdGVtIiwibG9nIiwiUHJvdmlkZXIiLCJ1c2VTZXR0aW5ncyIsImNvbnRleHQiLCJ1bmRlZmluZWQiLCJFcnJvciJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./contexts/SettingsContext.js\n"));

/***/ }),

/***/ "./hooks/useFontCss.js":
/*!*****************************!*\
  !*** ./hooks/useFontCss.js ***!
  \*****************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   useFontCss: function() { return /* binding */ useFontCss; }\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"./node_modules/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var react_toastify__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react-toastify */ \"./node_modules/react-toastify/dist/index.mjs\");\n/* harmony import */ var _utils_cssGenerator__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utils/cssGenerator */ \"./utils/cssGenerator.js\");\nvar _s = $RefreshSig$();\n\n\n\n/**\n * Хук для управления CSS стилями шрифтов.\n * \n * @param {Object} selectedFont - Текущий выбранный объект шрифта.\n * @param {Object} variableSettings - Текущие настройки вариативных осей.\n * @param {boolean} isSelectedFontVariable - Флаг, является ли выбранный шрифт вариативным.\n * @returns {Object} - Объект с CSS функциями и свойствами.\n */ function useFontCss(selectedFont, variableSettings, isSelectedFontVariable) {\n    _s();\n    /**\n   * Возвращает строку font-family для текущего или указанного шрифта.\n   * (Перенесено из useFontManager)\n   * \n   * @param {Object|null} font - Шрифт для получения font-family (по умолчанию selectedFont).\n   * @returns {string} - Строка font-family для CSS.\n   */ const getFontFamily = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(function() {\n        let font = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : null;\n        const targetFont = font || selectedFont;\n        if (!targetFont) return \"inherit\";\n        // Используем fontFamily из объекта шрифта, если он есть\n        if (targetFont.fontFamily) {\n            return '\"'.concat(targetFont.fontFamily, '\"');\n        }\n        // Для Fontsource шрифтов генерируем имя на основе name\n        if (targetFont.source === \"fontsource\" && targetFont.name) {\n            return '\"'.concat(targetFont.name, '\"');\n        }\n        // Для локальных шрифтов используем name или filename\n        if (targetFont.name) {\n            return '\"'.concat(targetFont.name, '\"');\n        }\n        // Если есть filename (без расширения), используем его\n        if (targetFont.filename) {\n            const nameWithoutExt = targetFont.filename.replace(/\\.[^/.]+$/, \"\");\n            return '\"'.concat(nameWithoutExt, '\"');\n        }\n        // Если ничего не найдено, используем ID как fallback\n        if (targetFont.id) {\n            console.warn(\"getFontFamily: Возвращаем временное имя на основе ID, т.к. fontFamily еще не установлен.\");\n            return '\"Font_'.concat(targetFont.id, '\"');\n        }\n        return \"inherit\";\n    }, [\n        selectedFont\n    ]);\n    /**\n   * Возвращает строку font-variation-settings для текущего или указанного шрифта.\n   * (Перенесено из useFontManager)\n   * \n   * @param {Object|null} font - Шрифт для получения настроек (по умолчанию selectedFont).\n   * @param {Object|null} settings - Настройки осей (по умолчанию variableSettings).\n   * @returns {string} - Строка font-variation-settings для CSS.\n   */ const getVariationSettings = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(function() {\n        let font = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : null, settings = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;\n        const targetFont = font || selectedFont;\n        const targetSettings = settings || variableSettings;\n        if (!targetFont || !targetFont.isVariableFont || !targetSettings) {\n            return \"normal\";\n        }\n        // Проверяем, что targetSettings - это объект с настройками\n        if (typeof targetSettings !== \"object\" || Object.keys(targetSettings).length === 0) {\n            return \"normal\";\n        }\n        // Генерируем строку font-variation-settings\n        const variationString = Object.entries(targetSettings).map((param)=>{\n            let [tag, value] = param;\n            return '\"'.concat(tag, '\" ').concat(value);\n        }).join(\", \");\n        return variationString || \"normal\";\n    }, [\n        selectedFont,\n        variableSettings\n    ]);\n    /**\n   * Мемоизированные CSS свойства для текущего шрифта.\n   * (Перенесено из useFontManager)\n   */ const fontCssProperties = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>{\n        if (!selectedFont) {\n            return {\n                fontFamily: \"inherit\"\n            };\n        }\n        const properties = {\n            fontFamily: getFontFamily()\n        };\n        if (isSelectedFontVariable) {\n            const variationSettings = getVariationSettings();\n            if (variationSettings && variationSettings !== \"normal\") {\n                properties.fontVariationSettings = variationSettings;\n            }\n        } else {\n            // Для статических шрифтов добавляем weight и style\n            if (selectedFont.currentWeight) {\n                properties.fontWeight = selectedFont.currentWeight;\n            }\n            if (selectedFont.currentStyle && selectedFont.currentStyle !== \"normal\") {\n                properties.fontStyle = selectedFont.currentStyle;\n            }\n        }\n        console.log(\"[fontCssProperties] Обновляем CSS для \".concat(selectedFont.name, \":\"), properties);\n        return properties;\n    }, [\n        selectedFont,\n        selectedFont === null || selectedFont === void 0 ? void 0 : selectedFont.currentWeight,\n        selectedFont === null || selectedFont === void 0 ? void 0 : selectedFont.currentStyle,\n        isSelectedFontVariable,\n        getFontFamily,\n        getVariationSettings\n    ]);\n    /**\n   * Генерирует CSS свойства для применения к элементам.\n   * (Перенесено из useFontManager)\n   * \n   * @returns {Object} - Объект с CSS свойствами.\n   */ const generateCSS = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(()=>{\n        return fontCssProperties;\n    }, [\n        fontCssProperties\n    ]);\n    /**\n   * Загружает шрифт с использованием FontFace API.\n   * (Перенесено из useFontManager)\n   * \n   * @param {Object} font - Объект шрифта для загрузки.\n   * @param {Object} settings - Настройки вариативных осей (опционально).\n   * @returns {Promise<FontFace|null>} - Промис с объектом FontFace или null.\n   */ const loadFontFace = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(async function(font) {\n        let settings = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};\n        if (!font) return null;\n        try {\n            const fontFamily = getFontFamily(font);\n            const url = font.url;\n            if (!url) {\n                console.warn(\"Нет URL для загрузки шрифта:\", font);\n                return null;\n            }\n            const fontFace = await (0,_utils_cssGenerator__WEBPACK_IMPORTED_MODULE_2__.loadFontFaceIfNeeded)(fontFamily.replace(/\"/g, \"\"), url, settings);\n            return fontFace;\n        } catch (error) {\n            console.error(\"Ошибка при загрузке FontFace:\", error);\n            react_toastify__WEBPACK_IMPORTED_MODULE_1__.toast.error(\"Ошибка загрузки шрифта: \".concat(error.message));\n            return null;\n        }\n    }, [\n        getFontFamily\n    ]);\n    /**\n   * Обновляет CSS для вариативного шрифта.\n   * (Перенесено из useFontManager)\n   * \n   * @param {Object} font - Объект шрифта.\n   * @param {Object} currentSettings - Текущие настройки осей.\n   * @param {Object} prevSettings - Предыдущие настройки осей.\n   */ const updateVariableFontCss = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(function(font, currentSettings) {\n        let prevSettings = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : null;\n        if (!font || !font.isVariableFont) return;\n        try {\n            (0,_utils_cssGenerator__WEBPACK_IMPORTED_MODULE_2__.updateVariableFontSettings)(font, currentSettings, prevSettings);\n        } catch (error) {\n            console.error(\"Ошибка при обновлении CSS вариативного шрифта:\", error);\n        }\n    }, []);\n    /**\n   * Debounced версия обновления CSS для вариативного шрифта.\n   * (Перенесено из useFontManager)\n   */ const debouncedUpdateVariableFontCss = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(function(font, currentSettings) {\n        let prevSettings = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : null;\n        if (!font || !font.isVariableFont) return;\n        try {\n            (0,_utils_cssGenerator__WEBPACK_IMPORTED_MODULE_2__.debouncedUpdateVariableFontSettings)(font, currentSettings, prevSettings);\n        } catch (error) {\n            console.error(\"Ошибка при debounced обновлении CSS вариативного шрифта:\", error);\n        }\n    }, []);\n    /**\n   * Генерирует CSS строку для экспорта.\n   * (Перенесено из useFontManager)\n   * \n   * @param {Object} font - Объект шрифта (по умолчанию selectedFont).\n   * @param {string} selectedFontName - Имя выбранного шрифта.\n   * @returns {string} - CSS строка для экспорта.\n   */ const exportToCSS = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(function() {\n        let font = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : null, selectedFontName = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : \"\";\n        const targetFont = font || selectedFont;\n        const targetFontName = selectedFontName || (targetFont === null || targetFont === void 0 ? void 0 : targetFont.name) || \"Unknown Font\";\n        if (!targetFont) {\n            return \"/* Нет выбранного шрифта для экспорта */\";\n        }\n        const css = generateCSS(); // Получаем { fontFamily, fontVariationSettings?, fontWeight?, fontStyle? }\n        let cssString = \"/* CSS для шрифта: \".concat(targetFontName, \" */\\n\");\n        cssString += \".font-\".concat(targetFontName.replace(/\\s+/g, \"-\").toLowerCase(), \" {\\n\");\n        Object.entries(css).forEach((param)=>{\n            let [property, value] = param;\n            // Конвертируем camelCase в kebab-case\n            const kebabProperty = property.replace(/([A-Z])/g, \"-$1\").toLowerCase();\n            cssString += \"  \".concat(kebabProperty, \": \").concat(value, \";\\n\");\n        });\n        cssString += \"}\\n\";\n        return cssString;\n    }, [\n        selectedFont,\n        generateCSS\n    ]);\n    return {\n        // CSS функции\n        getFontFamily,\n        getVariationSettings,\n        generateCSS,\n        // FontFace API\n        loadFontFace,\n        // Обновление CSS\n        updateVariableFontCss,\n        debouncedUpdateVariableFontCss,\n        // Экспорт\n        exportToCSS,\n        // Мемоизированные свойства\n        fontCssProperties\n    };\n}\n_s(useFontCss, \"qDqQLMwB3Y8nfuRJN0uUKmTN2xQ=\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QUNWQztRQUVBLDJCQUEyQjtRQUMzQm5CO0lBQ0Y7QUFDRjtHQXZPZ0I3QiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ob29rcy91c2VGb250Q3NzLmpzP2IxMjciXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgdXNlQ2FsbGJhY2ssIHVzZU1lbW8gfSBmcm9tICdyZWFjdCc7XG5pbXBvcnQgeyB0b2FzdCB9IGZyb20gJ3JlYWN0LXRvYXN0aWZ5JztcbmltcG9ydCB7IGxvYWRGb250RmFjZUlmTmVlZGVkLCB1cGRhdGVWYXJpYWJsZUZvbnRTZXR0aW5ncywgZGVib3VuY2VkVXBkYXRlVmFyaWFibGVGb250U2V0dGluZ3MgfSBmcm9tICcuLi91dGlscy9jc3NHZW5lcmF0b3InO1xuXG4vKipcbiAqINCl0YPQuiDQtNC70Y8g0YPQv9GA0LDQstC70LXQvdC40Y8gQ1NTINGB0YLQuNC70Y/QvNC4INGI0YDQuNGE0YLQvtCyLlxuICogXG4gKiBAcGFyYW0ge09iamVjdH0gc2VsZWN0ZWRGb250IC0g0KLQtdC60YPRidC40Lkg0LLRi9Cx0YDQsNC90L3Ri9C5INC+0LHRitC10LrRgiDRiNGA0LjRhNGC0LAuXG4gKiBAcGFyYW0ge09iamVjdH0gdmFyaWFibGVTZXR0aW5ncyAtINCi0LXQutGD0YnQuNC1INC90LDRgdGC0YDQvtC50LrQuCDQstCw0YDQuNCw0YLQuNCy0L3Ri9GFINC+0YHQtdC5LlxuICogQHBhcmFtIHtib29sZWFufSBpc1NlbGVjdGVkRm9udFZhcmlhYmxlIC0g0KTQu9Cw0LMsINGP0LLQu9GP0LXRgtGB0Y8g0LvQuCDQstGL0LHRgNCw0L3QvdGL0Lkg0YjRgNC40YTRgiDQstCw0YDQuNCw0YLQuNCy0L3Ri9C8LlxuICogQHJldHVybnMge09iamVjdH0gLSDQntCx0YrQtdC60YIg0YEgQ1NTINGE0YPQvdC60YbQuNGP0LzQuCDQuCDRgdCy0L7QudGB0YLQstCw0LzQuC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHVzZUZvbnRDc3Moc2VsZWN0ZWRGb250LCB2YXJpYWJsZVNldHRpbmdzLCBpc1NlbGVjdGVkRm9udFZhcmlhYmxlKSB7XG5cbiAgLyoqXG4gICAqINCS0L7Qt9Cy0YDQsNGJ0LDQtdGCINGB0YLRgNC+0LrRgyBmb250LWZhbWlseSDQtNC70Y8g0YLQtdC60YPRidC10LPQviDQuNC70Lgg0YPQutCw0LfQsNC90L3QvtCz0L4g0YjRgNC40YTRgtCwLlxuICAgKiAo0J/QtdGA0LXQvdC10YHQtdC90L4g0LjQtyB1c2VGb250TWFuYWdlcilcbiAgICogXG4gICAqIEBwYXJhbSB7T2JqZWN0fG51bGx9IGZvbnQgLSDQqNGA0LjRhNGCINC00LvRjyDQv9C+0LvRg9GH0LXQvdC40Y8gZm9udC1mYW1pbHkgKNC/0L4g0YPQvNC+0LvRh9Cw0L3QuNGOIHNlbGVjdGVkRm9udCkuXG4gICAqIEByZXR1cm5zIHtzdHJpbmd9IC0g0KHRgtGA0L7QutCwIGZvbnQtZmFtaWx5INC00LvRjyBDU1MuXG4gICAqL1xuICBjb25zdCBnZXRGb250RmFtaWx5ID0gdXNlQ2FsbGJhY2soKGZvbnQgPSBudWxsKSA9PiB7XG4gICAgY29uc3QgdGFyZ2V0Rm9udCA9IGZvbnQgfHwgc2VsZWN0ZWRGb250O1xuICAgIGlmICghdGFyZ2V0Rm9udCkgcmV0dXJuICdpbmhlcml0JztcblxuICAgIC8vINCY0YHQv9C+0LvRjNC30YPQtdC8IGZvbnRGYW1pbHkg0LjQtyDQvtCx0YrQtdC60YLQsCDRiNGA0LjRhNGC0LAsINC10YHQu9C4INC+0L0g0LXRgdGC0YxcbiAgICBpZiAodGFyZ2V0Rm9udC5mb250RmFtaWx5KSB7XG4gICAgICByZXR1cm4gYFwiJHt0YXJnZXRGb250LmZvbnRGYW1pbHl9XCJgO1xuICAgIH1cblxuICAgIC8vINCU0LvRjyBGb250c291cmNlINGI0YDQuNGE0YLQvtCyINCz0LXQvdC10YDQuNGA0YPQtdC8INC40LzRjyDQvdCwINC+0YHQvdC+0LLQtSBuYW1lXG4gICAgaWYgKHRhcmdldEZvbnQuc291cmNlID09PSAnZm9udHNvdXJjZScgJiYgdGFyZ2V0Rm9udC5uYW1lKSB7XG4gICAgICByZXR1cm4gYFwiJHt0YXJnZXRGb250Lm5hbWV9XCJgO1xuICAgIH1cblxuICAgIC8vINCU0LvRjyDQu9C+0LrQsNC70YzQvdGL0YUg0YjRgNC40YTRgtC+0LIg0LjRgdC/0L7Qu9GM0LfRg9C10LwgbmFtZSDQuNC70LggZmlsZW5hbWVcbiAgICBpZiAodGFyZ2V0Rm9udC5uYW1lKSB7XG4gICAgICByZXR1cm4gYFwiJHt0YXJnZXRGb250Lm5hbWV9XCJgO1xuICAgIH1cblxuICAgIC8vINCV0YHQu9C4INC10YHRgtGMIGZpbGVuYW1lICjQsdC10Lcg0YDQsNGB0YjQuNGA0LXQvdC40Y8pLCDQuNGB0L/QvtC70YzQt9GD0LXQvCDQtdCz0L5cbiAgICBpZiAodGFyZ2V0Rm9udC5maWxlbmFtZSkge1xuICAgICAgY29uc3QgbmFtZVdpdGhvdXRFeHQgPSB0YXJnZXRGb250LmZpbGVuYW1lLnJlcGxhY2UoL1xcLlteLy5dKyQvLCAnJyk7XG4gICAgICByZXR1cm4gYFwiJHtuYW1lV2l0aG91dEV4dH1cImA7XG4gICAgfVxuXG4gICAgLy8g0JXRgdC70Lgg0L3QuNGH0LXQs9C+INC90LUg0L3QsNC50LTQtdC90L4sINC40YHQv9C+0LvRjNC30YPQtdC8IElEINC60LDQuiBmYWxsYmFja1xuICAgIGlmICh0YXJnZXRGb250LmlkKSB7XG4gICAgICBjb25zb2xlLndhcm4oJ2dldEZvbnRGYW1pbHk6INCS0L7Qt9Cy0YDQsNGJ0LDQtdC8INCy0YDQtdC80LXQvdC90L7QtSDQuNC80Y8g0L3QsCDQvtGB0L3QvtCy0LUgSUQsINGCLtC6LiBmb250RmFtaWx5INC10YnQtSDQvdC1INGD0YHRgtCw0L3QvtCy0LvQtdC9LicpO1xuICAgICAgcmV0dXJuIGBcIkZvbnRfJHt0YXJnZXRGb250LmlkfVwiYDtcbiAgICB9XG5cbiAgICByZXR1cm4gJ2luaGVyaXQnO1xuICB9LCBbc2VsZWN0ZWRGb250XSk7XG5cbiAgLyoqXG4gICAqINCS0L7Qt9Cy0YDQsNGJ0LDQtdGCINGB0YLRgNC+0LrRgyBmb250LXZhcmlhdGlvbi1zZXR0aW5ncyDQtNC70Y8g0YLQtdC60YPRidC10LPQviDQuNC70Lgg0YPQutCw0LfQsNC90L3QvtCz0L4g0YjRgNC40YTRgtCwLlxuICAgKiAo0J/QtdGA0LXQvdC10YHQtdC90L4g0LjQtyB1c2VGb250TWFuYWdlcilcbiAgICogXG4gICAqIEBwYXJhbSB7T2JqZWN0fG51bGx9IGZvbnQgLSDQqNGA0LjRhNGCINC00LvRjyDQv9C+0LvRg9GH0LXQvdC40Y8g0L3QsNGB0YLRgNC+0LXQuiAo0L/QviDRg9C80L7Qu9GH0LDQvdC40Y4gc2VsZWN0ZWRGb250KS5cbiAgICogQHBhcmFtIHtPYmplY3R8bnVsbH0gc2V0dGluZ3MgLSDQndCw0YHRgtGA0L7QudC60Lgg0L7RgdC10LkgKNC/0L4g0YPQvNC+0LvRh9Cw0L3QuNGOIHZhcmlhYmxlU2V0dGluZ3MpLlxuICAgKiBAcmV0dXJucyB7c3RyaW5nfSAtINCh0YLRgNC+0LrQsCBmb250LXZhcmlhdGlvbi1zZXR0aW5ncyDQtNC70Y8gQ1NTLlxuICAgKi9cbiAgY29uc3QgZ2V0VmFyaWF0aW9uU2V0dGluZ3MgPSB1c2VDYWxsYmFjaygoZm9udCA9IG51bGwsIHNldHRpbmdzID0gbnVsbCkgPT4ge1xuICAgIGNvbnN0IHRhcmdldEZvbnQgPSBmb250IHx8IHNlbGVjdGVkRm9udDtcbiAgICBjb25zdCB0YXJnZXRTZXR0aW5ncyA9IHNldHRpbmdzIHx8IHZhcmlhYmxlU2V0dGluZ3M7XG5cbiAgICBpZiAoIXRhcmdldEZvbnQgfHwgIXRhcmdldEZvbnQuaXNWYXJpYWJsZUZvbnQgfHwgIXRhcmdldFNldHRpbmdzKSB7XG4gICAgICByZXR1cm4gJ25vcm1hbCc7XG4gICAgfVxuXG4gICAgLy8g0J/RgNC+0LLQtdGA0Y/QtdC8LCDRh9GC0L4gdGFyZ2V0U2V0dGluZ3MgLSDRjdGC0L4g0L7QsdGK0LXQutGCINGBINC90LDRgdGC0YDQvtC50LrQsNC80LhcbiAgICBpZiAodHlwZW9mIHRhcmdldFNldHRpbmdzICE9PSAnb2JqZWN0JyB8fCBPYmplY3Qua2V5cyh0YXJnZXRTZXR0aW5ncykubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm4gJ25vcm1hbCc7XG4gICAgfVxuXG4gICAgLy8g0JPQtdC90LXRgNC40YDRg9C10Lwg0YHRgtGA0L7QutGDIGZvbnQtdmFyaWF0aW9uLXNldHRpbmdzXG4gICAgY29uc3QgdmFyaWF0aW9uU3RyaW5nID0gT2JqZWN0LmVudHJpZXModGFyZ2V0U2V0dGluZ3MpXG4gICAgICAubWFwKChbdGFnLCB2YWx1ZV0pID0+IGBcIiR7dGFnfVwiICR7dmFsdWV9YClcbiAgICAgIC5qb2luKCcsICcpO1xuXG4gICAgcmV0dXJuIHZhcmlhdGlvblN0cmluZyB8fCAnbm9ybWFsJztcbiAgfSwgW3NlbGVjdGVkRm9udCwgdmFyaWFibGVTZXR0aW5nc10pO1xuXG4gIC8qKlxuICAgKiDQnNC10LzQvtC40LfQuNGA0L7QstCw0L3QvdGL0LUgQ1NTINGB0LLQvtC50YHRgtCy0LAg0LTQu9GPINGC0LXQutGD0YnQtdCz0L4g0YjRgNC40YTRgtCwLlxuICAgKiAo0J/QtdGA0LXQvdC10YHQtdC90L4g0LjQtyB1c2VGb250TWFuYWdlcilcbiAgICovXG4gIGNvbnN0IGZvbnRDc3NQcm9wZXJ0aWVzID0gdXNlTWVtbygoKSA9PiB7XG4gICAgaWYgKCFzZWxlY3RlZEZvbnQpIHtcbiAgICAgIHJldHVybiB7IGZvbnRGYW1pbHk6ICdpbmhlcml0JyB9O1xuICAgIH1cblxuICAgIGNvbnN0IHByb3BlcnRpZXMgPSB7XG4gICAgICBmb250RmFtaWx5OiBnZXRGb250RmFtaWx5KClcbiAgICB9O1xuXG4gICAgaWYgKGlzU2VsZWN0ZWRGb250VmFyaWFibGUpIHtcbiAgICAgIGNvbnN0IHZhcmlhdGlvblNldHRpbmdzID0gZ2V0VmFyaWF0aW9uU2V0dGluZ3MoKTtcbiAgICAgIGlmICh2YXJpYXRpb25TZXR0aW5ncyAmJiB2YXJpYXRpb25TZXR0aW5ncyAhPT0gJ25vcm1hbCcpIHtcbiAgICAgICAgcHJvcGVydGllcy5mb250VmFyaWF0aW9uU2V0dGluZ3MgPSB2YXJpYXRpb25TZXR0aW5ncztcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8g0JTQu9GPINGB0YLQsNGC0LjRh9C10YHQutC40YUg0YjRgNC40YTRgtC+0LIg0LTQvtCx0LDQstC70Y/QtdC8IHdlaWdodCDQuCBzdHlsZVxuICAgICAgaWYgKHNlbGVjdGVkRm9udC5jdXJyZW50V2VpZ2h0KSB7XG4gICAgICAgIHByb3BlcnRpZXMuZm9udFdlaWdodCA9IHNlbGVjdGVkRm9udC5jdXJyZW50V2VpZ2h0O1xuICAgICAgfVxuICAgICAgaWYgKHNlbGVjdGVkRm9udC5jdXJyZW50U3R5bGUgJiYgc2VsZWN0ZWRGb250LmN1cnJlbnRTdHlsZSAhPT0gJ25vcm1hbCcpIHtcbiAgICAgICAgcHJvcGVydGllcy5mb250U3R5bGUgPSBzZWxlY3RlZEZvbnQuY3VycmVudFN0eWxlO1xuICAgICAgfVxuICAgIH1cblxuICAgIGNvbnNvbGUubG9nKGBbZm9udENzc1Byb3BlcnRpZXNdINCe0LHQvdC+0LLQu9GP0LXQvCBDU1Mg0LTQu9GPICR7c2VsZWN0ZWRGb250Lm5hbWV9OmAsIHByb3BlcnRpZXMpO1xuICAgIHJldHVybiBwcm9wZXJ0aWVzO1xuICB9LCBbc2VsZWN0ZWRGb250LCBzZWxlY3RlZEZvbnQ/LmN1cnJlbnRXZWlnaHQsIHNlbGVjdGVkRm9udD8uY3VycmVudFN0eWxlLCBpc1NlbGVjdGVkRm9udFZhcmlhYmxlLCBnZXRGb250RmFtaWx5LCBnZXRWYXJpYXRpb25TZXR0aW5nc10pO1xuXG4gIC8qKlxuICAgKiDQk9C10L3QtdGA0LjRgNGD0LXRgiBDU1Mg0YHQstC+0LnRgdGC0LLQsCDQtNC70Y8g0L/RgNC40LzQtdC90LXQvdC40Y8g0Log0Y3Qu9C10LzQtdC90YLQsNC8LlxuICAgKiAo0J/QtdGA0LXQvdC10YHQtdC90L4g0LjQtyB1c2VGb250TWFuYWdlcilcbiAgICogXG4gICAqIEByZXR1cm5zIHtPYmplY3R9IC0g0J7QsdGK0LXQutGCINGBIENTUyDRgdCy0L7QudGB0YLQstCw0LzQuC5cbiAgICovXG4gIGNvbnN0IGdlbmVyYXRlQ1NTID0gdXNlQ2FsbGJhY2soKCkgPT4ge1xuICAgIHJldHVybiBmb250Q3NzUHJvcGVydGllcztcbiAgfSwgW2ZvbnRDc3NQcm9wZXJ0aWVzXSk7XG5cbiAgLyoqXG4gICAqINCX0LDQs9GA0YPQttCw0LXRgiDRiNGA0LjRhNGCINGBINC40YHQv9C+0LvRjNC30L7QstCw0L3QuNC10LwgRm9udEZhY2UgQVBJLlxuICAgKiAo0J/QtdGA0LXQvdC10YHQtdC90L4g0LjQtyB1c2VGb250TWFuYWdlcilcbiAgICogXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBmb250IC0g0J7QsdGK0LXQutGCINGI0YDQuNGE0YLQsCDQtNC70Y8g0LfQsNCz0YDRg9C30LrQuC5cbiAgICogQHBhcmFtIHtPYmplY3R9IHNldHRpbmdzIC0g0J3QsNGB0YLRgNC+0LnQutC4INCy0LDRgNC40LDRgtC40LLQvdGL0YUg0L7RgdC10LkgKNC+0L/RhtC40L7QvdCw0LvRjNC90L4pLlxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTxGb250RmFjZXxudWxsPn0gLSDQn9GA0L7QvNC40YEg0YEg0L7QsdGK0LXQutGC0L7QvCBGb250RmFjZSDQuNC70LggbnVsbC5cbiAgICovXG4gIGNvbnN0IGxvYWRGb250RmFjZSA9IHVzZUNhbGxiYWNrKGFzeW5jIChmb250LCBzZXR0aW5ncyA9IHt9KSA9PiB7XG4gICAgaWYgKCFmb250KSByZXR1cm4gbnVsbDtcblxuICAgIHRyeSB7XG4gICAgICBjb25zdCBmb250RmFtaWx5ID0gZ2V0Rm9udEZhbWlseShmb250KTtcbiAgICAgIGNvbnN0IHVybCA9IGZvbnQudXJsO1xuXG4gICAgICBpZiAoIXVybCkge1xuICAgICAgICBjb25zb2xlLndhcm4oJ9Cd0LXRgiBVUkwg0LTQu9GPINC30LDQs9GA0YPQt9C60Lgg0YjRgNC40YTRgtCwOicsIGZvbnQpO1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cblxuICAgICAgY29uc3QgZm9udEZhY2UgPSBhd2FpdCBsb2FkRm9udEZhY2VJZk5lZWRlZChcbiAgICAgICAgZm9udEZhbWlseS5yZXBsYWNlKC9cIi9nLCAnJyksIC8vINCj0LHQuNGA0LDQtdC8INC60LDQstGL0YfQutC4XG4gICAgICAgIHVybCxcbiAgICAgICAgc2V0dGluZ3NcbiAgICAgICk7XG5cbiAgICAgIHJldHVybiBmb250RmFjZTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcign0J7RiNC40LHQutCwINC/0YDQuCDQt9Cw0LPRgNGD0LfQutC1IEZvbnRGYWNlOicsIGVycm9yKTtcbiAgICAgIHRvYXN0LmVycm9yKGDQntGI0LjQsdC60LAg0LfQsNCz0YDRg9C30LrQuCDRiNGA0LjRhNGC0LA6ICR7ZXJyb3IubWVzc2FnZX1gKTtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgfSwgW2dldEZvbnRGYW1pbHldKTtcblxuICAvKipcbiAgICog0J7QsdC90L7QstC70Y/QtdGCIENTUyDQtNC70Y8g0LLQsNGA0LjQsNGC0LjQstC90L7Qs9C+INGI0YDQuNGE0YLQsC5cbiAgICogKNCf0LXRgNC10L3QtdGB0LXQvdC+INC40LcgdXNlRm9udE1hbmFnZXIpXG4gICAqIFxuICAgKiBAcGFyYW0ge09iamVjdH0gZm9udCAtINCe0LHRitC10LrRgiDRiNGA0LjRhNGC0LAuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBjdXJyZW50U2V0dGluZ3MgLSDQotC10LrRg9GJ0LjQtSDQvdCw0YHRgtGA0L7QudC60Lgg0L7RgdC10LkuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBwcmV2U2V0dGluZ3MgLSDQn9GA0LXQtNGL0LTRg9GJ0LjQtSDQvdCw0YHRgtGA0L7QudC60Lgg0L7RgdC10LkuXG4gICAqL1xuICBjb25zdCB1cGRhdGVWYXJpYWJsZUZvbnRDc3MgPSB1c2VDYWxsYmFjaygoZm9udCwgY3VycmVudFNldHRpbmdzLCBwcmV2U2V0dGluZ3MgPSBudWxsKSA9PiB7XG4gICAgaWYgKCFmb250IHx8ICFmb250LmlzVmFyaWFibGVGb250KSByZXR1cm47XG5cbiAgICB0cnkge1xuICAgICAgdXBkYXRlVmFyaWFibGVGb250U2V0dGluZ3MoZm9udCwgY3VycmVudFNldHRpbmdzLCBwcmV2U2V0dGluZ3MpO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCfQntGI0LjQsdC60LAg0L/RgNC4INC+0LHQvdC+0LLQu9C10L3QuNC4IENTUyDQstCw0YDQuNCw0YLQuNCy0L3QvtCz0L4g0YjRgNC40YTRgtCwOicsIGVycm9yKTtcbiAgICB9XG4gIH0sIFtdKTtcblxuICAvKipcbiAgICogRGVib3VuY2VkINCy0LXRgNGB0LjRjyDQvtCx0L3QvtCy0LvQtdC90LjRjyBDU1Mg0LTQu9GPINCy0LDRgNC40LDRgtC40LLQvdC+0LPQviDRiNGA0LjRhNGC0LAuXG4gICAqICjQn9C10YDQtdC90LXRgdC10L3QviDQuNC3IHVzZUZvbnRNYW5hZ2VyKVxuICAgKi9cbiAgY29uc3QgZGVib3VuY2VkVXBkYXRlVmFyaWFibGVGb250Q3NzID0gdXNlQ2FsbGJhY2soKGZvbnQsIGN1cnJlbnRTZXR0aW5ncywgcHJldlNldHRpbmdzID0gbnVsbCkgPT4ge1xuICAgIGlmICghZm9udCB8fCAhZm9udC5pc1ZhcmlhYmxlRm9udCkgcmV0dXJuO1xuXG4gICAgdHJ5IHtcbiAgICAgIGRlYm91bmNlZFVwZGF0ZVZhcmlhYmxlRm9udFNldHRpbmdzKGZvbnQsIGN1cnJlbnRTZXR0aW5ncywgcHJldlNldHRpbmdzKTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcign0J7RiNC40LHQutCwINC/0YDQuCBkZWJvdW5jZWQg0L7QsdC90L7QstC70LXQvdC40LggQ1NTINCy0LDRgNC40LDRgtC40LLQvdC+0LPQviDRiNGA0LjRhNGC0LA6JywgZXJyb3IpO1xuICAgIH1cbiAgfSwgW10pO1xuXG4gIC8qKlxuICAgKiDQk9C10L3QtdGA0LjRgNGD0LXRgiBDU1Mg0YHRgtGA0L7QutGDINC00LvRjyDRjdC60YHQv9C+0YDRgtCwLlxuICAgKiAo0J/QtdGA0LXQvdC10YHQtdC90L4g0LjQtyB1c2VGb250TWFuYWdlcilcbiAgICogXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBmb250IC0g0J7QsdGK0LXQutGCINGI0YDQuNGE0YLQsCAo0L/QviDRg9C80L7Qu9GH0LDQvdC40Y4gc2VsZWN0ZWRGb250KS5cbiAgICogQHBhcmFtIHtzdHJpbmd9IHNlbGVjdGVkRm9udE5hbWUgLSDQmNC80Y8g0LLRi9Cx0YDQsNC90L3QvtCz0L4g0YjRgNC40YTRgtCwLlxuICAgKiBAcmV0dXJucyB7c3RyaW5nfSAtIENTUyDRgdGC0YDQvtC60LAg0LTQu9GPINGN0LrRgdC/0L7RgNGC0LAuXG4gICAqL1xuICBjb25zdCBleHBvcnRUb0NTUyA9IHVzZUNhbGxiYWNrKChmb250ID0gbnVsbCwgc2VsZWN0ZWRGb250TmFtZSA9ICcnKSA9PiB7XG4gICAgY29uc3QgdGFyZ2V0Rm9udCA9IGZvbnQgfHwgc2VsZWN0ZWRGb250O1xuICAgIGNvbnN0IHRhcmdldEZvbnROYW1lID0gc2VsZWN0ZWRGb250TmFtZSB8fCB0YXJnZXRGb250Py5uYW1lIHx8ICdVbmtub3duIEZvbnQnO1xuXG4gICAgaWYgKCF0YXJnZXRGb250KSB7XG4gICAgICByZXR1cm4gYC8qINCd0LXRgiDQstGL0LHRgNCw0L3QvdC+0LPQviDRiNGA0LjRhNGC0LAg0LTQu9GPINGN0LrRgdC/0L7RgNGC0LAgKi9gO1xuICAgIH1cblxuICAgIGNvbnN0IGNzcyA9IGdlbmVyYXRlQ1NTKCk7IC8vINCf0L7Qu9GD0YfQsNC10LwgeyBmb250RmFtaWx5LCBmb250VmFyaWF0aW9uU2V0dGluZ3M/LCBmb250V2VpZ2h0PywgZm9udFN0eWxlPyB9XG4gICAgXG4gICAgbGV0IGNzc1N0cmluZyA9IGAvKiBDU1Mg0LTQu9GPINGI0YDQuNGE0YLQsDogJHt0YXJnZXRGb250TmFtZX0gKi9cXG5gO1xuICAgIGNzc1N0cmluZyArPSBgLmZvbnQtJHt0YXJnZXRGb250TmFtZS5yZXBsYWNlKC9cXHMrL2csICctJykudG9Mb3dlckNhc2UoKX0ge1xcbmA7XG4gICAgXG4gICAgT2JqZWN0LmVudHJpZXMoY3NzKS5mb3JFYWNoKChbcHJvcGVydHksIHZhbHVlXSkgPT4ge1xuICAgICAgLy8g0JrQvtC90LLQtdGA0YLQuNGA0YPQtdC8IGNhbWVsQ2FzZSDQsiBrZWJhYi1jYXNlXG4gICAgICBjb25zdCBrZWJhYlByb3BlcnR5ID0gcHJvcGVydHkucmVwbGFjZSgvKFtBLVpdKS9nLCAnLSQxJykudG9Mb3dlckNhc2UoKTtcbiAgICAgIGNzc1N0cmluZyArPSBgICAke2tlYmFiUHJvcGVydHl9OiAke3ZhbHVlfTtcXG5gO1xuICAgIH0pO1xuICAgIFxuICAgIGNzc1N0cmluZyArPSBgfVxcbmA7XG4gICAgXG4gICAgcmV0dXJuIGNzc1N0cmluZztcbiAgfSwgW3NlbGVjdGVkRm9udCwgZ2VuZXJhdGVDU1NdKTtcblxuICByZXR1cm4ge1xuICAgIC8vIENTUyDRhNGD0L3QutGG0LjQuFxuICAgIGdldEZvbnRGYW1pbHksXG4gICAgZ2V0VmFyaWF0aW9uU2V0dGluZ3MsXG4gICAgZ2VuZXJhdGVDU1MsXG4gICAgXG4gICAgLy8gRm9udEZhY2UgQVBJXG4gICAgbG9hZEZvbnRGYWNlLFxuICAgIFxuICAgIC8vINCe0LHQvdC+0LLQu9C10L3QuNC1IENTU1xuICAgIHVwZGF0ZVZhcmlhYmxlRm9udENzcyxcbiAgICBkZWJvdW5jZWRVcGRhdGVWYXJpYWJsZUZvbnRDc3MsXG4gICAgXG4gICAgLy8g0K3QutGB0L/QvtGA0YJcbiAgICBleHBvcnRUb0NTUyxcbiAgICBcbiAgICAvLyDQnNC10LzQvtC40LfQuNGA0L7QstCw0L3QvdGL0LUg0YHQstC+0LnRgdGC0LLQsFxuICAgIGZvbnRDc3NQcm9wZXJ0aWVzLFxuICB9O1xufSAiXSwibmFtZXMiOlsidXNlQ2FsbGJhY2siLCJ1c2VNZW1vIiwidG9hc3QiLCJsb2FkRm9udEZhY2VJZk5lZWRlZCIsInVwZGF0ZVZhcmlhYmxlRm9udFNldHRpbmdzIiwiZGVib3VuY2VkVXBkYXRlVmFyaWFibGVGb250U2V0dGluZ3MiLCJ1c2VGb250Q3NzIiwic2VsZWN0ZWRGb250IiwidmFyaWFibGVTZXR0aW5ncyIsImlzU2VsZWN0ZWRGb250VmFyaWFibGUiLCJnZXRGb250RmFtaWx5IiwiZm9udCIsInRhcmdldEZvbnQiLCJmb250RmFtaWx5Iiwic291cmNlIiwibmFtZSIsImZpbGVuYW1lIiwibmFtZVdpdGhvdXRFeHQiLCJyZXBsYWNlIiwiaWQiLCJjb25zb2xlIiwid2FybiIsImdldFZhcmlhdGlvblNldHRpbmdzIiwic2V0dGluZ3MiLCJ0YXJnZXRTZXR0aW5ncyIsImlzVmFyaWFibGVGb250IiwiT2JqZWN0Iiwia2V5cyIsImxlbmd0aCIsInZhcmlhdGlvblN0cmluZyIsImVudHJpZXMiLCJtYXAiLCJ0YWciLCJ2YWx1ZSIsImpvaW4iLCJmb250Q3NzUHJvcGVydGllcyIsInByb3BlcnRpZXMiLCJ2YXJpYXRpb25TZXR0aW5ncyIsImZvbnRWYXJpYXRpb25TZXR0aW5ncyIsImN1cnJlbnRXZWlnaHQiLCJmb250V2VpZ2h0IiwiY3VycmVudFN0eWxlIiwiZm9udFN0eWxlIiwibG9nIiwiZ2VuZXJhdGVDU1MiLCJsb2FkRm9udEZhY2UiLCJ1cmwiLCJmb250RmFjZSIsImVycm9yIiwibWVzc2FnZSIsInVwZGF0ZVZhcmlhYmxlRm9udENzcyIsImN1cnJlbnRTZXR0aW5ncyIsInByZXZTZXR0aW5ncyIsImRlYm91bmNlZFVwZGF0ZVZhcmlhYmxlRm9udENzcyIsImV4cG9ydFRvQ1NTIiwic2VsZWN0ZWRGb250TmFtZSIsInRhcmdldEZvbnROYW1lIiwiY3NzIiwiY3NzU3RyaW5nIiwidG9Mb3dlckNhc2UiLCJmb3JFYWNoIiwicHJvcGVydHkiLCJrZWJhYlByb3BlcnR5Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./hooks/useFontCss.js\n"));

/***/ }),

/***/ "./hooks/useFontExport.js":
/*!********************************!*\
  !*** ./hooks/useFontExport.js ***!
  \********************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   useFontExport: function() { return /* binding */ useFontExport; }\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"./node_modules/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var react_toastify__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react-toastify */ \"./node_modules/react-toastify/dist/index.mjs\");\n/* harmony import */ var _utils_staticFontGenerator__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utils/staticFontGenerator */ \"./utils/staticFontGenerator.js\");\nvar _s = $RefreshSig$();\n\n\n\n/**\n * Хук для экспорта и скачивания шрифтов и CSS\n * \n * Включает в себя:\n * - Универсальную логику скачивания файлов\n * - Экспорт CSS с возможностью скачивания\n * - Создание статических версий вариативных шрифтов\n * - Подготовка к будущей логике генерации статических шрифтов\n * \n * @param {Function} exportToCSSFromHook - Функция генерации CSS из useFontCss\n * @returns {Object} Объект с методами экспорта\n */ function useFontExport(exportToCSSFromHook) {\n    _s();\n    /**\n   * Универсальная функция скачивания файлов\n   * \n   * @param {string|Blob} content - Содержимое файла (строка или Blob)\n   * @param {string} filename - Имя файла для скачивания\n   * @param {string} mimeType - MIME тип файла (игнорируется если content это Blob)\n   * @returns {boolean} Успешность операции\n   */ const downloadFile = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(function(content, filename) {\n        let mimeType = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : \"text/plain\";\n        try {\n            let blob;\n            if (content instanceof Blob) {\n                blob = content;\n            } else {\n                blob = new Blob([\n                    content\n                ], {\n                    type: mimeType\n                });\n            }\n            const url = URL.createObjectURL(blob);\n            const downloadLink = document.createElement(\"a\");\n            downloadLink.href = url;\n            downloadLink.download = filename;\n            document.body.appendChild(downloadLink);\n            downloadLink.click();\n            // Очищаем ресурсы\n            setTimeout(()=>{\n                document.body.removeChild(downloadLink);\n                URL.revokeObjectURL(url);\n            }, 100);\n            return true;\n        } catch (error) {\n            console.error(\"Ошибка скачивания файла:\", error);\n            react_toastify__WEBPACK_IMPORTED_MODULE_1__.toast.error(\"Не удалось скачать файл: \".concat(error.message));\n            return false;\n        }\n    }, []);\n    /**\n   * Создает статическую версию вариативного шрифта с текущими настройками осей\n   * \n   * @param {Object} selectedFont - Выбранный шрифт\n   * @param {string} selectedFontName - Имя выбранного шрифта\n   * @param {Object} variableSettings - Настройки вариативных осей\n   * @param {Function} setExportedFont - Функция установки экспортированного шрифта\n   * @returns {Object|undefined} Объект статического шрифта или undefined\n   */ const createStaticFont = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((selectedFont, selectedFontName, variableSettings, setExportedFont)=>{\n        if (!selectedFont) {\n            return;\n        }\n        // Создаем новое имя для статической версии шрифта\n        const staticName = \"\".concat(selectedFontName.replace(/\\.[^/.]+$/, \"\"), \"-static\");\n        // Определяем текущие настройки\n        const settings = {\n            ...variableSettings\n        };\n        // Создаем статический экспортированный шрифт\n        const newExportedFont = {\n            name: staticName,\n            settings: settings,\n            isStatic: true,\n            originalFont: selectedFontName,\n            createdAt: new Date().toISOString()\n        };\n        setExportedFont(newExportedFont);\n        react_toastify__WEBPACK_IMPORTED_MODULE_1__.toast.success(\"Создана статическая версия шрифта: \".concat(staticName));\n        return newExportedFont;\n    }, []);\n    /**\n   * Экспортирует текущие настройки шрифта в CSS с возможностью скачивания\n   * \n   * @param {Object} selectedFont - Выбранный шрифт\n   * @param {string} selectedFontName - Имя выбранного шрифта\n   * @param {boolean} download - Если true, автоматически скачивает CSS файл\n   * @returns {string} CSS-код для текущего шрифта с примененными настройками\n   */ const exportToCSS = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(function(selectedFont, selectedFontName) {\n        let download = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;\n        // Используем функцию из useFontCss для генерации CSS\n        const cssCode = exportToCSSFromHook(selectedFont, selectedFontName);\n        if (download && cssCode) {\n            const filename = \"\".concat(selectedFontName.replace(/\\s+/g, \"-\").toLowerCase(), \"-styles.css\");\n            const success = downloadFile(cssCode, filename, \"text/css\");\n            if (success) {\n                react_toastify__WEBPACK_IMPORTED_MODULE_1__.toast.success(\"CSS файл \".concat(filename, \" скачан\"));\n            }\n        }\n        return cssCode;\n    }, [\n        exportToCSSFromHook,\n        downloadFile\n    ]);\n    /**\n   * Генерирует статический шрифт из вариативного используя современные методы\n   * \n   * @param {Object} selectedFont - Вариативный шрифт\n   * @param {Object} variableSettings - Настройки осей\n   * @param {string} format - Формат выходного файла ('woff2', 'woff', 'ttf', 'otf')\n   * @returns {Promise<Blob|null>} Blob статического шрифта или null при ошибке\n   */ const generateStaticFontFile = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(async function(selectedFont, variableSettings) {\n        let format = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : \"woff2\";\n        if (!selectedFont || !selectedFont.isVariableFont) {\n            react_toastify__WEBPACK_IMPORTED_MODULE_1__.toast.error(\"Выберите вариативный шрифт для создания статической версии\");\n            return null;\n        }\n        if (!selectedFont.url && !selectedFont.arrayBuffer) {\n            react_toastify__WEBPACK_IMPORTED_MODULE_1__.toast.error(\"Нет доступа к файлу шрифта для генерации\");\n            return null;\n        }\n        try {\n            // 1. Импортируем новую утилиту для генерации\n            const { generateStaticFont, checkGenerationCapabilities } = await Promise.resolve(/*! import() */).then(__webpack_require__.bind(__webpack_require__, /*! ../utils/staticFontGenerator */ \"./utils/staticFontGenerator.js\"));\n            // 2. Проверяем доступные методы\n            const capabilities = await checkGenerationCapabilities();\n            // Показываем пользователю информацию о методе\n            if (capabilities.harfbuzz) {\n                react_toastify__WEBPACK_IMPORTED_MODULE_1__.toast.info(\"Используется HarfBuzz для качественной генерации\");\n            } else if (capabilities.server) {\n                react_toastify__WEBPACK_IMPORTED_MODULE_1__.toast.info(\"Используется серверная генерация\");\n            } else {\n                react_toastify__WEBPACK_IMPORTED_MODULE_1__.toast.warning(\"Используется псевдо-статический метод (ограниченная функциональность)\");\n            }\n            // 3. Получаем данные шрифта\n            let fontData;\n            if (selectedFont.arrayBuffer) {\n                fontData = selectedFont.arrayBuffer;\n            } else if (selectedFont.url) {\n                const response = await fetch(selectedFont.url);\n                if (!response.ok) {\n                    throw new Error(\"Не удалось загрузить шрифт: \".concat(response.status));\n                }\n                fontData = await response.arrayBuffer();\n            } else {\n                throw new Error(\"Нет доступных данных шрифта\");\n            }\n            // Проверяем что fontData это действительно ArrayBuffer\n            if (!fontData || !(fontData instanceof ArrayBuffer)) {\n                throw new Error(\"Неправильный тип данных шрифта. Ожидается ArrayBuffer, получен: \".concat(typeof fontData));\n            }\n            // 4. Генерируем статический шрифт с помощью новой утилиты\n            const result = await generateStaticFont(fontData, variableSettings, {\n                format,\n                fontName: selectedFont.name || \"VariableFont\"\n            });\n            // Показываем предупреждение если это псевдо-статический шрифт\n            if (result.warning) {\n                react_toastify__WEBPACK_IMPORTED_MODULE_1__.toast.warning(result.warning);\n            }\n            // Если есть CSS (для псевдо-статического), предлагаем его скачать\n            if (result.css) {\n                const downloadCSS = window.confirm(\"Создан псевдо-статический шрифт с CSS. Скачать CSS файл?\");\n                if (downloadCSS) {\n                    downloadFile(result.css, \"\".concat(selectedFont.name, \"-static.css\"), \"text/css\");\n                }\n            }\n            // Определяем MIME тип\n            let mimeType;\n            switch(format.toLowerCase()){\n                case \"ttf\":\n                    mimeType = \"font/ttf\";\n                    break;\n                case \"otf\":\n                    mimeType = \"font/otf\";\n                    break;\n                case \"woff\":\n                    mimeType = \"font/woff\";\n                    break;\n                case \"woff2\":\n                    mimeType = \"font/woff2\";\n                    break;\n                default:\n                    mimeType = \"font/ttf\";\n            }\n            // 5. Создаем Blob\n            const blob = new Blob([\n                result.buffer\n            ], {\n                type: mimeType\n            });\n            const statusMessage = result.isRealStatic ? \"Настоящий статический шрифт сгенерирован (\".concat((blob.size / 1024).toFixed(1), \" KB)\") : \"Псевдо-статический шрифт создан (\".concat((blob.size / 1024).toFixed(1), \" KB)\");\n            react_toastify__WEBPACK_IMPORTED_MODULE_1__.toast.success(statusMessage);\n            return blob;\n        } catch (error) {\n            console.error(\"[generateStaticFontFile] Ошибка при генерации:\", error);\n            react_toastify__WEBPACK_IMPORTED_MODULE_1__.toast.error(\"Ошибка генерации статического шрифта: \".concat(error.message));\n            return null;\n        }\n    }, []);\n    /**\n   * Скачивает статический шрифт, сгенерированный из вариативного\n   * \n   * @param {Object} selectedFont - Вариативный шрифт\n   * @param {Object} variableSettings - Настройки осей\n   * @param {string} format - Формат файла\n   * @returns {Promise<boolean>} Успешность операции\n   */ const downloadStaticFont = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(async function(selectedFont, variableSettings) {\n        let format = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : \"ttf\";\n        if (!selectedFont || !selectedFont.isVariableFont) {\n            react_toastify__WEBPACK_IMPORTED_MODULE_1__.toast.error(\"Выберите вариативный шрифт для создания статической версии\");\n            return false;\n        }\n        try {\n            react_toastify__WEBPACK_IMPORTED_MODULE_1__.toast.info(\"Генерируем статический шрифт...\", {\n                autoClose: 2000\n            });\n            const fontBlob = await generateStaticFontFile(selectedFont, variableSettings, format);\n            if (fontBlob) {\n                // Создаем описательное имя файла с настройками осей\n                const fontBaseName = (selectedFont.name || selectedFont.fontFamily || \"font\").replace(/\\s+/g, \"-\").toLowerCase().replace(/[^a-z0-9\\-]/g, \"\");\n                // Добавляем информацию об основных осях в имя файла\n                let axisInfo = \"\";\n                // Основные оси (стандартные)\n                if (variableSettings.wght && variableSettings.wght !== 400) {\n                    axisInfo += \"_w\".concat(Math.round(variableSettings.wght));\n                }\n                if (variableSettings.wdth && variableSettings.wdth !== 100) {\n                    axisInfo += \"_wd\".concat(Math.round(variableSettings.wdth));\n                }\n                if (variableSettings.slnt && variableSettings.slnt !== 0) {\n                    axisInfo += \"_sl\".concat(Math.round(Math.abs(variableSettings.slnt)));\n                }\n                if (variableSettings.opsz && variableSettings.opsz !== 14) {\n                    axisInfo += \"_opsz\".concat(Math.round(variableSettings.opsz));\n                }\n                if (variableSettings.GRAD && variableSettings.GRAD !== 0) {\n                    axisInfo += \"_grad\".concat(Math.round(variableSettings.GRAD));\n                }\n                // Параметрические оси (если отличаются от дефолтных значений)\n                const parametricAxes = [\n                    \"XOPQ\",\n                    \"YOPQ\",\n                    \"XTRA\",\n                    \"YTUC\",\n                    \"YTLC\",\n                    \"YTAS\",\n                    \"YTDE\",\n                    \"YTFI\"\n                ];\n                parametricAxes.forEach((axis)=>{\n                    if (variableSettings[axis] !== undefined) {\n                        const value = Math.round(variableSettings[axis]);\n                        axisInfo += \"_\".concat(axis.toLowerCase()).concat(value);\n                    }\n                });\n                // Ограничиваем длину имени файла (если слишком много осей)\n                if (axisInfo.length > 50) {\n                    axisInfo = axisInfo.substring(0, 47) + \"...\";\n                }\n                const filename = \"\".concat(fontBaseName).concat(axisInfo, \"_static.\").concat(format);\n                const success = downloadFile(fontBlob, filename, \"font/\".concat(format));\n                if (success) {\n                    react_toastify__WEBPACK_IMPORTED_MODULE_1__.toast.success(\"Статический шрифт скачан: \".concat(filename));\n                }\n                return success;\n            }\n            return false;\n        } catch (error) {\n            react_toastify__WEBPACK_IMPORTED_MODULE_1__.toast.error(\"Ошибка при создании статического шрифта: \".concat(error.message));\n            return false;\n        }\n    }, [\n        generateStaticFontFile,\n        downloadFile\n    ]);\n    return {\n        // Универсальные функции\n        downloadFile,\n        // CSS экспорт\n        exportToCSS,\n        // Работа со статическими версиями\n        createStaticFont,\n        // Будущая функциональность генерации статических шрифтов\n        generateStaticFontFile,\n        downloadStaticFont\n    };\n}\n_s(useFontExport, \"++ypkl6eVG4Iyquogwe47LDjB+c=\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QUV6QyxPQUFPO1FBQ0wsd0JBQXdCO1FBQ3hCQTtRQUVBLGNBQWM7UUFDZHdDO1FBRUEsa0NBQWtDO1FBQ2xDaEI7UUFFQSx5REFBeUQ7UUFDekRtQjtRQUNBNEI7SUFDRjtBQUNGO0dBN1NnQnpFIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL2hvb2tzL3VzZUZvbnRFeHBvcnQuanM/ZjczYyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyB1c2VDYWxsYmFjayB9IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7IHRvYXN0IH0gZnJvbSAncmVhY3QtdG9hc3RpZnknO1xuaW1wb3J0IHsgZ2VuZXJhdGVTdGF0aWNGb250IH0gZnJvbSAnLi4vdXRpbHMvc3RhdGljRm9udEdlbmVyYXRvcic7XG5cbi8qKlxuICog0KXRg9C6INC00LvRjyDRjdC60YHQv9C+0YDRgtCwINC4INGB0LrQsNGH0LjQstCw0L3QuNGPINGI0YDQuNGE0YLQvtCyINC4IENTU1xuICogXG4gKiDQktC60LvRjtGH0LDQtdGCINCyINGB0LXQsdGPOlxuICogLSDQo9C90LjQstC10YDRgdCw0LvRjNC90YPRjiDQu9C+0LPQuNC60YMg0YHQutCw0YfQuNCy0LDQvdC40Y8g0YTQsNC50LvQvtCyXG4gKiAtINCt0LrRgdC/0L7RgNGCIENTUyDRgSDQstC+0LfQvNC+0LbQvdC+0YHRgtGM0Y4g0YHQutCw0YfQuNCy0LDQvdC40Y9cbiAqIC0g0KHQvtC30LTQsNC90LjQtSDRgdGC0LDRgtC40YfQtdGB0LrQuNGFINCy0LXRgNGB0LjQuSDQstCw0YDQuNCw0YLQuNCy0L3Ri9GFINGI0YDQuNGE0YLQvtCyXG4gKiAtINCf0L7QtNCz0L7RgtC+0LLQutCwINC6INCx0YPQtNGD0YnQtdC5INC70L7Qs9C40LrQtSDQs9C10L3QtdGA0LDRhtC40Lgg0YHRgtCw0YLQuNGH0LXRgdC60LjRhSDRiNGA0LjRhNGC0L7QslxuICogXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBleHBvcnRUb0NTU0Zyb21Ib29rIC0g0KTRg9C90LrRhtC40Y8g0LPQtdC90LXRgNCw0YbQuNC4IENTUyDQuNC3IHVzZUZvbnRDc3NcbiAqIEByZXR1cm5zIHtPYmplY3R9INCe0LHRitC10LrRgiDRgSDQvNC10YLQvtC00LDQvNC4INGN0LrRgdC/0L7RgNGC0LBcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHVzZUZvbnRFeHBvcnQoZXhwb3J0VG9DU1NGcm9tSG9vaykge1xuICAvKipcbiAgICog0KPQvdC40LLQtdGA0YHQsNC70YzQvdCw0Y8g0YTRg9C90LrRhtC40Y8g0YHQutCw0YfQuNCy0LDQvdC40Y8g0YTQsNC50LvQvtCyXG4gICAqIFxuICAgKiBAcGFyYW0ge3N0cmluZ3xCbG9ifSBjb250ZW50IC0g0KHQvtC00LXRgNC20LjQvNC+0LUg0YTQsNC50LvQsCAo0YHRgtGA0L7QutCwINC40LvQuCBCbG9iKVxuICAgKiBAcGFyYW0ge3N0cmluZ30gZmlsZW5hbWUgLSDQmNC80Y8g0YTQsNC50LvQsCDQtNC70Y8g0YHQutCw0YfQuNCy0LDQvdC40Y9cbiAgICogQHBhcmFtIHtzdHJpbmd9IG1pbWVUeXBlIC0gTUlNRSDRgtC40L8g0YTQsNC50LvQsCAo0LjQs9C90L7RgNC40YDRg9C10YLRgdGPINC10YHQu9C4IGNvbnRlbnQg0Y3RgtC+IEJsb2IpXG4gICAqIEByZXR1cm5zIHtib29sZWFufSDQo9GB0L/QtdGI0L3QvtGB0YLRjCDQvtC/0LXRgNCw0YbQuNC4XG4gICAqL1xuICBjb25zdCBkb3dubG9hZEZpbGUgPSB1c2VDYWxsYmFjaygoY29udGVudCwgZmlsZW5hbWUsIG1pbWVUeXBlID0gJ3RleHQvcGxhaW4nKSA9PiB7XG4gICAgdHJ5IHtcbiAgICAgIGxldCBibG9iO1xuICAgICAgaWYgKGNvbnRlbnQgaW5zdGFuY2VvZiBCbG9iKSB7XG4gICAgICAgIGJsb2IgPSBjb250ZW50O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYmxvYiA9IG5ldyBCbG9iKFtjb250ZW50XSwgeyB0eXBlOiBtaW1lVHlwZSB9KTtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgY29uc3QgdXJsID0gVVJMLmNyZWF0ZU9iamVjdFVSTChibG9iKTtcbiAgICAgIFxuICAgICAgY29uc3QgZG93bmxvYWRMaW5rID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnYScpO1xuICAgICAgZG93bmxvYWRMaW5rLmhyZWYgPSB1cmw7XG4gICAgICBkb3dubG9hZExpbmsuZG93bmxvYWQgPSBmaWxlbmFtZTtcbiAgICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoZG93bmxvYWRMaW5rKTtcbiAgICAgIGRvd25sb2FkTGluay5jbGljaygpO1xuICAgICAgXG4gICAgICAvLyDQntGH0LjRidCw0LXQvCDRgNC10YHRg9GA0YHRi1xuICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgIGRvY3VtZW50LmJvZHkucmVtb3ZlQ2hpbGQoZG93bmxvYWRMaW5rKTtcbiAgICAgICAgVVJMLnJldm9rZU9iamVjdFVSTCh1cmwpO1xuICAgICAgfSwgMTAwKTtcbiAgICAgIFxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ9Ce0YjQuNCx0LrQsCDRgdC60LDRh9C40LLQsNC90LjRjyDRhNCw0LnQu9CwOicsIGVycm9yKTtcbiAgICAgIHRvYXN0LmVycm9yKGDQndC1INGD0LTQsNC70L7RgdGMINGB0LrQsNGH0LDRgtGMINGE0LDQudC7OiAke2Vycm9yLm1lc3NhZ2V9YCk7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9LCBbXSk7XG5cbiAgLyoqXG4gICAqINCh0L7Qt9C00LDQtdGCINGB0YLQsNGC0LjRh9C10YHQutGD0Y4g0LLQtdGA0YHQuNGOINCy0LDRgNC40LDRgtC40LLQvdC+0LPQviDRiNGA0LjRhNGC0LAg0YEg0YLQtdC60YPRidC40LzQuCDQvdCw0YHRgtGA0L7QudC60LDQvNC4INC+0YHQtdC5XG4gICAqIFxuICAgKiBAcGFyYW0ge09iamVjdH0gc2VsZWN0ZWRGb250IC0g0JLRi9Cx0YDQsNC90L3Ri9C5INGI0YDQuNGE0YJcbiAgICogQHBhcmFtIHtzdHJpbmd9IHNlbGVjdGVkRm9udE5hbWUgLSDQmNC80Y8g0LLRi9Cx0YDQsNC90L3QvtCz0L4g0YjRgNC40YTRgtCwXG4gICAqIEBwYXJhbSB7T2JqZWN0fSB2YXJpYWJsZVNldHRpbmdzIC0g0J3QsNGB0YLRgNC+0LnQutC4INCy0LDRgNC40LDRgtC40LLQvdGL0YUg0L7RgdC10LlcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gc2V0RXhwb3J0ZWRGb250IC0g0KTRg9C90LrRhtC40Y8g0YPRgdGC0LDQvdC+0LLQutC4INGN0LrRgdC/0L7RgNGC0LjRgNC+0LLQsNC90L3QvtCz0L4g0YjRgNC40YTRgtCwXG4gICAqIEByZXR1cm5zIHtPYmplY3R8dW5kZWZpbmVkfSDQntCx0YrQtdC60YIg0YHRgtCw0YLQuNGH0LXRgdC60L7Qs9C+INGI0YDQuNGE0YLQsCDQuNC70LggdW5kZWZpbmVkXG4gICAqL1xuICBjb25zdCBjcmVhdGVTdGF0aWNGb250ID0gdXNlQ2FsbGJhY2soKHNlbGVjdGVkRm9udCwgc2VsZWN0ZWRGb250TmFtZSwgdmFyaWFibGVTZXR0aW5ncywgc2V0RXhwb3J0ZWRGb250KSA9PiB7XG4gICAgaWYgKCFzZWxlY3RlZEZvbnQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgXG4gICAgLy8g0KHQvtC30LTQsNC10Lwg0L3QvtCy0L7QtSDQuNC80Y8g0LTQu9GPINGB0YLQsNGC0LjRh9C10YHQutC+0Lkg0LLQtdGA0YHQuNC4INGI0YDQuNGE0YLQsFxuICAgIGNvbnN0IHN0YXRpY05hbWUgPSBgJHtzZWxlY3RlZEZvbnROYW1lLnJlcGxhY2UoL1xcLlteLy5dKyQvLCAnJyl9LXN0YXRpY2A7XG4gICAgXG4gICAgLy8g0J7Qv9GA0LXQtNC10LvRj9C10Lwg0YLQtdC60YPRidC40LUg0L3QsNGB0YLRgNC+0LnQutC4XG4gICAgY29uc3Qgc2V0dGluZ3MgPSB7IC4uLnZhcmlhYmxlU2V0dGluZ3MgfTtcbiAgICBcbiAgICAvLyDQodC+0LfQtNCw0LXQvCDRgdGC0LDRgtC40YfQtdGB0LrQuNC5INGN0LrRgdC/0L7RgNGC0LjRgNC+0LLQsNC90L3Ri9C5INGI0YDQuNGE0YJcbiAgICBjb25zdCBuZXdFeHBvcnRlZEZvbnQgPSB7XG4gICAgICBuYW1lOiBzdGF0aWNOYW1lLFxuICAgICAgc2V0dGluZ3M6IHNldHRpbmdzLFxuICAgICAgaXNTdGF0aWM6IHRydWUsXG4gICAgICBvcmlnaW5hbEZvbnQ6IHNlbGVjdGVkRm9udE5hbWUsXG4gICAgICBjcmVhdGVkQXQ6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKVxuICAgIH07XG4gICAgXG4gICAgc2V0RXhwb3J0ZWRGb250KG5ld0V4cG9ydGVkRm9udCk7XG4gICAgXG4gICAgdG9hc3Quc3VjY2Vzcyhg0KHQvtC30LTQsNC90LAg0YHRgtCw0YLQuNGH0LXRgdC60LDRjyDQstC10YDRgdC40Y8g0YjRgNC40YTRgtCwOiAke3N0YXRpY05hbWV9YCk7XG4gICAgXG4gICAgcmV0dXJuIG5ld0V4cG9ydGVkRm9udDtcbiAgfSwgW10pO1xuXG4gIC8qKlxuICAgKiDQrdC60YHQv9C+0YDRgtC40YDRg9C10YIg0YLQtdC60YPRidC40LUg0L3QsNGB0YLRgNC+0LnQutC4INGI0YDQuNGE0YLQsCDQsiBDU1Mg0YEg0LLQvtC30LzQvtC20L3QvtGB0YLRjNGOINGB0LrQsNGH0LjQstCw0L3QuNGPXG4gICAqIFxuICAgKiBAcGFyYW0ge09iamVjdH0gc2VsZWN0ZWRGb250IC0g0JLRi9Cx0YDQsNC90L3Ri9C5INGI0YDQuNGE0YJcbiAgICogQHBhcmFtIHtzdHJpbmd9IHNlbGVjdGVkRm9udE5hbWUgLSDQmNC80Y8g0LLRi9Cx0YDQsNC90L3QvtCz0L4g0YjRgNC40YTRgtCwXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gZG93bmxvYWQgLSDQldGB0LvQuCB0cnVlLCDQsNCy0YLQvtC80LDRgtC40YfQtdGB0LrQuCDRgdC60LDRh9C40LLQsNC10YIgQ1NTINGE0LDQudC7XG4gICAqIEByZXR1cm5zIHtzdHJpbmd9IENTUy3QutC+0LQg0LTQu9GPINGC0LXQutGD0YnQtdCz0L4g0YjRgNC40YTRgtCwINGBINC/0YDQuNC80LXQvdC10L3QvdGL0LzQuCDQvdCw0YHRgtGA0L7QudC60LDQvNC4XG4gICAqL1xuICBjb25zdCBleHBvcnRUb0NTUyA9IHVzZUNhbGxiYWNrKChzZWxlY3RlZEZvbnQsIHNlbGVjdGVkRm9udE5hbWUsIGRvd25sb2FkID0gZmFsc2UpID0+IHtcbiAgICAvLyDQmNGB0L/QvtC70YzQt9GD0LXQvCDRhNGD0L3QutGG0LjRjiDQuNC3IHVzZUZvbnRDc3Mg0LTQu9GPINCz0LXQvdC10YDQsNGG0LjQuCBDU1NcbiAgICBjb25zdCBjc3NDb2RlID0gZXhwb3J0VG9DU1NGcm9tSG9vayhzZWxlY3RlZEZvbnQsIHNlbGVjdGVkRm9udE5hbWUpO1xuICAgIFxuICAgIGlmIChkb3dubG9hZCAmJiBjc3NDb2RlKSB7XG4gICAgICBjb25zdCBmaWxlbmFtZSA9IGAke3NlbGVjdGVkRm9udE5hbWUucmVwbGFjZSgvXFxzKy9nLCAnLScpLnRvTG93ZXJDYXNlKCl9LXN0eWxlcy5jc3NgO1xuICAgICAgY29uc3Qgc3VjY2VzcyA9IGRvd25sb2FkRmlsZShjc3NDb2RlLCBmaWxlbmFtZSwgJ3RleHQvY3NzJyk7XG4gICAgICBcbiAgICAgIGlmIChzdWNjZXNzKSB7XG4gICAgICAgIHRvYXN0LnN1Y2Nlc3MoYENTUyDRhNCw0LnQuyAke2ZpbGVuYW1lfSDRgdC60LDRh9Cw0L1gKTtcbiAgICAgIH1cbiAgICB9XG4gICAgXG4gICAgcmV0dXJuIGNzc0NvZGU7XG4gIH0sIFtleHBvcnRUb0NTU0Zyb21Ib29rLCBkb3dubG9hZEZpbGVdKTtcblxuICAvKipcbiAgICog0JPQtdC90LXRgNC40YDRg9C10YIg0YHRgtCw0YLQuNGH0LXRgdC60LjQuSDRiNGA0LjRhNGCINC40Lcg0LLQsNGA0LjQsNGC0LjQstC90L7Qs9C+INC40YHQv9C+0LvRjNC30YPRjyDRgdC+0LLRgNC10LzQtdC90L3Ri9C1INC80LXRgtC+0LTRi1xuICAgKiBcbiAgICogQHBhcmFtIHtPYmplY3R9IHNlbGVjdGVkRm9udCAtINCS0LDRgNC40LDRgtC40LLQvdGL0Lkg0YjRgNC40YTRglxuICAgKiBAcGFyYW0ge09iamVjdH0gdmFyaWFibGVTZXR0aW5ncyAtINCd0LDRgdGC0YDQvtC50LrQuCDQvtGB0LXQuVxuICAgKiBAcGFyYW0ge3N0cmluZ30gZm9ybWF0IC0g0KTQvtGA0LzQsNGCINCy0YvRhdC+0LTQvdC+0LPQviDRhNCw0LnQu9CwICgnd29mZjInLCAnd29mZicsICd0dGYnLCAnb3RmJylcbiAgICogQHJldHVybnMge1Byb21pc2U8QmxvYnxudWxsPn0gQmxvYiDRgdGC0LDRgtC40YfQtdGB0LrQvtCz0L4g0YjRgNC40YTRgtCwINC40LvQuCBudWxsINC/0YDQuCDQvtGI0LjQsdC60LVcbiAgICovXG4gIGNvbnN0IGdlbmVyYXRlU3RhdGljRm9udEZpbGUgPSB1c2VDYWxsYmFjayhhc3luYyAoc2VsZWN0ZWRGb250LCB2YXJpYWJsZVNldHRpbmdzLCBmb3JtYXQgPSAnd29mZjInKSA9PiB7XG4gICAgaWYgKCFzZWxlY3RlZEZvbnQgfHwgIXNlbGVjdGVkRm9udC5pc1ZhcmlhYmxlRm9udCkge1xuICAgICAgdG9hc3QuZXJyb3IoJ9CS0YvQsdC10YDQuNGC0LUg0LLQsNGA0LjQsNGC0LjQstC90YvQuSDRiNGA0LjRhNGCINC00LvRjyDRgdC+0LfQtNCw0L3QuNGPINGB0YLQsNGC0LjRh9C10YHQutC+0Lkg0LLQtdGA0YHQuNC4Jyk7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICBpZiAoIXNlbGVjdGVkRm9udC51cmwgJiYgIXNlbGVjdGVkRm9udC5hcnJheUJ1ZmZlcikge1xuICAgICAgdG9hc3QuZXJyb3IoJ9Cd0LXRgiDQtNC+0YHRgtGD0L/QsCDQuiDRhNCw0LnQu9GDINGI0YDQuNGE0YLQsCDQtNC70Y8g0LPQtdC90LXRgNCw0YbQuNC4Jyk7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICB0cnkge1xuICAgICAgLy8gMS4g0JjQvNC/0L7RgNGC0LjRgNGD0LXQvCDQvdC+0LLRg9GOINGD0YLQuNC70LjRgtGDINC00LvRjyDQs9C10L3QtdGA0LDRhtC40LhcbiAgICAgIGNvbnN0IHsgZ2VuZXJhdGVTdGF0aWNGb250LCBjaGVja0dlbmVyYXRpb25DYXBhYmlsaXRpZXMgfSA9IGF3YWl0IGltcG9ydCgnLi4vdXRpbHMvc3RhdGljRm9udEdlbmVyYXRvcicpO1xuICAgICAgXG4gICAgICAvLyAyLiDQn9GA0L7QstC10YDRj9C10Lwg0LTQvtGB0YLRg9C/0L3Ri9C1INC80LXRgtC+0LTRi1xuICAgICAgY29uc3QgY2FwYWJpbGl0aWVzID0gYXdhaXQgY2hlY2tHZW5lcmF0aW9uQ2FwYWJpbGl0aWVzKCk7XG4gICAgICBcbiAgICAgIC8vINCf0L7QutCw0LfRi9Cy0LDQtdC8INC/0L7Qu9GM0LfQvtCy0LDRgtC10LvRjiDQuNC90YTQvtGA0LzQsNGG0LjRjiDQviDQvNC10YLQvtC00LVcbiAgICAgIGlmIChjYXBhYmlsaXRpZXMuaGFyZmJ1enopIHtcbiAgICAgICAgdG9hc3QuaW5mbygn0JjRgdC/0L7Qu9GM0LfRg9C10YLRgdGPIEhhcmZCdXp6INC00LvRjyDQutCw0YfQtdGB0YLQstC10L3QvdC+0Lkg0LPQtdC90LXRgNCw0YbQuNC4Jyk7XG4gICAgICB9IGVsc2UgaWYgKGNhcGFiaWxpdGllcy5zZXJ2ZXIpIHtcbiAgICAgICAgdG9hc3QuaW5mbygn0JjRgdC/0L7Qu9GM0LfRg9C10YLRgdGPINGB0LXRgNCy0LXRgNC90LDRjyDQs9C10L3QtdGA0LDRhtC40Y8nKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRvYXN0Lndhcm5pbmcoJ9CY0YHQv9C+0LvRjNC30YPQtdGC0YHRjyDQv9GB0LXQstC00L4t0YHRgtCw0YLQuNGH0LXRgdC60LjQuSDQvNC10YLQvtC0ICjQvtCz0YDQsNC90LjRh9C10L3QvdCw0Y8g0YTRg9C90LrRhtC40L7QvdCw0LvRjNC90L7RgdGC0YwpJyk7XG4gICAgICB9XG4gICAgICBcbiAgICAgIC8vIDMuINCf0L7Qu9GD0YfQsNC10Lwg0LTQsNC90L3Ri9C1INGI0YDQuNGE0YLQsFxuICAgICAgbGV0IGZvbnREYXRhO1xuICAgICAgaWYgKHNlbGVjdGVkRm9udC5hcnJheUJ1ZmZlcikge1xuICAgICAgICBmb250RGF0YSA9IHNlbGVjdGVkRm9udC5hcnJheUJ1ZmZlcjtcbiAgICAgIH0gZWxzZSBpZiAoc2VsZWN0ZWRGb250LnVybCkge1xuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKHNlbGVjdGVkRm9udC51cmwpO1xuICAgICAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGDQndC1INGD0LTQsNC70L7RgdGMINC30LDQs9GA0YPQt9C40YLRjCDRiNGA0LjRhNGCOiAke3Jlc3BvbnNlLnN0YXR1c31gKTtcbiAgICAgICAgfVxuICAgICAgICBmb250RGF0YSA9IGF3YWl0IHJlc3BvbnNlLmFycmF5QnVmZmVyKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ9Cd0LXRgiDQtNC+0YHRgtGD0L/QvdGL0YUg0LTQsNC90L3Ri9GFINGI0YDQuNGE0YLQsCcpO1xuICAgICAgfVxuXG4gICAgICAvLyDQn9GA0L7QstC10YDRj9C10Lwg0YfRgtC+IGZvbnREYXRhINGN0YLQviDQtNC10LnRgdGC0LLQuNGC0LXQu9GM0L3QviBBcnJheUJ1ZmZlclxuICAgICAgaWYgKCFmb250RGF0YSB8fCAhKGZvbnREYXRhIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihg0J3QtdC/0YDQsNCy0LjQu9GM0L3Ri9C5INGC0LjQvyDQtNCw0L3QvdGL0YUg0YjRgNC40YTRgtCwLiDQntC20LjQtNCw0LXRgtGB0Y8gQXJyYXlCdWZmZXIsINC/0L7Qu9GD0YfQtdC9OiAke3R5cGVvZiBmb250RGF0YX1gKTtcbiAgICAgIH1cblxuICAgICAgLy8gNC4g0JPQtdC90LXRgNC40YDRg9C10Lwg0YHRgtCw0YLQuNGH0LXRgdC60LjQuSDRiNGA0LjRhNGCINGBINC/0L7QvNC+0YnRjNGOINC90L7QstC+0Lkg0YPRgtC40LvQuNGC0YtcbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGdlbmVyYXRlU3RhdGljRm9udChmb250RGF0YSwgdmFyaWFibGVTZXR0aW5ncywge1xuICAgICAgICBmb3JtYXQsXG4gICAgICAgIGZvbnROYW1lOiBzZWxlY3RlZEZvbnQubmFtZSB8fCAnVmFyaWFibGVGb250J1xuICAgICAgfSk7XG4gICAgICBcbiAgICAgIC8vINCf0L7QutCw0LfRi9Cy0LDQtdC8INC/0YDQtdC00YPQv9GA0LXQttC00LXQvdC40LUg0LXRgdC70Lgg0Y3RgtC+INC/0YHQtdCy0LTQvi3RgdGC0LDRgtC40YfQtdGB0LrQuNC5INGI0YDQuNGE0YJcbiAgICAgIGlmIChyZXN1bHQud2FybmluZykge1xuICAgICAgICB0b2FzdC53YXJuaW5nKHJlc3VsdC53YXJuaW5nKTtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgLy8g0JXRgdC70Lgg0LXRgdGC0YwgQ1NTICjQtNC70Y8g0L/RgdC10LLQtNC+LdGB0YLQsNGC0LjRh9C10YHQutC+0LPQviksINC/0YDQtdC00LvQsNCz0LDQtdC8INC10LPQviDRgdC60LDRh9Cw0YLRjFxuICAgICAgaWYgKHJlc3VsdC5jc3MpIHtcbiAgICAgICAgY29uc3QgZG93bmxvYWRDU1MgPSB3aW5kb3cuY29uZmlybSgn0KHQvtC30LTQsNC9INC/0YHQtdCy0LTQvi3RgdGC0LDRgtC40YfQtdGB0LrQuNC5INGI0YDQuNGE0YIg0YEgQ1NTLiDQodC60LDRh9Cw0YLRjCBDU1Mg0YTQsNC50Ls/Jyk7XG4gICAgICAgIGlmIChkb3dubG9hZENTUykge1xuICAgICAgICAgIGRvd25sb2FkRmlsZShyZXN1bHQuY3NzLCBgJHtzZWxlY3RlZEZvbnQubmFtZX0tc3RhdGljLmNzc2AsICd0ZXh0L2NzcycpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vINCe0L/RgNC10LTQtdC70Y/QtdC8IE1JTUUg0YLQuNC/XG4gICAgICBsZXQgbWltZVR5cGU7XG4gICAgICBzd2l0Y2ggKGZvcm1hdC50b0xvd2VyQ2FzZSgpKSB7XG4gICAgICAgIGNhc2UgJ3R0Zic6XG4gICAgICAgICAgbWltZVR5cGUgPSAnZm9udC90dGYnO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdvdGYnOlxuICAgICAgICAgIG1pbWVUeXBlID0gJ2ZvbnQvb3RmJztcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnd29mZic6XG4gICAgICAgICAgbWltZVR5cGUgPSAnZm9udC93b2ZmJztcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnd29mZjInOlxuICAgICAgICAgIG1pbWVUeXBlID0gJ2ZvbnQvd29mZjInO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIG1pbWVUeXBlID0gJ2ZvbnQvdHRmJztcbiAgICAgIH1cblxuICAgICAgLy8gNS4g0KHQvtC30LTQsNC10LwgQmxvYlxuICAgICAgY29uc3QgYmxvYiA9IG5ldyBCbG9iKFtyZXN1bHQuYnVmZmVyXSwgeyB0eXBlOiBtaW1lVHlwZSB9KTtcblxuICAgICAgY29uc3Qgc3RhdHVzTWVzc2FnZSA9IHJlc3VsdC5pc1JlYWxTdGF0aWMgXG4gICAgICAgID8gYNCd0LDRgdGC0L7Rj9GJ0LjQuSDRgdGC0LDRgtC40YfQtdGB0LrQuNC5INGI0YDQuNGE0YIg0YHQs9C10L3QtdGA0LjRgNC+0LLQsNC9ICgkeyhibG9iLnNpemUgLyAxMDI0KS50b0ZpeGVkKDEpfSBLQilgXG4gICAgICAgIDogYNCf0YHQtdCy0LTQvi3RgdGC0LDRgtC40YfQtdGB0LrQuNC5INGI0YDQuNGE0YIg0YHQvtC30LTQsNC9ICgkeyhibG9iLnNpemUgLyAxMDI0KS50b0ZpeGVkKDEpfSBLQilgO1xuICAgICAgXG4gICAgICB0b2FzdC5zdWNjZXNzKHN0YXR1c01lc3NhZ2UpO1xuICAgICAgcmV0dXJuIGJsb2I7XG5cbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcignW2dlbmVyYXRlU3RhdGljRm9udEZpbGVdINCe0YjQuNCx0LrQsCDQv9GA0Lgg0LPQtdC90LXRgNCw0YbQuNC4OicsIGVycm9yKTtcbiAgICAgIHRvYXN0LmVycm9yKGDQntGI0LjQsdC60LAg0LPQtdC90LXRgNCw0YbQuNC4INGB0YLQsNGC0LjRh9C10YHQutC+0LPQviDRiNGA0LjRhNGC0LA6ICR7ZXJyb3IubWVzc2FnZX1gKTtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgfSwgW10pO1xuXG4gIC8qKlxuICAgKiDQodC60LDRh9C40LLQsNC10YIg0YHRgtCw0YLQuNGH0LXRgdC60LjQuSDRiNGA0LjRhNGCLCDRgdCz0LXQvdC10YDQuNGA0L7QstCw0L3QvdGL0Lkg0LjQtyDQstCw0YDQuNCw0YLQuNCy0L3QvtCz0L5cbiAgICogXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBzZWxlY3RlZEZvbnQgLSDQktCw0YDQuNCw0YLQuNCy0L3Ri9C5INGI0YDQuNGE0YJcbiAgICogQHBhcmFtIHtPYmplY3R9IHZhcmlhYmxlU2V0dGluZ3MgLSDQndCw0YHRgtGA0L7QudC60Lgg0L7RgdC10LlcbiAgICogQHBhcmFtIHtzdHJpbmd9IGZvcm1hdCAtINCk0L7RgNC80LDRgiDRhNCw0LnQu9CwXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPGJvb2xlYW4+fSDQo9GB0L/QtdGI0L3QvtGB0YLRjCDQvtC/0LXRgNCw0YbQuNC4XG4gICAqL1xuICBjb25zdCBkb3dubG9hZFN0YXRpY0ZvbnQgPSB1c2VDYWxsYmFjayhhc3luYyAoc2VsZWN0ZWRGb250LCB2YXJpYWJsZVNldHRpbmdzLCBmb3JtYXQgPSAndHRmJykgPT4ge1xuICAgIGlmICghc2VsZWN0ZWRGb250IHx8ICFzZWxlY3RlZEZvbnQuaXNWYXJpYWJsZUZvbnQpIHtcbiAgICAgIHRvYXN0LmVycm9yKCfQktGL0LHQtdGA0LjRgtC1INCy0LDRgNC40LDRgtC40LLQvdGL0Lkg0YjRgNC40YTRgiDQtNC70Y8g0YHQvtC30LTQsNC90LjRjyDRgdGC0LDRgtC40YfQtdGB0LrQvtC5INCy0LXRgNGB0LjQuCcpO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHRyeSB7XG4gICAgICB0b2FzdC5pbmZvKCfQk9C10L3QtdGA0LjRgNGD0LXQvCDRgdGC0LDRgtC40YfQtdGB0LrQuNC5INGI0YDQuNGE0YIuLi4nLCB7IGF1dG9DbG9zZTogMjAwMCB9KTtcbiAgICAgIFxuICAgICAgY29uc3QgZm9udEJsb2IgPSBhd2FpdCBnZW5lcmF0ZVN0YXRpY0ZvbnRGaWxlKHNlbGVjdGVkRm9udCwgdmFyaWFibGVTZXR0aW5ncywgZm9ybWF0KTtcbiAgICAgIFxuICAgICAgaWYgKGZvbnRCbG9iKSB7XG4gICAgICAgIC8vINCh0L7Qt9C00LDQtdC8INC+0L/QuNGB0LDRgtC10LvRjNC90L7QtSDQuNC80Y8g0YTQsNC50LvQsCDRgSDQvdCw0YHRgtGA0L7QudC60LDQvNC4INC+0YHQtdC5XG4gICAgICAgIGNvbnN0IGZvbnRCYXNlTmFtZSA9IChzZWxlY3RlZEZvbnQubmFtZSB8fCBzZWxlY3RlZEZvbnQuZm9udEZhbWlseSB8fCAnZm9udCcpXG4gICAgICAgICAgLnJlcGxhY2UoL1xccysvZywgJy0nKVxuICAgICAgICAgIC50b0xvd2VyQ2FzZSgpXG4gICAgICAgICAgLnJlcGxhY2UoL1teYS16MC05XFwtXS9nLCAnJyk7XG4gICAgICAgIFxuICAgICAgICAvLyDQlNC+0LHQsNCy0LvRj9C10Lwg0LjQvdGE0L7RgNC80LDRhtC40Y4g0L7QsSDQvtGB0L3QvtCy0L3Ri9GFINC+0YHRj9GFINCyINC40LzRjyDRhNCw0LnQu9CwXG4gICAgICAgIGxldCBheGlzSW5mbyA9ICcnO1xuICAgICAgICBcbiAgICAgICAgLy8g0J7RgdC90L7QstC90YvQtSDQvtGB0LggKNGB0YLQsNC90LTQsNGA0YLQvdGL0LUpXG4gICAgICAgIGlmICh2YXJpYWJsZVNldHRpbmdzLndnaHQgJiYgdmFyaWFibGVTZXR0aW5ncy53Z2h0ICE9PSA0MDApIHtcbiAgICAgICAgICBheGlzSW5mbyArPSBgX3cke01hdGgucm91bmQodmFyaWFibGVTZXR0aW5ncy53Z2h0KX1gO1xuICAgICAgICB9XG4gICAgICAgIGlmICh2YXJpYWJsZVNldHRpbmdzLndkdGggJiYgdmFyaWFibGVTZXR0aW5ncy53ZHRoICE9PSAxMDApIHtcbiAgICAgICAgICBheGlzSW5mbyArPSBgX3dkJHtNYXRoLnJvdW5kKHZhcmlhYmxlU2V0dGluZ3Mud2R0aCl9YDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodmFyaWFibGVTZXR0aW5ncy5zbG50ICYmIHZhcmlhYmxlU2V0dGluZ3Muc2xudCAhPT0gMCkge1xuICAgICAgICAgIGF4aXNJbmZvICs9IGBfc2wke01hdGgucm91bmQoTWF0aC5hYnModmFyaWFibGVTZXR0aW5ncy5zbG50KSl9YDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodmFyaWFibGVTZXR0aW5ncy5vcHN6ICYmIHZhcmlhYmxlU2V0dGluZ3Mub3BzeiAhPT0gMTQpIHtcbiAgICAgICAgICBheGlzSW5mbyArPSBgX29wc3oke01hdGgucm91bmQodmFyaWFibGVTZXR0aW5ncy5vcHN6KX1gO1xuICAgICAgICB9XG4gICAgICAgIGlmICh2YXJpYWJsZVNldHRpbmdzLkdSQUQgJiYgdmFyaWFibGVTZXR0aW5ncy5HUkFEICE9PSAwKSB7XG4gICAgICAgICAgYXhpc0luZm8gKz0gYF9ncmFkJHtNYXRoLnJvdW5kKHZhcmlhYmxlU2V0dGluZ3MuR1JBRCl9YDtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgLy8g0J/QsNGA0LDQvNC10YLRgNC40YfQtdGB0LrQuNC1INC+0YHQuCAo0LXRgdC70Lgg0L7RgtC70LjRh9Cw0Y7RgtGB0Y8g0L7RgiDQtNC10YTQvtC70YLQvdGL0YUg0LfQvdCw0YfQtdC90LjQuSlcbiAgICAgICAgY29uc3QgcGFyYW1ldHJpY0F4ZXMgPSBbJ1hPUFEnLCAnWU9QUScsICdYVFJBJywgJ1lUVUMnLCAnWVRMQycsICdZVEFTJywgJ1lUREUnLCAnWVRGSSddO1xuICAgICAgICBwYXJhbWV0cmljQXhlcy5mb3JFYWNoKGF4aXMgPT4ge1xuICAgICAgICAgIGlmICh2YXJpYWJsZVNldHRpbmdzW2F4aXNdICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gTWF0aC5yb3VuZCh2YXJpYWJsZVNldHRpbmdzW2F4aXNdKTtcbiAgICAgICAgICAgIGF4aXNJbmZvICs9IGBfJHtheGlzLnRvTG93ZXJDYXNlKCl9JHt2YWx1ZX1gO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIFxuICAgICAgICAvLyDQntCz0YDQsNC90LjRh9C40LLQsNC10Lwg0LTQu9C40L3RgyDQuNC80LXQvdC4INGE0LDQudC70LAgKNC10YHQu9C4INGB0LvQuNGI0LrQvtC8INC80L3QvtCz0L4g0L7RgdC10LkpXG4gICAgICAgIGlmIChheGlzSW5mby5sZW5ndGggPiA1MCkge1xuICAgICAgICAgIGF4aXNJbmZvID0gYXhpc0luZm8uc3Vic3RyaW5nKDAsIDQ3KSArICcuLi4nO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICBjb25zdCBmaWxlbmFtZSA9IGAke2ZvbnRCYXNlTmFtZX0ke2F4aXNJbmZvfV9zdGF0aWMuJHtmb3JtYXR9YDtcbiAgICAgICAgXG4gICAgICAgIGNvbnN0IHN1Y2Nlc3MgPSBkb3dubG9hZEZpbGUoZm9udEJsb2IsIGZpbGVuYW1lLCBgZm9udC8ke2Zvcm1hdH1gKTtcbiAgICAgICAgXG4gICAgICAgIGlmIChzdWNjZXNzKSB7XG4gICAgICAgICAgdG9hc3Quc3VjY2Vzcyhg0KHRgtCw0YLQuNGH0LXRgdC60LjQuSDRiNGA0LjRhNGCINGB0LrQsNGH0LDQvTogJHtmaWxlbmFtZX1gKTtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgcmV0dXJuIHN1Y2Nlc3M7XG4gICAgICB9XG4gICAgICBcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgdG9hc3QuZXJyb3IoYNCe0YjQuNCx0LrQsCDQv9GA0Lgg0YHQvtC30LTQsNC90LjQuCDRgdGC0LDRgtC40YfQtdGB0LrQvtCz0L4g0YjRgNC40YTRgtCwOiAke2Vycm9yLm1lc3NhZ2V9YCk7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9LCBbZ2VuZXJhdGVTdGF0aWNGb250RmlsZSwgZG93bmxvYWRGaWxlXSk7XG5cbiAgcmV0dXJuIHtcbiAgICAvLyDQo9C90LjQstC10YDRgdCw0LvRjNC90YvQtSDRhNGD0L3QutGG0LjQuFxuICAgIGRvd25sb2FkRmlsZSxcbiAgICBcbiAgICAvLyBDU1Mg0Y3QutGB0L/QvtGA0YJcbiAgICBleHBvcnRUb0NTUyxcbiAgICBcbiAgICAvLyDQoNCw0LHQvtGC0LAg0YHQviDRgdGC0LDRgtC40YfQtdGB0LrQuNC80Lgg0LLQtdGA0YHQuNGP0LzQuFxuICAgIGNyZWF0ZVN0YXRpY0ZvbnQsXG4gICAgXG4gICAgLy8g0JHRg9C00YPRidCw0Y8g0YTRg9C90LrRhtC40L7QvdCw0LvRjNC90L7RgdGC0Ywg0LPQtdC90LXRgNCw0YbQuNC4INGB0YLQsNGC0LjRh9C10YHQutC40YUg0YjRgNC40YTRgtC+0LJcbiAgICBnZW5lcmF0ZVN0YXRpY0ZvbnRGaWxlLFxuICAgIGRvd25sb2FkU3RhdGljRm9udCxcbiAgfTtcbn0gIl0sIm5hbWVzIjpbInVzZUNhbGxiYWNrIiwidG9hc3QiLCJnZW5lcmF0ZVN0YXRpY0ZvbnQiLCJ1c2VGb250RXhwb3J0IiwiZXhwb3J0VG9DU1NGcm9tSG9vayIsImRvd25sb2FkRmlsZSIsImNvbnRlbnQiLCJmaWxlbmFtZSIsIm1pbWVUeXBlIiwiYmxvYiIsIkJsb2IiLCJ0eXBlIiwidXJsIiwiVVJMIiwiY3JlYXRlT2JqZWN0VVJMIiwiZG93bmxvYWRMaW5rIiwiZG9jdW1lbnQiLCJjcmVhdGVFbGVtZW50IiwiaHJlZiIsImRvd25sb2FkIiwiYm9keSIsImFwcGVuZENoaWxkIiwiY2xpY2siLCJzZXRUaW1lb3V0IiwicmVtb3ZlQ2hpbGQiLCJyZXZva2VPYmplY3RVUkwiLCJlcnJvciIsImNvbnNvbGUiLCJtZXNzYWdlIiwiY3JlYXRlU3RhdGljRm9udCIsInNlbGVjdGVkRm9udCIsInNlbGVjdGVkRm9udE5hbWUiLCJ2YXJpYWJsZVNldHRpbmdzIiwic2V0RXhwb3J0ZWRGb250Iiwic3RhdGljTmFtZSIsInJlcGxhY2UiLCJzZXR0aW5ncyIsIm5ld0V4cG9ydGVkRm9udCIsIm5hbWUiLCJpc1N0YXRpYyIsIm9yaWdpbmFsRm9udCIsImNyZWF0ZWRBdCIsIkRhdGUiLCJ0b0lTT1N0cmluZyIsInN1Y2Nlc3MiLCJleHBvcnRUb0NTUyIsImNzc0NvZGUiLCJ0b0xvd2VyQ2FzZSIsImdlbmVyYXRlU3RhdGljRm9udEZpbGUiLCJmb3JtYXQiLCJpc1ZhcmlhYmxlRm9udCIsImFycmF5QnVmZmVyIiwiY2hlY2tHZW5lcmF0aW9uQ2FwYWJpbGl0aWVzIiwiY2FwYWJpbGl0aWVzIiwiaGFyZmJ1enoiLCJpbmZvIiwic2VydmVyIiwid2FybmluZyIsImZvbnREYXRhIiwicmVzcG9uc2UiLCJmZXRjaCIsIm9rIiwiRXJyb3IiLCJzdGF0dXMiLCJBcnJheUJ1ZmZlciIsInJlc3VsdCIsImZvbnROYW1lIiwiY3NzIiwiZG93bmxvYWRDU1MiLCJ3aW5kb3ciLCJjb25maXJtIiwiYnVmZmVyIiwic3RhdHVzTWVzc2FnZSIsImlzUmVhbFN0YXRpYyIsInNpemUiLCJ0b0ZpeGVkIiwiZG93bmxvYWRTdGF0aWNGb250IiwiYXV0b0Nsb3NlIiwiZm9udEJsb2IiLCJmb250QmFzZU5hbWUiLCJmb250RmFtaWx5IiwiYXhpc0luZm8iLCJ3Z2h0IiwiTWF0aCIsInJvdW5kIiwid2R0aCIsInNsbnQiLCJhYnMiLCJvcHN6IiwiR1JBRCIsInBhcmFtZXRyaWNBeGVzIiwiZm9yRWFjaCIsImF4aXMiLCJ1bmRlZmluZWQiLCJ2YWx1ZSIsImxlbmd0aCIsInN1YnN0cmluZyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./hooks/useFontExport.js\n"));

/***/ }),

/***/ "./hooks/useFontLoader.js":
/*!********************************!*\
  !*** ./hooks/useFontLoader.js ***!
  \********************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   useFontLoader: function() { return /* binding */ useFontLoader; }\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"./node_modules/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var react_toastify__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react-toastify */ \"./node_modules/react-toastify/dist/index.mjs\");\n/* harmony import */ var _utils_fontUtilsCommon__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utils/fontUtilsCommon */ \"./utils/fontUtilsCommon.js\");\n/* harmony import */ var _utils_localFontProcessor__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../utils/localFontProcessor */ \"./utils/localFontProcessor.js\");\n/* harmony import */ var _utils_db__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../utils/db */ \"./utils/db.js\");\n/* harmony import */ var _utils_fontManagerUtils__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../utils/fontManagerUtils */ \"./utils/fontManagerUtils.js\");\nvar _s = $RefreshSig$();\n\n\n\n\n\n\n// Кэш для хранения загруженных файлов шрифтов (статических Fontsource)\nconst fontFaceCache = new Map();\n// Хеш-функция для создания уникальных ключей кэширования\nconst createCacheKey = (fontFamily, weight, style)=>\"fontsource_\".concat(fontFamily, \"_\").concat(weight, \"_\").concat(style);\n/**\n * Хук для управления загрузкой шрифтов из различных источников.\n * @param {Function} setFonts - Функция для обновления состояния массива шрифтов.\n * @param {Function} setIsLoading - Функция для установки состояния загрузки.\n * @param {Function} safeSelectFont - Функция для безопасного выбора шрифта после загрузки.\n * @param {Array} currentFonts - Текущий массив шрифтов (для проверки дубликатов).\n */ function useFontLoader(setFonts, setIsLoading, safeSelectFont, currentFonts) {\n    _s();\n    // Вспомогательная функция для загрузки одного статического варианта стиля Fontsource\n    // (Перенесена из useFontManager)\n    const loadFontStyleVariant = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(async function(fontFamily, weight, style, fontObj) {\n        let returnBlob = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : false;\n        // НЕ загружаем статические стили, если шрифт определен как вариативный\n        if (fontObj.isVariableFont) {\n            return returnBlob ? null : undefined;\n        }\n        const cacheKey = createCacheKey(fontFamily, weight, style);\n        if (!returnBlob && fontFaceCache.has(cacheKey)) {\n            console.log(\"[FontLoader] Используем кэшированные данные для \".concat(fontFamily, \" \").concat(weight, \" \").concat(style));\n            const cachedData = fontFaceCache.get(cacheKey);\n            if (fontObj.loadedStyles && !fontObj.loadedStyles.some((s)=>s.weight === weight && s.style === style)) {\n                fontObj.loadedStyles.push({\n                    weight,\n                    style,\n                    cached: true\n                });\n            }\n            return returnBlob ? null : undefined;\n        }\n        let blob = null;\n        let fontDataUrl = null;\n        try {\n            const fontFamilyName = fontObj.fontFamily || fontFamily;\n            const apiUrl = \"/api/fontsource/\".concat(encodeURIComponent(fontFamily), \"?weight=\").concat(weight, \"&style=\").concat(style, \"&subset=latin\");\n            console.log(\"[FontLoader] Запрос к API: \".concat(apiUrl));\n            const response = await fetch(apiUrl);\n            if (!response.ok) throw new Error(\"Ошибка HTTP: \".concat(response.status));\n            // Проверяем, что ответ содержит JSON\n            const contentType = response.headers.get(\"content-type\");\n            console.log(\"[FontLoader] Content-Type ответа: \".concat(contentType));\n            if (!contentType || !contentType.includes(\"application/json\")) {\n                throw new Error(\"Неожиданный тип ответа: \".concat(contentType));\n            }\n            const responseText = await response.text();\n            console.log(\"[FontLoader] Ответ API (первые 100 символов): \".concat(responseText.substring(0, 100)));\n            if (!responseText || responseText === \"undefined\") {\n                throw new Error(\"API вернул пустой или undefined ответ\");\n            }\n            const { fontBufferBase64, fileName } = JSON.parse(responseText);\n            if (!fontBufferBase64) throw new Error(\"Пустой буфер шрифта\");\n            const fontBuffer = (0,_utils_fontManagerUtils__WEBPACK_IMPORTED_MODULE_5__.base64ToArrayBuffer)(fontBufferBase64);\n            const mimeType = \"font/\".concat((0,_utils_fontUtilsCommon__WEBPACK_IMPORTED_MODULE_2__.getFormatFromExtension)(fileName || \".woff2\"));\n            blob = new Blob([\n                fontBuffer\n            ], {\n                type: mimeType\n            });\n            fontDataUrl = URL.createObjectURL(blob);\n            const fontFaceRule = \"\\n        @font-face {\\n          font-family: '\".concat(fontFamilyName, \"';\\n          src: url('\").concat(fontDataUrl, \"') format('woff2');\\n          font-weight: \").concat(weight, \";\\n          font-style: \").concat(style, \";\\n          unicode-range: U+0000-00FF, U+0131, U+0152-0153, U+02BB-02BC, U+02C6, U+02DA, U+02DC, U+2000-206F, U+2074, U+20AC, U+2122, U+2191, U+2193, U+2212, U+2215, U+FEFF, U+FFFD;\\n        }\\n      \");\n            const styleElement = document.createElement(\"style\");\n            styleElement.textContent = fontFaceRule;\n            document.head.appendChild(styleElement);\n            fontFaceCache.set(cacheKey, {\n                url: fontDataUrl,\n                styleElement,\n                weight,\n                style\n            });\n            const fontFace = new FontFace(fontFamilyName, \"url(\".concat(fontDataUrl, \")\"), {\n                weight: String(weight),\n                style\n            });\n            try {\n                await fontFace.load();\n                document.fonts.add(fontFace);\n                if (fontObj.loadedStyles && !fontObj.loadedStyles.some((s)=>s.weight === weight && s.style === style)) {\n                    fontObj.loadedStyles.push({\n                        weight,\n                        style,\n                        cached: false\n                    });\n                }\n                console.log(\"[FontLoader] Загружен стиль \".concat(fontFamily, \" \").concat(weight, \" \").concat(style));\n                return returnBlob ? blob : undefined;\n            } catch (loadError) {\n                console.warn(\"Не удалось загрузить FontFace для \".concat(fontFamily, \" \").concat(weight, \" \").concat(style, \":\"), loadError);\n                if (fontDataUrl) URL.revokeObjectURL(fontDataUrl);\n                return returnBlob ? null : undefined;\n            }\n        } catch (error) {\n            console.error(\"Ошибка при загрузке стиля \".concat(fontFamily, \" \").concat(weight, \" \").concat(style, \":\"), error);\n            if (fontDataUrl) URL.revokeObjectURL(fontDataUrl);\n            if (returnBlob) return null;\n            else throw error;\n        } finally{\n            if (!returnBlob && fontDataUrl) {\n                // URL.revokeObjectURL(fontDataUrl); // Пока не удаляем, чтобы стили не пропадали\n                console.warn(\"[FontLoader] Blob URL \".concat(fontDataUrl, \" для \").concat(fontFamily, \" \").concat(weight, \" \").concat(style, \" НЕ удален (для стабильности стилей).\"));\n            }\n        }\n    }, [\n        _utils_fontManagerUtils__WEBPACK_IMPORTED_MODULE_5__.base64ToArrayBuffer,\n        _utils_fontUtilsCommon__WEBPACK_IMPORTED_MODULE_2__.getFormatFromExtension\n    ]); // Добавляем зависимости утилит\n    // Загружает все стили/вариативный файл для шрифта Fontsource\n    // (Перенесена из useFontManager)\n    const loadAllFontsourceStyles = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(async function(fontFamily) {\n        let forceVariableFont = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;\n        try {\n            var _metadata_metadata, _metadata_metadata1, _metadata_metadata2, _metadata_metadata3;\n            const metaApiUrl = \"/api/fontsource/\".concat(encodeURIComponent(fontFamily), \"?meta=true\");\n            console.log(\"[FontLoader] Запрос метаданных к API: \".concat(metaApiUrl));\n            const metaResponse = await fetch(metaApiUrl);\n            if (!metaResponse.ok) throw new Error(\"Метаданные для \".concat(fontFamily, \" не найдены (статус \").concat(metaResponse.status, \")\"));\n            // Проверяем, что ответ содержит JSON\n            const metaContentType = metaResponse.headers.get(\"content-type\");\n            console.log(\"[FontLoader] Content-Type метаданных: \".concat(metaContentType));\n            if (!metaContentType || !metaContentType.includes(\"application/json\")) {\n                throw new Error(\"Неожиданный тип ответа от API метаданных: \".concat(metaContentType));\n            }\n            const metaResponseText = await metaResponse.text();\n            console.log(\"[FontLoader] Ответ API метаданных (первые 100 символов): \".concat(metaResponseText.substring(0, 100)));\n            if (!metaResponseText || metaResponseText === \"undefined\") {\n                throw new Error(\"API метаданных вернул пустой или undefined ответ\");\n            }\n            const metadata = JSON.parse(metaResponseText);\n            const actualIsVariableFont = (metadata === null || metadata === void 0 ? void 0 : (_metadata_metadata = metadata.metadata) === null || _metadata_metadata === void 0 ? void 0 : _metadata_metadata.variable) && forceVariableFont;\n            const displayName = actualIsVariableFont ? \"\".concat(fontFamily, \" Variable\") : fontFamily;\n            const fontId = \"fontsource-\".concat(fontFamily, \"-\").concat(actualIsVariableFont ? \"variable\" : \"static\");\n            const fontObj = {\n                id: fontId,\n                name: fontFamily,\n                displayName: displayName,\n                source: \"fontsource\",\n                fontFamily: \"'\".concat(displayName, \"'\"),\n                variableAxes: actualIsVariableFont ? metadata === null || metadata === void 0 ? void 0 : (_metadata_metadata1 = metadata.metadata) === null || _metadata_metadata1 === void 0 ? void 0 : _metadata_metadata1.axes : {},\n                isVariableFont: actualIsVariableFont,\n                availableStyles: [],\n                loadedStyles: [],\n                file: null,\n                url: null\n            };\n            if (actualIsVariableFont && metadata.variable && metadata.variable.url) {\n                console.log(\"[FontLoader] Загружаем вариативный шрифт \".concat(displayName, \" по URL: \").concat(metadata.variable.url));\n                try {\n                    var _metadata_variable_url_split_pop;\n                    const fontFileResponse = await fetch(metadata.variable.url);\n                    if (!fontFileResponse.ok) throw new Error(\"Не удалось загрузить файл вариативного шрифта (статус \".concat(fontFileResponse.status, \")\"));\n                    const fontBuffer = await fontFileResponse.arrayBuffer();\n                    const fileExtension = ((_metadata_variable_url_split_pop = metadata.variable.url.split(\".\").pop()) === null || _metadata_variable_url_split_pop === void 0 ? void 0 : _metadata_variable_url_split_pop.toLowerCase()) || \"woff2\";\n                    const mimeType = \"font/\".concat(fileExtension === \"ttf\" ? \"ttf\" : fileExtension === \"otf\" ? \"otf\" : fileExtension === \"woff\" ? \"woff\" : \"woff2\");\n                    const blob = new Blob([\n                        fontBuffer\n                    ], {\n                        type: mimeType\n                    });\n                    fontObj.file = blob;\n                    fontObj.url = URL.createObjectURL(blob);\n                    console.log(\"[FontLoader] Вариативный шрифт \".concat(displayName, \" загружен, Blob создан, URL: \").concat(fontObj.url));\n                    // TODO: Перенести логику добавления @font-face в useFontCss\n                    const fontFaceRule = \"\\n              @font-face {\\n                  font-family: \".concat(fontObj.fontFamily, \";\\n                  src: url('\").concat(fontObj.url, \"') format('\").concat(fileExtension === \"ttf\" ? \"truetype\" : fileExtension === \"otf\" ? \"opentype\" : fileExtension, \"');\\n                  font-display: swap;\\n              }\\n            \");\n                    const styleElement = document.createElement(\"style\");\n                    styleElement.textContent = fontFaceRule;\n                    document.head.appendChild(styleElement);\n                    console.log(\"[FontLoader] Вариативный шрифт \".concat(displayName, \" добавлен через <style> tag.\"));\n                } catch (loadError) {\n                    console.error(\"[FontLoader] Ошибка при загрузке/обработке вариативного файла \".concat(displayName, \":\"), loadError);\n                    react_toastify__WEBPACK_IMPORTED_MODULE_1__.toast.error(\"Ошибка загрузки вариативного шрифта \".concat(displayName));\n                }\n            }\n            const weightsArray = Array.isArray(metadata === null || metadata === void 0 ? void 0 : (_metadata_metadata2 = metadata.metadata) === null || _metadata_metadata2 === void 0 ? void 0 : _metadata_metadata2.weights) ? metadata.metadata.weights : [];\n            const stylesArray = Array.isArray(metadata === null || metadata === void 0 ? void 0 : (_metadata_metadata3 = metadata.metadata) === null || _metadata_metadata3 === void 0 ? void 0 : _metadata_metadata3.styles) ? metadata.metadata.styles : [];\n            const availableStyles = weightsArray.flatMap((weight)=>{\n                return stylesArray.map((style)=>{\n                    const weightNum = parseInt(weight, 10) || 400;\n                    const styleInfo = (0,_utils_fontUtilsCommon__WEBPACK_IMPORTED_MODULE_2__.findStyleInfoByWeightAndStyle)(weightNum, style);\n                    return {\n                        name: styleInfo ? styleInfo.name : \"\".concat(weight, \" \").concat(style),\n                        weight: weightNum,\n                        style: style\n                    };\n                });\n            });\n            fontObj.availableStyles = availableStyles;\n            if (!actualIsVariableFont) {\n                const regularWeight = weightsArray.includes(\"400\") ? \"400\" : weightsArray[0] || \"400\";\n                const regularStyle = stylesArray.includes(\"normal\") ? \"normal\" : stylesArray[0] || \"normal\";\n                try {\n                    console.log(\"[FontLoader] Загружаем основной статический стиль \".concat(fontFamily, \" \").concat(regularWeight, \" \").concat(regularStyle));\n                    const mainStyleBlob = await loadFontStyleVariant(fontFamily, parseInt(regularWeight, 10), regularStyle, fontObj, true);\n                    if (mainStyleBlob instanceof Blob) {\n                        fontObj.file = mainStyleBlob;\n                        fontObj.url = URL.createObjectURL(mainStyleBlob);\n                        console.log(\"[FontLoader] Основной статический стиль \".concat(displayName, \" загружен, Blob сохранен, URL: \").concat(fontObj.url));\n                    } else {\n                        console.warn(\"[FontLoader] Не удалось получить Blob для основного стиля \".concat(displayName, \". Глифы могут быть недоступны.\"));\n                    }\n                } catch (mainStyleError) {\n                    console.error(\"[FontLoader] Критическая ошибка при загрузке основного стиля \".concat(displayName, \":\"), mainStyleError);\n                    react_toastify__WEBPACK_IMPORTED_MODULE_1__.toast.error(\"Ошибка загрузки основного стиля \".concat(displayName, \". Глифы будут недоступны.\"));\n                }\n                // Загружаем остальные стили в фоне\n                setTimeout(async ()=>{\n                    const promises = [];\n                    for (const weight of weightsArray){\n                        for (const style of stylesArray){\n                            if (weight === regularWeight && style === regularStyle) continue;\n                            promises.push(loadFontStyleVariant(fontFamily, parseInt(weight, 10), style, fontObj, false).catch((error)=>console.error(\"Ошибка фоновой загрузки стиля \".concat(fontFamily, \" \").concat(weight, \" \").concat(style, \":\"), error)));\n                        }\n                    }\n                    await Promise.allSettled(promises);\n                    console.log(\"[FontLoader] Фоновая загрузка всех стилей для \".concat(fontFamily, \" завершена.\"));\n                    setFonts((currentFonts)=>currentFonts.map((f)=>f.id === fontId ? {\n                                ...f\n                            } : f));\n                }, 100);\n            }\n            return fontObj;\n        } catch (error) {\n            console.error(\"[FontLoader] Ошибка при загрузке всех стилей шрифта \".concat(fontFamily, \":\"), error);\n            react_toastify__WEBPACK_IMPORTED_MODULE_1__.toast.error(\"Не удалось загрузить шрифт \".concat(fontFamily, \": \").concat(error.message));\n            throw error; // Пробрасываем ошибку для обработки в вызывающей функции\n        }\n    }, [\n        setFonts,\n        loadFontStyleVariant,\n        _utils_fontUtilsCommon__WEBPACK_IMPORTED_MODULE_2__.findStyleInfoByWeightAndStyle\n    ]); // Добавляем зависимости\n    // Обрабатывает загруженные локальные шрифты\n    // (Переименована из handleFontsUploaded)\n    const handleLocalFontsUpload = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(async (newFonts)=>{\n        console.log(\"[handleLocalFontsUpload] Начало обработки:\", newFonts);\n        if (!Array.isArray(newFonts) || newFonts.length === 0) {\n            console.log(\"[handleLocalFontsUpload] Ошибка: пустой массив или не массив\");\n            react_toastify__WEBPACK_IMPORTED_MODULE_1__.toast.error(\"Ошибка: Не указаны файлы шрифтов\");\n            return;\n        }\n        console.log(\"[handleLocalFontsUpload] Устанавливаем isLoading=true\");\n        setIsLoading(true); // Показываем индикатор загрузки\n        try {\n            const processedFonts = await Promise.all(newFonts.map(async (font)=>{\n                if (font.file instanceof Blob) {\n                    return await (0,_utils_localFontProcessor__WEBPACK_IMPORTED_MODULE_3__.processLocalFont)(font); // processLocalFont ожидает { file: Blob, name: string, ... }\n                } else {\n                    console.warn(\"[FontLoader] Пропущен элемент в handleLocalFontsUpload, так как отсутствует Blob:\", font);\n                    return null;\n                }\n            }));\n            const validFonts = processedFonts.filter((font)=>font !== null);\n            if (validFonts.length > 0) {\n                // Определяем новые шрифты ДО вызова setFonts\n                const currentIds = new Set(currentFonts.map((f)=>f.id).filter(Boolean));\n                const trulyNewFonts = validFonts.filter((f)=>!f.id || !currentIds.has(f.id));\n                console.log(\"[handleLocalFontsUpload] Найдено новых шрифтов: \".concat(trulyNewFonts.length, \" из \").concat(validFonts.length));\n                if (trulyNewFonts.length > 0) {\n                    // Обновляем состояние\n                    setFonts((prevFonts)=>[\n                            ...prevFonts,\n                            ...trulyNewFonts\n                        ]);\n                    // Сохраняем новые шрифты в IndexedDB\n                    await Promise.all(trulyNewFonts.map((fontToSave)=>(0,_utils_db__WEBPACK_IMPORTED_MODULE_4__.saveFont)(fontToSave)));\n                    console.log(\"[FontLoader/DB] \".concat(trulyNewFonts.length, \" локальных шрифтов сохранено.\"));\n                    react_toastify__WEBPACK_IMPORTED_MODULE_1__.toast.success(\"Успешно загружено и сохранено новых локальных шрифтов: \".concat(trulyNewFonts.length));\n                    // Выбираем первый из *только что добавленных*\n                    if (typeof safeSelectFont === \"function\") {\n                        safeSelectFont(trulyNewFonts[0]);\n                    }\n                } else {\n                    react_toastify__WEBPACK_IMPORTED_MODULE_1__.toast.info(\"Загруженные локальные шрифты уже были добавлены ранее.\");\n                }\n            } else {\n                react_toastify__WEBPACK_IMPORTED_MODULE_1__.toast.warning(\"Не удалось обработать ни одного из загруженных локальных файлов.\");\n            }\n        } catch (error) {\n            react_toastify__WEBPACK_IMPORTED_MODULE_1__.toast.error(\"Ошибка при загрузке локальных шрифтов: \".concat(error.message));\n            console.error(\"[FontLoader] Ошибка в handleLocalFontsUpload:\", error);\n        } finally{\n            setIsLoading(false); // Убираем индикатор загрузки\n        }\n    }, [\n        setFonts,\n        setIsLoading,\n        safeSelectFont,\n        _utils_localFontProcessor__WEBPACK_IMPORTED_MODULE_3__.processLocalFont,\n        _utils_db__WEBPACK_IMPORTED_MODULE_4__.saveFont,\n        currentFonts\n    ]); // Добавляем зависимости\n    // Выбирает или загружает шрифт Fontsource\n    // (Переименована из selectOrAddFontsourceFont)\n    const loadAndSelectFontsourceFont = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(async function(fontFamilyName) {\n        let forceVariableFont = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;\n        try {\n            // Проверяем существующие шрифты (переданные как currentFonts)\n            const existingFont = currentFonts.find((font)=>{\n                var _font_displayName, _font_displayName1;\n                const nameMatch = font.name === fontFamilyName;\n                const variableMatch = font.isVariableFont === forceVariableFont;\n                // Для вариативных также проверяем displayName, чтобы отличить от статической версии с тем же familyName\n                const displayNameMatch = forceVariableFont ? (_font_displayName = font.displayName) === null || _font_displayName === void 0 ? void 0 : _font_displayName.includes(\"Variable\") : !((_font_displayName1 = font.displayName) === null || _font_displayName1 === void 0 ? void 0 : _font_displayName1.includes(\"Variable\"));\n                return nameMatch && variableMatch && displayNameMatch;\n            });\n            if (existingFont) {\n                if (typeof safeSelectFont === \"function\") {\n                    safeSelectFont(existingFont);\n                    react_toastify__WEBPACK_IMPORTED_MODULE_1__.toast.info(\"Шрифт \".concat(existingFont.displayName, \" уже загружен.\"));\n                }\n                return;\n            }\n            setIsLoading(true);\n            const fontObj = await loadAllFontsourceStyles(fontFamilyName, forceVariableFont);\n            if (fontObj) {\n                await (0,_utils_db__WEBPACK_IMPORTED_MODULE_4__.saveFont)(fontObj); // Сохраняем в DB\n                setFonts((prevFonts)=>[\n                        ...prevFonts,\n                        fontObj\n                    ]); // Добавляем в состояние\n                if (typeof safeSelectFont === \"function\") {\n                    safeSelectFont(fontObj); // Выбираем новый шрифт\n                }\n                react_toastify__WEBPACK_IMPORTED_MODULE_1__.toast.success(\"Шрифт \".concat(fontObj.displayName, \" успешно загружен и добавлен\"));\n            }\n        // Ошибка уже обработана и показана в loadAllFontsourceStyles\n        } catch (error) {\n        // Ошибка уже залогирована и показана в loadAllFontsourceStyles\n        // toast.error(`Не удалось загрузить шрифт ${fontFamilyName}`); // Можно добавить общее сообщение\n        } finally{\n            setIsLoading(false);\n        }\n    }, [\n        currentFonts,\n        setIsLoading,\n        setFonts,\n        safeSelectFont,\n        loadAllFontsourceStyles,\n        _utils_db__WEBPACK_IMPORTED_MODULE_4__.saveFont\n    ]); // Добавляем зависимости\n    return {\n        handleLocalFontsUpload,\n        loadAndSelectFontsourceFont,\n        loadFontsourceStyleVariant: loadFontStyleVariant\n    };\n}\n_s(useFontLoader, \"+RbSvH2HVSF2HXFjOHCJqIOUgZ8=\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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O2dCQUMxQ0wsU0FBUzJILENBQUFBLFlBQWE7MkJBQUlBO3dCQUFXdEg7cUJBQVEsR0FBRyx3QkFBd0I7Z0JBQ3hFLElBQUksT0FBT0gsbUJBQW1CLFlBQVk7b0JBQ3JDQSxlQUFlRyxVQUFVLHVCQUF1QjtnQkFDckQ7Z0JBQ0FuQixpREFBS0EsQ0FBQzJJLE9BQU8sQ0FBQyxTQUE2QixPQUFwQnhILFFBQVFxRSxXQUFXLEVBQUM7WUFDN0M7UUFDQSw2REFBNkQ7UUFDL0QsRUFBRSxPQUFPVixPQUFPO1FBQ2QsK0RBQStEO1FBQy9ELGlHQUFpRztRQUNuRyxTQUFVO1lBQ1IvRCxhQUFhO1FBQ2Y7SUFDRixHQUFHO1FBQUNFO1FBQWNGO1FBQWNEO1FBQVVFO1FBQWdCK0Q7UUFBeUIxRSwrQ0FBUUE7S0FBQyxHQUFHLHdCQUF3QjtJQUV2SCxPQUFPO1FBQ0x3SDtRQUNBaUI7UUFDQU0sNEJBQTRCbEk7SUFFOUI7QUFDRjtHQTNVZ0JMIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL2hvb2tzL3VzZUZvbnRMb2FkZXIuanM/NjA0OCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyB1c2VDYWxsYmFjayB9IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7IHRvYXN0IH0gZnJvbSAncmVhY3QtdG9hc3RpZnknO1xuaW1wb3J0IHsgZmluZFN0eWxlSW5mb0J5V2VpZ2h0QW5kU3R5bGUsIGdldEZvcm1hdEZyb21FeHRlbnNpb24sIFBSRVNFVF9TVFlMRVMgfSBmcm9tICcuLi91dGlscy9mb250VXRpbHNDb21tb24nO1xuaW1wb3J0IHsgcHJvY2Vzc0xvY2FsRm9udCB9IGZyb20gJy4uL3V0aWxzL2xvY2FsRm9udFByb2Nlc3Nvcic7XG5pbXBvcnQgeyBzYXZlRm9udCB9IGZyb20gJy4uL3V0aWxzL2RiJztcbmltcG9ydCB7IGJhc2U2NFRvQXJyYXlCdWZmZXIgfSBmcm9tICcuLi91dGlscy9mb250TWFuYWdlclV0aWxzJztcblxuLy8g0JrRjdGIINC00LvRjyDRhdGA0LDQvdC10L3QuNGPINC30LDQs9GA0YPQttC10L3QvdGL0YUg0YTQsNC50LvQvtCyINGI0YDQuNGE0YLQvtCyICjRgdGC0LDRgtC40YfQtdGB0LrQuNGFIEZvbnRzb3VyY2UpXG5jb25zdCBmb250RmFjZUNhY2hlID0gbmV3IE1hcCgpO1xuXG4vLyDQpdC10Ygt0YTRg9C90LrRhtC40Y8g0LTQu9GPINGB0L7Qt9C00LDQvdC40Y8g0YPQvdC40LrQsNC70YzQvdGL0YUg0LrQu9GO0YfQtdC5INC60Y3RiNC40YDQvtCy0LDQvdC40Y9cbmNvbnN0IGNyZWF0ZUNhY2hlS2V5ID0gKGZvbnRGYW1pbHksIHdlaWdodCwgc3R5bGUpID0+IGBmb250c291cmNlXyR7Zm9udEZhbWlseX1fJHt3ZWlnaHR9XyR7c3R5bGV9YDtcblxuLyoqXG4gKiDQpdGD0Log0LTQu9GPINGD0L/RgNCw0LLQu9C10L3QuNGPINC30LDQs9GA0YPQt9C60L7QuSDRiNGA0LjRhNGC0L7QsiDQuNC3INGA0LDQt9C70LjRh9C90YvRhSDQuNGB0YLQvtGH0L3QuNC60L7Qsi5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IHNldEZvbnRzIC0g0KTRg9C90LrRhtC40Y8g0LTQu9GPINC+0LHQvdC+0LLQu9C10L3QuNGPINGB0L7RgdGC0L7Rj9C90LjRjyDQvNCw0YHRgdC40LLQsCDRiNGA0LjRhNGC0L7Qsi5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IHNldElzTG9hZGluZyAtINCk0YPQvdC60YbQuNGPINC00LvRjyDRg9GB0YLQsNC90L7QstC60Lgg0YHQvtGB0YLQvtGP0L3QuNGPINC30LDQs9GA0YPQt9C60LguXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBzYWZlU2VsZWN0Rm9udCAtINCk0YPQvdC60YbQuNGPINC00LvRjyDQsdC10LfQvtC/0LDRgdC90L7Qs9C+INCy0YvQsdC+0YDQsCDRiNGA0LjRhNGC0LAg0L/QvtGB0LvQtSDQt9Cw0LPRgNGD0LfQutC4LlxuICogQHBhcmFtIHtBcnJheX0gY3VycmVudEZvbnRzIC0g0KLQtdC60YPRidC40Lkg0LzQsNGB0YHQuNCyINGI0YDQuNGE0YLQvtCyICjQtNC70Y8g0L/RgNC+0LLQtdGA0LrQuCDQtNGD0LHQu9C40LrQsNGC0L7QsikuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1c2VGb250TG9hZGVyKHNldEZvbnRzLCBzZXRJc0xvYWRpbmcsIHNhZmVTZWxlY3RGb250LCBjdXJyZW50Rm9udHMpIHtcblxuICAvLyDQktGB0L/QvtC80L7Qs9Cw0YLQtdC70YzQvdCw0Y8g0YTRg9C90LrRhtC40Y8g0LTQu9GPINC30LDQs9GA0YPQt9C60Lgg0L7QtNC90L7Qs9C+INGB0YLQsNGC0LjRh9C10YHQutC+0LPQviDQstCw0YDQuNCw0L3RgtCwINGB0YLQuNC70Y8gRm9udHNvdXJjZVxuICAvLyAo0J/QtdGA0LXQvdC10YHQtdC90LAg0LjQtyB1c2VGb250TWFuYWdlcilcbiAgY29uc3QgbG9hZEZvbnRTdHlsZVZhcmlhbnQgPSB1c2VDYWxsYmFjayhhc3luYyAoZm9udEZhbWlseSwgd2VpZ2h0LCBzdHlsZSwgZm9udE9iaiwgcmV0dXJuQmxvYiA9IGZhbHNlKSA9PiB7XG4gICAgLy8g0J3QlSDQt9Cw0LPRgNGD0LbQsNC10Lwg0YHRgtCw0YLQuNGH0LXRgdC60LjQtSDRgdGC0LjQu9C4LCDQtdGB0LvQuCDRiNGA0LjRhNGCINC+0L/RgNC10LTQtdC70LXQvSDQutCw0Log0LLQsNGA0LjQsNGC0LjQstC90YvQuVxuICAgIGlmIChmb250T2JqLmlzVmFyaWFibGVGb250KSB7XG4gICAgICByZXR1cm4gcmV0dXJuQmxvYiA/IG51bGwgOiB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgY29uc3QgY2FjaGVLZXkgPSBjcmVhdGVDYWNoZUtleShmb250RmFtaWx5LCB3ZWlnaHQsIHN0eWxlKTtcblxuICAgIGlmICghcmV0dXJuQmxvYiAmJiBmb250RmFjZUNhY2hlLmhhcyhjYWNoZUtleSkpIHtcbiAgICAgIGNvbnNvbGUubG9nKGBbRm9udExvYWRlcl0g0JjRgdC/0L7Qu9GM0LfRg9C10Lwg0LrRjdGI0LjRgNC+0LLQsNC90L3Ri9C1INC00LDQvdC90YvQtSDQtNC70Y8gJHtmb250RmFtaWx5fSAke3dlaWdodH0gJHtzdHlsZX1gKTtcbiAgICAgIGNvbnN0IGNhY2hlZERhdGEgPSBmb250RmFjZUNhY2hlLmdldChjYWNoZUtleSk7XG4gICAgICBpZiAoZm9udE9iai5sb2FkZWRTdHlsZXMgJiYgIWZvbnRPYmoubG9hZGVkU3R5bGVzLnNvbWUocyA9PiBzLndlaWdodCA9PT0gd2VpZ2h0ICYmIHMuc3R5bGUgPT09IHN0eWxlKSkge1xuICAgICAgICBmb250T2JqLmxvYWRlZFN0eWxlcy5wdXNoKHsgd2VpZ2h0LCBzdHlsZSwgY2FjaGVkOiB0cnVlIH0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJldHVybkJsb2IgPyBudWxsIDogdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIGxldCBibG9iID0gbnVsbDtcbiAgICBsZXQgZm9udERhdGFVcmwgPSBudWxsO1xuXG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IGZvbnRGYW1pbHlOYW1lID0gZm9udE9iai5mb250RmFtaWx5IHx8IGZvbnRGYW1pbHk7XG4gICAgICBjb25zdCBhcGlVcmwgPSBgL2FwaS9mb250c291cmNlLyR7ZW5jb2RlVVJJQ29tcG9uZW50KGZvbnRGYW1pbHkpfT93ZWlnaHQ9JHt3ZWlnaHR9JnN0eWxlPSR7c3R5bGV9JnN1YnNldD1sYXRpbmA7XG4gICAgICBjb25zb2xlLmxvZyhgW0ZvbnRMb2FkZXJdINCX0LDQv9GA0L7RgSDQuiBBUEk6ICR7YXBpVXJsfWApO1xuICAgICAgXG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKGFwaVVybCk7XG4gICAgICBpZiAoIXJlc3BvbnNlLm9rKSB0aHJvdyBuZXcgRXJyb3IoYNCe0YjQuNCx0LrQsCBIVFRQOiAke3Jlc3BvbnNlLnN0YXR1c31gKTtcbiAgICAgIFxuICAgICAgLy8g0J/RgNC+0LLQtdGA0Y/QtdC8LCDRh9GC0L4g0L7RgtCy0LXRgiDRgdC+0LTQtdGA0LbQuNGCIEpTT05cbiAgICAgIGNvbnN0IGNvbnRlbnRUeXBlID0gcmVzcG9uc2UuaGVhZGVycy5nZXQoJ2NvbnRlbnQtdHlwZScpO1xuICAgICAgY29uc29sZS5sb2coYFtGb250TG9hZGVyXSBDb250ZW50LVR5cGUg0L7RgtCy0LXRgtCwOiAke2NvbnRlbnRUeXBlfWApO1xuICAgICAgaWYgKCFjb250ZW50VHlwZSB8fCAhY29udGVudFR5cGUuaW5jbHVkZXMoJ2FwcGxpY2F0aW9uL2pzb24nKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYNCd0LXQvtC20LjQtNCw0L3QvdGL0Lkg0YLQuNC/INC+0YLQstC10YLQsDogJHtjb250ZW50VHlwZX1gKTtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgY29uc3QgcmVzcG9uc2VUZXh0ID0gYXdhaXQgcmVzcG9uc2UudGV4dCgpO1xuICAgICAgY29uc29sZS5sb2coYFtGb250TG9hZGVyXSDQntGC0LLQtdGCIEFQSSAo0L/QtdGA0LLRi9C1IDEwMCDRgdC40LzQstC+0LvQvtCyKTogJHtyZXNwb25zZVRleHQuc3Vic3RyaW5nKDAsIDEwMCl9YCk7XG4gICAgICBpZiAoIXJlc3BvbnNlVGV4dCB8fCByZXNwb25zZVRleHQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignQVBJINCy0LXRgNC90YPQuyDQv9GD0YHRgtC+0Lkg0LjQu9C4IHVuZGVmaW5lZCDQvtGC0LLQtdGCJyk7XG4gICAgICB9XG4gICAgICBcbiAgICAgIGNvbnN0IHsgZm9udEJ1ZmZlckJhc2U2NCwgZmlsZU5hbWUgfSA9IEpTT04ucGFyc2UocmVzcG9uc2VUZXh0KTtcbiAgICAgIGlmICghZm9udEJ1ZmZlckJhc2U2NCkgdGhyb3cgbmV3IEVycm9yKFwi0J/Rg9GB0YLQvtC5INCx0YPRhNC10YAg0YjRgNC40YTRgtCwXCIpO1xuXG4gICAgICBjb25zdCBmb250QnVmZmVyID0gYmFzZTY0VG9BcnJheUJ1ZmZlcihmb250QnVmZmVyQmFzZTY0KTtcbiAgICAgIGNvbnN0IG1pbWVUeXBlID0gYGZvbnQvJHtnZXRGb3JtYXRGcm9tRXh0ZW5zaW9uKGZpbGVOYW1lIHx8ICcud29mZjInKX1gO1xuICAgICAgYmxvYiA9IG5ldyBCbG9iKFtmb250QnVmZmVyXSwgeyB0eXBlOiBtaW1lVHlwZSB9KTtcbiAgICAgIGZvbnREYXRhVXJsID0gVVJMLmNyZWF0ZU9iamVjdFVSTChibG9iKTtcblxuICAgICAgY29uc3QgZm9udEZhY2VSdWxlID0gYFxuICAgICAgICBAZm9udC1mYWNlIHtcbiAgICAgICAgICBmb250LWZhbWlseTogJyR7Zm9udEZhbWlseU5hbWV9JztcbiAgICAgICAgICBzcmM6IHVybCgnJHtmb250RGF0YVVybH0nKSBmb3JtYXQoJ3dvZmYyJyk7XG4gICAgICAgICAgZm9udC13ZWlnaHQ6ICR7d2VpZ2h0fTtcbiAgICAgICAgICBmb250LXN0eWxlOiAke3N0eWxlfTtcbiAgICAgICAgICB1bmljb2RlLXJhbmdlOiBVKzAwMDAtMDBGRiwgVSswMTMxLCBVKzAxNTItMDE1MywgVSswMkJCLTAyQkMsIFUrMDJDNiwgVSswMkRBLCBVKzAyREMsIFUrMjAwMC0yMDZGLCBVKzIwNzQsIFUrMjBBQywgVSsyMTIyLCBVKzIxOTEsIFUrMjE5MywgVSsyMjEyLCBVKzIyMTUsIFUrRkVGRiwgVStGRkZEO1xuICAgICAgICB9XG4gICAgICBgO1xuICAgICAgY29uc3Qgc3R5bGVFbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc3R5bGUnKTtcbiAgICAgIHN0eWxlRWxlbWVudC50ZXh0Q29udGVudCA9IGZvbnRGYWNlUnVsZTtcbiAgICAgIGRvY3VtZW50LmhlYWQuYXBwZW5kQ2hpbGQoc3R5bGVFbGVtZW50KTtcblxuICAgICAgZm9udEZhY2VDYWNoZS5zZXQoY2FjaGVLZXksIHsgdXJsOiBmb250RGF0YVVybCwgc3R5bGVFbGVtZW50LCB3ZWlnaHQsIHN0eWxlIH0pO1xuXG4gICAgICBjb25zdCBmb250RmFjZSA9IG5ldyBGb250RmFjZShmb250RmFtaWx5TmFtZSwgYHVybCgke2ZvbnREYXRhVXJsfSlgLCB7IHdlaWdodDogU3RyaW5nKHdlaWdodCksIHN0eWxlIH0pO1xuXG4gICAgICB0cnkge1xuICAgICAgICBhd2FpdCBmb250RmFjZS5sb2FkKCk7XG4gICAgICAgIGRvY3VtZW50LmZvbnRzLmFkZChmb250RmFjZSk7XG4gICAgICAgIGlmIChmb250T2JqLmxvYWRlZFN0eWxlcyAmJiAhZm9udE9iai5sb2FkZWRTdHlsZXMuc29tZShzID0+IHMud2VpZ2h0ID09PSB3ZWlnaHQgJiYgcy5zdHlsZSA9PT0gc3R5bGUpKSB7XG4gICAgICAgICAgZm9udE9iai5sb2FkZWRTdHlsZXMucHVzaCh7IHdlaWdodCwgc3R5bGUsIGNhY2hlZDogZmFsc2UgfSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc29sZS5sb2coYFtGb250TG9hZGVyXSDQl9Cw0LPRgNGD0LbQtdC9INGB0YLQuNC70YwgJHtmb250RmFtaWx5fSAke3dlaWdodH0gJHtzdHlsZX1gKTtcbiAgICAgICAgcmV0dXJuIHJldHVybkJsb2IgPyBibG9iIDogdW5kZWZpbmVkO1xuICAgICAgfSBjYXRjaCAobG9hZEVycm9yKSB7XG4gICAgICAgIGNvbnNvbGUud2Fybihg0J3QtSDRg9C00LDQu9C+0YHRjCDQt9Cw0LPRgNGD0LfQuNGC0YwgRm9udEZhY2Ug0LTQu9GPICR7Zm9udEZhbWlseX0gJHt3ZWlnaHR9ICR7c3R5bGV9OmAsIGxvYWRFcnJvcik7XG4gICAgICAgIGlmIChmb250RGF0YVVybCkgVVJMLnJldm9rZU9iamVjdFVSTChmb250RGF0YVVybCk7XG4gICAgICAgIHJldHVybiByZXR1cm5CbG9iID8gbnVsbCA6IHVuZGVmaW5lZDtcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcihg0J7RiNC40LHQutCwINC/0YDQuCDQt9Cw0LPRgNGD0LfQutC1INGB0YLQuNC70Y8gJHtmb250RmFtaWx5fSAke3dlaWdodH0gJHtzdHlsZX06YCwgZXJyb3IpO1xuICAgICAgaWYgKGZvbnREYXRhVXJsKSBVUkwucmV2b2tlT2JqZWN0VVJMKGZvbnREYXRhVXJsKTtcbiAgICAgIGlmIChyZXR1cm5CbG9iKSByZXR1cm4gbnVsbDtcbiAgICAgIGVsc2UgdGhyb3cgZXJyb3I7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIGlmICghcmV0dXJuQmxvYiAmJiBmb250RGF0YVVybCkge1xuICAgICAgICAvLyBVUkwucmV2b2tlT2JqZWN0VVJMKGZvbnREYXRhVXJsKTsgLy8g0J/QvtC60LAg0L3QtSDRg9C00LDQu9GP0LXQvCwg0YfRgtC+0LHRiyDRgdGC0LjQu9C4INC90LUg0L/RgNC+0L/QsNC00LDQu9C4XG4gICAgICAgIGNvbnNvbGUud2FybihgW0ZvbnRMb2FkZXJdIEJsb2IgVVJMICR7Zm9udERhdGFVcmx9INC00LvRjyAke2ZvbnRGYW1pbHl9ICR7d2VpZ2h0fSAke3N0eWxlfSDQndCVINGD0LTQsNC70LXQvSAo0LTQu9GPINGB0YLQsNCx0LjQu9GM0L3QvtGB0YLQuCDRgdGC0LjQu9C10LkpLmApXG4gICAgICB9XG4gICAgfVxuICB9LCBbYmFzZTY0VG9BcnJheUJ1ZmZlciwgZ2V0Rm9ybWF0RnJvbUV4dGVuc2lvbl0pOyAvLyDQlNC+0LHQsNCy0LvRj9C10Lwg0LfQsNCy0LjRgdC40LzQvtGB0YLQuCDRg9GC0LjQu9C40YJcblxuICAvLyDQl9Cw0LPRgNGD0LbQsNC10YIg0LLRgdC1INGB0YLQuNC70Lgv0LLQsNGA0LjQsNGC0LjQstC90YvQuSDRhNCw0LnQuyDQtNC70Y8g0YjRgNC40YTRgtCwIEZvbnRzb3VyY2VcbiAgLy8gKNCf0LXRgNC10L3QtdGB0LXQvdCwINC40LcgdXNlRm9udE1hbmFnZXIpXG4gIGNvbnN0IGxvYWRBbGxGb250c291cmNlU3R5bGVzID0gdXNlQ2FsbGJhY2soYXN5bmMgKGZvbnRGYW1pbHksIGZvcmNlVmFyaWFibGVGb250ID0gZmFsc2UpID0+IHtcbiAgICB0cnkge1xuICAgICAgY29uc3QgbWV0YUFwaVVybCA9IGAvYXBpL2ZvbnRzb3VyY2UvJHtlbmNvZGVVUklDb21wb25lbnQoZm9udEZhbWlseSl9P21ldGE9dHJ1ZWA7XG4gICAgICBjb25zb2xlLmxvZyhgW0ZvbnRMb2FkZXJdINCX0LDQv9GA0L7RgSDQvNC10YLQsNC00LDQvdC90YvRhSDQuiBBUEk6ICR7bWV0YUFwaVVybH1gKTtcbiAgICAgIFxuICAgICAgY29uc3QgbWV0YVJlc3BvbnNlID0gYXdhaXQgZmV0Y2gobWV0YUFwaVVybCk7XG4gICAgICBpZiAoIW1ldGFSZXNwb25zZS5vaykgdGhyb3cgbmV3IEVycm9yKGDQnNC10YLQsNC00LDQvdC90YvQtSDQtNC70Y8gJHtmb250RmFtaWx5fSDQvdC1INC90LDQudC00LXQvdGLICjRgdGC0LDRgtGD0YEgJHttZXRhUmVzcG9uc2Uuc3RhdHVzfSlgKTtcbiAgICAgIFxuICAgICAgLy8g0J/RgNC+0LLQtdGA0Y/QtdC8LCDRh9GC0L4g0L7RgtCy0LXRgiDRgdC+0LTQtdGA0LbQuNGCIEpTT05cbiAgICAgIGNvbnN0IG1ldGFDb250ZW50VHlwZSA9IG1ldGFSZXNwb25zZS5oZWFkZXJzLmdldCgnY29udGVudC10eXBlJyk7XG4gICAgICBjb25zb2xlLmxvZyhgW0ZvbnRMb2FkZXJdIENvbnRlbnQtVHlwZSDQvNC10YLQsNC00LDQvdC90YvRhTogJHttZXRhQ29udGVudFR5cGV9YCk7XG4gICAgICBpZiAoIW1ldGFDb250ZW50VHlwZSB8fCAhbWV0YUNvbnRlbnRUeXBlLmluY2x1ZGVzKCdhcHBsaWNhdGlvbi9qc29uJykpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGDQndC10L7QttC40LTQsNC90L3Ri9C5INGC0LjQvyDQvtGC0LLQtdGC0LAg0L7RgiBBUEkg0LzQtdGC0LDQtNCw0L3QvdGL0YU6ICR7bWV0YUNvbnRlbnRUeXBlfWApO1xuICAgICAgfVxuICAgICAgXG4gICAgICBjb25zdCBtZXRhUmVzcG9uc2VUZXh0ID0gYXdhaXQgbWV0YVJlc3BvbnNlLnRleHQoKTtcbiAgICAgIGNvbnNvbGUubG9nKGBbRm9udExvYWRlcl0g0J7RgtCy0LXRgiBBUEkg0LzQtdGC0LDQtNCw0L3QvdGL0YUgKNC/0LXRgNCy0YvQtSAxMDAg0YHQuNC80LLQvtC70L7Qsik6ICR7bWV0YVJlc3BvbnNlVGV4dC5zdWJzdHJpbmcoMCwgMTAwKX1gKTtcbiAgICAgIGlmICghbWV0YVJlc3BvbnNlVGV4dCB8fCBtZXRhUmVzcG9uc2VUZXh0ID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0FQSSDQvNC10YLQsNC00LDQvdC90YvRhSDQstC10YDQvdGD0Lsg0L/Rg9GB0YLQvtC5INC40LvQuCB1bmRlZmluZWQg0L7RgtCy0LXRgicpO1xuICAgICAgfVxuICAgICAgXG4gICAgICBjb25zdCBtZXRhZGF0YSA9IEpTT04ucGFyc2UobWV0YVJlc3BvbnNlVGV4dCk7XG5cbiAgICAgIGNvbnN0IGFjdHVhbElzVmFyaWFibGVGb250ID0gbWV0YWRhdGE/Lm1ldGFkYXRhPy52YXJpYWJsZSAmJiBmb3JjZVZhcmlhYmxlRm9udDtcbiAgICAgIGNvbnN0IGRpc3BsYXlOYW1lID0gYWN0dWFsSXNWYXJpYWJsZUZvbnQgPyBgJHtmb250RmFtaWx5fSBWYXJpYWJsZWAgOiBmb250RmFtaWx5O1xuICAgICAgY29uc3QgZm9udElkID0gYGZvbnRzb3VyY2UtJHtmb250RmFtaWx5fS0ke2FjdHVhbElzVmFyaWFibGVGb250ID8gJ3ZhcmlhYmxlJyA6ICdzdGF0aWMnfWA7XG5cbiAgICAgIGNvbnN0IGZvbnRPYmogPSB7XG4gICAgICAgIGlkOiBmb250SWQsXG4gICAgICAgIG5hbWU6IGZvbnRGYW1pbHksXG4gICAgICAgIGRpc3BsYXlOYW1lOiBkaXNwbGF5TmFtZSxcbiAgICAgICAgc291cmNlOiAnZm9udHNvdXJjZScsXG4gICAgICAgIGZvbnRGYW1pbHk6IGAnJHtkaXNwbGF5TmFtZX0nYCxcbiAgICAgICAgdmFyaWFibGVBeGVzOiBhY3R1YWxJc1ZhcmlhYmxlRm9udCA/IG1ldGFkYXRhPy5tZXRhZGF0YT8uYXhlcyA6IHt9LFxuICAgICAgICBpc1ZhcmlhYmxlRm9udDogYWN0dWFsSXNWYXJpYWJsZUZvbnQsXG4gICAgICAgIGF2YWlsYWJsZVN0eWxlczogW10sXG4gICAgICAgIGxvYWRlZFN0eWxlczogW10sXG4gICAgICAgIGZpbGU6IG51bGwsXG4gICAgICAgIHVybDogbnVsbFxuICAgICAgfTtcblxuICAgICAgaWYgKGFjdHVhbElzVmFyaWFibGVGb250ICYmIG1ldGFkYXRhLnZhcmlhYmxlICYmIG1ldGFkYXRhLnZhcmlhYmxlLnVybCkge1xuICAgICAgICBjb25zb2xlLmxvZyhgW0ZvbnRMb2FkZXJdINCX0LDQs9GA0YPQttCw0LXQvCDQstCw0YDQuNCw0YLQuNCy0L3Ri9C5INGI0YDQuNGE0YIgJHtkaXNwbGF5TmFtZX0g0L/QviBVUkw6ICR7bWV0YWRhdGEudmFyaWFibGUudXJsfWApO1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGNvbnN0IGZvbnRGaWxlUmVzcG9uc2UgPSBhd2FpdCBmZXRjaChtZXRhZGF0YS52YXJpYWJsZS51cmwpO1xuICAgICAgICAgIGlmICghZm9udEZpbGVSZXNwb25zZS5vaykgdGhyb3cgbmV3IEVycm9yKGDQndC1INGD0LTQsNC70L7RgdGMINC30LDQs9GA0YPQt9C40YLRjCDRhNCw0LnQuyDQstCw0YDQuNCw0YLQuNCy0L3QvtCz0L4g0YjRgNC40YTRgtCwICjRgdGC0LDRgtGD0YEgJHtmb250RmlsZVJlc3BvbnNlLnN0YXR1c30pYCk7XG4gICAgICAgICAgY29uc3QgZm9udEJ1ZmZlciA9IGF3YWl0IGZvbnRGaWxlUmVzcG9uc2UuYXJyYXlCdWZmZXIoKTtcbiAgICAgICAgICBjb25zdCBmaWxlRXh0ZW5zaW9uID0gbWV0YWRhdGEudmFyaWFibGUudXJsLnNwbGl0KCcuJykucG9wKCk/LnRvTG93ZXJDYXNlKCkgfHwgJ3dvZmYyJztcbiAgICAgICAgICBjb25zdCBtaW1lVHlwZSA9IGBmb250LyR7ZmlsZUV4dGVuc2lvbiA9PT0gJ3R0ZicgPyAndHRmJyA6IGZpbGVFeHRlbnNpb24gPT09ICdvdGYnID8gJ290ZicgOiBmaWxlRXh0ZW5zaW9uID09PSAnd29mZicgPyAnd29mZicgOiAnd29mZjInfWA7XG4gICAgICAgICAgY29uc3QgYmxvYiA9IG5ldyBCbG9iKFtmb250QnVmZmVyXSwgeyB0eXBlOiBtaW1lVHlwZSB9KTtcblxuICAgICAgICAgIGZvbnRPYmouZmlsZSA9IGJsb2I7XG4gICAgICAgICAgZm9udE9iai51cmwgPSBVUkwuY3JlYXRlT2JqZWN0VVJMKGJsb2IpO1xuICAgICAgICAgIGNvbnNvbGUubG9nKGBbRm9udExvYWRlcl0g0JLQsNGA0LjQsNGC0LjQstC90YvQuSDRiNGA0LjRhNGCICR7ZGlzcGxheU5hbWV9INC30LDQs9GA0YPQttC10L0sIEJsb2Ig0YHQvtC30LTQsNC9LCBVUkw6ICR7Zm9udE9iai51cmx9YCk7XG5cbiAgICAgICAgICAvLyBUT0RPOiDQn9C10YDQtdC90LXRgdGC0Lgg0LvQvtCz0LjQutGDINC00L7QsdCw0LLQu9C10L3QuNGPIEBmb250LWZhY2Ug0LIgdXNlRm9udENzc1xuICAgICAgICAgIGNvbnN0IGZvbnRGYWNlUnVsZSA9IGBcbiAgICAgICAgICAgICAgQGZvbnQtZmFjZSB7XG4gICAgICAgICAgICAgICAgICBmb250LWZhbWlseTogJHtmb250T2JqLmZvbnRGYW1pbHl9O1xuICAgICAgICAgICAgICAgICAgc3JjOiB1cmwoJyR7Zm9udE9iai51cmx9JykgZm9ybWF0KCcke2ZpbGVFeHRlbnNpb24gPT09ICd0dGYnID8gJ3RydWV0eXBlJyA6IGZpbGVFeHRlbnNpb24gPT09ICdvdGYnID8gJ29wZW50eXBlJyA6IGZpbGVFeHRlbnNpb259Jyk7XG4gICAgICAgICAgICAgICAgICBmb250LWRpc3BsYXk6IHN3YXA7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGA7XG4gICAgICAgICAgY29uc3Qgc3R5bGVFbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc3R5bGUnKTtcbiAgICAgICAgICBzdHlsZUVsZW1lbnQudGV4dENvbnRlbnQgPSBmb250RmFjZVJ1bGU7XG4gICAgICAgICAgZG9jdW1lbnQuaGVhZC5hcHBlbmRDaGlsZChzdHlsZUVsZW1lbnQpO1xuICAgICAgICAgIGNvbnNvbGUubG9nKGBbRm9udExvYWRlcl0g0JLQsNGA0LjQsNGC0LjQstC90YvQuSDRiNGA0LjRhNGCICR7ZGlzcGxheU5hbWV9INC00L7QsdCw0LLQu9C10L0g0YfQtdGA0LXQtyA8c3R5bGU+IHRhZy5gKTtcblxuICAgICAgICB9IGNhdGNoIChsb2FkRXJyb3IpIHtcbiAgICAgICAgICBjb25zb2xlLmVycm9yKGBbRm9udExvYWRlcl0g0J7RiNC40LHQutCwINC/0YDQuCDQt9Cw0LPRgNGD0LfQutC1L9C+0LHRgNCw0LHQvtGC0LrQtSDQstCw0YDQuNCw0YLQuNCy0L3QvtCz0L4g0YTQsNC50LvQsCAke2Rpc3BsYXlOYW1lfTpgLCBsb2FkRXJyb3IpO1xuICAgICAgICAgIHRvYXN0LmVycm9yKGDQntGI0LjQsdC60LAg0LfQsNCz0YDRg9C30LrQuCDQstCw0YDQuNCw0YLQuNCy0L3QvtCz0L4g0YjRgNC40YTRgtCwICR7ZGlzcGxheU5hbWV9YCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgY29uc3Qgd2VpZ2h0c0FycmF5ID0gQXJyYXkuaXNBcnJheShtZXRhZGF0YT8ubWV0YWRhdGE/LndlaWdodHMpID8gbWV0YWRhdGEubWV0YWRhdGEud2VpZ2h0cyA6IFtdO1xuICAgICAgY29uc3Qgc3R5bGVzQXJyYXkgPSBBcnJheS5pc0FycmF5KG1ldGFkYXRhPy5tZXRhZGF0YT8uc3R5bGVzKSA/IG1ldGFkYXRhLm1ldGFkYXRhLnN0eWxlcyA6IFtdO1xuXG4gICAgICBjb25zdCBhdmFpbGFibGVTdHlsZXMgPSB3ZWlnaHRzQXJyYXkuZmxhdE1hcCh3ZWlnaHQgPT4ge1xuICAgICAgICByZXR1cm4gc3R5bGVzQXJyYXkubWFwKHN0eWxlID0+IHtcbiAgICAgICAgICBjb25zdCB3ZWlnaHROdW0gPSBwYXJzZUludCh3ZWlnaHQsIDEwKSB8fCA0MDA7XG4gICAgICAgICAgY29uc3Qgc3R5bGVJbmZvID0gZmluZFN0eWxlSW5mb0J5V2VpZ2h0QW5kU3R5bGUod2VpZ2h0TnVtLCBzdHlsZSk7XG4gICAgICAgICAgcmV0dXJuIHsgbmFtZTogc3R5bGVJbmZvID8gc3R5bGVJbmZvLm5hbWUgOiBgJHt3ZWlnaHR9ICR7c3R5bGV9YCwgd2VpZ2h0OiB3ZWlnaHROdW0sIHN0eWxlOiBzdHlsZSB9O1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgICAgZm9udE9iai5hdmFpbGFibGVTdHlsZXMgPSBhdmFpbGFibGVTdHlsZXM7XG5cbiAgICAgIGlmICghYWN0dWFsSXNWYXJpYWJsZUZvbnQpIHtcbiAgICAgICAgY29uc3QgcmVndWxhcldlaWdodCA9IHdlaWdodHNBcnJheS5pbmNsdWRlcygnNDAwJykgPyAnNDAwJyA6ICh3ZWlnaHRzQXJyYXlbMF0gfHwgJzQwMCcpO1xuICAgICAgICBjb25zdCByZWd1bGFyU3R5bGUgPSBzdHlsZXNBcnJheS5pbmNsdWRlcygnbm9ybWFsJykgPyAnbm9ybWFsJyA6IChzdHlsZXNBcnJheVswXSB8fCAnbm9ybWFsJyk7XG5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBjb25zb2xlLmxvZyhgW0ZvbnRMb2FkZXJdINCX0LDQs9GA0YPQttCw0LXQvCDQvtGB0L3QvtCy0L3QvtC5INGB0YLQsNGC0LjRh9C10YHQutC40Lkg0YHRgtC40LvRjCAke2ZvbnRGYW1pbHl9ICR7cmVndWxhcldlaWdodH0gJHtyZWd1bGFyU3R5bGV9YCk7XG4gICAgICAgICAgY29uc3QgbWFpblN0eWxlQmxvYiA9IGF3YWl0IGxvYWRGb250U3R5bGVWYXJpYW50KGZvbnRGYW1pbHksIHBhcnNlSW50KHJlZ3VsYXJXZWlnaHQsIDEwKSwgcmVndWxhclN0eWxlLCBmb250T2JqLCB0cnVlKTtcbiAgICAgICAgICBpZiAobWFpblN0eWxlQmxvYiBpbnN0YW5jZW9mIEJsb2IpIHtcbiAgICAgICAgICAgIGZvbnRPYmouZmlsZSA9IG1haW5TdHlsZUJsb2I7XG4gICAgICAgICAgICBmb250T2JqLnVybCA9IFVSTC5jcmVhdGVPYmplY3RVUkwobWFpblN0eWxlQmxvYik7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhgW0ZvbnRMb2FkZXJdINCe0YHQvdC+0LLQvdC+0Lkg0YHRgtCw0YLQuNGH0LXRgdC60LjQuSDRgdGC0LjQu9GMICR7ZGlzcGxheU5hbWV9INC30LDQs9GA0YPQttC10L0sIEJsb2Ig0YHQvtGF0YDQsNC90LXQvSwgVVJMOiAke2ZvbnRPYmoudXJsfWApO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oYFtGb250TG9hZGVyXSDQndC1INGD0LTQsNC70L7RgdGMINC/0L7Qu9GD0YfQuNGC0YwgQmxvYiDQtNC70Y8g0L7RgdC90L7QstC90L7Qs9C+INGB0YLQuNC70Y8gJHtkaXNwbGF5TmFtZX0uINCT0LvQuNGE0Ysg0LzQvtCz0YPRgiDQsdGL0YLRjCDQvdC10LTQvtGB0YLRg9C/0L3Riy5gKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gY2F0Y2ggKG1haW5TdHlsZUVycm9yKSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKGBbRm9udExvYWRlcl0g0JrRgNC40YLQuNGH0LXRgdC60LDRjyDQvtGI0LjQsdC60LAg0L/RgNC4INC30LDQs9GA0YPQt9C60LUg0L7RgdC90L7QstC90L7Qs9C+INGB0YLQuNC70Y8gJHtkaXNwbGF5TmFtZX06YCwgbWFpblN0eWxlRXJyb3IpO1xuICAgICAgICAgICAgdG9hc3QuZXJyb3IoYNCe0YjQuNCx0LrQsCDQt9Cw0LPRgNGD0LfQutC4INC+0YHQvdC+0LLQvdC+0LPQviDRgdGC0LjQu9GPICR7ZGlzcGxheU5hbWV9LiDQk9C70LjRhNGLINCx0YPQtNGD0YIg0L3QtdC00L7RgdGC0YPQv9C90YsuYCk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyDQl9Cw0LPRgNGD0LbQsNC10Lwg0L7RgdGC0LDQu9GM0L3Ri9C1INGB0YLQuNC70Lgg0LIg0YTQvtC90LVcbiAgICAgICAgc2V0VGltZW91dChhc3luYyAoKSA9PiB7XG4gICAgICAgICAgY29uc3QgcHJvbWlzZXMgPSBbXTtcbiAgICAgICAgICBmb3IgKGNvbnN0IHdlaWdodCBvZiB3ZWlnaHRzQXJyYXkpIHtcbiAgICAgICAgICAgIGZvciAoY29uc3Qgc3R5bGUgb2Ygc3R5bGVzQXJyYXkpIHtcbiAgICAgICAgICAgICAgaWYgKHdlaWdodCA9PT0gcmVndWxhcldlaWdodCAmJiBzdHlsZSA9PT0gcmVndWxhclN0eWxlKSBjb250aW51ZTtcbiAgICAgICAgICAgICAgcHJvbWlzZXMucHVzaChsb2FkRm9udFN0eWxlVmFyaWFudChmb250RmFtaWx5LCBwYXJzZUludCh3ZWlnaHQsIDEwKSwgc3R5bGUsIGZvbnRPYmosIGZhbHNlKVxuICAgICAgICAgICAgICAgIC5jYXRjaChlcnJvciA9PiBjb25zb2xlLmVycm9yKGDQntGI0LjQsdC60LAg0YTQvtC90L7QstC+0Lkg0LfQsNCz0YDRg9C30LrQuCDRgdGC0LjQu9GPICR7Zm9udEZhbWlseX0gJHt3ZWlnaHR9ICR7c3R5bGV9OmAsIGVycm9yKSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBhd2FpdCBQcm9taXNlLmFsbFNldHRsZWQocHJvbWlzZXMpO1xuICAgICAgICAgIGNvbnNvbGUubG9nKGBbRm9udExvYWRlcl0g0KTQvtC90L7QstCw0Y8g0LfQsNCz0YDRg9C30LrQsCDQstGB0LXRhSDRgdGC0LjQu9C10Lkg0LTQu9GPICR7Zm9udEZhbWlseX0g0LfQsNCy0LXRgNGI0LXQvdCwLmApO1xuICAgICAgICAgIHNldEZvbnRzKGN1cnJlbnRGb250cyA9PiBjdXJyZW50Rm9udHMubWFwKGYgPT4gZi5pZCA9PT0gZm9udElkID8geyAuLi5mIH0gOiBmKSk7XG4gICAgICAgIH0sIDEwMCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBmb250T2JqO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKGBbRm9udExvYWRlcl0g0J7RiNC40LHQutCwINC/0YDQuCDQt9Cw0LPRgNGD0LfQutC1INCy0YHQtdGFINGB0YLQuNC70LXQuSDRiNGA0LjRhNGC0LAgJHtmb250RmFtaWx5fTpgLCBlcnJvcik7XG4gICAgICB0b2FzdC5lcnJvcihg0J3QtSDRg9C00LDQu9C+0YHRjCDQt9Cw0LPRgNGD0LfQuNGC0Ywg0YjRgNC40YTRgiAke2ZvbnRGYW1pbHl9OiAke2Vycm9yLm1lc3NhZ2V9YCk7XG4gICAgICB0aHJvdyBlcnJvcjsgLy8g0J/RgNC+0LHRgNCw0YHRi9Cy0LDQtdC8INC+0YjQuNCx0LrRgyDQtNC70Y8g0L7QsdGA0LDQsdC+0YLQutC4INCyINCy0YvQt9GL0LLQsNGO0YnQtdC5INGE0YPQvdC60YbQuNC4XG4gICAgfVxuICB9LCBbc2V0Rm9udHMsIGxvYWRGb250U3R5bGVWYXJpYW50LCBmaW5kU3R5bGVJbmZvQnlXZWlnaHRBbmRTdHlsZV0pOyAvLyDQlNC+0LHQsNCy0LvRj9C10Lwg0LfQsNCy0LjRgdC40LzQvtGB0YLQuFxuXG4gIC8vINCe0LHRgNCw0LHQsNGC0YvQstCw0LXRgiDQt9Cw0LPRgNGD0LbQtdC90L3Ri9C1INC70L7QutCw0LvRjNC90YvQtSDRiNGA0LjRhNGC0YtcbiAgLy8gKNCf0LXRgNC10LjQvNC10L3QvtCy0LDQvdCwINC40LcgaGFuZGxlRm9udHNVcGxvYWRlZClcbiAgY29uc3QgaGFuZGxlTG9jYWxGb250c1VwbG9hZCA9IHVzZUNhbGxiYWNrKGFzeW5jIChuZXdGb250cykgPT4ge1xuICAgIGNvbnNvbGUubG9nKCdbaGFuZGxlTG9jYWxGb250c1VwbG9hZF0g0J3QsNGH0LDQu9C+INC+0LHRgNCw0LHQvtGC0LrQuDonLCBuZXdGb250cyk7XG4gICAgaWYgKCFBcnJheS5pc0FycmF5KG5ld0ZvbnRzKSB8fCBuZXdGb250cy5sZW5ndGggPT09IDApIHtcbiAgICAgIGNvbnNvbGUubG9nKCdbaGFuZGxlTG9jYWxGb250c1VwbG9hZF0g0J7RiNC40LHQutCwOiDQv9GD0YHRgtC+0Lkg0LzQsNGB0YHQuNCyINC40LvQuCDQvdC1INC80LDRgdGB0LjQsicpO1xuICAgICAgdG9hc3QuZXJyb3IoJ9Ce0YjQuNCx0LrQsDog0J3QtSDRg9C60LDQt9Cw0L3RiyDRhNCw0LnQu9GLINGI0YDQuNGE0YLQvtCyJyk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnNvbGUubG9nKCdbaGFuZGxlTG9jYWxGb250c1VwbG9hZF0g0KPRgdGC0LDQvdCw0LLQu9C40LLQsNC10LwgaXNMb2FkaW5nPXRydWUnKTtcbiAgICBzZXRJc0xvYWRpbmcodHJ1ZSk7IC8vINCf0L7QutCw0LfRi9Cy0LDQtdC8INC40L3QtNC40LrQsNGC0L7RgCDQt9Cw0LPRgNGD0LfQutC4XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHByb2Nlc3NlZEZvbnRzID0gYXdhaXQgUHJvbWlzZS5hbGwobmV3Rm9udHMubWFwKGFzeW5jIChmb250KSA9PiB7XG4gICAgICAgIGlmIChmb250LmZpbGUgaW5zdGFuY2VvZiBCbG9iKSB7XG4gICAgICAgICAgcmV0dXJuIGF3YWl0IHByb2Nlc3NMb2NhbEZvbnQoZm9udCk7IC8vIHByb2Nlc3NMb2NhbEZvbnQg0L7QttC40LTQsNC10YIgeyBmaWxlOiBCbG9iLCBuYW1lOiBzdHJpbmcsIC4uLiB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY29uc29sZS53YXJuKCdbRm9udExvYWRlcl0g0J/RgNC+0L/Rg9GJ0LXQvSDRjdC70LXQvNC10L3RgiDQsiBoYW5kbGVMb2NhbEZvbnRzVXBsb2FkLCDRgtCw0Log0LrQsNC6INC+0YLRgdGD0YLRgdGC0LLRg9C10YIgQmxvYjonLCBmb250KTtcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgfSkpO1xuXG4gICAgICBjb25zdCB2YWxpZEZvbnRzID0gcHJvY2Vzc2VkRm9udHMuZmlsdGVyKGZvbnQgPT4gZm9udCAhPT0gbnVsbCk7XG5cbiAgICAgIGlmICh2YWxpZEZvbnRzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgLy8g0J7Qv9GA0LXQtNC10LvRj9C10Lwg0L3QvtCy0YvQtSDRiNGA0LjRhNGC0Ysg0JTQniDQstGL0LfQvtCy0LAgc2V0Rm9udHNcbiAgICAgICAgY29uc3QgY3VycmVudElkcyA9IG5ldyBTZXQoY3VycmVudEZvbnRzLm1hcChmID0+IGYuaWQpLmZpbHRlcihCb29sZWFuKSk7XG4gICAgICAgIGNvbnN0IHRydWx5TmV3Rm9udHMgPSB2YWxpZEZvbnRzLmZpbHRlcihmID0+ICFmLmlkIHx8ICFjdXJyZW50SWRzLmhhcyhmLmlkKSk7XG4gICAgICAgIFxuICAgICAgICBjb25zb2xlLmxvZyhgW2hhbmRsZUxvY2FsRm9udHNVcGxvYWRdINCd0LDQudC00LXQvdC+INC90L7QstGL0YUg0YjRgNC40YTRgtC+0LI6ICR7dHJ1bHlOZXdGb250cy5sZW5ndGh9INC40LcgJHt2YWxpZEZvbnRzLmxlbmd0aH1gKTtcblxuICAgICAgICBpZiAodHJ1bHlOZXdGb250cy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgLy8g0J7QsdC90L7QstC70Y/QtdC8INGB0L7RgdGC0L7Rj9C90LjQtVxuICAgICAgICAgIHNldEZvbnRzKHByZXZGb250cyA9PiBbLi4ucHJldkZvbnRzLCAuLi50cnVseU5ld0ZvbnRzXSk7XG5cbiAgICAgICAgICAvLyDQodC+0YXRgNCw0L3Rj9C10Lwg0L3QvtCy0YvQtSDRiNGA0LjRhNGC0Ysg0LIgSW5kZXhlZERCXG4gICAgICAgICAgYXdhaXQgUHJvbWlzZS5hbGwodHJ1bHlOZXdGb250cy5tYXAoZm9udFRvU2F2ZSA9PiBzYXZlRm9udChmb250VG9TYXZlKSkpO1xuICAgICAgICAgIGNvbnNvbGUubG9nKGBbRm9udExvYWRlci9EQl0gJHt0cnVseU5ld0ZvbnRzLmxlbmd0aH0g0LvQvtC60LDQu9GM0L3Ri9GFINGI0YDQuNGE0YLQvtCyINGB0L7RhdGA0LDQvdC10L3Qvi5gKTtcbiAgICAgICAgICB0b2FzdC5zdWNjZXNzKGDQo9GB0L/QtdGI0L3QviDQt9Cw0LPRgNGD0LbQtdC90L4g0Lgg0YHQvtGF0YDQsNC90LXQvdC+INC90L7QstGL0YUg0LvQvtC60LDQu9GM0L3Ri9GFINGI0YDQuNGE0YLQvtCyOiAke3RydWx5TmV3Rm9udHMubGVuZ3RofWApO1xuICAgICAgICAgIFxuICAgICAgICAgIC8vINCS0YvQsdC40YDQsNC10Lwg0L/QtdGA0LLRi9C5INC40LcgKtGC0L7Qu9GM0LrQviDRh9GC0L4g0LTQvtCx0LDQstC70LXQvdC90YvRhSpcbiAgICAgICAgICBpZiAodHlwZW9mIHNhZmVTZWxlY3RGb250ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBzYWZlU2VsZWN0Rm9udCh0cnVseU5ld0ZvbnRzWzBdKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgdG9hc3QuaW5mbyhcItCX0LDQs9GA0YPQttC10L3QvdGL0LUg0LvQvtC60LDQu9GM0L3Ri9C1INGI0YDQuNGE0YLRiyDRg9C20LUg0LHRi9C70Lgg0LTQvtCx0LDQstC70LXQvdGLINGA0LDQvdC10LUuXCIpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0b2FzdC53YXJuaW5nKCfQndC1INGD0LTQsNC70L7RgdGMINC+0LHRgNCw0LHQvtGC0LDRgtGMINC90Lgg0L7QtNC90L7Qs9C+INC40Lcg0LfQsNCz0YDRg9C20LXQvdC90YvRhSDQu9C+0LrQsNC70YzQvdGL0YUg0YTQsNC50LvQvtCyLicpO1xuICAgICAgfVxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICB0b2FzdC5lcnJvcihg0J7RiNC40LHQutCwINC/0YDQuCDQt9Cw0LPRgNGD0LfQutC1INC70L7QutCw0LvRjNC90YvRhSDRiNGA0LjRhNGC0L7QsjogJHtlcnJvci5tZXNzYWdlfWApO1xuICAgICAgY29uc29sZS5lcnJvcignW0ZvbnRMb2FkZXJdINCe0YjQuNCx0LrQsCDQsiBoYW5kbGVMb2NhbEZvbnRzVXBsb2FkOicsIGVycm9yKTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgc2V0SXNMb2FkaW5nKGZhbHNlKTsgLy8g0KPQsdC40YDQsNC10Lwg0LjQvdC00LjQutCw0YLQvtGAINC30LDQs9GA0YPQt9C60LhcbiAgICB9XG4gIH0sIFtzZXRGb250cywgc2V0SXNMb2FkaW5nLCBzYWZlU2VsZWN0Rm9udCwgcHJvY2Vzc0xvY2FsRm9udCwgc2F2ZUZvbnQsIGN1cnJlbnRGb250c10pOyAvLyDQlNC+0LHQsNCy0LvRj9C10Lwg0LfQsNCy0LjRgdC40LzQvtGB0YLQuFxuXG4gIC8vINCS0YvQsdC40YDQsNC10YIg0LjQu9C4INC30LDQs9GA0YPQttCw0LXRgiDRiNGA0LjRhNGCIEZvbnRzb3VyY2VcbiAgLy8gKNCf0LXRgNC10LjQvNC10L3QvtCy0LDQvdCwINC40Lcgc2VsZWN0T3JBZGRGb250c291cmNlRm9udClcbiAgY29uc3QgbG9hZEFuZFNlbGVjdEZvbnRzb3VyY2VGb250ID0gdXNlQ2FsbGJhY2soYXN5bmMgKGZvbnRGYW1pbHlOYW1lLCBmb3JjZVZhcmlhYmxlRm9udCA9IGZhbHNlKSA9PiB7XG4gICAgdHJ5IHtcbiAgICAgIC8vINCf0YDQvtCy0LXRgNGP0LXQvCDRgdGD0YnQtdGB0YLQstGD0Y7RidC40LUg0YjRgNC40YTRgtGLICjQv9C10YDQtdC00LDQvdC90YvQtSDQutCw0LogY3VycmVudEZvbnRzKVxuICAgICAgY29uc3QgZXhpc3RpbmdGb250ID0gY3VycmVudEZvbnRzLmZpbmQoZm9udCA9PiB7XG4gICAgICAgIGNvbnN0IG5hbWVNYXRjaCA9IGZvbnQubmFtZSA9PT0gZm9udEZhbWlseU5hbWU7XG4gICAgICAgIGNvbnN0IHZhcmlhYmxlTWF0Y2ggPSBmb250LmlzVmFyaWFibGVGb250ID09PSBmb3JjZVZhcmlhYmxlRm9udDtcbiAgICAgICAgLy8g0JTQu9GPINCy0LDRgNC40LDRgtC40LLQvdGL0YUg0YLQsNC60LbQtSDQv9GA0L7QstC10YDRj9C10LwgZGlzcGxheU5hbWUsINGH0YLQvtCx0Ysg0L7RgtC70LjRh9C40YLRjCDQvtGCINGB0YLQsNGC0LjRh9C10YHQutC+0Lkg0LLQtdGA0YHQuNC4INGBINGC0LXQvCDQttC1IGZhbWlseU5hbWVcbiAgICAgICAgY29uc3QgZGlzcGxheU5hbWVNYXRjaCA9IGZvcmNlVmFyaWFibGVGb250ID8gZm9udC5kaXNwbGF5TmFtZT8uaW5jbHVkZXMoJ1ZhcmlhYmxlJykgOiAhZm9udC5kaXNwbGF5TmFtZT8uaW5jbHVkZXMoJ1ZhcmlhYmxlJyk7XG4gICAgICAgIHJldHVybiBuYW1lTWF0Y2ggJiYgdmFyaWFibGVNYXRjaCAmJiBkaXNwbGF5TmFtZU1hdGNoO1xuICAgICAgfSk7XG5cbiAgICAgIGlmIChleGlzdGluZ0ZvbnQpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBzYWZlU2VsZWN0Rm9udCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgIHNhZmVTZWxlY3RGb250KGV4aXN0aW5nRm9udCk7XG4gICAgICAgICAgdG9hc3QuaW5mbyhg0KjRgNC40YTRgiAke2V4aXN0aW5nRm9udC5kaXNwbGF5TmFtZX0g0YPQttC1INC30LDQs9GA0YPQttC10L0uYCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBzZXRJc0xvYWRpbmcodHJ1ZSk7XG4gICAgICBjb25zdCBmb250T2JqID0gYXdhaXQgbG9hZEFsbEZvbnRzb3VyY2VTdHlsZXMoZm9udEZhbWlseU5hbWUsIGZvcmNlVmFyaWFibGVGb250KTtcblxuICAgICAgaWYgKGZvbnRPYmopIHtcbiAgICAgICAgYXdhaXQgc2F2ZUZvbnQoZm9udE9iaik7IC8vINCh0L7RhdGA0LDQvdGP0LXQvCDQsiBEQlxuICAgICAgICBzZXRGb250cyhwcmV2Rm9udHMgPT4gWy4uLnByZXZGb250cywgZm9udE9ial0pOyAvLyDQlNC+0LHQsNCy0LvRj9C10Lwg0LIg0YHQvtGB0YLQvtGP0L3QuNC1XG4gICAgICAgIGlmICh0eXBlb2Ygc2FmZVNlbGVjdEZvbnQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICBzYWZlU2VsZWN0Rm9udChmb250T2JqKTsgLy8g0JLRi9Cx0LjRgNCw0LXQvCDQvdC+0LLRi9C5INGI0YDQuNGE0YJcbiAgICAgICAgfVxuICAgICAgICB0b2FzdC5zdWNjZXNzKGDQqNGA0LjRhNGCICR7Zm9udE9iai5kaXNwbGF5TmFtZX0g0YPRgdC/0LXRiNC90L4g0LfQsNCz0YDRg9C20LXQvSDQuCDQtNC+0LHQsNCy0LvQtdC9YCk7XG4gICAgICB9XG4gICAgICAvLyDQntGI0LjQsdC60LAg0YPQttC1INC+0LHRgNCw0LHQvtGC0LDQvdCwINC4INC/0L7QutCw0LfQsNC90LAg0LIgbG9hZEFsbEZvbnRzb3VyY2VTdHlsZXNcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgLy8g0J7RiNC40LHQutCwINGD0LbQtSDQt9Cw0LvQvtCz0LjRgNC+0LLQsNC90LAg0Lgg0L/QvtC60LDQt9Cw0L3QsCDQsiBsb2FkQWxsRm9udHNvdXJjZVN0eWxlc1xuICAgICAgLy8gdG9hc3QuZXJyb3IoYNCd0LUg0YPQtNCw0LvQvtGB0Ywg0LfQsNCz0YDRg9C30LjRgtGMINGI0YDQuNGE0YIgJHtmb250RmFtaWx5TmFtZX1gKTsgLy8g0JzQvtC20L3QviDQtNC+0LHQsNCy0LjRgtGMINC+0LHRidC10LUg0YHQvtC+0LHRidC10L3QuNC1XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIHNldElzTG9hZGluZyhmYWxzZSk7XG4gICAgfVxuICB9LCBbY3VycmVudEZvbnRzLCBzZXRJc0xvYWRpbmcsIHNldEZvbnRzLCBzYWZlU2VsZWN0Rm9udCwgbG9hZEFsbEZvbnRzb3VyY2VTdHlsZXMsIHNhdmVGb250XSk7IC8vINCU0L7QsdCw0LLQu9GP0LXQvCDQt9Cw0LLQuNGB0LjQvNC+0YHRgtC4XG5cbiAgcmV0dXJuIHtcbiAgICBoYW5kbGVMb2NhbEZvbnRzVXBsb2FkLFxuICAgIGxvYWRBbmRTZWxlY3RGb250c291cmNlRm9udCxcbiAgICBsb2FkRm9udHNvdXJjZVN0eWxlVmFyaWFudDogbG9hZEZvbnRTdHlsZVZhcmlhbnQsIC8vINCt0LrRgdC/0L7RgNGC0LjRgNGD0LXQvCDQtNC70Y8gdXNlRm9udFN0eWxlTWFuYWdlclxuICAgIC8vIGxvYWRBbGxGb250c291cmNlU3R5bGVzIC8vINCd0LUg0Y3QutGB0L/QvtGA0YLQuNGA0YPQtdC8LCDQuNGB0L/QvtC70YzQt9GD0LXRgtGB0Y8g0LLQvdGD0YLRgNC4IGxvYWRBbmRTZWxlY3RGb250c291cmNlRm9udFxuICB9O1xufSAiXSwibmFtZXMiOlsidXNlQ2FsbGJhY2siLCJ0b2FzdCIsImZpbmRTdHlsZUluZm9CeVdlaWdodEFuZFN0eWxlIiwiZ2V0Rm9ybWF0RnJvbUV4dGVuc2lvbiIsIlBSRVNFVF9TVFlMRVMiLCJwcm9jZXNzTG9jYWxGb250Iiwic2F2ZUZvbnQiLCJiYXNlNjRUb0FycmF5QnVmZmVyIiwiZm9udEZhY2VDYWNoZSIsIk1hcCIsImNyZWF0ZUNhY2hlS2V5IiwiZm9udEZhbWlseSIsIndlaWdodCIsInN0eWxlIiwidXNlRm9udExvYWRlciIsInNldEZvbnRzIiwic2V0SXNMb2FkaW5nIiwic2FmZVNlbGVjdEZvbnQiLCJjdXJyZW50Rm9udHMiLCJsb2FkRm9udFN0eWxlVmFyaWFudCIsImZvbnRPYmoiLCJyZXR1cm5CbG9iIiwiaXNWYXJpYWJsZUZvbnQiLCJ1bmRlZmluZWQiLCJjYWNoZUtleSIsImhhcyIsImNvbnNvbGUiLCJsb2ciLCJjYWNoZWREYXRhIiwiZ2V0IiwibG9hZGVkU3R5bGVzIiwic29tZSIsInMiLCJwdXNoIiwiY2FjaGVkIiwiYmxvYiIsImZvbnREYXRhVXJsIiwiZm9udEZhbWlseU5hbWUiLCJhcGlVcmwiLCJlbmNvZGVVUklDb21wb25lbnQiLCJyZXNwb25zZSIsImZldGNoIiwib2siLCJFcnJvciIsInN0YXR1cyIsImNvbnRlbnRUeXBlIiwiaGVhZGVycyIsImluY2x1ZGVzIiwicmVzcG9uc2VUZXh0IiwidGV4dCIsInN1YnN0cmluZyIsImZvbnRCdWZmZXJCYXNlNjQiLCJmaWxlTmFtZSIsIkpTT04iLCJwYXJzZSIsImZvbnRCdWZmZXIiLCJtaW1lVHlwZSIsIkJsb2IiLCJ0eXBlIiwiVVJMIiwiY3JlYXRlT2JqZWN0VVJMIiwiZm9udEZhY2VSdWxlIiwic3R5bGVFbGVtZW50IiwiZG9jdW1lbnQiLCJjcmVhdGVFbGVtZW50IiwidGV4dENvbnRlbnQiLCJoZWFkIiwiYXBwZW5kQ2hpbGQiLCJzZXQiLCJ1cmwiLCJmb250RmFjZSIsIkZvbnRGYWNlIiwiU3RyaW5nIiwibG9hZCIsImZvbnRzIiwiYWRkIiwibG9hZEVycm9yIiwid2FybiIsInJldm9rZU9iamVjdFVSTCIsImVycm9yIiwibG9hZEFsbEZvbnRzb3VyY2VTdHlsZXMiLCJmb3JjZVZhcmlhYmxlRm9udCIsIm1ldGFkYXRhIiwibWV0YUFwaVVybCIsIm1ldGFSZXNwb25zZSIsIm1ldGFDb250ZW50VHlwZSIsIm1ldGFSZXNwb25zZVRleHQiLCJhY3R1YWxJc1ZhcmlhYmxlRm9udCIsInZhcmlhYmxlIiwiZGlzcGxheU5hbWUiLCJmb250SWQiLCJpZCIsIm5hbWUiLCJzb3VyY2UiLCJ2YXJpYWJsZUF4ZXMiLCJheGVzIiwiYXZhaWxhYmxlU3R5bGVzIiwiZmlsZSIsImZvbnRGaWxlUmVzcG9uc2UiLCJhcnJheUJ1ZmZlciIsImZpbGVFeHRlbnNpb24iLCJzcGxpdCIsInBvcCIsInRvTG93ZXJDYXNlIiwid2VpZ2h0c0FycmF5IiwiQXJyYXkiLCJpc0FycmF5Iiwid2VpZ2h0cyIsInN0eWxlc0FycmF5Iiwic3R5bGVzIiwiZmxhdE1hcCIsIm1hcCIsIndlaWdodE51bSIsInBhcnNlSW50Iiwic3R5bGVJbmZvIiwicmVndWxhcldlaWdodCIsInJlZ3VsYXJTdHlsZSIsIm1haW5TdHlsZUJsb2IiLCJtYWluU3R5bGVFcnJvciIsInNldFRpbWVvdXQiLCJwcm9taXNlcyIsImNhdGNoIiwiUHJvbWlzZSIsImFsbFNldHRsZWQiLCJmIiwibWVzc2FnZSIsImhhbmRsZUxvY2FsRm9udHNVcGxvYWQiLCJuZXdGb250cyIsImxlbmd0aCIsInByb2Nlc3NlZEZvbnRzIiwiYWxsIiwiZm9udCIsInZhbGlkRm9udHMiLCJmaWx0ZXIiLCJjdXJyZW50SWRzIiwiU2V0IiwiQm9vbGVhbiIsInRydWx5TmV3Rm9udHMiLCJwcmV2Rm9udHMiLCJmb250VG9TYXZlIiwic3VjY2VzcyIsImluZm8iLCJ3YXJuaW5nIiwibG9hZEFuZFNlbGVjdEZvbnRzb3VyY2VGb250IiwiZXhpc3RpbmdGb250IiwiZmluZCIsIm5hbWVNYXRjaCIsInZhcmlhYmxlTWF0Y2giLCJkaXNwbGF5TmFtZU1hdGNoIiwibG9hZEZvbnRzb3VyY2VTdHlsZVZhcmlhbnQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./hooks/useFontLoader.js\n"));

/***/ }),

/***/ "./hooks/useFontManager.js":
/*!*********************************!*\
  !*** ./hooks/useFontManager.js ***!
  \*********************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   useFontManager: function() { return /* binding */ useFontManager; }\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"./node_modules/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var react_toastify__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react-toastify */ \"./node_modules/react-toastify/dist/index.mjs\");\n/* harmony import */ var _utils_fontUtilsCommon__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utils/fontUtilsCommon */ \"./utils/fontUtilsCommon.js\");\n/* harmony import */ var _utils_cssGenerator__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../utils/cssGenerator */ \"./utils/cssGenerator.js\");\n/* harmony import */ var _utils_db__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../utils/db */ \"./utils/db.js\");\n/* harmony import */ var _utils_localFontProcessor__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../utils/localFontProcessor */ \"./utils/localFontProcessor.js\");\n/* harmony import */ var _useFontPersistence__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./useFontPersistence */ \"./hooks/useFontPersistence.js\");\n/* harmony import */ var _useFontLoader__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./useFontLoader */ \"./hooks/useFontLoader.js\");\n/* harmony import */ var _useVariableFontControls__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./useVariableFontControls */ \"./hooks/useVariableFontControls.js\");\n/* harmony import */ var _useFontStyleManager__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./useFontStyleManager */ \"./hooks/useFontStyleManager.js\");\n/* harmony import */ var _useFontCss__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./useFontCss */ \"./hooks/useFontCss.js\");\n/* harmony import */ var _useFontExport__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./useFontExport */ \"./hooks/useFontExport.js\");\nvar _s = $RefreshSig$();\n\n// import opentype from 'opentype.js';\n\n\n\n\n // <<< Добавляем импорт revokeObjectURL\n // <<< Импортируем новый хук\n // <<< Импортируем useFontLoader\n\n // <<< Импортируем useFontStyleManager\n // <<< Импортируем useFontCss\n // <<< Импортируем useFontExport\n/**\n * Хук управления шрифтами в приложении\n * \n * Этот хук централизует всю логику работы со шрифтами, включая:\n * - Загрузку и парсинг шрифтов (локальных и Google Fonts)\n * - Управление вариативными осями шрифтов\n * - Генерацию CSS для шрифтов\n * - Удаление шрифтов и очистку ресурсов\n * - Создание статических версий вариативных шрифтов\n * \n * @example\n * // Использование хука в компоненте\n * const {\n *   fonts, \n *   selectedFont, \n *   handleFontsUploaded, \n *   getFontFamily, \n *   getVariationSettings \n * } = useFontManager();\n * \n * @returns {Object} Объект с состоянием и методами для работы со шрифтами\n */ function useFontManager() {\n    _s();\n    const [fonts, setFonts] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)([]);\n    const [selectedFont, setSelectedFont] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n    const [variableSettings, setVariableSettings] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)({});\n    const [exportedFont, setExportedFont] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n    const [isLoading, setIsLoading] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(false);\n    // Референс для отслеживания последнего проанализированного шрифта\n    const loadedFontId = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    // <<< Флаг для отслеживания начальной загрузки >>>\n    const [isInitialLoadComplete, setIsInitialLoadComplete] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(false);\n    // Создаем ref для safeSelectFont, чтобы использовать в колбэках\n    const safeSelectFontRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    // <<< Вызов хука загрузки шрифтов (обновляем коллбэк) >>>\n    const { handleLocalFontsUpload, loadAndSelectFontsourceFont, loadFontsourceStyleVariant } = (0,_useFontLoader__WEBPACK_IMPORTED_MODULE_7__.useFontLoader)(setFonts, setIsLoading, (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((font)=>{\n        var _safeSelectFontRef_current;\n        return (_safeSelectFontRef_current = safeSelectFontRef.current) === null || _safeSelectFontRef_current === void 0 ? void 0 : _safeSelectFontRef_current.call(safeSelectFontRef, font);\n    }, []), fonts);\n    // Создаем ref для saveFontSettings, чтобы использовать в колбэке до его объявления\n    const saveFontSettingsRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    // Создаем ref для saveLastVariableSettings, чтобы использовать до его объявления\n    const saveLastVariableSettingsRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    // <<< Вызов хука управления вариативными шрифтами >>>\n    const { applyVariableSettings, getDefaultAxisValues, resetVariableSettings, getVariableAxesInfo } = (0,_useVariableFontControls__WEBPACK_IMPORTED_MODULE_8__.useVariableFontControls)(selectedFont, variableSettings, setVariableSettings, setSelectedFont, setFonts, _utils_cssGenerator__WEBPACK_IMPORTED_MODULE_3__.debouncedUpdateVariableFontSettings, (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((settings)=>{\n        var _saveLastVariableSettingsRef_current;\n        console.log(\"[FontManager] Callback вызван для сохранения настроек:\", settings, \"ref доступен:\", !!saveLastVariableSettingsRef.current);\n        return (_saveLastVariableSettingsRef_current = saveLastVariableSettingsRef.current) === null || _saveLastVariableSettingsRef_current === void 0 ? void 0 : _saveLastVariableSettingsRef_current.call(saveLastVariableSettingsRef, settings);\n    }, []) // Передаем ref через callback\n    );\n    // Колбэк для сохранения настроек пресета в IndexedDB\n    const handlePresetApplied = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((fontId, settings)=>{\n        if (saveFontSettingsRef.current) {\n            saveFontSettingsRef.current(fontId, settings);\n        }\n    }, []);\n    // <<< Вызов хука управления стилями >>>\n    const { applyPresetStyle// Получаем функцию из нового хука\n     } = (0,_useFontStyleManager__WEBPACK_IMPORTED_MODULE_9__.useFontStyleManager)(selectedFont, setSelectedFont, setFonts, variableSettings, applyVariableSettings, loadFontsourceStyleVariant, handlePresetApplied // Передаем колбэк для сохранения в IndexedDB\n    );\n    // <<< Вызов хука персистентности (ПОСЛЕ объявления applyVariableSettings и applyPresetStyle) >>>\n    const { saveSelectedFontId, saveLastVariableSettings, saveLastPresetName, clearFontLocalStorage, resetPersistence, saveFontSettings } = (0,_useFontPersistence__WEBPACK_IMPORTED_MODULE_6__.useFontPersistence)(setFonts, setIsLoading, setIsInitialLoadComplete, setSelectedFont, applyVariableSettings, applyPresetStyle, fonts, selectedFont);\n    // Устанавливаем saveFontSettings в ref для использования в handlePresetApplied\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        saveFontSettingsRef.current = saveFontSettings;\n    }, [\n        saveFontSettings\n    ]);\n    // Устанавливаем saveLastVariableSettings в ref для использования в useVariableFontControls\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        console.log(\"[FontManager] Обновляем saveLastVariableSettingsRef:\", typeof saveLastVariableSettings);\n        saveLastVariableSettingsRef.current = saveLastVariableSettings;\n    }, [\n        saveLastVariableSettings\n    ]);\n    // <<< Производные состояния >>>\n    const isSelectedFontVariable = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>(selectedFont === null || selectedFont === void 0 ? void 0 : selectedFont.isVariableFont) || false, [\n        selectedFont\n    ]);\n    // <<< Вызов хука управления CSS >>>\n    const { getFontFamily, getVariationSettings, generateCSS, loadFontFace, updateVariableFontCss, debouncedUpdateVariableFontCss, exportToCSS: exportToCSSFromHook, fontCssProperties } = (0,_useFontCss__WEBPACK_IMPORTED_MODULE_10__.useFontCss)(selectedFont, variableSettings, isSelectedFontVariable);\n    // <<< Вызов хука экспорта >>>\n    const { downloadFile, exportToCSS: exportToCSSFromExportHook, createStaticFont: createStaticFontFromExportHook, generateStaticFontFile, downloadStaticFont } = (0,_useFontExport__WEBPACK_IMPORTED_MODULE_11__.useFontExport)(exportToCSSFromHook);\n    /**\n   * Безопасно выбирает шрифт и применяет к нему базовые настройки\n   * @param {Object} font - Объект шрифта для выбора\n   */ const safeSelectFont = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((font)=>{\n        if (!font) {\n            console.warn(\"[safeSelectFont] Попытка выбрать null/undefined шрифт\");\n            return;\n        }\n        console.log(\"[safeSelectFont] Выбираем шрифт: \".concat(font.name || font.displayName));\n        // Устанавливаем выбранный шрифт\n        setSelectedFont(font);\n        // Проверяем, есть ли сохраненные настройки для этого шрифта\n        let settingsApplied = false;\n        // Приоритет 1: Сохраненные настройки осей для вариативного шрифта\n        if (font.isVariableFont && font.lastUsedVariableSettings) {\n            console.log(\"[safeSelectFont] Восстанавливаем сохраненные оси:\", font.lastUsedVariableSettings);\n            setVariableSettings(font.lastUsedVariableSettings);\n            // Применяем настройки через setTimeout для корректной работы\n            setTimeout(()=>{\n                if (applyVariableSettings) {\n                    applyVariableSettings(font.lastUsedVariableSettings, true, font);\n                }\n            }, 0);\n            settingsApplied = true;\n        } else if (font.lastUsedPresetName && applyPresetStyle) {\n            console.log(\"[safeSelectFont] Восстанавливаем сохраненный пресет:\", font.lastUsedPresetName);\n            // Убираем setTimeout - выполняем синхронно, чтобы currentWeight/currentStyle обновились\n            applyPresetStyle(font.lastUsedPresetName, font);\n            settingsApplied = true;\n        }\n        // Если настройки не были восстановлены, применяем дефолтные\n        if (!settingsApplied) {\n            if (font.isVariableFont && font.variableAxes) {\n                // Получаем дефолтные значения из хука\n                const defaultAxes = (getDefaultAxisValues === null || getDefaultAxisValues === void 0 ? void 0 : getDefaultAxisValues(font)) || {};\n                console.log(\"[safeSelectFont] Применяем дефолтные оси для вариативного шрифта:\", defaultAxes);\n                setVariableSettings(defaultAxes);\n            } else {\n                // Для статических шрифтов очищаем настройки осей\n                setVariableSettings({});\n            }\n            // Применяем базовый стиль Regular\n            if (applyPresetStyle) {\n                // Убираем setTimeout - выполняем синхронно\n                applyPresetStyle(\"Regular\", font);\n            }\n        }\n    }, [\n        setSelectedFont,\n        setVariableSettings,\n        getDefaultAxisValues,\n        applyPresetStyle,\n        applyVariableSettings\n    ]);\n    // Сохраняем ссылку на функцию для использования в колбэках\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        safeSelectFontRef.current = safeSelectFont;\n    }, [\n        safeSelectFont\n    ]);\n    // Мемоизированное имя выбранного пресета (нужно определить до useEffect)\n    const selectedPresetName = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>{\n        if (!selectedFont) return \"Regular\"; // По умолчанию\n        console.log(\"[selectedPresetName] Вычисляем для шрифта: \".concat(selectedFont.name), {\n            lastUsedPresetName: selectedFont.lastUsedPresetName,\n            currentWeight: selectedFont.currentWeight,\n            currentStyle: selectedFont.currentStyle,\n            isVariableFont: selectedFont.isVariableFont,\n            variableSettings: variableSettings\n        });\n        // Приоритет 1: Для статических шрифтов используем currentWeight/currentStyle\n        if (!selectedFont.isVariableFont) {\n            // Сначала пытаемся определить по текущему весу и стилю\n            if (selectedFont.currentWeight !== undefined && selectedFont.currentStyle !== undefined) {\n                const styleInfo = (0,_utils_fontUtilsCommon__WEBPACK_IMPORTED_MODULE_2__.findStyleInfoByWeightAndStyle)(selectedFont.currentWeight, selectedFont.currentStyle);\n                const presetName = (styleInfo === null || styleInfo === void 0 ? void 0 : styleInfo.name) || \"Regular\";\n                console.log(\"[selectedPresetName] Статический шрифт по текущему весу/стилю: \".concat(presetName, \" (\").concat(selectedFont.currentWeight, \", \").concat(selectedFont.currentStyle, \")\"));\n                return presetName;\n            }\n            // Если currentWeight/currentStyle не установлены, используем сохраненный пресет\n            if (selectedFont.lastUsedPresetName) {\n                console.log(\"[selectedPresetName] Статический шрифт с сохраненным пресетом: \".concat(selectedFont.lastUsedPresetName));\n                return selectedFont.lastUsedPresetName;\n            }\n            // По умолчанию\n            console.log(\"[selectedPresetName] Статический шрифт по умолчанию: Regular\");\n            return \"Regular\";\n        }\n        // Приоритет 2: Для вариативных шрифтов с настройками осей, определяем пресет по осям\n        if (selectedFont.isVariableFont && variableSettings && Object.keys(variableSettings).length > 0) {\n            // Пытаемся найти пресет, который соответствует текущим настройкам осей\n            const currentWeight = variableSettings.wght || 400;\n            const currentStyle = variableSettings.ital === 1 || variableSettings.slnt && variableSettings.slnt < 0 ? \"italic\" : \"normal\";\n            const matchedPreset = (0,_utils_fontUtilsCommon__WEBPACK_IMPORTED_MODULE_2__.findStyleInfoByWeightAndStyle)(currentWeight, currentStyle);\n            if (matchedPreset) {\n                console.log(\"[selectedPresetName] Вариативный шрифт по осям: \".concat(matchedPreset.name));\n                return matchedPreset.name;\n            }\n        }\n        // Приоритет 3: Если есть сохраненный пресет, используем его\n        if (selectedFont.lastUsedPresetName) {\n            console.log(\"[selectedPresetName] Сохраненный пресет: \".concat(selectedFont.lastUsedPresetName));\n            return selectedFont.lastUsedPresetName;\n        }\n        // Приоритет 4: По умолчанию Regular\n        console.log(\"[selectedPresetName] По умолчанию: Regular\");\n        return \"Regular\";\n    }, [\n        selectedFont,\n        variableSettings\n    ]);\n    // <<< Сохранение настроек при переключении шрифтов >>>\n    const previousSelectedFontRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    const previousVariableSettingsRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)({});\n    const previousPresetNameRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(\"Regular\");\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        // Если есть предыдущий шрифт и он отличается от текущего\n        if (previousSelectedFontRef.current && previousSelectedFontRef.current.id !== (selectedFont === null || selectedFont === void 0 ? void 0 : selectedFont.id)) {\n            const prevFont = previousSelectedFontRef.current;\n            const prevVariableSettings = previousVariableSettingsRef.current;\n            const prevPresetName = previousPresetNameRef.current;\n            console.log(\"[FontSwitch] Сохраняем настройки для предыдущего шрифта: \".concat(prevFont.name));\n            // Сохраняем настройки предыдущего шрифта в его объект (для сессии)\n            const updatedFonts = fonts.map((font)=>{\n                if (font.id === prevFont.id) {\n                    const updatedFont = {\n                        ...font\n                    };\n                    let dbUpdates = {}; // Объект для обновления в IndexedDB\n                    // Сохраняем настройки в зависимости от типа ПРЕДЫДУЩЕГО шрифта\n                    if (prevFont.isVariableFont && Object.keys(prevVariableSettings).length > 0) {\n                        updatedFont.lastUsedVariableSettings = {\n                            ...prevVariableSettings\n                        };\n                        updatedFont.lastUsedPresetName = null; // Очищаем пресет, если есть оси\n                        dbUpdates.lastUsedVariableSettings = {\n                            ...prevVariableSettings\n                        };\n                        dbUpdates.lastUsedPresetName = null;\n                        console.log(\"[FontSwitch] Сохранены оси для \".concat(prevFont.name, \":\"), updatedFont.lastUsedVariableSettings);\n                    } else if (prevPresetName && prevPresetName !== \"Regular\") {\n                        updatedFont.lastUsedPresetName = prevPresetName;\n                        updatedFont.lastUsedVariableSettings = null; // Очищаем оси, если есть пресет\n                        dbUpdates.lastUsedPresetName = prevPresetName;\n                        dbUpdates.lastUsedVariableSettings = null;\n                        console.log(\"[FontSwitch] Сохранен пресет для \".concat(prevFont.name, \":\"), updatedFont.lastUsedPresetName);\n                    }\n                    // Сохраняем currentWeight и currentStyle если они есть\n                    if (prevFont.currentWeight !== undefined && prevFont.currentStyle !== undefined) {\n                        updatedFont.currentWeight = prevFont.currentWeight;\n                        updatedFont.currentStyle = prevFont.currentStyle;\n                        dbUpdates.currentWeight = prevFont.currentWeight;\n                        dbUpdates.currentStyle = prevFont.currentStyle;\n                    }\n                    // Сохраняем в IndexedDB если есть что сохранять\n                    if (Object.keys(dbUpdates).length > 0) {\n                        saveFontSettings(prevFont.id, dbUpdates);\n                    }\n                    return updatedFont;\n                }\n                return font;\n            });\n            setFonts(updatedFonts);\n            // Также сохраняем в localStorage (глобальные настройки)\n            if (prevFont.isVariableFont && Object.keys(prevVariableSettings).length > 0) {\n                saveLastVariableSettings(prevVariableSettings);\n            } else if (prevPresetName && prevPresetName !== \"Regular\") {\n                saveLastPresetName(prevPresetName);\n            }\n        }\n        // Обновляем ссылки на текущие настройки для следующего переключения\n        previousSelectedFontRef.current = selectedFont;\n        previousVariableSettingsRef.current = {\n            ...variableSettings\n        };\n        previousPresetNameRef.current = selectedPresetName;\n        // Сохраняем ID выбранного шрифта\n        if (selectedFont === null || selectedFont === void 0 ? void 0 : selectedFont.id) {\n            saveSelectedFontId(selectedFont.id);\n        }\n    }, [\n        selectedFont,\n        fonts,\n        setFonts,\n        saveSelectedFontId,\n        saveLastVariableSettings,\n        saveLastPresetName,\n        saveFontSettings,\n        variableSettings,\n        selectedPresetName\n    ]);\n    // Убираем старый код loadInitialState, так как теперь useFontPersistence работает напрямую\n    // Мемоизированные доступные стили и имя выбранного пресета\n    const availableStyles = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>{\n        if (!selectedFont) return [];\n        console.log(\"[useMemo availableStyles] selectedFont:\", selectedFont === null || selectedFont === void 0 ? void 0 : selectedFont.name, \"selectedFont.availableStyles:\", selectedFont === null || selectedFont === void 0 ? void 0 : selectedFont.availableStyles);\n        // Удаляем специальную логику для Google Fonts\n        /*\n      if (selectedFont.source === 'google') {\n        // Для Google шрифтов берем стили из карты или дефолтные\n        const styles = GOOGLE_FONT_STYLES_MAP[selectedFont.name] || [\n            PRESET_STYLES.find(p => p.name === 'Regular'),\n            PRESET_STYLES.find(p => p.name === 'Bold')\n        ].filter(Boolean);\n        return styles;\n      } else */ // Если шрифт вариативный, возвращаем все пресеты (для UI выбора)\n        if (selectedFont.isVariableFont) {\n            return _utils_fontUtilsCommon__WEBPACK_IMPORTED_MODULE_2__.PRESET_STYLES;\n        // Если у шрифта есть поле availableStyles (из Fontsource или локального парсинга)\n        } else if (selectedFont.availableStyles && Array.isArray(selectedFont.availableStyles)) {\n            // Убедимся, что стили имеют нужный формат {name, weight, style}\n            // Если формат уже правильный, просто возвращаем\n            if (selectedFont.availableStyles.every((s)=>s.name && s.weight && s.style)) {\n                return selectedFont.availableStyles;\n            }\n            // Если формат другой (например, из Fontsource metadata), нужно будет его преобразовать\n            // Пока просто возвращаем пустой массив или базовые, если преобразование не реализовано\n            // TODO: Добавить преобразование из формата Fontsource metadata, если он отличается\n            console.warn(\"Формат availableStyles отличается от ожидаемого, требуется преобразование.\");\n            return [\n                _utils_fontUtilsCommon__WEBPACK_IMPORTED_MODULE_2__.PRESET_STYLES.find((p)=>p.name === \"Regular\"),\n                _utils_fontUtilsCommon__WEBPACK_IMPORTED_MODULE_2__.PRESET_STYLES.find((p)=>p.name === \"Bold\")\n            ].filter(Boolean);\n        // Иначе возвращаем базовые стили\n        } else {\n            return [\n                _utils_fontUtilsCommon__WEBPACK_IMPORTED_MODULE_2__.PRESET_STYLES.find((p)=>p.name === \"Regular\"),\n                _utils_fontUtilsCommon__WEBPACK_IMPORTED_MODULE_2__.PRESET_STYLES.find((p)=>p.name === \"Bold\")\n            ].filter(Boolean);\n        }\n    }, [\n        selectedFont\n    ]);\n    // Мемоизированный флаг вариативного шрифта (перенесено в useFontCss)\n    // Мемоизированное имя шрифта\n    const selectedFontName = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>{\n        return selectedFont ? selectedFont.name : \"\";\n    }, [\n        selectedFont\n    ]);\n    // Мемоизированные оси шрифта\n    const selectedFontAxes = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>{\n        return selectedFont && selectedFont.variableAxes ? selectedFont.variableAxes : {};\n    }, [\n        selectedFont\n    ]);\n    /**\n   * Создает статическую версию вариативного шрифта с текущими настройками осей\n   * \n   * @example\n   * // Создание статической версии текущего шрифта\n   * const staticFont = createStaticFont();\n   * console.log(staticFont.name); // Имя статического шрифта\n   * \n   * @returns {Object|undefined} Объект статического шрифта или undefined, если нет выбранного шрифта\n   */ const createStaticFont = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(()=>{\n        return createStaticFontFromExportHook(selectedFont, selectedFontName, variableSettings, setExportedFont);\n    }, [\n        createStaticFontFromExportHook,\n        selectedFont,\n        selectedFontName,\n        variableSettings,\n        setExportedFont\n    ]);\n    /**\n   * Обрабатывает загруженные шрифты: анализирует файлы, определяет характеристики и\n   * добавляет шрифты в состояние приложения\n   * \n   * @example\n   * // Обработка шрифтов из input[type=\"file\"]\n   * const handleFileUpload = (e) => {\n   *   const files = Array.from(e.target.files).map(file => ({\n   *     file,\n   *     name: file.name,\n   *     url: URL.createObjectURL(file)\n   *   }));\n   *   handleFontsUploaded(files);\n   * };\n   * \n   * @param {Array} newFonts - Массив объектов с информацией о новых шрифтах\n   * @returns {Promise<void>}\n   */ const handleFontsUploaded = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(async (newFonts)=>{\n        console.log(\"[handleFontsUploaded] Получены шрифты:\", newFonts);\n        // Используем функцию из useFontLoader\n        const result = await handleLocalFontsUpload(newFonts);\n        console.log(\"[handleFontsUploaded] handleLocalFontsUpload завершен\");\n        return result;\n    }, [\n        handleLocalFontsUpload\n    ]);\n    /**\n   * Удаляет шрифт и освобождает ресурсы\n   * Если удаляется текущий выбранный шрифт, выбирает следующий доступный\n   * \n   * @example\n   * // Кнопка удаления шрифта\n   * <button onClick={() => removeFont(font.id)}>\n   *   Удалить\n   * </button>\n   * \n   * @param {string} fontId - ID шрифта для удаления\n   */ const removeFont = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((fontId)=>{\n        let removedFontFamily = null;\n        setFonts((prev)=>{\n            const fontToRemove = prev.find((f)=>f.id === fontId);\n            if (fontToRemove) {\n                removedFontFamily = fontToRemove.fontFamily; // Сохраняем имя для очистки\n                if (fontToRemove.url) {\n                    // Освобождаем URL для предотвращения утечек памяти\n                    (0,_utils_localFontProcessor__WEBPACK_IMPORTED_MODULE_5__.revokeObjectURL)(fontToRemove.url);\n                }\n                // <<< Удаляем из IndexedDB >>>\n                (0,_utils_db__WEBPACK_IMPORTED_MODULE_4__.deleteFontDB)(fontId).catch((err)=>{\n                    console.error(\"[DB] Ошибка удаления шрифта \".concat(fontId, \" из DB:\"), err);\n                    react_toastify__WEBPACK_IMPORTED_MODULE_1__.toast.error(\"Ошибка удаления шрифта из базы данных.\");\n                // Что делать в этом случае? Возможно, ничего, шрифт останется в DB.\n                });\n            }\n            const updatedFonts = prev.filter((f)=>f.id !== fontId);\n            // Если удаляем текущий выбранный шрифт, выбираем следующий доступный\n            if (selectedFont && selectedFont.id === fontId) {\n                if (updatedFonts.length > 0) {\n                    // Сохраняем ссылку на новый шрифт для дальнейшего применения стиля\n                    const newFont = updatedFonts[0];\n                    // Устанавливаем новый шрифт\n                    setSelectedFont(newFont);\n                    // После установки нового шрифта, настраиваем его со стилем Regular\n                    setTimeout(()=>{\n                        var _safeSelectFontRef_current;\n                        // Устанавливаем стиль Regular для нового шрифта\n                        const presetName = \"Regular\";\n                        (_safeSelectFontRef_current = safeSelectFontRef.current) === null || _safeSelectFontRef_current === void 0 ? void 0 : _safeSelectFontRef_current.call(safeSelectFontRef, newFont);\n                    }, 0);\n                } else {\n                    setSelectedFont(null);\n                }\n            }\n            return updatedFonts;\n        });\n        react_toastify__WEBPACK_IMPORTED_MODULE_1__.toast.success(\"Шрифт удален\");\n    // Очистка FontFace из document.fonts (необязательно, но хорошо для гигиены)\n    // if (removedFontFamily && document.fonts) {\n    //    document.fonts.delete(removedFontFamily);\n    // }\n    }, [\n        selectedFont,\n        _utils_db__WEBPACK_IMPORTED_MODULE_4__.deleteFontDB,\n        setFonts,\n        setSelectedFont\n    ]);\n    // Обертки для совместимости с предыдущим API\n    const exportToCSS = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(function() {\n        let download = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : false;\n        return exportToCSSFromExportHook(selectedFont, selectedFontName, download);\n    }, [\n        exportToCSSFromExportHook,\n        selectedFont,\n        selectedFontName\n    ]);\n    /**\n   * Выбирает (или загружает, если ещё не загружен) шрифт Fontsource\n   * @param {string} fontFamilyName - Название семейства шрифтов\n   * @param {boolean} forceVariableFont - Загружать вариативный шрифт (если доступен)\n   */ const selectOrAddFontsourceFont = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(async function(fontFamilyName) {\n        let forceVariableFont = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;\n        // Просто перенаправляем на функцию из useFontLoader\n        return loadAndSelectFontsourceFont(fontFamilyName, forceVariableFont);\n    }, [\n        loadAndSelectFontsourceFont\n    ]);\n    // <<< Функция полного сброса >>>\n    const resetApplicationState = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(async ()=>{\n        console.log(\"[Reset] Запуск полного сброса состояния приложения...\");\n        try {\n            // 1. Очищаем хранилища (IndexedDB и localStorage) через новый хук\n            await resetPersistence(); // <<< Вызываем сброс персистентности\n            react_toastify__WEBPACK_IMPORTED_MODULE_1__.toast.info(\"Локальное хранилище данных очищено.\"); // Обновляем сообщение\n            // 2. Очищаем состояния хука (остается как было)\n            setFonts([]);\n            setSelectedFont(null);\n            setVariableSettings({});\n            setExportedFont(null);\n            setIsLoading(false); // Сбрасываем флаг загрузки\n            // isInitialLoadComplete останется true, т.к. начальная загрузка была\n            console.log(\"[Reset] Состояния useFontManager сброшены.\");\n            // 4. Вызываем сброс других контекстов (пока только SettingsContext)\n            // resetSettings(); // Вызов будет в компоненте кнопки\n            react_toastify__WEBPACK_IMPORTED_MODULE_1__.toast.success(\"Состояние приложения успешно сброшено!\");\n        } catch (error) {\n            console.error(\"[Reset] Ошибка во время сброса состояния:\", error);\n            react_toastify__WEBPACK_IMPORTED_MODULE_1__.toast.error(\"Произошла ошибка при сбросе состояния.\");\n        }\n    }, [\n        setFonts,\n        setSelectedFont,\n        setVariableSettings,\n        setExportedFont,\n        setIsLoading,\n        resetPersistence\n    ]); // Добавляем зависимости сеттеров\n    // Убираем старые useEffect, связанные с loadInitialState\n    return {\n        // Состояния\n        fonts,\n        selectedFont,\n        variableSettings,\n        exportedFont,\n        isSelectedFontVariable,\n        selectedFontName,\n        selectedFontAxes,\n        availableStyles,\n        selectedPresetName,\n        isLoading,\n        isInitialLoadComplete,\n        // Методы управления состоянием\n        setFonts,\n        setSelectedFont,\n        setVariableSettings,\n        setExportedFont,\n        // Методы загрузки (из useFontLoader)\n        handleLocalFontsUpload,\n        handleFontsUploaded,\n        loadAndSelectFontsourceFont,\n        selectOrAddFontsourceFont,\n        // Методы управления шрифтами \n        removeFont,\n        safeSelectFont,\n        // <<< Методы работы с вариативными осями из useVariableFontControls >>>\n        getVariableAxesInfo,\n        getVariableAxes: getVariableAxesInfo,\n        applyVariableSettings,\n        handleVariableSettingsChange: applyVariableSettings,\n        resetVariableSettings,\n        getDefaultAxisValues,\n        // Методы для стилей шрифта\n        applyPresetStyle,\n        // Методы для CSS\n        getFontFamily,\n        getVariationSettings,\n        generateCSS,\n        exportToCSS,\n        fontCssProperties,\n        // Методы экспорта и скачивания (из useFontExport)\n        downloadFile,\n        generateStaticFontFile,\n        downloadStaticFont,\n        // Прочие методы\n        createStaticFont,\n        resetApplicationState,\n        // Методы персистентности\n        saveFontSettings\n    };\n}\n_s(useFontManager, \"ahdq+c6xRuJbWBc67gEtRsw6LxM=\", false, function() {\n    return [\n        _useFontLoader__WEBPACK_IMPORTED_MODULE_7__.useFontLoader,\n        _useVariableFontControls__WEBPACK_IMPORTED_MODULE_8__.useVariableFontControls,\n        _useFontStyleManager__WEBPACK_IMPORTED_MODULE_9__.useFontStyleManager,\n        _useFontPersistence__WEBPACK_IMPORTED_MODULE_6__.useFontPersistence,\n        _useFontCss__WEBPACK_IMPORTED_MODULE_10__.useFontCss,\n        _useFontExport__WEBPACK_IMPORTED_MODULE_11__.useFontExport\n    ];\n});\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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UUFtQnJHQyw2RUFBdUJBO1FBdUJ2QkMscUVBQW1CQTtRQWtCbkJILG1FQUFrQkE7UUFtQ2xCSSxvREFBVUE7UUFTVkMsMERBQWFBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL2hvb2tzL3VzZUZvbnRNYW5hZ2VyLmpzPzVhZTEiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgdXNlU3RhdGUsIHVzZUNhbGxiYWNrLCB1c2VSZWYsIHVzZU1lbW8sIHVzZUVmZmVjdCB9IGZyb20gJ3JlYWN0Jztcbi8vIGltcG9ydCBvcGVudHlwZSBmcm9tICdvcGVudHlwZS5qcyc7XG5pbXBvcnQgeyB0b2FzdCB9IGZyb20gJ3JlYWN0LXRvYXN0aWZ5JztcbmltcG9ydCB7IGZpbmRTdHlsZUluZm9CeVdlaWdodEFuZFN0eWxlLCBQUkVTRVRfU1RZTEVTIH0gZnJvbSAnLi4vdXRpbHMvZm9udFV0aWxzQ29tbW9uJztcbmltcG9ydCB7IGRlYm91bmNlZFVwZGF0ZVZhcmlhYmxlRm9udFNldHRpbmdzIH0gZnJvbSAnLi4vdXRpbHMvY3NzR2VuZXJhdG9yJztcbmltcG9ydCB7IGRlbGV0ZUZvbnREQiB9IGZyb20gJy4uL3V0aWxzL2RiJztcbmltcG9ydCB7IHJldm9rZU9iamVjdFVSTCB9IGZyb20gJy4uL3V0aWxzL2xvY2FsRm9udFByb2Nlc3Nvcic7IC8vIDw8PCDQlNC+0LHQsNCy0LvRj9C10Lwg0LjQvNC/0L7RgNGCIHJldm9rZU9iamVjdFVSTFxuaW1wb3J0IHsgdXNlRm9udFBlcnNpc3RlbmNlIH0gZnJvbSAnLi91c2VGb250UGVyc2lzdGVuY2UnOyAvLyA8PDwg0JjQvNC/0L7RgNGC0LjRgNGD0LXQvCDQvdC+0LLRi9C5INGF0YPQulxuaW1wb3J0IHsgdXNlRm9udExvYWRlciB9IGZyb20gJy4vdXNlRm9udExvYWRlcic7IC8vIDw8PCDQmNC80L/QvtGA0YLQuNGA0YPQtdC8IHVzZUZvbnRMb2FkZXJcbmltcG9ydCB7IHVzZVZhcmlhYmxlRm9udENvbnRyb2xzIH0gZnJvbSAnLi91c2VWYXJpYWJsZUZvbnRDb250cm9scyc7XG5pbXBvcnQgeyB1c2VGb250U3R5bGVNYW5hZ2VyIH0gZnJvbSAnLi91c2VGb250U3R5bGVNYW5hZ2VyJzsgLy8gPDw8INCY0LzQv9C+0YDRgtC40YDRg9C10LwgdXNlRm9udFN0eWxlTWFuYWdlclxuaW1wb3J0IHsgdXNlRm9udENzcyB9IGZyb20gJy4vdXNlRm9udENzcyc7IC8vIDw8PCDQmNC80L/QvtGA0YLQuNGA0YPQtdC8IHVzZUZvbnRDc3NcbmltcG9ydCB7IHVzZUZvbnRFeHBvcnQgfSBmcm9tICcuL3VzZUZvbnRFeHBvcnQnOyAvLyA8PDwg0JjQvNC/0L7RgNGC0LjRgNGD0LXQvCB1c2VGb250RXhwb3J0XG5cbi8qKlxuICog0KXRg9C6INGD0L/RgNCw0LLQu9C10L3QuNGPINGI0YDQuNGE0YLQsNC80Lgg0LIg0L/RgNC40LvQvtC20LXQvdC40LhcbiAqIFxuICog0K3RgtC+0YIg0YXRg9C6INGG0LXQvdGC0YDQsNC70LjQt9GD0LXRgiDQstGB0Y4g0LvQvtCz0LjQutGDINGA0LDQsdC+0YLRiyDRgdC+INGI0YDQuNGE0YLQsNC80LgsINCy0LrQu9GO0YfQsNGPOlxuICogLSDQl9Cw0LPRgNGD0LfQutGDINC4INC/0LDRgNGB0LjQvdCzINGI0YDQuNGE0YLQvtCyICjQu9C+0LrQsNC70YzQvdGL0YUg0LggR29vZ2xlIEZvbnRzKVxuICogLSDQo9C/0YDQsNCy0LvQtdC90LjQtSDQstCw0YDQuNCw0YLQuNCy0L3Ri9C80Lgg0L7RgdGP0LzQuCDRiNGA0LjRhNGC0L7QslxuICogLSDQk9C10L3QtdGA0LDRhtC40Y4gQ1NTINC00LvRjyDRiNGA0LjRhNGC0L7QslxuICogLSDQo9C00LDQu9C10L3QuNC1INGI0YDQuNGE0YLQvtCyINC4INC+0YfQuNGB0YLQutGDINGA0LXRgdGD0YDRgdC+0LJcbiAqIC0g0KHQvtC30LTQsNC90LjQtSDRgdGC0LDRgtC40YfQtdGB0LrQuNGFINCy0LXRgNGB0LjQuSDQstCw0YDQuNCw0YLQuNCy0L3Ri9GFINGI0YDQuNGE0YLQvtCyXG4gKiBcbiAqIEBleGFtcGxlXG4gKiAvLyDQmNGB0L/QvtC70YzQt9C+0LLQsNC90LjQtSDRhdGD0LrQsCDQsiDQutC+0LzQv9C+0L3QtdC90YLQtVxuICogY29uc3Qge1xuICogICBmb250cywgXG4gKiAgIHNlbGVjdGVkRm9udCwgXG4gKiAgIGhhbmRsZUZvbnRzVXBsb2FkZWQsIFxuICogICBnZXRGb250RmFtaWx5LCBcbiAqICAgZ2V0VmFyaWF0aW9uU2V0dGluZ3MgXG4gKiB9ID0gdXNlRm9udE1hbmFnZXIoKTtcbiAqIFxuICogQHJldHVybnMge09iamVjdH0g0J7QsdGK0LXQutGCINGBINGB0L7RgdGC0L7Rj9C90LjQtdC8INC4INC80LXRgtC+0LTQsNC80Lgg0LTQu9GPINGA0LDQsdC+0YLRiyDRgdC+INGI0YDQuNGE0YLQsNC80LhcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHVzZUZvbnRNYW5hZ2VyKCkge1xuICBjb25zdCBbZm9udHMsIHNldEZvbnRzXSA9IHVzZVN0YXRlKFtdKTtcbiAgY29uc3QgW3NlbGVjdGVkRm9udCwgc2V0U2VsZWN0ZWRGb250XSA9IHVzZVN0YXRlKG51bGwpO1xuICBjb25zdCBbdmFyaWFibGVTZXR0aW5ncywgc2V0VmFyaWFibGVTZXR0aW5nc10gPSB1c2VTdGF0ZSh7fSk7XG4gIGNvbnN0IFtleHBvcnRlZEZvbnQsIHNldEV4cG9ydGVkRm9udF0gPSB1c2VTdGF0ZShudWxsKTtcbiAgY29uc3QgW2lzTG9hZGluZywgc2V0SXNMb2FkaW5nXSA9IHVzZVN0YXRlKGZhbHNlKTtcbiAgLy8g0KDQtdGE0LXRgNC10L3RgSDQtNC70Y8g0L7RgtGB0LvQtdC20LjQstCw0L3QuNGPINC/0L7RgdC70LXQtNC90LXQs9C+INC/0YDQvtCw0L3QsNC70LjQt9C40YDQvtCy0LDQvdC90L7Qs9C+INGI0YDQuNGE0YLQsFxuICBjb25zdCBsb2FkZWRGb250SWQgPSB1c2VSZWYobnVsbCk7XG4gIC8vIDw8PCDQpNC70LDQsyDQtNC70Y8g0L7RgtGB0LvQtdC20LjQstCw0L3QuNGPINC90LDRh9Cw0LvRjNC90L7QuSDQt9Cw0LPRgNGD0LfQutC4ID4+PlxuICBjb25zdCBbaXNJbml0aWFsTG9hZENvbXBsZXRlLCBzZXRJc0luaXRpYWxMb2FkQ29tcGxldGVdID0gdXNlU3RhdGUoZmFsc2UpO1xuICBcbiAgLy8g0KHQvtC30LTQsNC10LwgcmVmINC00LvRjyBzYWZlU2VsZWN0Rm9udCwg0YfRgtC+0LHRiyDQuNGB0L/QvtC70YzQt9C+0LLQsNGC0Ywg0LIg0LrQvtC70LHRjdC60LDRhVxuICBjb25zdCBzYWZlU2VsZWN0Rm9udFJlZiA9IHVzZVJlZihudWxsKTtcbiAgXG4gIC8vIDw8PCDQktGL0LfQvtCyINGF0YPQutCwINC30LDQs9GA0YPQt9C60Lgg0YjRgNC40YTRgtC+0LIgKNC+0LHQvdC+0LLQu9GP0LXQvCDQutC+0LvQu9Cx0Y3QuikgPj4+XG4gIGNvbnN0IHsgaGFuZGxlTG9jYWxGb250c1VwbG9hZCwgbG9hZEFuZFNlbGVjdEZvbnRzb3VyY2VGb250LCBsb2FkRm9udHNvdXJjZVN0eWxlVmFyaWFudCB9ID0gdXNlRm9udExvYWRlcihcbiAgICBzZXRGb250cyxcbiAgICBzZXRJc0xvYWRpbmcsXG4gICAgdXNlQ2FsbGJhY2soKGZvbnQpID0+IHNhZmVTZWxlY3RGb250UmVmLmN1cnJlbnQ/Lihmb250KSwgW10pLFxuICAgIGZvbnRzXG4gICk7XG4gIFxuICAvLyDQodC+0LfQtNCw0LXQvCByZWYg0LTQu9GPIHNhdmVGb250U2V0dGluZ3MsINGH0YLQvtCx0Ysg0LjRgdC/0L7Qu9GM0LfQvtCy0LDRgtGMINCyINC60L7Qu9Cx0Y3QutC1INC00L4g0LXQs9C+INC+0LHRitGP0LLQu9C10L3QuNGPXG4gIGNvbnN0IHNhdmVGb250U2V0dGluZ3NSZWYgPSB1c2VSZWYobnVsbCk7XG4gIFxuICAvLyDQodC+0LfQtNCw0LXQvCByZWYg0LTQu9GPIHNhdmVMYXN0VmFyaWFibGVTZXR0aW5ncywg0YfRgtC+0LHRiyDQuNGB0L/QvtC70YzQt9C+0LLQsNGC0Ywg0LTQviDQtdCz0L4g0L7QsdGK0Y/QstC70LXQvdC40Y9cbiAgY29uc3Qgc2F2ZUxhc3RWYXJpYWJsZVNldHRpbmdzUmVmID0gdXNlUmVmKG51bGwpO1xuICBcbiAgLy8gPDw8INCS0YvQt9C+0LIg0YXRg9C60LAg0YPQv9GA0LDQstC70LXQvdC40Y8g0LLQsNGA0LjQsNGC0LjQstC90YvQvNC4INGI0YDQuNGE0YLQsNC80LggPj4+XG4gIGNvbnN0IHtcbiAgICAgIGFwcGx5VmFyaWFibGVTZXR0aW5ncyxcbiAgICAgIGdldERlZmF1bHRBeGlzVmFsdWVzLFxuICAgICAgcmVzZXRWYXJpYWJsZVNldHRpbmdzLFxuICAgICAgZ2V0VmFyaWFibGVBeGVzSW5mbyxcbiAgfSA9IHVzZVZhcmlhYmxlRm9udENvbnRyb2xzKFxuICAgICAgc2VsZWN0ZWRGb250LFxuICAgICAgdmFyaWFibGVTZXR0aW5ncyxcbiAgICAgIHNldFZhcmlhYmxlU2V0dGluZ3MsXG4gICAgICBzZXRTZWxlY3RlZEZvbnQsXG4gICAgICBzZXRGb250cyxcbiAgICAgIGRlYm91bmNlZFVwZGF0ZVZhcmlhYmxlRm9udFNldHRpbmdzLCAvLyDQn9C10YDQtdC00LDQtdC8INGE0YPQvdC60YbQuNGOINC+0LHQvdC+0LLQu9C10L3QuNGPIENTU1xuICAgICAgdXNlQ2FsbGJhY2soKHNldHRpbmdzKSA9PiB7XG4gICAgICAgIGNvbnNvbGUubG9nKCdbRm9udE1hbmFnZXJdIENhbGxiYWNrINCy0YvQt9Cy0LDQvSDQtNC70Y8g0YHQvtGF0YDQsNC90LXQvdC40Y8g0L3QsNGB0YLRgNC+0LXQujonLCBzZXR0aW5ncywgJ3JlZiDQtNC+0YHRgtGD0L/QtdC9OicsICEhc2F2ZUxhc3RWYXJpYWJsZVNldHRpbmdzUmVmLmN1cnJlbnQpO1xuICAgICAgICByZXR1cm4gc2F2ZUxhc3RWYXJpYWJsZVNldHRpbmdzUmVmLmN1cnJlbnQ/LihzZXR0aW5ncyk7XG4gICAgICB9LCBbXSkgLy8g0J/QtdGA0LXQtNCw0LXQvCByZWYg0YfQtdGA0LXQtyBjYWxsYmFja1xuICApO1xuXG4gIC8vINCa0L7Qu9Cx0Y3QuiDQtNC70Y8g0YHQvtGF0YDQsNC90LXQvdC40Y8g0L3QsNGB0YLRgNC+0LXQuiDQv9GA0LXRgdC10YLQsCDQsiBJbmRleGVkREJcbiAgY29uc3QgaGFuZGxlUHJlc2V0QXBwbGllZCA9IHVzZUNhbGxiYWNrKChmb250SWQsIHNldHRpbmdzKSA9PiB7XG4gICAgaWYgKHNhdmVGb250U2V0dGluZ3NSZWYuY3VycmVudCkge1xuICAgICAgc2F2ZUZvbnRTZXR0aW5nc1JlZi5jdXJyZW50KGZvbnRJZCwgc2V0dGluZ3MpO1xuICAgIH1cbiAgfSwgW10pO1xuXG4gIC8vIDw8PCDQktGL0LfQvtCyINGF0YPQutCwINGD0L/RgNCw0LLQu9C10L3QuNGPINGB0YLQuNC70Y/QvNC4ID4+PlxuICBjb25zdCB7XG4gICAgICBhcHBseVByZXNldFN0eWxlIC8vINCf0L7Qu9GD0YfQsNC10Lwg0YTRg9C90LrRhtC40Y4g0LjQtyDQvdC+0LLQvtCz0L4g0YXRg9C60LBcbiAgfSA9IHVzZUZvbnRTdHlsZU1hbmFnZXIoXG4gICAgICBzZWxlY3RlZEZvbnQsXG4gICAgICBzZXRTZWxlY3RlZEZvbnQsXG4gICAgICBzZXRGb250cyxcbiAgICAgIHZhcmlhYmxlU2V0dGluZ3MsXG4gICAgICBhcHBseVZhcmlhYmxlU2V0dGluZ3MsIC8vINCf0LXRgNC10LTQsNC10Lwg0YTRg9C90LrRhtC40Y4g0LjQtyB1c2VWYXJpYWJsZUZvbnRDb250cm9sc1xuICAgICAgbG9hZEZvbnRzb3VyY2VTdHlsZVZhcmlhbnQsIC8vINCf0LXRgNC10LTQsNC10Lwg0YTRg9C90LrRhtC40Y4g0LjQtyB1c2VGb250TG9hZGVyXG4gICAgICBoYW5kbGVQcmVzZXRBcHBsaWVkIC8vINCf0LXRgNC10LTQsNC10Lwg0LrQvtC70LHRjdC6INC00LvRjyDRgdC+0YXRgNCw0L3QtdC90LjRjyDQsiBJbmRleGVkREJcbiAgKTtcblxuICAvLyA8PDwg0JLRi9C30L7QsiDRhdGD0LrQsCDQv9C10YDRgdC40YHRgtC10L3RgtC90L7RgdGC0LggKNCf0J7QodCb0JUg0L7QsdGK0Y/QstC70LXQvdC40Y8gYXBwbHlWYXJpYWJsZVNldHRpbmdzINC4IGFwcGx5UHJlc2V0U3R5bGUpID4+PlxuICBjb25zdCB7XG4gICAgc2F2ZVNlbGVjdGVkRm9udElkLFxuICAgIHNhdmVMYXN0VmFyaWFibGVTZXR0aW5ncyxcbiAgICBzYXZlTGFzdFByZXNldE5hbWUsXG4gICAgY2xlYXJGb250TG9jYWxTdG9yYWdlLFxuICAgIHJlc2V0UGVyc2lzdGVuY2UsXG4gICAgc2F2ZUZvbnRTZXR0aW5nc1xuICB9ID0gdXNlRm9udFBlcnNpc3RlbmNlKFxuICAgIHNldEZvbnRzLFxuICAgIHNldElzTG9hZGluZyxcbiAgICBzZXRJc0luaXRpYWxMb2FkQ29tcGxldGUsXG4gICAgc2V0U2VsZWN0ZWRGb250LFxuICAgIGFwcGx5VmFyaWFibGVTZXR0aW5ncyxcbiAgICBhcHBseVByZXNldFN0eWxlLFxuICAgIGZvbnRzLFxuICAgIHNlbGVjdGVkRm9udFxuICApO1xuXG4gIC8vINCj0YHRgtCw0L3QsNCy0LvQuNCy0LDQtdC8IHNhdmVGb250U2V0dGluZ3Mg0LIgcmVmINC00LvRjyDQuNGB0L/QvtC70YzQt9C+0LLQsNC90LjRjyDQsiBoYW5kbGVQcmVzZXRBcHBsaWVkXG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgc2F2ZUZvbnRTZXR0aW5nc1JlZi5jdXJyZW50ID0gc2F2ZUZvbnRTZXR0aW5ncztcbiAgfSwgW3NhdmVGb250U2V0dGluZ3NdKTtcblxuICAvLyDQo9GB0YLQsNC90LDQstC70LjQstCw0LXQvCBzYXZlTGFzdFZhcmlhYmxlU2V0dGluZ3Mg0LIgcmVmINC00LvRjyDQuNGB0L/QvtC70YzQt9C+0LLQsNC90LjRjyDQsiB1c2VWYXJpYWJsZUZvbnRDb250cm9sc1xuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGNvbnNvbGUubG9nKCdbRm9udE1hbmFnZXJdINCe0LHQvdC+0LLQu9GP0LXQvCBzYXZlTGFzdFZhcmlhYmxlU2V0dGluZ3NSZWY6JywgdHlwZW9mIHNhdmVMYXN0VmFyaWFibGVTZXR0aW5ncyk7XG4gICAgc2F2ZUxhc3RWYXJpYWJsZVNldHRpbmdzUmVmLmN1cnJlbnQgPSBzYXZlTGFzdFZhcmlhYmxlU2V0dGluZ3M7XG4gIH0sIFtzYXZlTGFzdFZhcmlhYmxlU2V0dGluZ3NdKTtcblxuICAvLyA8PDwg0J/RgNC+0LjQt9Cy0L7QtNC90YvQtSDRgdC+0YHRgtC+0Y/QvdC40Y8gPj4+XG4gIGNvbnN0IGlzU2VsZWN0ZWRGb250VmFyaWFibGUgPSB1c2VNZW1vKCgpID0+IHNlbGVjdGVkRm9udD8uaXNWYXJpYWJsZUZvbnQgfHwgZmFsc2UsIFtzZWxlY3RlZEZvbnRdKTtcblxuICAvLyA8PDwg0JLRi9C30L7QsiDRhdGD0LrQsCDRg9C/0YDQsNCy0LvQtdC90LjRjyBDU1MgPj4+XG4gIGNvbnN0IHtcbiAgICAgIGdldEZvbnRGYW1pbHksXG4gICAgICBnZXRWYXJpYXRpb25TZXR0aW5ncyxcbiAgICAgIGdlbmVyYXRlQ1NTLFxuICAgICAgbG9hZEZvbnRGYWNlLFxuICAgICAgdXBkYXRlVmFyaWFibGVGb250Q3NzLFxuICAgICAgZGVib3VuY2VkVXBkYXRlVmFyaWFibGVGb250Q3NzLFxuICAgICAgZXhwb3J0VG9DU1M6IGV4cG9ydFRvQ1NTRnJvbUhvb2ssXG4gICAgICBmb250Q3NzUHJvcGVydGllc1xuICB9ID0gdXNlRm9udENzcyhzZWxlY3RlZEZvbnQsIHZhcmlhYmxlU2V0dGluZ3MsIGlzU2VsZWN0ZWRGb250VmFyaWFibGUpO1xuXG4gIC8vIDw8PCDQktGL0LfQvtCyINGF0YPQutCwINGN0LrRgdC/0L7RgNGC0LAgPj4+XG4gIGNvbnN0IHtcbiAgICAgIGRvd25sb2FkRmlsZSxcbiAgICAgIGV4cG9ydFRvQ1NTOiBleHBvcnRUb0NTU0Zyb21FeHBvcnRIb29rLFxuICAgICAgY3JlYXRlU3RhdGljRm9udDogY3JlYXRlU3RhdGljRm9udEZyb21FeHBvcnRIb29rLFxuICAgICAgZ2VuZXJhdGVTdGF0aWNGb250RmlsZSxcbiAgICAgIGRvd25sb2FkU3RhdGljRm9udFxuICB9ID0gdXNlRm9udEV4cG9ydChleHBvcnRUb0NTU0Zyb21Ib29rKTtcblxuICAvKipcbiAgICog0JHQtdC30L7Qv9Cw0YHQvdC+INCy0YvQsdC40YDQsNC10YIg0YjRgNC40YTRgiDQuCDQv9GA0LjQvNC10L3Rj9C10YIg0Log0L3QtdC80YMg0LHQsNC30L7QstGL0LUg0L3QsNGB0YLRgNC+0LnQutC4XG4gICAqIEBwYXJhbSB7T2JqZWN0fSBmb250IC0g0J7QsdGK0LXQutGCINGI0YDQuNGE0YLQsCDQtNC70Y8g0LLRi9Cx0L7RgNCwXG4gICAqL1xuICBjb25zdCBzYWZlU2VsZWN0Rm9udCA9IHVzZUNhbGxiYWNrKChmb250KSA9PiB7XG4gICAgaWYgKCFmb250KSB7XG4gICAgICBjb25zb2xlLndhcm4oJ1tzYWZlU2VsZWN0Rm9udF0g0J/QvtC/0YvRgtC60LAg0LLRi9Cx0YDQsNGC0YwgbnVsbC91bmRlZmluZWQg0YjRgNC40YTRgicpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBcbiAgICBjb25zb2xlLmxvZyhgW3NhZmVTZWxlY3RGb250XSDQktGL0LHQuNGA0LDQtdC8INGI0YDQuNGE0YI6ICR7Zm9udC5uYW1lIHx8IGZvbnQuZGlzcGxheU5hbWV9YCk7XG4gICAgXG4gICAgLy8g0KPRgdGC0LDQvdCw0LLQu9C40LLQsNC10Lwg0LLRi9Cx0YDQsNC90L3Ri9C5INGI0YDQuNGE0YJcbiAgICBzZXRTZWxlY3RlZEZvbnQoZm9udCk7XG4gICAgXG4gICAgLy8g0J/RgNC+0LLQtdGA0Y/QtdC8LCDQtdGB0YLRjCDQu9C4INGB0L7RhdGA0LDQvdC10L3QvdGL0LUg0L3QsNGB0YLRgNC+0LnQutC4INC00LvRjyDRjdGC0L7Qs9C+INGI0YDQuNGE0YLQsFxuICAgIGxldCBzZXR0aW5nc0FwcGxpZWQgPSBmYWxzZTtcbiAgICBcbiAgICAvLyDQn9GA0LjQvtGA0LjRgtC10YIgMTog0KHQvtGF0YDQsNC90LXQvdC90YvQtSDQvdCw0YHRgtGA0L7QudC60Lgg0L7RgdC10Lkg0LTQu9GPINCy0LDRgNC40LDRgtC40LLQvdC+0LPQviDRiNGA0LjRhNGC0LBcbiAgICBpZiAoZm9udC5pc1ZhcmlhYmxlRm9udCAmJiBmb250Lmxhc3RVc2VkVmFyaWFibGVTZXR0aW5ncykge1xuICAgICAgY29uc29sZS5sb2coJ1tzYWZlU2VsZWN0Rm9udF0g0JLQvtGB0YHRgtCw0L3QsNCy0LvQuNCy0LDQtdC8INGB0L7RhdGA0LDQvdC10L3QvdGL0LUg0L7RgdC4OicsIGZvbnQubGFzdFVzZWRWYXJpYWJsZVNldHRpbmdzKTtcbiAgICAgIHNldFZhcmlhYmxlU2V0dGluZ3MoZm9udC5sYXN0VXNlZFZhcmlhYmxlU2V0dGluZ3MpO1xuICAgICAgLy8g0J/RgNC40LzQtdC90Y/QtdC8INC90LDRgdGC0YDQvtC50LrQuCDRh9C10YDQtdC3IHNldFRpbWVvdXQg0LTQu9GPINC60L7RgNGA0LXQutGC0L3QvtC5INGA0LDQsdC+0YLRi1xuICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgIGlmIChhcHBseVZhcmlhYmxlU2V0dGluZ3MpIHtcbiAgICAgICAgICBhcHBseVZhcmlhYmxlU2V0dGluZ3MoZm9udC5sYXN0VXNlZFZhcmlhYmxlU2V0dGluZ3MsIHRydWUsIGZvbnQpO1xuICAgICAgICB9XG4gICAgICB9LCAwKTtcbiAgICAgIHNldHRpbmdzQXBwbGllZCA9IHRydWU7XG4gICAgfVxuICAgIC8vINCf0YDQuNC+0YDQuNGC0LXRgiAyOiDQodC+0YXRgNCw0L3QtdC90L3Ri9C5INC/0YDQtdGB0LXRglxuICAgIGVsc2UgaWYgKGZvbnQubGFzdFVzZWRQcmVzZXROYW1lICYmIGFwcGx5UHJlc2V0U3R5bGUpIHtcbiAgICAgIGNvbnNvbGUubG9nKCdbc2FmZVNlbGVjdEZvbnRdINCS0L7RgdGB0YLQsNC90LDQstC70LjQstCw0LXQvCDRgdC+0YXRgNCw0L3QtdC90L3Ri9C5INC/0YDQtdGB0LXRgjonLCBmb250Lmxhc3RVc2VkUHJlc2V0TmFtZSk7XG4gICAgICAvLyDQo9Cx0LjRgNCw0LXQvCBzZXRUaW1lb3V0IC0g0LLRi9C/0L7Qu9C90Y/QtdC8INGB0LjQvdGF0YDQvtC90L3Qviwg0YfRgtC+0LHRiyBjdXJyZW50V2VpZ2h0L2N1cnJlbnRTdHlsZSDQvtCx0L3QvtCy0LjQu9C40YHRjFxuICAgICAgYXBwbHlQcmVzZXRTdHlsZShmb250Lmxhc3RVc2VkUHJlc2V0TmFtZSwgZm9udCk7XG4gICAgICBzZXR0aW5nc0FwcGxpZWQgPSB0cnVlO1xuICAgIH1cbiAgICBcbiAgICAvLyDQldGB0LvQuCDQvdCw0YHRgtGA0L7QudC60Lgg0L3QtSDQsdGL0LvQuCDQstC+0YHRgdGC0LDQvdC+0LLQu9C10L3Riywg0L/RgNC40LzQtdC90Y/QtdC8INC00LXRhNC+0LvRgtC90YvQtVxuICAgIGlmICghc2V0dGluZ3NBcHBsaWVkKSB7XG4gICAgICBpZiAoZm9udC5pc1ZhcmlhYmxlRm9udCAmJiBmb250LnZhcmlhYmxlQXhlcykge1xuICAgICAgICAvLyDQn9C+0LvRg9GH0LDQtdC8INC00LXRhNC+0LvRgtC90YvQtSDQt9C90LDRh9C10L3QuNGPINC40Lcg0YXRg9C60LBcbiAgICAgICAgY29uc3QgZGVmYXVsdEF4ZXMgPSBnZXREZWZhdWx0QXhpc1ZhbHVlcz8uKGZvbnQpIHx8IHt9O1xuICAgICAgICBjb25zb2xlLmxvZygnW3NhZmVTZWxlY3RGb250XSDQn9GA0LjQvNC10L3Rj9C10Lwg0LTQtdGE0L7Qu9GC0L3Ri9C1INC+0YHQuCDQtNC70Y8g0LLQsNGA0LjQsNGC0LjQstC90L7Qs9C+INGI0YDQuNGE0YLQsDonLCBkZWZhdWx0QXhlcyk7XG4gICAgICAgIHNldFZhcmlhYmxlU2V0dGluZ3MoZGVmYXVsdEF4ZXMpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8g0JTQu9GPINGB0YLQsNGC0LjRh9C10YHQutC40YUg0YjRgNC40YTRgtC+0LIg0L7Rh9C40YnQsNC10Lwg0L3QsNGB0YLRgNC+0LnQutC4INC+0YHQtdC5XG4gICAgICAgIHNldFZhcmlhYmxlU2V0dGluZ3Moe30pO1xuICAgICAgfVxuICAgICAgXG4gICAgICAvLyDQn9GA0LjQvNC10L3Rj9C10Lwg0LHQsNC30L7QstGL0Lkg0YHRgtC40LvRjCBSZWd1bGFyXG4gICAgICBpZiAoYXBwbHlQcmVzZXRTdHlsZSkge1xuICAgICAgICAvLyDQo9Cx0LjRgNCw0LXQvCBzZXRUaW1lb3V0IC0g0LLRi9C/0L7Qu9C90Y/QtdC8INGB0LjQvdGF0YDQvtC90L3QvlxuICAgICAgICBhcHBseVByZXNldFN0eWxlKCdSZWd1bGFyJywgZm9udCk7XG4gICAgICB9XG4gICAgfVxuICB9LCBbc2V0U2VsZWN0ZWRGb250LCBzZXRWYXJpYWJsZVNldHRpbmdzLCBnZXREZWZhdWx0QXhpc1ZhbHVlcywgYXBwbHlQcmVzZXRTdHlsZSwgYXBwbHlWYXJpYWJsZVNldHRpbmdzXSk7XG4gIFxuICAvLyDQodC+0YXRgNCw0L3Rj9C10Lwg0YHRgdGL0LvQutGDINC90LAg0YTRg9C90LrRhtC40Y4g0LTQu9GPINC40YHQv9C+0LvRjNC30L7QstCw0L3QuNGPINCyINC60L7Qu9Cx0Y3QutCw0YVcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBzYWZlU2VsZWN0Rm9udFJlZi5jdXJyZW50ID0gc2FmZVNlbGVjdEZvbnQ7XG4gIH0sIFtzYWZlU2VsZWN0Rm9udF0pO1xuXG4gIC8vINCc0LXQvNC+0LjQt9C40YDQvtCy0LDQvdC90L7QtSDQuNC80Y8g0LLRi9Cx0YDQsNC90L3QvtCz0L4g0L/RgNC10YHQtdGC0LAgKNC90YPQttC90L4g0L7Qv9GA0LXQtNC10LvQuNGC0Ywg0LTQviB1c2VFZmZlY3QpXG4gIGNvbnN0IHNlbGVjdGVkUHJlc2V0TmFtZSA9IHVzZU1lbW8oKCkgPT4ge1xuICAgICAgaWYgKCFzZWxlY3RlZEZvbnQpIHJldHVybiAnUmVndWxhcic7IC8vINCf0L4g0YPQvNC+0LvRh9Cw0L3QuNGOXG4gICAgICBcbiAgICAgIGNvbnNvbGUubG9nKGBbc2VsZWN0ZWRQcmVzZXROYW1lXSDQktGL0YfQuNGB0LvRj9C10Lwg0LTQu9GPINGI0YDQuNGE0YLQsDogJHtzZWxlY3RlZEZvbnQubmFtZX1gLCB7XG4gICAgICAgIGxhc3RVc2VkUHJlc2V0TmFtZTogc2VsZWN0ZWRGb250Lmxhc3RVc2VkUHJlc2V0TmFtZSxcbiAgICAgICAgY3VycmVudFdlaWdodDogc2VsZWN0ZWRGb250LmN1cnJlbnRXZWlnaHQsXG4gICAgICAgIGN1cnJlbnRTdHlsZTogc2VsZWN0ZWRGb250LmN1cnJlbnRTdHlsZSxcbiAgICAgICAgaXNWYXJpYWJsZUZvbnQ6IHNlbGVjdGVkRm9udC5pc1ZhcmlhYmxlRm9udCxcbiAgICAgICAgdmFyaWFibGVTZXR0aW5nczogdmFyaWFibGVTZXR0aW5nc1xuICAgICAgfSk7XG4gICAgICBcbiAgICAgIC8vINCf0YDQuNC+0YDQuNGC0LXRgiAxOiDQlNC70Y8g0YHRgtCw0YLQuNGH0LXRgdC60LjRhSDRiNGA0LjRhNGC0L7QsiDQuNGB0L/QvtC70YzQt9GD0LXQvCBjdXJyZW50V2VpZ2h0L2N1cnJlbnRTdHlsZVxuICAgICAgaWYgKCFzZWxlY3RlZEZvbnQuaXNWYXJpYWJsZUZvbnQpIHtcbiAgICAgICAgLy8g0KHQvdCw0YfQsNC70LAg0L/Ri9GC0LDQtdC80YHRjyDQvtC/0YDQtdC00LXQu9C40YLRjCDQv9C+INGC0LXQutGD0YnQtdC80YMg0LLQtdGB0YMg0Lgg0YHRgtC40LvRjlxuICAgICAgICBpZiAoc2VsZWN0ZWRGb250LmN1cnJlbnRXZWlnaHQgIT09IHVuZGVmaW5lZCAmJiBzZWxlY3RlZEZvbnQuY3VycmVudFN0eWxlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBjb25zdCBzdHlsZUluZm8gPSBmaW5kU3R5bGVJbmZvQnlXZWlnaHRBbmRTdHlsZShcbiAgICAgICAgICAgICAgc2VsZWN0ZWRGb250LmN1cnJlbnRXZWlnaHQsIFxuICAgICAgICAgICAgICBzZWxlY3RlZEZvbnQuY3VycmVudFN0eWxlXG4gICAgICAgICAgKTtcbiAgICAgICAgICBjb25zdCBwcmVzZXROYW1lID0gc3R5bGVJbmZvPy5uYW1lIHx8ICdSZWd1bGFyJztcbiAgICAgICAgICBjb25zb2xlLmxvZyhgW3NlbGVjdGVkUHJlc2V0TmFtZV0g0KHRgtCw0YLQuNGH0LXRgdC60LjQuSDRiNGA0LjRhNGCINC/0L4g0YLQtdC60YPRidC10LzRgyDQstC10YHRgy/RgdGC0LjQu9GOOiAke3ByZXNldE5hbWV9ICgke3NlbGVjdGVkRm9udC5jdXJyZW50V2VpZ2h0fSwgJHtzZWxlY3RlZEZvbnQuY3VycmVudFN0eWxlfSlgKTtcbiAgICAgICAgICByZXR1cm4gcHJlc2V0TmFtZTtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgLy8g0JXRgdC70LggY3VycmVudFdlaWdodC9jdXJyZW50U3R5bGUg0L3QtSDRg9GB0YLQsNC90L7QstC70LXQvdGLLCDQuNGB0L/QvtC70YzQt9GD0LXQvCDRgdC+0YXRgNCw0L3QtdC90L3Ri9C5INC/0YDQtdGB0LXRglxuICAgICAgICBpZiAoc2VsZWN0ZWRGb250Lmxhc3RVc2VkUHJlc2V0TmFtZSkge1xuICAgICAgICAgIGNvbnNvbGUubG9nKGBbc2VsZWN0ZWRQcmVzZXROYW1lXSDQodGC0LDRgtC40YfQtdGB0LrQuNC5INGI0YDQuNGE0YIg0YEg0YHQvtGF0YDQsNC90LXQvdC90YvQvCDQv9GA0LXRgdC10YLQvtC8OiAke3NlbGVjdGVkRm9udC5sYXN0VXNlZFByZXNldE5hbWV9YCk7XG4gICAgICAgICAgcmV0dXJuIHNlbGVjdGVkRm9udC5sYXN0VXNlZFByZXNldE5hbWU7XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIC8vINCf0L4g0YPQvNC+0LvRh9Cw0L3QuNGOXG4gICAgICAgIGNvbnNvbGUubG9nKGBbc2VsZWN0ZWRQcmVzZXROYW1lXSDQodGC0LDRgtC40YfQtdGB0LrQuNC5INGI0YDQuNGE0YIg0L/QviDRg9C80L7Qu9GH0LDQvdC40Y46IFJlZ3VsYXJgKTtcbiAgICAgICAgcmV0dXJuICdSZWd1bGFyJztcbiAgICAgIH1cbiAgICAgIFxuICAgICAgLy8g0J/RgNC40L7RgNC40YLQtdGCIDI6INCU0LvRjyDQstCw0YDQuNCw0YLQuNCy0L3Ri9GFINGI0YDQuNGE0YLQvtCyINGBINC90LDRgdGC0YDQvtC50LrQsNC80Lgg0L7RgdC10LksINC+0L/RgNC10LTQtdC70Y/QtdC8INC/0YDQtdGB0LXRgiDQv9C+INC+0YHRj9C8XG4gICAgICBpZiAoc2VsZWN0ZWRGb250LmlzVmFyaWFibGVGb250ICYmIHZhcmlhYmxlU2V0dGluZ3MgJiYgT2JqZWN0LmtleXModmFyaWFibGVTZXR0aW5ncykubGVuZ3RoID4gMCkge1xuICAgICAgICAvLyDQn9GL0YLQsNC10LzRgdGPINC90LDQudGC0Lgg0L/RgNC10YHQtdGCLCDQutC+0YLQvtGA0YvQuSDRgdC+0L7RgtCy0LXRgtGB0YLQstGD0LXRgiDRgtC10LrRg9GJ0LjQvCDQvdCw0YHRgtGA0L7QudC60LDQvCDQvtGB0LXQuVxuICAgICAgICBjb25zdCBjdXJyZW50V2VpZ2h0ID0gdmFyaWFibGVTZXR0aW5ncy53Z2h0IHx8IDQwMDtcbiAgICAgICAgY29uc3QgY3VycmVudFN0eWxlID0gKHZhcmlhYmxlU2V0dGluZ3MuaXRhbCA9PT0gMSB8fCAodmFyaWFibGVTZXR0aW5ncy5zbG50ICYmIHZhcmlhYmxlU2V0dGluZ3Muc2xudCA8IDApKSA/ICdpdGFsaWMnIDogJ25vcm1hbCc7XG4gICAgICAgIFxuICAgICAgICBjb25zdCBtYXRjaGVkUHJlc2V0ID0gZmluZFN0eWxlSW5mb0J5V2VpZ2h0QW5kU3R5bGUoY3VycmVudFdlaWdodCwgY3VycmVudFN0eWxlKTtcbiAgICAgICAgaWYgKG1hdGNoZWRQcmVzZXQpIHtcbiAgICAgICAgICBjb25zb2xlLmxvZyhgW3NlbGVjdGVkUHJlc2V0TmFtZV0g0JLQsNGA0LjQsNGC0LjQstC90YvQuSDRiNGA0LjRhNGCINC/0L4g0L7RgdGP0Lw6ICR7bWF0Y2hlZFByZXNldC5uYW1lfWApO1xuICAgICAgICAgIHJldHVybiBtYXRjaGVkUHJlc2V0Lm5hbWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIFxuICAgICAgLy8g0J/RgNC40L7RgNC40YLQtdGCIDM6INCV0YHQu9C4INC10YHRgtGMINGB0L7RhdGA0LDQvdC10L3QvdGL0Lkg0L/RgNC10YHQtdGCLCDQuNGB0L/QvtC70YzQt9GD0LXQvCDQtdCz0L5cbiAgICAgIGlmIChzZWxlY3RlZEZvbnQubGFzdFVzZWRQcmVzZXROYW1lKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKGBbc2VsZWN0ZWRQcmVzZXROYW1lXSDQodC+0YXRgNCw0L3QtdC90L3Ri9C5INC/0YDQtdGB0LXRgjogJHtzZWxlY3RlZEZvbnQubGFzdFVzZWRQcmVzZXROYW1lfWApO1xuICAgICAgICByZXR1cm4gc2VsZWN0ZWRGb250Lmxhc3RVc2VkUHJlc2V0TmFtZTtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgLy8g0J/RgNC40L7RgNC40YLQtdGCIDQ6INCf0L4g0YPQvNC+0LvRh9Cw0L3QuNGOIFJlZ3VsYXJcbiAgICAgIGNvbnNvbGUubG9nKGBbc2VsZWN0ZWRQcmVzZXROYW1lXSDQn9C+INGD0LzQvtC70YfQsNC90LjRjjogUmVndWxhcmApO1xuICAgICAgcmV0dXJuICdSZWd1bGFyJztcbiAgfSwgW3NlbGVjdGVkRm9udCwgdmFyaWFibGVTZXR0aW5nc10pO1xuXG4gIC8vIDw8PCDQodC+0YXRgNCw0L3QtdC90LjQtSDQvdCw0YHRgtGA0L7QtdC6INC/0YDQuCDQv9C10YDQtdC60LvRjtGH0LXQvdC40Lgg0YjRgNC40YTRgtC+0LIgPj4+XG4gIGNvbnN0IHByZXZpb3VzU2VsZWN0ZWRGb250UmVmID0gdXNlUmVmKG51bGwpO1xuICBjb25zdCBwcmV2aW91c1ZhcmlhYmxlU2V0dGluZ3NSZWYgPSB1c2VSZWYoe30pO1xuICBjb25zdCBwcmV2aW91c1ByZXNldE5hbWVSZWYgPSB1c2VSZWYoJ1JlZ3VsYXInKTtcbiAgXG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgLy8g0JXRgdC70Lgg0LXRgdGC0Ywg0L/RgNC10LTRi9C00YPRidC40Lkg0YjRgNC40YTRgiDQuCDQvtC9INC+0YLQu9C40YfQsNC10YLRgdGPINC+0YIg0YLQtdC60YPRidC10LPQvlxuICAgIGlmIChwcmV2aW91c1NlbGVjdGVkRm9udFJlZi5jdXJyZW50ICYmIFxuICAgICAgICBwcmV2aW91c1NlbGVjdGVkRm9udFJlZi5jdXJyZW50LmlkICE9PSBzZWxlY3RlZEZvbnQ/LmlkKSB7XG4gICAgICBcbiAgICAgIGNvbnN0IHByZXZGb250ID0gcHJldmlvdXNTZWxlY3RlZEZvbnRSZWYuY3VycmVudDtcbiAgICAgIGNvbnN0IHByZXZWYXJpYWJsZVNldHRpbmdzID0gcHJldmlvdXNWYXJpYWJsZVNldHRpbmdzUmVmLmN1cnJlbnQ7XG4gICAgICBjb25zdCBwcmV2UHJlc2V0TmFtZSA9IHByZXZpb3VzUHJlc2V0TmFtZVJlZi5jdXJyZW50O1xuICAgICAgXG4gICAgICBjb25zb2xlLmxvZyhgW0ZvbnRTd2l0Y2hdINCh0L7RhdGA0LDQvdGP0LXQvCDQvdCw0YHRgtGA0L7QudC60Lgg0LTQu9GPINC/0YDQtdC00YvQtNGD0YnQtdCz0L4g0YjRgNC40YTRgtCwOiAke3ByZXZGb250Lm5hbWV9YCk7XG4gICAgICBcbiAgICAgIC8vINCh0L7RhdGA0LDQvdGP0LXQvCDQvdCw0YHRgtGA0L7QudC60Lgg0L/RgNC10LTRi9C00YPRidC10LPQviDRiNGA0LjRhNGC0LAg0LIg0LXQs9C+INC+0LHRitC10LrRgiAo0LTQu9GPINGB0LXRgdGB0LjQuClcbiAgICAgIGNvbnN0IHVwZGF0ZWRGb250cyA9IGZvbnRzLm1hcChmb250ID0+IHtcbiAgICAgICAgaWYgKGZvbnQuaWQgPT09IHByZXZGb250LmlkKSB7XG4gICAgICAgICAgY29uc3QgdXBkYXRlZEZvbnQgPSB7IC4uLmZvbnQgfTtcbiAgICAgICAgICBsZXQgZGJVcGRhdGVzID0ge307IC8vINCe0LHRitC10LrRgiDQtNC70Y8g0L7QsdC90L7QstC70LXQvdC40Y8g0LIgSW5kZXhlZERCXG4gICAgICAgICAgXG4gICAgICAgICAgLy8g0KHQvtGF0YDQsNC90Y/QtdC8INC90LDRgdGC0YDQvtC50LrQuCDQsiDQt9Cw0LLQuNGB0LjQvNC+0YHRgtC4INC+0YIg0YLQuNC/0LAg0J/QoNCV0JTQq9CU0KPQqdCV0JPQniDRiNGA0LjRhNGC0LBcbiAgICAgICAgICBpZiAocHJldkZvbnQuaXNWYXJpYWJsZUZvbnQgJiYgT2JqZWN0LmtleXMocHJldlZhcmlhYmxlU2V0dGluZ3MpLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIHVwZGF0ZWRGb250Lmxhc3RVc2VkVmFyaWFibGVTZXR0aW5ncyA9IHsgLi4ucHJldlZhcmlhYmxlU2V0dGluZ3MgfTtcbiAgICAgICAgICAgIHVwZGF0ZWRGb250Lmxhc3RVc2VkUHJlc2V0TmFtZSA9IG51bGw7IC8vINCe0YfQuNGJ0LDQtdC8INC/0YDQtdGB0LXRgiwg0LXRgdC70Lgg0LXRgdGC0Ywg0L7RgdC4XG4gICAgICAgICAgICBkYlVwZGF0ZXMubGFzdFVzZWRWYXJpYWJsZVNldHRpbmdzID0geyAuLi5wcmV2VmFyaWFibGVTZXR0aW5ncyB9O1xuICAgICAgICAgICAgZGJVcGRhdGVzLmxhc3RVc2VkUHJlc2V0TmFtZSA9IG51bGw7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhgW0ZvbnRTd2l0Y2hdINCh0L7RhdGA0LDQvdC10L3RiyDQvtGB0Lgg0LTQu9GPICR7cHJldkZvbnQubmFtZX06YCwgdXBkYXRlZEZvbnQubGFzdFVzZWRWYXJpYWJsZVNldHRpbmdzKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKHByZXZQcmVzZXROYW1lICYmIHByZXZQcmVzZXROYW1lICE9PSAnUmVndWxhcicpIHtcbiAgICAgICAgICAgIHVwZGF0ZWRGb250Lmxhc3RVc2VkUHJlc2V0TmFtZSA9IHByZXZQcmVzZXROYW1lO1xuICAgICAgICAgICAgdXBkYXRlZEZvbnQubGFzdFVzZWRWYXJpYWJsZVNldHRpbmdzID0gbnVsbDsgLy8g0J7Rh9C40YnQsNC10Lwg0L7RgdC4LCDQtdGB0LvQuCDQtdGB0YLRjCDQv9GA0LXRgdC10YJcbiAgICAgICAgICAgIGRiVXBkYXRlcy5sYXN0VXNlZFByZXNldE5hbWUgPSBwcmV2UHJlc2V0TmFtZTtcbiAgICAgICAgICAgIGRiVXBkYXRlcy5sYXN0VXNlZFZhcmlhYmxlU2V0dGluZ3MgPSBudWxsO1xuICAgICAgICAgICAgY29uc29sZS5sb2coYFtGb250U3dpdGNoXSDQodC+0YXRgNCw0L3QtdC9INC/0YDQtdGB0LXRgiDQtNC70Y8gJHtwcmV2Rm9udC5uYW1lfTpgLCB1cGRhdGVkRm9udC5sYXN0VXNlZFByZXNldE5hbWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBcbiAgICAgICAgICAvLyDQodC+0YXRgNCw0L3Rj9C10LwgY3VycmVudFdlaWdodCDQuCBjdXJyZW50U3R5bGUg0LXRgdC70Lgg0L7QvdC4INC10YHRgtGMXG4gICAgICAgICAgaWYgKHByZXZGb250LmN1cnJlbnRXZWlnaHQgIT09IHVuZGVmaW5lZCAmJiBwcmV2Rm9udC5jdXJyZW50U3R5bGUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdXBkYXRlZEZvbnQuY3VycmVudFdlaWdodCA9IHByZXZGb250LmN1cnJlbnRXZWlnaHQ7XG4gICAgICAgICAgICB1cGRhdGVkRm9udC5jdXJyZW50U3R5bGUgPSBwcmV2Rm9udC5jdXJyZW50U3R5bGU7XG4gICAgICAgICAgICBkYlVwZGF0ZXMuY3VycmVudFdlaWdodCA9IHByZXZGb250LmN1cnJlbnRXZWlnaHQ7XG4gICAgICAgICAgICBkYlVwZGF0ZXMuY3VycmVudFN0eWxlID0gcHJldkZvbnQuY3VycmVudFN0eWxlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBcbiAgICAgICAgICAvLyDQodC+0YXRgNCw0L3Rj9C10Lwg0LIgSW5kZXhlZERCINC10YHQu9C4INC10YHRgtGMINGH0YLQviDRgdC+0YXRgNCw0L3Rj9GC0YxcbiAgICAgICAgICBpZiAoT2JqZWN0LmtleXMoZGJVcGRhdGVzKS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBzYXZlRm9udFNldHRpbmdzKHByZXZGb250LmlkLCBkYlVwZGF0ZXMpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBcbiAgICAgICAgICByZXR1cm4gdXBkYXRlZEZvbnQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZvbnQ7XG4gICAgICB9KTtcbiAgICAgIFxuICAgICAgc2V0Rm9udHModXBkYXRlZEZvbnRzKTtcbiAgICAgIFxuICAgICAgLy8g0KLQsNC60LbQtSDRgdC+0YXRgNCw0L3Rj9C10Lwg0LIgbG9jYWxTdG9yYWdlICjQs9C70L7QsdCw0LvRjNC90YvQtSDQvdCw0YHRgtGA0L7QudC60LgpXG4gICAgICBpZiAocHJldkZvbnQuaXNWYXJpYWJsZUZvbnQgJiYgT2JqZWN0LmtleXMocHJldlZhcmlhYmxlU2V0dGluZ3MpLmxlbmd0aCA+IDApIHtcbiAgICAgICAgc2F2ZUxhc3RWYXJpYWJsZVNldHRpbmdzKHByZXZWYXJpYWJsZVNldHRpbmdzKTtcbiAgICAgIH0gZWxzZSBpZiAocHJldlByZXNldE5hbWUgJiYgcHJldlByZXNldE5hbWUgIT09ICdSZWd1bGFyJykge1xuICAgICAgICBzYXZlTGFzdFByZXNldE5hbWUocHJldlByZXNldE5hbWUpO1xuICAgICAgfVxuICAgIH1cbiAgICBcbiAgICAvLyDQntCx0L3QvtCy0LvRj9C10Lwg0YHRgdGL0LvQutC4INC90LAg0YLQtdC60YPRidC40LUg0L3QsNGB0YLRgNC+0LnQutC4INC00LvRjyDRgdC70LXQtNGD0Y7RidC10LPQviDQv9C10YDQtdC60LvRjtGH0LXQvdC40Y9cbiAgICBwcmV2aW91c1NlbGVjdGVkRm9udFJlZi5jdXJyZW50ID0gc2VsZWN0ZWRGb250O1xuICAgIHByZXZpb3VzVmFyaWFibGVTZXR0aW5nc1JlZi5jdXJyZW50ID0geyAuLi52YXJpYWJsZVNldHRpbmdzIH07XG4gICAgcHJldmlvdXNQcmVzZXROYW1lUmVmLmN1cnJlbnQgPSBzZWxlY3RlZFByZXNldE5hbWU7XG4gICAgXG4gICAgLy8g0KHQvtGF0YDQsNC90Y/QtdC8IElEINCy0YvQsdGA0LDQvdC90L7Qs9C+INGI0YDQuNGE0YLQsFxuICAgIGlmIChzZWxlY3RlZEZvbnQ/LmlkKSB7XG4gICAgICBzYXZlU2VsZWN0ZWRGb250SWQoc2VsZWN0ZWRGb250LmlkKTtcbiAgICB9XG4gIH0sIFtzZWxlY3RlZEZvbnQsIGZvbnRzLCBzZXRGb250cywgc2F2ZVNlbGVjdGVkRm9udElkLCBzYXZlTGFzdFZhcmlhYmxlU2V0dGluZ3MsIHNhdmVMYXN0UHJlc2V0TmFtZSwgc2F2ZUZvbnRTZXR0aW5ncywgdmFyaWFibGVTZXR0aW5ncywgc2VsZWN0ZWRQcmVzZXROYW1lXSk7XG5cbiAgLy8g0KPQsdC40YDQsNC10Lwg0YHRgtCw0YDRi9C5INC60L7QtCBsb2FkSW5pdGlhbFN0YXRlLCDRgtCw0Log0LrQsNC6INGC0LXQv9C10YDRjCB1c2VGb250UGVyc2lzdGVuY2Ug0YDQsNCx0L7RgtCw0LXRgiDQvdCw0L/RgNGP0LzRg9GOXG5cbiAgLy8g0JzQtdC80L7QuNC30LjRgNC+0LLQsNC90L3Ri9C1INC00L7RgdGC0YPQv9C90YvQtSDRgdGC0LjQu9C4INC4INC40LzRjyDQstGL0LHRgNCw0L3QvdC+0LPQviDQv9GA0LXRgdC10YLQsFxuICBjb25zdCBhdmFpbGFibGVTdHlsZXMgPSB1c2VNZW1vKCgpID0+IHtcbiAgICAgIGlmICghc2VsZWN0ZWRGb250KSByZXR1cm4gW107XG4gICAgICBcbiAgICAgIGNvbnNvbGUubG9nKCdbdXNlTWVtbyBhdmFpbGFibGVTdHlsZXNdIHNlbGVjdGVkRm9udDonLCBzZWxlY3RlZEZvbnQ/Lm5hbWUsICdzZWxlY3RlZEZvbnQuYXZhaWxhYmxlU3R5bGVzOicsIHNlbGVjdGVkRm9udD8uYXZhaWxhYmxlU3R5bGVzKTtcbiAgICAgIFxuICAgICAgLy8g0KPQtNCw0LvRj9C10Lwg0YHQv9C10YbQuNCw0LvRjNC90YPRjiDQu9C+0LPQuNC60YMg0LTQu9GPIEdvb2dsZSBGb250c1xuICAgICAgLypcbiAgICAgIGlmIChzZWxlY3RlZEZvbnQuc291cmNlID09PSAnZ29vZ2xlJykge1xuICAgICAgICAvLyDQlNC70Y8gR29vZ2xlINGI0YDQuNGE0YLQvtCyINCx0LXRgNC10Lwg0YHRgtC40LvQuCDQuNC3INC60LDRgNGC0Ysg0LjQu9C4INC00LXRhNC+0LvRgtC90YvQtVxuICAgICAgICBjb25zdCBzdHlsZXMgPSBHT09HTEVfRk9OVF9TVFlMRVNfTUFQW3NlbGVjdGVkRm9udC5uYW1lXSB8fCBbXG4gICAgICAgICAgICBQUkVTRVRfU1RZTEVTLmZpbmQocCA9PiBwLm5hbWUgPT09ICdSZWd1bGFyJyksXG4gICAgICAgICAgICBQUkVTRVRfU1RZTEVTLmZpbmQocCA9PiBwLm5hbWUgPT09ICdCb2xkJylcbiAgICAgICAgXS5maWx0ZXIoQm9vbGVhbik7XG4gICAgICAgIHJldHVybiBzdHlsZXM7XG4gICAgICB9IGVsc2UgKi8gXG4gICAgICBcbiAgICAgIC8vINCV0YHQu9C4INGI0YDQuNGE0YIg0LLQsNGA0LjQsNGC0LjQstC90YvQuSwg0LLQvtC30LLRgNCw0YnQsNC10Lwg0LLRgdC1INC/0YDQtdGB0LXRgtGLICjQtNC70Y8gVUkg0LLRi9Cx0L7RgNCwKVxuICAgICAgaWYgKHNlbGVjdGVkRm9udC5pc1ZhcmlhYmxlRm9udCkge1xuICAgICAgICAgIHJldHVybiBQUkVTRVRfU1RZTEVTO1xuICAgICAgLy8g0JXRgdC70Lgg0YMg0YjRgNC40YTRgtCwINC10YHRgtGMINC/0L7Qu9C1IGF2YWlsYWJsZVN0eWxlcyAo0LjQtyBGb250c291cmNlINC40LvQuCDQu9C+0LrQsNC70YzQvdC+0LPQviDQv9Cw0YDRgdC40L3Qs9CwKVxuICAgICAgfSBlbHNlIGlmIChzZWxlY3RlZEZvbnQuYXZhaWxhYmxlU3R5bGVzICYmIEFycmF5LmlzQXJyYXkoc2VsZWN0ZWRGb250LmF2YWlsYWJsZVN0eWxlcykpIHtcbiAgICAgICAgICAvLyDQo9Cx0LXQtNC40LzRgdGPLCDRh9GC0L4g0YHRgtC40LvQuCDQuNC80LXRjtGCINC90YPQttC90YvQuSDRhNC+0YDQvNCw0YIge25hbWUsIHdlaWdodCwgc3R5bGV9XG4gICAgICAgICAgLy8g0JXRgdC70Lgg0YTQvtGA0LzQsNGCINGD0LbQtSDQv9GA0LDQstC40LvRjNC90YvQuSwg0L/RgNC+0YHRgtC+INCy0L7Qt9Cy0YDQsNGJ0LDQtdC8XG4gICAgICAgICAgaWYgKHNlbGVjdGVkRm9udC5hdmFpbGFibGVTdHlsZXMuZXZlcnkocyA9PiBzLm5hbWUgJiYgcy53ZWlnaHQgJiYgcy5zdHlsZSkpIHtcbiAgICAgICAgICByZXR1cm4gc2VsZWN0ZWRGb250LmF2YWlsYWJsZVN0eWxlcztcbiAgICAgICAgICB9XG4gICAgICAgICAgLy8g0JXRgdC70Lgg0YTQvtGA0LzQsNGCINC00YDRg9Cz0L7QuSAo0L3QsNC/0YDQuNC80LXRgCwg0LjQtyBGb250c291cmNlIG1ldGFkYXRhKSwg0L3Rg9C20L3QviDQsdGD0LTQtdGCINC10LPQviDQv9GA0LXQvtCx0YDQsNC30L7QstCw0YLRjFxuICAgICAgICAgIC8vINCf0L7QutCwINC/0YDQvtGB0YLQviDQstC+0LfQstGA0LDRidCw0LXQvCDQv9GD0YHRgtC+0Lkg0LzQsNGB0YHQuNCyINC40LvQuCDQsdCw0LfQvtCy0YvQtSwg0LXRgdC70Lgg0L/RgNC10L7QsdGA0LDQt9C+0LLQsNC90LjQtSDQvdC1INGA0LXQsNC70LjQt9C+0LLQsNC90L5cbiAgICAgICAgICAvLyBUT0RPOiDQlNC+0LHQsNCy0LjRgtGMINC/0YDQtdC+0LHRgNCw0LfQvtCy0LDQvdC40LUg0LjQtyDRhNC+0YDQvNCw0YLQsCBGb250c291cmNlIG1ldGFkYXRhLCDQtdGB0LvQuCDQvtC9INC+0YLQu9C40YfQsNC10YLRgdGPXG4gICAgICAgICAgY29uc29sZS53YXJuKCfQpNC+0YDQvNCw0YIgYXZhaWxhYmxlU3R5bGVzINC+0YLQu9C40YfQsNC10YLRgdGPINC+0YIg0L7QttC40LTQsNC10LzQvtCz0L4sINGC0YDQtdCx0YPQtdGC0YHRjyDQv9GA0LXQvtCx0YDQsNC30L7QstCw0L3QuNC1LicpO1xuICAgICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAgIFBSRVNFVF9TVFlMRVMuZmluZChwID0+IHAubmFtZSA9PT0gJ1JlZ3VsYXInKSxcbiAgICAgICAgICAgICAgUFJFU0VUX1NUWUxFUy5maW5kKHAgPT4gcC5uYW1lID09PSAnQm9sZCcpXG4gICAgICAgICAgXS5maWx0ZXIoQm9vbGVhbik7XG4gICAgICAvLyDQmNC90LDRh9C1INCy0L7Qt9Cy0YDQsNGJ0LDQtdC8INCx0LDQt9C+0LLRi9C1INGB0YLQuNC70LhcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgICAgUFJFU0VUX1NUWUxFUy5maW5kKHAgPT4gcC5uYW1lID09PSAnUmVndWxhcicpLFxuICAgICAgICAgICAgICBQUkVTRVRfU1RZTEVTLmZpbmQocCA9PiBwLm5hbWUgPT09ICdCb2xkJylcbiAgICAgICAgICBdLmZpbHRlcihCb29sZWFuKTtcbiAgICAgIH1cbiAgfSwgW3NlbGVjdGVkRm9udF0pO1xuXG4gIC8vINCc0LXQvNC+0LjQt9C40YDQvtCy0LDQvdC90YvQuSDRhNC70LDQsyDQstCw0YDQuNCw0YLQuNCy0L3QvtCz0L4g0YjRgNC40YTRgtCwICjQv9C10YDQtdC90LXRgdC10L3QviDQsiB1c2VGb250Q3NzKVxuICBcbiAgLy8g0JzQtdC80L7QuNC30LjRgNC+0LLQsNC90L3QvtC1INC40LzRjyDRiNGA0LjRhNGC0LBcbiAgY29uc3Qgc2VsZWN0ZWRGb250TmFtZSA9IHVzZU1lbW8oKCkgPT4ge1xuICAgIHJldHVybiBzZWxlY3RlZEZvbnQgPyBzZWxlY3RlZEZvbnQubmFtZSA6ICcnO1xuICB9LCBbc2VsZWN0ZWRGb250XSk7XG4gIFxuICAvLyDQnNC10LzQvtC40LfQuNGA0L7QstCw0L3QvdGL0LUg0L7RgdC4INGI0YDQuNGE0YLQsFxuICBjb25zdCBzZWxlY3RlZEZvbnRBeGVzID0gdXNlTWVtbygoKSA9PiB7XG4gICAgcmV0dXJuIHNlbGVjdGVkRm9udCAmJiBzZWxlY3RlZEZvbnQudmFyaWFibGVBeGVzID8gc2VsZWN0ZWRGb250LnZhcmlhYmxlQXhlcyA6IHt9O1xuICB9LCBbc2VsZWN0ZWRGb250XSk7XG4gIFxuICAvKipcbiAgICog0KHQvtC30LTQsNC10YIg0YHRgtCw0YLQuNGH0LXRgdC60YPRjiDQstC10YDRgdC40Y4g0LLQsNGA0LjQsNGC0LjQstC90L7Qs9C+INGI0YDQuNGE0YLQsCDRgSDRgtC10LrRg9GJ0LjQvNC4INC90LDRgdGC0YDQvtC50LrQsNC80Lgg0L7RgdC10LlcbiAgICogXG4gICAqIEBleGFtcGxlXG4gICAqIC8vINCh0L7Qt9C00LDQvdC40LUg0YHRgtCw0YLQuNGH0LXRgdC60L7QuSDQstC10YDRgdC40Lgg0YLQtdC60YPRidC10LPQviDRiNGA0LjRhNGC0LBcbiAgICogY29uc3Qgc3RhdGljRm9udCA9IGNyZWF0ZVN0YXRpY0ZvbnQoKTtcbiAgICogY29uc29sZS5sb2coc3RhdGljRm9udC5uYW1lKTsgLy8g0JjQvNGPINGB0YLQsNGC0LjRh9C10YHQutC+0LPQviDRiNGA0LjRhNGC0LBcbiAgICogXG4gICAqIEByZXR1cm5zIHtPYmplY3R8dW5kZWZpbmVkfSDQntCx0YrQtdC60YIg0YHRgtCw0YLQuNGH0LXRgdC60L7Qs9C+INGI0YDQuNGE0YLQsCDQuNC70LggdW5kZWZpbmVkLCDQtdGB0LvQuCDQvdC10YIg0LLRi9Cx0YDQsNC90L3QvtCz0L4g0YjRgNC40YTRgtCwXG4gICAqL1xuICBjb25zdCBjcmVhdGVTdGF0aWNGb250ID0gdXNlQ2FsbGJhY2soKCkgPT4ge1xuICAgIHJldHVybiBjcmVhdGVTdGF0aWNGb250RnJvbUV4cG9ydEhvb2soc2VsZWN0ZWRGb250LCBzZWxlY3RlZEZvbnROYW1lLCB2YXJpYWJsZVNldHRpbmdzLCBzZXRFeHBvcnRlZEZvbnQpO1xuICB9LCBbY3JlYXRlU3RhdGljRm9udEZyb21FeHBvcnRIb29rLCBzZWxlY3RlZEZvbnQsIHNlbGVjdGVkRm9udE5hbWUsIHZhcmlhYmxlU2V0dGluZ3MsIHNldEV4cG9ydGVkRm9udF0pO1xuICBcbiAgLyoqXG4gICAqINCe0LHRgNCw0LHQsNGC0YvQstCw0LXRgiDQt9Cw0LPRgNGD0LbQtdC90L3Ri9C1INGI0YDQuNGE0YLRizog0LDQvdCw0LvQuNC30LjRgNGD0LXRgiDRhNCw0LnQu9GLLCDQvtC/0YDQtdC00LXQu9GP0LXRgiDRhdCw0YDQsNC60YLQtdGA0LjRgdGC0LjQutC4INC4XG4gICAqINC00L7QsdCw0LLQu9GP0LXRgiDRiNGA0LjRhNGC0Ysg0LIg0YHQvtGB0YLQvtGP0L3QuNC1INC/0YDQuNC70L7QttC10L3QuNGPXG4gICAqIFxuICAgKiBAZXhhbXBsZVxuICAgKiAvLyDQntCx0YDQsNCx0L7RgtC60LAg0YjRgNC40YTRgtC+0LIg0LjQtyBpbnB1dFt0eXBlPVwiZmlsZVwiXVxuICAgKiBjb25zdCBoYW5kbGVGaWxlVXBsb2FkID0gKGUpID0+IHtcbiAgICogICBjb25zdCBmaWxlcyA9IEFycmF5LmZyb20oZS50YXJnZXQuZmlsZXMpLm1hcChmaWxlID0+ICh7XG4gICAqICAgICBmaWxlLFxuICAgKiAgICAgbmFtZTogZmlsZS5uYW1lLFxuICAgKiAgICAgdXJsOiBVUkwuY3JlYXRlT2JqZWN0VVJMKGZpbGUpXG4gICAqICAgfSkpO1xuICAgKiAgIGhhbmRsZUZvbnRzVXBsb2FkZWQoZmlsZXMpO1xuICAgKiB9O1xuICAgKiBcbiAgICogQHBhcmFtIHtBcnJheX0gbmV3Rm9udHMgLSDQnNCw0YHRgdC40LIg0L7QsdGK0LXQutGC0L7QsiDRgSDQuNC90YTQvtGA0LzQsNGG0LjQtdC5INC+INC90L7QstGL0YUg0YjRgNC40YTRgtCw0YVcbiAgICogQHJldHVybnMge1Byb21pc2U8dm9pZD59XG4gICAqL1xuICBjb25zdCBoYW5kbGVGb250c1VwbG9hZGVkID0gdXNlQ2FsbGJhY2soYXN5bmMgKG5ld0ZvbnRzKSA9PiB7XG4gICAgY29uc29sZS5sb2coJ1toYW5kbGVGb250c1VwbG9hZGVkXSDQn9C+0LvRg9GH0LXQvdGLINGI0YDQuNGE0YLRizonLCBuZXdGb250cyk7XG4gICAgLy8g0JjRgdC/0L7Qu9GM0LfRg9C10Lwg0YTRg9C90LrRhtC40Y4g0LjQtyB1c2VGb250TG9hZGVyXG4gICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgaGFuZGxlTG9jYWxGb250c1VwbG9hZChuZXdGb250cyk7XG4gICAgY29uc29sZS5sb2coJ1toYW5kbGVGb250c1VwbG9hZGVkXSBoYW5kbGVMb2NhbEZvbnRzVXBsb2FkINC30LDQstC10YDRiNC10L0nKTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9LCBbaGFuZGxlTG9jYWxGb250c1VwbG9hZF0pO1xuICBcbiAgLyoqXG4gICAqINCj0LTQsNC70Y/QtdGCINGI0YDQuNGE0YIg0Lgg0L7RgdCy0L7QsdC+0LbQtNCw0LXRgiDRgNC10YHRg9GA0YHRi1xuICAgKiDQldGB0LvQuCDRg9C00LDQu9GP0LXRgtGB0Y8g0YLQtdC60YPRidC40Lkg0LLRi9Cx0YDQsNC90L3Ri9C5INGI0YDQuNGE0YIsINCy0YvQsdC40YDQsNC10YIg0YHQu9C10LTRg9GO0YnQuNC5INC00L7RgdGC0YPQv9C90YvQuVxuICAgKiBcbiAgICogQGV4YW1wbGVcbiAgICogLy8g0JrQvdC+0L/QutCwINGD0LTQsNC70LXQvdC40Y8g0YjRgNC40YTRgtCwXG4gICAqIDxidXR0b24gb25DbGljaz17KCkgPT4gcmVtb3ZlRm9udChmb250LmlkKX0+XG4gICAqICAg0KPQtNCw0LvQuNGC0YxcbiAgICogPC9idXR0b24+XG4gICAqIFxuICAgKiBAcGFyYW0ge3N0cmluZ30gZm9udElkIC0gSUQg0YjRgNC40YTRgtCwINC00LvRjyDRg9C00LDQu9C10L3QuNGPXG4gICAqL1xuICBjb25zdCByZW1vdmVGb250ID0gdXNlQ2FsbGJhY2soKGZvbnRJZCkgPT4ge1xuICAgIGxldCByZW1vdmVkRm9udEZhbWlseSA9IG51bGw7IFxuXG4gICAgc2V0Rm9udHMocHJldiA9PiB7XG4gICAgICBjb25zdCBmb250VG9SZW1vdmUgPSBwcmV2LmZpbmQoZiA9PiBmLmlkID09PSBmb250SWQpO1xuICAgICAgaWYgKGZvbnRUb1JlbW92ZSkge1xuICAgICAgICAgcmVtb3ZlZEZvbnRGYW1pbHkgPSBmb250VG9SZW1vdmUuZm9udEZhbWlseTsgLy8g0KHQvtGF0YDQsNC90Y/QtdC8INC40LzRjyDQtNC70Y8g0L7Rh9C40YHRgtC60LhcbiAgICAgICAgIGlmIChmb250VG9SZW1vdmUudXJsKSB7XG4gICAgICAgIC8vINCe0YHQstC+0LHQvtC20LTQsNC10LwgVVJMINC00LvRjyDQv9GA0LXQtNC+0YLQstGA0LDRidC10L3QuNGPINGD0YLQtdGH0LXQuiDQv9Cw0LzRj9GC0LhcbiAgICAgICAgICAgICByZXZva2VPYmplY3RVUkwoZm9udFRvUmVtb3ZlLnVybCk7XG4gICAgICAgICB9XG4gICAgICAgICAvLyA8PDwg0KPQtNCw0LvRj9C10Lwg0LjQtyBJbmRleGVkREIgPj4+XG4gICAgICAgICBkZWxldGVGb250REIoZm9udElkKS5jYXRjaChlcnIgPT4ge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcihgW0RCXSDQntGI0LjQsdC60LAg0YPQtNCw0LvQtdC90LjRjyDRiNGA0LjRhNGC0LAgJHtmb250SWR9INC40LcgREI6YCwgZXJyKTtcbiAgICAgICAgICAgIHRvYXN0LmVycm9yKCfQntGI0LjQsdC60LAg0YPQtNCw0LvQtdC90LjRjyDRiNGA0LjRhNGC0LAg0LjQtyDQsdCw0LfRiyDQtNCw0L3QvdGL0YUuJyk7XG4gICAgICAgICAgICAvLyDQp9GC0L4g0LTQtdC70LDRgtGMINCyINGN0YLQvtC8INGB0LvRg9GH0LDQtT8g0JLQvtC30LzQvtC20L3Qviwg0L3QuNGH0LXQs9C+LCDRiNGA0LjRhNGCINC+0YHRgtCw0L3QtdGC0YHRjyDQsiBEQi5cbiAgICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgXG4gICAgICBjb25zdCB1cGRhdGVkRm9udHMgPSBwcmV2LmZpbHRlcihmID0+IGYuaWQgIT09IGZvbnRJZCk7XG4gICAgICBcbiAgICAgIC8vINCV0YHQu9C4INGD0LTQsNC70Y/QtdC8INGC0LXQutGD0YnQuNC5INCy0YvQsdGA0LDQvdC90YvQuSDRiNGA0LjRhNGCLCDQstGL0LHQuNGA0LDQtdC8INGB0LvQtdC00YPRjtGJ0LjQuSDQtNC+0YHRgtGD0L/QvdGL0LlcbiAgICAgIGlmIChzZWxlY3RlZEZvbnQgJiYgc2VsZWN0ZWRGb250LmlkID09PSBmb250SWQpIHtcbiAgICAgICAgaWYgKHVwZGF0ZWRGb250cy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgLy8g0KHQvtGF0YDQsNC90Y/QtdC8INGB0YHRi9C70LrRgyDQvdCwINC90L7QstGL0Lkg0YjRgNC40YTRgiDQtNC70Y8g0LTQsNC70YzQvdC10LnRiNC10LPQviDQv9GA0LjQvNC10L3QtdC90LjRjyDRgdGC0LjQu9GPXG4gICAgICAgICAgY29uc3QgbmV3Rm9udCA9IHVwZGF0ZWRGb250c1swXTtcbiAgICAgICAgICAvLyDQo9GB0YLQsNC90LDQstC70LjQstCw0LXQvCDQvdC+0LLRi9C5INGI0YDQuNGE0YJcbiAgICAgICAgICBzZXRTZWxlY3RlZEZvbnQobmV3Rm9udCk7XG4gICAgICAgICAgXG4gICAgICAgICAgLy8g0J/QvtGB0LvQtSDRg9GB0YLQsNC90L7QstC60Lgg0L3QvtCy0L7Qs9C+INGI0YDQuNGE0YLQsCwg0L3QsNGB0YLRgNCw0LjQstCw0LXQvCDQtdCz0L4g0YHQviDRgdGC0LjQu9C10LwgUmVndWxhclxuICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgLy8g0KPRgdGC0LDQvdCw0LLQu9C40LLQsNC10Lwg0YHRgtC40LvRjCBSZWd1bGFyINC00LvRjyDQvdC+0LLQvtCz0L4g0YjRgNC40YTRgtCwXG4gICAgICAgICAgICBjb25zdCBwcmVzZXROYW1lID0gJ1JlZ3VsYXInO1xuICAgICAgICAgICAgc2FmZVNlbGVjdEZvbnRSZWYuY3VycmVudD8uKG5ld0ZvbnQpO1xuXG4gICAgICAgICAgfSwgMCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc2V0U2VsZWN0ZWRGb250KG51bGwpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBcbiAgICAgIHJldHVybiB1cGRhdGVkRm9udHM7XG4gICAgfSk7XG4gICAgXG4gICAgdG9hc3Quc3VjY2Vzcygn0KjRgNC40YTRgiDRg9C00LDQu9C10L0nKTtcblxuICAgIC8vINCe0YfQuNGB0YLQutCwIEZvbnRGYWNlINC40LcgZG9jdW1lbnQuZm9udHMgKNC90LXQvtCx0Y/Qt9Cw0YLQtdC70YzQvdC+LCDQvdC+INGF0L7RgNC+0YjQviDQtNC70Y8g0LPQuNCz0LjQtdC90YspXG4gICAgLy8gaWYgKHJlbW92ZWRGb250RmFtaWx5ICYmIGRvY3VtZW50LmZvbnRzKSB7XG4gICAgLy8gICAgZG9jdW1lbnQuZm9udHMuZGVsZXRlKHJlbW92ZWRGb250RmFtaWx5KTtcbiAgICAvLyB9XG4gIH0sIFtzZWxlY3RlZEZvbnQsIGRlbGV0ZUZvbnREQiwgc2V0Rm9udHMsIHNldFNlbGVjdGVkRm9udF0pO1xuXG4gIC8vINCe0LHQtdGA0YLQutC4INC00LvRjyDRgdC+0LLQvNC10YHRgtC40LzQvtGB0YLQuCDRgSDQv9GA0LXQtNGL0LTRg9GJ0LjQvCBBUElcbiAgY29uc3QgZXhwb3J0VG9DU1MgPSB1c2VDYWxsYmFjaygoZG93bmxvYWQgPSBmYWxzZSkgPT4ge1xuICAgIHJldHVybiBleHBvcnRUb0NTU0Zyb21FeHBvcnRIb29rKHNlbGVjdGVkRm9udCwgc2VsZWN0ZWRGb250TmFtZSwgZG93bmxvYWQpO1xuICB9LCBbZXhwb3J0VG9DU1NGcm9tRXhwb3J0SG9vaywgc2VsZWN0ZWRGb250LCBzZWxlY3RlZEZvbnROYW1lXSk7XG4gIFxuICAvKipcbiAgICog0JLRi9Cx0LjRgNCw0LXRgiAo0LjQu9C4INC30LDQs9GA0YPQttCw0LXRgiwg0LXRgdC70Lgg0LXRidGRINC90LUg0LfQsNCz0YDRg9C20LXQvSkg0YjRgNC40YTRgiBGb250c291cmNlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBmb250RmFtaWx5TmFtZSAtINCd0LDQt9Cy0LDQvdC40LUg0YHQtdC80LXQudGB0YLQstCwINGI0YDQuNGE0YLQvtCyXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gZm9yY2VWYXJpYWJsZUZvbnQgLSDQl9Cw0LPRgNGD0LbQsNGC0Ywg0LLQsNGA0LjQsNGC0LjQstC90YvQuSDRiNGA0LjRhNGCICjQtdGB0LvQuCDQtNC+0YHRgtGD0L/QtdC9KVxuICAgKi9cbiAgY29uc3Qgc2VsZWN0T3JBZGRGb250c291cmNlRm9udCA9IHVzZUNhbGxiYWNrKGFzeW5jIChmb250RmFtaWx5TmFtZSwgZm9yY2VWYXJpYWJsZUZvbnQgPSBmYWxzZSkgPT4ge1xuICAgIC8vINCf0YDQvtGB0YLQviDQv9C10YDQtdC90LDQv9GA0LDQstC70Y/QtdC8INC90LAg0YTRg9C90LrRhtC40Y4g0LjQtyB1c2VGb250TG9hZGVyXG4gICAgcmV0dXJuIGxvYWRBbmRTZWxlY3RGb250c291cmNlRm9udChmb250RmFtaWx5TmFtZSwgZm9yY2VWYXJpYWJsZUZvbnQpO1xuICB9LCBbbG9hZEFuZFNlbGVjdEZvbnRzb3VyY2VGb250XSk7XG4gIFxuICAvLyA8PDwg0KTRg9C90LrRhtC40Y8g0L/QvtC70L3QvtCz0L4g0YHQsdGA0L7RgdCwID4+PlxuICBjb25zdCByZXNldEFwcGxpY2F0aW9uU3RhdGUgPSB1c2VDYWxsYmFjayhhc3luYyAoKSA9PiB7XG4gICAgY29uc29sZS5sb2coXCJbUmVzZXRdINCX0LDQv9GD0YHQuiDQv9C+0LvQvdC+0LPQviDRgdCx0YDQvtGB0LAg0YHQvtGB0YLQvtGP0L3QuNGPINC/0YDQuNC70L7QttC10L3QuNGPLi4uXCIpO1xuICAgIHRyeSB7XG4gICAgICAvLyAxLiDQntGH0LjRidCw0LXQvCDRhdGA0LDQvdC40LvQuNGJ0LAgKEluZGV4ZWREQiDQuCBsb2NhbFN0b3JhZ2UpINGH0LXRgNC10Lcg0L3QvtCy0YvQuSDRhdGD0LpcbiAgICAgIGF3YWl0IHJlc2V0UGVyc2lzdGVuY2UoKTsgLy8gPDw8INCS0YvQt9GL0LLQsNC10Lwg0YHQsdGA0L7RgSDQv9C10YDRgdC40YHRgtC10L3RgtC90L7RgdGC0LhcbiAgICAgIHRvYXN0LmluZm8oXCLQm9C+0LrQsNC70YzQvdC+0LUg0YXRgNCw0L3QuNC70LjRidC1INC00LDQvdC90YvRhSDQvtGH0LjRidC10L3Qvi5cIik7IC8vINCe0LHQvdC+0LLQu9GP0LXQvCDRgdC+0L7QsdGJ0LXQvdC40LVcblxuICAgICAgLy8gMi4g0J7Rh9C40YnQsNC10Lwg0YHQvtGB0YLQvtGP0L3QuNGPINGF0YPQutCwICjQvtGB0YLQsNC10YLRgdGPINC60LDQuiDQsdGL0LvQvilcbiAgICAgIHNldEZvbnRzKFtdKTtcbiAgICAgIHNldFNlbGVjdGVkRm9udChudWxsKTtcbiAgICAgIHNldFZhcmlhYmxlU2V0dGluZ3Moe30pO1xuICAgICAgc2V0RXhwb3J0ZWRGb250KG51bGwpO1xuICAgICAgc2V0SXNMb2FkaW5nKGZhbHNlKTsgLy8g0KHQsdGA0LDRgdGL0LLQsNC10Lwg0YTQu9Cw0LMg0LfQsNCz0YDRg9C30LrQuFxuICAgICAgLy8gaXNJbml0aWFsTG9hZENvbXBsZXRlINC+0YHRgtCw0L3QtdGC0YHRjyB0cnVlLCDRgi7Qui4g0L3QsNGH0LDQu9GM0L3QsNGPINC30LDQs9GA0YPQt9C60LAg0LHRi9C70LBcbiAgICAgIGNvbnNvbGUubG9nKFwiW1Jlc2V0XSDQodC+0YHRgtC+0Y/QvdC40Y8gdXNlRm9udE1hbmFnZXIg0YHQsdGA0L7RiNC10L3Riy5cIik7XG5cblxuICAgICAgLy8gNC4g0JLRi9C30YvQstCw0LXQvCDRgdCx0YDQvtGBINC00YDRg9Cz0LjRhSDQutC+0L3RgtC10LrRgdGC0L7QsiAo0L/QvtC60LAg0YLQvtC70YzQutC+IFNldHRpbmdzQ29udGV4dClcbiAgICAgIC8vIHJlc2V0U2V0dGluZ3MoKTsgLy8g0JLRi9C30L7QsiDQsdGD0LTQtdGCINCyINC60L7QvNC/0L7QvdC10L3RgtC1INC60L3QvtC/0LrQuFxuXG4gICAgICB0b2FzdC5zdWNjZXNzKFwi0KHQvtGB0YLQvtGP0L3QuNC1INC/0YDQuNC70L7QttC10L3QuNGPINGD0YHQv9C10YjQvdC+INGB0LHRgNC+0YjQtdC90L4hXCIpO1xuXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoXCJbUmVzZXRdINCe0YjQuNCx0LrQsCDQstC+INCy0YDQtdC80Y8g0YHQsdGA0L7RgdCwINGB0L7RgdGC0L7Rj9C90LjRjzpcIiwgZXJyb3IpO1xuICAgICAgdG9hc3QuZXJyb3IoXCLQn9GA0L7QuNC30L7RiNC70LAg0L7RiNC40LHQutCwINC/0YDQuCDRgdCx0YDQvtGB0LUg0YHQvtGB0YLQvtGP0L3QuNGPLlwiKTtcbiAgICB9XG4gIH0sIFtzZXRGb250cywgc2V0U2VsZWN0ZWRGb250LCBzZXRWYXJpYWJsZVNldHRpbmdzLCBzZXRFeHBvcnRlZEZvbnQsIHNldElzTG9hZGluZywgcmVzZXRQZXJzaXN0ZW5jZV0pOyAvLyDQlNC+0LHQsNCy0LvRj9C10Lwg0LfQsNCy0LjRgdC40LzQvtGB0YLQuCDRgdC10YLRgtC10YDQvtCyXG5cbiAgLy8g0KPQsdC40YDQsNC10Lwg0YHRgtCw0YDRi9C1IHVzZUVmZmVjdCwg0YHQstGP0LfQsNC90L3Ri9C1INGBIGxvYWRJbml0aWFsU3RhdGVcblxuICByZXR1cm4ge1xuICAgIC8vINCh0L7RgdGC0L7Rj9C90LjRj1xuICAgIGZvbnRzLFxuICAgIHNlbGVjdGVkRm9udCxcbiAgICB2YXJpYWJsZVNldHRpbmdzLFxuICAgIGV4cG9ydGVkRm9udCxcbiAgICBpc1NlbGVjdGVkRm9udFZhcmlhYmxlLFxuICAgIHNlbGVjdGVkRm9udE5hbWUsXG4gICAgc2VsZWN0ZWRGb250QXhlcyxcbiAgICBhdmFpbGFibGVTdHlsZXMsXG4gICAgc2VsZWN0ZWRQcmVzZXROYW1lLFxuICAgIGlzTG9hZGluZyxcbiAgICBpc0luaXRpYWxMb2FkQ29tcGxldGUsXG4gICAgXG4gICAgLy8g0JzQtdGC0L7QtNGLINGD0L/RgNCw0LLQu9C10L3QuNGPINGB0L7RgdGC0L7Rj9C90LjQtdC8XG4gICAgc2V0Rm9udHMsXG4gICAgc2V0U2VsZWN0ZWRGb250LFxuICAgIHNldFZhcmlhYmxlU2V0dGluZ3MsXG4gICAgc2V0RXhwb3J0ZWRGb250LFxuICAgIFxuICAgIC8vINCc0LXRgtC+0LTRiyDQt9Cw0LPRgNGD0LfQutC4ICjQuNC3IHVzZUZvbnRMb2FkZXIpXG4gICAgaGFuZGxlTG9jYWxGb250c1VwbG9hZCwgXG4gICAgaGFuZGxlRm9udHNVcGxvYWRlZCwgLy8g0J/RgNCw0LLQuNC70YzQvdCw0Y8g0YTRg9C90LrRhtC40Y8t0L7QsdC10YDRgtC60LBcbiAgICBsb2FkQW5kU2VsZWN0Rm9udHNvdXJjZUZvbnQsXG4gICAgc2VsZWN0T3JBZGRGb250c291cmNlRm9udCwgLy8g0JTQvtCx0LDQstC70Y/QtdC8INGC0LDQutC20LUg0Y3RgtC+0YIg0LDQu9C40LDRgVxuICAgIFxuICAgIC8vINCc0LXRgtC+0LTRiyDRg9C/0YDQsNCy0LvQtdC90LjRjyDRiNGA0LjRhNGC0LDQvNC4IFxuICAgIHJlbW92ZUZvbnQsXG4gICAgc2FmZVNlbGVjdEZvbnQsXG4gICAgXG4gICAgLy8gPDw8INCc0LXRgtC+0LTRiyDRgNCw0LHQvtGC0Ysg0YEg0LLQsNGA0LjQsNGC0LjQstC90YvQvNC4INC+0YHRj9C80Lgg0LjQtyB1c2VWYXJpYWJsZUZvbnRDb250cm9scyA+Pj5cbiAgICBnZXRWYXJpYWJsZUF4ZXNJbmZvLFxuICAgIGdldFZhcmlhYmxlQXhlczogZ2V0VmFyaWFibGVBeGVzSW5mbywgLy8g0JDQu9C40LDRgSDQtNC70Y8g0L7QsdGA0LDRgtC90L7QuSDRgdC+0LLQvNC10YHRgtC40LzQvtGB0YLQuFxuICAgIGFwcGx5VmFyaWFibGVTZXR0aW5ncyxcbiAgICBoYW5kbGVWYXJpYWJsZVNldHRpbmdzQ2hhbmdlOiBhcHBseVZhcmlhYmxlU2V0dGluZ3MsIC8vINCQ0LvQuNCw0YEg0LTQu9GPINC+0LHRgNCw0YLQvdC+0Lkg0YHQvtCy0LzQtdGB0YLQuNC80L7RgdGC0LhcbiAgICByZXNldFZhcmlhYmxlU2V0dGluZ3MsXG4gICAgZ2V0RGVmYXVsdEF4aXNWYWx1ZXMsXG4gICAgXG4gICAgLy8g0JzQtdGC0L7QtNGLINC00LvRjyDRgdGC0LjQu9C10Lkg0YjRgNC40YTRgtCwXG4gICAgYXBwbHlQcmVzZXRTdHlsZSxcbiAgICBcbiAgICAvLyDQnNC10YLQvtC00Ysg0LTQu9GPIENTU1xuICAgIGdldEZvbnRGYW1pbHksXG4gICAgZ2V0VmFyaWF0aW9uU2V0dGluZ3MsXG4gICAgZ2VuZXJhdGVDU1MsXG4gICAgZXhwb3J0VG9DU1MsXG4gICAgZm9udENzc1Byb3BlcnRpZXMsXG4gICAgXG4gICAgLy8g0JzQtdGC0L7QtNGLINGN0LrRgdC/0L7RgNGC0LAg0Lgg0YHQutCw0YfQuNCy0LDQvdC40Y8gKNC40LcgdXNlRm9udEV4cG9ydClcbiAgICBkb3dubG9hZEZpbGUsXG4gICAgZ2VuZXJhdGVTdGF0aWNGb250RmlsZSxcbiAgICBkb3dubG9hZFN0YXRpY0ZvbnQsXG4gICAgXG4gICAgLy8g0J/RgNC+0YfQuNC1INC80LXRgtC+0LTRi1xuICAgIGNyZWF0ZVN0YXRpY0ZvbnQsXG4gICAgcmVzZXRBcHBsaWNhdGlvblN0YXRlLFxuICAgIFxuICAgIC8vINCc0LXRgtC+0LTRiyDQv9C10YDRgdC40YHRgtC10L3RgtC90L7RgdGC0LhcbiAgICBzYXZlRm9udFNldHRpbmdzLFxuICB9O1xufSAiXSwibmFtZXMiOlsidXNlU3RhdGUiLCJ1c2VDYWxsYmFjayIsInVzZVJlZiIsInVzZU1lbW8iLCJ1c2VFZmZlY3QiLCJ0b2FzdCIsImZpbmRTdHlsZUluZm9CeVdlaWdodEFuZFN0eWxlIiwiUFJFU0VUX1NUWUxFUyIsImRlYm91bmNlZFVwZGF0ZVZhcmlhYmxlRm9udFNldHRpbmdzIiwiZGVsZXRlRm9udERCIiwicmV2b2tlT2JqZWN0VVJMIiwidXNlRm9udFBlcnNpc3RlbmNlIiwidXNlRm9udExvYWRlciIsInVzZVZhcmlhYmxlRm9udENvbnRyb2xzIiwidXNlRm9udFN0eWxlTWFuYWdlciIsInVzZUZvbnRDc3MiLCJ1c2VGb250RXhwb3J0IiwidXNlRm9udE1hbmFnZXIiLCJmb250cyIsInNldEZvbnRzIiwic2VsZWN0ZWRGb250Iiwic2V0U2VsZWN0ZWRGb250IiwidmFyaWFibGVTZXR0aW5ncyIsInNldFZhcmlhYmxlU2V0dGluZ3MiLCJleHBvcnRlZEZvbnQiLCJzZXRFeHBvcnRlZEZvbnQiLCJpc0xvYWRpbmciLCJzZXRJc0xvYWRpbmciLCJsb2FkZWRGb250SWQiLCJpc0luaXRpYWxMb2FkQ29tcGxldGUiLCJzZXRJc0luaXRpYWxMb2FkQ29tcGxldGUiLCJzYWZlU2VsZWN0Rm9udFJlZiIsImhhbmRsZUxvY2FsRm9udHNVcGxvYWQiLCJsb2FkQW5kU2VsZWN0Rm9udHNvdXJjZUZvbnQiLCJsb2FkRm9udHNvdXJjZVN0eWxlVmFyaWFudCIsImZvbnQiLCJjdXJyZW50Iiwic2F2ZUZvbnRTZXR0aW5nc1JlZiIsInNhdmVMYXN0VmFyaWFibGVTZXR0aW5nc1JlZiIsImFwcGx5VmFyaWFibGVTZXR0aW5ncyIsImdldERlZmF1bHRBeGlzVmFsdWVzIiwicmVzZXRWYXJpYWJsZVNldHRpbmdzIiwiZ2V0VmFyaWFibGVBeGVzSW5mbyIsInNldHRpbmdzIiwiY29uc29sZSIsImxvZyIsImhhbmRsZVByZXNldEFwcGxpZWQiLCJmb250SWQiLCJhcHBseVByZXNldFN0eWxlIiwic2F2ZVNlbGVjdGVkRm9udElkIiwic2F2ZUxhc3RWYXJpYWJsZVNldHRpbmdzIiwic2F2ZUxhc3RQcmVzZXROYW1lIiwiY2xlYXJGb250TG9jYWxTdG9yYWdlIiwicmVzZXRQZXJzaXN0ZW5jZSIsInNhdmVGb250U2V0dGluZ3MiLCJpc1NlbGVjdGVkRm9udFZhcmlhYmxlIiwiaXNWYXJpYWJsZUZvbnQiLCJnZXRGb250RmFtaWx5IiwiZ2V0VmFyaWF0aW9uU2V0dGluZ3MiLCJnZW5lcmF0ZUNTUyIsImxvYWRGb250RmFjZSIsInVwZGF0ZVZhcmlhYmxlRm9udENzcyIsImRlYm91bmNlZFVwZGF0ZVZhcmlhYmxlRm9udENzcyIsImV4cG9ydFRvQ1NTIiwiZXhwb3J0VG9DU1NGcm9tSG9vayIsImZvbnRDc3NQcm9wZXJ0aWVzIiwiZG93bmxvYWRGaWxlIiwiZXhwb3J0VG9DU1NGcm9tRXhwb3J0SG9vayIsImNyZWF0ZVN0YXRpY0ZvbnQiLCJjcmVhdGVTdGF0aWNGb250RnJvbUV4cG9ydEhvb2siLCJnZW5lcmF0ZVN0YXRpY0ZvbnRGaWxlIiwiZG93bmxvYWRTdGF0aWNGb250Iiwic2FmZVNlbGVjdEZvbnQiLCJ3YXJuIiwibmFtZSIsImRpc3BsYXlOYW1lIiwic2V0dGluZ3NBcHBsaWVkIiwibGFzdFVzZWRWYXJpYWJsZVNldHRpbmdzIiwic2V0VGltZW91dCIsImxhc3RVc2VkUHJlc2V0TmFtZSIsInZhcmlhYmxlQXhlcyIsImRlZmF1bHRBeGVzIiwic2VsZWN0ZWRQcmVzZXROYW1lIiwiY3VycmVudFdlaWdodCIsImN1cnJlbnRTdHlsZSIsInVuZGVmaW5lZCIsInN0eWxlSW5mbyIsInByZXNldE5hbWUiLCJPYmplY3QiLCJrZXlzIiwibGVuZ3RoIiwid2dodCIsIml0YWwiLCJzbG50IiwibWF0Y2hlZFByZXNldCIsInByZXZpb3VzU2VsZWN0ZWRGb250UmVmIiwicHJldmlvdXNWYXJpYWJsZVNldHRpbmdzUmVmIiwicHJldmlvdXNQcmVzZXROYW1lUmVmIiwiaWQiLCJwcmV2Rm9udCIsInByZXZWYXJpYWJsZVNldHRpbmdzIiwicHJldlByZXNldE5hbWUiLCJ1cGRhdGVkRm9udHMiLCJtYXAiLCJ1cGRhdGVkRm9udCIsImRiVXBkYXRlcyIsImF2YWlsYWJsZVN0eWxlcyIsIkFycmF5IiwiaXNBcnJheSIsImV2ZXJ5IiwicyIsIndlaWdodCIsInN0eWxlIiwiZmluZCIsInAiLCJmaWx0ZXIiLCJCb29sZWFuIiwic2VsZWN0ZWRGb250TmFtZSIsInNlbGVjdGVkRm9udEF4ZXMiLCJoYW5kbGVGb250c1VwbG9hZGVkIiwibmV3Rm9udHMiLCJyZXN1bHQiLCJyZW1vdmVGb250IiwicmVtb3ZlZEZvbnRGYW1pbHkiLCJwcmV2IiwiZm9udFRvUmVtb3ZlIiwiZiIsImZvbnRGYW1pbHkiLCJ1cmwiLCJjYXRjaCIsImVyciIsImVycm9yIiwibmV3Rm9udCIsInN1Y2Nlc3MiLCJkb3dubG9hZCIsInNlbGVjdE9yQWRkRm9udHNvdXJjZUZvbnQiLCJmb250RmFtaWx5TmFtZSIsImZvcmNlVmFyaWFibGVGb250IiwicmVzZXRBcHBsaWNhdGlvblN0YXRlIiwiaW5mbyIsImdldFZhcmlhYmxlQXhlcyIsImhhbmRsZVZhcmlhYmxlU2V0dGluZ3NDaGFuZ2UiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./hooks/useFontManager.js\n"));

/***/ }),

/***/ "./hooks/useFontPersistence.js":
/*!*************************************!*\
  !*** ./hooks/useFontPersistence.js ***!
  \*************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   useFontPersistence: function() { return /* binding */ useFontPersistence; }\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"./node_modules/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var react_toastify__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react-toastify */ \"./node_modules/react-toastify/dist/index.mjs\");\n/* harmony import */ var _utils_db__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utils/db */ \"./utils/db.js\");\n/* harmony import */ var _utils_cssGenerator__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../utils/cssGenerator */ \"./utils/cssGenerator.js\");\n/* harmony import */ var _utils_localFontProcessor__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../utils/localFontProcessor */ \"./utils/localFontProcessor.js\");\nvar _s = $RefreshSig$();\n\n\n\n // Нужен для восстановления\n // Для очистки URL\n// Ключи localStorage для настроек шрифта\nconst FONT_SETTINGS_LS_KEYS = {\n    LAST_PRESET_NAME: \"lastPresetName\",\n    LAST_VARIABLE_SETTINGS: \"lastVariableSettings\",\n    SELECTED_FONT_ID: \"selectedFontId\"\n};\n/**\n * Хук для управления постоянством данных шрифтов (IndexedDB, localStorage).\n * @param {Function} setFonts - Функция установки состояния массива шрифтов.\n * @param {Function} setIsLoading - Функция установки состояния загрузки.\n * @param {Function} setIsInitialLoadComplete - Функция установки флага завершения начальной загрузки.\n * @param {Function} setSelectedFont - Функция установки выбранного шрифта.\n * @param {Function} handleVariableSettingsChange - Функция применения настроек вариативности.\n * @param {Function} applyPresetStyle - Функция применения пресета стиля.\n * @param {Array} fonts - Текущий массив шрифтов (для поиска при восстановлении).\n * @param {Object|null} selectedFont - Текущий выбранный шрифт (для предотвращения повторного восстановления).\n */ function useFontPersistence(setFonts, setIsLoading, setIsInitialLoadComplete, setSelectedFont, handleVariableSettingsChange, applyPresetStyle, fonts, selectedFont // Передаем selectedFont\n) {\n    _s();\n    // --- Начальная загрузка из IndexedDB --- \n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        let isMounted = true;\n        const loadInitialFonts = async ()=>{\n            console.log(\"[DB] Загрузка начальных шрифтов...\");\n            setIsLoading(true);\n            try {\n                const storedFonts = await (0,_utils_db__WEBPACK_IMPORTED_MODULE_2__.getAllFonts)();\n                if (!isMounted) return;\n                if (storedFonts && storedFonts.length > 0) {\n                    console.log(\"[DB] Найдено \".concat(storedFonts.length, \" шрифтов.\"));\n                    const processedFonts = await Promise.all(storedFonts.map(async (font)=>{\n                        if (!(font === null || font === void 0 ? void 0 : font.id) || !font.file || !(font.file instanceof Blob)) {\n                            console.warn(\"[DB] Пропущен некорректный объект:\", font);\n                            return null;\n                        }\n                        try {\n                            font.url = URL.createObjectURL(font.file);\n                            const fontFamilyToLoad = font.fontFamily || \"font-\".concat(font.id); // Генерируем имя, если нет\n                            font.fontFamily = fontFamilyToLoad;\n                            let initialVarSettings = {};\n                            if (font.isVariableFont && font.variableAxes) {\n                                initialVarSettings = Object.entries(font.variableAxes).reduce((acc, param)=>{\n                                    let [tag, axis] = param;\n                                    if (axis && typeof axis === \"object\" && axis.default !== undefined) acc[tag] = axis.default;\n                                    return acc;\n                                }, {});\n                            }\n                            await (0,_utils_cssGenerator__WEBPACK_IMPORTED_MODULE_3__.loadFontFaceIfNeeded)(fontFamilyToLoad, font.url, initialVarSettings);\n                            // Добавляем недостающие поля сессии, если их нет\n                            return {\n                                ...font,\n                                lastUsedPresetName: font.lastUsedPresetName || null,\n                                lastUsedVariableSettings: font.lastUsedVariableSettings || null\n                            };\n                        } catch (loadError) {\n                            console.error(\"[DB] Ошибка пересоздания FontFace для \".concat(font.name, \":\"), loadError);\n                            if (font.url) (0,_utils_localFontProcessor__WEBPACK_IMPORTED_MODULE_4__.revokeObjectURL)(font.url);\n                            return null;\n                        }\n                    }));\n                    const validFonts = processedFonts.filter((f)=>f !== null);\n                    if (isMounted) {\n                        setFonts(validFonts);\n                        console.log(\"[DB] \".concat(validFonts.length, \" шрифтов успешно загружено.\"));\n                    }\n                } else {\n                    console.log(\"[DB] В IndexedDB нет шрифтов.\");\n                }\n            } catch (error) {\n                console.error(\"[DB] Ошибка загрузки шрифтов:\", error);\n                react_toastify__WEBPACK_IMPORTED_MODULE_1__.toast.error(\"Ошибка загрузки сохраненных шрифтов.\");\n            } finally{\n                if (isMounted) {\n                    setIsLoading(false);\n                    setIsInitialLoadComplete(true);\n                }\n            }\n        };\n        loadInitialFonts();\n        return ()=>{\n            isMounted = false;\n        };\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    }, [\n        setFonts,\n        setIsLoading,\n        setIsInitialLoadComplete\n    ]); // Зависимости только сеттеры\n    // --- Восстановление выбранного шрифта и его настроек --- \n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        // Запускаем только после завершения загрузки из DB и если есть шрифты, но ни один не выбран\n        if (fonts && fonts.length > 0 && !selectedFont) {\n            console.log(\"[Restore] Попытка восстановить выбор и настройки...\");\n            const storedId = localStorage.getItem(FONT_SETTINGS_LS_KEYS.SELECTED_FONT_ID);\n            let fontToSelect = null;\n            if (storedId) {\n                fontToSelect = fonts.find((f)=>f.id === storedId);\n                if (fontToSelect) {\n                    console.log(\"[Restore] Найден шрифт по ID: \".concat(fontToSelect.displayName || fontToSelect.name));\n                } else {\n                    console.log(\"[Restore] Шрифт с ID \".concat(storedId, \" не найден. Удаляем ID.\"));\n                    localStorage.removeItem(FONT_SETTINGS_LS_KEYS.SELECTED_FONT_ID);\n                }\n            }\n            if (!fontToSelect && fonts && fonts.length > 0) {\n                console.log(\"[Restore] Выбираем первый доступный шрифт.\");\n                fontToSelect = fonts[0];\n                localStorage.setItem(FONT_SETTINGS_LS_KEYS.SELECTED_FONT_ID, fontToSelect.id); // Сохраняем ID первого\n            }\n            if (fontToSelect) {\n                setSelectedFont(fontToSelect); // Устанавливаем шрифт\n                // Используем setTimeout для применения настроек после установки шрифта\n                setTimeout(()=>{\n                    console.log(\"[Restore] Применение настроек для \".concat(fontToSelect.displayName || fontToSelect.name, \" через setTimeout\"));\n                    const restoredVarSettingsRaw = localStorage.getItem(FONT_SETTINGS_LS_KEYS.LAST_VARIABLE_SETTINGS);\n                    const restoredPresetName = localStorage.getItem(FONT_SETTINGS_LS_KEYS.LAST_PRESET_NAME);\n                    let settingsApplied = false;\n                    // 1. ПРИОРИТЕТ: Глобальные настройки из localStorage (самые свежие)\n                    if (fontToSelect.isVariableFont && restoredVarSettingsRaw) {\n                        try {\n                            const restoredVarSettings = JSON.parse(restoredVarSettingsRaw);\n                            console.log(\"[Restore] Восстанавливаем оси из localStorage (приоритет):\", restoredVarSettings);\n                            if (handleVariableSettingsChange) {\n                                handleVariableSettingsChange(restoredVarSettings, true, fontToSelect);\n                                settingsApplied = true;\n                            }\n                        } catch (e) {\n                            console.error(\"[Restore] Ошибка парсинга осей из localStorage:\", e);\n                            localStorage.removeItem(FONT_SETTINGS_LS_KEYS.LAST_VARIABLE_SETTINGS);\n                        }\n                    } else if (restoredPresetName && applyPresetStyle) {\n                        console.log(\"[Restore] Восстанавливаем пресет из localStorage (приоритет): \".concat(restoredPresetName));\n                        applyPresetStyle(restoredPresetName, fontToSelect);\n                        settingsApplied = true;\n                    }\n                    // 2. FALLBACK: Настройки конкретного шрифта из IndexedDB (если нет в localStorage)\n                    if (!settingsApplied) {\n                        if (fontToSelect.isVariableFont && fontToSelect.lastUsedVariableSettings && handleVariableSettingsChange) {\n                            console.log(\"[Restore] Восстанавливаем оси из IndexedDB (fallback):\", fontToSelect.lastUsedVariableSettings);\n                            handleVariableSettingsChange(fontToSelect.lastUsedVariableSettings, true, fontToSelect);\n                            settingsApplied = true;\n                        } else if (fontToSelect.lastUsedPresetName && applyPresetStyle) {\n                            console.log(\"[Restore] Восстанавливаем пресет из IndexedDB (fallback): \".concat(fontToSelect.lastUsedPresetName));\n                            applyPresetStyle(fontToSelect.lastUsedPresetName, fontToSelect);\n                            settingsApplied = true;\n                        }\n                    }\n                    // 3. ПОСЛЕДНИЙ FALLBACK: Если вообще ничего не восстановлено, ставим дефолт\n                    if (!settingsApplied) {\n                        console.log(\"[Restore] Настройки не восстановлены, применяем дефолтный Regular\");\n                        if (applyPresetStyle) {\n                            applyPresetStyle(\"Regular\", fontToSelect);\n                            settingsApplied = true;\n                        }\n                    }\n                }, 0);\n            }\n        }\n    // Добавляем fonts и selectedFont в зависимости, чтобы эффект срабатывал при их изменении\n    }, [\n        fonts,\n        selectedFont,\n        setSelectedFont,\n        applyPresetStyle,\n        handleVariableSettingsChange\n    ]);\n    // --- Функции для управления localStorage --- \n    const saveSelectedFontId = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((fontId)=>{\n        if (true) {\n            if (fontId) {\n                localStorage.setItem(FONT_SETTINGS_LS_KEYS.SELECTED_FONT_ID, fontId);\n            } else {\n                localStorage.removeItem(FONT_SETTINGS_LS_KEYS.SELECTED_FONT_ID);\n            }\n        }\n    }, []);\n    const saveLastVariableSettings = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((settings)=>{\n        console.log(\"[Persistence] saveLastVariableSettings вызвана с настройками:\", settings);\n        if (true) {\n            localStorage.setItem(FONT_SETTINGS_LS_KEYS.LAST_VARIABLE_SETTINGS, JSON.stringify(settings));\n            localStorage.removeItem(FONT_SETTINGS_LS_KEYS.LAST_PRESET_NAME); // Сбрасываем пресет\n            console.log(\"[Persistence] Настройки сохранены в localStorage\");\n        } else {}\n    }, []);\n    const saveLastPresetName = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((presetName)=>{\n        if (true) {\n            localStorage.setItem(FONT_SETTINGS_LS_KEYS.LAST_PRESET_NAME, presetName);\n            localStorage.removeItem(FONT_SETTINGS_LS_KEYS.LAST_VARIABLE_SETTINGS); // Сбрасываем оси\n        }\n    }, []);\n    const clearFontLocalStorage = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(()=>{\n        if (true) {\n            Object.values(FONT_SETTINGS_LS_KEYS).forEach((key)=>{\n                localStorage.removeItem(key);\n            });\n            console.log(\"[Persistence] localStorage (шрифты) очищен.\");\n        }\n    }, []);\n    // --- Функция сброса персистентности --- \n    const resetPersistence = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(async ()=>{\n        try {\n            await (0,_utils_db__WEBPACK_IMPORTED_MODULE_2__.deleteAllFontsDB)();\n            clearFontLocalStorage();\n            react_toastify__WEBPACK_IMPORTED_MODULE_1__.toast.info(\"Хранилища шрифтов (DB и LS) очищены.\");\n        } catch (error) {\n            console.error(\"[Persistence] Ошибка при сбросе хранилищ:\", error);\n            react_toastify__WEBPACK_IMPORTED_MODULE_1__.toast.error(\"Ошибка очистки хранилищ шрифтов.\");\n        }\n    }, [\n        clearFontLocalStorage\n    ]);\n    // --- Функция сохранения настроек шрифта в IndexedDB ---\n    const saveFontSettings = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(async (fontId, settings)=>{\n        if (!fontId || !settings) return;\n        try {\n            await (0,_utils_db__WEBPACK_IMPORTED_MODULE_2__.updateFontSettings)(fontId, settings);\n        } catch (error) {\n            console.error(\"[Persistence] Ошибка сохранения настроек шрифта \".concat(fontId, \":\"), error);\n        }\n    }, []);\n    // Возвращаем функции для управления персистентностью\n    return {\n        saveSelectedFontId,\n        saveLastVariableSettings,\n        saveLastPresetName,\n        clearFontLocalStorage,\n        resetPersistence,\n        saveFontSettings\n    };\n}\n_s(useFontPersistence, \"BwgoPzZKTR5BGDYXO9SQZ52/WEk=\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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IjpbIndlYnBhY2s6Ly9fTl9FLy4vaG9va3MvdXNlRm9udFBlcnNpc3RlbmNlLmpzPzYxOTAiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgdXNlRWZmZWN0LCB1c2VDYWxsYmFjayB9IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7IHRvYXN0IH0gZnJvbSAncmVhY3QtdG9hc3RpZnknO1xuaW1wb3J0IHsgZ2V0QWxsRm9udHMsIGRlbGV0ZUFsbEZvbnRzREIsIHVwZGF0ZUZvbnRTZXR0aW5ncyB9IGZyb20gJy4uL3V0aWxzL2RiJztcbmltcG9ydCB7IGxvYWRGb250RmFjZUlmTmVlZGVkIH0gZnJvbSAnLi4vdXRpbHMvY3NzR2VuZXJhdG9yJzsgLy8g0J3Rg9C20LXQvSDQtNC70Y8g0LLQvtGB0YHRgtCw0L3QvtCy0LvQtdC90LjRj1xuaW1wb3J0IHsgcmV2b2tlT2JqZWN0VVJMIH0gZnJvbSAnLi4vdXRpbHMvbG9jYWxGb250UHJvY2Vzc29yJzsgLy8g0JTQu9GPINC+0YfQuNGB0YLQutC4IFVSTFxuXG4vLyDQmtC70Y7Rh9C4IGxvY2FsU3RvcmFnZSDQtNC70Y8g0L3QsNGB0YLRgNC+0LXQuiDRiNGA0LjRhNGC0LBcbmNvbnN0IEZPTlRfU0VUVElOR1NfTFNfS0VZUyA9IHtcbiAgICBMQVNUX1BSRVNFVF9OQU1FOiAnbGFzdFByZXNldE5hbWUnLFxuICAgIExBU1RfVkFSSUFCTEVfU0VUVElOR1M6ICdsYXN0VmFyaWFibGVTZXR0aW5ncycsXG4gICAgU0VMRUNURURfRk9OVF9JRDogJ3NlbGVjdGVkRm9udElkJ1xufTtcblxuLyoqXG4gKiDQpdGD0Log0LTQu9GPINGD0L/RgNCw0LLQu9C10L3QuNGPINC/0L7RgdGC0L7Rj9C90YHRgtCy0L7QvCDQtNCw0L3QvdGL0YUg0YjRgNC40YTRgtC+0LIgKEluZGV4ZWREQiwgbG9jYWxTdG9yYWdlKS5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IHNldEZvbnRzIC0g0KTRg9C90LrRhtC40Y8g0YPRgdGC0LDQvdC+0LLQutC4INGB0L7RgdGC0L7Rj9C90LjRjyDQvNCw0YHRgdC40LLQsCDRiNGA0LjRhNGC0L7Qsi5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IHNldElzTG9hZGluZyAtINCk0YPQvdC60YbQuNGPINGD0YHRgtCw0L3QvtCy0LrQuCDRgdC+0YHRgtC+0Y/QvdC40Y8g0LfQsNCz0YDRg9C30LrQuC5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IHNldElzSW5pdGlhbExvYWRDb21wbGV0ZSAtINCk0YPQvdC60YbQuNGPINGD0YHRgtCw0L3QvtCy0LrQuCDRhNC70LDQs9CwINC30LDQstC10YDRiNC10L3QuNGPINC90LDRh9Cw0LvRjNC90L7QuSDQt9Cw0LPRgNGD0LfQutC4LlxuICogQHBhcmFtIHtGdW5jdGlvbn0gc2V0U2VsZWN0ZWRGb250IC0g0KTRg9C90LrRhtC40Y8g0YPRgdGC0LDQvdC+0LLQutC4INCy0YvQsdGA0LDQvdC90L7Qs9C+INGI0YDQuNGE0YLQsC5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGhhbmRsZVZhcmlhYmxlU2V0dGluZ3NDaGFuZ2UgLSDQpNGD0L3QutGG0LjRjyDQv9GA0LjQvNC10L3QtdC90LjRjyDQvdCw0YHRgtGA0L7QtdC6INCy0LDRgNC40LDRgtC40LLQvdC+0YHRgtC4LlxuICogQHBhcmFtIHtGdW5jdGlvbn0gYXBwbHlQcmVzZXRTdHlsZSAtINCk0YPQvdC60YbQuNGPINC/0YDQuNC80LXQvdC10L3QuNGPINC/0YDQtdGB0LXRgtCwINGB0YLQuNC70Y8uXG4gKiBAcGFyYW0ge0FycmF5fSBmb250cyAtINCi0LXQutGD0YnQuNC5INC80LDRgdGB0LjQsiDRiNGA0LjRhNGC0L7QsiAo0LTQu9GPINC/0L7QuNGB0LrQsCDQv9GA0Lgg0LLQvtGB0YHRgtCw0L3QvtCy0LvQtdC90LjQuCkuXG4gKiBAcGFyYW0ge09iamVjdHxudWxsfSBzZWxlY3RlZEZvbnQgLSDQotC10LrRg9GJ0LjQuSDQstGL0LHRgNCw0L3QvdGL0Lkg0YjRgNC40YTRgiAo0LTQu9GPINC/0YDQtdC00L7RgtCy0YDQsNGJ0LXQvdC40Y8g0L/QvtCy0YLQvtGA0L3QvtCz0L4g0LLQvtGB0YHRgtCw0L3QvtCy0LvQtdC90LjRjykuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1c2VGb250UGVyc2lzdGVuY2UoXG4gICAgc2V0Rm9udHMsXG4gICAgc2V0SXNMb2FkaW5nLFxuICAgIHNldElzSW5pdGlhbExvYWRDb21wbGV0ZSxcbiAgICBzZXRTZWxlY3RlZEZvbnQsXG4gICAgaGFuZGxlVmFyaWFibGVTZXR0aW5nc0NoYW5nZSxcbiAgICBhcHBseVByZXNldFN0eWxlLFxuICAgIGZvbnRzLCAvLyDQn9C10YDQtdC00LDQtdC8INGC0LXQutGD0YnQuNC1IGZvbnRzXG4gICAgc2VsZWN0ZWRGb250IC8vINCf0LXRgNC10LTQsNC10Lwgc2VsZWN0ZWRGb250XG4pIHtcblxuICAgIC8vIC0tLSDQndCw0YfQsNC70YzQvdCw0Y8g0LfQsNCz0YDRg9C30LrQsCDQuNC3IEluZGV4ZWREQiAtLS0gXG4gICAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICAgICAgbGV0IGlzTW91bnRlZCA9IHRydWU7XG4gICAgICAgIGNvbnN0IGxvYWRJbml0aWFsRm9udHMgPSBhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZygnW0RCXSDQl9Cw0LPRgNGD0LfQutCwINC90LDRh9Cw0LvRjNC90YvRhSDRiNGA0LjRhNGC0L7Qsi4uLicpO1xuICAgICAgICAgICAgc2V0SXNMb2FkaW5nKHRydWUpO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBjb25zdCBzdG9yZWRGb250cyA9IGF3YWl0IGdldEFsbEZvbnRzKCk7XG4gICAgICAgICAgICAgICAgaWYgKCFpc01vdW50ZWQpIHJldHVybjtcblxuICAgICAgICAgICAgICAgIGlmIChzdG9yZWRGb250cyAmJiBzdG9yZWRGb250cy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKGBbREJdINCd0LDQudC00LXQvdC+ICR7c3RvcmVkRm9udHMubGVuZ3RofSDRiNGA0LjRhNGC0L7Qsi5gKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcHJvY2Vzc2VkRm9udHMgPSBhd2FpdCBQcm9taXNlLmFsbChzdG9yZWRGb250cy5tYXAoYXN5bmMgKGZvbnQpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghZm9udD8uaWQgfHwgIWZvbnQuZmlsZSB8fCAhKGZvbnQuZmlsZSBpbnN0YW5jZW9mIEJsb2IpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS53YXJuKCdbREJdINCf0YDQvtC/0YPRidC10L0g0L3QtdC60L7RgNGA0LXQutGC0L3Ri9C5INC+0LHRitC10LrRgjonLCBmb250KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9udC51cmwgPSBVUkwuY3JlYXRlT2JqZWN0VVJMKGZvbnQuZmlsZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZm9udEZhbWlseVRvTG9hZCA9IGZvbnQuZm9udEZhbWlseSB8fCBgZm9udC0ke2ZvbnQuaWR9YDsgLy8g0JPQtdC90LXRgNC40YDRg9C10Lwg0LjQvNGPLCDQtdGB0LvQuCDQvdC10YJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb250LmZvbnRGYW1pbHkgPSBmb250RmFtaWx5VG9Mb2FkO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGluaXRpYWxWYXJTZXR0aW5ncyA9IHt9O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChmb250LmlzVmFyaWFibGVGb250ICYmIGZvbnQudmFyaWFibGVBeGVzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluaXRpYWxWYXJTZXR0aW5ncyA9IE9iamVjdC5lbnRyaWVzKGZvbnQudmFyaWFibGVBeGVzKS5yZWR1Y2UoKGFjYywgW3RhZywgYXhpc10pID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChheGlzICYmIHR5cGVvZiBheGlzID09PSAnb2JqZWN0JyAmJiBheGlzLmRlZmF1bHQgIT09IHVuZGVmaW5lZCkgYWNjW3RhZ10gPSBheGlzLmRlZmF1bHQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gYWNjO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LCB7fSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGF3YWl0IGxvYWRGb250RmFjZUlmTmVlZGVkKGZvbnRGYW1pbHlUb0xvYWQsIGZvbnQudXJsLCBpbml0aWFsVmFyU2V0dGluZ3MpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vINCU0L7QsdCw0LLQu9GP0LXQvCDQvdC10LTQvtGB0YLQsNGO0YnQuNC1INC/0L7Qu9GPINGB0LXRgdGB0LjQuCwg0LXRgdC70Lgg0LjRhSDQvdC10YJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAuLi5mb250LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsYXN0VXNlZFByZXNldE5hbWU6IGZvbnQubGFzdFVzZWRQcmVzZXROYW1lIHx8IG51bGwsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxhc3RVc2VkVmFyaWFibGVTZXR0aW5nczogZm9udC5sYXN0VXNlZFZhcmlhYmxlU2V0dGluZ3MgfHwgbnVsbFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGNhdGNoIChsb2FkRXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKGBbREJdINCe0YjQuNCx0LrQsCDQv9C10YDQtdGB0L7Qt9C00LDQvdC40Y8gRm9udEZhY2Ug0LTQu9GPICR7Zm9udC5uYW1lfTpgLCBsb2FkRXJyb3IpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChmb250LnVybCkgcmV2b2tlT2JqZWN0VVJMKGZvbnQudXJsKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSkpO1xuXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHZhbGlkRm9udHMgPSBwcm9jZXNzZWRGb250cy5maWx0ZXIoZiA9PiBmICE9PSBudWxsKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzTW91bnRlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2V0Rm9udHModmFsaWRGb250cyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhgW0RCXSAke3ZhbGlkRm9udHMubGVuZ3RofSDRiNGA0LjRhNGC0L7QsiDRg9GB0L/QtdGI0L3QviDQt9Cw0LPRgNGD0LbQtdC90L4uYCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZygnW0RCXSDQkiBJbmRleGVkREIg0L3QtdGCINGI0YDQuNGE0YLQvtCyLicpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcignW0RCXSDQntGI0LjQsdC60LAg0LfQsNCz0YDRg9C30LrQuCDRiNGA0LjRhNGC0L7QsjonLCBlcnJvcik7XG4gICAgICAgICAgICAgICAgdG9hc3QuZXJyb3IoJ9Ce0YjQuNCx0LrQsCDQt9Cw0LPRgNGD0LfQutC4INGB0L7RhdGA0LDQvdC10L3QvdGL0YUg0YjRgNC40YTRgtC+0LIuJyk7XG4gICAgICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgICAgIGlmIChpc01vdW50ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgc2V0SXNMb2FkaW5nKGZhbHNlKTtcbiAgICAgICAgICAgICAgICAgICAgc2V0SXNJbml0aWFsTG9hZENvbXBsZXRlKHRydWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgbG9hZEluaXRpYWxGb250cygpO1xuICAgICAgICByZXR1cm4gKCkgPT4geyBpc01vdW50ZWQgPSBmYWxzZTsgfTtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaG9va3MvZXhoYXVzdGl2ZS1kZXBzXG4gICAgfSwgW3NldEZvbnRzLCBzZXRJc0xvYWRpbmcsIHNldElzSW5pdGlhbExvYWRDb21wbGV0ZV0pOyAvLyDQl9Cw0LLQuNGB0LjQvNC+0YHRgtC4INGC0L7Qu9GM0LrQviDRgdC10YLRgtC10YDRi1xuXG4gICAgLy8gLS0tINCS0L7RgdGB0YLQsNC90L7QstC70LXQvdC40LUg0LLRi9Cx0YDQsNC90L3QvtCz0L4g0YjRgNC40YTRgtCwINC4INC10LPQviDQvdCw0YHRgtGA0L7QtdC6IC0tLSBcbiAgICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgICAvLyDQl9Cw0L/Rg9GB0LrQsNC10Lwg0YLQvtC70YzQutC+INC/0L7RgdC70LUg0LfQsNCy0LXRgNGI0LXQvdC40Y8g0LfQsNCz0YDRg9C30LrQuCDQuNC3IERCINC4INC10YHQu9C4INC10YHRgtGMINGI0YDQuNGE0YLRiywg0L3QviDQvdC4INC+0LTQuNC9INC90LUg0LLRi9Cx0YDQsNC9XG4gICAgICAgIGlmIChmb250cyAmJiBmb250cy5sZW5ndGggPiAwICYmICFzZWxlY3RlZEZvbnQpIHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCdbUmVzdG9yZV0g0J/QvtC/0YvRgtC60LAg0LLQvtGB0YHRgtCw0L3QvtCy0LjRgtGMINCy0YvQsdC+0YAg0Lgg0L3QsNGB0YLRgNC+0LnQutC4Li4uJyk7XG4gICAgICAgICAgICBjb25zdCBzdG9yZWRJZCA9IGxvY2FsU3RvcmFnZS5nZXRJdGVtKEZPTlRfU0VUVElOR1NfTFNfS0VZUy5TRUxFQ1RFRF9GT05UX0lEKTtcbiAgICAgICAgICAgIGxldCBmb250VG9TZWxlY3QgPSBudWxsO1xuXG4gICAgICAgICAgICBpZiAoc3RvcmVkSWQpIHtcbiAgICAgICAgICAgICAgICBmb250VG9TZWxlY3QgPSBmb250cy5maW5kKGYgPT4gZi5pZCA9PT0gc3RvcmVkSWQpO1xuICAgICAgICAgICAgICAgIGlmIChmb250VG9TZWxlY3QpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coYFtSZXN0b3JlXSDQndCw0LnQtNC10L0g0YjRgNC40YTRgiDQv9C+IElEOiAke2ZvbnRUb1NlbGVjdC5kaXNwbGF5TmFtZSB8fCBmb250VG9TZWxlY3QubmFtZX1gKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhgW1Jlc3RvcmVdINCo0YDQuNGE0YIg0YEgSUQgJHtzdG9yZWRJZH0g0L3QtSDQvdCw0LnQtNC10L0uINCj0LTQsNC70Y/QtdC8IElELmApO1xuICAgICAgICAgICAgICAgICAgICBsb2NhbFN0b3JhZ2UucmVtb3ZlSXRlbShGT05UX1NFVFRJTkdTX0xTX0tFWVMuU0VMRUNURURfRk9OVF9JRCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoIWZvbnRUb1NlbGVjdCAmJiBmb250cyAmJiBmb250cy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coJ1tSZXN0b3JlXSDQktGL0LHQuNGA0LDQtdC8INC/0LXRgNCy0YvQuSDQtNC+0YHRgtGD0L/QvdGL0Lkg0YjRgNC40YTRgi4nKTtcbiAgICAgICAgICAgICAgICBmb250VG9TZWxlY3QgPSBmb250c1swXTtcbiAgICAgICAgICAgICAgICBsb2NhbFN0b3JhZ2Uuc2V0SXRlbShGT05UX1NFVFRJTkdTX0xTX0tFWVMuU0VMRUNURURfRk9OVF9JRCwgZm9udFRvU2VsZWN0LmlkKTsgLy8g0KHQvtGF0YDQsNC90Y/QtdC8IElEINC/0LXRgNCy0L7Qs9C+XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChmb250VG9TZWxlY3QpIHtcbiAgICAgICAgICAgICAgICBzZXRTZWxlY3RlZEZvbnQoZm9udFRvU2VsZWN0KTsgLy8g0KPRgdGC0LDQvdCw0LLQu9C40LLQsNC10Lwg0YjRgNC40YTRglxuXG4gICAgICAgICAgICAgICAgLy8g0JjRgdC/0L7Qu9GM0LfRg9C10Lwgc2V0VGltZW91dCDQtNC70Y8g0L/RgNC40LzQtdC90LXQvdC40Y8g0L3QsNGB0YLRgNC+0LXQuiDQv9C+0YHQu9C1INGD0YHRgtCw0L3QvtCy0LrQuCDRiNGA0LjRhNGC0LBcbiAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coYFtSZXN0b3JlXSDQn9GA0LjQvNC10L3QtdC90LjQtSDQvdCw0YHRgtGA0L7QtdC6INC00LvRjyAke2ZvbnRUb1NlbGVjdC5kaXNwbGF5TmFtZSB8fCBmb250VG9TZWxlY3QubmFtZX0g0YfQtdGA0LXQtyBzZXRUaW1lb3V0YCk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlc3RvcmVkVmFyU2V0dGluZ3NSYXcgPSBsb2NhbFN0b3JhZ2UuZ2V0SXRlbShGT05UX1NFVFRJTkdTX0xTX0tFWVMuTEFTVF9WQVJJQUJMRV9TRVRUSU5HUyk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlc3RvcmVkUHJlc2V0TmFtZSA9IGxvY2FsU3RvcmFnZS5nZXRJdGVtKEZPTlRfU0VUVElOR1NfTFNfS0VZUy5MQVNUX1BSRVNFVF9OQU1FKTtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHNldHRpbmdzQXBwbGllZCA9IGZhbHNlO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIDEuINCf0KDQmNCe0KDQmNCi0JXQojog0JPQu9C+0LHQsNC70YzQvdGL0LUg0L3QsNGB0YLRgNC+0LnQutC4INC40LcgbG9jYWxTdG9yYWdlICjRgdCw0LzRi9C1INGB0LLQtdC20LjQtSlcbiAgICAgICAgICAgICAgICAgICAgaWYgKGZvbnRUb1NlbGVjdC5pc1ZhcmlhYmxlRm9udCAmJiByZXN0b3JlZFZhclNldHRpbmdzUmF3KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlc3RvcmVkVmFyU2V0dGluZ3MgPSBKU09OLnBhcnNlKHJlc3RvcmVkVmFyU2V0dGluZ3NSYXcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCdbUmVzdG9yZV0g0JLQvtGB0YHRgtCw0L3QsNCy0LvQuNCy0LDQtdC8INC+0YHQuCDQuNC3IGxvY2FsU3RvcmFnZSAo0L/RgNC40L7RgNC40YLQtdGCKTonLCByZXN0b3JlZFZhclNldHRpbmdzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaGFuZGxlVmFyaWFibGVTZXR0aW5nc0NoYW5nZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBoYW5kbGVWYXJpYWJsZVNldHRpbmdzQ2hhbmdlKHJlc3RvcmVkVmFyU2V0dGluZ3MsIHRydWUsIGZvbnRUb1NlbGVjdCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNldHRpbmdzQXBwbGllZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ1tSZXN0b3JlXSDQntGI0LjQsdC60LAg0L/QsNGA0YHQuNC90LPQsCDQvtGB0LXQuSDQuNC3IGxvY2FsU3RvcmFnZTonLCBlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsb2NhbFN0b3JhZ2UucmVtb3ZlSXRlbShGT05UX1NFVFRJTkdTX0xTX0tFWVMuTEFTVF9WQVJJQUJMRV9TRVRUSU5HUyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAocmVzdG9yZWRQcmVzZXROYW1lICYmIGFwcGx5UHJlc2V0U3R5bGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKGBbUmVzdG9yZV0g0JLQvtGB0YHRgtCw0L3QsNCy0LvQuNCy0LDQtdC8INC/0YDQtdGB0LXRgiDQuNC3IGxvY2FsU3RvcmFnZSAo0L/RgNC40L7RgNC40YLQtdGCKTogJHtyZXN0b3JlZFByZXNldE5hbWV9YCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBhcHBseVByZXNldFN0eWxlKHJlc3RvcmVkUHJlc2V0TmFtZSwgZm9udFRvU2VsZWN0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNldHRpbmdzQXBwbGllZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAvLyAyLiBGQUxMQkFDSzog0J3QsNGB0YLRgNC+0LnQutC4INC60L7QvdC60YDQtdGC0L3QvtCz0L4g0YjRgNC40YTRgtCwINC40LcgSW5kZXhlZERCICjQtdGB0LvQuCDQvdC10YIg0LIgbG9jYWxTdG9yYWdlKVxuICAgICAgICAgICAgICAgICAgICBpZiAoIXNldHRpbmdzQXBwbGllZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGZvbnRUb1NlbGVjdC5pc1ZhcmlhYmxlRm9udCAmJiBmb250VG9TZWxlY3QubGFzdFVzZWRWYXJpYWJsZVNldHRpbmdzICYmIGhhbmRsZVZhcmlhYmxlU2V0dGluZ3NDaGFuZ2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZygnW1Jlc3RvcmVdINCS0L7RgdGB0YLQsNC90LDQstC70LjQstCw0LXQvCDQvtGB0Lgg0LjQtyBJbmRleGVkREIgKGZhbGxiYWNrKTonLCBmb250VG9TZWxlY3QubGFzdFVzZWRWYXJpYWJsZVNldHRpbmdzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBoYW5kbGVWYXJpYWJsZVNldHRpbmdzQ2hhbmdlKGZvbnRUb1NlbGVjdC5sYXN0VXNlZFZhcmlhYmxlU2V0dGluZ3MsIHRydWUsIGZvbnRUb1NlbGVjdCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2V0dGluZ3NBcHBsaWVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoZm9udFRvU2VsZWN0Lmxhc3RVc2VkUHJlc2V0TmFtZSAmJiBhcHBseVByZXNldFN0eWxlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coYFtSZXN0b3JlXSDQktC+0YHRgdGC0LDQvdCw0LLQu9C40LLQsNC10Lwg0L/RgNC10YHQtdGCINC40LcgSW5kZXhlZERCIChmYWxsYmFjayk6ICR7Zm9udFRvU2VsZWN0Lmxhc3RVc2VkUHJlc2V0TmFtZX1gKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcHBseVByZXNldFN0eWxlKGZvbnRUb1NlbGVjdC5sYXN0VXNlZFByZXNldE5hbWUsIGZvbnRUb1NlbGVjdCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2V0dGluZ3NBcHBsaWVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIC8vIDMuINCf0J7QodCb0JXQlNCd0JjQmSBGQUxMQkFDSzog0JXRgdC70Lgg0LLQvtC+0LHRidC1INC90LjRh9C10LPQviDQvdC1INCy0L7RgdGB0YLQsNC90L7QstC70LXQvdC+LCDRgdGC0LDQstC40Lwg0LTQtdGE0L7Qu9GCXG4gICAgICAgICAgICAgICAgICAgIGlmICghc2V0dGluZ3NBcHBsaWVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZygnW1Jlc3RvcmVdINCd0LDRgdGC0YDQvtC50LrQuCDQvdC1INCy0L7RgdGB0YLQsNC90L7QstC70LXQvdGLLCDQv9GA0LjQvNC10L3Rj9C10Lwg0LTQtdGE0L7Qu9GC0L3Ri9C5IFJlZ3VsYXInKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChhcHBseVByZXNldFN0eWxlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYXBwbHlQcmVzZXRTdHlsZSgnUmVndWxhcicsIGZvbnRUb1NlbGVjdCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2V0dGluZ3NBcHBsaWVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0sIDApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgLy8g0JTQvtCx0LDQstC70Y/QtdC8IGZvbnRzINC4IHNlbGVjdGVkRm9udCDQsiDQt9Cw0LLQuNGB0LjQvNC+0YHRgtC4LCDRh9GC0L7QsdGLINGN0YTRhNC10LrRgiDRgdGA0LDQsdCw0YLRi9Cy0LDQuyDQv9GA0Lgg0LjRhSDQuNC30LzQtdC90LXQvdC40LhcbiAgICB9LCBbZm9udHMsIHNlbGVjdGVkRm9udCwgc2V0U2VsZWN0ZWRGb250LCBhcHBseVByZXNldFN0eWxlLCBoYW5kbGVWYXJpYWJsZVNldHRpbmdzQ2hhbmdlXSk7XG5cbiAgICAvLyAtLS0g0KTRg9C90LrRhtC40Lgg0LTQu9GPINGD0L/RgNCw0LLQu9C10L3QuNGPIGxvY2FsU3RvcmFnZSAtLS0gXG5cbiAgICBjb25zdCBzYXZlU2VsZWN0ZWRGb250SWQgPSB1c2VDYWxsYmFjaygoZm9udElkKSA9PiB7XG4gICAgICAgIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgaWYgKGZvbnRJZCkge1xuICAgICAgICAgICAgICAgIGxvY2FsU3RvcmFnZS5zZXRJdGVtKEZPTlRfU0VUVElOR1NfTFNfS0VZUy5TRUxFQ1RFRF9GT05UX0lELCBmb250SWQpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBsb2NhbFN0b3JhZ2UucmVtb3ZlSXRlbShGT05UX1NFVFRJTkdTX0xTX0tFWVMuU0VMRUNURURfRk9OVF9JRCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LCBbXSk7XG5cbiAgICBjb25zdCBzYXZlTGFzdFZhcmlhYmxlU2V0dGluZ3MgPSB1c2VDYWxsYmFjaygoc2V0dGluZ3MpID0+IHtcbiAgICAgICAgY29uc29sZS5sb2coJ1tQZXJzaXN0ZW5jZV0gc2F2ZUxhc3RWYXJpYWJsZVNldHRpbmdzINCy0YvQt9Cy0LDQvdCwINGBINC90LDRgdGC0YDQvtC50LrQsNC80Lg6Jywgc2V0dGluZ3MpO1xuICAgICAgICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIGxvY2FsU3RvcmFnZS5zZXRJdGVtKEZPTlRfU0VUVElOR1NfTFNfS0VZUy5MQVNUX1ZBUklBQkxFX1NFVFRJTkdTLCBKU09OLnN0cmluZ2lmeShzZXR0aW5ncykpO1xuICAgICAgICAgICAgbG9jYWxTdG9yYWdlLnJlbW92ZUl0ZW0oRk9OVF9TRVRUSU5HU19MU19LRVlTLkxBU1RfUFJFU0VUX05BTUUpOyAvLyDQodCx0YDQsNGB0YvQstCw0LXQvCDQv9GA0LXRgdC10YJcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCdbUGVyc2lzdGVuY2VdINCd0LDRgdGC0YDQvtC50LrQuCDRgdC+0YXRgNCw0L3QtdC90Ysg0LIgbG9jYWxTdG9yYWdlJyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oJ1tQZXJzaXN0ZW5jZV0gd2luZG93INC90LXQtNC+0YHRgtGD0L/QtdC9LCDRgdC+0YXRgNCw0L3QtdC90LjQtSDQv9GA0L7Qv9GD0YnQtdC90L4nKTtcbiAgICAgICAgfVxuICAgIH0sIFtdKTtcblxuICAgIGNvbnN0IHNhdmVMYXN0UHJlc2V0TmFtZSA9IHVzZUNhbGxiYWNrKChwcmVzZXROYW1lKSA9PiB7XG4gICAgICAgIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgbG9jYWxTdG9yYWdlLnNldEl0ZW0oRk9OVF9TRVRUSU5HU19MU19LRVlTLkxBU1RfUFJFU0VUX05BTUUsIHByZXNldE5hbWUpO1xuICAgICAgICAgICAgbG9jYWxTdG9yYWdlLnJlbW92ZUl0ZW0oRk9OVF9TRVRUSU5HU19MU19LRVlTLkxBU1RfVkFSSUFCTEVfU0VUVElOR1MpOyAvLyDQodCx0YDQsNGB0YvQstCw0LXQvCDQvtGB0LhcbiAgICAgICAgfVxuICAgIH0sIFtdKTtcblxuICAgIGNvbnN0IGNsZWFyRm9udExvY2FsU3RvcmFnZSA9IHVzZUNhbGxiYWNrKCgpID0+IHtcbiAgICAgICAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBPYmplY3QudmFsdWVzKEZPTlRfU0VUVElOR1NfTFNfS0VZUykuZm9yRWFjaChrZXkgPT4ge1xuICAgICAgICAgICAgICAgIGxvY2FsU3RvcmFnZS5yZW1vdmVJdGVtKGtleSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiW1BlcnNpc3RlbmNlXSBsb2NhbFN0b3JhZ2UgKNGI0YDQuNGE0YLRiykg0L7Rh9C40YnQtdC9LlwiKTtcbiAgICAgICAgfVxuICAgIH0sIFtdKTtcblxuICAgIC8vIC0tLSDQpNGD0L3QutGG0LjRjyDRgdCx0YDQvtGB0LAg0L/QtdGA0YHQuNGB0YLQtdC90YLQvdC+0YHRgtC4IC0tLSBcbiAgICBjb25zdCByZXNldFBlcnNpc3RlbmNlID0gdXNlQ2FsbGJhY2soYXN5bmMgKCkgPT4ge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgYXdhaXQgZGVsZXRlQWxsRm9udHNEQigpO1xuICAgICAgICAgICAgY2xlYXJGb250TG9jYWxTdG9yYWdlKCk7XG4gICAgICAgICAgICB0b2FzdC5pbmZvKFwi0KXRgNCw0L3QuNC70LjRidCwINGI0YDQuNGE0YLQvtCyIChEQiDQuCBMUykg0L7Rh9C40YnQtdC90YsuXCIpO1xuICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcihcIltQZXJzaXN0ZW5jZV0g0J7RiNC40LHQutCwINC/0YDQuCDRgdCx0YDQvtGB0LUg0YXRgNCw0L3QuNC70LjRiTpcIiwgZXJyb3IpO1xuICAgICAgICAgICAgdG9hc3QuZXJyb3IoXCLQntGI0LjQsdC60LAg0L7Rh9C40YHRgtC60Lgg0YXRgNCw0L3QuNC70LjRiSDRiNGA0LjRhNGC0L7Qsi5cIik7XG4gICAgICAgIH1cbiAgICB9LCBbY2xlYXJGb250TG9jYWxTdG9yYWdlXSk7XG5cbiAgICAvLyAtLS0g0KTRg9C90LrRhtC40Y8g0YHQvtGF0YDQsNC90LXQvdC40Y8g0L3QsNGB0YLRgNC+0LXQuiDRiNGA0LjRhNGC0LAg0LIgSW5kZXhlZERCIC0tLVxuICAgIGNvbnN0IHNhdmVGb250U2V0dGluZ3MgPSB1c2VDYWxsYmFjayhhc3luYyAoZm9udElkLCBzZXR0aW5ncykgPT4ge1xuICAgICAgICBpZiAoIWZvbnRJZCB8fCAhc2V0dGluZ3MpIHJldHVybjtcbiAgICAgICAgXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBhd2FpdCB1cGRhdGVGb250U2V0dGluZ3MoZm9udElkLCBzZXR0aW5ncyk7XG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKGBbUGVyc2lzdGVuY2VdINCe0YjQuNCx0LrQsCDRgdC+0YXRgNCw0L3QtdC90LjRjyDQvdCw0YHRgtGA0L7QtdC6INGI0YDQuNGE0YLQsCAke2ZvbnRJZH06YCwgZXJyb3IpO1xuICAgICAgICB9XG4gICAgfSwgW10pO1xuXG4gICAgLy8g0JLQvtC30LLRgNCw0YnQsNC10Lwg0YTRg9C90LrRhtC40Lgg0LTQu9GPINGD0L/RgNCw0LLQu9C10L3QuNGPINC/0LXRgNGB0LjRgdGC0LXQvdGC0L3QvtGB0YLRjNGOXG4gICAgcmV0dXJuIHtcbiAgICAgICAgc2F2ZVNlbGVjdGVkRm9udElkLFxuICAgICAgICBzYXZlTGFzdFZhcmlhYmxlU2V0dGluZ3MsXG4gICAgICAgIHNhdmVMYXN0UHJlc2V0TmFtZSxcbiAgICAgICAgY2xlYXJGb250TG9jYWxTdG9yYWdlLFxuICAgICAgICByZXNldFBlcnNpc3RlbmNlLFxuICAgICAgICBzYXZlRm9udFNldHRpbmdzXG4gICAgfTtcbn0gIl0sIm5hbWVzIjpbInVzZUVmZmVjdCIsInVzZUNhbGxiYWNrIiwidG9hc3QiLCJnZXRBbGxGb250cyIsImRlbGV0ZUFsbEZvbnRzREIiLCJ1cGRhdGVGb250U2V0dGluZ3MiLCJsb2FkRm9udEZhY2VJZk5lZWRlZCIsInJldm9rZU9iamVjdFVSTCIsIkZPTlRfU0VUVElOR1NfTFNfS0VZUyIsIkxBU1RfUFJFU0VUX05BTUUiLCJMQVNUX1ZBUklBQkxFX1NFVFRJTkdTIiwiU0VMRUNURURfRk9OVF9JRCIsInVzZUZvbnRQZXJzaXN0ZW5jZSIsInNldEZvbnRzIiwic2V0SXNMb2FkaW5nIiwic2V0SXNJbml0aWFsTG9hZENvbXBsZXRlIiwic2V0U2VsZWN0ZWRGb250IiwiaGFuZGxlVmFyaWFibGVTZXR0aW5nc0NoYW5nZSIsImFwcGx5UHJlc2V0U3R5bGUiLCJmb250cyIsInNlbGVjdGVkRm9udCIsImlzTW91bnRlZCIsImxvYWRJbml0aWFsRm9udHMiLCJjb25zb2xlIiwibG9nIiwic3RvcmVkRm9udHMiLCJsZW5ndGgiLCJwcm9jZXNzZWRGb250cyIsIlByb21pc2UiLCJhbGwiLCJtYXAiLCJmb250IiwiaWQiLCJmaWxlIiwiQmxvYiIsIndhcm4iLCJ1cmwiLCJVUkwiLCJjcmVhdGVPYmplY3RVUkwiLCJmb250RmFtaWx5VG9Mb2FkIiwiZm9udEZhbWlseSIsImluaXRpYWxWYXJTZXR0aW5ncyIsImlzVmFyaWFibGVGb250IiwidmFyaWFibGVBeGVzIiwiT2JqZWN0IiwiZW50cmllcyIsInJlZHVjZSIsImFjYyIsInRhZyIsImF4aXMiLCJkZWZhdWx0IiwidW5kZWZpbmVkIiwibGFzdFVzZWRQcmVzZXROYW1lIiwibGFzdFVzZWRWYXJpYWJsZVNldHRpbmdzIiwibG9hZEVycm9yIiwiZXJyb3IiLCJuYW1lIiwidmFsaWRGb250cyIsImZpbHRlciIsImYiLCJzdG9yZWRJZCIsImxvY2FsU3RvcmFnZSIsImdldEl0ZW0iLCJmb250VG9TZWxlY3QiLCJmaW5kIiwiZGlzcGxheU5hbWUiLCJyZW1vdmVJdGVtIiwic2V0SXRlbSIsInNldFRpbWVvdXQiLCJyZXN0b3JlZFZhclNldHRpbmdzUmF3IiwicmVzdG9yZWRQcmVzZXROYW1lIiwic2V0dGluZ3NBcHBsaWVkIiwicmVzdG9yZWRWYXJTZXR0aW5ncyIsIkpTT04iLCJwYXJzZSIsImUiLCJzYXZlU2VsZWN0ZWRGb250SWQiLCJmb250SWQiLCJzYXZlTGFzdFZhcmlhYmxlU2V0dGluZ3MiLCJzZXR0aW5ncyIsInN0cmluZ2lmeSIsInNhdmVMYXN0UHJlc2V0TmFtZSIsInByZXNldE5hbWUiLCJjbGVhckZvbnRMb2NhbFN0b3JhZ2UiLCJ2YWx1ZXMiLCJmb3JFYWNoIiwia2V5IiwicmVzZXRQZXJzaXN0ZW5jZSIsImluZm8iLCJzYXZlRm9udFNldHRpbmdzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./hooks/useFontPersistence.js\n"));

/***/ }),

/***/ "./hooks/useFontStyleManager.js":
/*!**************************************!*\
  !*** ./hooks/useFontStyleManager.js ***!
  \**************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   useFontStyleManager: function() { return /* binding */ useFontStyleManager; }\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"./node_modules/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _utils_fontUtilsCommon__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/fontUtilsCommon */ \"./utils/fontUtilsCommon.js\");\nvar _s = $RefreshSig$();\n\n\n/**\n * Хук для управления стилями шрифтов (пресетами).\n * \n * @param {Object} selectedFont - Текущий выбранный объект шрифта.\n * @param {Function} setSelectedFont - Функция для обновления состояния выбранного шрифта.\n * @param {Function} setFonts - Функция для обновления всего массива шрифтов (для сохранения lastUsedPresetName).\n * @param {Object} variableSettings - Текущие настройки вариативных осей (для чтения перед применением пресета).\n * @param {Function} applyVariableSettings - Функция из useVariableFontControls для применения настроек осей.\n * @param {Function} loadFontsourceStyleVariant - Функция из useFontLoader для потенциальной загрузки статических вариантов Fontsource (пока не используется напрямую в applyPresetStyle).\n * @param {Function} onPresetApplied - Колбэк, вызываемый после применения пресета для сохранения в IndexedDB.\n * @returns {{ applyPresetStyle: Function }} - Объект с функцией применения пресета.\n */ function useFontStyleManager(selectedFont, setSelectedFont, setFonts, variableSettings, applyVariableSettings, loadFontsourceStyleVariant, onPresetApplied) {\n    _s();\n    /**\n   * Применяет предустановленный стиль (пресет) для текущего или указанного шрифта.\n   * (Перенесено из useFontManager)\n   * \n   * @param {string} presetName - Имя пресета (например, 'Regular', 'Bold', 'Italic').\n   * @param {Object|null} font - Шрифт для применения (по умолчанию selectedFont).\n   */ const applyPresetStyle = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(async function(presetName) {\n        let font = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;\n        const fontToApply = font || selectedFont;\n        if (!fontToApply) return;\n        const presetInfo = _utils_fontUtilsCommon__WEBPACK_IMPORTED_MODULE_1__.PRESET_STYLES.find((p)=>p.name === presetName);\n        if (!presetInfo) {\n            console.warn('Пресет \"'.concat(presetName, '\" не найден.'));\n            return;\n        }\n        const { weight, style } = presetInfo;\n        console.log(\"[applyPresetStyle] Применяем пресет '\".concat(presetName, \"' (weight: \").concat(weight, \", style: \").concat(style, \") к шрифту '\").concat(fontToApply.name, \"' (ID: \").concat(fontToApply.id, \")\"));\n        // Внутренняя функция для обновления состояния selectedFont, если необходимо\n        const updateSelectedFontStateIfNeeded = ()=>{\n            // Обновляем selectedFont если:\n            // 1. Применяем стиль к текущему выбранному шрифту\n            // 2. selectedFont еще не установлен, но fontToApply есть (восстановление)\n            // 3. fontToApply - это тот шрифт, который должен стать selectedFont (при переключении)\n            if (selectedFont && fontToApply.id === selectedFont.id || !selectedFont && fontToApply || font && fontToApply.id === font.id) {\n                setSelectedFont((prevSelected)=>{\n                    // Случай 1: prevSelected есть и это тот же шрифт - обновляем его\n                    if (prevSelected && prevSelected.id === fontToApply.id) {\n                        console.log(\"[applyPresetStyle] Обновляем состояние selectedFont (\".concat(fontToApply.name, \") до weight: \").concat(weight, \", style: \").concat(style));\n                        return {\n                            ...prevSelected,\n                            currentWeight: weight,\n                            currentStyle: style\n                        };\n                    } else if (fontToApply) {\n                        console.log(\"[applyPresetStyle] Устанавливаем состояние selectedFont (\".concat(fontToApply.name, \") до weight: \").concat(weight, \", style: \").concat(style));\n                        return {\n                            ...fontToApply,\n                            currentWeight: weight,\n                            currentStyle: style\n                        };\n                    }\n                    return prevSelected; // Возвращаем старое состояние в остальных случаях\n                });\n            }\n        };\n        // Логика для невариативных Fontsource шрифтов\n        if (fontToApply.source === \"fontsource\" && !fontToApply.isVariableFont) {\n            var _fontToApply_loadedStyles;\n            // Проверяем, был ли стиль загружен ранее\n            const styleIsLoaded = (_fontToApply_loadedStyles = fontToApply.loadedStyles) === null || _fontToApply_loadedStyles === void 0 ? void 0 : _fontToApply_loadedStyles.some((s)=>s.weight === weight && s.style === style);\n            if (!styleIsLoaded) {\n                console.log(\"[applyPresetStyle] Загружаем стиль \".concat(presetName, \" для Fontsource \").concat(fontToApply.name));\n                // Загружаем нужный стиль\n                if (loadFontsourceStyleVariant) {\n                    try {\n                        loadFontsourceStyleVariant(fontToApply.name, weight, style, fontToApply);\n                    } catch (error) {\n                        console.error(\"[applyPresetStyle] Ошибка загрузки стиля \".concat(presetName, \":\"), error);\n                    }\n                }\n            }\n        } else if (fontToApply.isVariableFont) {\n            const currentAxes = fontToApply.variableAxes || {};\n            // Используем актуальные настройки из variableSettings (переданные в хук)\n            const currentFontSettings = variableSettings;\n            const newSettings = {\n                ...currentFontSettings\n            }; // Копируем текущие настройки\n            let settingsChanged = false;\n            // Обновляем 'wght', если ось существует\n            if (\"wght\" in currentAxes) {\n                // Применяем вес из пресета\n                if (newSettings.wght !== weight) {\n                    newSettings.wght = weight;\n                    settingsChanged = true;\n                }\n            }\n            // Обновляем 'ital' или 'slnt' в зависимости от стиля пресета\n            const targetItal = style === \"italic\" ? 1 : 0;\n            const slantAxis = typeof currentAxes.slnt === \"object\" ? currentAxes.slnt : undefined;\n            var _slantAxis_min, _slantAxis_default;\n            // Определяем целевое значение 'slnt'. Если стиль 'italic', используем min оси (или -15), иначе default (или 0)\n            const targetSlnt = style === \"italic\" ? (_slantAxis_min = slantAxis === null || slantAxis === void 0 ? void 0 : slantAxis.min) !== null && _slantAxis_min !== void 0 ? _slantAxis_min : -15 : (_slantAxis_default = slantAxis === null || slantAxis === void 0 ? void 0 : slantAxis.default) !== null && _slantAxis_default !== void 0 ? _slantAxis_default : 0;\n            if (\"ital\" in currentAxes) {\n                if (newSettings.ital !== targetItal) {\n                    newSettings.ital = targetItal;\n                    settingsChanged = true;\n                    // Если есть 'slnt', удаляем его, т.к. 'ital' имеет приоритет\n                    if (\"slnt\" in newSettings) delete newSettings.slnt;\n                }\n            } else if (\"slnt\" in currentAxes) {\n                if (newSettings.slnt !== targetSlnt) {\n                    newSettings.slnt = targetSlnt;\n                    settingsChanged = true;\n                    // Если есть 'ital', удаляем его (хотя не должно быть по логике выше)\n                    if (\"ital\" in newSettings) delete newSettings.ital;\n                }\n            }\n            // Если настройки осей изменились, вызываем applyVariableSettings\n            if (settingsChanged) {\n                console.log(\"[applyPresetStyle] Настройки изменились. Вызываем applyVariableSettings для \".concat(fontToApply.name, \":\"), newSettings);\n                // Передаем isFinalUpdate = true, и сам объект шрифта fontToApply\n                applyVariableSettings(newSettings, true, fontToApply);\n            } else {\n                console.log(\"[applyPresetStyle] Настройки вариативности для пресета '\".concat(presetName, \"' уже применены или не изменились.\"));\n            }\n        } else {\n            console.log(\"[applyPresetStyle] Применяем стиль \".concat(presetName, \" к статическому/другому типу шрифта: \").concat(fontToApply.name));\n        }\n        // ВАЖНО: Обновляем selectedFont для ВСЕХ типов шрифтов (только один раз в конце)\n        updateSelectedFontStateIfNeeded();\n        // Обновляем lastUsedPresetName в общем массиве шрифтов\n        // Это нужно делать всегда, независимо от того, изменились ли оси\n        setFonts((currentFonts)=>{\n            if (!Array.isArray(currentFonts)) {\n                console.warn(\"[applyPresetStyle] currentFonts не является массивом:\", currentFonts);\n                return currentFonts; // Возвращаем как есть, если не массив\n            }\n            return currentFonts.map((f)=>{\n                if (f.id === fontToApply.id) {\n                    console.log(\"[applyPresetStyle] Обновляем lastUsedPresetName для \".concat(f.name, \" на \").concat(presetName));\n                    // Для вариативных шрифтов НЕ сбрасываем lastUsedVariableSettings,\n                    // так как пресет может изменить оси, и мы хотим сохранить эти изменения\n                    if (fontToApply.isVariableFont) {\n                        return {\n                            ...f,\n                            lastUsedPresetName: presetName\n                        };\n                    } else {\n                        // Для статических шрифтов сбрасываем variableSettings и сохраняем пресет\n                        return {\n                            ...f,\n                            lastUsedPresetName: presetName,\n                            lastUsedVariableSettings: null\n                        };\n                    }\n                }\n                return f;\n            });\n        });\n        // Сохраняем настройки в IndexedDB через колбэк\n        if (onPresetApplied) {\n            const settingsToSave = {\n                lastUsedPresetName: presetName,\n                currentWeight: weight,\n                currentStyle: style\n            };\n            // Для статических шрифтов очищаем lastUsedVariableSettings\n            if (!fontToApply.isVariableFont) {\n                settingsToSave.lastUsedVariableSettings = null;\n            }\n            console.log(\"[applyPresetStyle] Сохраняем настройки в IndexedDB для \".concat(fontToApply.name, \":\"), settingsToSave);\n            onPresetApplied(fontToApply.id, settingsToSave);\n        }\n    }, [\n        selectedFont,\n        setSelectedFont,\n        setFonts,\n        variableSettings,\n        applyVariableSettings,\n        loadFontsourceStyleVariant,\n        onPresetApplied\n    ]); // Зависимости useCallback\n    return {\n        applyPresetStyle\n    };\n}\n_s(useFontStyleManager, \"ZgPq+ouA/z7DsHdDRSdZLJrCPgI=\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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O1lBQ25CLE1BQU0rQyxpQkFBaUI7Z0JBQ3JCRixvQkFBb0IzQztnQkFDcEJlLGVBQWVOO2dCQUNmTyxjQUFjTjtZQUNoQjtZQUVBLDJEQUEyRDtZQUMzRCxJQUFJLENBQUNSLFlBQVlnQixjQUFjLEVBQUU7Z0JBQy9CMkIsZUFBZUQsd0JBQXdCLEdBQUc7WUFDNUM7WUFFQXJDLFFBQVFJLEdBQUcsQ0FBQywwREFBMkUsT0FBakJULFlBQVlJLElBQUksRUFBQyxNQUFJdUM7WUFDM0YvQyxnQkFBZ0JJLFlBQVlVLEVBQUUsRUFBRWlDO1FBQ2xDO0lBRUYsR0FBRztRQUFDckQ7UUFBY0M7UUFBaUJDO1FBQVVDO1FBQWtCQztRQUF1QkM7UUFBNEJDO0tBQWdCLEdBQUcsMEJBQTBCO0lBRS9KLE9BQU87UUFDTEM7SUFDRjtBQUNGO0dBNUtnQlIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vaG9va3MvdXNlRm9udFN0eWxlTWFuYWdlci5qcz9iMjhjIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IHVzZUNhbGxiYWNrIH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IHsgUFJFU0VUX1NUWUxFUyB9IGZyb20gJy4uL3V0aWxzL2ZvbnRVdGlsc0NvbW1vbic7XG5cbi8qKlxuICog0KXRg9C6INC00LvRjyDRg9C/0YDQsNCy0LvQtdC90LjRjyDRgdGC0LjQu9GP0LzQuCDRiNGA0LjRhNGC0L7QsiAo0L/RgNC10YHQtdGC0LDQvNC4KS5cbiAqIFxuICogQHBhcmFtIHtPYmplY3R9IHNlbGVjdGVkRm9udCAtINCi0LXQutGD0YnQuNC5INCy0YvQsdGA0LDQvdC90YvQuSDQvtCx0YrQtdC60YIg0YjRgNC40YTRgtCwLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gc2V0U2VsZWN0ZWRGb250IC0g0KTRg9C90LrRhtC40Y8g0LTQu9GPINC+0LHQvdC+0LLQu9C10L3QuNGPINGB0L7RgdGC0L7Rj9C90LjRjyDQstGL0LHRgNCw0L3QvdC+0LPQviDRiNGA0LjRhNGC0LAuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBzZXRGb250cyAtINCk0YPQvdC60YbQuNGPINC00LvRjyDQvtCx0L3QvtCy0LvQtdC90LjRjyDQstGB0LXQs9C+INC80LDRgdGB0LjQstCwINGI0YDQuNGE0YLQvtCyICjQtNC70Y8g0YHQvtGF0YDQsNC90LXQvdC40Y8gbGFzdFVzZWRQcmVzZXROYW1lKS5cbiAqIEBwYXJhbSB7T2JqZWN0fSB2YXJpYWJsZVNldHRpbmdzIC0g0KLQtdC60YPRidC40LUg0L3QsNGB0YLRgNC+0LnQutC4INCy0LDRgNC40LDRgtC40LLQvdGL0YUg0L7RgdC10LkgKNC00LvRjyDRh9GC0LXQvdC40Y8g0L/QtdGA0LXQtCDQv9GA0LjQvNC10L3QtdC90LjQtdC8INC/0YDQtdGB0LXRgtCwKS5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGFwcGx5VmFyaWFibGVTZXR0aW5ncyAtINCk0YPQvdC60YbQuNGPINC40LcgdXNlVmFyaWFibGVGb250Q29udHJvbHMg0LTQu9GPINC/0YDQuNC80LXQvdC10L3QuNGPINC90LDRgdGC0YDQvtC10Log0L7RgdC10LkuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBsb2FkRm9udHNvdXJjZVN0eWxlVmFyaWFudCAtINCk0YPQvdC60YbQuNGPINC40LcgdXNlRm9udExvYWRlciDQtNC70Y8g0L/QvtGC0LXQvdGG0LjQsNC70YzQvdC+0Lkg0LfQsNCz0YDRg9C30LrQuCDRgdGC0LDRgtC40YfQtdGB0LrQuNGFINCy0LDRgNC40LDQvdGC0L7QsiBGb250c291cmNlICjQv9C+0LrQsCDQvdC1INC40YHQv9C+0LvRjNC30YPQtdGC0YHRjyDQvdCw0L/RgNGP0LzRg9GOINCyIGFwcGx5UHJlc2V0U3R5bGUpLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gb25QcmVzZXRBcHBsaWVkIC0g0JrQvtC70LHRjdC6LCDQstGL0LfRi9Cy0LDQtdC80YvQuSDQv9C+0YHQu9C1INC/0YDQuNC80LXQvdC10L3QuNGPINC/0YDQtdGB0LXRgtCwINC00LvRjyDRgdC+0YXRgNCw0L3QtdC90LjRjyDQsiBJbmRleGVkREIuXG4gKiBAcmV0dXJucyB7eyBhcHBseVByZXNldFN0eWxlOiBGdW5jdGlvbiB9fSAtINCe0LHRitC10LrRgiDRgSDRhNGD0L3QutGG0LjQtdC5INC/0YDQuNC80LXQvdC10L3QuNGPINC/0YDQtdGB0LXRgtCwLlxuICovXG5leHBvcnQgZnVuY3Rpb24gdXNlRm9udFN0eWxlTWFuYWdlcihcbiAgc2VsZWN0ZWRGb250LFxuICBzZXRTZWxlY3RlZEZvbnQsXG4gIHNldEZvbnRzLFxuICB2YXJpYWJsZVNldHRpbmdzLFxuICBhcHBseVZhcmlhYmxlU2V0dGluZ3MsXG4gIGxvYWRGb250c291cmNlU3R5bGVWYXJpYW50LFxuICBvblByZXNldEFwcGxpZWRcbikge1xuXG4gIC8qKlxuICAgKiDQn9GA0LjQvNC10L3Rj9C10YIg0L/RgNC10LTRg9GB0YLQsNC90L7QstC70LXQvdC90YvQuSDRgdGC0LjQu9GMICjQv9GA0LXRgdC10YIpINC00LvRjyDRgtC10LrRg9GJ0LXQs9C+INC40LvQuCDRg9C60LDQt9Cw0L3QvdC+0LPQviDRiNGA0LjRhNGC0LAuXG4gICAqICjQn9C10YDQtdC90LXRgdC10L3QviDQuNC3IHVzZUZvbnRNYW5hZ2VyKVxuICAgKiBcbiAgICogQHBhcmFtIHtzdHJpbmd9IHByZXNldE5hbWUgLSDQmNC80Y8g0L/RgNC10YHQtdGC0LAgKNC90LDQv9GA0LjQvNC10YAsICdSZWd1bGFyJywgJ0JvbGQnLCAnSXRhbGljJykuXG4gICAqIEBwYXJhbSB7T2JqZWN0fG51bGx9IGZvbnQgLSDQqNGA0LjRhNGCINC00LvRjyDQv9GA0LjQvNC10L3QtdC90LjRjyAo0L/QviDRg9C80L7Qu9GH0LDQvdC40Y4gc2VsZWN0ZWRGb250KS5cbiAgICovXG4gIGNvbnN0IGFwcGx5UHJlc2V0U3R5bGUgPSB1c2VDYWxsYmFjayhhc3luYyAocHJlc2V0TmFtZSwgZm9udCA9IG51bGwpID0+IHtcbiAgICBjb25zdCBmb250VG9BcHBseSA9IGZvbnQgfHwgc2VsZWN0ZWRGb250O1xuICAgIGlmICghZm9udFRvQXBwbHkpIHJldHVybjtcblxuICAgIGNvbnN0IHByZXNldEluZm8gPSBQUkVTRVRfU1RZTEVTLmZpbmQocCA9PiBwLm5hbWUgPT09IHByZXNldE5hbWUpO1xuICAgIGlmICghcHJlc2V0SW5mbykge1xuICAgICAgY29uc29sZS53YXJuKGDQn9GA0LXRgdC10YIgXCIke3ByZXNldE5hbWV9XCIg0L3QtSDQvdCw0LnQtNC10L0uYCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHsgd2VpZ2h0LCBzdHlsZSB9ID0gcHJlc2V0SW5mbztcbiAgICBjb25zb2xlLmxvZyhgW2FwcGx5UHJlc2V0U3R5bGVdINCf0YDQuNC80LXQvdGP0LXQvCDQv9GA0LXRgdC10YIgJyR7cHJlc2V0TmFtZX0nICh3ZWlnaHQ6ICR7d2VpZ2h0fSwgc3R5bGU6ICR7c3R5bGV9KSDQuiDRiNGA0LjRhNGC0YMgJyR7Zm9udFRvQXBwbHkubmFtZX0nIChJRDogJHtmb250VG9BcHBseS5pZH0pYCk7XG5cbiAgICAvLyDQktC90YPRgtGA0LXQvdC90Y/RjyDRhNGD0L3QutGG0LjRjyDQtNC70Y8g0L7QsdC90L7QstC70LXQvdC40Y8g0YHQvtGB0YLQvtGP0L3QuNGPIHNlbGVjdGVkRm9udCwg0LXRgdC70Lgg0L3QtdC+0LHRhdC+0LTQuNC80L5cbiAgICBjb25zdCB1cGRhdGVTZWxlY3RlZEZvbnRTdGF0ZUlmTmVlZGVkID0gKCkgPT4ge1xuICAgICAgLy8g0J7QsdC90L7QstC70Y/QtdC8IHNlbGVjdGVkRm9udCDQtdGB0LvQuDpcbiAgICAgIC8vIDEuINCf0YDQuNC80LXQvdGP0LXQvCDRgdGC0LjQu9GMINC6INGC0LXQutGD0YnQtdC80YMg0LLRi9Cx0YDQsNC90L3QvtC80YMg0YjRgNC40YTRgtGDXG4gICAgICAvLyAyLiBzZWxlY3RlZEZvbnQg0LXRidC1INC90LUg0YPRgdGC0LDQvdC+0LLQu9C10L0sINC90L4gZm9udFRvQXBwbHkg0LXRgdGC0YwgKNCy0L7RgdGB0YLQsNC90L7QstC70LXQvdC40LUpXG4gICAgICAvLyAzLiBmb250VG9BcHBseSAtINGN0YLQviDRgtC+0YIg0YjRgNC40YTRgiwg0LrQvtGC0L7RgNGL0Lkg0LTQvtC70LbQtdC9INGB0YLQsNGC0Ywgc2VsZWN0ZWRGb250ICjQv9GA0Lgg0L/QtdGA0LXQutC70Y7Rh9C10L3QuNC4KVxuICAgICAgaWYgKChzZWxlY3RlZEZvbnQgJiYgZm9udFRvQXBwbHkuaWQgPT09IHNlbGVjdGVkRm9udC5pZCkgfHwgXG4gICAgICAgICAgKCFzZWxlY3RlZEZvbnQgJiYgZm9udFRvQXBwbHkpIHx8XG4gICAgICAgICAgKGZvbnQgJiYgZm9udFRvQXBwbHkuaWQgPT09IGZvbnQuaWQpKSB7XG4gICAgICAgIHNldFNlbGVjdGVkRm9udChwcmV2U2VsZWN0ZWQgPT4ge1xuICAgICAgICAgIC8vINCh0LvRg9GH0LDQuSAxOiBwcmV2U2VsZWN0ZWQg0LXRgdGC0Ywg0Lgg0Y3RgtC+INGC0L7RgiDQttC1INGI0YDQuNGE0YIgLSDQvtCx0L3QvtCy0LvRj9C10Lwg0LXQs9C+XG4gICAgICAgICAgaWYgKHByZXZTZWxlY3RlZCAmJiBwcmV2U2VsZWN0ZWQuaWQgPT09IGZvbnRUb0FwcGx5LmlkKSB7XG4gICAgICAgICAgICAgY29uc29sZS5sb2coYFthcHBseVByZXNldFN0eWxlXSDQntCx0L3QvtCy0LvRj9C10Lwg0YHQvtGB0YLQvtGP0L3QuNC1IHNlbGVjdGVkRm9udCAoJHtmb250VG9BcHBseS5uYW1lfSkg0LTQviB3ZWlnaHQ6ICR7d2VpZ2h0fSwgc3R5bGU6ICR7c3R5bGV9YCk7XG4gICAgICAgICAgICAgcmV0dXJuIHsgLi4ucHJldlNlbGVjdGVkLCBjdXJyZW50V2VpZ2h0OiB3ZWlnaHQsIGN1cnJlbnRTdHlsZTogc3R5bGUgfTtcbiAgICAgICAgICB9XG4gICAgICAgICAgLy8g0KHQu9GD0YfQsNC5IDI6IHByZXZTZWxlY3RlZCDQvdC10YIg0LjQu9C4INGN0YLQviDQtNGA0YPQs9C+0Lkg0YjRgNC40YTRgiwg0L3QviBmb250VG9BcHBseSDQtdGB0YLRjCAtINGD0YHRgtCw0L3QsNCy0LvQuNCy0LDQtdC8IGZvbnRUb0FwcGx5INC60LDQuiBzZWxlY3RlZEZvbnRcbiAgICAgICAgICBlbHNlIGlmIChmb250VG9BcHBseSkge1xuICAgICAgICAgICAgIGNvbnNvbGUubG9nKGBbYXBwbHlQcmVzZXRTdHlsZV0g0KPRgdGC0LDQvdCw0LLQu9C40LLQsNC10Lwg0YHQvtGB0YLQvtGP0L3QuNC1IHNlbGVjdGVkRm9udCAoJHtmb250VG9BcHBseS5uYW1lfSkg0LTQviB3ZWlnaHQ6ICR7d2VpZ2h0fSwgc3R5bGU6ICR7c3R5bGV9YCk7XG4gICAgICAgICAgICAgcmV0dXJuIHsgLi4uZm9udFRvQXBwbHksIGN1cnJlbnRXZWlnaHQ6IHdlaWdodCwgY3VycmVudFN0eWxlOiBzdHlsZSB9O1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gcHJldlNlbGVjdGVkOyAvLyDQktC+0LfQstGA0LDRidCw0LXQvCDRgdGC0LDRgNC+0LUg0YHQvtGB0YLQvtGP0L3QuNC1INCyINC+0YHRgtCw0LvRjNC90YvRhSDRgdC70YPRh9Cw0Y/RhVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgLy8g0JvQvtCz0LjQutCwINC00LvRjyDQvdC10LLQsNGA0LjQsNGC0LjQstC90YvRhSBGb250c291cmNlINGI0YDQuNGE0YLQvtCyXG4gICAgaWYgKGZvbnRUb0FwcGx5LnNvdXJjZSA9PT0gJ2ZvbnRzb3VyY2UnICYmICFmb250VG9BcHBseS5pc1ZhcmlhYmxlRm9udCkge1xuICAgICAgLy8g0J/RgNC+0LLQtdGA0Y/QtdC8LCDQsdGL0Lsg0LvQuCDRgdGC0LjQu9GMINC30LDQs9GA0YPQttC10L0g0YDQsNC90LXQtVxuICAgICAgY29uc3Qgc3R5bGVJc0xvYWRlZCA9IGZvbnRUb0FwcGx5LmxvYWRlZFN0eWxlcz8uc29tZShzID0+IHMud2VpZ2h0ID09PSB3ZWlnaHQgJiYgcy5zdHlsZSA9PT0gc3R5bGUpO1xuICAgICAgaWYgKCFzdHlsZUlzTG9hZGVkKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKGBbYXBwbHlQcmVzZXRTdHlsZV0g0JfQsNCz0YDRg9C20LDQtdC8INGB0YLQuNC70YwgJHtwcmVzZXROYW1lfSDQtNC70Y8gRm9udHNvdXJjZSAke2ZvbnRUb0FwcGx5Lm5hbWV9YCk7XG4gICAgICAgIC8vINCX0LDQs9GA0YPQttCw0LXQvCDQvdGD0LbQvdGL0Lkg0YHRgtC40LvRjFxuICAgICAgICBpZiAobG9hZEZvbnRzb3VyY2VTdHlsZVZhcmlhbnQpIHtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgbG9hZEZvbnRzb3VyY2VTdHlsZVZhcmlhbnQoZm9udFRvQXBwbHkubmFtZSwgd2VpZ2h0LCBzdHlsZSwgZm9udFRvQXBwbHkpO1xuICAgICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKGBbYXBwbHlQcmVzZXRTdHlsZV0g0J7RiNC40LHQutCwINC30LDQs9GA0YPQt9C60Lgg0YHRgtC40LvRjyAke3ByZXNldE5hbWV9OmAsIGVycm9yKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgLy8g0JvQvtCz0LjQutCwINC00LvRjyDQstCw0YDQuNCw0YLQuNCy0L3Ri9GFINGI0YDQuNGE0YLQvtCyXG4gICAgZWxzZSBpZiAoZm9udFRvQXBwbHkuaXNWYXJpYWJsZUZvbnQpIHtcbiAgICAgIGNvbnN0IGN1cnJlbnRBeGVzID0gZm9udFRvQXBwbHkudmFyaWFibGVBeGVzIHx8IHt9O1xuICAgICAgLy8g0JjRgdC/0L7Qu9GM0LfRg9C10Lwg0LDQutGC0YPQsNC70YzQvdGL0LUg0L3QsNGB0YLRgNC+0LnQutC4INC40LcgdmFyaWFibGVTZXR0aW5ncyAo0L/QtdGA0LXQtNCw0L3QvdGL0LUg0LIg0YXRg9C6KVxuICAgICAgY29uc3QgY3VycmVudEZvbnRTZXR0aW5ncyA9IHZhcmlhYmxlU2V0dGluZ3M7IFxuICAgICAgY29uc3QgbmV3U2V0dGluZ3MgPSB7IC4uLmN1cnJlbnRGb250U2V0dGluZ3MgfTsgLy8g0JrQvtC/0LjRgNGD0LXQvCDRgtC10LrRg9GJ0LjQtSDQvdCw0YHRgtGA0L7QudC60LhcbiAgICAgIGxldCBzZXR0aW5nc0NoYW5nZWQgPSBmYWxzZTtcblxuICAgICAgLy8g0J7QsdC90L7QstC70Y/QtdC8ICd3Z2h0Jywg0LXRgdC70Lgg0L7RgdGMINGB0YPRidC10YHRgtCy0YPQtdGCXG4gICAgICBpZiAoJ3dnaHQnIGluIGN1cnJlbnRBeGVzKSB7XG4gICAgICAgIC8vINCf0YDQuNC80LXQvdGP0LXQvCDQstC10YEg0LjQtyDQv9GA0LXRgdC10YLQsFxuICAgICAgICBpZiAobmV3U2V0dGluZ3Mud2dodCAhPT0gd2VpZ2h0KSB7XG4gICAgICAgICAgbmV3U2V0dGluZ3Mud2dodCA9IHdlaWdodDtcbiAgICAgICAgICBzZXR0aW5nc0NoYW5nZWQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vINCe0LHQvdC+0LLQu9GP0LXQvCAnaXRhbCcg0LjQu9C4ICdzbG50JyDQsiDQt9Cw0LLQuNGB0LjQvNC+0YHRgtC4INC+0YIg0YHRgtC40LvRjyDQv9GA0LXRgdC10YLQsFxuICAgICAgY29uc3QgdGFyZ2V0SXRhbCA9IHN0eWxlID09PSAnaXRhbGljJyA/IDEgOiAwO1xuICAgICAgY29uc3Qgc2xhbnRBeGlzID0gdHlwZW9mIGN1cnJlbnRBeGVzLnNsbnQgPT09ICdvYmplY3QnID8gY3VycmVudEF4ZXMuc2xudCA6IHVuZGVmaW5lZDtcbiAgICAgIC8vINCe0L/RgNC10LTQtdC70Y/QtdC8INGG0LXQu9C10LLQvtC1INC30L3QsNGH0LXQvdC40LUgJ3NsbnQnLiDQldGB0LvQuCDRgdGC0LjQu9GMICdpdGFsaWMnLCDQuNGB0L/QvtC70YzQt9GD0LXQvCBtaW4g0L7RgdC4ICjQuNC70LggLTE1KSwg0LjQvdCw0YfQtSBkZWZhdWx0ICjQuNC70LggMClcbiAgICAgIGNvbnN0IHRhcmdldFNsbnQgPSBzdHlsZSA9PT0gJ2l0YWxpYycgPyAoc2xhbnRBeGlzPy5taW4gPz8gLTE1KSA6IChzbGFudEF4aXM/LmRlZmF1bHQgPz8gMCk7XG5cbiAgICAgIGlmICgnaXRhbCcgaW4gY3VycmVudEF4ZXMpIHsgLy8g0JXRgdC70Lgg0LXRgdGC0Ywg0L7RgdGMICdpdGFsJ1xuICAgICAgICBpZiAobmV3U2V0dGluZ3MuaXRhbCAhPT0gdGFyZ2V0SXRhbCkge1xuICAgICAgICAgIG5ld1NldHRpbmdzLml0YWwgPSB0YXJnZXRJdGFsO1xuICAgICAgICAgIHNldHRpbmdzQ2hhbmdlZCA9IHRydWU7XG4gICAgICAgICAgLy8g0JXRgdC70Lgg0LXRgdGC0YwgJ3NsbnQnLCDRg9C00LDQu9GP0LXQvCDQtdCz0L4sINGCLtC6LiAnaXRhbCcg0LjQvNC10LXRgiDQv9GA0LjQvtGA0LjRgtC10YJcbiAgICAgICAgICBpZiAoJ3NsbnQnIGluIG5ld1NldHRpbmdzKSBkZWxldGUgbmV3U2V0dGluZ3Muc2xudDsgXG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoJ3NsbnQnIGluIGN1cnJlbnRBeGVzKSB7IC8vINCY0L3QsNGH0LUsINC10YHQu9C4INC10YHRgtGMINC+0YHRjCAnc2xudCdcbiAgICAgICAgaWYgKG5ld1NldHRpbmdzLnNsbnQgIT09IHRhcmdldFNsbnQpIHtcbiAgICAgICAgICBuZXdTZXR0aW5ncy5zbG50ID0gdGFyZ2V0U2xudDtcbiAgICAgICAgICBzZXR0aW5nc0NoYW5nZWQgPSB0cnVlO1xuICAgICAgICAgICAvLyDQldGB0LvQuCDQtdGB0YLRjCAnaXRhbCcsINGD0LTQsNC70Y/QtdC8INC10LPQviAo0YXQvtGC0Y8g0L3QtSDQtNC+0LvQttC90L4g0LHRi9GC0Ywg0L/QviDQu9C+0LPQuNC60LUg0LLRi9GI0LUpXG4gICAgICAgICAgaWYgKCdpdGFsJyBpbiBuZXdTZXR0aW5ncykgZGVsZXRlIG5ld1NldHRpbmdzLml0YWw7IFxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vINCV0YHQu9C4INC90LDRgdGC0YDQvtC50LrQuCDQvtGB0LXQuSDQuNC30LzQtdC90LjQu9C40YHRjCwg0LLRi9C30YvQstCw0LXQvCBhcHBseVZhcmlhYmxlU2V0dGluZ3NcbiAgICAgIGlmIChzZXR0aW5nc0NoYW5nZWQpIHtcbiAgICAgICAgY29uc29sZS5sb2coYFthcHBseVByZXNldFN0eWxlXSDQndCw0YHRgtGA0L7QudC60Lgg0LjQt9C80LXQvdC40LvQuNGB0YwuINCS0YvQt9GL0LLQsNC10LwgYXBwbHlWYXJpYWJsZVNldHRpbmdzINC00LvRjyAke2ZvbnRUb0FwcGx5Lm5hbWV9OmAsIG5ld1NldHRpbmdzKTtcbiAgICAgICAgLy8g0J/QtdGA0LXQtNCw0LXQvCBpc0ZpbmFsVXBkYXRlID0gdHJ1ZSwg0Lgg0YHQsNC8INC+0LHRitC10LrRgiDRiNGA0LjRhNGC0LAgZm9udFRvQXBwbHlcbiAgICAgICAgYXBwbHlWYXJpYWJsZVNldHRpbmdzKG5ld1NldHRpbmdzLCB0cnVlLCBmb250VG9BcHBseSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zb2xlLmxvZyhgW2FwcGx5UHJlc2V0U3R5bGVdINCd0LDRgdGC0YDQvtC50LrQuCDQstCw0YDQuNCw0YLQuNCy0L3QvtGB0YLQuCDQtNC70Y8g0L/RgNC10YHQtdGC0LAgJyR7cHJlc2V0TmFtZX0nINGD0LbQtSDQv9GA0LjQvNC10L3QtdC90Ysg0LjQu9C4INC90LUg0LjQt9C80LXQvdC40LvQuNGB0YwuYCk7XG4gICAgICB9XG4gICAgfVxuICAgIC8vINCb0L7Qs9C40LrQsCDQtNC70Y8g0LTRgNGD0LPQuNGFINGC0LjQv9C+0LIg0YjRgNC40YTRgtC+0LIgKNC90LDQv9GA0LjQvNC10YAsINC70L7QutCw0LvRjNC90YvQtSDQvdC10LLQsNGA0LjQsNGC0LjQstC90YvQtSlcbiAgICBlbHNlIHtcbiAgICAgIGNvbnNvbGUubG9nKGBbYXBwbHlQcmVzZXRTdHlsZV0g0J/RgNC40LzQtdC90Y/QtdC8INGB0YLQuNC70YwgJHtwcmVzZXROYW1lfSDQuiDRgdGC0LDRgtC40YfQtdGB0LrQvtC80YMv0LTRgNGD0LPQvtC80YMg0YLQuNC/0YMg0YjRgNC40YTRgtCwOiAke2ZvbnRUb0FwcGx5Lm5hbWV9YCk7XG4gICAgfVxuXG4gICAgLy8g0JLQkNCW0J3Qnjog0J7QsdC90L7QstC70Y/QtdC8IHNlbGVjdGVkRm9udCDQtNC70Y8g0JLQodCV0KUg0YLQuNC/0L7QsiDRiNGA0LjRhNGC0L7QsiAo0YLQvtC70YzQutC+INC+0LTQuNC9INGA0LDQtyDQsiDQutC+0L3RhtC1KVxuICAgIHVwZGF0ZVNlbGVjdGVkRm9udFN0YXRlSWZOZWVkZWQoKTtcblxuICAgIC8vINCe0LHQvdC+0LLQu9GP0LXQvCBsYXN0VXNlZFByZXNldE5hbWUg0LIg0L7QsdGJ0LXQvCDQvNCw0YHRgdC40LLQtSDRiNGA0LjRhNGC0L7QslxuICAgIC8vINCt0YLQviDQvdGD0LbQvdC+INC00LXQu9Cw0YLRjCDQstGB0LXQs9C00LAsINC90LXQt9Cw0LLQuNGB0LjQvNC+INC+0YIg0YLQvtCz0L4sINC40LfQvNC10L3QuNC70LjRgdGMINC70Lgg0L7RgdC4XG4gICAgc2V0Rm9udHMoY3VycmVudEZvbnRzID0+IHtcbiAgICAgIGlmICghQXJyYXkuaXNBcnJheShjdXJyZW50Rm9udHMpKSB7XG4gICAgICAgIGNvbnNvbGUud2FybignW2FwcGx5UHJlc2V0U3R5bGVdIGN1cnJlbnRGb250cyDQvdC1INGP0LLQu9GP0LXRgtGB0Y8g0LzQsNGB0YHQuNCy0L7QvDonLCBjdXJyZW50Rm9udHMpO1xuICAgICAgICByZXR1cm4gY3VycmVudEZvbnRzOyAvLyDQktC+0LfQstGA0LDRidCw0LXQvCDQutCw0Log0LXRgdGC0YwsINC10YHQu9C4INC90LUg0LzQsNGB0YHQuNCyXG4gICAgICB9XG4gICAgICByZXR1cm4gY3VycmVudEZvbnRzLm1hcChmID0+IHtcbiAgICAgICAgaWYgKGYuaWQgPT09IGZvbnRUb0FwcGx5LmlkKSB7XG4gICAgICAgICAgY29uc29sZS5sb2coYFthcHBseVByZXNldFN0eWxlXSDQntCx0L3QvtCy0LvRj9C10LwgbGFzdFVzZWRQcmVzZXROYW1lINC00LvRjyAke2YubmFtZX0g0L3QsCAke3ByZXNldE5hbWV9YCk7XG4gICAgICAgICAgXG4gICAgICAgICAgLy8g0JTQu9GPINCy0LDRgNC40LDRgtC40LLQvdGL0YUg0YjRgNC40YTRgtC+0LIg0J3QlSDRgdCx0YDQsNGB0YvQstCw0LXQvCBsYXN0VXNlZFZhcmlhYmxlU2V0dGluZ3MsXG4gICAgICAgICAgLy8g0YLQsNC6INC60LDQuiDQv9GA0LXRgdC10YIg0LzQvtC20LXRgiDQuNC30LzQtdC90LjRgtGMINC+0YHQuCwg0Lgg0LzRiyDRhdC+0YLQuNC8INGB0L7RhdGA0LDQvdC40YLRjCDRjdGC0Lgg0LjQt9C80LXQvdC10L3QuNGPXG4gICAgICAgICAgaWYgKGZvbnRUb0FwcGx5LmlzVmFyaWFibGVGb250KSB7XG4gICAgICAgICAgICByZXR1cm4geyAuLi5mLCBsYXN0VXNlZFByZXNldE5hbWU6IHByZXNldE5hbWUgfTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8g0JTQu9GPINGB0YLQsNGC0LjRh9C10YHQutC40YUg0YjRgNC40YTRgtC+0LIg0YHQsdGA0LDRgdGL0LLQsNC10LwgdmFyaWFibGVTZXR0aW5ncyDQuCDRgdC+0YXRgNCw0L3Rj9C10Lwg0L/RgNC10YHQtdGCXG4gICAgICAgICAgICByZXR1cm4geyAuLi5mLCBsYXN0VXNlZFByZXNldE5hbWU6IHByZXNldE5hbWUsIGxhc3RVc2VkVmFyaWFibGVTZXR0aW5nczogbnVsbCB9O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZjtcbiAgICAgIH0pO1xuICAgIH0pO1xuXG4gICAgLy8g0KHQvtGF0YDQsNC90Y/QtdC8INC90LDRgdGC0YDQvtC50LrQuCDQsiBJbmRleGVkREIg0YfQtdGA0LXQtyDQutC+0LvQsdGN0LpcbiAgICBpZiAob25QcmVzZXRBcHBsaWVkKSB7XG4gICAgICBjb25zdCBzZXR0aW5nc1RvU2F2ZSA9IHtcbiAgICAgICAgbGFzdFVzZWRQcmVzZXROYW1lOiBwcmVzZXROYW1lLFxuICAgICAgICBjdXJyZW50V2VpZ2h0OiB3ZWlnaHQsXG4gICAgICAgIGN1cnJlbnRTdHlsZTogc3R5bGVcbiAgICAgIH07XG4gICAgICBcbiAgICAgIC8vINCU0LvRjyDRgdGC0LDRgtC40YfQtdGB0LrQuNGFINGI0YDQuNGE0YLQvtCyINC+0YfQuNGJ0LDQtdC8IGxhc3RVc2VkVmFyaWFibGVTZXR0aW5nc1xuICAgICAgaWYgKCFmb250VG9BcHBseS5pc1ZhcmlhYmxlRm9udCkge1xuICAgICAgICBzZXR0aW5nc1RvU2F2ZS5sYXN0VXNlZFZhcmlhYmxlU2V0dGluZ3MgPSBudWxsO1xuICAgICAgfVxuICAgICAgXG4gICAgICBjb25zb2xlLmxvZyhgW2FwcGx5UHJlc2V0U3R5bGVdINCh0L7RhdGA0LDQvdGP0LXQvCDQvdCw0YHRgtGA0L7QudC60Lgg0LIgSW5kZXhlZERCINC00LvRjyAke2ZvbnRUb0FwcGx5Lm5hbWV9OmAsIHNldHRpbmdzVG9TYXZlKTtcbiAgICAgIG9uUHJlc2V0QXBwbGllZChmb250VG9BcHBseS5pZCwgc2V0dGluZ3NUb1NhdmUpO1xuICAgIH1cblxuICB9LCBbc2VsZWN0ZWRGb250LCBzZXRTZWxlY3RlZEZvbnQsIHNldEZvbnRzLCB2YXJpYWJsZVNldHRpbmdzLCBhcHBseVZhcmlhYmxlU2V0dGluZ3MsIGxvYWRGb250c291cmNlU3R5bGVWYXJpYW50LCBvblByZXNldEFwcGxpZWRdKTsgLy8g0JfQsNCy0LjRgdC40LzQvtGB0YLQuCB1c2VDYWxsYmFja1xuXG4gIHJldHVybiB7XG4gICAgYXBwbHlQcmVzZXRTdHlsZSxcbiAgfTtcbn0gIl0sIm5hbWVzIjpbInVzZUNhbGxiYWNrIiwiUFJFU0VUX1NUWUxFUyIsInVzZUZvbnRTdHlsZU1hbmFnZXIiLCJzZWxlY3RlZEZvbnQiLCJzZXRTZWxlY3RlZEZvbnQiLCJzZXRGb250cyIsInZhcmlhYmxlU2V0dGluZ3MiLCJhcHBseVZhcmlhYmxlU2V0dGluZ3MiLCJsb2FkRm9udHNvdXJjZVN0eWxlVmFyaWFudCIsIm9uUHJlc2V0QXBwbGllZCIsImFwcGx5UHJlc2V0U3R5bGUiLCJwcmVzZXROYW1lIiwiZm9udCIsImZvbnRUb0FwcGx5IiwicHJlc2V0SW5mbyIsImZpbmQiLCJwIiwibmFtZSIsImNvbnNvbGUiLCJ3YXJuIiwid2VpZ2h0Iiwic3R5bGUiLCJsb2ciLCJpZCIsInVwZGF0ZVNlbGVjdGVkRm9udFN0YXRlSWZOZWVkZWQiLCJwcmV2U2VsZWN0ZWQiLCJjdXJyZW50V2VpZ2h0IiwiY3VycmVudFN0eWxlIiwic291cmNlIiwiaXNWYXJpYWJsZUZvbnQiLCJzdHlsZUlzTG9hZGVkIiwibG9hZGVkU3R5bGVzIiwic29tZSIsInMiLCJlcnJvciIsImN1cnJlbnRBeGVzIiwidmFyaWFibGVBeGVzIiwiY3VycmVudEZvbnRTZXR0aW5ncyIsIm5ld1NldHRpbmdzIiwic2V0dGluZ3NDaGFuZ2VkIiwid2dodCIsInRhcmdldEl0YWwiLCJzbGFudEF4aXMiLCJzbG50IiwidW5kZWZpbmVkIiwidGFyZ2V0U2xudCIsIm1pbiIsImRlZmF1bHQiLCJpdGFsIiwiY3VycmVudEZvbnRzIiwiQXJyYXkiLCJpc0FycmF5IiwibWFwIiwiZiIsImxhc3RVc2VkUHJlc2V0TmFtZSIsImxhc3RVc2VkVmFyaWFibGVTZXR0aW5ncyIsInNldHRpbmdzVG9TYXZlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./hooks/useFontStyleManager.js\n"));

/***/ }),

/***/ "./hooks/useVariableFontControls.js":
/*!******************************************!*\
  !*** ./hooks/useVariableFontControls.js ***!
  \******************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   useVariableFontControls: function() { return /* binding */ useVariableFontControls; }\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"./node_modules/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var react_toastify__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react-toastify */ \"./node_modules/react-toastify/dist/index.mjs\");\nvar _s = $RefreshSig$();\n\n\n// import opentype from 'opentype.js'; // opentype нужен для getVariableAxes, если парсим файл\n// Кэш для хранения метаданных шрифтов (перенесен из useFontManager)\nconst fontMetadataCache = new Map();\n/**\n * Хук для управления настройками вариативных шрифтов.\n * @param {Object} selectedFont - Текущий выбранный объект шрифта.\n * @param {Object} variableSettings - Текущие настройки вариативных осей.\n * @param {Function} setVariableSettings - Функция для обновления состояния настроек осей.\n * @param {Function} setSelectedFont - Функция для обновления состояния выбранного шрифта.\n * @param {Function} setFonts - Функция для обновления всего массива шрифтов (для сохранения lastUsedVariableSettings).\n * @param {Function} debouncedUpdateCssSettings - Debounced функция для обновления CSS (переименована из debouncedUpdateVariableFontSettings).\n * @param {Function} saveLastVariableSettings - Функция для сохранения настроек в localStorage.\n */ function useVariableFontControls(selectedFont, variableSettings, setVariableSettings, setSelectedFont, setFonts, debouncedUpdateCssSettings, saveLastVariableSettings) {\n    _s();\n    // Реф для applyVariableSettings, если он будет вызываться из других функций этого хука\n    const applyVariableSettingsRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    /**\n   * Применяет новые настройки к вариативному шрифту.\n   * (Перенесено из useFontManager, переименовано из handleVariableSettingsChange)\n   * @param {Object} newSettings - Новые значения осей.\n   * @param {boolean} isFinalUpdate - Флаг финального обновления (для CSS).\n   * @param {Object|null} font - Шрифт для применения (по умолчанию selectedFont).\n   */ const applyVariableSettings = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(function(newSettings) {\n        let isFinalUpdate = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false, font = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : null;\n        const fontToApply = font || selectedFont;\n        if (!fontToApply || !fontToApply.isVariableFont) return;\n        const prevSettings = {\n            ...variableSettings\n        }; // Сохраняем предыдущие для CSS\n        let hasChanges = false;\n        Object.keys(newSettings).forEach((tag)=>{\n            if (variableSettings[tag] !== newSettings[tag]) hasChanges = true;\n        });\n        if (!hasChanges && !isFinalUpdate) return; // Выходим если нет изменений И это не финальный апдейт (финальный может быть без изменений)\n        setVariableSettings((currentPrevSettings)=>({\n                ...currentPrevSettings,\n                ...newSettings\n            }));\n        const updatedSettings = {\n            ...variableSettings,\n            ...newSettings\n        };\n        // Обновляем объект selectedFont асинхронно\n        setSelectedFont((prevFont)=>{\n            if (!prevFont || prevFont.id !== fontToApply.id) return prevFont;\n            const variationSettingsStr = Object.entries(updatedSettings).map((param)=>{\n                let [tag, value] = param;\n                return '\"'.concat(tag, '\" ').concat(value);\n            }).join(\", \");\n            const updatedAxes = {\n                ...fontToApply.variableAxes\n            };\n            Object.entries(updatedSettings).forEach((param)=>{\n                let [tag, value] = param;\n                if (updatedAxes[tag]) {\n                    if (typeof updatedAxes[tag] === \"object\") {\n                        updatedAxes[tag] = {\n                            ...updatedAxes[tag],\n                            currentValue: value\n                        };\n                    } else {\n                        updatedAxes[tag] = {\n                            min: value * 0.5,\n                            max: value * 1.5,\n                            default: value,\n                            currentValue: value,\n                            name: tag.charAt(0).toUpperCase() + tag.slice(1)\n                        };\n                    }\n                }\n            });\n            return {\n                ...prevFont,\n                variableAxes: updatedAxes,\n                variationSettings: variationSettingsStr\n            };\n        });\n        // Обновляем CSS (если финальное изменение)\n        if (isFinalUpdate && typeof debouncedUpdateCssSettings === \"function\") {\n            // Передаем сам объект шрифта, актуальные и предыдущие настройки\n            debouncedUpdateCssSettings(fontToApply, updatedSettings, prevSettings);\n        }\n        // Сохраняем настройки в localStorage при финальном обновлении\n        if (isFinalUpdate && typeof saveLastVariableSettings === \"function\") {\n            console.log(\"[VarControls] Сохраняем настройки в localStorage:\", updatedSettings);\n            saveLastVariableSettings(updatedSettings);\n        }\n        // Обновляем lastUsedVariableSettings в общем массиве шрифтов\n        setFonts((currentFonts)=>currentFonts.map((f)=>{\n                if (f.id === fontToApply.id) {\n                    console.log(\"[VarControls] Обновляем lastUsedVariableSettings для \".concat(f.name, \":\"), updatedSettings);\n                    return {\n                        ...f,\n                        lastUsedVariableSettings: updatedSettings,\n                        lastUsedPresetName: null\n                    };\n                }\n                return f;\n            }));\n    }, [\n        selectedFont,\n        variableSettings,\n        setVariableSettings,\n        setSelectedFont,\n        setFonts,\n        debouncedUpdateCssSettings,\n        saveLastVariableSettings\n    ]);\n    // Обновляем реф при каждом изменении функции\n    applyVariableSettingsRef.current = applyVariableSettings;\n    /**\n   * Получает дефолтные значения осей для текущего шрифта.\n   * (Перенесено из useFontManager)\n   */ const getDefaultAxisValues = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(()=>{\n        if (!selectedFont || !selectedFont.variableAxes) return {};\n        const defaultSettings = {};\n        Object.entries(selectedFont.variableAxes).forEach((param)=>{\n            let [tag, axisData] = param;\n            if (typeof axisData === \"object\" && axisData.default !== undefined) {\n                defaultSettings[tag] = axisData.default;\n            } else if (typeof axisData === \"number\") {\n                defaultSettings[tag] = axisData; // Если вдруг ось - просто число\n            }\n        });\n        return defaultSettings;\n    }, [\n        selectedFont\n    ]);\n    /**\n   * Сбрасывает настройки осей к дефолтным значениям.\n   * (Перенесено из useFontManager)\n   */ const resetVariableSettings = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(()=>{\n        const defaultSettings = getDefaultAxisValues();\n        if (Object.keys(defaultSettings).length > 0) {\n            var // Используем applyVariableSettings через реф\n            _applyVariableSettingsRef_current;\n            (_applyVariableSettingsRef_current = applyVariableSettingsRef.current) === null || _applyVariableSettingsRef_current === void 0 ? void 0 : _applyVariableSettingsRef_current.call(applyVariableSettingsRef, defaultSettings, true); // isFinalUpdate = true для обновления CSS\n        }\n        return defaultSettings; // Возвращаем на всякий случай\n    }, [\n        getDefaultAxisValues\n    ]);\n    /**\n   * Извлекает информацию о вариативных осях шрифта.\n   * (Перенесено из useFontManager)\n   * TODO: Рассмотреть возможность использования opentype.js здесь или вынести в утилиты.\n   */ const getVariableAxesInfo = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(async (font)=>{\n        const targetFont = font || selectedFont;\n        if (!targetFont) return [];\n        const fontId = targetFont.id || null;\n        if (targetFont.isVariableFont === false) return [];\n        // 1. Используем существующие данные, если есть\n        if (targetFont.variableAxes && Object.keys(targetFont.variableAxes).length > 0) {\n            var _targetFont_supportedAxes;\n            const fontAxes = Object.entries(targetFont.variableAxes).map((param)=>{\n                let [tag, axisData] = param;\n                return {\n                    tag,\n                    name: axisData.name || tag,\n                    min: axisData.min,\n                    max: axisData.max,\n                    default: axisData.default,\n                    // Добавляем текущее значение для UI\n                    current: typeof axisData.currentValue !== \"undefined\" ? axisData.currentValue : axisData.default\n                };\n            });\n            // Фильтрация по supportedAxes (если есть)\n            let filteredAxes = fontAxes;\n            if (((_targetFont_supportedAxes = targetFont.supportedAxes) === null || _targetFont_supportedAxes === void 0 ? void 0 : _targetFont_supportedAxes.length) > 0) {\n                filteredAxes = fontAxes.filter((axis)=>targetFont.supportedAxes.includes(axis.tag));\n                if (filteredAxes.length === 0) filteredAxes = fontAxes; // Показать все, если фильтр ничего не дал\n            }\n            return filteredAxes;\n        }\n        // 2. Используем кэш\n        if (fontId && fontMetadataCache.has(fontId)) {\n            return fontMetadataCache.get(fontId);\n        }\n        // 3. Парсим файл (если есть и если opentype.js доступен)\n        // TODO: Добавить проверку на opentype.js и реализовать парсинг, если нужно\n        /*\n    if (targetFont.file instanceof Blob && typeof opentype !== 'undefined') {\n      try {\n        const fontData = await parseFontFile(targetFont.file); // Нужна функция parseFontFile\n        if (fontData?.tables?.fvar) {\n          const axes = fontData.tables.fvar.axes.map(axis => ({ ... }));\n          if (fontId) fontMetadataCache.set(fontId, axes);\n          return axes;\n        } else {\n          if (fontId) fontMetadataCache.set(fontId, []);\n          return [];\n        }\n      } catch (error) {\n        toast.error(`Ошибка парсинга шрифта: ${error.message}`);\n        return [];\n      }\n    }\n    */ console.warn(\"[VarControls] Не удалось получить оси для \".concat(targetFont.name, \". Нет данных в объекте или кэше, парсинг файла не реализован.\"));\n        return []; // Возвращаем пустой массив, если оси не найдены/не спарсены\n    }, [\n        selectedFont\n    ]); // Зависит только от selectedFont (для дефолта) и кэша\n    return {\n        applyVariableSettings,\n        getDefaultAxisValues,\n        resetVariableSettings,\n        getVariableAxesInfo\n    };\n}\n_s(useVariableFontControls, \"4E4CuCzByTsNQb4FktXlkRuxF4s=\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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RCxLQUFLekMsR0FBRztnQkFDakYsSUFBSXNDLGFBQWFMLE1BQU0sS0FBSyxHQUFHSyxlQUFlRCxVQUFVLDBDQUEwQztZQUN0RztZQUNBLE9BQU9DO1FBQ1Q7UUFFQSxvQkFBb0I7UUFDcEIsSUFBSUYsVUFBVTFELGtCQUFrQmlFLEdBQUcsQ0FBQ1AsU0FBUztZQUMzQyxPQUFPMUQsa0JBQWtCa0UsR0FBRyxDQUFDUjtRQUMvQjtRQUVBLHlEQUF5RDtRQUN6RCwyRUFBMkU7UUFDM0U7Ozs7Ozs7Ozs7Ozs7Ozs7O0lBaUJBLEdBRUFmLFFBQVF3QixJQUFJLENBQUMsNkNBQTZELE9BQWhCVixXQUFXbkIsSUFBSSxFQUFDO1FBQzFFLE9BQU8sRUFBRSxFQUFFLDREQUE0RDtJQUN6RSxHQUFHO1FBQUNuQztLQUFhLEdBQUcsc0RBQXNEO0lBRTFFLE9BQU87UUFDTFE7UUFDQXVDO1FBQ0FJO1FBQ0FFO0lBQ0Y7QUFDRjtHQXhMZ0J0RCIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ob29rcy91c2VWYXJpYWJsZUZvbnRDb250cm9scy5qcz9kN2U2Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IHVzZUNhbGxiYWNrLCB1c2VSZWYgfSBmcm9tICdyZWFjdCc7XG5pbXBvcnQgeyB0b2FzdCB9IGZyb20gJ3JlYWN0LXRvYXN0aWZ5Jztcbi8vIGltcG9ydCBvcGVudHlwZSBmcm9tICdvcGVudHlwZS5qcyc7IC8vIG9wZW50eXBlINC90YPQttC10L0g0LTQu9GPIGdldFZhcmlhYmxlQXhlcywg0LXRgdC70Lgg0L/QsNGA0YHQuNC8INGE0LDQudC7XG5cbi8vINCa0Y3RiCDQtNC70Y8g0YXRgNCw0L3QtdC90LjRjyDQvNC10YLQsNC00LDQvdC90YvRhSDRiNGA0LjRhNGC0L7QsiAo0L/QtdGA0LXQvdC10YHQtdC9INC40LcgdXNlRm9udE1hbmFnZXIpXG5jb25zdCBmb250TWV0YWRhdGFDYWNoZSA9IG5ldyBNYXAoKTtcblxuLyoqXG4gKiDQpdGD0Log0LTQu9GPINGD0L/RgNCw0LLQu9C10L3QuNGPINC90LDRgdGC0YDQvtC50LrQsNC80Lgg0LLQsNGA0LjQsNGC0LjQstC90YvRhSDRiNGA0LjRhNGC0L7Qsi5cbiAqIEBwYXJhbSB7T2JqZWN0fSBzZWxlY3RlZEZvbnQgLSDQotC10LrRg9GJ0LjQuSDQstGL0LHRgNCw0L3QvdGL0Lkg0L7QsdGK0LXQutGCINGI0YDQuNGE0YLQsC5cbiAqIEBwYXJhbSB7T2JqZWN0fSB2YXJpYWJsZVNldHRpbmdzIC0g0KLQtdC60YPRidC40LUg0L3QsNGB0YLRgNC+0LnQutC4INCy0LDRgNC40LDRgtC40LLQvdGL0YUg0L7RgdC10LkuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBzZXRWYXJpYWJsZVNldHRpbmdzIC0g0KTRg9C90LrRhtC40Y8g0LTQu9GPINC+0LHQvdC+0LLQu9C10L3QuNGPINGB0L7RgdGC0L7Rj9C90LjRjyDQvdCw0YHRgtGA0L7QtdC6INC+0YHQtdC5LlxuICogQHBhcmFtIHtGdW5jdGlvbn0gc2V0U2VsZWN0ZWRGb250IC0g0KTRg9C90LrRhtC40Y8g0LTQu9GPINC+0LHQvdC+0LLQu9C10L3QuNGPINGB0L7RgdGC0L7Rj9C90LjRjyDQstGL0LHRgNCw0L3QvdC+0LPQviDRiNGA0LjRhNGC0LAuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBzZXRGb250cyAtINCk0YPQvdC60YbQuNGPINC00LvRjyDQvtCx0L3QvtCy0LvQtdC90LjRjyDQstGB0LXQs9C+INC80LDRgdGB0LjQstCwINGI0YDQuNGE0YLQvtCyICjQtNC70Y8g0YHQvtGF0YDQsNC90LXQvdC40Y8gbGFzdFVzZWRWYXJpYWJsZVNldHRpbmdzKS5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGRlYm91bmNlZFVwZGF0ZUNzc1NldHRpbmdzIC0gRGVib3VuY2VkINGE0YPQvdC60YbQuNGPINC00LvRjyDQvtCx0L3QvtCy0LvQtdC90LjRjyBDU1MgKNC/0LXRgNC10LjQvNC10L3QvtCy0LDQvdCwINC40LcgZGVib3VuY2VkVXBkYXRlVmFyaWFibGVGb250U2V0dGluZ3MpLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gc2F2ZUxhc3RWYXJpYWJsZVNldHRpbmdzIC0g0KTRg9C90LrRhtC40Y8g0LTQu9GPINGB0L7RhdGA0LDQvdC10L3QuNGPINC90LDRgdGC0YDQvtC10Log0LIgbG9jYWxTdG9yYWdlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gdXNlVmFyaWFibGVGb250Q29udHJvbHMoXG4gIHNlbGVjdGVkRm9udCxcbiAgdmFyaWFibGVTZXR0aW5ncyxcbiAgc2V0VmFyaWFibGVTZXR0aW5ncyxcbiAgc2V0U2VsZWN0ZWRGb250LFxuICBzZXRGb250cyxcbiAgZGVib3VuY2VkVXBkYXRlQ3NzU2V0dGluZ3MsXG4gIHNhdmVMYXN0VmFyaWFibGVTZXR0aW5nc1xuKSB7XG5cbiAgLy8g0KDQtdGEINC00LvRjyBhcHBseVZhcmlhYmxlU2V0dGluZ3MsINC10YHQu9C4INC+0L0g0LHRg9C00LXRgiDQstGL0LfRi9Cy0LDRgtGM0YHRjyDQuNC3INC00YDRg9Cz0LjRhSDRhNGD0L3QutGG0LjQuSDRjdGC0L7Qs9C+INGF0YPQutCwXG4gIGNvbnN0IGFwcGx5VmFyaWFibGVTZXR0aW5nc1JlZiA9IHVzZVJlZihudWxsKTtcblxuICAvKipcbiAgICog0J/RgNC40LzQtdC90Y/QtdGCINC90L7QstGL0LUg0L3QsNGB0YLRgNC+0LnQutC4INC6INCy0LDRgNC40LDRgtC40LLQvdC+0LzRgyDRiNGA0LjRhNGC0YMuXG4gICAqICjQn9C10YDQtdC90LXRgdC10L3QviDQuNC3IHVzZUZvbnRNYW5hZ2VyLCDQv9C10YDQtdC40LzQtdC90L7QstCw0L3QviDQuNC3IGhhbmRsZVZhcmlhYmxlU2V0dGluZ3NDaGFuZ2UpXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBuZXdTZXR0aW5ncyAtINCd0L7QstGL0LUg0LfQvdCw0YfQtdC90LjRjyDQvtGB0LXQuS5cbiAgICogQHBhcmFtIHtib29sZWFufSBpc0ZpbmFsVXBkYXRlIC0g0KTQu9Cw0LMg0YTQuNC90LDQu9GM0L3QvtCz0L4g0L7QsdC90L7QstC70LXQvdC40Y8gKNC00LvRjyBDU1MpLlxuICAgKiBAcGFyYW0ge09iamVjdHxudWxsfSBmb250IC0g0KjRgNC40YTRgiDQtNC70Y8g0L/RgNC40LzQtdC90LXQvdC40Y8gKNC/0L4g0YPQvNC+0LvRh9Cw0L3QuNGOIHNlbGVjdGVkRm9udCkuXG4gICAqL1xuICBjb25zdCBhcHBseVZhcmlhYmxlU2V0dGluZ3MgPSB1c2VDYWxsYmFjaygobmV3U2V0dGluZ3MsIGlzRmluYWxVcGRhdGUgPSBmYWxzZSwgZm9udCA9IG51bGwpID0+IHtcbiAgICBjb25zdCBmb250VG9BcHBseSA9IGZvbnQgfHwgc2VsZWN0ZWRGb250O1xuICAgIGlmICghZm9udFRvQXBwbHkgfHwgIWZvbnRUb0FwcGx5LmlzVmFyaWFibGVGb250KSByZXR1cm47XG5cbiAgICBjb25zdCBwcmV2U2V0dGluZ3MgPSB7IC4uLnZhcmlhYmxlU2V0dGluZ3MgfTsgLy8g0KHQvtGF0YDQsNC90Y/QtdC8INC/0YDQtdC00YvQtNGD0YnQuNC1INC00LvRjyBDU1NcblxuICAgIGxldCBoYXNDaGFuZ2VzID0gZmFsc2U7XG4gICAgT2JqZWN0LmtleXMobmV3U2V0dGluZ3MpLmZvckVhY2godGFnID0+IHtcbiAgICAgIGlmICh2YXJpYWJsZVNldHRpbmdzW3RhZ10gIT09IG5ld1NldHRpbmdzW3RhZ10pIGhhc0NoYW5nZXMgPSB0cnVlO1xuICAgIH0pO1xuICAgIGlmICghaGFzQ2hhbmdlcyAmJiAhaXNGaW5hbFVwZGF0ZSkgcmV0dXJuOyAvLyDQktGL0YXQvtC00LjQvCDQtdGB0LvQuCDQvdC10YIg0LjQt9C80LXQvdC10L3QuNC5INCYINGN0YLQviDQvdC1INGE0LjQvdCw0LvRjNC90YvQuSDQsNC/0LTQtdC50YIgKNGE0LjQvdCw0LvRjNC90YvQuSDQvNC+0LbQtdGCINCx0YvRgtGMINCx0LXQtyDQuNC30LzQtdC90LXQvdC40LkpXG5cbiAgICBzZXRWYXJpYWJsZVNldHRpbmdzKGN1cnJlbnRQcmV2U2V0dGluZ3MgPT4gKHsgLi4uY3VycmVudFByZXZTZXR0aW5ncywgLi4ubmV3U2V0dGluZ3MgfSkpO1xuXG4gICAgY29uc3QgdXBkYXRlZFNldHRpbmdzID0geyAuLi52YXJpYWJsZVNldHRpbmdzLCAuLi5uZXdTZXR0aW5ncyB9O1xuXG4gICAgLy8g0J7QsdC90L7QstC70Y/QtdC8INC+0LHRitC10LrRgiBzZWxlY3RlZEZvbnQg0LDRgdC40L3RhdGA0L7QvdC90L5cbiAgICBzZXRTZWxlY3RlZEZvbnQocHJldkZvbnQgPT4ge1xuICAgICAgaWYgKCFwcmV2Rm9udCB8fCBwcmV2Rm9udC5pZCAhPT0gZm9udFRvQXBwbHkuaWQpIHJldHVybiBwcmV2Rm9udDtcblxuICAgICAgY29uc3QgdmFyaWF0aW9uU2V0dGluZ3NTdHIgPSBPYmplY3QuZW50cmllcyh1cGRhdGVkU2V0dGluZ3MpXG4gICAgICAgIC5tYXAoKFt0YWcsIHZhbHVlXSkgPT4gYFxcXCIke3RhZ31cXFwiICR7dmFsdWV9YClcbiAgICAgICAgLmpvaW4oJywgJyk7XG5cbiAgICAgIGNvbnN0IHVwZGF0ZWRBeGVzID0geyAuLi5mb250VG9BcHBseS52YXJpYWJsZUF4ZXMgfTtcbiAgICAgIE9iamVjdC5lbnRyaWVzKHVwZGF0ZWRTZXR0aW5ncykuZm9yRWFjaCgoW3RhZywgdmFsdWVdKSA9PiB7XG4gICAgICAgIGlmICh1cGRhdGVkQXhlc1t0YWddKSB7XG4gICAgICAgICAgaWYgKHR5cGVvZiB1cGRhdGVkQXhlc1t0YWddID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgdXBkYXRlZEF4ZXNbdGFnXSA9IHsgLi4udXBkYXRlZEF4ZXNbdGFnXSwgY3VycmVudFZhbHVlOiB2YWx1ZSB9O1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB1cGRhdGVkQXhlc1t0YWddID0geyBtaW46IHZhbHVlICogMC41LCBtYXg6IHZhbHVlICogMS41LCBkZWZhdWx0OiB2YWx1ZSwgY3VycmVudFZhbHVlOiB2YWx1ZSwgbmFtZTogdGFnLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsgdGFnLnNsaWNlKDEpIH07XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgcmV0dXJuIHsgLi4ucHJldkZvbnQsIHZhcmlhYmxlQXhlczogdXBkYXRlZEF4ZXMsIHZhcmlhdGlvblNldHRpbmdzOiB2YXJpYXRpb25TZXR0aW5nc1N0ciB9O1xuICAgIH0pO1xuXG4gICAgLy8g0J7QsdC90L7QstC70Y/QtdC8IENTUyAo0LXRgdC70Lgg0YTQuNC90LDQu9GM0L3QvtC1INC40LfQvNC10L3QtdC90LjQtSlcbiAgICBpZiAoaXNGaW5hbFVwZGF0ZSAmJiB0eXBlb2YgZGVib3VuY2VkVXBkYXRlQ3NzU2V0dGluZ3MgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAvLyDQn9C10YDQtdC00LDQtdC8INGB0LDQvCDQvtCx0YrQtdC60YIg0YjRgNC40YTRgtCwLCDQsNC60YLRg9Cw0LvRjNC90YvQtSDQuCDQv9GA0LXQtNGL0LTRg9GJ0LjQtSDQvdCw0YHRgtGA0L7QudC60LhcbiAgICAgIGRlYm91bmNlZFVwZGF0ZUNzc1NldHRpbmdzKGZvbnRUb0FwcGx5LCB1cGRhdGVkU2V0dGluZ3MsIHByZXZTZXR0aW5ncyk7XG4gICAgfVxuXG4gICAgLy8g0KHQvtGF0YDQsNC90Y/QtdC8INC90LDRgdGC0YDQvtC50LrQuCDQsiBsb2NhbFN0b3JhZ2Ug0L/RgNC4INGE0LjQvdCw0LvRjNC90L7QvCDQvtCx0L3QvtCy0LvQtdC90LjQuFxuICAgIGlmIChpc0ZpbmFsVXBkYXRlICYmIHR5cGVvZiBzYXZlTGFzdFZhcmlhYmxlU2V0dGluZ3MgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGNvbnNvbGUubG9nKGBbVmFyQ29udHJvbHNdINCh0L7RhdGA0LDQvdGP0LXQvCDQvdCw0YHRgtGA0L7QudC60Lgg0LIgbG9jYWxTdG9yYWdlOmAsIHVwZGF0ZWRTZXR0aW5ncyk7XG4gICAgICBzYXZlTGFzdFZhcmlhYmxlU2V0dGluZ3ModXBkYXRlZFNldHRpbmdzKTtcbiAgICB9XG5cbiAgICAvLyDQntCx0L3QvtCy0LvRj9C10LwgbGFzdFVzZWRWYXJpYWJsZVNldHRpbmdzINCyINC+0LHRidC10Lwg0LzQsNGB0YHQuNCy0LUg0YjRgNC40YTRgtC+0LJcbiAgICBzZXRGb250cyhjdXJyZW50Rm9udHMgPT4gY3VycmVudEZvbnRzLm1hcChmID0+IHtcbiAgICAgIGlmIChmLmlkID09PSBmb250VG9BcHBseS5pZCkge1xuICAgICAgICBjb25zb2xlLmxvZyhgW1ZhckNvbnRyb2xzXSDQntCx0L3QvtCy0LvRj9C10LwgbGFzdFVzZWRWYXJpYWJsZVNldHRpbmdzINC00LvRjyAke2YubmFtZX06YCwgdXBkYXRlZFNldHRpbmdzKTtcbiAgICAgICAgcmV0dXJuIHsgLi4uZiwgbGFzdFVzZWRWYXJpYWJsZVNldHRpbmdzOiB1cGRhdGVkU2V0dGluZ3MsIGxhc3RVc2VkUHJlc2V0TmFtZTogbnVsbCB9O1xuICAgICAgfVxuICAgICAgcmV0dXJuIGY7XG4gICAgfSkpO1xuXG4gIH0sIFtzZWxlY3RlZEZvbnQsIHZhcmlhYmxlU2V0dGluZ3MsIHNldFZhcmlhYmxlU2V0dGluZ3MsIHNldFNlbGVjdGVkRm9udCwgc2V0Rm9udHMsIGRlYm91bmNlZFVwZGF0ZUNzc1NldHRpbmdzLCBzYXZlTGFzdFZhcmlhYmxlU2V0dGluZ3NdKTtcblxuICAvLyDQntCx0L3QvtCy0LvRj9C10Lwg0YDQtdGEINC/0YDQuCDQutCw0LbQtNC+0Lwg0LjQt9C80LXQvdC10L3QuNC4INGE0YPQvdC60YbQuNC4XG4gIGFwcGx5VmFyaWFibGVTZXR0aW5nc1JlZi5jdXJyZW50ID0gYXBwbHlWYXJpYWJsZVNldHRpbmdzO1xuXG4gIC8qKlxuICAgKiDQn9C+0LvRg9GH0LDQtdGCINC00LXRhNC+0LvRgtC90YvQtSDQt9C90LDRh9C10L3QuNGPINC+0YHQtdC5INC00LvRjyDRgtC10LrRg9GJ0LXQs9C+INGI0YDQuNGE0YLQsC5cbiAgICogKNCf0LXRgNC10L3QtdGB0LXQvdC+INC40LcgdXNlRm9udE1hbmFnZXIpXG4gICAqL1xuICBjb25zdCBnZXREZWZhdWx0QXhpc1ZhbHVlcyA9IHVzZUNhbGxiYWNrKCgpID0+IHtcbiAgICBpZiAoIXNlbGVjdGVkRm9udCB8fCAhc2VsZWN0ZWRGb250LnZhcmlhYmxlQXhlcykgcmV0dXJuIHt9O1xuICAgIFxuICAgIGNvbnN0IGRlZmF1bHRTZXR0aW5ncyA9IHt9O1xuICAgIE9iamVjdC5lbnRyaWVzKHNlbGVjdGVkRm9udC52YXJpYWJsZUF4ZXMpLmZvckVhY2goKFt0YWcsIGF4aXNEYXRhXSkgPT4ge1xuICAgICAgaWYgKHR5cGVvZiBheGlzRGF0YSA9PT0gJ29iamVjdCcgJiYgYXhpc0RhdGEuZGVmYXVsdCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGRlZmF1bHRTZXR0aW5nc1t0YWddID0gYXhpc0RhdGEuZGVmYXVsdDtcbiAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGF4aXNEYXRhID09PSAnbnVtYmVyJykge1xuICAgICAgICBkZWZhdWx0U2V0dGluZ3NbdGFnXSA9IGF4aXNEYXRhOyAvLyDQldGB0LvQuCDQstC00YDRg9CzINC+0YHRjCAtINC/0YDQvtGB0YLQviDRh9C40YHQu9C+XG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIGRlZmF1bHRTZXR0aW5ncztcbiAgfSwgW3NlbGVjdGVkRm9udF0pO1xuXG4gIC8qKlxuICAgKiDQodCx0YDQsNGB0YvQstCw0LXRgiDQvdCw0YHRgtGA0L7QudC60Lgg0L7RgdC10Lkg0Log0LTQtdGE0L7Qu9GC0L3Ri9C8INC30L3QsNGH0LXQvdC40Y/QvC5cbiAgICogKNCf0LXRgNC10L3QtdGB0LXQvdC+INC40LcgdXNlRm9udE1hbmFnZXIpXG4gICAqL1xuICBjb25zdCByZXNldFZhcmlhYmxlU2V0dGluZ3MgPSB1c2VDYWxsYmFjaygoKSA9PiB7XG4gICAgY29uc3QgZGVmYXVsdFNldHRpbmdzID0gZ2V0RGVmYXVsdEF4aXNWYWx1ZXMoKTtcbiAgICBpZiAoT2JqZWN0LmtleXMoZGVmYXVsdFNldHRpbmdzKS5sZW5ndGggPiAwKSB7XG4gICAgICAvLyDQmNGB0L/QvtC70YzQt9GD0LXQvCBhcHBseVZhcmlhYmxlU2V0dGluZ3Mg0YfQtdGA0LXQtyDRgNC10YRcbiAgICAgIGFwcGx5VmFyaWFibGVTZXR0aW5nc1JlZi5jdXJyZW50Py4oZGVmYXVsdFNldHRpbmdzLCB0cnVlKTsgLy8gaXNGaW5hbFVwZGF0ZSA9IHRydWUg0LTQu9GPINC+0LHQvdC+0LLQu9C10L3QuNGPIENTU1xuICAgIH1cbiAgICByZXR1cm4gZGVmYXVsdFNldHRpbmdzOyAvLyDQktC+0LfQstGA0LDRidCw0LXQvCDQvdCwINCy0YHRj9C60LjQuSDRgdC70YPRh9Cw0LlcbiAgfSwgW2dldERlZmF1bHRBeGlzVmFsdWVzXSk7XG5cbiAgLyoqXG4gICAqINCY0LfQstC70LXQutCw0LXRgiDQuNC90YTQvtGA0LzQsNGG0LjRjiDQviDQstCw0YDQuNCw0YLQuNCy0L3Ri9GFINC+0YHRj9GFINGI0YDQuNGE0YLQsC5cbiAgICogKNCf0LXRgNC10L3QtdGB0LXQvdC+INC40LcgdXNlRm9udE1hbmFnZXIpXG4gICAqIFRPRE86INCg0LDRgdGB0LzQvtGC0YDQtdGC0Ywg0LLQvtC30LzQvtC20L3QvtGB0YLRjCDQuNGB0L/QvtC70YzQt9C+0LLQsNC90LjRjyBvcGVudHlwZS5qcyDQt9C00LXRgdGMINC40LvQuCDQstGL0L3QtdGB0YLQuCDQsiDRg9GC0LjQu9C40YLRiy5cbiAgICovXG4gIGNvbnN0IGdldFZhcmlhYmxlQXhlc0luZm8gPSB1c2VDYWxsYmFjayhhc3luYyAoZm9udCkgPT4ge1xuICAgIGNvbnN0IHRhcmdldEZvbnQgPSBmb250IHx8IHNlbGVjdGVkRm9udDtcbiAgICBpZiAoIXRhcmdldEZvbnQpIHJldHVybiBbXTtcblxuICAgIGNvbnN0IGZvbnRJZCA9IHRhcmdldEZvbnQuaWQgfHwgbnVsbDtcblxuICAgIGlmICh0YXJnZXRGb250LmlzVmFyaWFibGVGb250ID09PSBmYWxzZSkgcmV0dXJuIFtdO1xuXG4gICAgLy8gMS4g0JjRgdC/0L7Qu9GM0LfRg9C10Lwg0YHRg9GJ0LXRgdGC0LLRg9GO0YnQuNC1INC00LDQvdC90YvQtSwg0LXRgdC70Lgg0LXRgdGC0YxcbiAgICBpZiAodGFyZ2V0Rm9udC52YXJpYWJsZUF4ZXMgJiYgT2JqZWN0LmtleXModGFyZ2V0Rm9udC52YXJpYWJsZUF4ZXMpLmxlbmd0aCA+IDApIHtcbiAgICAgIGNvbnN0IGZvbnRBeGVzID0gT2JqZWN0LmVudHJpZXModGFyZ2V0Rm9udC52YXJpYWJsZUF4ZXMpLm1hcCgoW3RhZywgYXhpc0RhdGFdKSA9PiAoe1xuICAgICAgICB0YWcsXG4gICAgICAgIG5hbWU6IGF4aXNEYXRhLm5hbWUgfHwgdGFnLFxuICAgICAgICBtaW46IGF4aXNEYXRhLm1pbixcbiAgICAgICAgbWF4OiBheGlzRGF0YS5tYXgsXG4gICAgICAgIGRlZmF1bHQ6IGF4aXNEYXRhLmRlZmF1bHQsXG4gICAgICAgIC8vINCU0L7QsdCw0LLQu9GP0LXQvCDRgtC10LrRg9GJ0LXQtSDQt9C90LDRh9C10L3QuNC1INC00LvRjyBVSVxuICAgICAgICBjdXJyZW50OiB0eXBlb2YgYXhpc0RhdGEuY3VycmVudFZhbHVlICE9PSAndW5kZWZpbmVkJyA/IGF4aXNEYXRhLmN1cnJlbnRWYWx1ZSA6IGF4aXNEYXRhLmRlZmF1bHRcbiAgICAgIH0pKTtcbiAgICAgIC8vINCk0LjQu9GM0YLRgNCw0YbQuNGPINC/0L4gc3VwcG9ydGVkQXhlcyAo0LXRgdC70Lgg0LXRgdGC0YwpXG4gICAgICBsZXQgZmlsdGVyZWRBeGVzID0gZm9udEF4ZXM7XG4gICAgICBpZiAodGFyZ2V0Rm9udC5zdXBwb3J0ZWRBeGVzPy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgZmlsdGVyZWRBeGVzID0gZm9udEF4ZXMuZmlsdGVyKGF4aXMgPT4gdGFyZ2V0Rm9udC5zdXBwb3J0ZWRBeGVzLmluY2x1ZGVzKGF4aXMudGFnKSk7XG4gICAgICAgICAgaWYgKGZpbHRlcmVkQXhlcy5sZW5ndGggPT09IDApIGZpbHRlcmVkQXhlcyA9IGZvbnRBeGVzOyAvLyDQn9C+0LrQsNC30LDRgtGMINCy0YHQtSwg0LXRgdC70Lgg0YTQuNC70YzRgtGAINC90LjRh9C10LPQviDQvdC1INC00LDQu1xuICAgICAgfVxuICAgICAgcmV0dXJuIGZpbHRlcmVkQXhlcztcbiAgICB9XG5cbiAgICAvLyAyLiDQmNGB0L/QvtC70YzQt9GD0LXQvCDQutGN0YhcbiAgICBpZiAoZm9udElkICYmIGZvbnRNZXRhZGF0YUNhY2hlLmhhcyhmb250SWQpKSB7XG4gICAgICByZXR1cm4gZm9udE1ldGFkYXRhQ2FjaGUuZ2V0KGZvbnRJZCk7XG4gICAgfVxuXG4gICAgLy8gMy4g0J/QsNGA0YHQuNC8INGE0LDQudC7ICjQtdGB0LvQuCDQtdGB0YLRjCDQuCDQtdGB0LvQuCBvcGVudHlwZS5qcyDQtNC+0YHRgtGD0L/QtdC9KVxuICAgIC8vIFRPRE86INCU0L7QsdCw0LLQuNGC0Ywg0L/RgNC+0LLQtdGA0LrRgyDQvdCwIG9wZW50eXBlLmpzINC4INGA0LXQsNC70LjQt9C+0LLQsNGC0Ywg0L/QsNGA0YHQuNC90LMsINC10YHQu9C4INC90YPQttC90L5cbiAgICAvKlxuICAgIGlmICh0YXJnZXRGb250LmZpbGUgaW5zdGFuY2VvZiBCbG9iICYmIHR5cGVvZiBvcGVudHlwZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IGZvbnREYXRhID0gYXdhaXQgcGFyc2VGb250RmlsZSh0YXJnZXRGb250LmZpbGUpOyAvLyDQndGD0LbQvdCwINGE0YPQvdC60YbQuNGPIHBhcnNlRm9udEZpbGVcbiAgICAgICAgaWYgKGZvbnREYXRhPy50YWJsZXM/LmZ2YXIpIHtcbiAgICAgICAgICBjb25zdCBheGVzID0gZm9udERhdGEudGFibGVzLmZ2YXIuYXhlcy5tYXAoYXhpcyA9PiAoeyAuLi4gfSkpO1xuICAgICAgICAgIGlmIChmb250SWQpIGZvbnRNZXRhZGF0YUNhY2hlLnNldChmb250SWQsIGF4ZXMpO1xuICAgICAgICAgIHJldHVybiBheGVzO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmIChmb250SWQpIGZvbnRNZXRhZGF0YUNhY2hlLnNldChmb250SWQsIFtdKTtcbiAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIHRvYXN0LmVycm9yKGDQntGI0LjQsdC60LAg0L/QsNGA0YHQuNC90LPQsCDRiNGA0LjRhNGC0LA6ICR7ZXJyb3IubWVzc2FnZX1gKTtcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgfVxuICAgIH1cbiAgICAqL1xuXG4gICAgY29uc29sZS53YXJuKGBbVmFyQ29udHJvbHNdINCd0LUg0YPQtNCw0LvQvtGB0Ywg0L/QvtC70YPRh9C40YLRjCDQvtGB0Lgg0LTQu9GPICR7dGFyZ2V0Rm9udC5uYW1lfS4g0J3QtdGCINC00LDQvdC90YvRhSDQsiDQvtCx0YrQtdC60YLQtSDQuNC70Lgg0LrRjdGI0LUsINC/0LDRgNGB0LjQvdCzINGE0LDQudC70LAg0L3QtSDRgNC10LDQu9C40LfQvtCy0LDQvS5gKTtcbiAgICByZXR1cm4gW107IC8vINCS0L7Qt9Cy0YDQsNGJ0LDQtdC8INC/0YPRgdGC0L7QuSDQvNCw0YHRgdC40LIsINC10YHQu9C4INC+0YHQuCDQvdC1INC90LDQudC00LXQvdGLL9C90LUg0YHQv9Cw0YDRgdC10L3Ri1xuICB9LCBbc2VsZWN0ZWRGb250XSk7IC8vINCX0LDQstC40YHQuNGCINGC0L7Qu9GM0LrQviDQvtGCIHNlbGVjdGVkRm9udCAo0LTQu9GPINC00LXRhNC+0LvRgtCwKSDQuCDQutGN0YjQsFxuXG4gIHJldHVybiB7XG4gICAgYXBwbHlWYXJpYWJsZVNldHRpbmdzLFxuICAgIGdldERlZmF1bHRBeGlzVmFsdWVzLFxuICAgIHJlc2V0VmFyaWFibGVTZXR0aW5ncyxcbiAgICBnZXRWYXJpYWJsZUF4ZXNJbmZvLCAvLyDQn9C10YDQtdC40LzQtdC90L7QstCw0L3QviDQuNC3IGdldFZhcmlhYmxlQXhlc1xuICB9O1xufSAiXSwibmFtZXMiOlsidXNlQ2FsbGJhY2siLCJ1c2VSZWYiLCJ0b2FzdCIsImZvbnRNZXRhZGF0YUNhY2hlIiwiTWFwIiwidXNlVmFyaWFibGVGb250Q29udHJvbHMiLCJzZWxlY3RlZEZvbnQiLCJ2YXJpYWJsZVNldHRpbmdzIiwic2V0VmFyaWFibGVTZXR0aW5ncyIsInNldFNlbGVjdGVkRm9udCIsInNldEZvbnRzIiwiZGVib3VuY2VkVXBkYXRlQ3NzU2V0dGluZ3MiLCJzYXZlTGFzdFZhcmlhYmxlU2V0dGluZ3MiLCJhcHBseVZhcmlhYmxlU2V0dGluZ3NSZWYiLCJhcHBseVZhcmlhYmxlU2V0dGluZ3MiLCJuZXdTZXR0aW5ncyIsImlzRmluYWxVcGRhdGUiLCJmb250IiwiZm9udFRvQXBwbHkiLCJpc1ZhcmlhYmxlRm9udCIsInByZXZTZXR0aW5ncyIsImhhc0NoYW5nZXMiLCJPYmplY3QiLCJrZXlzIiwiZm9yRWFjaCIsInRhZyIsImN1cnJlbnRQcmV2U2V0dGluZ3MiLCJ1cGRhdGVkU2V0dGluZ3MiLCJwcmV2Rm9udCIsImlkIiwidmFyaWF0aW9uU2V0dGluZ3NTdHIiLCJlbnRyaWVzIiwibWFwIiwidmFsdWUiLCJqb2luIiwidXBkYXRlZEF4ZXMiLCJ2YXJpYWJsZUF4ZXMiLCJjdXJyZW50VmFsdWUiLCJtaW4iLCJtYXgiLCJkZWZhdWx0IiwibmFtZSIsImNoYXJBdCIsInRvVXBwZXJDYXNlIiwic2xpY2UiLCJ2YXJpYXRpb25TZXR0aW5ncyIsImNvbnNvbGUiLCJsb2ciLCJjdXJyZW50Rm9udHMiLCJmIiwibGFzdFVzZWRWYXJpYWJsZVNldHRpbmdzIiwibGFzdFVzZWRQcmVzZXROYW1lIiwiY3VycmVudCIsImdldERlZmF1bHRBeGlzVmFsdWVzIiwiZGVmYXVsdFNldHRpbmdzIiwiYXhpc0RhdGEiLCJ1bmRlZmluZWQiLCJyZXNldFZhcmlhYmxlU2V0dGluZ3MiLCJsZW5ndGgiLCJnZXRWYXJpYWJsZUF4ZXNJbmZvIiwidGFyZ2V0Rm9udCIsImZvbnRJZCIsImZvbnRBeGVzIiwiZmlsdGVyZWRBeGVzIiwic3VwcG9ydGVkQXhlcyIsImZpbHRlciIsImF4aXMiLCJpbmNsdWRlcyIsImhhcyIsImdldCIsIndhcm4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./hooks/useVariableFontControls.js\n"));

/***/ }),

/***/ "./pages/_app.jsx":
/*!************************!*\
  !*** ./pages/_app.jsx ***!
  \************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ MyApp; }\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"./node_modules/react/jsx-dev-runtime.js\");\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"./node_modules/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var react_toastify__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! react-toastify */ \"./node_modules/react-toastify/dist/index.mjs\");\n/* harmony import */ var _styles_globals_css__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../styles/globals.css */ \"./styles/globals.css\");\n/* harmony import */ var _styles_globals_css__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_styles_globals_css__WEBPACK_IMPORTED_MODULE_3__);\n/* harmony import */ var react_toastify_dist_ReactToastify_css__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! react-toastify/dist/ReactToastify.css */ \"./node_modules/react-toastify/dist/ReactToastify.css\");\n/* harmony import */ var react_toastify_dist_ReactToastify_css__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(react_toastify_dist_ReactToastify_css__WEBPACK_IMPORTED_MODULE_4__);\n/* harmony import */ var _contexts_SettingsContext__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../contexts/SettingsContext */ \"./contexts/SettingsContext.js\");\n/* harmony import */ var _contexts_FontContext__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../contexts/FontContext */ \"./contexts/FontContext.js\");\n/* harmony import */ var next_head__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! next/head */ \"./node_modules/next/head.js\");\n/* harmony import */ var next_head__WEBPACK_IMPORTED_MODULE_7___default = /*#__PURE__*/__webpack_require__.n(next_head__WEBPACK_IMPORTED_MODULE_7__);\n\nvar _s = $RefreshSig$();\n\n\n\n\n\n\n\nfunction MyApp(param) {\n    let { Component, pageProps } = param;\n    _s();\n    // Очищаем все шрифты при загрузке страницы\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        // Создаем стиль, который очистит все шрифты перед загрузкой\n        const clearFontsStyle = document.createElement(\"style\");\n        clearFontsStyle.textContent = \"\\n      /* Очистка всех шрифтов */\\n      @font-face {\\n        font-family: 'Arial';\\n        src: local('Arial');\\n        font-weight: normal;\\n        font-style: normal;\\n      }\\n    \";\n        document.head.appendChild(clearFontsStyle);\n        return ()=>{\n            // Удаляем стиль при размонтировании\n            if (clearFontsStyle.parentNode) {\n                clearFontsStyle.parentNode.removeChild(clearFontsStyle);\n            }\n        };\n    }, []);\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.Fragment, {\n        children: [\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)((next_head__WEBPACK_IMPORTED_MODULE_7___default()), {\n                children: [\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"meta\", {\n                        name: \"viewport\",\n                        content: \"width=device-width, initial-scale=1\"\n                    }, void 0, false, {\n                        fileName: \"/Users/igormocalov/Desktop/Font/pages/_app.jsx\",\n                        lineNumber: 36,\n                        columnNumber: 9\n                    }, this),\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"title\", {\n                        children: \"Font Gauntlet - Инструмент для работы со шрифтами\"\n                    }, void 0, false, {\n                        fileName: \"/Users/igormocalov/Desktop/Font/pages/_app.jsx\",\n                        lineNumber: 37,\n                        columnNumber: 9\n                    }, this)\n                ]\n            }, void 0, true, {\n                fileName: \"/Users/igormocalov/Desktop/Font/pages/_app.jsx\",\n                lineNumber: 35,\n                columnNumber: 7\n            }, this),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_contexts_SettingsContext__WEBPACK_IMPORTED_MODULE_5__.SettingsProvider, {\n                children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_contexts_FontContext__WEBPACK_IMPORTED_MODULE_6__.FontProvider, {\n                    children: [\n                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(Component, {\n                            ...pageProps\n                        }, void 0, false, {\n                            fileName: \"/Users/igormocalov/Desktop/Font/pages/_app.jsx\",\n                            lineNumber: 42,\n                            columnNumber: 11\n                        }, this),\n                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(react_toastify__WEBPACK_IMPORTED_MODULE_2__.ToastContainer, {\n                            position: \"bottom-right\",\n                            autoClose: 3000,\n                            hideProgressBar: false,\n                            newestOnTop: true,\n                            closeOnClick: true,\n                            rtl: false,\n                            pauseOnFocusLoss: true,\n                            draggable: true,\n                            pauseOnHover: true\n                        }, void 0, false, {\n                            fileName: \"/Users/igormocalov/Desktop/Font/pages/_app.jsx\",\n                            lineNumber: 43,\n                            columnNumber: 11\n                        }, this)\n                    ]\n                }, void 0, true, {\n                    fileName: \"/Users/igormocalov/Desktop/Font/pages/_app.jsx\",\n                    lineNumber: 41,\n                    columnNumber: 9\n                }, this)\n            }, void 0, false, {\n                fileName: \"/Users/igormocalov/Desktop/Font/pages/_app.jsx\",\n                lineNumber: 40,\n                columnNumber: 7\n            }, this)\n        ]\n    }, void 0, true);\n}\n_s(MyApp, \"OD7bBpZva5O2jO+Puf00hKivP7c=\");\n_c = MyApp;\nvar _c;\n$RefreshReg$(_c, \"MyApp\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9wYWdlcy9fYXBwLmpzeCIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQXlDO0FBQ2M7QUFDeEI7QUFDZ0I7QUFDZ0I7QUFDUjtBQUMxQjtBQUVkLFNBQVNPLE1BQU0sS0FBd0I7UUFBeEIsRUFBRUMsU0FBUyxFQUFFQyxTQUFTLEVBQUUsR0FBeEI7O0lBQzVCLDJDQUEyQztJQUMzQ1IsZ0RBQVNBLENBQUM7UUFDUiw0REFBNEQ7UUFDNUQsTUFBTVMsa0JBQWtCQyxTQUFTQyxhQUFhLENBQUM7UUFDL0NGLGdCQUFnQkcsV0FBVyxHQUFJO1FBUy9CRixTQUFTRyxJQUFJLENBQUNDLFdBQVcsQ0FBQ0w7UUFFMUIsT0FBTztZQUNMLG9DQUFvQztZQUNwQyxJQUFJQSxnQkFBZ0JNLFVBQVUsRUFBRTtnQkFDOUJOLGdCQUFnQk0sVUFBVSxDQUFDQyxXQUFXLENBQUNQO1lBQ3pDO1FBQ0Y7SUFDRixHQUFHLEVBQUU7SUFFTCxxQkFDRTs7MEJBQ0UsOERBQUNKLGtEQUFJQTs7a0NBQ0gsOERBQUNZO3dCQUFLQyxNQUFLO3dCQUFXQyxTQUFROzs7Ozs7a0NBQzlCLDhEQUFDQztrQ0FBTTs7Ozs7Ozs7Ozs7OzBCQUdULDhEQUFDakIsdUVBQWdCQTswQkFDZiw0RUFBQ0MsK0RBQVlBOztzQ0FDWCw4REFBQ0c7NEJBQVcsR0FBR0MsU0FBUzs7Ozs7O3NDQUN4Qiw4REFBQ1AsMERBQWNBOzRCQUNib0IsVUFBUzs0QkFDVEMsV0FBVzs0QkFDWEMsaUJBQWlCOzRCQUNqQkMsV0FBVzs0QkFDWEMsWUFBWTs0QkFDWkMsS0FBSzs0QkFDTEMsZ0JBQWdCOzRCQUNoQkMsU0FBUzs0QkFDVEMsWUFBWTs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQU14QjtHQWpEd0J2QjtLQUFBQSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9wYWdlcy9fYXBwLmpzeD80Y2IzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBSZWFjdCwgeyB1c2VFZmZlY3QgfSBmcm9tICdyZWFjdCc7XG5pbXBvcnQgeyBUb2FzdENvbnRhaW5lciwgdG9hc3QgfSBmcm9tICdyZWFjdC10b2FzdGlmeSc7XG5pbXBvcnQgJy4uL3N0eWxlcy9nbG9iYWxzLmNzcyc7IFxuaW1wb3J0ICdyZWFjdC10b2FzdGlmeS9kaXN0L1JlYWN0VG9hc3RpZnkuY3NzJztcbmltcG9ydCB7IFNldHRpbmdzUHJvdmlkZXIgfSBmcm9tICcuLi9jb250ZXh0cy9TZXR0aW5nc0NvbnRleHQnO1xuaW1wb3J0IHsgRm9udFByb3ZpZGVyIH0gZnJvbSAnLi4vY29udGV4dHMvRm9udENvbnRleHQnO1xuaW1wb3J0IEhlYWQgZnJvbSAnbmV4dC9oZWFkJztcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gTXlBcHAoeyBDb21wb25lbnQsIHBhZ2VQcm9wcyB9KSB7XG4gIC8vINCe0YfQuNGJ0LDQtdC8INCy0YHQtSDRiNGA0LjRhNGC0Ysg0L/RgNC4INC30LDQs9GA0YPQt9C60LUg0YHRgtGA0LDQvdC40YbRi1xuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIC8vINCh0L7Qt9C00LDQtdC8INGB0YLQuNC70YwsINC60L7RgtC+0YDRi9C5INC+0YfQuNGB0YLQuNGCINCy0YHQtSDRiNGA0LjRhNGC0Ysg0L/QtdGA0LXQtCDQt9Cw0LPRgNGD0LfQutC+0LlcbiAgICBjb25zdCBjbGVhckZvbnRzU3R5bGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzdHlsZScpO1xuICAgIGNsZWFyRm9udHNTdHlsZS50ZXh0Q29udGVudCA9IGBcbiAgICAgIC8qINCe0YfQuNGB0YLQutCwINCy0YHQtdGFINGI0YDQuNGE0YLQvtCyICovXG4gICAgICBAZm9udC1mYWNlIHtcbiAgICAgICAgZm9udC1mYW1pbHk6ICdBcmlhbCc7XG4gICAgICAgIHNyYzogbG9jYWwoJ0FyaWFsJyk7XG4gICAgICAgIGZvbnQtd2VpZ2h0OiBub3JtYWw7XG4gICAgICAgIGZvbnQtc3R5bGU6IG5vcm1hbDtcbiAgICAgIH1cbiAgICBgO1xuICAgIGRvY3VtZW50LmhlYWQuYXBwZW5kQ2hpbGQoY2xlYXJGb250c1N0eWxlKTtcbiAgICBcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgLy8g0KPQtNCw0LvRj9C10Lwg0YHRgtC40LvRjCDQv9GA0Lgg0YDQsNC30LzQvtC90YLQuNGA0L7QstCw0L3QuNC4XG4gICAgICBpZiAoY2xlYXJGb250c1N0eWxlLnBhcmVudE5vZGUpIHtcbiAgICAgICAgY2xlYXJGb250c1N0eWxlLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoY2xlYXJGb250c1N0eWxlKTtcbiAgICAgIH1cbiAgICB9O1xuICB9LCBbXSk7XG4gIFxuICByZXR1cm4gKFxuICAgIDw+XG4gICAgICA8SGVhZD5cbiAgICAgICAgPG1ldGEgbmFtZT1cInZpZXdwb3J0XCIgY29udGVudD1cIndpZHRoPWRldmljZS13aWR0aCwgaW5pdGlhbC1zY2FsZT0xXCIgLz5cbiAgICAgICAgPHRpdGxlPkZvbnQgR2F1bnRsZXQgLSDQmNC90YHRgtGA0YPQvNC10L3RgiDQtNC70Y8g0YDQsNCx0L7RgtGLINGB0L4g0YjRgNC40YTRgtCw0LzQuDwvdGl0bGU+XG4gICAgICA8L0hlYWQ+XG4gICAgICBcbiAgICAgIDxTZXR0aW5nc1Byb3ZpZGVyPlxuICAgICAgICA8Rm9udFByb3ZpZGVyPlxuICAgICAgICAgIDxDb21wb25lbnQgey4uLnBhZ2VQcm9wc30gLz5cbiAgICAgICAgICA8VG9hc3RDb250YWluZXIgXG4gICAgICAgICAgICBwb3NpdGlvbj1cImJvdHRvbS1yaWdodFwiXG4gICAgICAgICAgICBhdXRvQ2xvc2U9ezMwMDB9XG4gICAgICAgICAgICBoaWRlUHJvZ3Jlc3NCYXI9e2ZhbHNlfVxuICAgICAgICAgICAgbmV3ZXN0T25Ub3BcbiAgICAgICAgICAgIGNsb3NlT25DbGlja1xuICAgICAgICAgICAgcnRsPXtmYWxzZX1cbiAgICAgICAgICAgIHBhdXNlT25Gb2N1c0xvc3NcbiAgICAgICAgICAgIGRyYWdnYWJsZVxuICAgICAgICAgICAgcGF1c2VPbkhvdmVyXG4gICAgICAgICAgLz5cbiAgICAgICAgPC9Gb250UHJvdmlkZXI+XG4gICAgICA8L1NldHRpbmdzUHJvdmlkZXI+XG4gICAgPC8+XG4gICk7XG59ICJdLCJuYW1lcyI6WyJSZWFjdCIsInVzZUVmZmVjdCIsIlRvYXN0Q29udGFpbmVyIiwidG9hc3QiLCJTZXR0aW5nc1Byb3ZpZGVyIiwiRm9udFByb3ZpZGVyIiwiSGVhZCIsIk15QXBwIiwiQ29tcG9uZW50IiwicGFnZVByb3BzIiwiY2xlYXJGb250c1N0eWxlIiwiZG9jdW1lbnQiLCJjcmVhdGVFbGVtZW50IiwidGV4dENvbnRlbnQiLCJoZWFkIiwiYXBwZW5kQ2hpbGQiLCJwYXJlbnROb2RlIiwicmVtb3ZlQ2hpbGQiLCJtZXRhIiwibmFtZSIsImNvbnRlbnQiLCJ0aXRsZSIsInBvc2l0aW9uIiwiYXV0b0Nsb3NlIiwiaGlkZVByb2dyZXNzQmFyIiwibmV3ZXN0T25Ub3AiLCJjbG9zZU9uQ2xpY2siLCJydGwiLCJwYXVzZU9uRm9jdXNMb3NzIiwiZHJhZ2dhYmxlIiwicGF1c2VPbkhvdmVyIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./pages/_app.jsx\n"));

/***/ }),

/***/ "./utils/cssGenerator.js":
/*!*******************************!*\
  !*** ./utils/cssGenerator.js ***!
  \*******************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   addFontFace: function() { return /* binding */ addFontFace; },\n/* harmony export */   debounce: function() { return /* binding */ debounce; },\n/* harmony export */   debouncedAddFontFace: function() { return /* binding */ debouncedAddFontFace; },\n/* harmony export */   debouncedUpdateVariableFontSettings: function() { return /* binding */ debouncedUpdateVariableFontSettings; },\n/* harmony export */   hasSignificantChanges: function() { return /* binding */ hasSignificantChanges; },\n/* harmony export */   loadFontFaceIfNeeded: function() { return /* binding */ loadFontFaceIfNeeded; },\n/* harmony export */   updateVariableFontSettings: function() { return /* binding */ updateVariableFontSettings; }\n/* harmony export */ });\n/* harmony import */ var react_toastify__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react-toastify */ \"./node_modules/react-toastify/dist/index.mjs\");\n/* harmony import */ var _fontUtilsCommon__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./fontUtilsCommon */ \"./utils/fontUtilsCommon.js\");\n// Функции для генерации CSS правил (@font-face, font-variation-settings и т.д.) \n\n\n// Восстанавливаем функцию hasSignificantChanges\n/**\n * Проверяет, являются ли изменения в настройках вариативных осей \"значительными\"\n * Используется для оптимизации обновлений CSS (например, при перетаскивании слайдера)\n * @param {Object} prevSettings - Предыдущие настройки\n * @param {Object} currentSettings - Текущие настройки\n * @param {number} threshold - Порог \"значительности\" изменения для одной оси\n * @returns {boolean} true, если изменения значительны\n */ const hasSignificantChanges = function(prevSettings, currentSettings) {\n    let threshold = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 10;\n    // Если предыдущих настроек нет, считаем изменение значительным\n    if (!prevSettings) return true;\n    // Получаем ключи (теги осей) из обоих объектов\n    const prevKeys = Object.keys(prevSettings);\n    const currentKeys = Object.keys(currentSettings);\n    // Если количество осей изменилось, считаем изменение значительным\n    if (prevKeys.length !== currentKeys.length) return true;\n    // Проверяем каждую ось\n    for (const key of currentKeys){\n        // Если ось новая или значение изменилось значительно, считаем изменение значительным\n        if (!(key in prevSettings) || Math.abs(parseFloat(prevSettings[key]) - parseFloat(currentSettings[key])) >= threshold) {\n            return true;\n        }\n    }\n    // Если ни одно из условий выше не сработало, изменения незначительны\n    return false;\n};\n/**\n * Буфер для CSS обновлений\n * Помогает предотвратить моргание шрифта при частом обновлении\n */ const fontCssBuffer = {\n    // Основной буфер (активный)\n    main: new Map(),\n    // Вторичный буфер (для подготовки)\n    shadow: new Map(),\n    // Флаг отслеживания активного переключения\n    switching: false,\n    // ID кадра анимации для отмены\n    animationFrameId: null\n};\n/**\n * Обновляет CSS правило с использованием двойной буферизации и requestAnimationFrame\n * @param {string} fontId - ID шрифта\n * @param {string} cssRule - CSS правило\n */ const updateBufferedFontCss = (fontId, cssRule)=>{\n    // Сохраняем правило в теневом буфере\n    fontCssBuffer.shadow.set(fontId, cssRule);\n    // Если кадр анимации уже запланирован, не создаем новый\n    if (fontCssBuffer.animationFrameId) {\n        return;\n    }\n    // Планируем переключение на следующий кадр анимации\n    fontCssBuffer.animationFrameId = requestAnimationFrame(()=>{\n        // Устанавливаем флаг переключения\n        fontCssBuffer.switching = true;\n        // Применяем все CSS правила из теневого буфера\n        fontCssBuffer.shadow.forEach((rule, id)=>{\n            try {\n                // Находим существующий элемент style или создаем новый\n                let styleElement = document.querySelector('style[data-font-id=\"'.concat(id, '\"]'));\n                if (!styleElement) {\n                    styleElement = document.createElement(\"style\");\n                    styleElement.setAttribute(\"data-font-id\", id);\n                    document.head.appendChild(styleElement);\n                }\n                // Обновляем содержимое, только если оно изменилось\n                if (styleElement.textContent !== rule) {\n                    styleElement.textContent = rule;\n                }\n                // Копируем правило в основной буфер\n                fontCssBuffer.main.set(id, rule);\n            // УДАЛЕНО: Принудительная перерисовка страницы\n            // document.body.offsetHeight;\n            } catch (error) {\n                console.error(\"Ошибка при обновлении CSS для шрифта \".concat(id, \":\"), error);\n            }\n        });\n        // Очищаем теневой буфер\n        fontCssBuffer.shadow.clear();\n        // Сбрасываем флаг переключения и ID кадра анимации\n        fontCssBuffer.switching = false;\n        fontCssBuffer.animationFrameId = null;\n    });\n};\n/**\n * Кэш для хранения загруженных объектов FontFace\n * Ключ: `${fontFamily}_${url}`, Значение: Promise<FontFace>\n */ const fontFaceCache = new Map();\n/**\n * Загружает шрифт с использованием FontFace API и кэширования\n * @param {string} fontFamily - Имя семейства шрифтов\n * @param {string} url - URL шрифта\n * @param {Object} settings - Настройки вариативных осей (опционально)\n * @returns {Promise<FontFace>} - Промис с объектом FontFace\n */ const loadFontFaceIfNeeded = async function(fontFamily, url) {\n    let settings = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};\n    const cacheKey = \"\".concat(fontFamily, \"_\").concat(url);\n    // Проверяем кэш\n    if (fontFaceCache.has(cacheKey)) {\n        try {\n            const cachedPromise = fontFaceCache.get(cacheKey);\n            const fontFace = await cachedPromise; // Дожидаемся разрешения промиса из кэша\n            // Проверяем, добавлен ли шрифт в document.fonts (на случай, если он был удален)\n            if (typeof document !== \"undefined\" && document.fonts && !document.fonts.has(fontFace)) {\n                document.fonts.add(fontFace);\n            }\n            return fontFace;\n        } catch (error) {\n            // Если промис в кэше был отклонен, удаляем его и продолжаем загрузку\n            console.warn(\"Ошибка при использовании кэшированного FontFace для \".concat(fontFamily, \", повторная загрузка:\"), error);\n            fontFaceCache.delete(cacheKey);\n        }\n    }\n    // Создаем промис для загрузки (чтобы закэшировать сам промис)\n    const loadPromise = (async ()=>{\n        try {\n            // ИСПРАВЛЕНИЕ: НЕ устанавливаем variationSettings в FontFace опциях!\n            // Это позволит динамически изменять оси через CSS font-variation-settings\n            const options = {};\n            // УДАЛЕНО: if (Object.keys(settings).length > 0) { ... }\n            console.log(\"[loadFontFaceIfNeeded] Создаем FontFace для \".concat(fontFamily, \" БЕЗ фиксированных variationSettings\"));\n            const fontFace = new FontFace(fontFamily, \"url(\".concat(url, \")\"), options);\n            await fontFace.load();\n            if (typeof document !== \"undefined\" && document.fonts) {\n                document.fonts.add(fontFace);\n            }\n            console.log(\"[loadFontFaceIfNeeded] FontFace успешно загружен и добавлен: \".concat(fontFamily));\n            return fontFace;\n        } catch (error) {\n            console.error(\"Ошибка при загрузке шрифта \".concat(fontFamily, \" через FontFace API:\"), error);\n            fontFaceCache.delete(cacheKey); // Удаляем из кэша при ошибке загрузки\n            throw error; // Пробрасываем ошибку дальше\n        }\n    })();\n    // Кэшируем сам промис\n    fontFaceCache.set(cacheKey, loadPromise);\n    return loadPromise;\n};\n/**\n * @deprecated Эта функция больше не добавляет @font-face. Используйте loadFontFaceIfNeeded.\n *             Она может быть использована только для обновления настроек, но лучше использовать updateVariableFontSettings.\n */ const addFontFace = function(fontObj) {\n    let prevSettings = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;\n    // Проверяем, что у нас есть допустимый объект шрифта\n    if (!fontObj) {\n        console.error(\"fontObj не предоставлен\");\n        return null;\n    }\n    // Проверяем, что у нас есть файл или URL (уже не нужно для этой функции)\n    /*\n  if (!fontObj.url && (!fontObj.file || !(fontObj.file instanceof Blob))) {\n    console.error('Нет URL или файла для шрифта');\n    return fontObj;\n  }\n  */ // Убедимся, что у шрифта есть ID\n    if (!fontObj.id) {\n        fontObj.id = Math.random().toString(36).substring(2, 15) + Math.random().toString(36).substring(2, 15);\n    }\n    // Убедимся, что есть fontFamily (он должен быть установлен в processLocalFont или взят из источника)\n    const fontFamilyName = fontObj.fontFamily;\n    if (!fontFamilyName) {\n        console.error(\"fontObj не имеет fontFamily, не могу обновить CSS.\", fontObj);\n        return fontObj; // Возвращаем без изменений\n    }\n    // --- УДАЛЕНА ГЕНЕРАЦИЯ @font-face --- \n    // Вся логика, связанная с `src: url(...)` и `format()` удалена.\n    // --- ЛОГИКА ОБНОВЛЕНИЯ VARIATION SETTINGS (оставлена для обратной совместимости, но лучше использовать updateVariableFontSettings) ---\n    // ... (код извлечения currentSettings и генерации variationSettingsRule остается, как в предыдущем анализе)\n    const currentSettings = {};\n    if (fontObj.isVariableFont && fontObj.variableAxes) {\n        Object.entries(fontObj.variableAxes).forEach((param)=>{\n            let [tag, axisData] = param;\n            var _axisData_currentValue;\n            const value = (_axisData_currentValue = axisData === null || axisData === void 0 ? void 0 : axisData.currentValue) !== null && _axisData_currentValue !== void 0 ? _axisData_currentValue : axisData === null || axisData === void 0 ? void 0 : axisData.default;\n            if (value !== undefined) {\n                currentSettings[tag] = value;\n            }\n        });\n    }\n    // Подготавливаем строку font-variation-settings\n    let variationSettingsRule = \"\";\n    if (fontObj.isVariableFont) {\n        const settingsToApply = Object.entries(currentSettings);\n        if (settingsToApply.length > 0) {\n            const settingsArray = settingsToApply.map((param)=>{\n                let [tag, value] = param;\n                return '\"'.concat(tag, '\" ').concat(value);\n            });\n            // Используем data-атрибут как селектор (пример)\n            variationSettingsRule = '[data-font-family=\"'.concat(fontFamilyName, '\"] { font-variation-settings: ').concat(settingsArray.join(\", \"), \"; }\");\n        }\n    }\n    const cssRule = variationSettingsRule;\n    // Обновляем CSS с помощью буферизации, если есть что обновлять\n    if (cssRule) {\n        // Используем ID + '-settings', чтобы не конфликтовать с возможным старым @font-face стилем\n        updateBufferedFontCss(fontObj.id + \"-settings\", cssRule);\n    }\n    return fontObj;\n};\n/**\n * Создает дебаунсированную версию функции для предотвращения частых вызовов\n * @param {Function} func - Функция для дебаунсинга\n * @param {number} wait - Время ожидания в миллисекундах\n * @returns {Function} - Дебаунсированная функция\n */ const debounce = function(func) {\n    let wait = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 50;\n    let timeout;\n    return function() {\n        for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){\n            args[_key] = arguments[_key];\n        }\n        const context = this;\n        clearTimeout(timeout);\n        timeout = setTimeout(()=>func.apply(context, args), wait);\n    };\n};\n/**\n * Дебаунсированная версия addFontFace для безопасного вызова при изменении осей\n */ const debouncedAddFontFace = debounce(addFontFace, 50);\n/**\n * Переименовываем updateFontFaceIfNeeded в updateVariableFontSettings\n * @param {Object} fontObj - Объект шрифта\n * @param {Object} currentSettings - Объект с текущими настройками осей { tag: value, ... }\n * @param {Object} prevSettings - Предыдущие настройки (опционально, для hasSignificantChanges)\n * @returns {Object} - Исходный fontObj\n */ const updateVariableFontSettings = function(fontObj, currentSettings) {\n    let prevSettings = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : null;\n    if (!fontObj || !fontObj.fontFamily || !fontObj.isVariableFont) {\n        console.warn(\"updateVariableFontSettings: Невалидный fontObj или не вариативный шрифт.\");\n        return fontObj;\n    }\n    if (!currentSettings || typeof currentSettings !== \"object\") {\n        console.warn(\"updateVariableFontSettings: Не предоставлены currentSettings.\");\n        return fontObj;\n    }\n    const fontFamilyName = fontObj.fontFamily;\n    const fontId = fontObj.id || fontFamilyName; // Нужен ID для updateBufferedFontCss\n    // Опциональная проверка на значительные изменения\n    // if (prevSettings && !hasSignificantChanges(prevSettings, currentSettings)) {\n    //     return fontObj; // Нет значительных изменений\n    // }\n    // Формируем CSS правило ТОЛЬКО для font-variation-settings\n    let variationSettingsRule = \"\";\n    const settingsToApply = Object.entries(currentSettings);\n    if (settingsToApply.length > 0) {\n        const settingsArray = settingsToApply.map((param)=>{\n            let [tag, value] = param;\n            return '\"'.concat(tag, '\" ').concat(value);\n        });\n        // Используем data-атрибут как селектор. Убедись, что элемент превью имеет этот атрибут!\n        variationSettingsRule = '[data-font-family=\"'.concat(fontFamilyName, '\"] { font-variation-settings: ').concat(settingsArray.join(\", \"), \"; }\");\n    // Альтернатива: CSS переменные (требует изменений в компоненте)\n    // variationSettingsRule = `:root { ${settingsArray.map(([tag, value]) => `--${fontId}-${tag}: ${value};`).join('\\n')} }`;\n    }\n    // Обновляем CSS через буфер\n    if (variationSettingsRule) {\n        updateBufferedFontCss(fontId + \"-settings\", variationSettingsRule); // Используем уникальный ID для стилей настроек\n    } else {\n    // Если настроек нет, возможно, нужно удалить предыдущее правило?\n    // updateBufferedFontCss(fontId + '-settings', ''); // Очистить стиль\n    }\n    return fontObj;\n};\n// Дебаунсированная версия updateVariableFontSettings (остается)\nconst debouncedUpdateVariableFontSettings = debounce(updateVariableFontSettings, 50);\n/**\n * Счетчик для отслеживания количества загрузок шрифтов для отладки\n */ let fontLoadCounter = 0;\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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RUEsTUFBTUksaUJBQWlCSixRQUFRbEIsVUFBVTtJQUN6QyxNQUFNcEIsU0FBU3NDLFFBQVFoQyxFQUFFLElBQUlvQyxnQkFBZ0IscUNBQXFDO0lBRWxGLGtEQUFrRDtJQUNsRCwrRUFBK0U7SUFDL0Usb0RBQW9EO0lBQ3BELElBQUk7SUFFSiwyREFBMkQ7SUFDM0QsSUFBSVUsd0JBQXdCO0lBQzVCLE1BQU1DLGtCQUFrQnBFLE9BQU80RCxPQUFPLENBQUMvRDtJQUN2QyxJQUFJdUUsZ0JBQWdCakUsTUFBTSxHQUFHLEdBQUc7UUFDNUIsTUFBTWtFLGdCQUFnQkQsZ0JBQWdCRSxHQUFHLENBQUM7Z0JBQUMsQ0FBQ1QsS0FBS0UsTUFBTTttQkFBSyxJQUFjQSxPQUFURixLQUFJLE1BQVcsT0FBTkU7O1FBQzFFLHdGQUF3RjtRQUN4Rkksd0JBQXdCLHNCQUFxRUUsT0FBL0NaLGdCQUFlLGtDQUF5RCxPQUF6QlksY0FBY0UsSUFBSSxDQUFDLE9BQU07SUFDdEgsZ0VBQWdFO0lBQ2hFLDBIQUEwSDtJQUM5SDtJQUVBLDRCQUE0QjtJQUM1QixJQUFJSix1QkFBdUI7UUFDdkJyRCxzQkFBc0JDLFNBQVMsYUFBYW9ELHdCQUF3QiwrQ0FBK0M7SUFDdkgsT0FBTztJQUNILGlFQUFpRTtJQUNqRSxxRUFBcUU7SUFDekU7SUFFQSxPQUFPZDtBQUNYLEVBQUU7QUFFRixnRUFBZ0U7QUFDekQsTUFBTThCLHNDQUFzQ1gsU0FBU1UsNEJBQTRCLElBQUk7QUFFNUY7O0NBRUMsR0FDRCxJQUFJRSxrQkFBa0IiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vdXRpbHMvY3NzR2VuZXJhdG9yLmpzP2NhN2UiXSwic291cmNlc0NvbnRlbnQiOlsiLy8g0KTRg9C90LrRhtC40Lgg0LTQu9GPINCz0LXQvdC10YDQsNGG0LjQuCBDU1Mg0L/RgNCw0LLQuNC7IChAZm9udC1mYWNlLCBmb250LXZhcmlhdGlvbi1zZXR0aW5ncyDQuCDRgi7QtC4pIFxuaW1wb3J0IHsgdG9hc3QgfSBmcm9tICdyZWFjdC10b2FzdGlmeSc7XG5pbXBvcnQgeyBnZXRGb3JtYXRGcm9tRXh0ZW5zaW9uIH0gZnJvbSAnLi9mb250VXRpbHNDb21tb24nO1xuXG4vLyDQktC+0YHRgdGC0LDQvdCw0LLQu9C40LLQsNC10Lwg0YTRg9C90LrRhtC40Y4gaGFzU2lnbmlmaWNhbnRDaGFuZ2VzXG4vKipcbiAqINCf0YDQvtCy0LXRgNGP0LXRgiwg0Y/QstC70Y/RjtGC0YHRjyDQu9C4INC40LfQvNC10L3QtdC90LjRjyDQsiDQvdCw0YHRgtGA0L7QudC60LDRhSDQstCw0YDQuNCw0YLQuNCy0L3Ri9GFINC+0YHQtdC5IFwi0LfQvdCw0YfQuNGC0LXQu9GM0L3Ri9C80LhcIlxuICog0JjRgdC/0L7Qu9GM0LfRg9C10YLRgdGPINC00LvRjyDQvtC/0YLQuNC80LjQt9Cw0YbQuNC4INC+0LHQvdC+0LLQu9C10L3QuNC5IENTUyAo0L3QsNC/0YDQuNC80LXRgCwg0L/RgNC4INC/0LXRgNC10YLQsNGB0LrQuNCy0LDQvdC40Lgg0YHQu9Cw0LnQtNC10YDQsClcbiAqIEBwYXJhbSB7T2JqZWN0fSBwcmV2U2V0dGluZ3MgLSDQn9GA0LXQtNGL0LTRg9GJ0LjQtSDQvdCw0YHRgtGA0L7QudC60LhcbiAqIEBwYXJhbSB7T2JqZWN0fSBjdXJyZW50U2V0dGluZ3MgLSDQotC10LrRg9GJ0LjQtSDQvdCw0YHRgtGA0L7QudC60LhcbiAqIEBwYXJhbSB7bnVtYmVyfSB0aHJlc2hvbGQgLSDQn9C+0YDQvtCzIFwi0LfQvdCw0YfQuNGC0LXQu9GM0L3QvtGB0YLQuFwiINC40LfQvNC10L3QtdC90LjRjyDQtNC70Y8g0L7QtNC90L7QuSDQvtGB0LhcbiAqIEByZXR1cm5zIHtib29sZWFufSB0cnVlLCDQtdGB0LvQuCDQuNC30LzQtdC90LXQvdC40Y8g0LfQvdCw0YfQuNGC0LXQu9GM0L3Ri1xuICovXG5leHBvcnQgY29uc3QgaGFzU2lnbmlmaWNhbnRDaGFuZ2VzID0gKHByZXZTZXR0aW5ncywgY3VycmVudFNldHRpbmdzLCB0aHJlc2hvbGQgPSAxMCkgPT4ge1xuICAvLyDQldGB0LvQuCDQv9GA0LXQtNGL0LTRg9GJ0LjRhSDQvdCw0YHRgtGA0L7QtdC6INC90LXRgiwg0YHRh9C40YLQsNC10Lwg0LjQt9C80LXQvdC10L3QuNC1INC30L3QsNGH0LjRgtC10LvRjNC90YvQvFxuICBpZiAoIXByZXZTZXR0aW5ncykgcmV0dXJuIHRydWU7XG4gIFxuICAvLyDQn9C+0LvRg9GH0LDQtdC8INC60LvRjtGH0LggKNGC0LXQs9C4INC+0YHQtdC5KSDQuNC3INC+0LHQvtC40YUg0L7QsdGK0LXQutGC0L7QslxuICBjb25zdCBwcmV2S2V5cyA9IE9iamVjdC5rZXlzKHByZXZTZXR0aW5ncyk7XG4gIGNvbnN0IGN1cnJlbnRLZXlzID0gT2JqZWN0LmtleXMoY3VycmVudFNldHRpbmdzKTtcblxuICAvLyDQldGB0LvQuCDQutC+0LvQuNGH0LXRgdGC0LLQviDQvtGB0LXQuSDQuNC30LzQtdC90LjQu9C+0YHRjCwg0YHRh9C40YLQsNC10Lwg0LjQt9C80LXQvdC10L3QuNC1INC30L3QsNGH0LjRgtC10LvRjNC90YvQvFxuICBpZiAocHJldktleXMubGVuZ3RoICE9PSBjdXJyZW50S2V5cy5sZW5ndGgpIHJldHVybiB0cnVlO1xuXG4gIC8vINCf0YDQvtCy0LXRgNGP0LXQvCDQutCw0LbQtNGD0Y4g0L7RgdGMXG4gIGZvciAoY29uc3Qga2V5IG9mIGN1cnJlbnRLZXlzKSB7XG4gICAgLy8g0JXRgdC70Lgg0L7RgdGMINC90L7QstCw0Y8g0LjQu9C4INC30L3QsNGH0LXQvdC40LUg0LjQt9C80LXQvdC40LvQvtGB0Ywg0LfQvdCw0YfQuNGC0LXQu9GM0L3Qviwg0YHRh9C40YLQsNC10Lwg0LjQt9C80LXQvdC10L3QuNC1INC30L3QsNGH0LjRgtC10LvRjNC90YvQvFxuICAgIGlmICghKGtleSBpbiBwcmV2U2V0dGluZ3MpIHx8IFxuICAgICAgICBNYXRoLmFicyhwYXJzZUZsb2F0KHByZXZTZXR0aW5nc1trZXldKSAtIHBhcnNlRmxvYXQoY3VycmVudFNldHRpbmdzW2tleV0pKSA+PSB0aHJlc2hvbGQpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfVxuXG4gIC8vINCV0YHQu9C4INC90Lgg0L7QtNC90L4g0LjQtyDRg9GB0LvQvtCy0LjQuSDQstGL0YjQtSDQvdC1INGB0YDQsNCx0L7RgtCw0LvQviwg0LjQt9C80LXQvdC10L3QuNGPINC90LXQt9C90LDRh9C40YLQtdC70YzQvdGLXG4gIHJldHVybiBmYWxzZTtcbn07XG5cbi8qKlxuICog0JHRg9GE0LXRgCDQtNC70Y8gQ1NTINC+0LHQvdC+0LLQu9C10L3QuNC5XG4gKiDQn9C+0LzQvtCz0LDQtdGCINC/0YDQtdC00L7RgtCy0YDQsNGC0LjRgtGMINC80L7RgNCz0LDQvdC40LUg0YjRgNC40YTRgtCwINC/0YDQuCDRh9Cw0YHRgtC+0Lwg0L7QsdC90L7QstC70LXQvdC40LhcbiAqL1xuY29uc3QgZm9udENzc0J1ZmZlciA9IHtcbiAgLy8g0J7RgdC90L7QstC90L7QuSDQsdGD0YTQtdGAICjQsNC60YLQuNCy0L3Ri9C5KVxuICBtYWluOiBuZXcgTWFwKCksXG4gIC8vINCS0YLQvtGA0LjRh9C90YvQuSDQsdGD0YTQtdGAICjQtNC70Y8g0L/QvtC00LPQvtGC0L7QstC60LgpXG4gIHNoYWRvdzogbmV3IE1hcCgpLFxuICAvLyDQpNC70LDQsyDQvtGC0YHQu9C10LbQuNCy0LDQvdC40Y8g0LDQutGC0LjQstC90L7Qs9C+INC/0LXRgNC10LrQu9GO0YfQtdC90LjRj1xuICBzd2l0Y2hpbmc6IGZhbHNlLFxuICAvLyBJRCDQutCw0LTRgNCwINCw0L3QuNC80LDRhtC40Lgg0LTQu9GPINC+0YLQvNC10L3Ri1xuICBhbmltYXRpb25GcmFtZUlkOiBudWxsXG59O1xuXG4vKipcbiAqINCe0LHQvdC+0LLQu9GP0LXRgiBDU1Mg0L/RgNCw0LLQuNC70L4g0YEg0LjRgdC/0L7Qu9GM0LfQvtCy0LDQvdC40LXQvCDQtNCy0L7QudC90L7QuSDQsdGD0YTQtdGA0LjQt9Cw0YbQuNC4INC4IHJlcXVlc3RBbmltYXRpb25GcmFtZVxuICogQHBhcmFtIHtzdHJpbmd9IGZvbnRJZCAtIElEINGI0YDQuNGE0YLQsFxuICogQHBhcmFtIHtzdHJpbmd9IGNzc1J1bGUgLSBDU1Mg0L/RgNCw0LLQuNC70L5cbiAqL1xuY29uc3QgdXBkYXRlQnVmZmVyZWRGb250Q3NzID0gKGZvbnRJZCwgY3NzUnVsZSkgPT4ge1xuICAvLyDQodC+0YXRgNCw0L3Rj9C10Lwg0L/RgNCw0LLQuNC70L4g0LIg0YLQtdC90LXQstC+0Lwg0LHRg9GE0LXRgNC1XG4gIGZvbnRDc3NCdWZmZXIuc2hhZG93LnNldChmb250SWQsIGNzc1J1bGUpO1xuXG4gIC8vINCV0YHQu9C4INC60LDQtNGAINCw0L3QuNC80LDRhtC40Lgg0YPQttC1INC30LDQv9C70LDQvdC40YDQvtCy0LDQvSwg0L3QtSDRgdC+0LfQtNCw0LXQvCDQvdC+0LLRi9C5XG4gIGlmIChmb250Q3NzQnVmZmVyLmFuaW1hdGlvbkZyYW1lSWQpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICAvLyDQn9C70LDQvdC40YDRg9C10Lwg0L/QtdGA0LXQutC70Y7Rh9C10L3QuNC1INC90LAg0YHQu9C10LTRg9GO0YnQuNC5INC60LDQtNGAINCw0L3QuNC80LDRhtC40LhcbiAgZm9udENzc0J1ZmZlci5hbmltYXRpb25GcmFtZUlkID0gcmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+IHtcbiAgICAvLyDQo9GB0YLQsNC90LDQstC70LjQstCw0LXQvCDRhNC70LDQsyDQv9C10YDQtdC60LvRjtGH0LXQvdC40Y9cbiAgICBmb250Q3NzQnVmZmVyLnN3aXRjaGluZyA9IHRydWU7XG5cbiAgICAvLyDQn9GA0LjQvNC10L3Rj9C10Lwg0LLRgdC1IENTUyDQv9GA0LDQstC40LvQsCDQuNC3INGC0LXQvdC10LLQvtCz0L4g0LHRg9GE0LXRgNCwXG4gICAgZm9udENzc0J1ZmZlci5zaGFkb3cuZm9yRWFjaCgocnVsZSwgaWQpID0+IHtcbiAgICAgIHRyeSB7XG4gICAgICAgIC8vINCd0LDRhdC+0LTQuNC8INGB0YPRidC10YHRgtCy0YPRjtGJ0LjQuSDRjdC70LXQvNC10L3RgiBzdHlsZSDQuNC70Lgg0YHQvtC30LTQsNC10Lwg0L3QvtCy0YvQuVxuICAgICAgICBsZXQgc3R5bGVFbGVtZW50ID0gZG9jdW1lbnQucXVlcnlTZWxlY3Rvcihgc3R5bGVbZGF0YS1mb250LWlkPVwiJHtpZH1cIl1gKTtcblxuICAgICAgICBpZiAoIXN0eWxlRWxlbWVudCkge1xuICAgICAgICAgIHN0eWxlRWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3N0eWxlJyk7XG4gICAgICAgICAgc3R5bGVFbGVtZW50LnNldEF0dHJpYnV0ZSgnZGF0YS1mb250LWlkJywgaWQpO1xuICAgICAgICAgIGRvY3VtZW50LmhlYWQuYXBwZW5kQ2hpbGQoc3R5bGVFbGVtZW50KTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vINCe0LHQvdC+0LLQu9GP0LXQvCDRgdC+0LTQtdGA0LbQuNC80L7QtSwg0YLQvtC70YzQutC+INC10YHQu9C4INC+0L3QviDQuNC30LzQtdC90LjQu9C+0YHRjFxuICAgICAgICBpZiAoc3R5bGVFbGVtZW50LnRleHRDb250ZW50ICE9PSBydWxlKSB7XG4gICAgICAgICAgc3R5bGVFbGVtZW50LnRleHRDb250ZW50ID0gcnVsZTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vINCa0L7Qv9C40YDRg9C10Lwg0L/RgNCw0LLQuNC70L4g0LIg0L7RgdC90L7QstC90L7QuSDQsdGD0YTQtdGAXG4gICAgICAgIGZvbnRDc3NCdWZmZXIubWFpbi5zZXQoaWQsIHJ1bGUpO1xuXG4gICAgICAgIC8vINCj0JTQkNCb0JXQndCeOiDQn9GA0LjQvdGD0LTQuNGC0LXQu9GM0L3QsNGPINC/0LXRgNC10YDQuNGB0L7QstC60LAg0YHRgtGA0LDQvdC40YbRi1xuICAgICAgICAvLyBkb2N1bWVudC5ib2R5Lm9mZnNldEhlaWdodDtcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoYNCe0YjQuNCx0LrQsCDQv9GA0Lgg0L7QsdC90L7QstC70LXQvdC40LggQ1NTINC00LvRjyDRiNGA0LjRhNGC0LAgJHtpZH06YCwgZXJyb3IpO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgLy8g0J7Rh9C40YnQsNC10Lwg0YLQtdC90LXQstC+0Lkg0LHRg9GE0LXRgFxuICAgIGZvbnRDc3NCdWZmZXIuc2hhZG93LmNsZWFyKCk7XG5cbiAgICAvLyDQodCx0YDQsNGB0YvQstCw0LXQvCDRhNC70LDQsyDQv9C10YDQtdC60LvRjtGH0LXQvdC40Y8g0LggSUQg0LrQsNC00YDQsCDQsNC90LjQvNCw0YbQuNC4XG4gICAgZm9udENzc0J1ZmZlci5zd2l0Y2hpbmcgPSBmYWxzZTtcbiAgICBmb250Q3NzQnVmZmVyLmFuaW1hdGlvbkZyYW1lSWQgPSBudWxsO1xuICB9KTtcbn07XG5cbi8qKlxuICog0JrRjdGIINC00LvRjyDRhdGA0LDQvdC10L3QuNGPINC30LDQs9GA0YPQttC10L3QvdGL0YUg0L7QsdGK0LXQutGC0L7QsiBGb250RmFjZVxuICog0JrQu9GO0Yc6IGAke2ZvbnRGYW1pbHl9XyR7dXJsfWAsINCX0L3QsNGH0LXQvdC40LU6IFByb21pc2U8Rm9udEZhY2U+XG4gKi9cbmNvbnN0IGZvbnRGYWNlQ2FjaGUgPSBuZXcgTWFwKCk7XG5cbi8qKlxuICog0JfQsNCz0YDRg9C20LDQtdGCINGI0YDQuNGE0YIg0YEg0LjRgdC/0L7Qu9GM0LfQvtCy0LDQvdC40LXQvCBGb250RmFjZSBBUEkg0Lgg0LrRjdGI0LjRgNC+0LLQsNC90LjRj1xuICogQHBhcmFtIHtzdHJpbmd9IGZvbnRGYW1pbHkgLSDQmNC80Y8g0YHQtdC80LXQudGB0YLQstCwINGI0YDQuNGE0YLQvtCyXG4gKiBAcGFyYW0ge3N0cmluZ30gdXJsIC0gVVJMINGI0YDQuNGE0YLQsFxuICogQHBhcmFtIHtPYmplY3R9IHNldHRpbmdzIC0g0J3QsNGB0YLRgNC+0LnQutC4INCy0LDRgNC40LDRgtC40LLQvdGL0YUg0L7RgdC10LkgKNC+0L/RhtC40L7QvdCw0LvRjNC90L4pXG4gKiBAcmV0dXJucyB7UHJvbWlzZTxGb250RmFjZT59IC0g0J/RgNC+0LzQuNGBINGBINC+0LHRitC10LrRgtC+0LwgRm9udEZhY2VcbiAqL1xuZXhwb3J0IGNvbnN0IGxvYWRGb250RmFjZUlmTmVlZGVkID0gYXN5bmMgKGZvbnRGYW1pbHksIHVybCwgc2V0dGluZ3MgPSB7fSkgPT4ge1xuICBjb25zdCBjYWNoZUtleSA9IGAke2ZvbnRGYW1pbHl9XyR7dXJsfWA7XG4gIFxuICAvLyDQn9GA0L7QstC10YDRj9C10Lwg0LrRjdGIXG4gIGlmIChmb250RmFjZUNhY2hlLmhhcyhjYWNoZUtleSkpIHtcbiAgICB0cnkge1xuICAgICAgY29uc3QgY2FjaGVkUHJvbWlzZSA9IGZvbnRGYWNlQ2FjaGUuZ2V0KGNhY2hlS2V5KTtcbiAgICAgIGNvbnN0IGZvbnRGYWNlID0gYXdhaXQgY2FjaGVkUHJvbWlzZTsgLy8g0JTQvtC20LjQtNCw0LXQvNGB0Y8g0YDQsNC30YDQtdGI0LXQvdC40Y8g0L/RgNC+0LzQuNGB0LAg0LjQtyDQutGN0YjQsFxuICAgICAgLy8g0J/RgNC+0LLQtdGA0Y/QtdC8LCDQtNC+0LHQsNCy0LvQtdC9INC70Lgg0YjRgNC40YTRgiDQsiBkb2N1bWVudC5mb250cyAo0L3QsCDRgdC70YPRh9Cw0LksINC10YHQu9C4INC+0L0g0LHRi9C7INGD0LTQsNC70LXQvSlcbiAgICAgIGlmICh0eXBlb2YgZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnICYmIGRvY3VtZW50LmZvbnRzICYmICFkb2N1bWVudC5mb250cy5oYXMoZm9udEZhY2UpKSB7XG4gICAgICAgICBkb2N1bWVudC5mb250cy5hZGQoZm9udEZhY2UpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGZvbnRGYWNlO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAvLyDQldGB0LvQuCDQv9GA0L7QvNC40YEg0LIg0LrRjdGI0LUg0LHRi9C7INC+0YLQutC70L7QvdC10L0sINGD0LTQsNC70Y/QtdC8INC10LPQviDQuCDQv9GA0L7QtNC+0LvQttCw0LXQvCDQt9Cw0LPRgNGD0LfQutGDXG4gICAgICBjb25zb2xlLndhcm4oYNCe0YjQuNCx0LrQsCDQv9GA0Lgg0LjRgdC/0L7Qu9GM0LfQvtCy0LDQvdC40Lgg0LrRjdGI0LjRgNC+0LLQsNC90L3QvtCz0L4gRm9udEZhY2Ug0LTQu9GPICR7Zm9udEZhbWlseX0sINC/0L7QstGC0L7RgNC90LDRjyDQt9Cw0LPRgNGD0LfQutCwOmAsIGVycm9yKTtcbiAgICAgIGZvbnRGYWNlQ2FjaGUuZGVsZXRlKGNhY2hlS2V5KTtcbiAgICB9XG4gIH1cblxuICAvLyDQodC+0LfQtNCw0LXQvCDQv9GA0L7QvNC40YEg0LTQu9GPINC30LDQs9GA0YPQt9C60LggKNGH0YLQvtCx0Ysg0LfQsNC60Y3RiNC40YDQvtCy0LDRgtGMINGB0LDQvCDQv9GA0L7QvNC40YEpXG4gIGNvbnN0IGxvYWRQcm9taXNlID0gKGFzeW5jICgpID0+IHtcbiAgICB0cnkge1xuICAgICAgLy8g0JjQodCf0KDQkNCS0JvQldCd0JjQlTog0J3QlSDRg9GB0YLQsNC90LDQstC70LjQstCw0LXQvCB2YXJpYXRpb25TZXR0aW5ncyDQsiBGb250RmFjZSDQvtC/0YbQuNGP0YUhXG4gICAgICAvLyDQrdGC0L4g0L/QvtC30LLQvtC70LjRgiDQtNC40L3QsNC80LjRh9C10YHQutC4INC40LfQvNC10L3Rj9GC0Ywg0L7RgdC4INGH0LXRgNC10LcgQ1NTIGZvbnQtdmFyaWF0aW9uLXNldHRpbmdzXG4gICAgICBjb25zdCBvcHRpb25zID0ge307XG4gICAgICAvLyDQo9CU0JDQm9CV0J3QnjogaWYgKE9iamVjdC5rZXlzKHNldHRpbmdzKS5sZW5ndGggPiAwKSB7IC4uLiB9XG4gICAgICBcbiAgICAgIGNvbnNvbGUubG9nKGBbbG9hZEZvbnRGYWNlSWZOZWVkZWRdINCh0L7Qt9C00LDQtdC8IEZvbnRGYWNlINC00LvRjyAke2ZvbnRGYW1pbHl9INCR0JXQlyDRhNC40LrRgdC40YDQvtCy0LDQvdC90YvRhSB2YXJpYXRpb25TZXR0aW5nc2ApO1xuICAgICAgXG4gICAgICBjb25zdCBmb250RmFjZSA9IG5ldyBGb250RmFjZShmb250RmFtaWx5LCBgdXJsKCR7dXJsfSlgLCBvcHRpb25zKTtcbiAgICAgIGF3YWl0IGZvbnRGYWNlLmxvYWQoKTtcbiAgICAgIGlmICh0eXBlb2YgZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnICYmIGRvY3VtZW50LmZvbnRzKSB7XG4gICAgICAgICAgZG9jdW1lbnQuZm9udHMuYWRkKGZvbnRGYWNlKTtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgY29uc29sZS5sb2coYFtsb2FkRm9udEZhY2VJZk5lZWRlZF0gRm9udEZhY2Ug0YPRgdC/0LXRiNC90L4g0LfQsNCz0YDRg9C20LXQvSDQuCDQtNC+0LHQsNCy0LvQtdC9OiAke2ZvbnRGYW1pbHl9YCk7XG4gICAgICByZXR1cm4gZm9udEZhY2U7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoYNCe0YjQuNCx0LrQsCDQv9GA0Lgg0LfQsNCz0YDRg9C30LrQtSDRiNGA0LjRhNGC0LAgJHtmb250RmFtaWx5fSDRh9C10YDQtdC3IEZvbnRGYWNlIEFQSTpgLCBlcnJvcik7XG4gICAgICBmb250RmFjZUNhY2hlLmRlbGV0ZShjYWNoZUtleSk7IC8vINCj0LTQsNC70Y/QtdC8INC40Lcg0LrRjdGI0LAg0L/RgNC4INC+0YjQuNCx0LrQtSDQt9Cw0LPRgNGD0LfQutC4XG4gICAgICB0aHJvdyBlcnJvcjsgLy8g0J/RgNC+0LHRgNCw0YHRi9Cy0LDQtdC8INC+0YjQuNCx0LrRgyDQtNCw0LvRjNGI0LVcbiAgICB9XG4gIH0pKCk7XG5cbiAgLy8g0JrRjdGI0LjRgNGD0LXQvCDRgdCw0Lwg0L/RgNC+0LzQuNGBXG4gIGZvbnRGYWNlQ2FjaGUuc2V0KGNhY2hlS2V5LCBsb2FkUHJvbWlzZSk7XG5cbiAgcmV0dXJuIGxvYWRQcm9taXNlO1xufTtcblxuLyoqXG4gKiBAZGVwcmVjYXRlZCDQrdGC0LAg0YTRg9C90LrRhtC40Y8g0LHQvtC70YzRiNC1INC90LUg0LTQvtCx0LDQstC70Y/QtdGCIEBmb250LWZhY2UuINCY0YHQv9C+0LvRjNC30YPQudGC0LUgbG9hZEZvbnRGYWNlSWZOZWVkZWQuXG4gKiAgICAgICAgICAgICDQntC90LAg0LzQvtC20LXRgiDQsdGL0YLRjCDQuNGB0L/QvtC70YzQt9C+0LLQsNC90LAg0YLQvtC70YzQutC+INC00LvRjyDQvtCx0L3QvtCy0LvQtdC90LjRjyDQvdCw0YHRgtGA0L7QtdC6LCDQvdC+INC70YPRh9GI0LUg0LjRgdC/0L7Qu9GM0LfQvtCy0LDRgtGMIHVwZGF0ZVZhcmlhYmxlRm9udFNldHRpbmdzLlxuICovXG5leHBvcnQgY29uc3QgYWRkRm9udEZhY2UgPSAoZm9udE9iaiwgcHJldlNldHRpbmdzID0gbnVsbCkgPT4ge1xuICAvLyDQn9GA0L7QstC10YDRj9C10LwsINGH0YLQviDRgyDQvdCw0YEg0LXRgdGC0Ywg0LTQvtC/0YPRgdGC0LjQvNGL0Lkg0L7QsdGK0LXQutGCINGI0YDQuNGE0YLQsFxuICBpZiAoIWZvbnRPYmopIHtcbiAgICBjb25zb2xlLmVycm9yKCdmb250T2JqINC90LUg0L/RgNC10LTQvtGB0YLQsNCy0LvQtdC9Jyk7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICAvLyDQn9GA0L7QstC10YDRj9C10LwsINGH0YLQviDRgyDQvdCw0YEg0LXRgdGC0Ywg0YTQsNC50Lsg0LjQu9C4IFVSTCAo0YPQttC1INC90LUg0L3Rg9C20L3QviDQtNC70Y8g0Y3RgtC+0Lkg0YTRg9C90LrRhtC40LgpXG4gIC8qXG4gIGlmICghZm9udE9iai51cmwgJiYgKCFmb250T2JqLmZpbGUgfHwgIShmb250T2JqLmZpbGUgaW5zdGFuY2VvZiBCbG9iKSkpIHtcbiAgICBjb25zb2xlLmVycm9yKCfQndC10YIgVVJMINC40LvQuCDRhNCw0LnQu9CwINC00LvRjyDRiNGA0LjRhNGC0LAnKTtcbiAgICByZXR1cm4gZm9udE9iajtcbiAgfVxuICAqL1xuXG4gIC8vINCj0LHQtdC00LjQvNGB0Y8sINGH0YLQviDRgyDRiNGA0LjRhNGC0LAg0LXRgdGC0YwgSURcbiAgaWYgKCFmb250T2JqLmlkKSB7XG4gICAgZm9udE9iai5pZCA9IE1hdGgucmFuZG9tKCkudG9TdHJpbmcoMzYpLnN1YnN0cmluZygyLCAxNSkgKyBNYXRoLnJhbmRvbSgpLnRvU3RyaW5nKDM2KS5zdWJzdHJpbmcoMiwgMTUpO1xuICB9XG5cbiAgLy8g0KPQsdC10LTQuNC80YHRjywg0YfRgtC+INC10YHRgtGMIGZvbnRGYW1pbHkgKNC+0L0g0LTQvtC70LbQtdC9INCx0YvRgtGMINGD0YHRgtCw0L3QvtCy0LvQtdC9INCyIHByb2Nlc3NMb2NhbEZvbnQg0LjQu9C4INCy0LfRj9GCINC40Lcg0LjRgdGC0L7Rh9C90LjQutCwKVxuICBjb25zdCBmb250RmFtaWx5TmFtZSA9IGZvbnRPYmouZm9udEZhbWlseTtcbiAgaWYgKCFmb250RmFtaWx5TmFtZSkge1xuICAgIGNvbnNvbGUuZXJyb3IoJ2ZvbnRPYmog0L3QtSDQuNC80LXQtdGCIGZvbnRGYW1pbHksINC90LUg0LzQvtCz0YMg0L7QsdC90L7QstC40YLRjCBDU1MuJywgZm9udE9iaik7XG4gICAgcmV0dXJuIGZvbnRPYmo7IC8vINCS0L7Qt9Cy0YDQsNGJ0LDQtdC8INCx0LXQtyDQuNC30LzQtdC90LXQvdC40LlcbiAgfVxuXG4gIC8vIC0tLSDQo9CU0JDQm9CV0J3QkCDQk9CV0J3QldCg0JDQptCY0K8gQGZvbnQtZmFjZSAtLS0gXG4gIC8vINCS0YHRjyDQu9C+0LPQuNC60LAsINGB0LLRj9C30LDQvdC90LDRjyDRgSBgc3JjOiB1cmwoLi4uKWAg0LggYGZvcm1hdCgpYCDRg9C00LDQu9C10L3QsC5cblxuICAvLyAtLS0g0JvQntCT0JjQmtCQINCe0JHQndCe0JLQm9CV0J3QmNCvIFZBUklBVElPTiBTRVRUSU5HUyAo0L7RgdGC0LDQstC70LXQvdCwINC00LvRjyDQvtCx0YDQsNGC0L3QvtC5INGB0L7QstC80LXRgdGC0LjQvNC+0YHRgtC4LCDQvdC+INC70YPRh9GI0LUg0LjRgdC/0L7Qu9GM0LfQvtCy0LDRgtGMIHVwZGF0ZVZhcmlhYmxlRm9udFNldHRpbmdzKSAtLS1cbiAgLy8gLi4uICjQutC+0LQg0LjQt9Cy0LvQtdGH0LXQvdC40Y8gY3VycmVudFNldHRpbmdzINC4INCz0LXQvdC10YDQsNGG0LjQuCB2YXJpYXRpb25TZXR0aW5nc1J1bGUg0L7RgdGC0LDQtdGC0YHRjywg0LrQsNC6INCyINC/0YDQtdC00YvQtNGD0YnQtdC8INCw0L3QsNC70LjQt9C1KVxuICBjb25zdCBjdXJyZW50U2V0dGluZ3MgPSB7fTtcbiAgaWYgKGZvbnRPYmouaXNWYXJpYWJsZUZvbnQgJiYgZm9udE9iai52YXJpYWJsZUF4ZXMpIHtcbiAgICBPYmplY3QuZW50cmllcyhmb250T2JqLnZhcmlhYmxlQXhlcykuZm9yRWFjaCgoW3RhZywgYXhpc0RhdGFdKSA9PiB7XG4gICAgICAgICBjb25zdCB2YWx1ZSA9IGF4aXNEYXRhPy5jdXJyZW50VmFsdWUgPz8gYXhpc0RhdGE/LmRlZmF1bHQ7XG4gICAgICAgICBpZiAodmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgIGN1cnJlbnRTZXR0aW5nc1t0YWddID0gdmFsdWU7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgXG4gIC8vINCf0L7QtNCz0L7RgtCw0LLQu9C40LLQsNC10Lwg0YHRgtGA0L7QutGDIGZvbnQtdmFyaWF0aW9uLXNldHRpbmdzXG4gIGxldCB2YXJpYXRpb25TZXR0aW5nc1J1bGUgPSAnJztcbiAgaWYgKGZvbnRPYmouaXNWYXJpYWJsZUZvbnQpIHtcbiAgICAgIGNvbnN0IHNldHRpbmdzVG9BcHBseSA9IE9iamVjdC5lbnRyaWVzKGN1cnJlbnRTZXR0aW5ncyk7XG4gICAgICBpZiAoc2V0dGluZ3NUb0FwcGx5Lmxlbmd0aCA+IDApIHtcbiAgICAgICAgICBjb25zdCBzZXR0aW5nc0FycmF5ID0gc2V0dGluZ3NUb0FwcGx5Lm1hcCgoW3RhZywgdmFsdWVdKSA9PiBgXFxcIiR7dGFnfVxcXCIgJHt2YWx1ZX1gKTtcbiAgICAgICAgICAvLyDQmNGB0L/QvtC70YzQt9GD0LXQvCBkYXRhLdCw0YLRgNC40LHRg9GCINC60LDQuiDRgdC10LvQtdC60YLQvtGAICjQv9GA0LjQvNC10YApXG4gICAgICAgICAgdmFyaWF0aW9uU2V0dGluZ3NSdWxlID0gYFtkYXRhLWZvbnQtZmFtaWx5PVwiJHtmb250RmFtaWx5TmFtZX1cIl0geyBmb250LXZhcmlhdGlvbi1zZXR0aW5nczogJHtzZXR0aW5nc0FycmF5LmpvaW4oJywgJyl9OyB9YDtcbiAgICAgIH1cbiAgfVxuXG4gIGNvbnN0IGNzc1J1bGUgPSB2YXJpYXRpb25TZXR0aW5nc1J1bGU7XG5cbiAgLy8g0J7QsdC90L7QstC70Y/QtdC8IENTUyDRgSDQv9C+0LzQvtGJ0YzRjiDQsdGD0YTQtdGA0LjQt9Cw0YbQuNC4LCDQtdGB0LvQuCDQtdGB0YLRjCDRh9GC0L4g0L7QsdC90L7QstC70Y/RgtGMXG4gIGlmIChjc3NSdWxlKSB7XG4gICAgICAvLyDQmNGB0L/QvtC70YzQt9GD0LXQvCBJRCArICctc2V0dGluZ3MnLCDRh9GC0L7QsdGLINC90LUg0LrQvtC90YTQu9C40LrRgtC+0LLQsNGC0Ywg0YEg0LLQvtC30LzQvtC20L3Ri9C8INGB0YLQsNGA0YvQvCBAZm9udC1mYWNlINGB0YLQuNC70LXQvFxuICAgICAgdXBkYXRlQnVmZmVyZWRGb250Q3NzKGZvbnRPYmouaWQgKyAnLXNldHRpbmdzJywgY3NzUnVsZSk7XG4gIH1cblxuICAgIHJldHVybiBmb250T2JqO1xufTtcblxuLyoqXG4gKiDQodC+0LfQtNCw0LXRgiDQtNC10LHQsNGD0L3RgdC40YDQvtCy0LDQvdC90YPRjiDQstC10YDRgdC40Y4g0YTRg9C90LrRhtC40Lgg0LTQu9GPINC/0YDQtdC00L7RgtCy0YDQsNGJ0LXQvdC40Y8g0YfQsNGB0YLRi9GFINCy0YvQt9C+0LLQvtCyXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIC0g0KTRg9C90LrRhtC40Y8g0LTQu9GPINC00LXQsdCw0YPQvdGB0LjQvdCz0LBcbiAqIEBwYXJhbSB7bnVtYmVyfSB3YWl0IC0g0JLRgNC10LzRjyDQvtC20LjQtNCw0L3QuNGPINCyINC80LjQu9C70LjRgdC10LrRg9C90LTQsNGFXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IC0g0JTQtdCx0LDRg9C90YHQuNGA0L7QstCw0L3QvdCw0Y8g0YTRg9C90LrRhtC40Y9cbiAqL1xuZXhwb3J0IGNvbnN0IGRlYm91bmNlID0gKGZ1bmMsIHdhaXQgPSA1MCkgPT4ge1xuICBsZXQgdGltZW91dDtcbiAgcmV0dXJuIGZ1bmN0aW9uKC4uLmFyZ3MpIHtcbiAgICBjb25zdCBjb250ZXh0ID0gdGhpcztcbiAgICBjbGVhclRpbWVvdXQodGltZW91dCk7XG4gICAgdGltZW91dCA9IHNldFRpbWVvdXQoKCkgPT4gZnVuYy5hcHBseShjb250ZXh0LCBhcmdzKSwgd2FpdCk7XG4gIH07XG59O1xuXG4vKipcbiAqINCU0LXQsdCw0YPQvdGB0LjRgNC+0LLQsNC90L3QsNGPINCy0LXRgNGB0LjRjyBhZGRGb250RmFjZSDQtNC70Y8g0LHQtdC30L7Qv9Cw0YHQvdC+0LPQviDQstGL0LfQvtCy0LAg0L/RgNC4INC40LfQvNC10L3QtdC90LjQuCDQvtGB0LXQuVxuICovXG5leHBvcnQgY29uc3QgZGVib3VuY2VkQWRkRm9udEZhY2UgPSBkZWJvdW5jZShhZGRGb250RmFjZSwgNTApO1xuXG4vKipcbiAqINCf0LXRgNC10LjQvNC10L3QvtCy0YvQstCw0LXQvCB1cGRhdGVGb250RmFjZUlmTmVlZGVkINCyIHVwZGF0ZVZhcmlhYmxlRm9udFNldHRpbmdzXG4gKiBAcGFyYW0ge09iamVjdH0gZm9udE9iaiAtINCe0LHRitC10LrRgiDRiNGA0LjRhNGC0LBcbiAqIEBwYXJhbSB7T2JqZWN0fSBjdXJyZW50U2V0dGluZ3MgLSDQntCx0YrQtdC60YIg0YEg0YLQtdC60YPRidC40LzQuCDQvdCw0YHRgtGA0L7QudC60LDQvNC4INC+0YHQtdC5IHsgdGFnOiB2YWx1ZSwgLi4uIH1cbiAqIEBwYXJhbSB7T2JqZWN0fSBwcmV2U2V0dGluZ3MgLSDQn9GA0LXQtNGL0LTRg9GJ0LjQtSDQvdCw0YHRgtGA0L7QudC60LggKNC+0L/RhtC40L7QvdCw0LvRjNC90L4sINC00LvRjyBoYXNTaWduaWZpY2FudENoYW5nZXMpXG4gKiBAcmV0dXJucyB7T2JqZWN0fSAtINCY0YHRhdC+0LTQvdGL0LkgZm9udE9ialxuICovXG5leHBvcnQgY29uc3QgdXBkYXRlVmFyaWFibGVGb250U2V0dGluZ3MgPSAoZm9udE9iaiwgY3VycmVudFNldHRpbmdzLCBwcmV2U2V0dGluZ3MgPSBudWxsKSA9PiB7XG4gICAgaWYgKCFmb250T2JqIHx8ICFmb250T2JqLmZvbnRGYW1pbHkgfHwgIWZvbnRPYmouaXNWYXJpYWJsZUZvbnQpIHtcbiAgICAgICAgY29uc29sZS53YXJuKCd1cGRhdGVWYXJpYWJsZUZvbnRTZXR0aW5nczog0J3QtdCy0LDQu9C40LTQvdGL0LkgZm9udE9iaiDQuNC70Lgg0L3QtSDQstCw0YDQuNCw0YLQuNCy0L3Ri9C5INGI0YDQuNGE0YIuJyk7XG4gICAgICAgIHJldHVybiBmb250T2JqO1xuICAgIH1cbiAgICBpZiAoIWN1cnJlbnRTZXR0aW5ncyB8fCB0eXBlb2YgY3VycmVudFNldHRpbmdzICE9PSAnb2JqZWN0Jykge1xuICAgICAgICBjb25zb2xlLndhcm4oJ3VwZGF0ZVZhcmlhYmxlRm9udFNldHRpbmdzOiDQndC1INC/0YDQtdC00L7RgdGC0LDQstC70LXQvdGLIGN1cnJlbnRTZXR0aW5ncy4nKTtcbiAgICAgICAgcmV0dXJuIGZvbnRPYmo7XG4gICAgfVxuXG4gICAgY29uc3QgZm9udEZhbWlseU5hbWUgPSBmb250T2JqLmZvbnRGYW1pbHk7XG4gICAgY29uc3QgZm9udElkID0gZm9udE9iai5pZCB8fCBmb250RmFtaWx5TmFtZTsgLy8g0J3Rg9C20LXQvSBJRCDQtNC70Y8gdXBkYXRlQnVmZmVyZWRGb250Q3NzXG5cbiAgICAvLyDQntC/0YbQuNC+0L3QsNC70YzQvdCw0Y8g0L/RgNC+0LLQtdGA0LrQsCDQvdCwINC30L3QsNGH0LjRgtC10LvRjNC90YvQtSDQuNC30LzQtdC90LXQvdC40Y9cbiAgICAvLyBpZiAocHJldlNldHRpbmdzICYmICFoYXNTaWduaWZpY2FudENoYW5nZXMocHJldlNldHRpbmdzLCBjdXJyZW50U2V0dGluZ3MpKSB7XG4gICAgLy8gICAgIHJldHVybiBmb250T2JqOyAvLyDQndC10YIg0LfQvdCw0YfQuNGC0LXQu9GM0L3Ri9GFINC40LfQvNC10L3QtdC90LjQuVxuICAgIC8vIH1cblxuICAgIC8vINCk0L7RgNC80LjRgNGD0LXQvCBDU1Mg0L/RgNCw0LLQuNC70L4g0KLQntCb0KzQmtCeINC00LvRjyBmb250LXZhcmlhdGlvbi1zZXR0aW5nc1xuICAgIGxldCB2YXJpYXRpb25TZXR0aW5nc1J1bGUgPSAnJztcbiAgICBjb25zdCBzZXR0aW5nc1RvQXBwbHkgPSBPYmplY3QuZW50cmllcyhjdXJyZW50U2V0dGluZ3MpO1xuICAgIGlmIChzZXR0aW5nc1RvQXBwbHkubGVuZ3RoID4gMCkge1xuICAgICAgICBjb25zdCBzZXR0aW5nc0FycmF5ID0gc2V0dGluZ3NUb0FwcGx5Lm1hcCgoW3RhZywgdmFsdWVdKSA9PiBgXFxcIiR7dGFnfVxcXCIgJHt2YWx1ZX1gKTtcbiAgICAgICAgLy8g0JjRgdC/0L7Qu9GM0LfRg9C10LwgZGF0YS3QsNGC0YDQuNCx0YPRgiDQutCw0Log0YHQtdC70LXQutGC0L7RgC4g0KPQsdC10LTQuNGB0YwsINGH0YLQviDRjdC70LXQvNC10L3RgiDQv9GA0LXQstGM0Y4g0LjQvNC10LXRgiDRjdGC0L7RgiDQsNGC0YDQuNCx0YPRgiFcbiAgICAgICAgdmFyaWF0aW9uU2V0dGluZ3NSdWxlID0gYFtkYXRhLWZvbnQtZmFtaWx5PVwiJHtmb250RmFtaWx5TmFtZX1cIl0geyBmb250LXZhcmlhdGlvbi1zZXR0aW5nczogJHtzZXR0aW5nc0FycmF5LmpvaW4oJywgJyl9OyB9YDtcbiAgICAgICAgLy8g0JDQu9GM0YLQtdGA0L3QsNGC0LjQstCwOiBDU1Mg0L/QtdGA0LXQvNC10L3QvdGL0LUgKNGC0YDQtdCx0YPQtdGCINC40LfQvNC10L3QtdC90LjQuSDQsiDQutC+0LzQv9C+0L3QtdC90YLQtSlcbiAgICAgICAgLy8gdmFyaWF0aW9uU2V0dGluZ3NSdWxlID0gYDpyb290IHsgJHtzZXR0aW5nc0FycmF5Lm1hcCgoW3RhZywgdmFsdWVdKSA9PiBgLS0ke2ZvbnRJZH0tJHt0YWd9OiAke3ZhbHVlfTtgKS5qb2luKCdcXG4nKX0gfWA7XG4gICAgfVxuXG4gICAgLy8g0J7QsdC90L7QstC70Y/QtdC8IENTUyDRh9C10YDQtdC3INCx0YPRhNC10YBcbiAgICBpZiAodmFyaWF0aW9uU2V0dGluZ3NSdWxlKSB7XG4gICAgICAgIHVwZGF0ZUJ1ZmZlcmVkRm9udENzcyhmb250SWQgKyAnLXNldHRpbmdzJywgdmFyaWF0aW9uU2V0dGluZ3NSdWxlKTsgLy8g0JjRgdC/0L7Qu9GM0LfRg9C10Lwg0YPQvdC40LrQsNC70YzQvdGL0LkgSUQg0LTQu9GPINGB0YLQuNC70LXQuSDQvdCw0YHRgtGA0L7QtdC6XG4gICAgfSBlbHNlIHtcbiAgICAgICAgLy8g0JXRgdC70Lgg0L3QsNGB0YLRgNC+0LXQuiDQvdC10YIsINCy0L7Qt9C80L7QttC90L4sINC90YPQttC90L4g0YPQtNCw0LvQuNGC0Ywg0L/RgNC10LTRi9C00YPRidC10LUg0L/RgNCw0LLQuNC70L4/XG4gICAgICAgIC8vIHVwZGF0ZUJ1ZmZlcmVkRm9udENzcyhmb250SWQgKyAnLXNldHRpbmdzJywgJycpOyAvLyDQntGH0LjRgdGC0LjRgtGMINGB0YLQuNC70YxcbiAgICB9XG5cbiAgICByZXR1cm4gZm9udE9iajtcbn07XG5cbi8vINCU0LXQsdCw0YPQvdGB0LjRgNC+0LLQsNC90L3QsNGPINCy0LXRgNGB0LjRjyB1cGRhdGVWYXJpYWJsZUZvbnRTZXR0aW5ncyAo0L7RgdGC0LDQtdGC0YHRjylcbmV4cG9ydCBjb25zdCBkZWJvdW5jZWRVcGRhdGVWYXJpYWJsZUZvbnRTZXR0aW5ncyA9IGRlYm91bmNlKHVwZGF0ZVZhcmlhYmxlRm9udFNldHRpbmdzLCA1MCk7XG5cbi8qKlxuICog0KHRh9C10YLRh9C40Log0LTQu9GPINC+0YLRgdC70LXQttC40LLQsNC90LjRjyDQutC+0LvQuNGH0LXRgdGC0LLQsCDQt9Cw0LPRgNGD0LfQvtC6INGI0YDQuNGE0YLQvtCyINC00LvRjyDQvtGC0LvQsNC00LrQuFxuICovXG5sZXQgZm9udExvYWRDb3VudGVyID0gMDtcblxuIl0sIm5hbWVzIjpbInRvYXN0IiwiZ2V0Rm9ybWF0RnJvbUV4dGVuc2lvbiIsImhhc1NpZ25pZmljYW50Q2hhbmdlcyIsInByZXZTZXR0aW5ncyIsImN1cnJlbnRTZXR0aW5ncyIsInRocmVzaG9sZCIsInByZXZLZXlzIiwiT2JqZWN0Iiwia2V5cyIsImN1cnJlbnRLZXlzIiwibGVuZ3RoIiwia2V5IiwiTWF0aCIsImFicyIsInBhcnNlRmxvYXQiLCJmb250Q3NzQnVmZmVyIiwibWFpbiIsIk1hcCIsInNoYWRvdyIsInN3aXRjaGluZyIsImFuaW1hdGlvbkZyYW1lSWQiLCJ1cGRhdGVCdWZmZXJlZEZvbnRDc3MiLCJmb250SWQiLCJjc3NSdWxlIiwic2V0IiwicmVxdWVzdEFuaW1hdGlvbkZyYW1lIiwiZm9yRWFjaCIsInJ1bGUiLCJpZCIsInN0eWxlRWxlbWVudCIsImRvY3VtZW50IiwicXVlcnlTZWxlY3RvciIsImNyZWF0ZUVsZW1lbnQiLCJzZXRBdHRyaWJ1dGUiLCJoZWFkIiwiYXBwZW5kQ2hpbGQiLCJ0ZXh0Q29udGVudCIsImVycm9yIiwiY29uc29sZSIsImNsZWFyIiwiZm9udEZhY2VDYWNoZSIsImxvYWRGb250RmFjZUlmTmVlZGVkIiwiZm9udEZhbWlseSIsInVybCIsInNldHRpbmdzIiwiY2FjaGVLZXkiLCJoYXMiLCJjYWNoZWRQcm9taXNlIiwiZ2V0IiwiZm9udEZhY2UiLCJmb250cyIsImFkZCIsIndhcm4iLCJkZWxldGUiLCJsb2FkUHJvbWlzZSIsIm9wdGlvbnMiLCJsb2ciLCJGb250RmFjZSIsImxvYWQiLCJhZGRGb250RmFjZSIsImZvbnRPYmoiLCJyYW5kb20iLCJ0b1N0cmluZyIsInN1YnN0cmluZyIsImZvbnRGYW1pbHlOYW1lIiwiaXNWYXJpYWJsZUZvbnQiLCJ2YXJpYWJsZUF4ZXMiLCJlbnRyaWVzIiwidGFnIiwiYXhpc0RhdGEiLCJ2YWx1ZSIsImN1cnJlbnRWYWx1ZSIsImRlZmF1bHQiLCJ1bmRlZmluZWQiLCJ2YXJpYXRpb25TZXR0aW5nc1J1bGUiLCJzZXR0aW5nc1RvQXBwbHkiLCJzZXR0aW5nc0FycmF5IiwibWFwIiwiam9pbiIsImRlYm91bmNlIiwiZnVuYyIsIndhaXQiLCJ0aW1lb3V0IiwiYXJncyIsImNvbnRleHQiLCJjbGVhclRpbWVvdXQiLCJzZXRUaW1lb3V0IiwiYXBwbHkiLCJkZWJvdW5jZWRBZGRGb250RmFjZSIsInVwZGF0ZVZhcmlhYmxlRm9udFNldHRpbmdzIiwiZGVib3VuY2VkVXBkYXRlVmFyaWFibGVGb250U2V0dGluZ3MiLCJmb250TG9hZENvdW50ZXIiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./utils/cssGenerator.js\n"));

/***/ }),

/***/ "./utils/db.js":
/*!*********************!*\
  !*** ./utils/db.js ***!
  \*********************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   deleteAllFontsDB: function() { return /* binding */ deleteAllFontsDB; },\n/* harmony export */   deleteFontDB: function() { return /* binding */ deleteFontDB; },\n/* harmony export */   getAllFonts: function() { return /* binding */ getAllFonts; },\n/* harmony export */   saveFont: function() { return /* binding */ saveFont; },\n/* harmony export */   updateFontSettings: function() { return /* binding */ updateFontSettings; }\n/* harmony export */ });\n// utils/db.js\nconst DB_NAME = \"FontGauntletDB\";\nconst DB_VERSION = 1;\nconst STORE_NAME = \"fonts\";\nlet dbPromise = null;\n/**\n * Открывает (или создает/обновляет) базу данных IndexedDB.\n * @returns {Promise<IDBDatabase>} Промис с объектом базы данных.\n */ function openDB() {\n    if (dbPromise) {\n        return dbPromise;\n    }\n    dbPromise = new Promise((resolve, reject)=>{\n        const request = indexedDB.open(DB_NAME, DB_VERSION);\n        request.onerror = (event)=>{\n            console.error(\"Ошибка открытия IndexedDB:\", event.target.error);\n            reject(\"Ошибка открытия IndexedDB\");\n        };\n        request.onsuccess = (event)=>{\n            console.log(\"IndexedDB успешно открыта\");\n            resolve(event.target.result);\n        };\n        // Вызывается при создании БД или обновлении версии\n        request.onupgradeneeded = (event)=>{\n            console.log(\"Обновление схемы IndexedDB...\");\n            const db = event.target.result;\n            if (!db.objectStoreNames.contains(STORE_NAME)) {\n                console.log(\"Создание хранилища объектов: \".concat(STORE_NAME));\n                // Создаем хранилище объектов для шрифтов\n                // 'id' будет ключом\n                db.createObjectStore(STORE_NAME, {\n                    keyPath: \"id\"\n                });\n            // Можно добавить индексы при необходимости, например:\n            // store.createIndex('name', 'name', { unique: false });\n            }\n        };\n    });\n    return dbPromise;\n}\n/**\n * Сохраняет объект шрифта в IndexedDB.\n * @param {Object} fontObj - Объект шрифта для сохранения (должен содержать Blob в поле file).\n * @returns {Promise<void>}\n */ async function saveFont(fontObj) {\n    if (!fontObj || !fontObj.id || !fontObj.file) {\n        console.warn(\"Попытка сохранить некорректный fontObj в IndexedDB\", fontObj);\n        return;\n    }\n    try {\n        const db = await openDB();\n        const transaction = db.transaction(STORE_NAME, \"readwrite\");\n        const store = transaction.objectStore(STORE_NAME);\n        // Используем put для вставки или обновления\n        const request = store.put(fontObj);\n        return new Promise((resolve, reject)=>{\n            request.onsuccess = ()=>{\n                // console.log(`Шрифт ${fontObj.name} (${fontObj.id}) сохранен в IndexedDB`);\n                resolve();\n            };\n            request.onerror = (event)=>{\n                console.error(\"Ошибка сохранения шрифта в IndexedDB:\", event.target.error);\n                reject(\"Ошибка сохранения шрифта\");\n            };\n        });\n    } catch (error) {\n        console.error(\"Не удалось выполнить транзакцию сохранения в IndexedDB:\", error);\n    }\n}\n/**\n * Получает все объекты шрифтов из IndexedDB.\n * @returns {Promise<Array<Object>>} Промис с массивом объектов шрифтов.\n */ async function getAllFonts() {\n    try {\n        const db = await openDB();\n        const transaction = db.transaction(STORE_NAME, \"readonly\");\n        const store = transaction.objectStore(STORE_NAME);\n        const request = store.getAll();\n        return new Promise((resolve, reject)=>{\n            request.onsuccess = (event)=>{\n                resolve(event.target.result || []);\n            };\n            request.onerror = (event)=>{\n                console.error(\"Ошибка получения всех шрифтов из IndexedDB:\", event.target.error);\n                reject(\"Ошибка получения шрифтов\");\n            };\n        });\n    } catch (error) {\n        console.error(\"Не удалось выполнить транзакцию чтения из IndexedDB:\", error);\n        return []; // Возвращаем пустой массив при ошибке\n    }\n}\n/**\n * Удаляет объект шрифта из IndexedDB по ID.\n * @param {string} fontId - ID шрифта для удаления.\n * @returns {Promise<void>}\n */ async function deleteFontDB(fontId) {\n    if (!fontId) return;\n    try {\n        const db = await openDB();\n        const transaction = db.transaction(STORE_NAME, \"readwrite\");\n        const store = transaction.objectStore(STORE_NAME);\n        const request = store.delete(fontId);\n        return new Promise((resolve, reject)=>{\n            request.onsuccess = ()=>{\n                // console.log(`Шрифт ${fontId} удален из IndexedDB`);\n                resolve();\n            };\n            request.onerror = (event)=>{\n                console.error(\"Ошибка удаления шрифта из IndexedDB:\", event.target.error);\n                reject(\"Ошибка удаления шрифта\");\n            };\n        });\n    } catch (error) {\n        console.error(\"Не удалось выполнить транзакцию удаления из IndexedDB:\", error);\n    }\n}\n/**\n * Удаляет ВСЕ объекты шрифтов из хранилища IndexedDB.\n * @returns {Promise<void>}\n */ async function deleteAllFontsDB() {\n    try {\n        const db = await openDB();\n        const transaction = db.transaction(STORE_NAME, \"readwrite\");\n        const store = transaction.objectStore(STORE_NAME);\n        // Используем clear() для удаления всех записей\n        const request = store.clear();\n        return new Promise((resolve, reject)=>{\n            request.onsuccess = ()=>{\n                console.log(\"Все шрифты удалены из IndexedDB (хранилище \".concat(STORE_NAME, \")\"));\n                resolve();\n            };\n            request.onerror = (event)=>{\n                console.error(\"Ошибка очистки хранилища шрифтов в IndexedDB:\", event.target.error);\n                reject(\"Ошибка очистки хранилища шрифтов\");\n            };\n        });\n    } catch (error) {\n        console.error(\"Не удалось выполнить транзакцию очистки хранилища IndexedDB:\", error);\n    // Не пробрасываем ошибку дальше, просто логируем\n    }\n}\n/**\n * Обновляет настройки шрифта в IndexedDB (lastUsedPresetName, lastUsedVariableSettings, currentWeight, currentStyle).\n * @param {string} fontId - ID шрифта для обновления.\n * @param {Object} updates - Объект с обновлениями для шрифта.\n * @returns {Promise<void>}\n */ async function updateFontSettings(fontId, updates) {\n    if (!fontId || !updates) {\n        console.warn(\"updateFontSettings: некорректные параметры\", {\n            fontId,\n            updates\n        });\n        return;\n    }\n    try {\n        const db = await openDB();\n        const transaction = db.transaction(STORE_NAME, \"readwrite\");\n        const store = transaction.objectStore(STORE_NAME);\n        // Сначала получаем существующий объект\n        const getRequest = store.get(fontId);\n        return new Promise((resolve, reject)=>{\n            getRequest.onsuccess = ()=>{\n                const existingFont = getRequest.result;\n                if (!existingFont) {\n                    console.warn(\"updateFontSettings: шрифт \".concat(fontId, \" не найден в IndexedDB\"));\n                    resolve();\n                    return;\n                }\n                // Обновляем только нужные поля\n                const updatedFont = {\n                    ...existingFont,\n                    ...updates,\n                    // Обновляем timestamp для отслеживания изменений\n                    lastUpdated: Date.now()\n                };\n                // Сохраняем обновленный объект\n                const putRequest = store.put(updatedFont);\n                putRequest.onsuccess = ()=>{\n                    console.log(\"Настройки шрифта \".concat(fontId, \" обновлены в IndexedDB:\"), updates);\n                    resolve();\n                };\n                putRequest.onerror = (event)=>{\n                    console.error(\"Ошибка обновления настроек шрифта в IndexedDB:\", event.target.error);\n                    reject(\"Ошибка обновления настроек шрифта\");\n                };\n            };\n            getRequest.onerror = (event)=>{\n                console.error(\"Ошибка получения шрифта для обновления из IndexedDB:\", event.target.error);\n                reject(\"Ошибка получения шрифта для обновления\");\n            };\n        });\n    } catch (error) {\n        console.error(\"Не удалось выполнить транзакцию обновления в IndexedDB:\", error);\n    }\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi91dGlscy9kYi5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7OztBQUFBLGNBQWM7QUFFZCxNQUFNQSxVQUFVO0FBQ2hCLE1BQU1DLGFBQWE7QUFDbkIsTUFBTUMsYUFBYTtBQUVuQixJQUFJQyxZQUFZO0FBRWhCOzs7Q0FHQyxHQUNELFNBQVNDO0lBQ1AsSUFBSUQsV0FBVztRQUNiLE9BQU9BO0lBQ1Q7SUFDQUEsWUFBWSxJQUFJRSxRQUFRLENBQUNDLFNBQVNDO1FBQ2hDLE1BQU1DLFVBQVVDLFVBQVVDLElBQUksQ0FBQ1YsU0FBU0M7UUFFeENPLFFBQVFHLE9BQU8sR0FBRyxDQUFDQztZQUNqQkMsUUFBUUMsS0FBSyxDQUFDLDhCQUE4QkYsTUFBTUcsTUFBTSxDQUFDRCxLQUFLO1lBQzlEUCxPQUFPO1FBQ1Q7UUFFQUMsUUFBUVEsU0FBUyxHQUFHLENBQUNKO1lBQ25CQyxRQUFRSSxHQUFHLENBQUM7WUFDWlgsUUFBUU0sTUFBTUcsTUFBTSxDQUFDRyxNQUFNO1FBQzdCO1FBRUEsbURBQW1EO1FBQ25EVixRQUFRVyxlQUFlLEdBQUcsQ0FBQ1A7WUFDekJDLFFBQVFJLEdBQUcsQ0FBQztZQUNaLE1BQU1HLEtBQUtSLE1BQU1HLE1BQU0sQ0FBQ0csTUFBTTtZQUM5QixJQUFJLENBQUNFLEdBQUdDLGdCQUFnQixDQUFDQyxRQUFRLENBQUNwQixhQUFhO2dCQUM3Q1csUUFBUUksR0FBRyxDQUFDLGdDQUEyQyxPQUFYZjtnQkFDNUMseUNBQXlDO2dCQUN6QyxvQkFBb0I7Z0JBQ3BCa0IsR0FBR0csaUJBQWlCLENBQUNyQixZQUFZO29CQUFFc0IsU0FBUztnQkFBSztZQUNqRCxzREFBc0Q7WUFDdEQsd0RBQXdEO1lBQzFEO1FBQ0Y7SUFDRjtJQUNBLE9BQU9yQjtBQUNUO0FBRUE7Ozs7Q0FJQyxHQUNNLGVBQWVzQixTQUFTQyxPQUFPO0lBQ3BDLElBQUksQ0FBQ0EsV0FBVyxDQUFDQSxRQUFRQyxFQUFFLElBQUksQ0FBQ0QsUUFBUUUsSUFBSSxFQUFFO1FBQzFDZixRQUFRZ0IsSUFBSSxDQUFDLHNEQUFzREg7UUFDbkU7SUFDSjtJQUNBLElBQUk7UUFDRixNQUFNTixLQUFLLE1BQU1oQjtRQUNqQixNQUFNMEIsY0FBY1YsR0FBR1UsV0FBVyxDQUFDNUIsWUFBWTtRQUMvQyxNQUFNNkIsUUFBUUQsWUFBWUUsV0FBVyxDQUFDOUI7UUFDdEMsNENBQTRDO1FBQzVDLE1BQU1NLFVBQVV1QixNQUFNRSxHQUFHLENBQUNQO1FBRTFCLE9BQU8sSUFBSXJCLFFBQVEsQ0FBQ0MsU0FBU0M7WUFDM0JDLFFBQVFRLFNBQVMsR0FBRztnQkFDbEIsNkVBQTZFO2dCQUM3RVY7WUFDRjtZQUNBRSxRQUFRRyxPQUFPLEdBQUcsQ0FBQ0M7Z0JBQ2pCQyxRQUFRQyxLQUFLLENBQUMseUNBQXlDRixNQUFNRyxNQUFNLENBQUNELEtBQUs7Z0JBQ3pFUCxPQUFPO1lBQ1Q7UUFDRjtJQUNGLEVBQUUsT0FBT08sT0FBTztRQUNaRCxRQUFRQyxLQUFLLENBQUMsMkRBQTJEQTtJQUM3RTtBQUNGO0FBRUE7OztDQUdDLEdBQ00sZUFBZW9CO0lBQ3BCLElBQUk7UUFDRixNQUFNZCxLQUFLLE1BQU1oQjtRQUNqQixNQUFNMEIsY0FBY1YsR0FBR1UsV0FBVyxDQUFDNUIsWUFBWTtRQUMvQyxNQUFNNkIsUUFBUUQsWUFBWUUsV0FBVyxDQUFDOUI7UUFDdEMsTUFBTU0sVUFBVXVCLE1BQU1JLE1BQU07UUFFNUIsT0FBTyxJQUFJOUIsUUFBUSxDQUFDQyxTQUFTQztZQUMzQkMsUUFBUVEsU0FBUyxHQUFHLENBQUNKO2dCQUNuQk4sUUFBUU0sTUFBTUcsTUFBTSxDQUFDRyxNQUFNLElBQUksRUFBRTtZQUNuQztZQUNBVixRQUFRRyxPQUFPLEdBQUcsQ0FBQ0M7Z0JBQ2pCQyxRQUFRQyxLQUFLLENBQUMsK0NBQStDRixNQUFNRyxNQUFNLENBQUNELEtBQUs7Z0JBQy9FUCxPQUFPO1lBQ1Q7UUFDRjtJQUNGLEVBQUUsT0FBT08sT0FBTztRQUNaRCxRQUFRQyxLQUFLLENBQUMsd0RBQXdEQTtRQUN0RSxPQUFPLEVBQUUsRUFBRSxzQ0FBc0M7SUFDckQ7QUFDRjtBQUVBOzs7O0NBSUMsR0FDTSxlQUFlc0IsYUFBYUMsTUFBTTtJQUN2QyxJQUFJLENBQUNBLFFBQVE7SUFDYixJQUFJO1FBQ0YsTUFBTWpCLEtBQUssTUFBTWhCO1FBQ2pCLE1BQU0wQixjQUFjVixHQUFHVSxXQUFXLENBQUM1QixZQUFZO1FBQy9DLE1BQU02QixRQUFRRCxZQUFZRSxXQUFXLENBQUM5QjtRQUN0QyxNQUFNTSxVQUFVdUIsTUFBTU8sTUFBTSxDQUFDRDtRQUU3QixPQUFPLElBQUloQyxRQUFRLENBQUNDLFNBQVNDO1lBQzNCQyxRQUFRUSxTQUFTLEdBQUc7Z0JBQ2xCLHNEQUFzRDtnQkFDdERWO1lBQ0Y7WUFDQUUsUUFBUUcsT0FBTyxHQUFHLENBQUNDO2dCQUNqQkMsUUFBUUMsS0FBSyxDQUFDLHdDQUF3Q0YsTUFBTUcsTUFBTSxDQUFDRCxLQUFLO2dCQUN4RVAsT0FBTztZQUNUO1FBQ0Y7SUFDRixFQUFFLE9BQU9PLE9BQU87UUFDWEQsUUFBUUMsS0FBSyxDQUFDLDBEQUEwREE7SUFDN0U7QUFDRjtBQUVBOzs7Q0FHQyxHQUNNLGVBQWV5QjtJQUNwQixJQUFJO1FBQ0YsTUFBTW5CLEtBQUssTUFBTWhCO1FBQ2pCLE1BQU0wQixjQUFjVixHQUFHVSxXQUFXLENBQUM1QixZQUFZO1FBQy9DLE1BQU02QixRQUFRRCxZQUFZRSxXQUFXLENBQUM5QjtRQUN0QywrQ0FBK0M7UUFDL0MsTUFBTU0sVUFBVXVCLE1BQU1TLEtBQUs7UUFFM0IsT0FBTyxJQUFJbkMsUUFBUSxDQUFDQyxTQUFTQztZQUMzQkMsUUFBUVEsU0FBUyxHQUFHO2dCQUNsQkgsUUFBUUksR0FBRyxDQUFDLDhDQUF5RCxPQUFYZixZQUFXO2dCQUNyRUk7WUFDRjtZQUNBRSxRQUFRRyxPQUFPLEdBQUcsQ0FBQ0M7Z0JBQ2pCQyxRQUFRQyxLQUFLLENBQUMsaURBQWlERixNQUFNRyxNQUFNLENBQUNELEtBQUs7Z0JBQ2pGUCxPQUFPO1lBQ1Q7UUFDRjtJQUNGLEVBQUUsT0FBT08sT0FBTztRQUNkRCxRQUFRQyxLQUFLLENBQUMsZ0VBQWdFQTtJQUM5RSxpREFBaUQ7SUFDbkQ7QUFDRjtBQUVBOzs7OztDQUtDLEdBQ00sZUFBZTJCLG1CQUFtQkosTUFBTSxFQUFFSyxPQUFPO0lBQ3RELElBQUksQ0FBQ0wsVUFBVSxDQUFDSyxTQUFTO1FBQ3ZCN0IsUUFBUWdCLElBQUksQ0FBQyw4Q0FBOEM7WUFBRVE7WUFBUUs7UUFBUTtRQUM3RTtJQUNGO0lBRUEsSUFBSTtRQUNGLE1BQU10QixLQUFLLE1BQU1oQjtRQUNqQixNQUFNMEIsY0FBY1YsR0FBR1UsV0FBVyxDQUFDNUIsWUFBWTtRQUMvQyxNQUFNNkIsUUFBUUQsWUFBWUUsV0FBVyxDQUFDOUI7UUFFdEMsdUNBQXVDO1FBQ3ZDLE1BQU15QyxhQUFhWixNQUFNYSxHQUFHLENBQUNQO1FBRTdCLE9BQU8sSUFBSWhDLFFBQVEsQ0FBQ0MsU0FBU0M7WUFDM0JvQyxXQUFXM0IsU0FBUyxHQUFHO2dCQUNyQixNQUFNNkIsZUFBZUYsV0FBV3pCLE1BQU07Z0JBQ3RDLElBQUksQ0FBQzJCLGNBQWM7b0JBQ2pCaEMsUUFBUWdCLElBQUksQ0FBQyw2QkFBb0MsT0FBUFEsUUFBTztvQkFDakQvQjtvQkFDQTtnQkFDRjtnQkFFQSwrQkFBK0I7Z0JBQy9CLE1BQU13QyxjQUFjO29CQUNsQixHQUFHRCxZQUFZO29CQUNmLEdBQUdILE9BQU87b0JBQ1YsaURBQWlEO29CQUNqREssYUFBYUMsS0FBS0MsR0FBRztnQkFDdkI7Z0JBRUEsK0JBQStCO2dCQUMvQixNQUFNQyxhQUFhbkIsTUFBTUUsR0FBRyxDQUFDYTtnQkFFN0JJLFdBQVdsQyxTQUFTLEdBQUc7b0JBQ3JCSCxRQUFRSSxHQUFHLENBQUMsb0JBQTJCLE9BQVBvQixRQUFPLDRCQUEwQks7b0JBQ2pFcEM7Z0JBQ0Y7Z0JBRUE0QyxXQUFXdkMsT0FBTyxHQUFHLENBQUNDO29CQUNwQkMsUUFBUUMsS0FBSyxDQUFDLGtEQUFrREYsTUFBTUcsTUFBTSxDQUFDRCxLQUFLO29CQUNsRlAsT0FBTztnQkFDVDtZQUNGO1lBRUFvQyxXQUFXaEMsT0FBTyxHQUFHLENBQUNDO2dCQUNwQkMsUUFBUUMsS0FBSyxDQUFDLHdEQUF3REYsTUFBTUcsTUFBTSxDQUFDRCxLQUFLO2dCQUN4RlAsT0FBTztZQUNUO1FBQ0Y7SUFDRixFQUFFLE9BQU9PLE9BQU87UUFDZEQsUUFBUUMsS0FBSyxDQUFDLDJEQUEyREE7SUFDM0U7QUFDRiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi91dGlscy9kYi5qcz83Y2IyIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIHV0aWxzL2RiLmpzXG5cbmNvbnN0IERCX05BTUUgPSAnRm9udEdhdW50bGV0REInO1xuY29uc3QgREJfVkVSU0lPTiA9IDE7XG5jb25zdCBTVE9SRV9OQU1FID0gJ2ZvbnRzJztcblxubGV0IGRiUHJvbWlzZSA9IG51bGw7XG5cbi8qKlxuICog0J7RgtC60YDRi9Cy0LDQtdGCICjQuNC70Lgg0YHQvtC30LTQsNC10YIv0L7QsdC90L7QstC70Y/QtdGCKSDQsdCw0LfRgyDQtNCw0L3QvdGL0YUgSW5kZXhlZERCLlxuICogQHJldHVybnMge1Byb21pc2U8SURCRGF0YWJhc2U+fSDQn9GA0L7QvNC40YEg0YEg0L7QsdGK0LXQutGC0L7QvCDQsdCw0LfRiyDQtNCw0L3QvdGL0YUuXG4gKi9cbmZ1bmN0aW9uIG9wZW5EQigpIHtcbiAgaWYgKGRiUHJvbWlzZSkge1xuICAgIHJldHVybiBkYlByb21pc2U7XG4gIH1cbiAgZGJQcm9taXNlID0gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgIGNvbnN0IHJlcXVlc3QgPSBpbmRleGVkREIub3BlbihEQl9OQU1FLCBEQl9WRVJTSU9OKTtcblxuICAgIHJlcXVlc3Qub25lcnJvciA9IChldmVudCkgPT4ge1xuICAgICAgY29uc29sZS5lcnJvcihcItCe0YjQuNCx0LrQsCDQvtGC0LrRgNGL0YLQuNGPIEluZGV4ZWREQjpcIiwgZXZlbnQudGFyZ2V0LmVycm9yKTtcbiAgICAgIHJlamVjdChcItCe0YjQuNCx0LrQsCDQvtGC0LrRgNGL0YLQuNGPIEluZGV4ZWREQlwiKTtcbiAgICB9O1xuXG4gICAgcmVxdWVzdC5vbnN1Y2Nlc3MgPSAoZXZlbnQpID0+IHtcbiAgICAgIGNvbnNvbGUubG9nKFwiSW5kZXhlZERCINGD0YHQv9C10YjQvdC+INC+0YLQutGA0YvRgtCwXCIpO1xuICAgICAgcmVzb2x2ZShldmVudC50YXJnZXQucmVzdWx0KTtcbiAgICB9O1xuXG4gICAgLy8g0JLRi9C30YvQstCw0LXRgtGB0Y8g0L/RgNC4INGB0L7Qt9C00LDQvdC40Lgg0JHQlCDQuNC70Lgg0L7QsdC90L7QstC70LXQvdC40Lgg0LLQtdGA0YHQuNC4XG4gICAgcmVxdWVzdC5vbnVwZ3JhZGVuZWVkZWQgPSAoZXZlbnQpID0+IHtcbiAgICAgIGNvbnNvbGUubG9nKFwi0J7QsdC90L7QstC70LXQvdC40LUg0YHRhdC10LzRiyBJbmRleGVkREIuLi5cIik7XG4gICAgICBjb25zdCBkYiA9IGV2ZW50LnRhcmdldC5yZXN1bHQ7XG4gICAgICBpZiAoIWRiLm9iamVjdFN0b3JlTmFtZXMuY29udGFpbnMoU1RPUkVfTkFNRSkpIHtcbiAgICAgICAgY29uc29sZS5sb2coYNCh0L7Qt9C00LDQvdC40LUg0YXRgNCw0L3QuNC70LjRidCwINC+0LHRitC10LrRgtC+0LI6ICR7U1RPUkVfTkFNRX1gKTtcbiAgICAgICAgLy8g0KHQvtC30LTQsNC10Lwg0YXRgNCw0L3QuNC70LjRidC1INC+0LHRitC10LrRgtC+0LIg0LTQu9GPINGI0YDQuNGE0YLQvtCyXG4gICAgICAgIC8vICdpZCcg0LHRg9C00LXRgiDQutC70Y7Rh9C+0LxcbiAgICAgICAgZGIuY3JlYXRlT2JqZWN0U3RvcmUoU1RPUkVfTkFNRSwgeyBrZXlQYXRoOiAnaWQnIH0pO1xuICAgICAgICAvLyDQnNC+0LbQvdC+INC00L7QsdCw0LLQuNGC0Ywg0LjQvdC00LXQutGB0Ysg0L/RgNC4INC90LXQvtCx0YXQvtC00LjQvNC+0YHRgtC4LCDQvdCw0L/RgNC40LzQtdGAOlxuICAgICAgICAvLyBzdG9yZS5jcmVhdGVJbmRleCgnbmFtZScsICduYW1lJywgeyB1bmlxdWU6IGZhbHNlIH0pO1xuICAgICAgfVxuICAgIH07XG4gIH0pO1xuICByZXR1cm4gZGJQcm9taXNlO1xufVxuXG4vKipcbiAqINCh0L7RhdGA0LDQvdGP0LXRgiDQvtCx0YrQtdC60YIg0YjRgNC40YTRgtCwINCyIEluZGV4ZWREQi5cbiAqIEBwYXJhbSB7T2JqZWN0fSBmb250T2JqIC0g0J7QsdGK0LXQutGCINGI0YDQuNGE0YLQsCDQtNC70Y8g0YHQvtGF0YDQsNC90LXQvdC40Y8gKNC00L7Qu9C20LXQvSDRgdC+0LTQtdGA0LbQsNGC0YwgQmxvYiDQsiDQv9C+0LvQtSBmaWxlKS5cbiAqIEByZXR1cm5zIHtQcm9taXNlPHZvaWQ+fVxuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gc2F2ZUZvbnQoZm9udE9iaikge1xuICBpZiAoIWZvbnRPYmogfHwgIWZvbnRPYmouaWQgfHwgIWZvbnRPYmouZmlsZSkge1xuICAgICAgY29uc29sZS53YXJuKFwi0J/QvtC/0YvRgtC60LAg0YHQvtGF0YDQsNC90LjRgtGMINC90LXQutC+0YDRgNC10LrRgtC90YvQuSBmb250T2JqINCyIEluZGV4ZWREQlwiLCBmb250T2JqKTtcbiAgICAgIHJldHVybjtcbiAgfVxuICB0cnkge1xuICAgIGNvbnN0IGRiID0gYXdhaXQgb3BlbkRCKCk7XG4gICAgY29uc3QgdHJhbnNhY3Rpb24gPSBkYi50cmFuc2FjdGlvbihTVE9SRV9OQU1FLCAncmVhZHdyaXRlJyk7XG4gICAgY29uc3Qgc3RvcmUgPSB0cmFuc2FjdGlvbi5vYmplY3RTdG9yZShTVE9SRV9OQU1FKTtcbiAgICAvLyDQmNGB0L/QvtC70YzQt9GD0LXQvCBwdXQg0LTQu9GPINCy0YHRgtCw0LLQutC4INC40LvQuCDQvtCx0L3QvtCy0LvQtdC90LjRj1xuICAgIGNvbnN0IHJlcXVlc3QgPSBzdG9yZS5wdXQoZm9udE9iaik7XG5cbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgcmVxdWVzdC5vbnN1Y2Nlc3MgPSAoKSA9PiB7XG4gICAgICAgIC8vIGNvbnNvbGUubG9nKGDQqNGA0LjRhNGCICR7Zm9udE9iai5uYW1lfSAoJHtmb250T2JqLmlkfSkg0YHQvtGF0YDQsNC90LXQvSDQsiBJbmRleGVkREJgKTtcbiAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgfTtcbiAgICAgIHJlcXVlc3Qub25lcnJvciA9IChldmVudCkgPT4ge1xuICAgICAgICBjb25zb2xlLmVycm9yKFwi0J7RiNC40LHQutCwINGB0L7RhdGA0LDQvdC10L3QuNGPINGI0YDQuNGE0YLQsCDQsiBJbmRleGVkREI6XCIsIGV2ZW50LnRhcmdldC5lcnJvcik7XG4gICAgICAgIHJlamVjdChcItCe0YjQuNCx0LrQsCDRgdC+0YXRgNCw0L3QtdC90LjRjyDRiNGA0LjRhNGC0LBcIik7XG4gICAgICB9O1xuICAgIH0pO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcihcItCd0LUg0YPQtNCw0LvQvtGB0Ywg0LLRi9C/0L7Qu9C90LjRgtGMINGC0YDQsNC90LfQsNC60YbQuNGOINGB0L7RhdGA0LDQvdC10L3QuNGPINCyIEluZGV4ZWREQjpcIiwgZXJyb3IpO1xuICB9XG59XG5cbi8qKlxuICog0J/QvtC70YPRh9Cw0LXRgiDQstGB0LUg0L7QsdGK0LXQutGC0Ysg0YjRgNC40YTRgtC+0LIg0LjQtyBJbmRleGVkREIuXG4gKiBAcmV0dXJucyB7UHJvbWlzZTxBcnJheTxPYmplY3Q+Pn0g0J/RgNC+0LzQuNGBINGBINC80LDRgdGB0LjQstC+0Lwg0L7QsdGK0LXQutGC0L7QsiDRiNGA0LjRhNGC0L7Qsi5cbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGdldEFsbEZvbnRzKCkge1xuICB0cnkge1xuICAgIGNvbnN0IGRiID0gYXdhaXQgb3BlbkRCKCk7XG4gICAgY29uc3QgdHJhbnNhY3Rpb24gPSBkYi50cmFuc2FjdGlvbihTVE9SRV9OQU1FLCAncmVhZG9ubHknKTtcbiAgICBjb25zdCBzdG9yZSA9IHRyYW5zYWN0aW9uLm9iamVjdFN0b3JlKFNUT1JFX05BTUUpO1xuICAgIGNvbnN0IHJlcXVlc3QgPSBzdG9yZS5nZXRBbGwoKTtcblxuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICByZXF1ZXN0Lm9uc3VjY2VzcyA9IChldmVudCkgPT4ge1xuICAgICAgICByZXNvbHZlKGV2ZW50LnRhcmdldC5yZXN1bHQgfHwgW10pO1xuICAgICAgfTtcbiAgICAgIHJlcXVlc3Qub25lcnJvciA9IChldmVudCkgPT4ge1xuICAgICAgICBjb25zb2xlLmVycm9yKFwi0J7RiNC40LHQutCwINC/0L7Qu9GD0YfQtdC90LjRjyDQstGB0LXRhSDRiNGA0LjRhNGC0L7QsiDQuNC3IEluZGV4ZWREQjpcIiwgZXZlbnQudGFyZ2V0LmVycm9yKTtcbiAgICAgICAgcmVqZWN0KFwi0J7RiNC40LHQutCwINC/0L7Qu9GD0YfQtdC90LjRjyDRiNGA0LjRhNGC0L7QslwiKTtcbiAgICAgIH07XG4gICAgfSk7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKFwi0J3QtSDRg9C00LDQu9C+0YHRjCDQstGL0L/QvtC70L3QuNGC0Ywg0YLRgNCw0L3Qt9Cw0LrRhtC40Y4g0YfRgtC10L3QuNGPINC40LcgSW5kZXhlZERCOlwiLCBlcnJvcik7XG4gICAgICByZXR1cm4gW107IC8vINCS0L7Qt9Cy0YDQsNGJ0LDQtdC8INC/0YPRgdGC0L7QuSDQvNCw0YHRgdC40LIg0L/RgNC4INC+0YjQuNCx0LrQtVxuICB9XG59XG5cbi8qKlxuICog0KPQtNCw0LvRj9C10YIg0L7QsdGK0LXQutGCINGI0YDQuNGE0YLQsCDQuNC3IEluZGV4ZWREQiDQv9C+IElELlxuICogQHBhcmFtIHtzdHJpbmd9IGZvbnRJZCAtIElEINGI0YDQuNGE0YLQsCDQtNC70Y8g0YPQtNCw0LvQtdC90LjRjy5cbiAqIEByZXR1cm5zIHtQcm9taXNlPHZvaWQ+fVxuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZGVsZXRlRm9udERCKGZvbnRJZCkge1xuICBpZiAoIWZvbnRJZCkgcmV0dXJuO1xuICB0cnkge1xuICAgIGNvbnN0IGRiID0gYXdhaXQgb3BlbkRCKCk7XG4gICAgY29uc3QgdHJhbnNhY3Rpb24gPSBkYi50cmFuc2FjdGlvbihTVE9SRV9OQU1FLCAncmVhZHdyaXRlJyk7XG4gICAgY29uc3Qgc3RvcmUgPSB0cmFuc2FjdGlvbi5vYmplY3RTdG9yZShTVE9SRV9OQU1FKTtcbiAgICBjb25zdCByZXF1ZXN0ID0gc3RvcmUuZGVsZXRlKGZvbnRJZCk7XG5cbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgcmVxdWVzdC5vbnN1Y2Nlc3MgPSAoKSA9PiB7XG4gICAgICAgIC8vIGNvbnNvbGUubG9nKGDQqNGA0LjRhNGCICR7Zm9udElkfSDRg9C00LDQu9C10L0g0LjQtyBJbmRleGVkREJgKTtcbiAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgfTtcbiAgICAgIHJlcXVlc3Qub25lcnJvciA9IChldmVudCkgPT4ge1xuICAgICAgICBjb25zb2xlLmVycm9yKFwi0J7RiNC40LHQutCwINGD0LTQsNC70LXQvdC40Y8g0YjRgNC40YTRgtCwINC40LcgSW5kZXhlZERCOlwiLCBldmVudC50YXJnZXQuZXJyb3IpO1xuICAgICAgICByZWplY3QoXCLQntGI0LjQsdC60LAg0YPQtNCw0LvQtdC90LjRjyDRiNGA0LjRhNGC0LBcIik7XG4gICAgICB9O1xuICAgIH0pO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgIGNvbnNvbGUuZXJyb3IoXCLQndC1INGD0LTQsNC70L7RgdGMINCy0YvQv9C+0LvQvdC40YLRjCDRgtGA0LDQvdC30LDQutGG0LjRjiDRg9C00LDQu9C10L3QuNGPINC40LcgSW5kZXhlZERCOlwiLCBlcnJvcik7XG4gIH1cbn1cblxuLyoqXG4gKiDQo9C00LDQu9GP0LXRgiDQktCh0JUg0L7QsdGK0LXQutGC0Ysg0YjRgNC40YTRgtC+0LIg0LjQtyDRhdGA0LDQvdC40LvQuNGJ0LAgSW5kZXhlZERCLlxuICogQHJldHVybnMge1Byb21pc2U8dm9pZD59XG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBkZWxldGVBbGxGb250c0RCKCkge1xuICB0cnkge1xuICAgIGNvbnN0IGRiID0gYXdhaXQgb3BlbkRCKCk7XG4gICAgY29uc3QgdHJhbnNhY3Rpb24gPSBkYi50cmFuc2FjdGlvbihTVE9SRV9OQU1FLCAncmVhZHdyaXRlJyk7XG4gICAgY29uc3Qgc3RvcmUgPSB0cmFuc2FjdGlvbi5vYmplY3RTdG9yZShTVE9SRV9OQU1FKTtcbiAgICAvLyDQmNGB0L/QvtC70YzQt9GD0LXQvCBjbGVhcigpINC00LvRjyDRg9C00LDQu9C10L3QuNGPINCy0YHQtdGFINC30LDQv9C40YHQtdC5XG4gICAgY29uc3QgcmVxdWVzdCA9IHN0b3JlLmNsZWFyKCk7XG5cbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgcmVxdWVzdC5vbnN1Y2Nlc3MgPSAoKSA9PiB7XG4gICAgICAgIGNvbnNvbGUubG9nKGDQktGB0LUg0YjRgNC40YTRgtGLINGD0LTQsNC70LXQvdGLINC40LcgSW5kZXhlZERCICjRhdGA0LDQvdC40LvQuNGJ0LUgJHtTVE9SRV9OQU1FfSlgKTtcbiAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgfTtcbiAgICAgIHJlcXVlc3Qub25lcnJvciA9IChldmVudCkgPT4ge1xuICAgICAgICBjb25zb2xlLmVycm9yKFwi0J7RiNC40LHQutCwINC+0YfQuNGB0YLQutC4INGF0YDQsNC90LjQu9C40YnQsCDRiNGA0LjRhNGC0L7QsiDQsiBJbmRleGVkREI6XCIsIGV2ZW50LnRhcmdldC5lcnJvcik7XG4gICAgICAgIHJlamVjdChcItCe0YjQuNCx0LrQsCDQvtGH0LjRgdGC0LrQuCDRhdGA0LDQvdC40LvQuNGJ0LAg0YjRgNC40YTRgtC+0LJcIik7XG4gICAgICB9O1xuICAgIH0pO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGNvbnNvbGUuZXJyb3IoXCLQndC1INGD0LTQsNC70L7RgdGMINCy0YvQv9C+0LvQvdC40YLRjCDRgtGA0LDQvdC30LDQutGG0LjRjiDQvtGH0LjRgdGC0LrQuCDRhdGA0LDQvdC40LvQuNGJ0LAgSW5kZXhlZERCOlwiLCBlcnJvcik7XG4gICAgLy8g0J3QtSDQv9GA0L7QsdGA0LDRgdGL0LLQsNC10Lwg0L7RiNC40LHQutGDINC00LDQu9GM0YjQtSwg0L/RgNC+0YHRgtC+INC70L7Qs9C40YDRg9C10LxcbiAgfVxufVxuXG4vKipcbiAqINCe0LHQvdC+0LLQu9GP0LXRgiDQvdCw0YHRgtGA0L7QudC60Lgg0YjRgNC40YTRgtCwINCyIEluZGV4ZWREQiAobGFzdFVzZWRQcmVzZXROYW1lLCBsYXN0VXNlZFZhcmlhYmxlU2V0dGluZ3MsIGN1cnJlbnRXZWlnaHQsIGN1cnJlbnRTdHlsZSkuXG4gKiBAcGFyYW0ge3N0cmluZ30gZm9udElkIC0gSUQg0YjRgNC40YTRgtCwINC00LvRjyDQvtCx0L3QvtCy0LvQtdC90LjRjy5cbiAqIEBwYXJhbSB7T2JqZWN0fSB1cGRhdGVzIC0g0J7QsdGK0LXQutGCINGBINC+0LHQvdC+0LLQu9C10L3QuNGP0LzQuCDQtNC70Y8g0YjRgNC40YTRgtCwLlxuICogQHJldHVybnMge1Byb21pc2U8dm9pZD59XG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiB1cGRhdGVGb250U2V0dGluZ3MoZm9udElkLCB1cGRhdGVzKSB7XG4gIGlmICghZm9udElkIHx8ICF1cGRhdGVzKSB7XG4gICAgY29uc29sZS53YXJuKFwidXBkYXRlRm9udFNldHRpbmdzOiDQvdC10LrQvtGA0YDQtdC60YLQvdGL0LUg0L/QsNGA0LDQvNC10YLRgNGLXCIsIHsgZm9udElkLCB1cGRhdGVzIH0pO1xuICAgIHJldHVybjtcbiAgfVxuICBcbiAgdHJ5IHtcbiAgICBjb25zdCBkYiA9IGF3YWl0IG9wZW5EQigpO1xuICAgIGNvbnN0IHRyYW5zYWN0aW9uID0gZGIudHJhbnNhY3Rpb24oU1RPUkVfTkFNRSwgJ3JlYWR3cml0ZScpO1xuICAgIGNvbnN0IHN0b3JlID0gdHJhbnNhY3Rpb24ub2JqZWN0U3RvcmUoU1RPUkVfTkFNRSk7XG4gICAgXG4gICAgLy8g0KHQvdCw0YfQsNC70LAg0L/QvtC70YPRh9Cw0LXQvCDRgdGD0YnQtdGB0YLQstGD0Y7RidC40Lkg0L7QsdGK0LXQutGCXG4gICAgY29uc3QgZ2V0UmVxdWVzdCA9IHN0b3JlLmdldChmb250SWQpO1xuICAgIFxuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICBnZXRSZXF1ZXN0Lm9uc3VjY2VzcyA9ICgpID0+IHtcbiAgICAgICAgY29uc3QgZXhpc3RpbmdGb250ID0gZ2V0UmVxdWVzdC5yZXN1bHQ7XG4gICAgICAgIGlmICghZXhpc3RpbmdGb250KSB7XG4gICAgICAgICAgY29uc29sZS53YXJuKGB1cGRhdGVGb250U2V0dGluZ3M6INGI0YDQuNGE0YIgJHtmb250SWR9INC90LUg0L3QsNC50LTQtdC9INCyIEluZGV4ZWREQmApO1xuICAgICAgICAgIHJlc29sdmUoKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIC8vINCe0LHQvdC+0LLQu9GP0LXQvCDRgtC+0LvRjNC60L4g0L3Rg9C20L3Ri9C1INC/0L7Qu9GPXG4gICAgICAgIGNvbnN0IHVwZGF0ZWRGb250ID0ge1xuICAgICAgICAgIC4uLmV4aXN0aW5nRm9udCxcbiAgICAgICAgICAuLi51cGRhdGVzLFxuICAgICAgICAgIC8vINCe0LHQvdC+0LLQu9GP0LXQvCB0aW1lc3RhbXAg0LTQu9GPINC+0YLRgdC70LXQttC40LLQsNC90LjRjyDQuNC30LzQtdC90LXQvdC40LlcbiAgICAgICAgICBsYXN0VXBkYXRlZDogRGF0ZS5ub3coKVxuICAgICAgICB9O1xuICAgICAgICBcbiAgICAgICAgLy8g0KHQvtGF0YDQsNC90Y/QtdC8INC+0LHQvdC+0LLQu9C10L3QvdGL0Lkg0L7QsdGK0LXQutGCXG4gICAgICAgIGNvbnN0IHB1dFJlcXVlc3QgPSBzdG9yZS5wdXQodXBkYXRlZEZvbnQpO1xuICAgICAgICBcbiAgICAgICAgcHV0UmVxdWVzdC5vbnN1Y2Nlc3MgPSAoKSA9PiB7XG4gICAgICAgICAgY29uc29sZS5sb2coYNCd0LDRgdGC0YDQvtC50LrQuCDRiNGA0LjRhNGC0LAgJHtmb250SWR9INC+0LHQvdC+0LLQu9C10L3RiyDQsiBJbmRleGVkREI6YCwgdXBkYXRlcyk7XG4gICAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgICB9O1xuICAgICAgICBcbiAgICAgICAgcHV0UmVxdWVzdC5vbmVycm9yID0gKGV2ZW50KSA9PiB7XG4gICAgICAgICAgY29uc29sZS5lcnJvcihcItCe0YjQuNCx0LrQsCDQvtCx0L3QvtCy0LvQtdC90LjRjyDQvdCw0YHRgtGA0L7QtdC6INGI0YDQuNGE0YLQsCDQsiBJbmRleGVkREI6XCIsIGV2ZW50LnRhcmdldC5lcnJvcik7XG4gICAgICAgICAgcmVqZWN0KFwi0J7RiNC40LHQutCwINC+0LHQvdC+0LLQu9C10L3QuNGPINC90LDRgdGC0YDQvtC10Log0YjRgNC40YTRgtCwXCIpO1xuICAgICAgICB9O1xuICAgICAgfTtcbiAgICAgIFxuICAgICAgZ2V0UmVxdWVzdC5vbmVycm9yID0gKGV2ZW50KSA9PiB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoXCLQntGI0LjQsdC60LAg0L/QvtC70YPRh9C10L3QuNGPINGI0YDQuNGE0YLQsCDQtNC70Y8g0L7QsdC90L7QstC70LXQvdC40Y8g0LjQtyBJbmRleGVkREI6XCIsIGV2ZW50LnRhcmdldC5lcnJvcik7XG4gICAgICAgIHJlamVjdChcItCe0YjQuNCx0LrQsCDQv9C+0LvRg9GH0LXQvdC40Y8g0YjRgNC40YTRgtCwINC00LvRjyDQvtCx0L3QvtCy0LvQtdC90LjRj1wiKTtcbiAgICAgIH07XG4gICAgfSk7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgY29uc29sZS5lcnJvcihcItCd0LUg0YPQtNCw0LvQvtGB0Ywg0LLRi9C/0L7Qu9C90LjRgtGMINGC0YDQsNC90LfQsNC60YbQuNGOINC+0LHQvdC+0LLQu9C10L3QuNGPINCyIEluZGV4ZWREQjpcIiwgZXJyb3IpO1xuICB9XG59ICJdLCJuYW1lcyI6WyJEQl9OQU1FIiwiREJfVkVSU0lPTiIsIlNUT1JFX05BTUUiLCJkYlByb21pc2UiLCJvcGVuREIiLCJQcm9taXNlIiwicmVzb2x2ZSIsInJlamVjdCIsInJlcXVlc3QiLCJpbmRleGVkREIiLCJvcGVuIiwib25lcnJvciIsImV2ZW50IiwiY29uc29sZSIsImVycm9yIiwidGFyZ2V0Iiwib25zdWNjZXNzIiwibG9nIiwicmVzdWx0Iiwib251cGdyYWRlbmVlZGVkIiwiZGIiLCJvYmplY3RTdG9yZU5hbWVzIiwiY29udGFpbnMiLCJjcmVhdGVPYmplY3RTdG9yZSIsImtleVBhdGgiLCJzYXZlRm9udCIsImZvbnRPYmoiLCJpZCIsImZpbGUiLCJ3YXJuIiwidHJhbnNhY3Rpb24iLCJzdG9yZSIsIm9iamVjdFN0b3JlIiwicHV0IiwiZ2V0QWxsRm9udHMiLCJnZXRBbGwiLCJkZWxldGVGb250REIiLCJmb250SWQiLCJkZWxldGUiLCJkZWxldGVBbGxGb250c0RCIiwiY2xlYXIiLCJ1cGRhdGVGb250U2V0dGluZ3MiLCJ1cGRhdGVzIiwiZ2V0UmVxdWVzdCIsImdldCIsImV4aXN0aW5nRm9udCIsInVwZGF0ZWRGb250IiwibGFzdFVwZGF0ZWQiLCJEYXRlIiwibm93IiwicHV0UmVxdWVzdCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./utils/db.js\n"));

/***/ }),

/***/ "./utils/fontManagerUtils.js":
/*!***********************************!*\
  !*** ./utils/fontManagerUtils.js ***!
  \***********************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   base64ToArrayBuffer: function() { return /* binding */ base64ToArrayBuffer; }\n/* harmony export */ });\n/**\n * Вспомогательная функция для декодирования Base64 в ArrayBuffer.\n * @param {string} base64 - Строка в формате Base64.\n * @returns {ArrayBuffer} - Декодированный ArrayBuffer.\n * @throws {Error} Если декодирование не удалось.\n */ function base64ToArrayBuffer(base64) {\n    try {\n        const binaryString = window.atob(base64);\n        const len = binaryString.length;\n        const bytes = new Uint8Array(len);\n        for(let i = 0; i < len; i++){\n            bytes[i] = binaryString.charCodeAt(i);\n        }\n        return bytes.buffer;\n    } catch (e) {\n        console.error(\"Ошибка декодирования base64:\", e);\n        throw new Error(\"Не удалось декодировать данные шрифта.\");\n    }\n} // Другие общие утилиты для useFontManager можно будет добавить сюда позже \n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi91dGlscy9mb250TWFuYWdlclV0aWxzLmpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBQTs7Ozs7Q0FLQyxHQUNNLFNBQVNBLG9CQUFvQkMsTUFBTTtJQUN4QyxJQUFJO1FBQ0YsTUFBTUMsZUFBZUMsT0FBT0MsSUFBSSxDQUFDSDtRQUNqQyxNQUFNSSxNQUFNSCxhQUFhSSxNQUFNO1FBQy9CLE1BQU1DLFFBQVEsSUFBSUMsV0FBV0g7UUFDN0IsSUFBSyxJQUFJSSxJQUFJLEdBQUdBLElBQUlKLEtBQUtJLElBQUs7WUFDNUJGLEtBQUssQ0FBQ0UsRUFBRSxHQUFHUCxhQUFhUSxVQUFVLENBQUNEO1FBQ3JDO1FBQ0EsT0FBT0YsTUFBTUksTUFBTTtJQUNyQixFQUFFLE9BQU9DLEdBQUc7UUFDVkMsUUFBUUMsS0FBSyxDQUFDLGdDQUFnQ0Y7UUFDOUMsTUFBTSxJQUFJRyxNQUFNO0lBQ2xCO0FBQ0YsRUFFQSwyRUFBMkUiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vdXRpbHMvZm9udE1hbmFnZXJVdGlscy5qcz9lYzIzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICog0JLRgdC/0L7QvNC+0LPQsNGC0LXQu9GM0L3QsNGPINGE0YPQvdC60YbQuNGPINC00LvRjyDQtNC10LrQvtC00LjRgNC+0LLQsNC90LjRjyBCYXNlNjQg0LIgQXJyYXlCdWZmZXIuXG4gKiBAcGFyYW0ge3N0cmluZ30gYmFzZTY0IC0g0KHRgtGA0L7QutCwINCyINGE0L7RgNC80LDRgtC1IEJhc2U2NC5cbiAqIEByZXR1cm5zIHtBcnJheUJ1ZmZlcn0gLSDQlNC10LrQvtC00LjRgNC+0LLQsNC90L3Ri9C5IEFycmF5QnVmZmVyLlxuICogQHRocm93cyB7RXJyb3J9INCV0YHQu9C4INC00LXQutC+0LTQuNGA0L7QstCw0L3QuNC1INC90LUg0YPQtNCw0LvQvtGB0YwuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBiYXNlNjRUb0FycmF5QnVmZmVyKGJhc2U2NCkge1xuICB0cnkge1xuICAgIGNvbnN0IGJpbmFyeVN0cmluZyA9IHdpbmRvdy5hdG9iKGJhc2U2NCk7XG4gICAgY29uc3QgbGVuID0gYmluYXJ5U3RyaW5nLmxlbmd0aDtcbiAgICBjb25zdCBieXRlcyA9IG5ldyBVaW50OEFycmF5KGxlbik7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgYnl0ZXNbaV0gPSBiaW5hcnlTdHJpbmcuY2hhckNvZGVBdChpKTtcbiAgICB9XG4gICAgcmV0dXJuIGJ5dGVzLmJ1ZmZlcjtcbiAgfSBjYXRjaCAoZSkge1xuICAgIGNvbnNvbGUuZXJyb3IoXCLQntGI0LjQsdC60LAg0LTQtdC60L7QtNC40YDQvtCy0LDQvdC40Y8gYmFzZTY0OlwiLCBlKTtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCLQndC1INGD0LTQsNC70L7RgdGMINC00LXQutC+0LTQuNGA0L7QstCw0YLRjCDQtNCw0L3QvdGL0LUg0YjRgNC40YTRgtCwLlwiKTtcbiAgfVxufVxuXG4vLyDQlNGA0YPQs9C40LUg0L7QsdGJ0LjQtSDRg9GC0LjQu9C40YLRiyDQtNC70Y8gdXNlRm9udE1hbmFnZXIg0LzQvtC20L3QviDQsdGD0LTQtdGCINC00L7QsdCw0LLQuNGC0Ywg0YHRjtC00LAg0L/QvtC30LbQtSAiXSwibmFtZXMiOlsiYmFzZTY0VG9BcnJheUJ1ZmZlciIsImJhc2U2NCIsImJpbmFyeVN0cmluZyIsIndpbmRvdyIsImF0b2IiLCJsZW4iLCJsZW5ndGgiLCJieXRlcyIsIlVpbnQ4QXJyYXkiLCJpIiwiY2hhckNvZGVBdCIsImJ1ZmZlciIsImUiLCJjb25zb2xlIiwiZXJyb3IiLCJFcnJvciJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./utils/fontManagerUtils.js\n"));

/***/ }),

/***/ "./utils/fontParser.js":
/*!*****************************!*\
  !*** ./utils/fontParser.js ***!
  \*****************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   _parseFontBufferDirect: function() { return /* binding */ _parseFontBufferDirect; },\n/* harmony export */   _parseFontFileDirect: function() { return /* binding */ _parseFontFileDirect; },\n/* harmony export */   getGlyphDataForFont: function() { return /* binding */ getGlyphDataForFont; },\n/* harmony export */   isVariableFont: function() { return /* binding */ isVariableFont; },\n/* harmony export */   parseFontBuffer: function() { return /* binding */ parseFontBuffer; }\n/* harmony export */ });\n/* harmony import */ var opentype_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! opentype.js */ \"./node_modules/opentype.js/dist/opentype.module.js\");\n/* harmony import */ var react_toastify__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react-toastify */ \"./node_modules/react-toastify/dist/index.mjs\");\n/* harmony import */ var _glyphUtils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./glyphUtils */ \"./utils/glyphUtils.js\");\n/* harmony import */ var woff2_encoder_decompress__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! woff2-encoder/decompress */ \"./node_modules/woff2-encoder/dist/decompress.js\");\n// Функции для парсинга файлов шрифтов с использованием opentype.js\n // Оставляем стандартный импорт\n // toast используется в parseFontFile\n\n// --- ИМПОРТИРУЕМ ДЕКОМПРЕССОР ИЗ НОВОГО ПАКЕТА ---\n\n// <<< ЛОГ ПРОВЕРКИ OPENTYPE.JS >>>\ntry {\n    console.log(\"[Main] opentype.js status:\", typeof opentype_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"], \"Version:\", (opentype_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"] === null || opentype_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"] === void 0 ? void 0 : opentype_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].version) || \"N/A\");\n} catch (e) {\n    console.error(\"[Main] Failed to access opentype object after import:\", e);\n}\n// <<< КОНЕЦ ЛОГА ПРОВЕРКИ >>>\n// <<< ЛОГ ПРОВЕРКИ ДЕКОМПРЕССОРА >>>\ntry {\n    console.log(\"[Main] woff2-encoder/decompress status:\", typeof woff2_encoder_decompress__WEBPACK_IMPORTED_MODULE_3__[\"default\"]);\n} catch (e) {\n    console.error(\"[Main] Failed to access decompress function after import:\", e);\n}\n// <<< КОНЕЦ ЛОГА ПРОВЕРКИ >>>\n/**\n * Проверяет первые 4 байта буфера на сигнатуру WOFF2 ('wOF2')\n */ const isWoff2 = (buffer)=>{\n    if (!buffer || buffer.byteLength < 4) return false;\n    if (!(buffer instanceof ArrayBuffer) && typeof buffer.slice !== \"function\") return false;\n    try {\n        const signature = String.fromCharCode(...new Uint8Array(buffer.slice(0, 4)));\n        return signature === \"wOF2\";\n    } catch (e) {\n        console.error(\"Error checking WOFF2 signature:\", e);\n        return false;\n    }\n};\n/**\n * Проверяет, является ли шрифт вариативным (содержит таблицу fvar).\n * @param {opentype.Font} fontData - Объект шрифта, полученный из opentype.parse.\n * @returns {boolean} - true, если шрифт вариативный, иначе false.\n */ const isVariableFont = (fontData)=>{\n    return !!(fontData && fontData.tables && fontData.tables.fvar);\n};\n/**\n * [Только основной поток] Асинхронно парсит ArrayBuffer шрифта.\n * Декомпрессирует WOFF2 при необходимости.\n * Возвращает полный объект opentype.Font или null при ошибке.\n *\n * @param {ArrayBuffer} buffer - ArrayBuffer с данными шрифта.\n * @param {string} [fontName='unknown'] - Имя шрифта для логирования.\n * @returns {Promise<opentype.Font|null>} Промис с объектом шрифта или null.\n */ async function parseFontBuffer(buffer) {\n    let fontName = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : \"unknown\";\n    // Теперь эта функция просто вызывает _parseFontBufferDirect\n    return _parseFontBufferDirect(buffer, fontName);\n}\n/**\n * [Только основной поток] Асинхронно парсит ArrayBuffer файла шрифта с помощью opentype.js\n * Декомпрессирует WOFF2 с помощью woff2-encoder.\n * @param {ArrayBuffer} buffer - Буфер с данными файла шрифта\n * @param {string} fontName - Имя шрифта (для сообщений об ошибках)\n * @returns {Promise<opentype.Font|null>} - Промис с объектом fontData от opentype.js или null в случае ошибки\n */ const _parseFontBufferDirect = async function(buffer) {\n    let fontName = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : \"font\";\n    if (!buffer || !(buffer instanceof ArrayBuffer) || buffer.byteLength === 0) {\n        console.error(\"[\".concat(fontName, \"] Invalid or empty buffer provided for direct parsing.\"));\n        return null;\n    }\n    let processedBuffer = buffer;\n    try {\n        if (isWoff2(buffer)) {\n            console.log(\"[Main] Detected WOFF2 for \".concat(fontName, \", attempting decompression with woff2-encoder...\"));\n            try {\n                if (typeof woff2_encoder_decompress__WEBPACK_IMPORTED_MODULE_3__[\"default\"] !== \"function\") {\n                    throw new Error(\"woff2-encoder decompress function is not available. Check import.\");\n                }\n                const decompressedData = await (0,woff2_encoder_decompress__WEBPACK_IMPORTED_MODULE_3__[\"default\"])(new Uint8Array(buffer));\n                if (!decompressedData) {\n                    throw new Error(\"woff2-encoder decompression returned null or undefined.\");\n                }\n                processedBuffer = decompressedData.buffer;\n                console.log(\"[Main] WOFF2 decompression successful for \".concat(fontName));\n            } catch (decompError) {\n                react_toastify__WEBPACK_IMPORTED_MODULE_1__.toast.error(\"Ошибка декомпрессии WOFF2 для \".concat(fontName, \": \").concat(decompError.message));\n                console.error(\"[Main] WOFF2 decompression failed for \".concat(fontName, \":\"), decompError);\n                return null;\n            }\n        }\n        if (typeof opentype_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"] === \"undefined\" || typeof opentype_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].parse !== \"function\") {\n            throw new Error(\"opentype.js is not loaded or parse function is missing.\");\n        }\n        const parsedFont = opentype_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].parse(processedBuffer);\n        console.log(\"[Main] Parsed \".concat(fontName, \" successfully.\"));\n        return parsedFont;\n    } catch (parseError) {\n        react_toastify__WEBPACK_IMPORTED_MODULE_1__.toast.error(\"Ошибка анализа шрифта \".concat(fontName, \": \").concat(parseError.message));\n        console.error(\"[Main] Font parsing/processing error for \".concat(fontName, \":\"), parseError);\n        return null;\n    }\n};\n/**\n * [Только основной поток] Читает файл шрифта (Blob) и парсит его.\n */ const _parseFontFileDirect = function(file) {\n    let fontName = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : \"font\";\n    return new Promise((resolve)=>{\n        if (!(file instanceof Blob)) {\n            react_toastify__WEBPACK_IMPORTED_MODULE_1__.toast.error(\"Недопустимый файл шрифта для \".concat(fontName, \" (ожидается Blob)\"));\n            resolve(null);\n            return;\n        }\n        const reader = new FileReader();\n        reader.onload = async (e)=>{\n            try {\n                const buffer = e.target.result;\n                // Вызываем парсер основного потока\n                const parsedFont = await _parseFontBufferDirect(buffer, fontName);\n                resolve(parsedFont);\n            } catch (error) {\n                console.error(\"Unexpected error during font buffer processing (direct):\", error);\n                resolve(null);\n            }\n        };\n        reader.onerror = (error)=>{\n            react_toastify__WEBPACK_IMPORTED_MODULE_1__.toast.error(\"Ошибка при чтении файла шрифта \".concat(fontName));\n            console.error(\"FileReader error for \".concat(fontName, \":\"), error);\n            resolve(null);\n        };\n        try {\n            reader.readAsArrayBuffer(file);\n        } catch (readError) {\n            react_toastify__WEBPACK_IMPORTED_MODULE_1__.toast.error(\"Не удалось начать чтение файла \".concat(fontName));\n            console.error(\"Error calling readAsArrayBuffer for \".concat(fontName, \":\"), readError);\n            resolve(null);\n        }\n    });\n};\n/**\n * [Только основной поток] Получает данные глифов для шрифта.\n * @param {Object} fontObj - Объект шрифта\n * @returns {Promise<Object|null>} - Промис с данными глифов или null.\n */ const getGlyphDataForFont = async (fontObj)=>{\n    if (!fontObj || !fontObj.file) {\n        console.error(\"getGlyphDataForFont: Invalid fontObj or missing file.\");\n        return null;\n    }\n    const fontId = fontObj.id || fontObj.name;\n    try {\n        // Получаем ArrayBuffer\n        const buffer = await fontObj.file.arrayBuffer();\n        if (!buffer || buffer.byteLength === 0) {\n            console.error(\"[fontParser] Font file buffer is empty for \".concat(fontObj.name));\n            throw new Error(\"Font file buffer is empty.\");\n        }\n        // --- Используем только основной поток --- \n        console.log(\"[fontParser] Processing glyphs in main thread for \".concat(fontObj.name));\n        // Парсим буфер в основном потоке\n        const font = await parseFontBuffer(buffer, fontObj.name); // parseFontBuffer теперь вызывает _parseFontBufferDirect\n        if (!font) {\n            console.error(\"[fontParser] Main thread: Failed to parse font buffer for \".concat(fontObj.name));\n            throw new Error(\"Ошибка при парсинге шрифта в основном потоке\");\n        }\n        // Извлекаем глифы\n        const resultData = (0,_glyphUtils__WEBPACK_IMPORTED_MODULE_2__.extractBasicGlyphData)(font, \"main\");\n        if (!resultData) {\n            console.error(\"[fontParser] Main thread: extractBasicGlyphData returned null for \".concat(fontObj.name, \".\"));\n            throw new Error(\"Ошибка при извлечении данных глифов в основном потоке\");\n        }\n        // --- Конец использования основного потока --- \n        // Логируем ошибки, если они были\n        if (resultData.errors && resultData.errors.length > 0) {\n            console.warn(\"[fontParser - main] Found \".concat(resultData.errors.length, \" errors processing glyphs for \").concat(fontObj.name, \".\"));\n        }\n        // Проверяем итоговый результат перед возвратом\n        if (!resultData || !Array.isArray(resultData.allGlyphs)) {\n            console.error(\"[fontParser - main] Final glyph data result is invalid for \".concat(fontObj.name), resultData);\n            return null;\n        }\n        return resultData; // Возвращаем { allGlyphs, names, unicodes, advanceWidths, errors }\n    } catch (error) {\n        console.error(\"[fontParser] Error in getGlyphDataForFont for \".concat(fontId, \":\"), error);\n        // toast.error('Ошибка при загрузке данных о глифах'); // Можно раскомментировать, если нужно\n        return null; // Возвращаем null при критической ошибке\n    }\n};\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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TSxJQUFJRCxXQUFXQyxNQUFNLENBQUNDLE1BQU0sR0FBRyxHQUFHO1lBQ3ZEbkQsUUFBUW9ELElBQUksQ0FBQyw2QkFBc0ZULE9BQXpETSxXQUFXQyxNQUFNLENBQUNDLE1BQU0sRUFBQyxrQ0FBNkMsT0FBYlIsUUFBUUcsSUFBSSxFQUFDO1FBQ2hIO1FBRUEsK0NBQStDO1FBQy9DLElBQUksQ0FBQ0csY0FBYyxDQUFDSSxNQUFNQyxPQUFPLENBQUNMLFdBQVdNLFNBQVMsR0FBRztZQUN2RHZELFFBQVFJLEtBQUssQ0FBQyw4REFBMkUsT0FBYnVDLFFBQVFHLElBQUksR0FBSUc7WUFDNUYsT0FBTztRQUNUO1FBRUYsT0FBT0EsWUFBWSxtRUFBbUU7SUFFeEYsRUFBRSxPQUFPN0MsT0FBTztRQUNkSixRQUFRSSxLQUFLLENBQUMsaURBQXdELE9BQVB3QyxRQUFPLE1BQUl4QztRQUMxRSw2RkFBNkY7UUFDN0YsT0FBTyxNQUFNLHlDQUF5QztJQUN4RDtBQUNGLEVBQUUiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vdXRpbHMvZm9udFBhcnNlci5qcz85MTZmIl0sInNvdXJjZXNDb250ZW50IjpbIi8vINCk0YPQvdC60YbQuNC4INC00LvRjyDQv9Cw0YDRgdC40L3Qs9CwINGE0LDQudC70L7QsiDRiNGA0LjRhNGC0L7QsiDRgSDQuNGB0L/QvtC70YzQt9C+0LLQsNC90LjQtdC8IG9wZW50eXBlLmpzXG5pbXBvcnQgb3BlbnR5cGUgZnJvbSAnb3BlbnR5cGUuanMnOyAvLyDQntGB0YLQsNCy0LvRj9C10Lwg0YHRgtCw0L3QtNCw0YDRgtC90YvQuSDQuNC80L/QvtGA0YJcbmltcG9ydCB7IHRvYXN0IH0gZnJvbSAncmVhY3QtdG9hc3RpZnknOyAvLyB0b2FzdCDQuNGB0L/QvtC70YzQt9GD0LXRgtGB0Y8g0LIgcGFyc2VGb250RmlsZVxuaW1wb3J0IHsgZXh0cmFjdEJhc2ljR2x5cGhEYXRhIH0gZnJvbSAnLi9nbHlwaFV0aWxzJztcblxuLy8gLS0tINCY0JzQn9Ce0KDQotCY0KDQo9CV0Jwg0JTQldCa0J7QnNCf0KDQldCh0KHQntCgINCY0Jcg0J3QntCS0J7Qk9CeINCf0JDQmtCV0KLQkCAtLS1cbmltcG9ydCBkZWNvbXByZXNzIGZyb20gJ3dvZmYyLWVuY29kZXIvZGVjb21wcmVzcyc7XG5cbi8vIDw8PCDQm9Ce0JMg0J/QoNCe0JLQldCg0JrQmCBPUEVOVFlQRS5KUyA+Pj5cbnRyeSB7XG4gIGNvbnNvbGUubG9nKCdbTWFpbl0gb3BlbnR5cGUuanMgc3RhdHVzOicsIHR5cGVvZiBvcGVudHlwZSwgJ1ZlcnNpb246Jywgb3BlbnR5cGU/LnZlcnNpb24gfHwgJ04vQScpOyBcbn0gY2F0Y2ggKGUpIHtcbiAgY29uc29sZS5lcnJvcignW01haW5dIEZhaWxlZCB0byBhY2Nlc3Mgb3BlbnR5cGUgb2JqZWN0IGFmdGVyIGltcG9ydDonLCBlKTtcbn1cbi8vIDw8PCDQmtCe0J3QldCmINCb0J7Qk9CQINCf0KDQntCS0JXQoNCa0JggPj4+XG5cbi8vIDw8PCDQm9Ce0JMg0J/QoNCe0JLQldCg0JrQmCDQlNCV0JrQntCc0J/QoNCV0KHQodCe0KDQkCA+Pj5cbnRyeSB7XG4gIGNvbnNvbGUubG9nKCdbTWFpbl0gd29mZjItZW5jb2Rlci9kZWNvbXByZXNzIHN0YXR1czonLCB0eXBlb2YgZGVjb21wcmVzcyk7XG59IGNhdGNoIChlKSB7XG4gIGNvbnNvbGUuZXJyb3IoJ1tNYWluXSBGYWlsZWQgdG8gYWNjZXNzIGRlY29tcHJlc3MgZnVuY3Rpb24gYWZ0ZXIgaW1wb3J0OicsIGUpO1xufVxuLy8gPDw8INCa0J7QndCV0KYg0JvQntCT0JAg0J/QoNCe0JLQldCg0JrQmCA+Pj5cblxuLyoqXG4gKiDQn9GA0L7QstC10YDRj9C10YIg0L/QtdGA0LLRi9C1IDQg0LHQsNC50YLQsCDQsdGD0YTQtdGA0LAg0L3QsCDRgdC40LPQvdCw0YLRg9GA0YMgV09GRjIgKCd3T0YyJylcbiAqL1xuY29uc3QgaXNXb2ZmMiA9IChidWZmZXIpID0+IHtcbiAgaWYgKCFidWZmZXIgfHwgYnVmZmVyLmJ5dGVMZW5ndGggPCA0KSByZXR1cm4gZmFsc2U7XG4gIGlmICghKGJ1ZmZlciBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKSAmJiB0eXBlb2YgYnVmZmVyLnNsaWNlICE9PSAnZnVuY3Rpb24nKSByZXR1cm4gZmFsc2U7IFxuICB0cnkge1xuICAgIGNvbnN0IHNpZ25hdHVyZSA9IFN0cmluZy5mcm9tQ2hhckNvZGUoLi4ubmV3IFVpbnQ4QXJyYXkoYnVmZmVyLnNsaWNlKDAsIDQpKSk7XG4gICAgcmV0dXJuIHNpZ25hdHVyZSA9PT0gJ3dPRjInO1xuICB9IGNhdGNoIChlKSB7XG4gICAgIGNvbnNvbGUuZXJyb3IoXCJFcnJvciBjaGVja2luZyBXT0ZGMiBzaWduYXR1cmU6XCIsIGUpO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfTtcbiAgXG4vKipcbiAqINCf0YDQvtCy0LXRgNGP0LXRgiwg0Y/QstC70Y/QtdGC0YHRjyDQu9C4INGI0YDQuNGE0YIg0LLQsNGA0LjQsNGC0LjQstC90YvQvCAo0YHQvtC00LXRgNC20LjRgiDRgtCw0LHQu9C40YbRgyBmdmFyKS5cbiAqIEBwYXJhbSB7b3BlbnR5cGUuRm9udH0gZm9udERhdGEgLSDQntCx0YrQtdC60YIg0YjRgNC40YTRgtCwLCDQv9C+0LvRg9GH0LXQvdC90YvQuSDQuNC3IG9wZW50eXBlLnBhcnNlLlxuICogQHJldHVybnMge2Jvb2xlYW59IC0gdHJ1ZSwg0LXRgdC70Lgg0YjRgNC40YTRgiDQstCw0YDQuNCw0YLQuNCy0L3Ri9C5LCDQuNC90LDRh9C1IGZhbHNlLlxuICovXG5leHBvcnQgY29uc3QgaXNWYXJpYWJsZUZvbnQgPSAoZm9udERhdGEpID0+IHtcbiAgcmV0dXJuICEhKGZvbnREYXRhICYmIGZvbnREYXRhLnRhYmxlcyAmJiBmb250RGF0YS50YWJsZXMuZnZhcik7XG59O1xuXG4vKipcbiAqIFvQotC+0LvRjNC60L4g0L7RgdC90L7QstC90L7QuSDQv9C+0YLQvtC6XSDQkNGB0LjQvdGF0YDQvtC90L3QviDQv9Cw0YDRgdC40YIgQXJyYXlCdWZmZXIg0YjRgNC40YTRgtCwLlxuICog0JTQtdC60L7QvNC/0YDQtdGB0YHQuNGA0YPQtdGCIFdPRkYyINC/0YDQuCDQvdC10L7QsdGF0L7QtNC40LzQvtGB0YLQuC5cbiAqINCS0L7Qt9Cy0YDQsNGJ0LDQtdGCINC/0L7Qu9C90YvQuSDQvtCx0YrQtdC60YIgb3BlbnR5cGUuRm9udCDQuNC70LggbnVsbCDQv9GA0Lgg0L7RiNC40LHQutC1LlxuICpcbiAqIEBwYXJhbSB7QXJyYXlCdWZmZXJ9IGJ1ZmZlciAtIEFycmF5QnVmZmVyINGBINC00LDQvdC90YvQvNC4INGI0YDQuNGE0YLQsC5cbiAqIEBwYXJhbSB7c3RyaW5nfSBbZm9udE5hbWU9J3Vua25vd24nXSAtINCY0LzRjyDRiNGA0LjRhNGC0LAg0LTQu9GPINC70L7Qs9C40YDQvtCy0LDQvdC40Y8uXG4gKiBAcmV0dXJucyB7UHJvbWlzZTxvcGVudHlwZS5Gb250fG51bGw+fSDQn9GA0L7QvNC40YEg0YEg0L7QsdGK0LXQutGC0L7QvCDRiNGA0LjRhNGC0LAg0LjQu9C4IG51bGwuXG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBwYXJzZUZvbnRCdWZmZXIoYnVmZmVyLCBmb250TmFtZSA9ICd1bmtub3duJykge1xuICAvLyDQotC10L/QtdGA0Ywg0Y3RgtCwINGE0YPQvdC60YbQuNGPINC/0YDQvtGB0YLQviDQstGL0LfRi9Cy0LDQtdGCIF9wYXJzZUZvbnRCdWZmZXJEaXJlY3RcbiAgICByZXR1cm4gX3BhcnNlRm9udEJ1ZmZlckRpcmVjdChidWZmZXIsIGZvbnROYW1lKTtcbn1cblxuLyoqXG4gKiBb0KLQvtC70YzQutC+INC+0YHQvdC+0LLQvdC+0Lkg0L/QvtGC0L7Qul0g0JDRgdC40L3RhdGA0L7QvdC90L4g0L/QsNGA0YHQuNGCIEFycmF5QnVmZmVyINGE0LDQudC70LAg0YjRgNC40YTRgtCwINGBINC/0L7QvNC+0YnRjNGOIG9wZW50eXBlLmpzXG4gKiDQlNC10LrQvtC80L/RgNC10YHRgdC40YDRg9C10YIgV09GRjIg0YEg0L/QvtC80L7RidGM0Y4gd29mZjItZW5jb2Rlci5cbiAqIEBwYXJhbSB7QXJyYXlCdWZmZXJ9IGJ1ZmZlciAtINCR0YPRhNC10YAg0YEg0LTQsNC90L3Ri9C80Lgg0YTQsNC50LvQsCDRiNGA0LjRhNGC0LBcbiAqIEBwYXJhbSB7c3RyaW5nfSBmb250TmFtZSAtINCY0LzRjyDRiNGA0LjRhNGC0LAgKNC00LvRjyDRgdC+0L7QsdGJ0LXQvdC40Lkg0L7QsSDQvtGI0LjQsdC60LDRhSlcbiAqIEByZXR1cm5zIHtQcm9taXNlPG9wZW50eXBlLkZvbnR8bnVsbD59IC0g0J/RgNC+0LzQuNGBINGBINC+0LHRitC10LrRgtC+0LwgZm9udERhdGEg0L7RgiBvcGVudHlwZS5qcyDQuNC70LggbnVsbCDQsiDRgdC70YPRh9Cw0LUg0L7RiNC40LHQutC4XG4gKi9cbmV4cG9ydCBjb25zdCBfcGFyc2VGb250QnVmZmVyRGlyZWN0ID0gYXN5bmMgKGJ1ZmZlciwgZm9udE5hbWUgPSAnZm9udCcpID0+IHtcbiAgaWYgKCFidWZmZXIgfHwgIShidWZmZXIgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcikgfHwgYnVmZmVyLmJ5dGVMZW5ndGggPT09IDApIHtcbiAgICBjb25zb2xlLmVycm9yKGBbJHtmb250TmFtZX1dIEludmFsaWQgb3IgZW1wdHkgYnVmZmVyIHByb3ZpZGVkIGZvciBkaXJlY3QgcGFyc2luZy5gKTtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBcbiAgbGV0IHByb2Nlc3NlZEJ1ZmZlciA9IGJ1ZmZlcjtcbiAgXG4gIHRyeSB7XG4gICAgIGlmIChpc1dvZmYyKGJ1ZmZlcikpIHtcbiAgICAgICAgIGNvbnNvbGUubG9nKGBbTWFpbl0gRGV0ZWN0ZWQgV09GRjIgZm9yICR7Zm9udE5hbWV9LCBhdHRlbXB0aW5nIGRlY29tcHJlc3Npb24gd2l0aCB3b2ZmMi1lbmNvZGVyLi4uYCk7XG4gICAgICAgICB0cnkge1xuICAgICAgICAgICAgIGlmICh0eXBlb2YgZGVjb21wcmVzcyAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3dvZmYyLWVuY29kZXIgZGVjb21wcmVzcyBmdW5jdGlvbiBpcyBub3QgYXZhaWxhYmxlLiBDaGVjayBpbXBvcnQuJyk7XG4gICAgICAgICAgICAgfVxuICAgICAgICAgICAgIGNvbnN0IGRlY29tcHJlc3NlZERhdGEgPSBhd2FpdCBkZWNvbXByZXNzKG5ldyBVaW50OEFycmF5KGJ1ZmZlcikpOyBcbiAgICAgICAgICAgICBpZiAoIWRlY29tcHJlc3NlZERhdGEpIHtcbiAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCd3b2ZmMi1lbmNvZGVyIGRlY29tcHJlc3Npb24gcmV0dXJuZWQgbnVsbCBvciB1bmRlZmluZWQuJyk7XG4gICAgICAgICAgICAgfVxuICAgICAgICAgICAgIHByb2Nlc3NlZEJ1ZmZlciA9IGRlY29tcHJlc3NlZERhdGEuYnVmZmVyO1xuICAgICAgICAgICAgIGNvbnNvbGUubG9nKGBbTWFpbl0gV09GRjIgZGVjb21wcmVzc2lvbiBzdWNjZXNzZnVsIGZvciAke2ZvbnROYW1lfWApO1xuICAgICAgICAgfSBjYXRjaCAoZGVjb21wRXJyb3IpIHtcbiAgICAgICAgICAgICB0b2FzdC5lcnJvcihg0J7RiNC40LHQutCwINC00LXQutC+0LzQv9GA0LXRgdGB0LjQuCBXT0ZGMiDQtNC70Y8gJHtmb250TmFtZX06ICR7ZGVjb21wRXJyb3IubWVzc2FnZX1gKTtcbiAgICAgICAgICAgICBjb25zb2xlLmVycm9yKGBbTWFpbl0gV09GRjIgZGVjb21wcmVzc2lvbiBmYWlsZWQgZm9yICR7Zm9udE5hbWV9OmAsIGRlY29tcEVycm9yKTtcbiAgICAgICAgICAgICByZXR1cm4gbnVsbDsgXG4gICAgICAgICB9XG4gICAgIH1cbiAgICAgXG4gICAgaWYgKHR5cGVvZiBvcGVudHlwZSA9PT0gJ3VuZGVmaW5lZCcgfHwgdHlwZW9mIG9wZW50eXBlLnBhcnNlICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignb3BlbnR5cGUuanMgaXMgbm90IGxvYWRlZCBvciBwYXJzZSBmdW5jdGlvbiBpcyBtaXNzaW5nLicpO1xuICAgIH1cbiAgICAgXG4gICAgY29uc3QgcGFyc2VkRm9udCA9IG9wZW50eXBlLnBhcnNlKHByb2Nlc3NlZEJ1ZmZlcik7XG4gICAgY29uc29sZS5sb2coYFtNYWluXSBQYXJzZWQgJHtmb250TmFtZX0gc3VjY2Vzc2Z1bGx5LmApO1xuICAgIHJldHVybiBwYXJzZWRGb250O1xuICAgIFxuICB9IGNhdGNoIChwYXJzZUVycm9yKSB7XG4gICAgdG9hc3QuZXJyb3IoYNCe0YjQuNCx0LrQsCDQsNC90LDQu9C40LfQsCDRiNGA0LjRhNGC0LAgJHtmb250TmFtZX06ICR7cGFyc2VFcnJvci5tZXNzYWdlfWApO1xuICAgIGNvbnNvbGUuZXJyb3IoYFtNYWluXSBGb250IHBhcnNpbmcvcHJvY2Vzc2luZyBlcnJvciBmb3IgJHtmb250TmFtZX06YCwgcGFyc2VFcnJvcik7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbn07XG5cbi8qKlxuICogW9Ci0L7Qu9GM0LrQviDQvtGB0L3QvtCy0L3QvtC5INC/0L7RgtC+0LpdINCn0LjRgtCw0LXRgiDRhNCw0LnQuyDRiNGA0LjRhNGC0LAgKEJsb2IpINC4INC/0LDRgNGB0LjRgiDQtdCz0L4uXG4gKi9cbmV4cG9ydCBjb25zdCBfcGFyc2VGb250RmlsZURpcmVjdCA9IChmaWxlLCBmb250TmFtZSA9ICdmb250JykgPT4ge1xuICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHsgXG4gICAgaWYgKCEoZmlsZSBpbnN0YW5jZW9mIEJsb2IpKSB7XG4gICAgICB0b2FzdC5lcnJvcihg0J3QtdC00L7Qv9GD0YHRgtC40LzRi9C5INGE0LDQudC7INGI0YDQuNGE0YLQsCDQtNC70Y8gJHtmb250TmFtZX0gKNC+0LbQuNC00LDQtdGC0YHRjyBCbG9iKWApO1xuICAgICAgcmVzb2x2ZShudWxsKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25zdCByZWFkZXIgPSBuZXcgRmlsZVJlYWRlcigpO1xuICAgIHJlYWRlci5vbmxvYWQgPSBhc3luYyAoZSkgPT4ge1xuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3QgYnVmZmVyID0gZS50YXJnZXQucmVzdWx0O1xuICAgICAgICAvLyDQktGL0LfRi9Cy0LDQtdC8INC/0LDRgNGB0LXRgCDQvtGB0L3QvtCy0L3QvtCz0L4g0L/QvtGC0L7QutCwXG4gICAgICAgIGNvbnN0IHBhcnNlZEZvbnQgPSBhd2FpdCBfcGFyc2VGb250QnVmZmVyRGlyZWN0KGJ1ZmZlciwgZm9udE5hbWUpO1xuICAgICAgICByZXNvbHZlKHBhcnNlZEZvbnQpO1xuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ1VuZXhwZWN0ZWQgZXJyb3IgZHVyaW5nIGZvbnQgYnVmZmVyIHByb2Nlc3NpbmcgKGRpcmVjdCk6JywgZXJyb3IpO1xuICAgICAgICAgcmVzb2x2ZShudWxsKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIHJlYWRlci5vbmVycm9yID0gKGVycm9yKSA9PiB7XG4gICAgICB0b2FzdC5lcnJvcihg0J7RiNC40LHQutCwINC/0YDQuCDRh9GC0LXQvdC40Lgg0YTQsNC50LvQsCDRiNGA0LjRhNGC0LAgJHtmb250TmFtZX1gKTtcbiAgICAgIGNvbnNvbGUuZXJyb3IoYEZpbGVSZWFkZXIgZXJyb3IgZm9yICR7Zm9udE5hbWV9OmAsIGVycm9yKTtcbiAgICAgIHJlc29sdmUobnVsbCk7XG4gICAgfTtcblxuICAgIHRyeSB7XG4gICAgICByZWFkZXIucmVhZEFzQXJyYXlCdWZmZXIoZmlsZSk7XG4gICAgfSBjYXRjaCAocmVhZEVycm9yKSB7XG4gICAgICAgIHRvYXN0LmVycm9yKGDQndC1INGD0LTQsNC70L7RgdGMINC90LDRh9Cw0YLRjCDRh9GC0LXQvdC40LUg0YTQsNC50LvQsCAke2ZvbnROYW1lfWApO1xuICAgICAgICBjb25zb2xlLmVycm9yKGBFcnJvciBjYWxsaW5nIHJlYWRBc0FycmF5QnVmZmVyIGZvciAke2ZvbnROYW1lfTpgLCByZWFkRXJyb3IpO1xuICAgICAgICByZXNvbHZlKG51bGwpO1xuICAgIH1cbiAgfSk7XG59O1xuXG4vKipcbiAqIFvQotC+0LvRjNC60L4g0L7RgdC90L7QstC90L7QuSDQv9C+0YLQvtC6XSDQn9C+0LvRg9GH0LDQtdGCINC00LDQvdC90YvQtSDQs9C70LjRhNC+0LIg0LTQu9GPINGI0YDQuNGE0YLQsC5cbiAqIEBwYXJhbSB7T2JqZWN0fSBmb250T2JqIC0g0J7QsdGK0LXQutGCINGI0YDQuNGE0YLQsFxuICogQHJldHVybnMge1Byb21pc2U8T2JqZWN0fG51bGw+fSAtINCf0YDQvtC80LjRgSDRgSDQtNCw0L3QvdGL0LzQuCDQs9C70LjRhNC+0LIg0LjQu9C4IG51bGwuXG4gKi9cbmV4cG9ydCBjb25zdCBnZXRHbHlwaERhdGFGb3JGb250ID0gYXN5bmMgKGZvbnRPYmopID0+IHtcbiAgaWYgKCFmb250T2JqIHx8ICFmb250T2JqLmZpbGUpIHtcbiAgICBjb25zb2xlLmVycm9yKCdnZXRHbHlwaERhdGFGb3JGb250OiBJbnZhbGlkIGZvbnRPYmogb3IgbWlzc2luZyBmaWxlLicpO1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIFxuICBjb25zdCBmb250SWQgPSBmb250T2JqLmlkIHx8IGZvbnRPYmoubmFtZTtcblxuICB0cnkge1xuICAgIC8vINCf0L7Qu9GD0YfQsNC10LwgQXJyYXlCdWZmZXJcbiAgICBjb25zdCBidWZmZXIgPSBhd2FpdCBmb250T2JqLmZpbGUuYXJyYXlCdWZmZXIoKTtcbiAgICBpZiAoIWJ1ZmZlciB8fCBidWZmZXIuYnl0ZUxlbmd0aCA9PT0gMCkge1xuICAgICAgY29uc29sZS5lcnJvcihgW2ZvbnRQYXJzZXJdIEZvbnQgZmlsZSBidWZmZXIgaXMgZW1wdHkgZm9yICR7Zm9udE9iai5uYW1lfWApO1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRm9udCBmaWxlIGJ1ZmZlciBpcyBlbXB0eS5cIik7XG4gICAgfVxuXG4gICAgLy8gLS0tINCY0YHQv9C+0LvRjNC30YPQtdC8INGC0L7Qu9GM0LrQviDQvtGB0L3QvtCy0L3QvtC5INC/0L7RgtC+0LogLS0tIFxuICAgIGNvbnNvbGUubG9nKGBbZm9udFBhcnNlcl0gUHJvY2Vzc2luZyBnbHlwaHMgaW4gbWFpbiB0aHJlYWQgZm9yICR7Zm9udE9iai5uYW1lfWApO1xuICAgIFxuICAgIC8vINCf0LDRgNGB0LjQvCDQsdGD0YTQtdGAINCyINC+0YHQvdC+0LLQvdC+0Lwg0L/QvtGC0L7QutC1XG4gICAgY29uc3QgZm9udCA9IGF3YWl0IHBhcnNlRm9udEJ1ZmZlcihidWZmZXIsIGZvbnRPYmoubmFtZSk7IC8vIHBhcnNlRm9udEJ1ZmZlciDRgtC10L/QtdGA0Ywg0LLRi9C30YvQstCw0LXRgiBfcGFyc2VGb250QnVmZmVyRGlyZWN0XG4gICAgICAgIGlmICghZm9udCkge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcihgW2ZvbnRQYXJzZXJdIE1haW4gdGhyZWFkOiBGYWlsZWQgdG8gcGFyc2UgZm9udCBidWZmZXIgZm9yICR7Zm9udE9iai5uYW1lfWApO1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCfQntGI0LjQsdC60LAg0L/RgNC4INC/0LDRgNGB0LjQvdCz0LUg0YjRgNC40YTRgtCwINCyINC+0YHQvdC+0LLQvdC+0Lwg0L/QvtGC0L7QutC1Jyk7XG4gICAgICAgIH1cblxuICAgIC8vINCY0LfQstC70LXQutCw0LXQvCDQs9C70LjRhNGLXG4gICAgY29uc3QgcmVzdWx0RGF0YSA9IGV4dHJhY3RCYXNpY0dseXBoRGF0YShmb250LCAnbWFpbicpO1xuXG4gICAgICAgIGlmICghcmVzdWx0RGF0YSkge1xuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoYFtmb250UGFyc2VyXSBNYWluIHRocmVhZDogZXh0cmFjdEJhc2ljR2x5cGhEYXRhIHJldHVybmVkIG51bGwgZm9yICR7Zm9udE9iai5uYW1lfS5gKTtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ9Ce0YjQuNCx0LrQsCDQv9GA0Lgg0LjQt9Cy0LvQtdGH0LXQvdC40Lgg0LTQsNC90L3Ri9GFINCz0LvQuNGE0L7QsiDQsiDQvtGB0L3QvtCy0L3QvtC8INC/0L7RgtC+0LrQtScpO1xuICAgICAgICB9XG4gICAgLy8gLS0tINCa0L7QvdC10YYg0LjRgdC/0L7Qu9GM0LfQvtCy0LDQvdC40Y8g0L7RgdC90L7QstC90L7Qs9C+INC/0L7RgtC+0LrQsCAtLS0gXG4gICAgICBcbiAgICAvLyDQm9C+0LPQuNGA0YPQtdC8INC+0YjQuNCx0LrQuCwg0LXRgdC70Lgg0L7QvdC4INCx0YvQu9C4XG4gICAgICBpZiAocmVzdWx0RGF0YS5lcnJvcnMgJiYgcmVzdWx0RGF0YS5lcnJvcnMubGVuZ3RoID4gMCkge1xuICAgICAgY29uc29sZS53YXJuKGBbZm9udFBhcnNlciAtIG1haW5dIEZvdW5kICR7cmVzdWx0RGF0YS5lcnJvcnMubGVuZ3RofSBlcnJvcnMgcHJvY2Vzc2luZyBnbHlwaHMgZm9yICR7Zm9udE9iai5uYW1lfS5gKTtcbiAgICAgIH1cblxuICAgICAgLy8g0J/RgNC+0LLQtdGA0Y/QtdC8INC40YLQvtCz0L7QstGL0Lkg0YDQtdC30YPQu9GM0YLQsNGCINC/0LXRgNC10LQg0LLQvtC30LLRgNCw0YLQvtC8XG4gICAgICBpZiAoIXJlc3VsdERhdGEgfHwgIUFycmF5LmlzQXJyYXkocmVzdWx0RGF0YS5hbGxHbHlwaHMpKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoYFtmb250UGFyc2VyIC0gbWFpbl0gRmluYWwgZ2x5cGggZGF0YSByZXN1bHQgaXMgaW52YWxpZCBmb3IgJHtmb250T2JqLm5hbWV9YCwgcmVzdWx0RGF0YSk7XG4gICAgICAgIHJldHVybiBudWxsOyBcbiAgICAgIH1cblxuICAgIHJldHVybiByZXN1bHREYXRhOyAvLyDQktC+0LfQstGA0LDRidCw0LXQvCB7IGFsbEdseXBocywgbmFtZXMsIHVuaWNvZGVzLCBhZHZhbmNlV2lkdGhzLCBlcnJvcnMgfVxuXG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgY29uc29sZS5lcnJvcihgW2ZvbnRQYXJzZXJdIEVycm9yIGluIGdldEdseXBoRGF0YUZvckZvbnQgZm9yICR7Zm9udElkfTpgLCBlcnJvcik7XG4gICAgLy8gdG9hc3QuZXJyb3IoJ9Ce0YjQuNCx0LrQsCDQv9GA0Lgg0LfQsNCz0YDRg9C30LrQtSDQtNCw0L3QvdGL0YUg0L4g0LPQu9C40YTQsNGFJyk7IC8vINCc0L7QttC90L4g0YDQsNGB0LrQvtC80LzQtdC90YLQuNGA0L7QstCw0YLRjCwg0LXRgdC70Lgg0L3Rg9C20L3QvlxuICAgIHJldHVybiBudWxsOyAvLyDQktC+0LfQstGA0LDRidCw0LXQvCBudWxsINC/0YDQuCDQutGA0LjRgtC40YfQtdGB0LrQvtC5INC+0YjQuNCx0LrQtVxuICB9XG59OyAiXSwibmFtZXMiOlsib3BlbnR5cGUiLCJ0b2FzdCIsImV4dHJhY3RCYXNpY0dseXBoRGF0YSIsImRlY29tcHJlc3MiLCJjb25zb2xlIiwibG9nIiwidmVyc2lvbiIsImUiLCJlcnJvciIsImlzV29mZjIiLCJidWZmZXIiLCJieXRlTGVuZ3RoIiwiQXJyYXlCdWZmZXIiLCJzbGljZSIsInNpZ25hdHVyZSIsIlN0cmluZyIsImZyb21DaGFyQ29kZSIsIlVpbnQ4QXJyYXkiLCJpc1ZhcmlhYmxlRm9udCIsImZvbnREYXRhIiwidGFibGVzIiwiZnZhciIsInBhcnNlRm9udEJ1ZmZlciIsImZvbnROYW1lIiwiX3BhcnNlRm9udEJ1ZmZlckRpcmVjdCIsInByb2Nlc3NlZEJ1ZmZlciIsIkVycm9yIiwiZGVjb21wcmVzc2VkRGF0YSIsImRlY29tcEVycm9yIiwibWVzc2FnZSIsInBhcnNlIiwicGFyc2VkRm9udCIsInBhcnNlRXJyb3IiLCJfcGFyc2VGb250RmlsZURpcmVjdCIsImZpbGUiLCJQcm9taXNlIiwicmVzb2x2ZSIsIkJsb2IiLCJyZWFkZXIiLCJGaWxlUmVhZGVyIiwib25sb2FkIiwidGFyZ2V0IiwicmVzdWx0Iiwib25lcnJvciIsInJlYWRBc0FycmF5QnVmZmVyIiwicmVhZEVycm9yIiwiZ2V0R2x5cGhEYXRhRm9yRm9udCIsImZvbnRPYmoiLCJmb250SWQiLCJpZCIsIm5hbWUiLCJhcnJheUJ1ZmZlciIsImZvbnQiLCJyZXN1bHREYXRhIiwiZXJyb3JzIiwibGVuZ3RoIiwid2FybiIsIkFycmF5IiwiaXNBcnJheSIsImFsbEdseXBocyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./utils/fontParser.js\n"));

/***/ }),

/***/ "./utils/fontUtilsCommon.js":
/*!**********************************!*\
  !*** ./utils/fontUtilsCommon.js ***!
  \**********************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   PRESET_STYLES: function() { return /* binding */ PRESET_STYLES; },\n/* harmony export */   findStyleInfoByWeightAndStyle: function() { return /* binding */ findStyleInfoByWeightAndStyle; },\n/* harmony export */   getAxisName: function() { return /* binding */ getAxisName; },\n/* harmony export */   getFormatFromExtension: function() { return /* binding */ getFormatFromExtension; }\n/* harmony export */ });\n// Общие вспомогательные функции для работы со шрифтами\n// Константы пресетов стилей\nconst PRESET_STYLES = [\n    {\n        name: \"Thin\",\n        weight: 100,\n        style: \"normal\"\n    },\n    {\n        name: \"ExtraLight\",\n        weight: 200,\n        style: \"normal\"\n    },\n    {\n        name: \"Light\",\n        weight: 300,\n        style: \"normal\"\n    },\n    {\n        name: \"Regular\",\n        weight: 400,\n        style: \"normal\"\n    },\n    {\n        name: \"Medium\",\n        weight: 500,\n        style: \"normal\"\n    },\n    {\n        name: \"SemiBold\",\n        weight: 600,\n        style: \"normal\"\n    },\n    {\n        name: \"Bold\",\n        weight: 700,\n        style: \"normal\"\n    },\n    {\n        name: \"ExtraBold\",\n        weight: 800,\n        style: \"normal\"\n    },\n    {\n        name: \"Black\",\n        weight: 900,\n        style: \"normal\"\n    },\n    // { name: 'ExtraBlack', weight: 1000, style: 'normal' }, // Редко используется\n    {\n        name: \"Thin Italic\",\n        weight: 100,\n        style: \"italic\"\n    },\n    {\n        name: \"ExtraLight Italic\",\n        weight: 200,\n        style: \"italic\"\n    },\n    {\n        name: \"Light Italic\",\n        weight: 300,\n        style: \"italic\"\n    },\n    {\n        name: \"Italic\",\n        weight: 400,\n        style: \"italic\"\n    },\n    {\n        name: \"Medium Italic\",\n        weight: 500,\n        style: \"italic\"\n    },\n    {\n        name: \"SemiBold Italic\",\n        weight: 600,\n        style: \"italic\"\n    },\n    {\n        name: \"Bold Italic\",\n        weight: 700,\n        style: \"italic\"\n    },\n    {\n        name: \"ExtraBold Italic\",\n        weight: 800,\n        style: \"italic\"\n    },\n    {\n        name: \"Black Italic\",\n        weight: 900,\n        style: \"italic\"\n    }\n];\n/**\n * Находит информацию о стиле по весу и типу шрифта\n * @param {number} weight - Вес шрифта (100-900)\n * @param {string} style - Стиль шрифта ('normal', 'italic')\n * @returns {Object} - Объект с информацией о стиле (имя, вес, стиль)\n */ const findStyleInfoByWeightAndStyle = (weight, style)=>{\n    // Нормализуем вес для поиска\n    if (!weight) weight = 400;\n    if (!style) style = \"normal\";\n    // Ищем соответствие стилю и весу\n    switch(true){\n        case weight <= 100 && style === \"normal\":\n            return {\n                name: \"Thin\",\n                weight: 100,\n                style: \"normal\"\n            };\n        case weight <= 100 && style === \"italic\":\n            return {\n                name: \"Thin Italic\",\n                weight: 100,\n                style: \"italic\"\n            };\n        case weight <= 200 && style === \"normal\":\n            return {\n                name: \"ExtraLight\",\n                weight: 200,\n                style: \"normal\"\n            };\n        case weight <= 200 && style === \"italic\":\n            return {\n                name: \"ExtraLight Italic\",\n                weight: 200,\n                style: \"italic\"\n            };\n        case weight <= 300 && style === \"normal\":\n            return {\n                name: \"Light\",\n                weight: 300,\n                style: \"normal\"\n            };\n        case weight <= 300 && style === \"italic\":\n            return {\n                name: \"Light Italic\",\n                weight: 300,\n                style: \"italic\"\n            };\n        case weight <= 400 && style === \"normal\":\n            return {\n                name: \"Regular\",\n                weight: 400,\n                style: \"normal\"\n            };\n        case weight <= 400 && style === \"italic\":\n            return {\n                name: \"Italic\",\n                weight: 400,\n                style: \"italic\"\n            };\n        case weight <= 500 && style === \"normal\":\n            return {\n                name: \"Medium\",\n                weight: 500,\n                style: \"normal\"\n            };\n        case weight <= 500 && style === \"italic\":\n            return {\n                name: \"Medium Italic\",\n                weight: 500,\n                style: \"italic\"\n            };\n        case weight <= 600 && style === \"normal\":\n            return {\n                name: \"SemiBold\",\n                weight: 600,\n                style: \"normal\"\n            };\n        case weight <= 600 && style === \"italic\":\n            return {\n                name: \"SemiBold Italic\",\n                weight: 600,\n                style: \"italic\"\n            };\n        case weight <= 700 && style === \"normal\":\n            return {\n                name: \"Bold\",\n                weight: 700,\n                style: \"normal\"\n            };\n        case weight <= 700 && style === \"italic\":\n            return {\n                name: \"Bold Italic\",\n                weight: 700,\n                style: \"italic\"\n            };\n        case weight <= 800 && style === \"normal\":\n            return {\n                name: \"ExtraBold\",\n                weight: 800,\n                style: \"normal\"\n            };\n        case weight <= 800 && style === \"italic\":\n            return {\n                name: \"ExtraBold Italic\",\n                weight: 800,\n                style: \"italic\"\n            };\n        case weight <= 900 && style === \"normal\":\n            return {\n                name: \"Black\",\n                weight: 900,\n                style: \"normal\"\n            };\n        case weight <= 900 && style === \"italic\":\n            return {\n                name: \"Black Italic\",\n                weight: 900,\n                style: \"italic\"\n            };\n        default:\n            return {\n                name: \"Regular\",\n                weight: 400,\n                style: \"normal\"\n            };\n    }\n};\n/**\n * Определяет формат шрифта на основе расширения файла\n * @param {string} fileName - Имя файла шрифта\n * @returns {string} - Формат шрифта для @font-face\n */ const getFormatFromExtension = (fileName)=>{\n    const extension = (fileName === null || fileName === void 0 ? void 0 : fileName.toLowerCase().split(\".\").pop()) || \"\";\n    switch(extension){\n        case \"ttf\":\n            return \"truetype\";\n        case \"otf\":\n            return \"opentype\";\n        case \"woff\":\n            return \"woff\";\n        case \"woff2\":\n            return \"woff2\";\n        default:\n            // Попытка вернуть truetype по умолчанию, если расширение неизвестно, но есть\n            return extension ? \"truetype\" : \"\";\n    }\n};\n/**\n * Получает читаемое имя для тега оси вариативного шрифта\n * @param {string} tag - Тег оси (например, 'wght', 'wdth')\n * @returns {string} - Читаемое имя (например, 'Weight', 'Width')\n */ const getAxisName = (tag)=>{\n// ... (остальной код)\n};\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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RyxPQUFNO0lBQzlELE9BQVFIO1FBQ04sS0FBSztZQUNILE9BQU87UUFDVCxLQUFLO1lBQ0gsT0FBTztRQUNULEtBQUs7WUFDSCxPQUFPO1FBQ1QsS0FBSztZQUNILE9BQU87UUFDVDtZQUNFLDZFQUE2RTtZQUM3RSxPQUFPQSxZQUFZLGFBQWE7SUFDcEM7QUFDRixFQUFFO0FBRUY7Ozs7Q0FJQyxHQUNNLE1BQU1JLGNBQWMsQ0FBQ0M7QUFDMUIsc0JBQXNCO0FBQ3hCLEVBQUUiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vdXRpbHMvZm9udFV0aWxzQ29tbW9uLmpzP2NlYWQiXSwic291cmNlc0NvbnRlbnQiOlsiLy8g0J7QsdGJ0LjQtSDQstGB0L/QvtC80L7Qs9Cw0YLQtdC70YzQvdGL0LUg0YTRg9C90LrRhtC40Lgg0LTQu9GPINGA0LDQsdC+0YLRiyDRgdC+INGI0YDQuNGE0YLQsNC80LhcblxuLy8g0JrQvtC90YHRgtCw0L3RgtGLINC/0YDQtdGB0LXRgtC+0LIg0YHRgtC40LvQtdC5XG5leHBvcnQgY29uc3QgUFJFU0VUX1NUWUxFUyA9IFtcbiAgeyBuYW1lOiAnVGhpbicsIHdlaWdodDogMTAwLCBzdHlsZTogJ25vcm1hbCcgfSxcbiAgeyBuYW1lOiAnRXh0cmFMaWdodCcsIHdlaWdodDogMjAwLCBzdHlsZTogJ25vcm1hbCcgfSxcbiAgeyBuYW1lOiAnTGlnaHQnLCB3ZWlnaHQ6IDMwMCwgc3R5bGU6ICdub3JtYWwnIH0sXG4gIHsgbmFtZTogJ1JlZ3VsYXInLCB3ZWlnaHQ6IDQwMCwgc3R5bGU6ICdub3JtYWwnIH0sXG4gIHsgbmFtZTogJ01lZGl1bScsIHdlaWdodDogNTAwLCBzdHlsZTogJ25vcm1hbCcgfSxcbiAgeyBuYW1lOiAnU2VtaUJvbGQnLCB3ZWlnaHQ6IDYwMCwgc3R5bGU6ICdub3JtYWwnIH0sXG4gIHsgbmFtZTogJ0JvbGQnLCB3ZWlnaHQ6IDcwMCwgc3R5bGU6ICdub3JtYWwnIH0sXG4gIHsgbmFtZTogJ0V4dHJhQm9sZCcsIHdlaWdodDogODAwLCBzdHlsZTogJ25vcm1hbCcgfSxcbiAgeyBuYW1lOiAnQmxhY2snLCB3ZWlnaHQ6IDkwMCwgc3R5bGU6ICdub3JtYWwnIH0sXG4gIC8vIHsgbmFtZTogJ0V4dHJhQmxhY2snLCB3ZWlnaHQ6IDEwMDAsIHN0eWxlOiAnbm9ybWFsJyB9LCAvLyDQoNC10LTQutC+INC40YHQv9C+0LvRjNC30YPQtdGC0YHRj1xuICB7IG5hbWU6ICdUaGluIEl0YWxpYycsIHdlaWdodDogMTAwLCBzdHlsZTogJ2l0YWxpYycgfSxcbiAgeyBuYW1lOiAnRXh0cmFMaWdodCBJdGFsaWMnLCB3ZWlnaHQ6IDIwMCwgc3R5bGU6ICdpdGFsaWMnIH0sXG4gIHsgbmFtZTogJ0xpZ2h0IEl0YWxpYycsIHdlaWdodDogMzAwLCBzdHlsZTogJ2l0YWxpYycgfSxcbiAgeyBuYW1lOiAnSXRhbGljJywgd2VpZ2h0OiA0MDAsIHN0eWxlOiAnaXRhbGljJyB9LFxuICB7IG5hbWU6ICdNZWRpdW0gSXRhbGljJywgd2VpZ2h0OiA1MDAsIHN0eWxlOiAnaXRhbGljJyB9LFxuICB7IG5hbWU6ICdTZW1pQm9sZCBJdGFsaWMnLCB3ZWlnaHQ6IDYwMCwgc3R5bGU6ICdpdGFsaWMnIH0sXG4gIHsgbmFtZTogJ0JvbGQgSXRhbGljJywgd2VpZ2h0OiA3MDAsIHN0eWxlOiAnaXRhbGljJyB9LFxuICB7IG5hbWU6ICdFeHRyYUJvbGQgSXRhbGljJywgd2VpZ2h0OiA4MDAsIHN0eWxlOiAnaXRhbGljJyB9LFxuICB7IG5hbWU6ICdCbGFjayBJdGFsaWMnLCB3ZWlnaHQ6IDkwMCwgc3R5bGU6ICdpdGFsaWMnIH0sXG4gIC8vIHsgbmFtZTogJ0V4dHJhQmxhY2sgSXRhbGljJywgd2VpZ2h0OiAxMDAwLCBzdHlsZTogJ2l0YWxpYycgfVxuXTtcblxuLyoqXG4gKiDQndCw0YXQvtC00LjRgiDQuNC90YTQvtGA0LzQsNGG0LjRjiDQviDRgdGC0LjQu9C1INC/0L4g0LLQtdGB0YMg0Lgg0YLQuNC/0YMg0YjRgNC40YTRgtCwXG4gKiBAcGFyYW0ge251bWJlcn0gd2VpZ2h0IC0g0JLQtdGBINGI0YDQuNGE0YLQsCAoMTAwLTkwMClcbiAqIEBwYXJhbSB7c3RyaW5nfSBzdHlsZSAtINCh0YLQuNC70Ywg0YjRgNC40YTRgtCwICgnbm9ybWFsJywgJ2l0YWxpYycpXG4gKiBAcmV0dXJucyB7T2JqZWN0fSAtINCe0LHRitC10LrRgiDRgSDQuNC90YTQvtGA0LzQsNGG0LjQtdC5INC+INGB0YLQuNC70LUgKNC40LzRjywg0LLQtdGBLCDRgdGC0LjQu9GMKVxuICovXG5leHBvcnQgY29uc3QgZmluZFN0eWxlSW5mb0J5V2VpZ2h0QW5kU3R5bGUgPSAod2VpZ2h0LCBzdHlsZSkgPT4ge1xuICAvLyDQndC+0YDQvNCw0LvQuNC30YPQtdC8INCy0LXRgSDQtNC70Y8g0L/QvtC40YHQutCwXG4gIGlmICghd2VpZ2h0KSB3ZWlnaHQgPSA0MDA7XG4gIGlmICghc3R5bGUpIHN0eWxlID0gJ25vcm1hbCc7XG5cbiAgLy8g0JjRidC10Lwg0YHQvtC+0YLQstC10YLRgdGC0LLQuNC1INGB0YLQuNC70Y4g0Lgg0LLQtdGB0YNcbiAgc3dpdGNoICh0cnVlKSB7XG4gICAgY2FzZSB3ZWlnaHQgPD0gMTAwICYmIHN0eWxlID09PSAnbm9ybWFsJzpcbiAgICAgIHJldHVybiB7IG5hbWU6ICdUaGluJywgd2VpZ2h0OiAxMDAsIHN0eWxlOiAnbm9ybWFsJyB9O1xuICAgIGNhc2Ugd2VpZ2h0IDw9IDEwMCAmJiBzdHlsZSA9PT0gJ2l0YWxpYyc6XG4gICAgICByZXR1cm4geyBuYW1lOiAnVGhpbiBJdGFsaWMnLCB3ZWlnaHQ6IDEwMCwgc3R5bGU6ICdpdGFsaWMnIH07XG4gICAgY2FzZSB3ZWlnaHQgPD0gMjAwICYmIHN0eWxlID09PSAnbm9ybWFsJzpcbiAgICAgIHJldHVybiB7IG5hbWU6ICdFeHRyYUxpZ2h0Jywgd2VpZ2h0OiAyMDAsIHN0eWxlOiAnbm9ybWFsJyB9O1xuICAgIGNhc2Ugd2VpZ2h0IDw9IDIwMCAmJiBzdHlsZSA9PT0gJ2l0YWxpYyc6XG4gICAgICByZXR1cm4geyBuYW1lOiAnRXh0cmFMaWdodCBJdGFsaWMnLCB3ZWlnaHQ6IDIwMCwgc3R5bGU6ICdpdGFsaWMnIH07XG4gICAgY2FzZSB3ZWlnaHQgPD0gMzAwICYmIHN0eWxlID09PSAnbm9ybWFsJzpcbiAgICAgIHJldHVybiB7IG5hbWU6ICdMaWdodCcsIHdlaWdodDogMzAwLCBzdHlsZTogJ25vcm1hbCcgfTtcbiAgICBjYXNlIHdlaWdodCA8PSAzMDAgJiYgc3R5bGUgPT09ICdpdGFsaWMnOlxuICAgICAgcmV0dXJuIHsgbmFtZTogJ0xpZ2h0IEl0YWxpYycsIHdlaWdodDogMzAwLCBzdHlsZTogJ2l0YWxpYycgfTtcbiAgICBjYXNlIHdlaWdodCA8PSA0MDAgJiYgc3R5bGUgPT09ICdub3JtYWwnOlxuICAgICAgcmV0dXJuIHsgbmFtZTogJ1JlZ3VsYXInLCB3ZWlnaHQ6IDQwMCwgc3R5bGU6ICdub3JtYWwnIH07XG4gICAgY2FzZSB3ZWlnaHQgPD0gNDAwICYmIHN0eWxlID09PSAnaXRhbGljJzpcbiAgICAgIHJldHVybiB7IG5hbWU6ICdJdGFsaWMnLCB3ZWlnaHQ6IDQwMCwgc3R5bGU6ICdpdGFsaWMnIH07XG4gICAgY2FzZSB3ZWlnaHQgPD0gNTAwICYmIHN0eWxlID09PSAnbm9ybWFsJzpcbiAgICAgIHJldHVybiB7IG5hbWU6ICdNZWRpdW0nLCB3ZWlnaHQ6IDUwMCwgc3R5bGU6ICdub3JtYWwnIH07XG4gICAgY2FzZSB3ZWlnaHQgPD0gNTAwICYmIHN0eWxlID09PSAnaXRhbGljJzpcbiAgICAgIHJldHVybiB7IG5hbWU6ICdNZWRpdW0gSXRhbGljJywgd2VpZ2h0OiA1MDAsIHN0eWxlOiAnaXRhbGljJyB9O1xuICAgIGNhc2Ugd2VpZ2h0IDw9IDYwMCAmJiBzdHlsZSA9PT0gJ25vcm1hbCc6XG4gICAgICByZXR1cm4geyBuYW1lOiAnU2VtaUJvbGQnLCB3ZWlnaHQ6IDYwMCwgc3R5bGU6ICdub3JtYWwnIH07XG4gICAgY2FzZSB3ZWlnaHQgPD0gNjAwICYmIHN0eWxlID09PSAnaXRhbGljJzpcbiAgICAgIHJldHVybiB7IG5hbWU6ICdTZW1pQm9sZCBJdGFsaWMnLCB3ZWlnaHQ6IDYwMCwgc3R5bGU6ICdpdGFsaWMnIH07XG4gICAgY2FzZSB3ZWlnaHQgPD0gNzAwICYmIHN0eWxlID09PSAnbm9ybWFsJzpcbiAgICAgIHJldHVybiB7IG5hbWU6ICdCb2xkJywgd2VpZ2h0OiA3MDAsIHN0eWxlOiAnbm9ybWFsJyB9O1xuICAgIGNhc2Ugd2VpZ2h0IDw9IDcwMCAmJiBzdHlsZSA9PT0gJ2l0YWxpYyc6XG4gICAgICByZXR1cm4geyBuYW1lOiAnQm9sZCBJdGFsaWMnLCB3ZWlnaHQ6IDcwMCwgc3R5bGU6ICdpdGFsaWMnIH07XG4gICAgY2FzZSB3ZWlnaHQgPD0gODAwICYmIHN0eWxlID09PSAnbm9ybWFsJzpcbiAgICAgIHJldHVybiB7IG5hbWU6ICdFeHRyYUJvbGQnLCB3ZWlnaHQ6IDgwMCwgc3R5bGU6ICdub3JtYWwnIH07XG4gICAgY2FzZSB3ZWlnaHQgPD0gODAwICYmIHN0eWxlID09PSAnaXRhbGljJzpcbiAgICAgIHJldHVybiB7IG5hbWU6ICdFeHRyYUJvbGQgSXRhbGljJywgd2VpZ2h0OiA4MDAsIHN0eWxlOiAnaXRhbGljJyB9O1xuICAgIGNhc2Ugd2VpZ2h0IDw9IDkwMCAmJiBzdHlsZSA9PT0gJ25vcm1hbCc6XG4gICAgICByZXR1cm4geyBuYW1lOiAnQmxhY2snLCB3ZWlnaHQ6IDkwMCwgc3R5bGU6ICdub3JtYWwnIH07XG4gICAgY2FzZSB3ZWlnaHQgPD0gOTAwICYmIHN0eWxlID09PSAnaXRhbGljJzpcbiAgICAgIHJldHVybiB7IG5hbWU6ICdCbGFjayBJdGFsaWMnLCB3ZWlnaHQ6IDkwMCwgc3R5bGU6ICdpdGFsaWMnIH07XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiB7IG5hbWU6ICdSZWd1bGFyJywgd2VpZ2h0OiA0MDAsIHN0eWxlOiAnbm9ybWFsJyB9O1xuICB9XG59O1xuXG4vKipcbiAqINCe0L/RgNC10LTQtdC70Y/QtdGCINGE0L7RgNC80LDRgiDRiNGA0LjRhNGC0LAg0L3QsCDQvtGB0L3QvtCy0LUg0YDQsNGB0YjQuNGA0LXQvdC40Y8g0YTQsNC50LvQsFxuICogQHBhcmFtIHtzdHJpbmd9IGZpbGVOYW1lIC0g0JjQvNGPINGE0LDQudC70LAg0YjRgNC40YTRgtCwXG4gKiBAcmV0dXJucyB7c3RyaW5nfSAtINCk0L7RgNC80LDRgiDRiNGA0LjRhNGC0LAg0LTQu9GPIEBmb250LWZhY2VcbiAqL1xuZXhwb3J0IGNvbnN0IGdldEZvcm1hdEZyb21FeHRlbnNpb24gPSAoZmlsZU5hbWUpID0+IHtcbiAgY29uc3QgZXh0ZW5zaW9uID0gZmlsZU5hbWU/LnRvTG93ZXJDYXNlKCkuc3BsaXQoJy4nKS5wb3AoKSB8fCAnJztcbiAgc3dpdGNoIChleHRlbnNpb24pIHtcbiAgICBjYXNlICd0dGYnOlxuICAgICAgcmV0dXJuICd0cnVldHlwZSc7XG4gICAgY2FzZSAnb3RmJzpcbiAgICAgIHJldHVybiAnb3BlbnR5cGUnO1xuICAgIGNhc2UgJ3dvZmYnOlxuICAgICAgcmV0dXJuICd3b2ZmJztcbiAgICBjYXNlICd3b2ZmMic6XG4gICAgICByZXR1cm4gJ3dvZmYyJztcbiAgICBkZWZhdWx0OlxuICAgICAgLy8g0J/QvtC/0YvRgtC60LAg0LLQtdGA0L3Rg9GC0YwgdHJ1ZXR5cGUg0L/QviDRg9C80L7Qu9GH0LDQvdC40Y4sINC10YHQu9C4INGA0LDRgdGI0LjRgNC10L3QuNC1INC90LXQuNC30LLQtdGB0YLQvdC+LCDQvdC+INC10YHRgtGMXG4gICAgICByZXR1cm4gZXh0ZW5zaW9uID8gJ3RydWV0eXBlJyA6ICcnO1xuICB9XG59O1xuXG4vKipcbiAqINCf0L7Qu9GD0YfQsNC10YIg0YfQuNGC0LDQtdC80L7QtSDQuNC80Y8g0LTQu9GPINGC0LXQs9CwINC+0YHQuCDQstCw0YDQuNCw0YLQuNCy0L3QvtCz0L4g0YjRgNC40YTRgtCwXG4gKiBAcGFyYW0ge3N0cmluZ30gdGFnIC0g0KLQtdCzINC+0YHQuCAo0L3QsNC/0YDQuNC80LXRgCwgJ3dnaHQnLCAnd2R0aCcpXG4gKiBAcmV0dXJucyB7c3RyaW5nfSAtINCn0LjRgtCw0LXQvNC+0LUg0LjQvNGPICjQvdCw0L/RgNC40LzQtdGALCAnV2VpZ2h0JywgJ1dpZHRoJylcbiAqL1xuZXhwb3J0IGNvbnN0IGdldEF4aXNOYW1lID0gKHRhZykgPT4ge1xuICAvLyAuLi4gKNC+0YHRgtCw0LvRjNC90L7QuSDQutC+0LQpXG59OyAiXSwibmFtZXMiOlsiUFJFU0VUX1NUWUxFUyIsIm5hbWUiLCJ3ZWlnaHQiLCJzdHlsZSIsImZpbmRTdHlsZUluZm9CeVdlaWdodEFuZFN0eWxlIiwiZ2V0Rm9ybWF0RnJvbUV4dGVuc2lvbiIsImZpbGVOYW1lIiwiZXh0ZW5zaW9uIiwidG9Mb3dlckNhc2UiLCJzcGxpdCIsInBvcCIsImdldEF4aXNOYW1lIiwidGFnIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./utils/fontUtilsCommon.js\n"));

/***/ }),

/***/ "./utils/glyphUtils.js":
/*!*****************************!*\
  !*** ./utils/glyphUtils.js ***!
  \*****************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   extractBasicGlyphData: function() { return /* binding */ extractBasicGlyphData; },\n/* harmony export */   getAllGlyphsFromFont: function() { return /* binding */ getAllGlyphsFromFont; },\n/* harmony export */   getCharUnicode: function() { return /* binding */ getCharUnicode; },\n/* harmony export */   getGlyphAlternatives: function() { return /* binding */ getGlyphAlternatives; },\n/* harmony export */   getGlyphNameFromFont: function() { return /* binding */ getGlyphNameFromFont; },\n/* harmony export */   getLigatures: function() { return /* binding */ getLigatures; },\n/* harmony export */   getSimpleCharName: function() { return /* binding */ getSimpleCharName; }\n/* harmony export */ });\n// Функции для работы с глифами, лигатурами, альтернативными символами шрифта\n// import { getCharUnicode } from './fontUtilsCommon'; // Удаляем этот лишний импорт\n// Вспомогательные функции для работы с глифами и структурами opentype.js\n// --- НОВАЯ ОБЩАЯ ФУНКЦИЯ ---\n/**\n * Извлекает базовые данные глифов из объекта шрифта opentype.js\n * Эта функция будет использоваться как в основном потоке (fallback), так и в веб-воркере.\n * \n * @param {object} font - Распарсенный объект шрифта opentype.js\n * @param {string} [source='unknown'] - Источник вызова ('worker' или 'main') для логирования\n * @returns {object|null} - Объект с данными глифов: { allGlyphs: Array, names: Object, unicodes: Object, advanceWidths: Object, errors: Array }\n *                   или null в случае ошибки.\n */ const extractBasicGlyphData = function(font) {\n    let source = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : \"unknown\";\n    if (!font || !font.glyphs || typeof font.glyphs.get !== \"function\") {\n        console.error(\"[extractBasicGlyphData - \".concat(source, \"] Invalid font object provided.\"));\n        return null;\n    }\n    const allGlyphs = [];\n    const glyphNames = {};\n    const glyphUnicodes = {};\n    const advanceWidths = {};\n    const errors = []; // Собираем ошибки\n    const numGlyphs = font.numGlyphs;\n    // console.log(`[extractBasicGlyphData - ${source}] Processing ${numGlyphs} glyphs.`);\n    for(let i = 0; i < numGlyphs; i++){\n        try {\n            const glyph = font.glyphs.get(i);\n            // Пропускаем невалидные глифы и .notdef\n            if (!glyph || glyph.name === \".notdef\") {\n                continue;\n            }\n            // Основная информация\n            const glyphInfo = {\n                id: glyph.index,\n                name: glyph.name || \"glyph_\".concat(glyph.index),\n                unicode: glyph.unicode || null,\n                unicodes: glyph.unicodes || [],\n                advanceWidth: Math.round(glyph.advanceWidth) || 0\n            };\n            allGlyphs.push(glyphInfo);\n            // Сохраняем имя и Unicode для быстрого доступа\n            glyphNames[glyphInfo.id] = glyphInfo.name;\n            if (glyphInfo.unicode) {\n                glyphUnicodes[glyphInfo.id] = \"U+\".concat(glyphInfo.unicode.toString(16).toUpperCase().padStart(4, \"0\"));\n            }\n            advanceWidths[glyphInfo.id] = glyphInfo.advanceWidth;\n        } catch (glyphError) {\n            // Логируем ошибку обработки конкретного глифа\n            console.warn(\"[extractBasicGlyphData - \".concat(source, \"] Error processing glyph index \").concat(i, \":\"), glyphError);\n            errors.push({\n                index: i,\n                message: glyphError.message\n            }); // Сохраняем ошибку\n        }\n    }\n    // console.log(`[extractBasicGlyphData - ${source}] Successfully extracted ${allGlyphs.length} glyphs.`);\n    return {\n        allGlyphs: allGlyphs,\n        names: glyphNames,\n        unicodes: glyphUnicodes,\n        advanceWidths: advanceWidths,\n        errors: errors // Возвращаем ошибки\n    };\n};\n// --- КОНЕЦ НОВОЙ ОБЩЕЙ ФУНКЦИИ ---\n/**\n * Получает имя глифа из шрифта с помощью opentype.js\n * @param {Object} font - Объект шрифта из opentype.js\n * @param {string} char - Символ для поиска имени глифа\n * @returns {string|null} - Имя глифа из шрифта или null, если не найдено или ошибка\n */ const getGlyphNameFromFont = (font, char)=>{\n    if (!font || typeof font.charToGlyph !== \"function\" || !char || typeof char !== \"string\") {\n        return null;\n    }\n    try {\n        const glyph = font.charToGlyph(char);\n        return glyph ? glyph.name : null;\n    } catch (error) {\n        // console.error(`Error getting glyph name for char \"${char}\":`, error);\n        return null;\n    }\n};\n/**\n * Получает упрощенное название символа\n * @param {string} char - Символ для получения названия\n * @returns {string} - Упрощенное название символа\n */ const getSimpleCharName = (char)=>{\n    if (!char || typeof char !== \"string\" || !char.length) {\n        return \"unknown\";\n    }\n    // Используем специальный словарь для латинских букв\n    const latinNames = {\n        \"a\": \"a (lowercase)\",\n        \"b\": \"b (lowercase)\",\n        \"c\": \"c (lowercase)\",\n        \"d\": \"d (lowercase)\",\n        \"e\": \"e (lowercase)\",\n        \"f\": \"f (lowercase)\",\n        \"g\": \"g (lowercase)\",\n        \"h\": \"h (lowercase)\",\n        \"i\": \"i (lowercase)\",\n        \"j\": \"j (lowercase)\",\n        \"k\": \"k (lowercase)\",\n        \"l\": \"l (lowercase)\",\n        \"m\": \"m (lowercase)\",\n        \"n\": \"n (lowercase)\",\n        \"o\": \"o (lowercase)\",\n        \"p\": \"p (lowercase)\",\n        \"q\": \"q (lowercase)\",\n        \"r\": \"r (lowercase)\",\n        \"s\": \"s (lowercase)\",\n        \"t\": \"t (lowercase)\",\n        \"u\": \"u (lowercase)\",\n        \"v\": \"v (lowercase)\",\n        \"w\": \"w (lowercase)\",\n        \"x\": \"x (lowercase)\",\n        \"y\": \"y (lowercase)\",\n        \"z\": \"z (lowercase)\",\n        \"A\": \"A (uppercase)\",\n        \"B\": \"B (uppercase)\",\n        \"C\": \"C (uppercase)\",\n        \"D\": \"D (uppercase)\",\n        \"E\": \"E (uppercase)\",\n        \"F\": \"F (uppercase)\",\n        \"G\": \"G (uppercase)\",\n        \"H\": \"H (uppercase)\",\n        \"I\": \"I (uppercase)\",\n        \"J\": \"J (uppercase)\",\n        \"K\": \"K (uppercase)\",\n        \"L\": \"L (uppercase)\",\n        \"M\": \"M (uppercase)\",\n        \"N\": \"N (uppercase)\",\n        \"O\": \"O (uppercase)\",\n        \"P\": \"P (uppercase)\",\n        \"Q\": \"Q (uppercase)\",\n        \"R\": \"R (uppercase)\",\n        \"S\": \"S (uppercase)\",\n        \"T\": \"T (uppercase)\",\n        \"U\": \"U (uppercase)\",\n        \"V\": \"V (uppercase)\",\n        \"W\": \"W (uppercase)\",\n        \"X\": \"X (uppercase)\",\n        \"Y\": \"Y (uppercase)\",\n        \"Z\": \"Z (uppercase)\",\n        \"0\": \"zero\",\n        \"1\": \"one\",\n        \"2\": \"two\",\n        \"3\": \"three\",\n        \"4\": \"four\",\n        \"5\": \"five\",\n        \"6\": \"six\",\n        \"7\": \"seven\",\n        \"8\": \"eight\",\n        \"9\": \"nine\",\n        \".\": \"period\",\n        \",\": \"comma\",\n        \":\": \"colon\",\n        \";\": \"semicolon\",\n        \"-\": \"hyphen\",\n        \"_\": \"underscore\",\n        \"!\": \"exclamation\",\n        \"?\": \"question\",\n        '\"': \"quotation mark\",\n        \"'\": \"apostrophe\",\n        \"(\": \"left parenthesis\",\n        \")\": \"right parenthesis\",\n        \"[\": \"left bracket\",\n        \"]\": \"right bracket\",\n        \"{\": \"left brace\",\n        \"}\": \"right brace\",\n        \"/\": \"slash\",\n        \"\\\\\": \"backslash\",\n        \"|\": \"vertical bar\",\n        \"@\": \"at sign\",\n        \"#\": \"number sign\",\n        \"$\": \"dollar sign\",\n        \"%\": \"percent\",\n        \"^\": \"caret\",\n        \"&\": \"ampersand\",\n        \"*\": \"asterisk\",\n        \"+\": \"plus\",\n        \"=\": \"equals\",\n        \"<\": \"less than\",\n        \">\": \"greater than\",\n        \"~\": \"tilde\",\n        \"`\": \"grave accent\",\n        \"№\": \"numero\",\n        \"€\": \"euro sign\",\n        \"\\xa3\": \"pound sign\",\n        \"\\xa5\": \"yen sign\",\n        \"\\xa9\": \"copyright\",\n        \"\\xae\": \"registered\",\n        \"™\": \"trademark\",\n        \"\\xb0\": \"degree\",\n        \"\\xb1\": \"plus-minus\",\n        \"\\xd7\": \"multiply\",\n        \"\\xf7\": \"divide\",\n        \"≠\": \"not equal\",\n        \"≈\": \"approximately equal\",\n        \" \": \"space\"\n    };\n    // Используем словарь для кириллицы\n    const cyrillicNames = {\n        \"А\": \"А (заглавная)\",\n        \"Б\": \"Б (заглавная)\",\n        \"В\": \"В (заглавная)\",\n        \"Г\": \"Г (заглавная)\",\n        \"Д\": \"Д (заглавная)\",\n        \"Е\": \"Е (заглавная)\",\n        \"Ё\": \"Ё (заглавная)\",\n        \"Ж\": \"Ж (заглавная)\",\n        \"З\": \"З (заглавная)\",\n        \"И\": \"И (заглавная)\",\n        \"Й\": \"Й (заглавная)\",\n        \"К\": \"К (заглавная)\",\n        \"Л\": \"Л (заглавная)\",\n        \"М\": \"М (заглавная)\",\n        \"Н\": \"Н (заглавная)\",\n        \"О\": \"О (заглавная)\",\n        \"П\": \"П (заглавная)\",\n        \"Р\": \"Р (заглавная)\",\n        \"С\": \"С (заглавная)\",\n        \"Т\": \"Т (заглавная)\",\n        \"У\": \"У (заглавная)\",\n        \"Ф\": \"Ф (заглавная)\",\n        \"Х\": \"Х (заглавная)\",\n        \"Ц\": \"Ц (заглавная)\",\n        \"Ч\": \"Ч (заглавная)\",\n        \"Ш\": \"Ш (заглавная)\",\n        \"Щ\": \"Щ (заглавная)\",\n        \"Ъ\": \"Ъ (заглавная)\",\n        \"Ы\": \"Ы (заглавная)\",\n        \"Ь\": \"Ь (заглавная)\",\n        \"Э\": \"Э (заглавная)\",\n        \"Ю\": \"Ю (заглавная)\",\n        \"Я\": \"Я (заглавная)\",\n        \"а\": \"а (строчная)\",\n        \"б\": \"б (строчная)\",\n        \"в\": \"в (строчная)\",\n        \"г\": \"г (строчная)\",\n        \"д\": \"д (строчная)\",\n        \"е\": \"е (строчная)\",\n        \"ё\": \"ё (строчная)\",\n        \"ж\": \"ж (строчная)\",\n        \"з\": \"з (строчная)\",\n        \"и\": \"и (строчная)\",\n        \"й\": \"й (строчная)\",\n        \"к\": \"к (строчная)\",\n        \"л\": \"л (строчная)\",\n        \"м\": \"м (строчная)\",\n        \"н\": \"н (строчная)\",\n        \"о\": \"о (строчная)\",\n        \"п\": \"п (строчная)\",\n        \"р\": \"р (строчная)\",\n        \"с\": \"с (строчная)\",\n        \"т\": \"т (строчная)\",\n        \"у\": \"у (строчная)\",\n        \"ф\": \"ф (строчная)\",\n        \"х\": \"х (строчная)\",\n        \"ц\": \"ц (строчная)\",\n        \"ч\": \"ч (строчная)\",\n        \"ш\": \"ш (строчная)\",\n        \"щ\": \"щ (строчная)\",\n        \"ъ\": \"ъ (строчная)\",\n        \"ы\": \"ы (строчная)\",\n        \"ь\": \"ь (строчная)\",\n        \"э\": \"э (строчная)\",\n        \"ю\": \"ю (строчная)\",\n        \"я\": \"я (строчная)\"\n    };\n    // Сначала проверяем в словарях\n    if (latinNames[char]) return latinNames[char];\n    if (cyrillicNames[char]) return cyrillicNames[char];\n    // Если не нашли, пытаемся определить категорию символа по Unicode блоку\n    try {\n        const code = char.codePointAt(0);\n        if (isNaN(code)) return \"unknown\";\n        if (code >= 0x2600 && code <= 0x26FF) return \"Miscellaneous Symbols\";\n        if (code >= 0x2700 && code <= 0x27BF) return \"Dingbats\";\n        if (code >= 0x1F300 && code <= 0x1F5FF) return \"Miscellaneous Symbols and Pictographs\";\n        if (code >= 0x1F600 && code <= 0x1F64F) return \"Emoticons\";\n        if (code >= 0x1F680 && code <= 0x1F6FF) return \"Transport and Map Symbols\";\n        if (code >= 0x1F700 && code <= 0x1F77F) return \"Alchemical Symbols\";\n    // Добавить другие блоки по необходимости\n    } catch (error) {\n        // Ошибка при получении codePoint (например, для суррогатных пар)\n        return \"unknown\";\n    }\n    // Если не смогли классифицировать, возвращаем generic name\n    return \"character\";\n};\n/**\n * Получает все доступные глифы из шрифта\n * @param {Object} font - Объект шрифта из opentype.js\n * @returns {Array<{character: string, unicode: string, name: string, index: number}>} - Массив объектов глифов\n */ const getAllGlyphsFromFont = (font)=>{\n    if (!font || !font.glyphs || typeof font.glyphs.get !== \"function\" || typeof font.numGlyphs !== \"number\") {\n        return [];\n    }\n    try {\n        const glyphs = [];\n        const numGlyphs = font.numGlyphs;\n        for(let i = 0; i < numGlyphs; i++){\n            const glyph = font.glyphs.get(i);\n            // Пропускаем .notdef и глифы без Unicode\n            if (!glyph || glyph.name === \".notdef\" || !glyph.unicode) continue;\n            // Получаем символ (может быть несколько Unicode для одного глифа)\n            // Берем первый Unicode для простоты\n            const charCode = glyph.unicode;\n            const char = String.fromCodePoint(charCode);\n            // Добавляем только уникальные символы (не глифы)\n            if (!glyphs.some((g)=>g.character === char)) {\n                glyphs.push({\n                    character: char,\n                    unicode: getCharUnicode(char),\n                    name: glyph.name || \"\",\n                    index: i // Сохраняем индекс глифа\n                });\n            }\n        }\n        // Можно добавить сортировку по Unicode\n        glyphs.sort((a, b)=>a.unicode.localeCompare(b.unicode));\n        return glyphs;\n    } catch (error) {\n        console.error(\"Error getting all glyphs from font:\", error);\n        return [];\n    }\n};\n/**\n * Получает альтернативные формы глифа (если они есть в шрифте)\n * Реализация требует глубокого понимания таблицы GSUB 'aalt' и других фич.\n * Эта функция является заглушкой или требует значительной доработки.\n * @param {Object} font - Объект шрифта из opentype.js\n * @param {string} char - Символ для поиска альтернативных форм\n * @returns {Array<{name: string, unicode: string, index: number}>} - Массив объектов альтернативных глифов\n */ const getGlyphAlternatives = (font, char)=>{\n    if (!font || !char || !font.tables || !font.tables.gsub || !font.glyphs) return [];\n    try {\n        const alternatives = [];\n        const mainGlyph = font.charToGlyph(char);\n        if (!mainGlyph || !mainGlyph.index) return [];\n        const mainGlyphIndex = mainGlyph.index;\n        const gsub = font.tables.gsub;\n        // Поиск альтернатив в таблицах GSUB (упрощенный пример для lookupType 3)\n        if (gsub.lookups) {\n            for (const lookup of gsub.lookups){\n                // LookupType 3: Alternate Substitution Subtable\n                if (lookup.lookupType === 3) {\n                    for (const subtable of lookup.subtables){\n                        if (subtable.coverage && subtable.coverage.glyphs) {\n                            const coverageIndex = subtable.coverage.glyphs.indexOf(mainGlyphIndex);\n                            if (coverageIndex !== -1 && subtable.alternateSets && subtable.alternateSets[coverageIndex]) {\n                                const alternateIndices = subtable.alternateSets[coverageIndex];\n                                alternateIndices.forEach((altIndex)=>{\n                                    const altGlyph = font.glyphs.get(altIndex);\n                                    if (altGlyph) {\n                                        alternatives.push({\n                                            name: altGlyph.name || \"\",\n                                            unicode: altGlyph.unicode ? getCharUnicode(String.fromCodePoint(altGlyph.unicode)) : \"\",\n                                            index: altIndex\n                                        });\n                                    }\n                                });\n                            }\n                        }\n                    }\n                }\n            // Можно добавить поддержку других lookupTypes (e.g., lookupType 1)\n            }\n        }\n        // Удаляем дубликаты и основной глиф из альтернатив\n        const uniqueAlternatives = alternatives.filter((alt, index, self)=>alt.index !== mainGlyphIndex && index === self.findIndex((t)=>t.index === alt.index));\n        return uniqueAlternatives;\n    } catch (error) {\n        console.error(\"Error getting glyph alternatives:\", error);\n        return [];\n    }\n};\n/**\n * Получает лигатуры для последовательности символов (если они есть в шрифте)\n * Реализация требует глубокого понимания таблицы GSUB 'liga', 'clig' и др.\n * Эта функция является заглушкой или требует значительной доработки.\n * @param {Object} font - Объект шрифта из opentype.js\n * @param {string} chars - Последовательность символов для поиска лигатур\n * @returns {Array<{original: string, ligature: string, unicode: string}>} - Массив объектов лигатур\n */ const getLigatures = (font, chars)=>{\n    if (!font || !chars || chars.length < 2 || !font.tables || !font.tables.gsub) return [];\n    try {\n        const ligatures = [];\n        // const gsub = font.tables.gsub;\n        // TODO: Реализовать сложную логику поиска лигатур в GSUB таблицах (lookupType 4)\n        // Это требует рекурсивного обхода или сложного сопоставления последовательностей глифов.\n        // Добавляем базовые лигатуры для распространенных сочетаний как запасной вариант\n        const commonLigatures = {\n            \"ff\": \"ﬀ\",\n            \"fi\": \"ﬁ\",\n            \"fl\": \"ﬂ\",\n            \"ffi\": \"ﬃ\",\n            \"ffl\": \"ﬄ\"\n        };\n        if (commonLigatures[chars]) {\n            const ligChar = commonLigatures[chars];\n            ligatures.push({\n                original: chars,\n                ligature: ligChar,\n                unicode: getCharUnicode(ligChar)\n            });\n        }\n        return ligatures;\n    } catch (error) {\n        console.error(\"Error getting ligatures:\", error);\n        return [];\n    }\n};\n// Добавляем функцию getCharUnicode, перенесенную из fontUtilsCommon.js\n/**\n * Получает Unicode-код символа в формате \"U+XXXX\"\n * @param {string} char - Символ для получения Unicode\n * @returns {string} - Unicode-код в формате \"U+XXXX\"\n */ const getCharUnicode = (char)=>{\n    if (!char || typeof char !== \"string\" || !char.length) {\n        return \"U+????\";\n    }\n    try {\n        const codePoint = char.codePointAt(0);\n        // Проверка на NaN, чтобы избежать \"U+NAN\"\n        if (isNaN(codePoint)) {\n            return \"U+????\";\n        }\n        return \"U+\".concat(codePoint.toString(16).toUpperCase().padStart(4, \"0\"));\n    } catch (error) {\n        return \"U+????\";\n    }\n};\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi91dGlscy9nbHlwaFV0aWxzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7QUFBQSw2RUFBNkU7QUFDN0Usb0ZBQW9GO0FBRXBGLHlFQUF5RTtBQUV6RSw4QkFBOEI7QUFDOUI7Ozs7Ozs7O0NBUUMsR0FDTSxNQUFNQSx3QkFBd0IsU0FBQ0M7UUFBTUMsMEVBQVM7SUFDbkQsSUFBSSxDQUFDRCxRQUFRLENBQUNBLEtBQUtFLE1BQU0sSUFBSSxPQUFPRixLQUFLRSxNQUFNLENBQUNDLEdBQUcsS0FBSyxZQUFZO1FBQ2xFQyxRQUFRQyxLQUFLLENBQUMsNEJBQW1DLE9BQVBKLFFBQU87UUFDakQsT0FBTztJQUNUO0lBRUEsTUFBTUssWUFBWSxFQUFFO0lBQ3BCLE1BQU1DLGFBQWEsQ0FBQztJQUNwQixNQUFNQyxnQkFBZ0IsQ0FBQztJQUN2QixNQUFNQyxnQkFBZ0IsQ0FBQztJQUN2QixNQUFNQyxTQUFTLEVBQUUsRUFBRSxrQkFBa0I7SUFDckMsTUFBTUMsWUFBWVgsS0FBS1csU0FBUztJQUVoQyxzRkFBc0Y7SUFFdEYsSUFBSyxJQUFJQyxJQUFJLEdBQUdBLElBQUlELFdBQVdDLElBQUs7UUFDbEMsSUFBSTtZQUNGLE1BQU1DLFFBQVFiLEtBQUtFLE1BQU0sQ0FBQ0MsR0FBRyxDQUFDUztZQUU5Qix3Q0FBd0M7WUFDeEMsSUFBSSxDQUFDQyxTQUFTQSxNQUFNQyxJQUFJLEtBQUssV0FBVztnQkFDdEM7WUFDRjtZQUVBLHNCQUFzQjtZQUN0QixNQUFNQyxZQUFZO2dCQUNoQkMsSUFBSUgsTUFBTUksS0FBSztnQkFDZkgsTUFBTUQsTUFBTUMsSUFBSSxJQUFJLFNBQXFCLE9BQVpELE1BQU1JLEtBQUs7Z0JBQ3hDQyxTQUFTTCxNQUFNSyxPQUFPLElBQUk7Z0JBQzFCQyxVQUFVTixNQUFNTSxRQUFRLElBQUksRUFBRTtnQkFDOUJDLGNBQWNDLEtBQUtDLEtBQUssQ0FBQ1QsTUFBTU8sWUFBWSxLQUFLO1lBQ2xEO1lBRUFkLFVBQVVpQixJQUFJLENBQUNSO1lBRWYsK0NBQStDO1lBQy9DUixVQUFVLENBQUNRLFVBQVVDLEVBQUUsQ0FBQyxHQUFHRCxVQUFVRCxJQUFJO1lBQ3pDLElBQUlDLFVBQVVHLE9BQU8sRUFBRTtnQkFDckJWLGFBQWEsQ0FBQ08sVUFBVUMsRUFBRSxDQUFDLEdBQUcsS0FBbUUsT0FBOURELFVBQVVHLE9BQU8sQ0FBQ00sUUFBUSxDQUFDLElBQUlDLFdBQVcsR0FBR0MsUUFBUSxDQUFDLEdBQUc7WUFDOUY7WUFDQWpCLGFBQWEsQ0FBQ00sVUFBVUMsRUFBRSxDQUFDLEdBQUdELFVBQVVLLFlBQVk7UUFFdEQsRUFBRSxPQUFPTyxZQUFZO1lBQ25CLDhDQUE4QztZQUM5Q3ZCLFFBQVF3QixJQUFJLENBQUMsNEJBQW9FaEIsT0FBeENYLFFBQU8sbUNBQW1DLE9BQUZXLEdBQUUsTUFBSWU7WUFDdkZqQixPQUFPYSxJQUFJLENBQUM7Z0JBQUVOLE9BQU9MO2dCQUFHaUIsU0FBU0YsV0FBV0UsT0FBTztZQUFDLElBQUksbUJBQW1CO1FBQzdFO0lBQ0Y7SUFFQSx5R0FBeUc7SUFFekcsT0FBTztRQUNMdkIsV0FBV0E7UUFDWHdCLE9BQU92QjtRQUNQWSxVQUFVWDtRQUNWQyxlQUFlQTtRQUNmQyxRQUFRQSxPQUFPLG9CQUFvQjtJQUNyQztBQUNGLEVBQUU7QUFDRixvQ0FBb0M7QUFFcEM7Ozs7O0NBS0MsR0FDTSxNQUFNcUIsdUJBQXVCLENBQUMvQixNQUFNZ0M7SUFDekMsSUFBSSxDQUFDaEMsUUFBUSxPQUFPQSxLQUFLaUMsV0FBVyxLQUFLLGNBQWMsQ0FBQ0QsUUFBUSxPQUFPQSxTQUFTLFVBQVU7UUFDeEYsT0FBTztJQUNUO0lBRUEsSUFBSTtRQUNGLE1BQU1uQixRQUFRYixLQUFLaUMsV0FBVyxDQUFDRDtRQUMvQixPQUFPbkIsUUFBUUEsTUFBTUMsSUFBSSxHQUFHO0lBQzlCLEVBQUUsT0FBT1QsT0FBTztRQUNkLHdFQUF3RTtRQUN4RSxPQUFPO0lBQ1Q7QUFDRixFQUFFO0FBRUY7Ozs7Q0FJQyxHQUNNLE1BQU02QixvQkFBb0IsQ0FBQ0Y7SUFDaEMsSUFBSSxDQUFDQSxRQUFRLE9BQU9BLFNBQVMsWUFBWSxDQUFDQSxLQUFLRyxNQUFNLEVBQUU7UUFDckQsT0FBTztJQUNUO0lBRUEsb0RBQW9EO0lBQ3BELE1BQU1DLGFBQWE7UUFDakIsS0FBSztRQUFpQixLQUFLO1FBQWlCLEtBQUs7UUFBaUIsS0FBSztRQUN2RSxLQUFLO1FBQWlCLEtBQUs7UUFBaUIsS0FBSztRQUFpQixLQUFLO1FBQ3ZFLEtBQUs7UUFBaUIsS0FBSztRQUFpQixLQUFLO1FBQWlCLEtBQUs7UUFDdkUsS0FBSztRQUFpQixLQUFLO1FBQWlCLEtBQUs7UUFBaUIsS0FBSztRQUN2RSxLQUFLO1FBQWlCLEtBQUs7UUFBaUIsS0FBSztRQUFpQixLQUFLO1FBQ3ZFLEtBQUs7UUFBaUIsS0FBSztRQUFpQixLQUFLO1FBQWlCLEtBQUs7UUFDdkUsS0FBSztRQUFpQixLQUFLO1FBQzNCLEtBQUs7UUFBaUIsS0FBSztRQUFpQixLQUFLO1FBQWlCLEtBQUs7UUFDdkUsS0FBSztRQUFpQixLQUFLO1FBQWlCLEtBQUs7UUFBaUIsS0FBSztRQUN2RSxLQUFLO1FBQWlCLEtBQUs7UUFBaUIsS0FBSztRQUFpQixLQUFLO1FBQ3ZFLEtBQUs7UUFBaUIsS0FBSztRQUFpQixLQUFLO1FBQWlCLEtBQUs7UUFDdkUsS0FBSztRQUFpQixLQUFLO1FBQWlCLEtBQUs7UUFBaUIsS0FBSztRQUN2RSxLQUFLO1FBQWlCLEtBQUs7UUFBaUIsS0FBSztRQUFpQixLQUFLO1FBQ3ZFLEtBQUs7UUFBaUIsS0FBSztRQUMzQixLQUFLO1FBQVEsS0FBSztRQUFPLEtBQUs7UUFBTyxLQUFLO1FBQVMsS0FBSztRQUN4RCxLQUFLO1FBQVEsS0FBSztRQUFPLEtBQUs7UUFBUyxLQUFLO1FBQVMsS0FBSztRQUMxRCxLQUFLO1FBQVUsS0FBSztRQUFTLEtBQUs7UUFBUyxLQUFLO1FBQWEsS0FBSztRQUFVLEtBQUs7UUFDakYsS0FBSztRQUFlLEtBQUs7UUFBWSxLQUFLO1FBQWtCLEtBQUs7UUFDakUsS0FBSztRQUFvQixLQUFLO1FBQXFCLEtBQUs7UUFBZ0IsS0FBSztRQUM3RSxLQUFLO1FBQWMsS0FBSztRQUFlLEtBQUs7UUFBUyxNQUFNO1FBQWEsS0FBSztRQUM3RSxLQUFLO1FBQVcsS0FBSztRQUFlLEtBQUs7UUFBZSxLQUFLO1FBQVcsS0FBSztRQUM3RSxLQUFLO1FBQWEsS0FBSztRQUFZLEtBQUs7UUFBUSxLQUFLO1FBQVUsS0FBSztRQUFhLEtBQUs7UUFDdEYsS0FBSztRQUFTLEtBQUs7UUFBZ0IsS0FBSztRQUFVLEtBQUs7UUFBYSxRQUFLO1FBQ3pFLFFBQUs7UUFBWSxRQUFLO1FBQWEsUUFBSztRQUFjLEtBQUs7UUFBYSxRQUFLO1FBQzdFLFFBQUs7UUFBYyxRQUFLO1FBQVksUUFBSztRQUFVLEtBQUs7UUFBYSxLQUFLO1FBQzFFLEtBQUs7SUFDUDtJQUVBLG1DQUFtQztJQUNuQyxNQUFNQyxnQkFBZ0I7UUFDcEIsS0FBSztRQUFpQixLQUFLO1FBQWlCLEtBQUs7UUFBaUIsS0FBSztRQUN2RSxLQUFLO1FBQWlCLEtBQUs7UUFBaUIsS0FBSztRQUFpQixLQUFLO1FBQ3ZFLEtBQUs7UUFBaUIsS0FBSztRQUFpQixLQUFLO1FBQWlCLEtBQUs7UUFDdkUsS0FBSztRQUFpQixLQUFLO1FBQWlCLEtBQUs7UUFBaUIsS0FBSztRQUN2RSxLQUFLO1FBQWlCLEtBQUs7UUFBaUIsS0FBSztRQUFpQixLQUFLO1FBQ3ZFLEtBQUs7UUFBaUIsS0FBSztRQUFpQixLQUFLO1FBQWlCLEtBQUs7UUFDdkUsS0FBSztRQUFpQixLQUFLO1FBQWlCLEtBQUs7UUFBaUIsS0FBSztRQUN2RSxLQUFLO1FBQWlCLEtBQUs7UUFBaUIsS0FBSztRQUFpQixLQUFLO1FBQ3ZFLEtBQUs7UUFDTCxLQUFLO1FBQWdCLEtBQUs7UUFBZ0IsS0FBSztRQUFnQixLQUFLO1FBQ3BFLEtBQUs7UUFBZ0IsS0FBSztRQUFnQixLQUFLO1FBQWdCLEtBQUs7UUFDcEUsS0FBSztRQUFnQixLQUFLO1FBQWdCLEtBQUs7UUFBZ0IsS0FBSztRQUNwRSxLQUFLO1FBQWdCLEtBQUs7UUFBZ0IsS0FBSztRQUFnQixLQUFLO1FBQ3BFLEtBQUs7UUFBZ0IsS0FBSztRQUFnQixLQUFLO1FBQWdCLEtBQUs7UUFDcEUsS0FBSztRQUFnQixLQUFLO1FBQWdCLEtBQUs7UUFBZ0IsS0FBSztRQUNwRSxLQUFLO1FBQWdCLEtBQUs7UUFBZ0IsS0FBSztRQUFnQixLQUFLO1FBQ3BFLEtBQUs7UUFBZ0IsS0FBSztRQUFnQixLQUFLO1FBQWdCLEtBQUs7UUFDcEUsS0FBSztJQUNQO0lBRUEsK0JBQStCO0lBQy9CLElBQUlELFVBQVUsQ0FBQ0osS0FBSyxFQUFFLE9BQU9JLFVBQVUsQ0FBQ0osS0FBSztJQUM3QyxJQUFJSyxhQUFhLENBQUNMLEtBQUssRUFBRSxPQUFPSyxhQUFhLENBQUNMLEtBQUs7SUFFbkQsd0VBQXdFO0lBQ3hFLElBQUk7UUFDRixNQUFNTSxPQUFPTixLQUFLTyxXQUFXLENBQUM7UUFDOUIsSUFBSUMsTUFBTUYsT0FBTyxPQUFPO1FBRXhCLElBQUlBLFFBQVEsVUFBVUEsUUFBUSxRQUFRLE9BQU87UUFDN0MsSUFBSUEsUUFBUSxVQUFVQSxRQUFRLFFBQVEsT0FBTztRQUM3QyxJQUFJQSxRQUFRLFdBQVdBLFFBQVEsU0FBUyxPQUFPO1FBQy9DLElBQUlBLFFBQVEsV0FBV0EsUUFBUSxTQUFTLE9BQU87UUFDL0MsSUFBSUEsUUFBUSxXQUFXQSxRQUFRLFNBQVMsT0FBTztRQUMvQyxJQUFJQSxRQUFRLFdBQVdBLFFBQVEsU0FBUyxPQUFPO0lBQy9DLHlDQUF5QztJQUUzQyxFQUFFLE9BQU9qQyxPQUFPO1FBQ2QsaUVBQWlFO1FBQ2pFLE9BQU87SUFDVDtJQUVBLDJEQUEyRDtJQUMzRCxPQUFPO0FBQ1QsRUFBRTtBQUVGOzs7O0NBSUMsR0FDTSxNQUFNb0MsdUJBQXVCLENBQUN6QztJQUNuQyxJQUFJLENBQUNBLFFBQVEsQ0FBQ0EsS0FBS0UsTUFBTSxJQUFJLE9BQU9GLEtBQUtFLE1BQU0sQ0FBQ0MsR0FBRyxLQUFLLGNBQWMsT0FBT0gsS0FBS1csU0FBUyxLQUFLLFVBQVU7UUFDeEcsT0FBTyxFQUFFO0lBQ1g7SUFFQSxJQUFJO1FBQ0YsTUFBTVQsU0FBUyxFQUFFO1FBQ2pCLE1BQU1TLFlBQVlYLEtBQUtXLFNBQVM7UUFFaEMsSUFBSyxJQUFJQyxJQUFJLEdBQUdBLElBQUlELFdBQVdDLElBQUs7WUFDbEMsTUFBTUMsUUFBUWIsS0FBS0UsTUFBTSxDQUFDQyxHQUFHLENBQUNTO1lBRTlCLHlDQUF5QztZQUN6QyxJQUFJLENBQUNDLFNBQVNBLE1BQU1DLElBQUksS0FBSyxhQUFhLENBQUNELE1BQU1LLE9BQU8sRUFBRTtZQUUxRCxrRUFBa0U7WUFDbEUsb0NBQW9DO1lBQ3BDLE1BQU13QixXQUFXN0IsTUFBTUssT0FBTztZQUM5QixNQUFNYyxPQUFPVyxPQUFPQyxhQUFhLENBQUNGO1lBRWxDLGlEQUFpRDtZQUNqRCxJQUFJLENBQUN4QyxPQUFPMkMsSUFBSSxDQUFDQyxDQUFBQSxJQUFLQSxFQUFFQyxTQUFTLEtBQUtmLE9BQU87Z0JBQzFDOUIsT0FBT3FCLElBQUksQ0FBQztvQkFDVndCLFdBQVdmO29CQUNYZCxTQUFTOEIsZUFBZWhCO29CQUN4QmxCLE1BQU1ELE1BQU1DLElBQUksSUFBSTtvQkFDcEJHLE9BQU9MLEVBQUUseUJBQXlCO2dCQUNwQztZQUNIO1FBQ0Y7UUFFQSx1Q0FBdUM7UUFDdkNWLE9BQU8rQyxJQUFJLENBQUMsQ0FBQ0MsR0FBR0MsSUFBTUQsRUFBRWhDLE9BQU8sQ0FBQ2tDLGFBQWEsQ0FBQ0QsRUFBRWpDLE9BQU87UUFFdkQsT0FBT2hCO0lBQ1QsRUFBRSxPQUFPRyxPQUFPO1FBQ2RELFFBQVFDLEtBQUssQ0FBQyx1Q0FBdUNBO1FBQ3JELE9BQU8sRUFBRTtJQUNYO0FBQ0YsRUFBRTtBQUVGOzs7Ozs7O0NBT0MsR0FDTSxNQUFNZ0QsdUJBQXVCLENBQUNyRCxNQUFNZ0M7SUFDekMsSUFBSSxDQUFDaEMsUUFBUSxDQUFDZ0MsUUFBUSxDQUFDaEMsS0FBS3NELE1BQU0sSUFBSSxDQUFDdEQsS0FBS3NELE1BQU0sQ0FBQ0MsSUFBSSxJQUFJLENBQUN2RCxLQUFLRSxNQUFNLEVBQUUsT0FBTyxFQUFFO0lBRWxGLElBQUk7UUFDRixNQUFNc0QsZUFBZSxFQUFFO1FBQ3ZCLE1BQU1DLFlBQVl6RCxLQUFLaUMsV0FBVyxDQUFDRDtRQUNuQyxJQUFJLENBQUN5QixhQUFhLENBQUNBLFVBQVV4QyxLQUFLLEVBQUUsT0FBTyxFQUFFO1FBRTdDLE1BQU15QyxpQkFBaUJELFVBQVV4QyxLQUFLO1FBQ3RDLE1BQU1zQyxPQUFPdkQsS0FBS3NELE1BQU0sQ0FBQ0MsSUFBSTtRQUU3Qix5RUFBeUU7UUFDekUsSUFBSUEsS0FBS0ksT0FBTyxFQUFFO1lBQ2QsS0FBSyxNQUFNQyxVQUFVTCxLQUFLSSxPQUFPLENBQUU7Z0JBQy9CLGdEQUFnRDtnQkFDaEQsSUFBSUMsT0FBT0MsVUFBVSxLQUFLLEdBQUc7b0JBQ3pCLEtBQUssTUFBTUMsWUFBWUYsT0FBT0csU0FBUyxDQUFFO3dCQUNyQyxJQUFJRCxTQUFTRSxRQUFRLElBQUlGLFNBQVNFLFFBQVEsQ0FBQzlELE1BQU0sRUFBRTs0QkFDL0MsTUFBTStELGdCQUFnQkgsU0FBU0UsUUFBUSxDQUFDOUQsTUFBTSxDQUFDZ0UsT0FBTyxDQUFDUjs0QkFDdkQsSUFBSU8sa0JBQWtCLENBQUMsS0FBS0gsU0FBU0ssYUFBYSxJQUFJTCxTQUFTSyxhQUFhLENBQUNGLGNBQWMsRUFBRTtnQ0FDekYsTUFBTUcsbUJBQW1CTixTQUFTSyxhQUFhLENBQUNGLGNBQWM7Z0NBQzlERyxpQkFBaUJDLE9BQU8sQ0FBQ0MsQ0FBQUE7b0NBQ3JCLE1BQU1DLFdBQVd2RSxLQUFLRSxNQUFNLENBQUNDLEdBQUcsQ0FBQ21FO29DQUNqQyxJQUFJQyxVQUFVO3dDQUNUZixhQUFhakMsSUFBSSxDQUFDOzRDQUNoQlQsTUFBTXlELFNBQVN6RCxJQUFJLElBQUk7NENBQ3ZCSSxTQUFTcUQsU0FBU3JELE9BQU8sR0FBRzhCLGVBQWVMLE9BQU9DLGFBQWEsQ0FBQzJCLFNBQVNyRCxPQUFPLEtBQUs7NENBQ3JGRCxPQUFPcUQ7d0NBQ1Q7b0NBQ0w7Z0NBQ0o7NEJBQ0o7d0JBQ0o7b0JBQ0o7Z0JBQ0o7WUFDQyxtRUFBbUU7WUFDeEU7UUFDSjtRQUVBLG1EQUFtRDtRQUNuRCxNQUFNRSxxQkFBcUJoQixhQUFhaUIsTUFBTSxDQUFDLENBQUNDLEtBQUt6RCxPQUFPMEQsT0FDeERELElBQUl6RCxLQUFLLEtBQUt5QyxrQkFDZHpDLFVBQVUwRCxLQUFLQyxTQUFTLENBQUMsQ0FBQ0MsSUFBTUEsRUFBRTVELEtBQUssS0FBS3lELElBQUl6RCxLQUFLO1FBR3pELE9BQU91RDtJQUNULEVBQUUsT0FBT25FLE9BQU87UUFDZEQsUUFBUUMsS0FBSyxDQUFDLHFDQUFxQ0E7UUFDbkQsT0FBTyxFQUFFO0lBQ1g7QUFDRixFQUFFO0FBRUY7Ozs7Ozs7Q0FPQyxHQUNNLE1BQU15RSxlQUFlLENBQUM5RSxNQUFNK0U7SUFDakMsSUFBSSxDQUFDL0UsUUFBUSxDQUFDK0UsU0FBU0EsTUFBTTVDLE1BQU0sR0FBRyxLQUFLLENBQUNuQyxLQUFLc0QsTUFBTSxJQUFJLENBQUN0RCxLQUFLc0QsTUFBTSxDQUFDQyxJQUFJLEVBQUUsT0FBTyxFQUFFO0lBRXZGLElBQUk7UUFDRixNQUFNeUIsWUFBWSxFQUFFO1FBQ3BCLGlDQUFpQztRQUVqQyxpRkFBaUY7UUFDakYseUZBQXlGO1FBRXpGLGlGQUFpRjtRQUNqRixNQUFNQyxrQkFBa0I7WUFDdEIsTUFBTTtZQUNOLE1BQU07WUFDTixNQUFNO1lBQ04sT0FBTztZQUNQLE9BQU87UUFDVDtRQUVBLElBQUlBLGVBQWUsQ0FBQ0YsTUFBTSxFQUFFO1lBQ3hCLE1BQU1HLFVBQVVELGVBQWUsQ0FBQ0YsTUFBTTtZQUN0Q0MsVUFBVXpELElBQUksQ0FBQztnQkFDWDRELFVBQVVKO2dCQUNWSyxVQUFVRjtnQkFDVmhFLFNBQVM4QixlQUFla0M7WUFDNUI7UUFDSjtRQUVBLE9BQU9GO0lBQ1QsRUFBRSxPQUFPM0UsT0FBTztRQUNkRCxRQUFRQyxLQUFLLENBQUMsNEJBQTRCQTtRQUMxQyxPQUFPLEVBQUU7SUFDWDtBQUNGLEVBQUU7QUFFRix1RUFBdUU7QUFDdkU7Ozs7Q0FJQyxHQUNNLE1BQU0yQyxpQkFBaUIsQ0FBQ2hCO0lBQzdCLElBQUksQ0FBQ0EsUUFBUSxPQUFPQSxTQUFTLFlBQVksQ0FBQ0EsS0FBS0csTUFBTSxFQUFFO1FBQ3JELE9BQU87SUFDVDtJQUVBLElBQUk7UUFDRixNQUFNa0QsWUFBWXJELEtBQUtPLFdBQVcsQ0FBQztRQUNuQywwQ0FBMEM7UUFDMUMsSUFBSUMsTUFBTTZDLFlBQVk7WUFDbEIsT0FBTztRQUNYO1FBQ0EsT0FBTyxLQUEyRCxPQUF0REEsVUFBVTdELFFBQVEsQ0FBQyxJQUFJQyxXQUFXLEdBQUdDLFFBQVEsQ0FBQyxHQUFHO0lBQy9ELEVBQUUsT0FBT3JCLE9BQU87UUFDZCxPQUFPO0lBQ1Q7QUFDRixFQUFFIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL3V0aWxzL2dseXBoVXRpbHMuanM/MDkwNCJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyDQpNGD0L3QutGG0LjQuCDQtNC70Y8g0YDQsNCx0L7RgtGLINGBINCz0LvQuNGE0LDQvNC4LCDQu9C40LPQsNGC0YPRgNCw0LzQuCwg0LDQu9GM0YLQtdGA0L3QsNGC0LjQstC90YvQvNC4INGB0LjQvNCy0L7Qu9Cw0LzQuCDRiNGA0LjRhNGC0LBcbi8vIGltcG9ydCB7IGdldENoYXJVbmljb2RlIH0gZnJvbSAnLi9mb250VXRpbHNDb21tb24nOyAvLyDQo9C00LDQu9GP0LXQvCDRjdGC0L7RgiDQu9C40YjQvdC40Lkg0LjQvNC/0L7RgNGCXG5cbi8vINCS0YHQv9C+0LzQvtCz0LDRgtC10LvRjNC90YvQtSDRhNGD0L3QutGG0LjQuCDQtNC70Y8g0YDQsNCx0L7RgtGLINGBINCz0LvQuNGE0LDQvNC4INC4INGB0YLRgNGD0LrRgtGD0YDQsNC80Lggb3BlbnR5cGUuanNcblxuLy8gLS0tINCd0J7QktCQ0K8g0J7QkdCp0JDQryDQpNCj0J3QmtCm0JjQryAtLS1cbi8qKlxuICog0JjQt9Cy0LvQtdC60LDQtdGCINCx0LDQt9C+0LLRi9C1INC00LDQvdC90YvQtSDQs9C70LjRhNC+0LIg0LjQtyDQvtCx0YrQtdC60YLQsCDRiNGA0LjRhNGC0LAgb3BlbnR5cGUuanNcbiAqINCt0YLQsCDRhNGD0L3QutGG0LjRjyDQsdGD0LTQtdGCINC40YHQv9C+0LvRjNC30L7QstCw0YLRjNGB0Y8g0LrQsNC6INCyINC+0YHQvdC+0LLQvdC+0Lwg0L/QvtGC0L7QutC1IChmYWxsYmFjayksINGC0LDQuiDQuCDQsiDQstC10LEt0LLQvtGA0LrQtdGA0LUuXG4gKiBcbiAqIEBwYXJhbSB7b2JqZWN0fSBmb250IC0g0KDQsNGB0L/QsNGA0YHQtdC90L3Ri9C5INC+0LHRitC10LrRgiDRiNGA0LjRhNGC0LAgb3BlbnR5cGUuanNcbiAqIEBwYXJhbSB7c3RyaW5nfSBbc291cmNlPSd1bmtub3duJ10gLSDQmNGB0YLQvtGH0L3QuNC6INCy0YvQt9C+0LLQsCAoJ3dvcmtlcicg0LjQu9C4ICdtYWluJykg0LTQu9GPINC70L7Qs9C40YDQvtCy0LDQvdC40Y9cbiAqIEByZXR1cm5zIHtvYmplY3R8bnVsbH0gLSDQntCx0YrQtdC60YIg0YEg0LTQsNC90L3Ri9C80Lgg0LPQu9C40YTQvtCyOiB7IGFsbEdseXBoczogQXJyYXksIG5hbWVzOiBPYmplY3QsIHVuaWNvZGVzOiBPYmplY3QsIGFkdmFuY2VXaWR0aHM6IE9iamVjdCwgZXJyb3JzOiBBcnJheSB9XG4gKiAgICAgICAgICAgICAgICAgICDQuNC70LggbnVsbCDQsiDRgdC70YPRh9Cw0LUg0L7RiNC40LHQutC4LlxuICovXG5leHBvcnQgY29uc3QgZXh0cmFjdEJhc2ljR2x5cGhEYXRhID0gKGZvbnQsIHNvdXJjZSA9ICd1bmtub3duJykgPT4ge1xuICBpZiAoIWZvbnQgfHwgIWZvbnQuZ2x5cGhzIHx8IHR5cGVvZiBmb250LmdseXBocy5nZXQgIT09ICdmdW5jdGlvbicpIHtcbiAgICBjb25zb2xlLmVycm9yKGBbZXh0cmFjdEJhc2ljR2x5cGhEYXRhIC0gJHtzb3VyY2V9XSBJbnZhbGlkIGZvbnQgb2JqZWN0IHByb3ZpZGVkLmApO1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgY29uc3QgYWxsR2x5cGhzID0gW107XG4gIGNvbnN0IGdseXBoTmFtZXMgPSB7fTtcbiAgY29uc3QgZ2x5cGhVbmljb2RlcyA9IHt9O1xuICBjb25zdCBhZHZhbmNlV2lkdGhzID0ge307XG4gIGNvbnN0IGVycm9ycyA9IFtdOyAvLyDQodC+0LHQuNGA0LDQtdC8INC+0YjQuNCx0LrQuFxuICBjb25zdCBudW1HbHlwaHMgPSBmb250Lm51bUdseXBocztcblxuICAvLyBjb25zb2xlLmxvZyhgW2V4dHJhY3RCYXNpY0dseXBoRGF0YSAtICR7c291cmNlfV0gUHJvY2Vzc2luZyAke251bUdseXBoc30gZ2x5cGhzLmApO1xuXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbnVtR2x5cGhzOyBpKyspIHtcbiAgICB0cnkge1xuICAgICAgY29uc3QgZ2x5cGggPSBmb250LmdseXBocy5nZXQoaSk7XG5cbiAgICAgIC8vINCf0YDQvtC/0YPRgdC60LDQtdC8INC90LXQstCw0LvQuNC00L3Ri9C1INCz0LvQuNGE0Ysg0LggLm5vdGRlZlxuICAgICAgaWYgKCFnbHlwaCB8fCBnbHlwaC5uYW1lID09PSAnLm5vdGRlZicpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIC8vINCe0YHQvdC+0LLQvdCw0Y8g0LjQvdGE0L7RgNC80LDRhtC40Y9cbiAgICAgIGNvbnN0IGdseXBoSW5mbyA9IHtcbiAgICAgICAgaWQ6IGdseXBoLmluZGV4LCBcbiAgICAgICAgbmFtZTogZ2x5cGgubmFtZSB8fCBgZ2x5cGhfJHtnbHlwaC5pbmRleH1gLFxuICAgICAgICB1bmljb2RlOiBnbHlwaC51bmljb2RlIHx8IG51bGwsXG4gICAgICAgIHVuaWNvZGVzOiBnbHlwaC51bmljb2RlcyB8fCBbXSxcbiAgICAgICAgYWR2YW5jZVdpZHRoOiBNYXRoLnJvdW5kKGdseXBoLmFkdmFuY2VXaWR0aCkgfHwgMCxcbiAgICAgIH07XG5cbiAgICAgIGFsbEdseXBocy5wdXNoKGdseXBoSW5mbyk7XG5cbiAgICAgIC8vINCh0L7RhdGA0LDQvdGP0LXQvCDQuNC80Y8g0LggVW5pY29kZSDQtNC70Y8g0LHRi9GB0YLRgNC+0LPQviDQtNC+0YHRgtGD0L/QsFxuICAgICAgZ2x5cGhOYW1lc1tnbHlwaEluZm8uaWRdID0gZ2x5cGhJbmZvLm5hbWU7XG4gICAgICBpZiAoZ2x5cGhJbmZvLnVuaWNvZGUpIHtcbiAgICAgICAgZ2x5cGhVbmljb2Rlc1tnbHlwaEluZm8uaWRdID0gYFUrJHtnbHlwaEluZm8udW5pY29kZS50b1N0cmluZygxNikudG9VcHBlckNhc2UoKS5wYWRTdGFydCg0LCAnMCcpfWA7XG4gICAgICB9XG4gICAgICBhZHZhbmNlV2lkdGhzW2dseXBoSW5mby5pZF0gPSBnbHlwaEluZm8uYWR2YW5jZVdpZHRoO1xuXG4gICAgfSBjYXRjaCAoZ2x5cGhFcnJvcikge1xuICAgICAgLy8g0JvQvtCz0LjRgNGD0LXQvCDQvtGI0LjQsdC60YMg0L7QsdGA0LDQsdC+0YLQutC4INC60L7QvdC60YDQtdGC0L3QvtCz0L4g0LPQu9C40YTQsFxuICAgICAgY29uc29sZS53YXJuKGBbZXh0cmFjdEJhc2ljR2x5cGhEYXRhIC0gJHtzb3VyY2V9XSBFcnJvciBwcm9jZXNzaW5nIGdseXBoIGluZGV4ICR7aX06YCwgZ2x5cGhFcnJvcik7XG4gICAgICBlcnJvcnMucHVzaCh7IGluZGV4OiBpLCBtZXNzYWdlOiBnbHlwaEVycm9yLm1lc3NhZ2UgfSk7IC8vINCh0L7RhdGA0LDQvdGP0LXQvCDQvtGI0LjQsdC60YNcbiAgICB9XG4gIH1cblxuICAvLyBjb25zb2xlLmxvZyhgW2V4dHJhY3RCYXNpY0dseXBoRGF0YSAtICR7c291cmNlfV0gU3VjY2Vzc2Z1bGx5IGV4dHJhY3RlZCAke2FsbEdseXBocy5sZW5ndGh9IGdseXBocy5gKTtcblxuICByZXR1cm4ge1xuICAgIGFsbEdseXBoczogYWxsR2x5cGhzLFxuICAgIG5hbWVzOiBnbHlwaE5hbWVzLFxuICAgIHVuaWNvZGVzOiBnbHlwaFVuaWNvZGVzLFxuICAgIGFkdmFuY2VXaWR0aHM6IGFkdmFuY2VXaWR0aHMsXG4gICAgZXJyb3JzOiBlcnJvcnMgLy8g0JLQvtC30LLRgNCw0YnQsNC10Lwg0L7RiNC40LHQutC4XG4gIH07XG59O1xuLy8gLS0tINCa0J7QndCV0KYg0J3QntCS0J7QmSDQntCR0KnQldCZINCk0KPQndCa0KbQmNCYIC0tLVxuXG4vKipcbiAqINCf0L7Qu9GD0YfQsNC10YIg0LjQvNGPINCz0LvQuNGE0LAg0LjQtyDRiNGA0LjRhNGC0LAg0YEg0L/QvtC80L7RidGM0Y4gb3BlbnR5cGUuanNcbiAqIEBwYXJhbSB7T2JqZWN0fSBmb250IC0g0J7QsdGK0LXQutGCINGI0YDQuNGE0YLQsCDQuNC3IG9wZW50eXBlLmpzXG4gKiBAcGFyYW0ge3N0cmluZ30gY2hhciAtINCh0LjQvNCy0L7QuyDQtNC70Y8g0L/QvtC40YHQutCwINC40LzQtdC90Lgg0LPQu9C40YTQsFxuICogQHJldHVybnMge3N0cmluZ3xudWxsfSAtINCY0LzRjyDQs9C70LjRhNCwINC40Lcg0YjRgNC40YTRgtCwINC40LvQuCBudWxsLCDQtdGB0LvQuCDQvdC1INC90LDQudC00LXQvdC+INC40LvQuCDQvtGI0LjQsdC60LBcbiAqL1xuZXhwb3J0IGNvbnN0IGdldEdseXBoTmFtZUZyb21Gb250ID0gKGZvbnQsIGNoYXIpID0+IHtcbiAgaWYgKCFmb250IHx8IHR5cGVvZiBmb250LmNoYXJUb0dseXBoICE9PSAnZnVuY3Rpb24nIHx8ICFjaGFyIHx8IHR5cGVvZiBjaGFyICE9PSAnc3RyaW5nJykge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgdHJ5IHtcbiAgICBjb25zdCBnbHlwaCA9IGZvbnQuY2hhclRvR2x5cGgoY2hhcik7XG4gICAgcmV0dXJuIGdseXBoID8gZ2x5cGgubmFtZSA6IG51bGw7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgLy8gY29uc29sZS5lcnJvcihgRXJyb3IgZ2V0dGluZyBnbHlwaCBuYW1lIGZvciBjaGFyIFwiJHtjaGFyfVwiOmAsIGVycm9yKTtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxufTtcblxuLyoqXG4gKiDQn9C+0LvRg9GH0LDQtdGCINGD0L/RgNC+0YnQtdC90L3QvtC1INC90LDQt9Cy0LDQvdC40LUg0YHQuNC80LLQvtC70LBcbiAqIEBwYXJhbSB7c3RyaW5nfSBjaGFyIC0g0KHQuNC80LLQvtC7INC00LvRjyDQv9C+0LvRg9GH0LXQvdC40Y8g0L3QsNC30LLQsNC90LjRj1xuICogQHJldHVybnMge3N0cmluZ30gLSDQo9C/0YDQvtGJ0LXQvdC90L7QtSDQvdCw0LfQstCw0L3QuNC1INGB0LjQvNCy0L7Qu9CwXG4gKi9cbmV4cG9ydCBjb25zdCBnZXRTaW1wbGVDaGFyTmFtZSA9IChjaGFyKSA9PiB7XG4gIGlmICghY2hhciB8fCB0eXBlb2YgY2hhciAhPT0gJ3N0cmluZycgfHwgIWNoYXIubGVuZ3RoKSB7XG4gICAgcmV0dXJuICd1bmtub3duJztcbiAgfVxuXG4gIC8vINCY0YHQv9C+0LvRjNC30YPQtdC8INGB0L/QtdGG0LjQsNC70YzQvdGL0Lkg0YHQu9C+0LLQsNGA0Ywg0LTQu9GPINC70LDRgtC40L3RgdC60LjRhSDQsdGD0LrQslxuICBjb25zdCBsYXRpbk5hbWVzID0ge1xuICAgICdhJzogJ2EgKGxvd2VyY2FzZSknLCAnYic6ICdiIChsb3dlcmNhc2UpJywgJ2MnOiAnYyAobG93ZXJjYXNlKScsICdkJzogJ2QgKGxvd2VyY2FzZSknLFxuICAgICdlJzogJ2UgKGxvd2VyY2FzZSknLCAnZic6ICdmIChsb3dlcmNhc2UpJywgJ2cnOiAnZyAobG93ZXJjYXNlKScsICdoJzogJ2ggKGxvd2VyY2FzZSknLFxuICAgICdpJzogJ2kgKGxvd2VyY2FzZSknLCAnaic6ICdqIChsb3dlcmNhc2UpJywgJ2snOiAnayAobG93ZXJjYXNlKScsICdsJzogJ2wgKGxvd2VyY2FzZSknLFxuICAgICdtJzogJ20gKGxvd2VyY2FzZSknLCAnbic6ICduIChsb3dlcmNhc2UpJywgJ28nOiAnbyAobG93ZXJjYXNlKScsICdwJzogJ3AgKGxvd2VyY2FzZSknLFxuICAgICdxJzogJ3EgKGxvd2VyY2FzZSknLCAncic6ICdyIChsb3dlcmNhc2UpJywgJ3MnOiAncyAobG93ZXJjYXNlKScsICd0JzogJ3QgKGxvd2VyY2FzZSknLFxuICAgICd1JzogJ3UgKGxvd2VyY2FzZSknLCAndic6ICd2IChsb3dlcmNhc2UpJywgJ3cnOiAndyAobG93ZXJjYXNlKScsICd4JzogJ3ggKGxvd2VyY2FzZSknLFxuICAgICd5JzogJ3kgKGxvd2VyY2FzZSknLCAneic6ICd6IChsb3dlcmNhc2UpJyxcbiAgICAnQSc6ICdBICh1cHBlcmNhc2UpJywgJ0InOiAnQiAodXBwZXJjYXNlKScsICdDJzogJ0MgKHVwcGVyY2FzZSknLCAnRCc6ICdEICh1cHBlcmNhc2UpJyxcbiAgICAnRSc6ICdFICh1cHBlcmNhc2UpJywgJ0YnOiAnRiAodXBwZXJjYXNlKScsICdHJzogJ0cgKHVwcGVyY2FzZSknLCAnSCc6ICdIICh1cHBlcmNhc2UpJyxcbiAgICAnSSc6ICdJICh1cHBlcmNhc2UpJywgJ0onOiAnSiAodXBwZXJjYXNlKScsICdLJzogJ0sgKHVwcGVyY2FzZSknLCAnTCc6ICdMICh1cHBlcmNhc2UpJyxcbiAgICAnTSc6ICdNICh1cHBlcmNhc2UpJywgJ04nOiAnTiAodXBwZXJjYXNlKScsICdPJzogJ08gKHVwcGVyY2FzZSknLCAnUCc6ICdQICh1cHBlcmNhc2UpJyxcbiAgICAnUSc6ICdRICh1cHBlcmNhc2UpJywgJ1InOiAnUiAodXBwZXJjYXNlKScsICdTJzogJ1MgKHVwcGVyY2FzZSknLCAnVCc6ICdUICh1cHBlcmNhc2UpJyxcbiAgICAnVSc6ICdVICh1cHBlcmNhc2UpJywgJ1YnOiAnViAodXBwZXJjYXNlKScsICdXJzogJ1cgKHVwcGVyY2FzZSknLCAnWCc6ICdYICh1cHBlcmNhc2UpJyxcbiAgICAnWSc6ICdZICh1cHBlcmNhc2UpJywgJ1onOiAnWiAodXBwZXJjYXNlKScsXG4gICAgJzAnOiAnemVybycsICcxJzogJ29uZScsICcyJzogJ3R3bycsICczJzogJ3RocmVlJywgJzQnOiAnZm91cicsXG4gICAgJzUnOiAnZml2ZScsICc2JzogJ3NpeCcsICc3JzogJ3NldmVuJywgJzgnOiAnZWlnaHQnLCAnOSc6ICduaW5lJyxcbiAgICAnLic6ICdwZXJpb2QnLCAnLCc6ICdjb21tYScsICc6JzogJ2NvbG9uJywgJzsnOiAnc2VtaWNvbG9uJywgJy0nOiAnaHlwaGVuJywgJ18nOiAndW5kZXJzY29yZScsXG4gICAgJyEnOiAnZXhjbGFtYXRpb24nLCAnPyc6ICdxdWVzdGlvbicsICdcIic6ICdxdW90YXRpb24gbWFyaycsIFwiJ1wiOiAnYXBvc3Ryb3BoZScsXG4gICAgJygnOiAnbGVmdCBwYXJlbnRoZXNpcycsICcpJzogJ3JpZ2h0IHBhcmVudGhlc2lzJywgJ1snOiAnbGVmdCBicmFja2V0JywgJ10nOiAncmlnaHQgYnJhY2tldCcsXG4gICAgJ3snOiAnbGVmdCBicmFjZScsICd9JzogJ3JpZ2h0IGJyYWNlJywgJy8nOiAnc2xhc2gnLCAnXFxcXCc6ICdiYWNrc2xhc2gnLCAnfCc6ICd2ZXJ0aWNhbCBiYXInLFxuICAgICdAJzogJ2F0IHNpZ24nLCAnIyc6ICdudW1iZXIgc2lnbicsICckJzogJ2RvbGxhciBzaWduJywgJyUnOiAncGVyY2VudCcsICdeJzogJ2NhcmV0JyxcbiAgICAnJic6ICdhbXBlcnNhbmQnLCAnKic6ICdhc3RlcmlzaycsICcrJzogJ3BsdXMnLCAnPSc6ICdlcXVhbHMnLCAnPCc6ICdsZXNzIHRoYW4nLCAnPic6ICdncmVhdGVyIHRoYW4nLFxuICAgICd+JzogJ3RpbGRlJywgJ2AnOiAnZ3JhdmUgYWNjZW50JywgJ+KElic6ICdudW1lcm8nLCAn4oKsJzogJ2V1cm8gc2lnbicsICfCoyc6ICdwb3VuZCBzaWduJyxcbiAgICAnwqUnOiAneWVuIHNpZ24nLCAnwqknOiAnY29weXJpZ2h0JywgJ8KuJzogJ3JlZ2lzdGVyZWQnLCAn4oSiJzogJ3RyYWRlbWFyaycsICfCsCc6ICdkZWdyZWUnLFxuICAgICfCsSc6ICdwbHVzLW1pbnVzJywgJ8OXJzogJ211bHRpcGx5JywgJ8O3JzogJ2RpdmlkZScsICfiiaAnOiAnbm90IGVxdWFsJywgJ+KJiCc6ICdhcHByb3hpbWF0ZWx5IGVxdWFsJyxcbiAgICAnICc6ICdzcGFjZSdcbiAgfTtcblxuICAvLyDQmNGB0L/QvtC70YzQt9GD0LXQvCDRgdC70L7QstCw0YDRjCDQtNC70Y8g0LrQuNGA0LjQu9C70LjRhtGLXG4gIGNvbnN0IGN5cmlsbGljTmFtZXMgPSB7XG4gICAgJ9CQJzogJ9CQICjQt9Cw0LPQu9Cw0LLQvdCw0Y8pJywgJ9CRJzogJ9CRICjQt9Cw0LPQu9Cw0LLQvdCw0Y8pJywgJ9CSJzogJ9CSICjQt9Cw0LPQu9Cw0LLQvdCw0Y8pJywgJ9CTJzogJ9CTICjQt9Cw0LPQu9Cw0LLQvdCw0Y8pJyxcbiAgICAn0JQnOiAn0JQgKNC30LDQs9C70LDQstC90LDRjyknLCAn0JUnOiAn0JUgKNC30LDQs9C70LDQstC90LDRjyknLCAn0IEnOiAn0IEgKNC30LDQs9C70LDQstC90LDRjyknLCAn0JYnOiAn0JYgKNC30LDQs9C70LDQstC90LDRjyknLFxuICAgICfQlyc6ICfQlyAo0LfQsNCz0LvQsNCy0L3QsNGPKScsICfQmCc6ICfQmCAo0LfQsNCz0LvQsNCy0L3QsNGPKScsICfQmSc6ICfQmSAo0LfQsNCz0LvQsNCy0L3QsNGPKScsICfQmic6ICfQmiAo0LfQsNCz0LvQsNCy0L3QsNGPKScsXG4gICAgJ9CbJzogJ9CbICjQt9Cw0LPQu9Cw0LLQvdCw0Y8pJywgJ9CcJzogJ9CcICjQt9Cw0LPQu9Cw0LLQvdCw0Y8pJywgJ9CdJzogJ9CdICjQt9Cw0LPQu9Cw0LLQvdCw0Y8pJywgJ9CeJzogJ9CeICjQt9Cw0LPQu9Cw0LLQvdCw0Y8pJyxcbiAgICAn0J8nOiAn0J8gKNC30LDQs9C70LDQstC90LDRjyknLCAn0KAnOiAn0KAgKNC30LDQs9C70LDQstC90LDRjyknLCAn0KEnOiAn0KEgKNC30LDQs9C70LDQstC90LDRjyknLCAn0KInOiAn0KIgKNC30LDQs9C70LDQstC90LDRjyknLFxuICAgICfQoyc6ICfQoyAo0LfQsNCz0LvQsNCy0L3QsNGPKScsICfQpCc6ICfQpCAo0LfQsNCz0LvQsNCy0L3QsNGPKScsICfQpSc6ICfQpSAo0LfQsNCz0LvQsNCy0L3QsNGPKScsICfQpic6ICfQpiAo0LfQsNCz0LvQsNCy0L3QsNGPKScsXG4gICAgJ9CnJzogJ9CnICjQt9Cw0LPQu9Cw0LLQvdCw0Y8pJywgJ9CoJzogJ9CoICjQt9Cw0LPQu9Cw0LLQvdCw0Y8pJywgJ9CpJzogJ9CpICjQt9Cw0LPQu9Cw0LLQvdCw0Y8pJywgJ9CqJzogJ9CqICjQt9Cw0LPQu9Cw0LLQvdCw0Y8pJyxcbiAgICAn0KsnOiAn0KsgKNC30LDQs9C70LDQstC90LDRjyknLCAn0KwnOiAn0KwgKNC30LDQs9C70LDQstC90LDRjyknLCAn0K0nOiAn0K0gKNC30LDQs9C70LDQstC90LDRjyknLCAn0K4nOiAn0K4gKNC30LDQs9C70LDQstC90LDRjyknLFxuICAgICfQryc6ICfQryAo0LfQsNCz0LvQsNCy0L3QsNGPKScsXG4gICAgJ9CwJzogJ9CwICjRgdGC0YDQvtGH0L3QsNGPKScsICfQsSc6ICfQsSAo0YHRgtGA0L7Rh9C90LDRjyknLCAn0LInOiAn0LIgKNGB0YLRgNC+0YfQvdCw0Y8pJywgJ9CzJzogJ9CzICjRgdGC0YDQvtGH0L3QsNGPKScsXG4gICAgJ9C0JzogJ9C0ICjRgdGC0YDQvtGH0L3QsNGPKScsICfQtSc6ICfQtSAo0YHRgtGA0L7Rh9C90LDRjyknLCAn0ZEnOiAn0ZEgKNGB0YLRgNC+0YfQvdCw0Y8pJywgJ9C2JzogJ9C2ICjRgdGC0YDQvtGH0L3QsNGPKScsXG4gICAgJ9C3JzogJ9C3ICjRgdGC0YDQvtGH0L3QsNGPKScsICfQuCc6ICfQuCAo0YHRgtGA0L7Rh9C90LDRjyknLCAn0LknOiAn0LkgKNGB0YLRgNC+0YfQvdCw0Y8pJywgJ9C6JzogJ9C6ICjRgdGC0YDQvtGH0L3QsNGPKScsXG4gICAgJ9C7JzogJ9C7ICjRgdGC0YDQvtGH0L3QsNGPKScsICfQvCc6ICfQvCAo0YHRgtGA0L7Rh9C90LDRjyknLCAn0L0nOiAn0L0gKNGB0YLRgNC+0YfQvdCw0Y8pJywgJ9C+JzogJ9C+ICjRgdGC0YDQvtGH0L3QsNGPKScsXG4gICAgJ9C/JzogJ9C/ICjRgdGC0YDQvtGH0L3QsNGPKScsICfRgCc6ICfRgCAo0YHRgtGA0L7Rh9C90LDRjyknLCAn0YEnOiAn0YEgKNGB0YLRgNC+0YfQvdCw0Y8pJywgJ9GCJzogJ9GCICjRgdGC0YDQvtGH0L3QsNGPKScsXG4gICAgJ9GDJzogJ9GDICjRgdGC0YDQvtGH0L3QsNGPKScsICfRhCc6ICfRhCAo0YHRgtGA0L7Rh9C90LDRjyknLCAn0YUnOiAn0YUgKNGB0YLRgNC+0YfQvdCw0Y8pJywgJ9GGJzogJ9GGICjRgdGC0YDQvtGH0L3QsNGPKScsXG4gICAgJ9GHJzogJ9GHICjRgdGC0YDQvtGH0L3QsNGPKScsICfRiCc6ICfRiCAo0YHRgtGA0L7Rh9C90LDRjyknLCAn0YknOiAn0YkgKNGB0YLRgNC+0YfQvdCw0Y8pJywgJ9GKJzogJ9GKICjRgdGC0YDQvtGH0L3QsNGPKScsXG4gICAgJ9GLJzogJ9GLICjRgdGC0YDQvtGH0L3QsNGPKScsICfRjCc6ICfRjCAo0YHRgtGA0L7Rh9C90LDRjyknLCAn0Y0nOiAn0Y0gKNGB0YLRgNC+0YfQvdCw0Y8pJywgJ9GOJzogJ9GOICjRgdGC0YDQvtGH0L3QsNGPKScsXG4gICAgJ9GPJzogJ9GPICjRgdGC0YDQvtGH0L3QsNGPKSdcbiAgfTtcblxuICAvLyDQodC90LDRh9Cw0LvQsCDQv9GA0L7QstC10YDRj9C10Lwg0LIg0YHQu9C+0LLQsNGA0Y/RhVxuICBpZiAobGF0aW5OYW1lc1tjaGFyXSkgcmV0dXJuIGxhdGluTmFtZXNbY2hhcl07XG4gIGlmIChjeXJpbGxpY05hbWVzW2NoYXJdKSByZXR1cm4gY3lyaWxsaWNOYW1lc1tjaGFyXTtcblxuICAvLyDQldGB0LvQuCDQvdC1INC90LDRiNC70LgsINC/0YvRgtCw0LXQvNGB0Y8g0L7Qv9GA0LXQtNC10LvQuNGC0Ywg0LrQsNGC0LXQs9C+0YDQuNGOINGB0LjQvNCy0L7Qu9CwINC/0L4gVW5pY29kZSDQsdC70L7QutGDXG4gIHRyeSB7XG4gICAgY29uc3QgY29kZSA9IGNoYXIuY29kZVBvaW50QXQoMCk7XG4gICAgaWYgKGlzTmFOKGNvZGUpKSByZXR1cm4gJ3Vua25vd24nO1xuXG4gICAgaWYgKGNvZGUgPj0gMHgyNjAwICYmIGNvZGUgPD0gMHgyNkZGKSByZXR1cm4gJ01pc2NlbGxhbmVvdXMgU3ltYm9scyc7XG4gICAgaWYgKGNvZGUgPj0gMHgyNzAwICYmIGNvZGUgPD0gMHgyN0JGKSByZXR1cm4gJ0RpbmdiYXRzJztcbiAgICBpZiAoY29kZSA+PSAweDFGMzAwICYmIGNvZGUgPD0gMHgxRjVGRikgcmV0dXJuICdNaXNjZWxsYW5lb3VzIFN5bWJvbHMgYW5kIFBpY3RvZ3JhcGhzJztcbiAgICBpZiAoY29kZSA+PSAweDFGNjAwICYmIGNvZGUgPD0gMHgxRjY0RikgcmV0dXJuICdFbW90aWNvbnMnO1xuICAgIGlmIChjb2RlID49IDB4MUY2ODAgJiYgY29kZSA8PSAweDFGNkZGKSByZXR1cm4gJ1RyYW5zcG9ydCBhbmQgTWFwIFN5bWJvbHMnO1xuICAgIGlmIChjb2RlID49IDB4MUY3MDAgJiYgY29kZSA8PSAweDFGNzdGKSByZXR1cm4gJ0FsY2hlbWljYWwgU3ltYm9scyc7XG4gICAgLy8g0JTQvtCx0LDQstC40YLRjCDQtNGA0YPQs9C40LUg0LHQu9C+0LrQuCDQv9C+INC90LXQvtCx0YXQvtC00LjQvNC+0YHRgtC4XG5cbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAvLyDQntGI0LjQsdC60LAg0L/RgNC4INC/0L7Qu9GD0YfQtdC90LjQuCBjb2RlUG9pbnQgKNC90LDQv9GA0LjQvNC10YAsINC00LvRjyDRgdGD0YDRgNC+0LPQsNGC0L3Ri9GFINC/0LDRgClcbiAgICByZXR1cm4gJ3Vua25vd24nO1xuICB9XG5cbiAgLy8g0JXRgdC70Lgg0L3QtSDRgdC80L7Qs9C70Lgg0LrQu9Cw0YHRgdC40YTQuNGG0LjRgNC+0LLQsNGC0YwsINCy0L7Qt9Cy0YDQsNGJ0LDQtdC8IGdlbmVyaWMgbmFtZVxuICByZXR1cm4gJ2NoYXJhY3Rlcic7XG59O1xuXG4vKipcbiAqINCf0L7Qu9GD0YfQsNC10YIg0LLRgdC1INC00L7RgdGC0YPQv9C90YvQtSDQs9C70LjRhNGLINC40Lcg0YjRgNC40YTRgtCwXG4gKiBAcGFyYW0ge09iamVjdH0gZm9udCAtINCe0LHRitC10LrRgiDRiNGA0LjRhNGC0LAg0LjQtyBvcGVudHlwZS5qc1xuICogQHJldHVybnMge0FycmF5PHtjaGFyYWN0ZXI6IHN0cmluZywgdW5pY29kZTogc3RyaW5nLCBuYW1lOiBzdHJpbmcsIGluZGV4OiBudW1iZXJ9Pn0gLSDQnNCw0YHRgdC40LIg0L7QsdGK0LXQutGC0L7QsiDQs9C70LjRhNC+0LJcbiAqL1xuZXhwb3J0IGNvbnN0IGdldEFsbEdseXBoc0Zyb21Gb250ID0gKGZvbnQpID0+IHtcbiAgaWYgKCFmb250IHx8ICFmb250LmdseXBocyB8fCB0eXBlb2YgZm9udC5nbHlwaHMuZ2V0ICE9PSAnZnVuY3Rpb24nIHx8IHR5cGVvZiBmb250Lm51bUdseXBocyAhPT0gJ251bWJlcicpIHtcbiAgICByZXR1cm4gW107XG4gIH1cblxuICB0cnkge1xuICAgIGNvbnN0IGdseXBocyA9IFtdO1xuICAgIGNvbnN0IG51bUdseXBocyA9IGZvbnQubnVtR2x5cGhzO1xuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBudW1HbHlwaHM7IGkrKykge1xuICAgICAgY29uc3QgZ2x5cGggPSBmb250LmdseXBocy5nZXQoaSk7XG5cbiAgICAgIC8vINCf0YDQvtC/0YPRgdC60LDQtdC8IC5ub3RkZWYg0Lgg0LPQu9C40YTRiyDQsdC10LcgVW5pY29kZVxuICAgICAgaWYgKCFnbHlwaCB8fCBnbHlwaC5uYW1lID09PSAnLm5vdGRlZicgfHwgIWdseXBoLnVuaWNvZGUpIGNvbnRpbnVlO1xuXG4gICAgICAvLyDQn9C+0LvRg9GH0LDQtdC8INGB0LjQvNCy0L7QuyAo0LzQvtC20LXRgiDQsdGL0YLRjCDQvdC10YHQutC+0LvRjNC60L4gVW5pY29kZSDQtNC70Y8g0L7QtNC90L7Qs9C+INCz0LvQuNGE0LApXG4gICAgICAvLyDQkdC10YDQtdC8INC/0LXRgNCy0YvQuSBVbmljb2RlINC00LvRjyDQv9GA0L7RgdGC0L7RgtGLXG4gICAgICBjb25zdCBjaGFyQ29kZSA9IGdseXBoLnVuaWNvZGU7XG4gICAgICBjb25zdCBjaGFyID0gU3RyaW5nLmZyb21Db2RlUG9pbnQoY2hhckNvZGUpO1xuXG4gICAgICAvLyDQlNC+0LHQsNCy0LvRj9C10Lwg0YLQvtC70YzQutC+INGD0L3QuNC60LDQu9GM0L3Ri9C1INGB0LjQvNCy0L7Qu9GLICjQvdC1INCz0LvQuNGE0YspXG4gICAgICBpZiAoIWdseXBocy5zb21lKGcgPT4gZy5jaGFyYWN0ZXIgPT09IGNoYXIpKSB7XG4gICAgICAgICBnbHlwaHMucHVzaCh7XG4gICAgICAgICAgIGNoYXJhY3RlcjogY2hhcixcbiAgICAgICAgICAgdW5pY29kZTogZ2V0Q2hhclVuaWNvZGUoY2hhciksXG4gICAgICAgICAgIG5hbWU6IGdseXBoLm5hbWUgfHwgJycsXG4gICAgICAgICAgIGluZGV4OiBpIC8vINCh0L7RhdGA0LDQvdGP0LXQvCDQuNC90LTQtdC60YEg0LPQu9C40YTQsFxuICAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8g0JzQvtC20L3QviDQtNC+0LHQsNCy0LjRgtGMINGB0L7RgNGC0LjRgNC+0LLQutGDINC/0L4gVW5pY29kZVxuICAgIGdseXBocy5zb3J0KChhLCBiKSA9PiBhLnVuaWNvZGUubG9jYWxlQ29tcGFyZShiLnVuaWNvZGUpKTtcblxuICAgIHJldHVybiBnbHlwaHM7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgY29uc29sZS5lcnJvcignRXJyb3IgZ2V0dGluZyBhbGwgZ2x5cGhzIGZyb20gZm9udDonLCBlcnJvcik7XG4gICAgcmV0dXJuIFtdO1xuICB9XG59O1xuXG4vKipcbiAqINCf0L7Qu9GD0YfQsNC10YIg0LDQu9GM0YLQtdGA0L3QsNGC0LjQstC90YvQtSDRhNC+0YDQvNGLINCz0LvQuNGE0LAgKNC10YHQu9C4INC+0L3QuCDQtdGB0YLRjCDQsiDRiNGA0LjRhNGC0LUpXG4gKiDQoNC10LDQu9C40LfQsNGG0LjRjyDRgtGA0LXQsdGD0LXRgiDQs9C70YPQsdC+0LrQvtCz0L4g0L/QvtC90LjQvNCw0L3QuNGPINGC0LDQsdC70LjRhtGLIEdTVUIgJ2FhbHQnINC4INC00YDRg9Cz0LjRhSDRhNC40YcuXG4gKiDQrdGC0LAg0YTRg9C90LrRhtC40Y8g0Y/QstC70Y/QtdGC0YHRjyDQt9Cw0LPQu9GD0YjQutC+0Lkg0LjQu9C4INGC0YDQtdCx0YPQtdGCINC30L3QsNGH0LjRgtC10LvRjNC90L7QuSDQtNC+0YDQsNCx0L7RgtC60LguXG4gKiBAcGFyYW0ge09iamVjdH0gZm9udCAtINCe0LHRitC10LrRgiDRiNGA0LjRhNGC0LAg0LjQtyBvcGVudHlwZS5qc1xuICogQHBhcmFtIHtzdHJpbmd9IGNoYXIgLSDQodC40LzQstC+0Lsg0LTQu9GPINC/0L7QuNGB0LrQsCDQsNC70YzRgtC10YDQvdCw0YLQuNCy0L3Ri9GFINGE0L7RgNC8XG4gKiBAcmV0dXJucyB7QXJyYXk8e25hbWU6IHN0cmluZywgdW5pY29kZTogc3RyaW5nLCBpbmRleDogbnVtYmVyfT59IC0g0JzQsNGB0YHQuNCyINC+0LHRitC10LrRgtC+0LIg0LDQu9GM0YLQtdGA0L3QsNGC0LjQstC90YvRhSDQs9C70LjRhNC+0LJcbiAqL1xuZXhwb3J0IGNvbnN0IGdldEdseXBoQWx0ZXJuYXRpdmVzID0gKGZvbnQsIGNoYXIpID0+IHtcbiAgaWYgKCFmb250IHx8ICFjaGFyIHx8ICFmb250LnRhYmxlcyB8fCAhZm9udC50YWJsZXMuZ3N1YiB8fCAhZm9udC5nbHlwaHMpIHJldHVybiBbXTtcblxuICB0cnkge1xuICAgIGNvbnN0IGFsdGVybmF0aXZlcyA9IFtdO1xuICAgIGNvbnN0IG1haW5HbHlwaCA9IGZvbnQuY2hhclRvR2x5cGgoY2hhcik7XG4gICAgaWYgKCFtYWluR2x5cGggfHwgIW1haW5HbHlwaC5pbmRleCkgcmV0dXJuIFtdO1xuXG4gICAgY29uc3QgbWFpbkdseXBoSW5kZXggPSBtYWluR2x5cGguaW5kZXg7XG4gICAgY29uc3QgZ3N1YiA9IGZvbnQudGFibGVzLmdzdWI7XG5cbiAgICAvLyDQn9C+0LjRgdC6INCw0LvRjNGC0LXRgNC90LDRgtC40LIg0LIg0YLQsNCx0LvQuNGG0LDRhSBHU1VCICjRg9C/0YDQvtGJ0LXQvdC90YvQuSDQv9GA0LjQvNC10YAg0LTQu9GPIGxvb2t1cFR5cGUgMylcbiAgICBpZiAoZ3N1Yi5sb29rdXBzKSB7XG4gICAgICAgIGZvciAoY29uc3QgbG9va3VwIG9mIGdzdWIubG9va3Vwcykge1xuICAgICAgICAgICAgLy8gTG9va3VwVHlwZSAzOiBBbHRlcm5hdGUgU3Vic3RpdHV0aW9uIFN1YnRhYmxlXG4gICAgICAgICAgICBpZiAobG9va3VwLmxvb2t1cFR5cGUgPT09IDMpIHtcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IHN1YnRhYmxlIG9mIGxvb2t1cC5zdWJ0YWJsZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHN1YnRhYmxlLmNvdmVyYWdlICYmIHN1YnRhYmxlLmNvdmVyYWdlLmdseXBocykge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgY292ZXJhZ2VJbmRleCA9IHN1YnRhYmxlLmNvdmVyYWdlLmdseXBocy5pbmRleE9mKG1haW5HbHlwaEluZGV4KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjb3ZlcmFnZUluZGV4ICE9PSAtMSAmJiBzdWJ0YWJsZS5hbHRlcm5hdGVTZXRzICYmIHN1YnRhYmxlLmFsdGVybmF0ZVNldHNbY292ZXJhZ2VJbmRleF0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBhbHRlcm5hdGVJbmRpY2VzID0gc3VidGFibGUuYWx0ZXJuYXRlU2V0c1tjb3ZlcmFnZUluZGV4XTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhbHRlcm5hdGVJbmRpY2VzLmZvckVhY2goYWx0SW5kZXggPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBhbHRHbHlwaCA9IGZvbnQuZ2x5cGhzLmdldChhbHRJbmRleCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChhbHRHbHlwaCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFsdGVybmF0aXZlcy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6IGFsdEdseXBoLm5hbWUgfHwgJycsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB1bmljb2RlOiBhbHRHbHlwaC51bmljb2RlID8gZ2V0Q2hhclVuaWNvZGUoU3RyaW5nLmZyb21Db2RlUG9pbnQoYWx0R2x5cGgudW5pY29kZSkpIDogJycgLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5kZXg6IGFsdEluZGV4XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAvLyDQnNC+0LbQvdC+INC00L7QsdCw0LLQuNGC0Ywg0L/QvtC00LTQtdGA0LbQutGDINC00YDRg9Cz0LjRhSBsb29rdXBUeXBlcyAoZS5nLiwgbG9va3VwVHlwZSAxKVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8g0KPQtNCw0LvRj9C10Lwg0LTRg9Cx0LvQuNC60LDRgtGLINC4INC+0YHQvdC+0LLQvdC+0Lkg0LPQu9C40YQg0LjQtyDQsNC70YzRgtC10YDQvdCw0YLQuNCyXG4gICAgY29uc3QgdW5pcXVlQWx0ZXJuYXRpdmVzID0gYWx0ZXJuYXRpdmVzLmZpbHRlcigoYWx0LCBpbmRleCwgc2VsZikgPT5cbiAgICAgICAgYWx0LmluZGV4ICE9PSBtYWluR2x5cGhJbmRleCAmJlxuICAgICAgICBpbmRleCA9PT0gc2VsZi5maW5kSW5kZXgoKHQpID0+IHQuaW5kZXggPT09IGFsdC5pbmRleClcbiAgICApO1xuXG4gICAgcmV0dXJuIHVuaXF1ZUFsdGVybmF0aXZlcztcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBjb25zb2xlLmVycm9yKCdFcnJvciBnZXR0aW5nIGdseXBoIGFsdGVybmF0aXZlczonLCBlcnJvcik7XG4gICAgcmV0dXJuIFtdO1xuICB9XG59O1xuXG4vKipcbiAqINCf0L7Qu9GD0YfQsNC10YIg0LvQuNCz0LDRgtGD0YDRiyDQtNC70Y8g0L/QvtGB0LvQtdC00L7QstCw0YLQtdC70YzQvdC+0YHRgtC4INGB0LjQvNCy0L7Qu9C+0LIgKNC10YHQu9C4INC+0L3QuCDQtdGB0YLRjCDQsiDRiNGA0LjRhNGC0LUpXG4gKiDQoNC10LDQu9C40LfQsNGG0LjRjyDRgtGA0LXQsdGD0LXRgiDQs9C70YPQsdC+0LrQvtCz0L4g0L/QvtC90LjQvNCw0L3QuNGPINGC0LDQsdC70LjRhtGLIEdTVUIgJ2xpZ2EnLCAnY2xpZycg0Lgg0LTRgC5cbiAqINCt0YLQsCDRhNGD0L3QutGG0LjRjyDRj9Cy0LvRj9C10YLRgdGPINC30LDQs9C70YPRiNC60L7QuSDQuNC70Lgg0YLRgNC10LHRg9C10YIg0LfQvdCw0YfQuNGC0LXQu9GM0L3QvtC5INC00L7RgNCw0LHQvtGC0LrQuC5cbiAqIEBwYXJhbSB7T2JqZWN0fSBmb250IC0g0J7QsdGK0LXQutGCINGI0YDQuNGE0YLQsCDQuNC3IG9wZW50eXBlLmpzXG4gKiBAcGFyYW0ge3N0cmluZ30gY2hhcnMgLSDQn9C+0YHQu9C10LTQvtCy0LDRgtC10LvRjNC90L7RgdGC0Ywg0YHQuNC80LLQvtC70L7QsiDQtNC70Y8g0L/QvtC40YHQutCwINC70LjQs9Cw0YLRg9GAXG4gKiBAcmV0dXJucyB7QXJyYXk8e29yaWdpbmFsOiBzdHJpbmcsIGxpZ2F0dXJlOiBzdHJpbmcsIHVuaWNvZGU6IHN0cmluZ30+fSAtINCc0LDRgdGB0LjQsiDQvtCx0YrQtdC60YLQvtCyINC70LjQs9Cw0YLRg9GAXG4gKi9cbmV4cG9ydCBjb25zdCBnZXRMaWdhdHVyZXMgPSAoZm9udCwgY2hhcnMpID0+IHtcbiAgaWYgKCFmb250IHx8ICFjaGFycyB8fCBjaGFycy5sZW5ndGggPCAyIHx8ICFmb250LnRhYmxlcyB8fCAhZm9udC50YWJsZXMuZ3N1YikgcmV0dXJuIFtdO1xuXG4gIHRyeSB7XG4gICAgY29uc3QgbGlnYXR1cmVzID0gW107XG4gICAgLy8gY29uc3QgZ3N1YiA9IGZvbnQudGFibGVzLmdzdWI7XG5cbiAgICAvLyBUT0RPOiDQoNC10LDQu9C40LfQvtCy0LDRgtGMINGB0LvQvtC20L3Rg9GOINC70L7Qs9C40LrRgyDQv9C+0LjRgdC60LAg0LvQuNCz0LDRgtGD0YAg0LIgR1NVQiDRgtCw0LHQu9C40YbQsNGFIChsb29rdXBUeXBlIDQpXG4gICAgLy8g0K3RgtC+INGC0YDQtdCx0YPQtdGCINGA0LXQutGD0YDRgdC40LLQvdC+0LPQviDQvtCx0YXQvtC00LAg0LjQu9C4INGB0LvQvtC20L3QvtCz0L4g0YHQvtC/0L7RgdGC0LDQstC70LXQvdC40Y8g0L/QvtGB0LvQtdC00L7QstCw0YLQtdC70YzQvdC+0YHRgtC10Lkg0LPQu9C40YTQvtCyLlxuXG4gICAgLy8g0JTQvtCx0LDQstC70Y/QtdC8INCx0LDQt9C+0LLRi9C1INC70LjQs9Cw0YLRg9GA0Ysg0LTQu9GPINGA0LDRgdC/0YDQvtGB0YLRgNCw0L3QtdC90L3Ri9GFINGB0L7Rh9C10YLQsNC90LjQuSDQutCw0Log0LfQsNC/0LDRgdC90L7QuSDQstCw0YDQuNCw0L3RglxuICAgIGNvbnN0IGNvbW1vbkxpZ2F0dXJlcyA9IHtcbiAgICAgICdmZic6ICfvrIAnLFxuICAgICAgJ2ZpJzogJ++sgScsXG4gICAgICAnZmwnOiAn76yCJyxcbiAgICAgICdmZmknOiAn76yDJyxcbiAgICAgICdmZmwnOiAn76yEJ1xuICAgIH07XG5cbiAgICBpZiAoY29tbW9uTGlnYXR1cmVzW2NoYXJzXSkge1xuICAgICAgICBjb25zdCBsaWdDaGFyID0gY29tbW9uTGlnYXR1cmVzW2NoYXJzXTtcbiAgICAgICAgbGlnYXR1cmVzLnB1c2goe1xuICAgICAgICAgICAgb3JpZ2luYWw6IGNoYXJzLFxuICAgICAgICAgICAgbGlnYXR1cmU6IGxpZ0NoYXIsXG4gICAgICAgICAgICB1bmljb2RlOiBnZXRDaGFyVW5pY29kZShsaWdDaGFyKVxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICByZXR1cm4gbGlnYXR1cmVzO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGdldHRpbmcgbGlnYXR1cmVzOicsIGVycm9yKTtcbiAgICByZXR1cm4gW107XG4gIH1cbn07XG5cbi8vINCU0L7QsdCw0LLQu9GP0LXQvCDRhNGD0L3QutGG0LjRjiBnZXRDaGFyVW5pY29kZSwg0L/QtdGA0LXQvdC10YHQtdC90L3Rg9GOINC40LcgZm9udFV0aWxzQ29tbW9uLmpzXG4vKipcbiAqINCf0L7Qu9GD0YfQsNC10YIgVW5pY29kZS3QutC+0LQg0YHQuNC80LLQvtC70LAg0LIg0YTQvtGA0LzQsNGC0LUgXCJVK1hYWFhcIlxuICogQHBhcmFtIHtzdHJpbmd9IGNoYXIgLSDQodC40LzQstC+0Lsg0LTQu9GPINC/0L7Qu9GD0YfQtdC90LjRjyBVbmljb2RlXG4gKiBAcmV0dXJucyB7c3RyaW5nfSAtIFVuaWNvZGUt0LrQvtC0INCyINGE0L7RgNC80LDRgtC1IFwiVStYWFhYXCJcbiAqL1xuZXhwb3J0IGNvbnN0IGdldENoYXJVbmljb2RlID0gKGNoYXIpID0+IHtcbiAgaWYgKCFjaGFyIHx8IHR5cGVvZiBjaGFyICE9PSAnc3RyaW5nJyB8fCAhY2hhci5sZW5ndGgpIHtcbiAgICByZXR1cm4gJ1UrPz8/Pyc7XG4gIH1cblxuICB0cnkge1xuICAgIGNvbnN0IGNvZGVQb2ludCA9IGNoYXIuY29kZVBvaW50QXQoMCk7XG4gICAgLy8g0J/RgNC+0LLQtdGA0LrQsCDQvdCwIE5hTiwg0YfRgtC+0LHRiyDQuNC30LHQtdC20LDRgtGMIFwiVStOQU5cIlxuICAgIGlmIChpc05hTihjb2RlUG9pbnQpKSB7XG4gICAgICAgIHJldHVybiAnVSs/Pz8/JztcbiAgICB9XG4gICAgcmV0dXJuIGBVKyR7Y29kZVBvaW50LnRvU3RyaW5nKDE2KS50b1VwcGVyQ2FzZSgpLnBhZFN0YXJ0KDQsICcwJyl9YDtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICByZXR1cm4gJ1UrPz8/Pyc7XG4gIH1cbn07ICJdLCJuYW1lcyI6WyJleHRyYWN0QmFzaWNHbHlwaERhdGEiLCJmb250Iiwic291cmNlIiwiZ2x5cGhzIiwiZ2V0IiwiY29uc29sZSIsImVycm9yIiwiYWxsR2x5cGhzIiwiZ2x5cGhOYW1lcyIsImdseXBoVW5pY29kZXMiLCJhZHZhbmNlV2lkdGhzIiwiZXJyb3JzIiwibnVtR2x5cGhzIiwiaSIsImdseXBoIiwibmFtZSIsImdseXBoSW5mbyIsImlkIiwiaW5kZXgiLCJ1bmljb2RlIiwidW5pY29kZXMiLCJhZHZhbmNlV2lkdGgiLCJNYXRoIiwicm91bmQiLCJwdXNoIiwidG9TdHJpbmciLCJ0b1VwcGVyQ2FzZSIsInBhZFN0YXJ0IiwiZ2x5cGhFcnJvciIsIndhcm4iLCJtZXNzYWdlIiwibmFtZXMiLCJnZXRHbHlwaE5hbWVGcm9tRm9udCIsImNoYXIiLCJjaGFyVG9HbHlwaCIsImdldFNpbXBsZUNoYXJOYW1lIiwibGVuZ3RoIiwibGF0aW5OYW1lcyIsImN5cmlsbGljTmFtZXMiLCJjb2RlIiwiY29kZVBvaW50QXQiLCJpc05hTiIsImdldEFsbEdseXBoc0Zyb21Gb250IiwiY2hhckNvZGUiLCJTdHJpbmciLCJmcm9tQ29kZVBvaW50Iiwic29tZSIsImciLCJjaGFyYWN0ZXIiLCJnZXRDaGFyVW5pY29kZSIsInNvcnQiLCJhIiwiYiIsImxvY2FsZUNvbXBhcmUiLCJnZXRHbHlwaEFsdGVybmF0aXZlcyIsInRhYmxlcyIsImdzdWIiLCJhbHRlcm5hdGl2ZXMiLCJtYWluR2x5cGgiLCJtYWluR2x5cGhJbmRleCIsImxvb2t1cHMiLCJsb29rdXAiLCJsb29rdXBUeXBlIiwic3VidGFibGUiLCJzdWJ0YWJsZXMiLCJjb3ZlcmFnZSIsImNvdmVyYWdlSW5kZXgiLCJpbmRleE9mIiwiYWx0ZXJuYXRlU2V0cyIsImFsdGVybmF0ZUluZGljZXMiLCJmb3JFYWNoIiwiYWx0SW5kZXgiLCJhbHRHbHlwaCIsInVuaXF1ZUFsdGVybmF0aXZlcyIsImZpbHRlciIsImFsdCIsInNlbGYiLCJmaW5kSW5kZXgiLCJ0IiwiZ2V0TGlnYXR1cmVzIiwiY2hhcnMiLCJsaWdhdHVyZXMiLCJjb21tb25MaWdhdHVyZXMiLCJsaWdDaGFyIiwib3JpZ2luYWwiLCJsaWdhdHVyZSIsImNvZGVQb2ludCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./utils/glyphUtils.js\n"));

/***/ }),

/***/ "./utils/localFontProcessor.js":
/*!*************************************!*\
  !*** ./utils/localFontProcessor.js ***!
  \*************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   processLocalFont: function() { return /* binding */ processLocalFont; },\n/* harmony export */   revokeObjectURL: function() { return /* binding */ revokeObjectURL; }\n/* harmony export */ });\n/* harmony import */ var react_toastify__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react-toastify */ \"./node_modules/react-toastify/dist/index.mjs\");\n/* harmony import */ var _fontParser__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./fontParser */ \"./utils/fontParser.js\");\n/* harmony import */ var _fontUtilsCommon__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./fontUtilsCommon */ \"./utils/fontUtilsCommon.js\");\n/* harmony import */ var _cssGenerator__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./cssGenerator */ \"./utils/cssGenerator.js\");\n// Функции для обработки локально загруженных шрифтов (кэширование, FontFace)\n\n\n\n\n/**\n * Кэш для хранения результатов анализа локальных шрифтов\n * Ключ - хеш содержимого шрифта.\n * Значение - объект metadata, полученный из воркера.\n * @type {Object.<string, Object>}\n */ const localFontCache = {};\n/**\n * Освобождает URL, созданный через URL.createObjectURL()\n * @param {string} url - URL для освобождения\n */ const revokeObjectURL = (url)=>{\n    if (url && typeof url === \"string\" && url.startsWith(\"blob:\")) {\n        try {\n            URL.revokeObjectURL(url);\n        } catch (error) {\n            console.warn(\"Failed to revoke Object URL:\", error); // Используем warn вместо error\n        // toast.error('Ошибка при освобождении URL'); // Не спамим пользователя\n        }\n    }\n};\n/**\n * Асинхронно вычисляет SHA-256 хеш для Blob файла.\n * @param {Blob} file - Файл (Blob).\n * @returns {Promise<string|null>} - Промис с HEX-строкой хеша или null в случае ошибки.\n */ const calculateFileHash = async (file)=>{\n    if (!(file instanceof Blob)) {\n        console.error(\"Invalid input for hashing: expected Blob.\");\n        return null;\n    }\n    try {\n        const buffer = await file.arrayBuffer();\n        const hashBuffer = await crypto.subtle.digest(\"SHA-256\", buffer);\n        // Преобразуем ArrayBuffer хеша в HEX-строку\n        const hashArray = Array.from(new Uint8Array(hashBuffer));\n        const hashHex = hashArray.map((b)=>b.toString(16).padStart(2, \"0\")).join(\"\");\n        return hashHex;\n    } catch (error) {\n        console.error(\"Error calculating file hash:\", error);\n        react_toastify__WEBPACK_IMPORTED_MODULE_0__.toast.error(\"Не удалось вычислить хеш файла для кэширования.\");\n        return null;\n    }\n};\n/**\n * Полностью анализирует локальный шрифт (из файла), определяя его характеристики.\n * Включает парсинг, извлечение метаданных, кэширование и добавление @font-face.\n * @param {Object} fontInput - Объект шрифта с file (Blob) и name (string)\n * @returns {Promise<Object|null>} - Промис с обработанным объектом шрифта или null при критической ошибке.\n */ const processLocalFont = async (fontInput)=>{\n    if (!fontInput || !(fontInput.file instanceof Blob) || !fontInput.name) {\n        react_toastify__WEBPACK_IMPORTED_MODULE_0__.toast.error(\"Неверные входные данные для обработки локального шрифта.\");\n        return null;\n    }\n    const { file, name } = fontInput;\n    const fontId = Math.random().toString(36).substring(2, 9); // Короткий ID для читаемости\n    const cleanedName = name.replace(/\\.[^/.]+$/, \"\");\n    let objectUrl = null;\n    let cacheKey = null; // Инициализируем cacheKey\n    try {\n        // 1. Вычисляем хеш файла для использования в качестве ключа кэша\n        cacheKey = await calculateFileHash(file);\n        if (!cacheKey) {\n            // Если хеш не удалось получить, кэширование невозможно, но продолжаем обработку\n            react_toastify__WEBPACK_IMPORTED_MODULE_0__.toast.warning(\"Не удалось создать ключ кэша для шрифта, кэширование будет пропущено.\");\n        }\n        // 2. Проверка кэша (теперь по хешу)\n        if (cacheKey && localFontCache[cacheKey]) {\n            var _cachedMetadata_names;\n            console.log(\"Using cached metadata for \".concat(name, \" (hash: \").concat(cacheKey.substring(0, 8), \"...)\")); // Лог для отладки\n            objectUrl = URL.createObjectURL(file); // Свежий URL нужен всегда\n            const cachedMetadata = {\n                ...localFontCache[cacheKey]\n            }; // Получаем метаданные из кэша\n            const fontFamilyName = \"font-\".concat(fontId); // Генерируем уникальное имя\n            // Создаем fontObj на основе кэшированных метаданных\n            const fontObj = {\n                id: fontId,\n                name: cachedMetadata.preferredFamily || ((_cachedMetadata_names = cachedMetadata.names) === null || _cachedMetadata_names === void 0 ? void 0 : _cachedMetadata_names.fontFamily) || cleanedName,\n                originalName: name,\n                source: \"local\",\n                currentWeight: 400,\n                currentStyle: \"normal\",\n                isVariableFont: cachedMetadata.isVariable || false,\n                variableAxes: {},\n                supportedAxes: [],\n                variationSettings: \"\",\n                availableStyles: [],\n                file: file,\n                url: objectUrl,\n                fontFamily: fontFamilyName\n            };\n            // Восстанавливаем оси и стили из кэшированных метаданных\n            if (fontObj.isVariableFont && cachedMetadata.supportedAxes) {\n                // Заполняем информацию об осях из кэша\n                fontObj.variableAxes = Object.entries(cachedMetadata.supportedAxes).reduce((acc, param)=>{\n                    let [tag, axisInfo] = param;\n                    acc[tag] = {\n                        name: axisInfo.name || tag.toUpperCase(),\n                        min: axisInfo.min,\n                        max: axisInfo.max,\n                        default: axisInfo.default\n                    };\n                    return acc;\n                }, {});\n                fontObj.supportedAxes = Object.keys(cachedMetadata.supportedAxes);\n                fontObj.variationSettings = Object.entries(fontObj.variableAxes).map((param)=>{\n                    let [tag, value] = param;\n                    return '\"'.concat(tag, '\" ').concat(value.default || 400);\n                }) // Запасное значение для веса\n                .join(\", \");\n                // Определяем начальные стили для вариативных шрифтов из кэша (может быть пересмотрено)\n                // Пока оставляем заглушку или определяем на основе дефолтных осей, если возможно\n                // TODO: Уточнить логику availableStyles для вариативных из кэша\n                fontObj.availableStyles = [\n                    {\n                        name: \"Default\",\n                        weight: 400,\n                        style: \"normal\"\n                    }\n                ]; // Заглушка\n            } else if (!fontObj.isVariableFont && cachedMetadata.names) {\n                var _cachedMetadata_names1;\n                // Определяем стиль/вес для невариативных из кэша\n                let weight = 400;\n                let style = \"normal\";\n                const subfamily = cachedMetadata.preferredSubfamily || ((_cachedMetadata_names1 = cachedMetadata.names) === null || _cachedMetadata_names1 === void 0 ? void 0 : _cachedMetadata_names1.fontSubfamily) || \"Regular\";\n                const subfamilyLower = subfamily.toLowerCase();\n                style = subfamilyLower.includes(\"italic\") || subfamilyLower.includes(\"oblique\") ? \"italic\" : \"normal\";\n                // ... (логика определения веса из subfamily) ...\n                if (subfamilyLower.includes(\"thin\")) weight = 100;\n                else if (subfamilyLower.includes(\"extralight\") || subfamilyLower.includes(\"ultralight\")) weight = 200;\n                else if (subfamilyLower.includes(\"light\")) weight = 300;\n                else if (subfamilyLower.includes(\"medium\")) weight = 500;\n                else if (subfamilyLower.includes(\"semibold\") || subfamilyLower.includes(\"demibold\")) weight = 600;\n                else if (subfamilyLower.includes(\"bold\")) weight = 700;\n                else if (subfamilyLower.includes(\"extrabold\") || subfamilyLower.includes(\"ultrabold\")) weight = 800;\n                else if (subfamilyLower.includes(\"black\") || subfamilyLower.includes(\"heavy\")) weight = 900;\n                fontObj.currentWeight = weight;\n                fontObj.currentStyle = style;\n                const styleInfo = (0,_fontUtilsCommon__WEBPACK_IMPORTED_MODULE_2__.findStyleInfoByWeightAndStyle)(weight, style);\n                fontObj.availableStyles = [\n                    {\n                        name: styleInfo.name,\n                        weight,\n                        style\n                    }\n                ];\n            } else {\n                // Если стилей нет в кэше (например, старый кэш или ошибка парсинга при кэшировании)\n                fontObj.availableStyles = [\n                    {\n                        name: \"Regular\",\n                        weight: 400,\n                        style: \"normal\"\n                    }\n                ];\n            }\n            // Определяем начальные настройки для вариативных шрифтов из кэша\n            let initialSettings = {};\n            if (fontObj.isVariableFont && fontObj.variableAxes) {\n                initialSettings = Object.entries(fontObj.variableAxes).reduce((acc, param)=>{\n                    let [tag, axis] = param;\n                    acc[tag] = axis.default;\n                    return acc;\n                }, {});\n            }\n            // !!! Используем loadFontFaceIfNeeded напрямую !!!\n            try {\n                // Вызываем функцию через именованный импорт\n                await (0,_cssGenerator__WEBPACK_IMPORTED_MODULE_3__.loadFontFaceIfNeeded)(fontFamilyName, objectUrl, initialSettings);\n                console.log(\"Font \".concat(fontFamilyName, \" loaded successfully from cache using FontFace API.\"));\n                // Успешно загрузили, возвращаем fontObj\n                revokeObjectURL(objectUrl); // Освобождаем blob URL после успешной загрузки\n                return fontObj;\n            } catch (error) {\n                console.error(\"Failed to load font \".concat(fontFamilyName, \" from cache using FontFace API:\"), error);\n                react_toastify__WEBPACK_IMPORTED_MODULE_0__.toast.error(\"Ошибка при загрузке шрифта \".concat(fontObj.name, \" из кэша.\"));\n                revokeObjectURL(objectUrl); // Освобождаем blob URL при ошибке\n                fontObj.error = \"Failed to load via FontFace API\";\n                return fontObj; // Возвращаем объект с ошибкой\n            }\n        // --- Конец обработки кэша ---\n        }\n        // --- Конец проверки кэша ---\n        // 3. Создание URL (если не из кэша)\n        if (!objectUrl) {\n            objectUrl = URL.createObjectURL(file);\n        }\n        // 4. Парсинг файла -> получение полного объекта шрифта через parseFontBuffer\n        // parseFontFile теперь возвращает объект metadata или null\n        let parsedFontData = null;\n        try {\n            const buffer = await file.arrayBuffer();\n            parsedFontData = await (0,_fontParser__WEBPACK_IMPORTED_MODULE_1__.parseFontBuffer)(buffer); // Используем parseFontBuffer\n        } catch (e) {\n            console.error(\"Error reading or parsing font buffer for \".concat(name, \":\"), e);\n            react_toastify__WEBPACK_IMPORTED_MODULE_0__.toast.error(\"Ошибка чтения или анализа файла шрифта \".concat(name, \".\"));\n        // Не возвращаем null сразу, т.к. addFontFace может работать с базовым fontObj\n        }\n        // Создаем базовый объект шрифта (как и раньше)\n        const fontObj = {\n            id: fontId,\n            name: cleanedName,\n            originalName: name,\n            source: \"local\",\n            currentWeight: 400,\n            currentStyle: \"normal\",\n            isVariableFont: false,\n            variableAxes: {},\n            supportedAxes: [],\n            variationSettings: \"\",\n            availableStyles: [],\n            file: file,\n            // url: objectUrl, // Устанавливаем ниже, после создания fontFamilyName\n            fontFamily: null\n        };\n        // Установим fontObj.url и fontObj.fontFamily\n        const fontFamilyName = \"font-\".concat(fontId);\n        fontObj.url = objectUrl;\n        fontObj.fontFamily = fontFamilyName;\n        // 5. Заполнение fontObj из данных парсинга, если парсинг успешен\n        if (parsedFontData) {\n            var _names_preferredFamily, _names_fontFamily, _names_preferredSubfamily, _names_fontSubfamily, _parsedFontData_tables_fvar, _parsedFontData_tables, _parsedFontData_tables_fvar1, _parsedFontData_tables1;\n            // Используем данные из объекта parsedFontData (результат opentype.parse)\n            // Получаем имена (предпочитаем английские)\n            const names = parsedFontData.names || {};\n            const preferredFamily = ((_names_preferredFamily = names.preferredFamily) === null || _names_preferredFamily === void 0 ? void 0 : _names_preferredFamily.en) || ((_names_fontFamily = names.fontFamily) === null || _names_fontFamily === void 0 ? void 0 : _names_fontFamily.en);\n            const preferredSubfamily = ((_names_preferredSubfamily = names.preferredSubfamily) === null || _names_preferredSubfamily === void 0 ? void 0 : _names_preferredSubfamily.en) || ((_names_fontSubfamily = names.fontSubfamily) === null || _names_fontSubfamily === void 0 ? void 0 : _names_fontSubfamily.en) || \"Regular\";\n            fontObj.name = preferredFamily || fontObj.name;\n            fontObj.isVariableFont = (0,_fontParser__WEBPACK_IMPORTED_MODULE_1__.isVariableFont)(parsedFontData); // Используем isVariableFont\n            if (fontObj.isVariableFont && ((_parsedFontData_tables = parsedFontData.tables) === null || _parsedFontData_tables === void 0 ? void 0 : (_parsedFontData_tables_fvar = _parsedFontData_tables.fvar) === null || _parsedFontData_tables_fvar === void 0 ? void 0 : _parsedFontData_tables_fvar.axes)) {\n                // Заполняем информацию об осях из parsedFontData.tables.fvar.axes\n                fontObj.variableAxes = parsedFontData.tables.fvar.axes.reduce((acc, axis)=>{\n                    var _axis_name;\n                    const tag = axis.tag;\n                    // Используем имя из axis.name?.en, если оно есть\n                    const axisName = ((_axis_name = axis.name) === null || _axis_name === void 0 ? void 0 : _axis_name.en) || tag.toUpperCase();\n                    acc[tag] = {\n                        name: axisName,\n                        min: axis.minValue,\n                        max: axis.maxValue,\n                        default: axis.defaultValue\n                    };\n                    return acc;\n                }, {});\n                fontObj.supportedAxes = Object.keys(fontObj.variableAxes);\n                fontObj.variationSettings = Object.entries(fontObj.variableAxes).map((param)=>{\n                    let [tag, value] = param;\n                    return '\"'.concat(tag, '\" ').concat(value.default || 400);\n                }) // Запасное значение для веса\n                .join(\", \");\n                fontObj.availableStyles = [\n                    {\n                        name: \"Default\",\n                        weight: 400,\n                        style: \"normal\"\n                    }\n                ]; // Заглушка\n            } else if (fontObj.isVariableFont && !((_parsedFontData_tables1 = parsedFontData.tables) === null || _parsedFontData_tables1 === void 0 ? void 0 : (_parsedFontData_tables_fvar1 = _parsedFontData_tables1.fvar) === null || _parsedFontData_tables_fvar1 === void 0 ? void 0 : _parsedFontData_tables_fvar1.axes)) {\n                // Вариативный, но оси не извлеклись\n                console.warn(\"Variable font \".concat(name, \" parsed without axes info.\"));\n                fontObj.isVariableFont = false; // Считаем невариативным\n                fontObj.availableStyles = [\n                    {\n                        name: \"Regular\",\n                        weight: 400,\n                        style: \"normal\"\n                    }\n                ];\n            } else {\n                // НЕвариативный шрифт - определяем стиль из имен\n                let weight = 400;\n                let style = \"normal\";\n                if (names) {\n                    const subfamily = preferredSubfamily; // Используем извлеченное имя\n                    const subfamilyLower = subfamily.toLowerCase();\n                    style = subfamilyLower.includes(\"italic\") || subfamilyLower.includes(\"oblique\") ? \"italic\" : \"normal\";\n                    // ... (логика определения веса из subfamily - без изменений) ...\n                    if (subfamilyLower.includes(\"thin\")) weight = 100;\n                    else if (subfamilyLower.includes(\"extralight\") || subfamilyLower.includes(\"ultralight\")) weight = 200;\n                    else if (subfamilyLower.includes(\"light\")) weight = 300;\n                    else if (subfamilyLower.includes(\"medium\")) weight = 500;\n                    else if (subfamilyLower.includes(\"semibold\") || subfamilyLower.includes(\"demibold\")) weight = 600;\n                    else if (subfamilyLower.includes(\"bold\")) weight = 700;\n                    else if (subfamilyLower.includes(\"extrabold\") || subfamilyLower.includes(\"ultrabold\")) weight = 800;\n                    else if (subfamilyLower.includes(\"black\") || subfamilyLower.includes(\"heavy\")) weight = 900;\n                }\n                fontObj.currentWeight = weight;\n                fontObj.currentStyle = style;\n                const styleInfo = (0,_fontUtilsCommon__WEBPACK_IMPORTED_MODULE_2__.findStyleInfoByWeightAndStyle)(weight, style);\n                fontObj.availableStyles = [\n                    {\n                        name: styleInfo.name,\n                        weight,\n                        style\n                    }\n                ];\n            }\n            // 6. Кэширование результата (метаданных - извлекаем из parsedFontData для совместимости кэша)\n            if (cacheKey && parsedFontData) {\n                // Кэшируем объект, похожий на старый metadata, для обратной совместимости?\n                // Или кэшировать весь parsedFontData? Пока оставим как было, извлекая нужное\n                const metadataToCache = {\n                    names: parsedFontData.names,\n                    preferredFamily: preferredFamily,\n                    preferredSubfamily: preferredSubfamily,\n                    isVariable: fontObj.isVariableFont,\n                    supportedAxes: fontObj.isVariableFont ? parsedFontData.tables.fvar.axes.reduce((acc, axis)=>{\n                        var _axis_name;\n                        acc[axis.tag] = {\n                            name: (_axis_name = axis.name) === null || _axis_name === void 0 ? void 0 : _axis_name.en,\n                            min: axis.minValue,\n                            max: axis.maxValue,\n                            default: axis.defaultValue\n                        };\n                        return acc;\n                    }, {}) : null\n                };\n                localFontCache[cacheKey] = metadataToCache;\n            // console.log(`Metadata cached for ${name} (hash: ${cacheKey.substring(0, 8)}...)`); // Удаляем лог\n            }\n        } else {\n            // Парсинг не удался (parsedFontData is null)\n            react_toastify__WEBPACK_IMPORTED_MODULE_0__.toast.warning(\"Не удалось проанализировать шрифт \".concat(name, \". Используются значения по умолчанию.\"));\n            fontObj.availableStyles = [\n                {\n                    name: \"Regular\",\n                    weight: 400,\n                    style: \"normal\"\n                }\n            ];\n        }\n        // Определяем начальные настройки для вариативных шрифтов\n        let initialSettings = {};\n        if (fontObj.isVariableFont && fontObj.variableAxes) {\n            initialSettings = Object.entries(fontObj.variableAxes).reduce((acc, param)=>{\n                let [tag, axis] = param;\n                acc[tag] = axis.default;\n                return acc;\n            }, {});\n        }\n        // !!! Используем loadFontFaceIfNeeded напрямую !!!\n        try {\n            // Вызываем функцию через именованный импорт\n            await (0,_cssGenerator__WEBPACK_IMPORTED_MODULE_3__.loadFontFaceIfNeeded)(fontFamilyName, objectUrl, initialSettings);\n            console.log(\"Font \".concat(fontFamilyName, \" loaded successfully using FontFace API.\"));\n            // Успешно загрузили, возвращаем fontObj\n            revokeObjectURL(objectUrl); // Освобождаем blob URL после успешной загрузки\n            return fontObj;\n        } catch (error) {\n            console.error(\"Failed to load font \".concat(fontFamilyName, \" using FontFace API:\"), error);\n            react_toastify__WEBPACK_IMPORTED_MODULE_0__.toast.error(\"Ошибка при загрузке шрифта \".concat(fontObj.name, \".\"));\n            revokeObjectURL(objectUrl); // Освобождаем blob URL при ошибке\n            fontObj.error = \"Failed to load via FontFace API\";\n            return fontObj; // Возвращаем объект с ошибкой\n        }\n    } catch (error) {\n        console.error(\"Critical error processing font \".concat(name, \":\"), error);\n        react_toastify__WEBPACK_IMPORTED_MODULE_0__.toast.error(\"Критическая ошибка при обработке шрифта \".concat(name, \".\"));\n        if (objectUrl) {\n            revokeObjectURL(objectUrl); // Освобождаем URL при любой критической ошибке\n        }\n        return null; // Возвращаем null при критической ошибке\n    }\n};\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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SXhCO1FBQ3pEWCxpREFBS0EsQ0FBQ1csS0FBSyxDQUFDLDJDQUFnRCxPQUFMd0IsTUFBSztRQUM1RCxJQUFJTyxXQUFXO1lBQ1huQyxnQkFBZ0JtQyxZQUFZLCtDQUErQztRQUMvRTtRQUNBLE9BQU8sTUFBTSx5Q0FBeUM7SUFDeEQ7QUFDRixFQUFFIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL3V0aWxzL2xvY2FsRm9udFByb2Nlc3Nvci5qcz81YzMxIl0sInNvdXJjZXNDb250ZW50IjpbIi8vINCk0YPQvdC60YbQuNC4INC00LvRjyDQvtCx0YDQsNCx0L7RgtC60Lgg0LvQvtC60LDQu9GM0L3QviDQt9Cw0LPRgNGD0LbQtdC90L3Ri9GFINGI0YDQuNGE0YLQvtCyICjQutGN0YjQuNGA0L7QstCw0L3QuNC1LCBGb250RmFjZSlcbmltcG9ydCB7IHRvYXN0IH0gZnJvbSAncmVhY3QtdG9hc3RpZnknO1xuaW1wb3J0IHsgcGFyc2VGb250QnVmZmVyLCBpc1ZhcmlhYmxlRm9udCB9IGZyb20gJy4vZm9udFBhcnNlcic7XG5pbXBvcnQgeyBmaW5kU3R5bGVJbmZvQnlXZWlnaHRBbmRTdHlsZSwgZ2V0Rm9ybWF0RnJvbUV4dGVuc2lvbiB9IGZyb20gJy4vZm9udFV0aWxzQ29tbW9uJztcbmltcG9ydCB7IGxvYWRGb250RmFjZUlmTmVlZGVkIH0gZnJvbSAnLi9jc3NHZW5lcmF0b3InO1xuXG4vKipcbiAqINCa0Y3RiCDQtNC70Y8g0YXRgNCw0L3QtdC90LjRjyDRgNC10LfRg9C70YzRgtCw0YLQvtCyINCw0L3QsNC70LjQt9CwINC70L7QutCw0LvRjNC90YvRhSDRiNGA0LjRhNGC0L7QslxuICog0JrQu9GO0YcgLSDRhdC10Ygg0YHQvtC00LXRgNC20LjQvNC+0LPQviDRiNGA0LjRhNGC0LAuXG4gKiDQl9C90LDRh9C10L3QuNC1IC0g0L7QsdGK0LXQutGCIG1ldGFkYXRhLCDQv9C+0LvRg9GH0LXQvdC90YvQuSDQuNC3INCy0L7RgNC60LXRgNCwLlxuICogQHR5cGUge09iamVjdC48c3RyaW5nLCBPYmplY3Q+fVxuICovXG5jb25zdCBsb2NhbEZvbnRDYWNoZSA9IHt9O1xuXG4vKipcbiAqINCe0YHQstC+0LHQvtC20LTQsNC10YIgVVJMLCDRgdC+0LfQtNCw0L3QvdGL0Lkg0YfQtdGA0LXQtyBVUkwuY3JlYXRlT2JqZWN0VVJMKClcbiAqIEBwYXJhbSB7c3RyaW5nfSB1cmwgLSBVUkwg0LTQu9GPINC+0YHQstC+0LHQvtC20LTQtdC90LjRj1xuICovXG5leHBvcnQgY29uc3QgcmV2b2tlT2JqZWN0VVJMID0gKHVybCkgPT4ge1xuICBpZiAodXJsICYmIHR5cGVvZiB1cmwgPT09ICdzdHJpbmcnICYmIHVybC5zdGFydHNXaXRoKCdibG9iOicpKSB7XG4gICAgdHJ5IHtcbiAgICAgIFVSTC5yZXZva2VPYmplY3RVUkwodXJsKTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS53YXJuKCdGYWlsZWQgdG8gcmV2b2tlIE9iamVjdCBVUkw6JywgZXJyb3IpOyAvLyDQmNGB0L/QvtC70YzQt9GD0LXQvCB3YXJuINCy0LzQtdGB0YLQviBlcnJvclxuICAgICAgLy8gdG9hc3QuZXJyb3IoJ9Ce0YjQuNCx0LrQsCDQv9GA0Lgg0L7RgdCy0L7QsdC+0LbQtNC10L3QuNC4IFVSTCcpOyAvLyDQndC1INGB0L/QsNC80LjQvCDQv9C+0LvRjNC30L7QstCw0YLQtdC70Y9cbiAgICB9XG4gIH1cbn07XG5cbi8qKlxuICog0JDRgdC40L3RhdGA0L7QvdC90L4g0LLRi9GH0LjRgdC70Y/QtdGCIFNIQS0yNTYg0YXQtdGIINC00LvRjyBCbG9iINGE0LDQudC70LAuXG4gKiBAcGFyYW0ge0Jsb2J9IGZpbGUgLSDQpNCw0LnQuyAoQmxvYikuXG4gKiBAcmV0dXJucyB7UHJvbWlzZTxzdHJpbmd8bnVsbD59IC0g0J/RgNC+0LzQuNGBINGBIEhFWC3RgdGC0YDQvtC60L7QuSDRhdC10YjQsCDQuNC70LggbnVsbCDQsiDRgdC70YPRh9Cw0LUg0L7RiNC40LHQutC4LlxuICovXG5jb25zdCBjYWxjdWxhdGVGaWxlSGFzaCA9IGFzeW5jIChmaWxlKSA9PiB7XG4gIGlmICghKGZpbGUgaW5zdGFuY2VvZiBCbG9iKSkge1xuICAgIGNvbnNvbGUuZXJyb3IoJ0ludmFsaWQgaW5wdXQgZm9yIGhhc2hpbmc6IGV4cGVjdGVkIEJsb2IuJyk7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgdHJ5IHtcbiAgICBjb25zdCBidWZmZXIgPSBhd2FpdCBmaWxlLmFycmF5QnVmZmVyKCk7XG4gICAgY29uc3QgaGFzaEJ1ZmZlciA9IGF3YWl0IGNyeXB0by5zdWJ0bGUuZGlnZXN0KCdTSEEtMjU2JywgYnVmZmVyKTtcbiAgICAvLyDQn9GA0LXQvtCx0YDQsNC30YPQtdC8IEFycmF5QnVmZmVyINGF0LXRiNCwINCyIEhFWC3RgdGC0YDQvtC60YNcbiAgICBjb25zdCBoYXNoQXJyYXkgPSBBcnJheS5mcm9tKG5ldyBVaW50OEFycmF5KGhhc2hCdWZmZXIpKTtcbiAgICBjb25zdCBoYXNoSGV4ID0gaGFzaEFycmF5Lm1hcChiID0+IGIudG9TdHJpbmcoMTYpLnBhZFN0YXJ0KDIsICcwJykpLmpvaW4oJycpO1xuICAgIHJldHVybiBoYXNoSGV4O1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGNhbGN1bGF0aW5nIGZpbGUgaGFzaDonLCBlcnJvcik7XG4gICAgdG9hc3QuZXJyb3IoJ9Cd0LUg0YPQtNCw0LvQvtGB0Ywg0LLRi9GH0LjRgdC70LjRgtGMINGF0LXRiCDRhNCw0LnQu9CwINC00LvRjyDQutGN0YjQuNGA0L7QstCw0L3QuNGPLicpO1xuICAgIHJldHVybiBudWxsO1xuICB9XG59O1xuXG4vKipcbiAqINCf0L7Qu9C90L7RgdGC0YzRjiDQsNC90LDQu9C40LfQuNGA0YPQtdGCINC70L7QutCw0LvRjNC90YvQuSDRiNGA0LjRhNGCICjQuNC3INGE0LDQudC70LApLCDQvtC/0YDQtdC00LXQu9GP0Y8g0LXQs9C+INGF0LDRgNCw0LrRgtC10YDQuNGB0YLQuNC60LguXG4gKiDQktC60LvRjtGH0LDQtdGCINC/0LDRgNGB0LjQvdCzLCDQuNC30LLQu9C10YfQtdC90LjQtSDQvNC10YLQsNC00LDQvdC90YvRhSwg0LrRjdGI0LjRgNC+0LLQsNC90LjQtSDQuCDQtNC+0LHQsNCy0LvQtdC90LjQtSBAZm9udC1mYWNlLlxuICogQHBhcmFtIHtPYmplY3R9IGZvbnRJbnB1dCAtINCe0LHRitC10LrRgiDRiNGA0LjRhNGC0LAg0YEgZmlsZSAoQmxvYikg0LggbmFtZSAoc3RyaW5nKVxuICogQHJldHVybnMge1Byb21pc2U8T2JqZWN0fG51bGw+fSAtINCf0YDQvtC80LjRgSDRgSDQvtCx0YDQsNCx0L7RgtCw0L3QvdGL0Lwg0L7QsdGK0LXQutGC0L7QvCDRiNGA0LjRhNGC0LAg0LjQu9C4IG51bGwg0L/RgNC4INC60YDQuNGC0LjRh9C10YHQutC+0Lkg0L7RiNC40LHQutC1LlxuICovXG5leHBvcnQgY29uc3QgcHJvY2Vzc0xvY2FsRm9udCA9IGFzeW5jIChmb250SW5wdXQpID0+IHtcbiAgaWYgKCFmb250SW5wdXQgfHwgIShmb250SW5wdXQuZmlsZSBpbnN0YW5jZW9mIEJsb2IpIHx8ICFmb250SW5wdXQubmFtZSkge1xuICAgIHRvYXN0LmVycm9yKCfQndC10LLQtdGA0L3Ri9C1INCy0YXQvtC00L3Ri9C1INC00LDQvdC90YvQtSDQtNC70Y8g0L7QsdGA0LDQsdC+0YLQutC4INC70L7QutCw0LvRjNC90L7Qs9C+INGI0YDQuNGE0YLQsC4nKTtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIGNvbnN0IHsgZmlsZSwgbmFtZSB9ID0gZm9udElucHV0O1xuICBjb25zdCBmb250SWQgPSBNYXRoLnJhbmRvbSgpLnRvU3RyaW5nKDM2KS5zdWJzdHJpbmcoMiwgOSk7IC8vINCa0L7RgNC+0YLQutC40LkgSUQg0LTQu9GPINGH0LjRgtCw0LXQvNC+0YHRgtC4XG4gIGNvbnN0IGNsZWFuZWROYW1lID0gbmFtZS5yZXBsYWNlKC9cXC5bXi8uXSskLywgJycpO1xuICBsZXQgb2JqZWN0VXJsID0gbnVsbDtcbiAgbGV0IGNhY2hlS2V5ID0gbnVsbDsgLy8g0JjQvdC40YbQuNCw0LvQuNC30LjRgNGD0LXQvCBjYWNoZUtleVxuXG4gIHRyeSB7XG4gICAgLy8gMS4g0JLRi9GH0LjRgdC70Y/QtdC8INGF0LXRiCDRhNCw0LnQu9CwINC00LvRjyDQuNGB0L/QvtC70YzQt9C+0LLQsNC90LjRjyDQsiDQutCw0YfQtdGB0YLQstC1INC60LvRjtGH0LAg0LrRjdGI0LBcbiAgICBjYWNoZUtleSA9IGF3YWl0IGNhbGN1bGF0ZUZpbGVIYXNoKGZpbGUpO1xuICAgIGlmICghY2FjaGVLZXkpIHtcbiAgICAgIC8vINCV0YHQu9C4INGF0LXRiCDQvdC1INGD0LTQsNC70L7RgdGMINC/0L7Qu9GD0YfQuNGC0YwsINC60Y3RiNC40YDQvtCy0LDQvdC40LUg0L3QtdCy0L7Qt9C80L7QttC90L4sINC90L4g0L/RgNC+0LTQvtC70LbQsNC10Lwg0L7QsdGA0LDQsdC+0YLQutGDXG4gICAgICB0b2FzdC53YXJuaW5nKCfQndC1INGD0LTQsNC70L7RgdGMINGB0L7Qt9C00LDRgtGMINC60LvRjtGHINC60Y3RiNCwINC00LvRjyDRiNGA0LjRhNGC0LAsINC60Y3RiNC40YDQvtCy0LDQvdC40LUg0LHRg9C00LXRgiDQv9GA0L7Qv9GD0YnQtdC90L4uJyk7XG4gICAgfVxuXG4gICAgLy8gMi4g0J/RgNC+0LLQtdGA0LrQsCDQutGN0YjQsCAo0YLQtdC/0LXRgNGMINC/0L4g0YXQtdGI0YMpXG4gICAgaWYgKGNhY2hlS2V5ICYmIGxvY2FsRm9udENhY2hlW2NhY2hlS2V5XSkge1xuICAgICAgY29uc29sZS5sb2coYFVzaW5nIGNhY2hlZCBtZXRhZGF0YSBmb3IgJHtuYW1lfSAoaGFzaDogJHtjYWNoZUtleS5zdWJzdHJpbmcoMCwgOCl9Li4uKWApOyAvLyDQm9C+0LMg0LTQu9GPINC+0YLQu9Cw0LTQutC4XG4gICAgICBvYmplY3RVcmwgPSBVUkwuY3JlYXRlT2JqZWN0VVJMKGZpbGUpOyAvLyDQodCy0LXQttC40LkgVVJMINC90YPQttC10L0g0LLRgdC10LPQtNCwXG4gICAgICBjb25zdCBjYWNoZWRNZXRhZGF0YSA9IHsgLi4ubG9jYWxGb250Q2FjaGVbY2FjaGVLZXldIH07IC8vINCf0L7Qu9GD0YfQsNC10Lwg0LzQtdGC0LDQtNCw0L3QvdGL0LUg0LjQtyDQutGN0YjQsFxuXG4gICAgICBjb25zdCBmb250RmFtaWx5TmFtZSA9IGBmb250LSR7Zm9udElkfWA7IC8vINCT0LXQvdC10YDQuNGA0YPQtdC8INGD0L3QuNC60LDQu9GM0L3QvtC1INC40LzRj1xuXG4gICAgICAvLyDQodC+0LfQtNCw0LXQvCBmb250T2JqINC90LAg0L7RgdC90L7QstC1INC60Y3RiNC40YDQvtCy0LDQvdC90YvRhSDQvNC10YLQsNC00LDQvdC90YvRhVxuICAgICAgY29uc3QgZm9udE9iaiA9IHtcbiAgICAgICAgaWQ6IGZvbnRJZCxcbiAgICAgICAgbmFtZTogY2FjaGVkTWV0YWRhdGEucHJlZmVycmVkRmFtaWx5IHx8IGNhY2hlZE1ldGFkYXRhLm5hbWVzPy5mb250RmFtaWx5IHx8IGNsZWFuZWROYW1lLCAvLyDQmNGB0L/QvtC70YzQt9GD0LXQvCDQuNC80LXQvdCwINC40Lcg0LrRjdGI0LBcbiAgICAgICAgb3JpZ2luYWxOYW1lOiBuYW1lLFxuICAgICAgICBzb3VyY2U6ICdsb2NhbCcsXG4gICAgICAgIGN1cnJlbnRXZWlnaHQ6IDQwMCwgLy8g0JHRg9C00LXRgiDRg9GC0L7Rh9C90LXQvdC+INC90LjQttC1XG4gICAgICAgIGN1cnJlbnRTdHlsZTogJ25vcm1hbCcsIC8vINCR0YPQtNC10YIg0YPRgtC+0YfQvdC10L3QviDQvdC40LbQtVxuICAgICAgICBpc1ZhcmlhYmxlRm9udDogY2FjaGVkTWV0YWRhdGEuaXNWYXJpYWJsZSB8fCBmYWxzZSwgLy8g0JjRgdC/0L7Qu9GM0LfRg9C10Lwg0YTQu9Cw0LMg0LjQtyDQutGN0YjQsFxuICAgICAgICB2YXJpYWJsZUF4ZXM6IHt9LFxuICAgICAgICBzdXBwb3J0ZWRBeGVzOiBbXSxcbiAgICAgICAgdmFyaWF0aW9uU2V0dGluZ3M6ICcnLFxuICAgICAgICBhdmFpbGFibGVTdHlsZXM6IFtdLFxuICAgICAgICBmaWxlOiBmaWxlLCAvLyDQntGB0YLQsNCy0LvRj9C10Lwg0YTQsNC50Lsg0LTQu9GPINCy0L7Qt9C80L7QttC90L7Qs9C+INC/0L7QstGC0L7RgNC90L7Qs9C+INC40YHQv9C+0LvRjNC30L7QstCw0L3QuNGPXG4gICAgICAgIHVybDogb2JqZWN0VXJsLCAvLyDQodC+0YXRgNCw0L3Rj9C10LwgYmxvYiBVUkwg0LTQu9GPIEZvbnRGYWNlIEFQSVxuICAgICAgICBmb250RmFtaWx5OiBmb250RmFtaWx5TmFtZSwgLy8g0KHQvtGF0YDQsNC90Y/QtdC8INGB0LPQtdC90LXRgNC40YDQvtCy0LDQvdC90L7QtSDQuNC80Y8hXG4gICAgICB9O1xuXG4gICAgICAvLyDQktC+0YHRgdGC0LDQvdCw0LLQu9C40LLQsNC10Lwg0L7RgdC4INC4INGB0YLQuNC70Lgg0LjQtyDQutGN0YjQuNGA0L7QstCw0L3QvdGL0YUg0LzQtdGC0LDQtNCw0L3QvdGL0YVcbiAgICAgIGlmIChmb250T2JqLmlzVmFyaWFibGVGb250ICYmIGNhY2hlZE1ldGFkYXRhLnN1cHBvcnRlZEF4ZXMpIHtcbiAgICAgICAgIC8vINCX0LDQv9C+0LvQvdGP0LXQvCDQuNC90YTQvtGA0LzQsNGG0LjRjiDQvtCxINC+0YHRj9GFINC40Lcg0LrRjdGI0LBcbiAgICAgICAgIGZvbnRPYmoudmFyaWFibGVBeGVzID0gT2JqZWN0LmVudHJpZXMoY2FjaGVkTWV0YWRhdGEuc3VwcG9ydGVkQXhlcykucmVkdWNlKChhY2MsIFt0YWcsIGF4aXNJbmZvXSkgPT4ge1xuICAgICAgICAgICAgICAgIGFjY1t0YWddID0geyBuYW1lOiBheGlzSW5mby5uYW1lIHx8IHRhZy50b1VwcGVyQ2FzZSgpLCBtaW46IGF4aXNJbmZvLm1pbiwgbWF4OiBheGlzSW5mby5tYXgsIGRlZmF1bHQ6IGF4aXNJbmZvLmRlZmF1bHQgfTtcbiAgICAgICAgICAgICAgICByZXR1cm4gYWNjO1xuICAgICAgICAgfSwge30pO1xuICAgICAgICAgZm9udE9iai5zdXBwb3J0ZWRBeGVzID0gT2JqZWN0LmtleXMoY2FjaGVkTWV0YWRhdGEuc3VwcG9ydGVkQXhlcyk7XG4gICAgICAgICBmb250T2JqLnZhcmlhdGlvblNldHRpbmdzID0gT2JqZWN0LmVudHJpZXMoZm9udE9iai52YXJpYWJsZUF4ZXMpXG4gICAgICAgICAgICAubWFwKChbdGFnLCB2YWx1ZV0pID0+IGBcXFwiJHt0YWd9XFxcIiAke3ZhbHVlLmRlZmF1bHQgfHwgNDAwfWApIC8vINCX0LDQv9Cw0YHQvdC+0LUg0LfQvdCw0YfQtdC90LjQtSDQtNC70Y8g0LLQtdGB0LBcbiAgICAgICAgICAgIC5qb2luKCcsICcpO1xuICAgICAgICAgLy8g0J7Qv9GA0LXQtNC10LvRj9C10Lwg0L3QsNGH0LDQu9GM0L3Ri9C1INGB0YLQuNC70Lgg0LTQu9GPINCy0LDRgNC40LDRgtC40LLQvdGL0YUg0YjRgNC40YTRgtC+0LIg0LjQtyDQutGN0YjQsCAo0LzQvtC20LXRgiDQsdGL0YLRjCDQv9C10YDQtdGB0LzQvtGC0YDQtdC90L4pXG4gICAgICAgICAvLyDQn9C+0LrQsCDQvtGB0YLQsNCy0LvRj9C10Lwg0LfQsNCz0LvRg9GI0LrRgyDQuNC70Lgg0L7Qv9GA0LXQtNC10LvRj9C10Lwg0L3QsCDQvtGB0L3QvtCy0LUg0LTQtdGE0L7Qu9GC0L3Ri9GFINC+0YHQtdC5LCDQtdGB0LvQuCDQstC+0LfQvNC+0LbQvdC+XG4gICAgICAgICAvLyBUT0RPOiDQo9GC0L7Rh9C90LjRgtGMINC70L7Qs9C40LrRgyBhdmFpbGFibGVTdHlsZXMg0LTQu9GPINCy0LDRgNC40LDRgtC40LLQvdGL0YUg0LjQtyDQutGN0YjQsFxuICAgICAgICAgZm9udE9iai5hdmFpbGFibGVTdHlsZXMgPSBbeyBuYW1lOiAnRGVmYXVsdCcsIHdlaWdodDogNDAwLCBzdHlsZTogJ25vcm1hbCcgfV07IC8vINCX0LDQs9C70YPRiNC60LBcbiAgICAgIH0gZWxzZSBpZiAoIWZvbnRPYmouaXNWYXJpYWJsZUZvbnQgJiYgY2FjaGVkTWV0YWRhdGEubmFtZXMpIHtcbiAgICAgICAgIC8vINCe0L/RgNC10LTQtdC70Y/QtdC8INGB0YLQuNC70Ywv0LLQtdGBINC00LvRjyDQvdC10LLQsNGA0LjQsNGC0LjQstC90YvRhSDQuNC3INC60Y3RiNCwXG4gICAgICAgICBsZXQgd2VpZ2h0ID0gNDAwO1xuICAgICAgICAgbGV0IHN0eWxlID0gJ25vcm1hbCc7XG4gICAgICAgICBjb25zdCBzdWJmYW1pbHkgPSBjYWNoZWRNZXRhZGF0YS5wcmVmZXJyZWRTdWJmYW1pbHkgfHwgY2FjaGVkTWV0YWRhdGEubmFtZXM/LmZvbnRTdWJmYW1pbHkgfHwgJ1JlZ3VsYXInO1xuICAgICAgICAgY29uc3Qgc3ViZmFtaWx5TG93ZXIgPSBzdWJmYW1pbHkudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgIHN0eWxlID0gKHN1YmZhbWlseUxvd2VyLmluY2x1ZGVzKCdpdGFsaWMnKSB8fCBzdWJmYW1pbHlMb3dlci5pbmNsdWRlcygnb2JsaXF1ZScpKSA/ICdpdGFsaWMnIDogJ25vcm1hbCc7XG4gICAgICAgICAvLyAuLi4gKNC70L7Qs9C40LrQsCDQvtC/0YDQtdC00LXQu9C10L3QuNGPINCy0LXRgdCwINC40Lcgc3ViZmFtaWx5KSAuLi5cbiAgICAgICAgICBpZiAoc3ViZmFtaWx5TG93ZXIuaW5jbHVkZXMoJ3RoaW4nKSkgd2VpZ2h0ID0gMTAwO1xuICAgICAgICAgIGVsc2UgaWYgKHN1YmZhbWlseUxvd2VyLmluY2x1ZGVzKCdleHRyYWxpZ2h0JykgfHwgc3ViZmFtaWx5TG93ZXIuaW5jbHVkZXMoJ3VsdHJhbGlnaHQnKSkgd2VpZ2h0ID0gMjAwO1xuICAgICAgICAgIGVsc2UgaWYgKHN1YmZhbWlseUxvd2VyLmluY2x1ZGVzKCdsaWdodCcpKSB3ZWlnaHQgPSAzMDA7XG4gICAgICAgICAgZWxzZSBpZiAoc3ViZmFtaWx5TG93ZXIuaW5jbHVkZXMoJ21lZGl1bScpKSB3ZWlnaHQgPSA1MDA7XG4gICAgICAgICAgZWxzZSBpZiAoc3ViZmFtaWx5TG93ZXIuaW5jbHVkZXMoJ3NlbWlib2xkJykgfHwgc3ViZmFtaWx5TG93ZXIuaW5jbHVkZXMoJ2RlbWlib2xkJykpIHdlaWdodCA9IDYwMDtcbiAgICAgICAgICBlbHNlIGlmIChzdWJmYW1pbHlMb3dlci5pbmNsdWRlcygnYm9sZCcpKSB3ZWlnaHQgPSA3MDA7XG4gICAgICAgICAgZWxzZSBpZiAoc3ViZmFtaWx5TG93ZXIuaW5jbHVkZXMoJ2V4dHJhYm9sZCcpIHx8IHN1YmZhbWlseUxvd2VyLmluY2x1ZGVzKCd1bHRyYWJvbGQnKSkgd2VpZ2h0ID0gODAwO1xuICAgICAgICAgIGVsc2UgaWYgKHN1YmZhbWlseUxvd2VyLmluY2x1ZGVzKCdibGFjaycpIHx8IHN1YmZhbWlseUxvd2VyLmluY2x1ZGVzKCdoZWF2eScpKSB3ZWlnaHQgPSA5MDA7XG5cbiAgICAgICAgIGZvbnRPYmouY3VycmVudFdlaWdodCA9IHdlaWdodDtcbiAgICAgICAgIGZvbnRPYmouY3VycmVudFN0eWxlID0gc3R5bGU7XG4gICAgICAgICBjb25zdCBzdHlsZUluZm8gPSBmaW5kU3R5bGVJbmZvQnlXZWlnaHRBbmRTdHlsZSh3ZWlnaHQsIHN0eWxlKTtcbiAgICAgICAgIGZvbnRPYmouYXZhaWxhYmxlU3R5bGVzID0gW3sgbmFtZTogc3R5bGVJbmZvLm5hbWUsIHdlaWdodCwgc3R5bGUgfV07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vINCV0YHQu9C4INGB0YLQuNC70LXQuSDQvdC10YIg0LIg0LrRjdGI0LUgKNC90LDQv9GA0LjQvNC10YAsINGB0YLQsNGA0YvQuSDQutGN0Ygg0LjQu9C4INC+0YjQuNCx0LrQsCDQv9Cw0YDRgdC40L3Qs9CwINC/0YDQuCDQutGN0YjQuNGA0L7QstCw0L3QuNC4KVxuICAgICAgICAgIGZvbnRPYmouYXZhaWxhYmxlU3R5bGVzID0gW3sgbmFtZTogJ1JlZ3VsYXInLCB3ZWlnaHQ6IDQwMCwgc3R5bGU6ICdub3JtYWwnIH1dO1xuICAgICAgfVxuXG4gICAgICAvLyDQntC/0YDQtdC00LXQu9GP0LXQvCDQvdCw0YfQsNC70YzQvdGL0LUg0L3QsNGB0YLRgNC+0LnQutC4INC00LvRjyDQstCw0YDQuNCw0YLQuNCy0L3Ri9GFINGI0YDQuNGE0YLQvtCyINC40Lcg0LrRjdGI0LBcbiAgICAgIGxldCBpbml0aWFsU2V0dGluZ3MgPSB7fTtcbiAgICAgIGlmIChmb250T2JqLmlzVmFyaWFibGVGb250ICYmIGZvbnRPYmoudmFyaWFibGVBeGVzKSB7XG4gICAgICAgIGluaXRpYWxTZXR0aW5ncyA9IE9iamVjdC5lbnRyaWVzKGZvbnRPYmoudmFyaWFibGVBeGVzKS5yZWR1Y2UoKGFjYywgW3RhZywgYXhpc10pID0+IHtcbiAgICAgICAgICBhY2NbdGFnXSA9IGF4aXMuZGVmYXVsdDtcbiAgICAgICAgICByZXR1cm4gYWNjO1xuICAgICAgICB9LCB7fSk7XG4gICAgICB9XG5cbiAgICAgIC8vICEhISDQmNGB0L/QvtC70YzQt9GD0LXQvCBsb2FkRm9udEZhY2VJZk5lZWRlZCDQvdCw0L/RgNGP0LzRg9GOICEhIVxuICAgICAgdHJ5IHtcbiAgICAgICAgLy8g0JLRi9C30YvQstCw0LXQvCDRhNGD0L3QutGG0LjRjiDRh9C10YDQtdC3INC40LzQtdC90L7QstCw0L3QvdGL0Lkg0LjQvNC/0L7RgNGCXG4gICAgICAgIGF3YWl0IGxvYWRGb250RmFjZUlmTmVlZGVkKGZvbnRGYW1pbHlOYW1lLCBvYmplY3RVcmwsIGluaXRpYWxTZXR0aW5ncyk7XG4gICAgICAgIGNvbnNvbGUubG9nKGBGb250ICR7Zm9udEZhbWlseU5hbWV9IGxvYWRlZCBzdWNjZXNzZnVsbHkgZnJvbSBjYWNoZSB1c2luZyBGb250RmFjZSBBUEkuYCk7XG4gICAgICAgIC8vINCj0YHQv9C10YjQvdC+INC30LDQs9GA0YPQt9C40LvQuCwg0LLQvtC30LLRgNCw0YnQsNC10LwgZm9udE9ialxuICAgICAgICByZXZva2VPYmplY3RVUkwob2JqZWN0VXJsKTsgLy8g0J7RgdCy0L7QsdC+0LbQtNCw0LXQvCBibG9iIFVSTCDQv9C+0YHQu9C1INGD0YHQv9C10YjQvdC+0Lkg0LfQsNCz0YDRg9C30LrQuFxuICAgICAgICByZXR1cm4gZm9udE9iajtcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoYEZhaWxlZCB0byBsb2FkIGZvbnQgJHtmb250RmFtaWx5TmFtZX0gZnJvbSBjYWNoZSB1c2luZyBGb250RmFjZSBBUEk6YCwgZXJyb3IpO1xuICAgICAgICB0b2FzdC5lcnJvcihg0J7RiNC40LHQutCwINC/0YDQuCDQt9Cw0LPRgNGD0LfQutC1INGI0YDQuNGE0YLQsCAke2ZvbnRPYmoubmFtZX0g0LjQtyDQutGN0YjQsC5gKTtcbiAgICAgICAgcmV2b2tlT2JqZWN0VVJMKG9iamVjdFVybCk7IC8vINCe0YHQstC+0LHQvtC20LTQsNC10LwgYmxvYiBVUkwg0L/RgNC4INC+0YjQuNCx0LrQtVxuICAgICAgICBmb250T2JqLmVycm9yID0gJ0ZhaWxlZCB0byBsb2FkIHZpYSBGb250RmFjZSBBUEknO1xuICAgICAgICByZXR1cm4gZm9udE9iajsgLy8g0JLQvtC30LLRgNCw0YnQsNC10Lwg0L7QsdGK0LXQutGCINGBINC+0YjQuNCx0LrQvtC5XG4gICAgfVxuICAgIC8vIC0tLSDQmtC+0L3QtdGGINC+0LHRgNCw0LHQvtGC0LrQuCDQutGN0YjQsCAtLS1cbiAgICB9XG4gICAgLy8gLS0tINCa0L7QvdC10YYg0L/RgNC+0LLQtdGA0LrQuCDQutGN0YjQsCAtLS1cblxuXG4gICAgLy8gMy4g0KHQvtC30LTQsNC90LjQtSBVUkwgKNC10YHQu9C4INC90LUg0LjQtyDQutGN0YjQsClcbiAgICBpZiAoIW9iamVjdFVybCkge1xuICAgICAgICBvYmplY3RVcmwgPSBVUkwuY3JlYXRlT2JqZWN0VVJMKGZpbGUpO1xuICAgIH1cblxuICAgIC8vIDQuINCf0LDRgNGB0LjQvdCzINGE0LDQudC70LAgLT4g0L/QvtC70YPRh9C10L3QuNC1INC/0L7Qu9C90L7Qs9C+INC+0LHRitC10LrRgtCwINGI0YDQuNGE0YLQsCDRh9C10YDQtdC3IHBhcnNlRm9udEJ1ZmZlclxuICAgIC8vIHBhcnNlRm9udEZpbGUg0YLQtdC/0LXRgNGMINCy0L7Qt9Cy0YDQsNGJ0LDQtdGCINC+0LHRitC10LrRgiBtZXRhZGF0YSDQuNC70LggbnVsbFxuICAgIGxldCBwYXJzZWRGb250RGF0YSA9IG51bGw7XG4gICAgdHJ5IHtcbiAgICAgICBjb25zdCBidWZmZXIgPSBhd2FpdCBmaWxlLmFycmF5QnVmZmVyKCk7XG4gICAgICAgcGFyc2VkRm9udERhdGEgPSBhd2FpdCBwYXJzZUZvbnRCdWZmZXIoYnVmZmVyKTsgLy8g0JjRgdC/0L7Qu9GM0LfRg9C10LwgcGFyc2VGb250QnVmZmVyXG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBjb25zb2xlLmVycm9yKGBFcnJvciByZWFkaW5nIG9yIHBhcnNpbmcgZm9udCBidWZmZXIgZm9yICR7bmFtZX06YCwgZSk7XG4gICAgICAgIHRvYXN0LmVycm9yKGDQntGI0LjQsdC60LAg0YfRgtC10L3QuNGPINC40LvQuCDQsNC90LDQu9C40LfQsCDRhNCw0LnQu9CwINGI0YDQuNGE0YLQsCAke25hbWV9LmApO1xuICAgICAgICAvLyDQndC1INCy0L7Qt9Cy0YDQsNGJ0LDQtdC8IG51bGwg0YHRgNCw0LfRgywg0YIu0LouIGFkZEZvbnRGYWNlINC80L7QttC10YIg0YDQsNCx0L7RgtCw0YLRjCDRgSDQsdCw0LfQvtCy0YvQvCBmb250T2JqXG4gICAgfVxuXG4gICAgLy8g0KHQvtC30LTQsNC10Lwg0LHQsNC30L7QstGL0Lkg0L7QsdGK0LXQutGCINGI0YDQuNGE0YLQsCAo0LrQsNC6INC4INGA0LDQvdGM0YjQtSlcbiAgICBjb25zdCBmb250T2JqID0ge1xuICAgICAgaWQ6IGZvbnRJZCxcbiAgICAgIG5hbWU6IGNsZWFuZWROYW1lLCAvLyDQo9GC0L7Rh9C90LjQvCDQuNC3IG1ldGFkYXRhXG4gICAgICBvcmlnaW5hbE5hbWU6IG5hbWUsXG4gICAgICBzb3VyY2U6ICdsb2NhbCcsXG4gICAgICBjdXJyZW50V2VpZ2h0OiA0MDAsXG4gICAgICBjdXJyZW50U3R5bGU6ICdub3JtYWwnLFxuICAgICAgaXNWYXJpYWJsZUZvbnQ6IGZhbHNlLCAvLyDQo9GC0L7Rh9C90LjQvCDQuNC3IG1ldGFkYXRhXG4gICAgICB2YXJpYWJsZUF4ZXM6IHt9LFxuICAgICAgc3VwcG9ydGVkQXhlczogW10sXG4gICAgICB2YXJpYXRpb25TZXR0aW5nczogJycsXG4gICAgICBhdmFpbGFibGVTdHlsZXM6IFtdLFxuICAgICAgZmlsZTogZmlsZSxcbiAgICAgIC8vIHVybDogb2JqZWN0VXJsLCAvLyDQo9GB0YLQsNC90LDQstC70LjQstCw0LXQvCDQvdC40LbQtSwg0L/QvtGB0LvQtSDRgdC+0LfQtNCw0L3QuNGPIGZvbnRGYW1pbHlOYW1lXG4gICAgICBmb250RmFtaWx5OiBudWxsLCAvLyDQo9GB0YLQsNC90L7QstC40Lwg0L3QuNC20LVcbiAgICB9O1xuXG4gICAgLy8g0KPRgdGC0LDQvdC+0LLQuNC8IGZvbnRPYmoudXJsINC4IGZvbnRPYmouZm9udEZhbWlseVxuICAgIGNvbnN0IGZvbnRGYW1pbHlOYW1lID0gYGZvbnQtJHtmb250SWR9YDtcbiAgICBmb250T2JqLnVybCA9IG9iamVjdFVybDtcbiAgICBmb250T2JqLmZvbnRGYW1pbHkgPSBmb250RmFtaWx5TmFtZTtcblxuICAgIC8vIDUuINCX0LDQv9C+0LvQvdC10L3QuNC1IGZvbnRPYmog0LjQtyDQtNCw0L3QvdGL0YUg0L/QsNGA0YHQuNC90LPQsCwg0LXRgdC70Lgg0L/QsNGA0YHQuNC90LMg0YPRgdC/0LXRiNC10L1cbiAgICBpZiAocGFyc2VkRm9udERhdGEpIHsgLy8g0J3QvtCy0LDRjyDQv9GA0L7QstC10YDQutCwXG4gICAgICAvLyDQmNGB0L/QvtC70YzQt9GD0LXQvCDQtNCw0L3QvdGL0LUg0LjQtyDQvtCx0YrQtdC60YLQsCBwYXJzZWRGb250RGF0YSAo0YDQtdC30YPQu9GM0YLQsNGCIG9wZW50eXBlLnBhcnNlKVxuICAgICAgLy8g0J/QvtC70YPRh9Cw0LXQvCDQuNC80LXQvdCwICjQv9GA0LXQtNC/0L7Rh9C40YLQsNC10Lwg0LDQvdCz0LvQuNC50YHQutC40LUpXG4gICAgICBjb25zdCBuYW1lcyA9IHBhcnNlZEZvbnREYXRhLm5hbWVzIHx8IHt9O1xuICAgICAgY29uc3QgcHJlZmVycmVkRmFtaWx5ID0gbmFtZXMucHJlZmVycmVkRmFtaWx5Py5lbiB8fCBuYW1lcy5mb250RmFtaWx5Py5lbjtcbiAgICAgIGNvbnN0IHByZWZlcnJlZFN1YmZhbWlseSA9IG5hbWVzLnByZWZlcnJlZFN1YmZhbWlseT8uZW4gfHwgbmFtZXMuZm9udFN1YmZhbWlseT8uZW4gfHwgJ1JlZ3VsYXInO1xuXG4gICAgICBmb250T2JqLm5hbWUgPSBwcmVmZXJyZWRGYW1pbHkgfHwgZm9udE9iai5uYW1lO1xuICAgICAgZm9udE9iai5pc1ZhcmlhYmxlRm9udCA9IGlzVmFyaWFibGVGb250KHBhcnNlZEZvbnREYXRhKTsgLy8g0JjRgdC/0L7Qu9GM0LfRg9C10LwgaXNWYXJpYWJsZUZvbnRcblxuICAgICAgaWYgKGZvbnRPYmouaXNWYXJpYWJsZUZvbnQgJiYgcGFyc2VkRm9udERhdGEudGFibGVzPy5mdmFyPy5heGVzKSB7XG4gICAgICAgICAvLyDQl9Cw0L/QvtC70L3Rj9C10Lwg0LjQvdGE0L7RgNC80LDRhtC40Y4g0L7QsSDQvtGB0Y/RhSDQuNC3IHBhcnNlZEZvbnREYXRhLnRhYmxlcy5mdmFyLmF4ZXNcbiAgICAgICAgIGZvbnRPYmoudmFyaWFibGVBeGVzID0gcGFyc2VkRm9udERhdGEudGFibGVzLmZ2YXIuYXhlcy5yZWR1Y2UoKGFjYywgYXhpcykgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHRhZyA9IGF4aXMudGFnO1xuICAgICAgICAgICAgICAgIC8vINCY0YHQv9C+0LvRjNC30YPQtdC8INC40LzRjyDQuNC3IGF4aXMubmFtZT8uZW4sINC10YHQu9C4INC+0L3QviDQtdGB0YLRjFxuICAgICAgICAgICAgICAgIGNvbnN0IGF4aXNOYW1lID0gYXhpcy5uYW1lPy5lbiB8fCB0YWcudG9VcHBlckNhc2UoKTtcbiAgICAgICAgICAgICAgICAgYWNjW3RhZ10gPSB7IG5hbWU6IGF4aXNOYW1lLCBtaW46IGF4aXMubWluVmFsdWUsIG1heDogYXhpcy5tYXhWYWx1ZSwgZGVmYXVsdDogYXhpcy5kZWZhdWx0VmFsdWUgfTtcbiAgICAgICAgICAgICAgICByZXR1cm4gYWNjO1xuICAgICAgICAgfSwge30pO1xuICAgICAgICAgZm9udE9iai5zdXBwb3J0ZWRBeGVzID0gT2JqZWN0LmtleXMoZm9udE9iai52YXJpYWJsZUF4ZXMpO1xuICAgICAgICAgZm9udE9iai52YXJpYXRpb25TZXR0aW5ncyA9IE9iamVjdC5lbnRyaWVzKGZvbnRPYmoudmFyaWFibGVBeGVzKVxuICAgICAgICAgICAgLm1hcCgoW3RhZywgdmFsdWVdKSA9PiBgXFxcIiR7dGFnfVxcXCIgJHt2YWx1ZS5kZWZhdWx0IHx8IDQwMH1gKSAvLyDQl9Cw0L/QsNGB0L3QvtC1INC30L3QsNGH0LXQvdC40LUg0LTQu9GPINCy0LXRgdCwXG4gICAgICAgICAgICAuam9pbignLCAnKTtcbiAgICAgICAgIGZvbnRPYmouYXZhaWxhYmxlU3R5bGVzID0gW3sgbmFtZTogJ0RlZmF1bHQnLCB3ZWlnaHQ6IDQwMCwgc3R5bGU6ICdub3JtYWwnIH1dOyAvLyDQl9Cw0LPQu9GD0YjQutCwXG4gICAgICB9IGVsc2UgaWYgKGZvbnRPYmouaXNWYXJpYWJsZUZvbnQgJiYgIXBhcnNlZEZvbnREYXRhLnRhYmxlcz8uZnZhcj8uYXhlcykge1xuICAgICAgICAgLy8g0JLQsNGA0LjQsNGC0LjQstC90YvQuSwg0L3QviDQvtGB0Lgg0L3QtSDQuNC30LLQu9C10LrQu9C40YHRjFxuICAgICAgICAgY29uc29sZS53YXJuKGBWYXJpYWJsZSBmb250ICR7bmFtZX0gcGFyc2VkIHdpdGhvdXQgYXhlcyBpbmZvLmApO1xuICAgICAgICAgZm9udE9iai5pc1ZhcmlhYmxlRm9udCA9IGZhbHNlOyAvLyDQodGH0LjRgtCw0LXQvCDQvdC10LLQsNGA0LjQsNGC0LjQstC90YvQvFxuICAgICAgICAgZm9udE9iai5hdmFpbGFibGVTdHlsZXMgPSBbeyBuYW1lOiAnUmVndWxhcicsIHdlaWdodDogNDAwLCBzdHlsZTogJ25vcm1hbCcgfV07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyDQndCV0LLQsNGA0LjQsNGC0LjQstC90YvQuSDRiNGA0LjRhNGCIC0g0L7Qv9GA0LXQtNC10LvRj9C10Lwg0YHRgtC40LvRjCDQuNC3INC40LzQtdC9XG4gICAgICAgIGxldCB3ZWlnaHQgPSA0MDA7XG4gICAgICAgIGxldCBzdHlsZSA9ICdub3JtYWwnO1xuICAgICAgICBpZiAobmFtZXMpIHsgLy8g0J3QvtCy0LDRjyDQv9GA0L7QstC10YDQutCwXG4gICAgICAgICAgIGNvbnN0IHN1YmZhbWlseSA9IHByZWZlcnJlZFN1YmZhbWlseTsgLy8g0JjRgdC/0L7Qu9GM0LfRg9C10Lwg0LjQt9Cy0LvQtdGH0LXQvdC90L7QtSDQuNC80Y9cbiAgICAgICAgICAgY29uc3Qgc3ViZmFtaWx5TG93ZXIgPSBzdWJmYW1pbHkudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICAgIHN0eWxlID0gKHN1YmZhbWlseUxvd2VyLmluY2x1ZGVzKCdpdGFsaWMnKSB8fCBzdWJmYW1pbHlMb3dlci5pbmNsdWRlcygnb2JsaXF1ZScpKSA/ICdpdGFsaWMnIDogJ25vcm1hbCc7XG4gICAgICAgICAgICAvLyAuLi4gKNC70L7Qs9C40LrQsCDQvtC/0YDQtdC00LXQu9C10L3QuNGPINCy0LXRgdCwINC40Lcgc3ViZmFtaWx5IC0g0LHQtdC3INC40LfQvNC10L3QtdC90LjQuSkgLi4uXG4gICAgICAgICAgICBpZiAoc3ViZmFtaWx5TG93ZXIuaW5jbHVkZXMoJ3RoaW4nKSkgd2VpZ2h0ID0gMTAwO1xuICAgICAgICAgICAgZWxzZSBpZiAoc3ViZmFtaWx5TG93ZXIuaW5jbHVkZXMoJ2V4dHJhbGlnaHQnKSB8fCBzdWJmYW1pbHlMb3dlci5pbmNsdWRlcygndWx0cmFsaWdodCcpKSB3ZWlnaHQgPSAyMDA7XG4gICAgICAgICAgICBlbHNlIGlmIChzdWJmYW1pbHlMb3dlci5pbmNsdWRlcygnbGlnaHQnKSkgd2VpZ2h0ID0gMzAwO1xuICAgICAgICAgICAgZWxzZSBpZiAoc3ViZmFtaWx5TG93ZXIuaW5jbHVkZXMoJ21lZGl1bScpKSB3ZWlnaHQgPSA1MDA7XG4gICAgICAgICAgICBlbHNlIGlmIChzdWJmYW1pbHlMb3dlci5pbmNsdWRlcygnc2VtaWJvbGQnKSB8fCBzdWJmYW1pbHlMb3dlci5pbmNsdWRlcygnZGVtaWJvbGQnKSkgd2VpZ2h0ID0gNjAwO1xuICAgICAgICAgICAgZWxzZSBpZiAoc3ViZmFtaWx5TG93ZXIuaW5jbHVkZXMoJ2JvbGQnKSkgd2VpZ2h0ID0gNzAwO1xuICAgICAgICAgICAgZWxzZSBpZiAoc3ViZmFtaWx5TG93ZXIuaW5jbHVkZXMoJ2V4dHJhYm9sZCcpIHx8IHN1YmZhbWlseUxvd2VyLmluY2x1ZGVzKCd1bHRyYWJvbGQnKSkgd2VpZ2h0ID0gODAwO1xuICAgICAgICAgICAgZWxzZSBpZiAoc3ViZmFtaWx5TG93ZXIuaW5jbHVkZXMoJ2JsYWNrJykgfHwgc3ViZmFtaWx5TG93ZXIuaW5jbHVkZXMoJ2hlYXZ5JykpIHdlaWdodCA9IDkwMDtcbiAgICAgICAgfVxuICAgICAgICAgZm9udE9iai5jdXJyZW50V2VpZ2h0ID0gd2VpZ2h0O1xuICAgICAgICAgZm9udE9iai5jdXJyZW50U3R5bGUgPSBzdHlsZTtcbiAgICAgICAgY29uc3Qgc3R5bGVJbmZvID0gZmluZFN0eWxlSW5mb0J5V2VpZ2h0QW5kU3R5bGUod2VpZ2h0LCBzdHlsZSk7XG4gICAgICAgIGZvbnRPYmouYXZhaWxhYmxlU3R5bGVzID0gW3sgbmFtZTogc3R5bGVJbmZvLm5hbWUsIHdlaWdodCwgc3R5bGUgfV07XG4gICAgICB9XG5cbiAgICAgIC8vIDYuINCa0Y3RiNC40YDQvtCy0LDQvdC40LUg0YDQtdC30YPQu9GM0YLQsNGC0LAgKNC80LXRgtCw0LTQsNC90L3Ri9GFIC0g0LjQt9Cy0LvQtdC60LDQtdC8INC40LcgcGFyc2VkRm9udERhdGEg0LTQu9GPINGB0L7QstC80LXRgdGC0LjQvNC+0YHRgtC4INC60Y3RiNCwKVxuICAgICAgaWYgKGNhY2hlS2V5ICYmIHBhcnNlZEZvbnREYXRhKSB7IC8vINCU0L7QsdCw0LLQuNC70Lgg0L/RgNC+0LLQtdGA0LrRgyBwYXJzZWRGb250RGF0YVxuICAgICAgICAvLyDQmtGN0YjQuNGA0YPQtdC8INC+0LHRitC10LrRgiwg0L/QvtGF0L7QttC40Lkg0L3QsCDRgdGC0LDRgNGL0LkgbWV0YWRhdGEsINC00LvRjyDQvtCx0YDQsNGC0L3QvtC5INGB0L7QstC80LXRgdGC0LjQvNC+0YHRgtC4P1xuICAgICAgICAvLyDQmNC70Lgg0LrRjdGI0LjRgNC+0LLQsNGC0Ywg0LLQtdGB0YwgcGFyc2VkRm9udERhdGE/INCf0L7QutCwINC+0YHRgtCw0LLQuNC8INC60LDQuiDQsdGL0LvQviwg0LjQt9Cy0LvQtdC60LDRjyDQvdGD0LbQvdC+0LVcbiAgICAgICAgY29uc3QgbWV0YWRhdGFUb0NhY2hlID0ge1xuICAgICAgICAgICAgbmFtZXM6IHBhcnNlZEZvbnREYXRhLm5hbWVzLFxuICAgICAgICAgICAgcHJlZmVycmVkRmFtaWx5OiBwcmVmZXJyZWRGYW1pbHksXG4gICAgICAgICAgICBwcmVmZXJyZWRTdWJmYW1pbHk6IHByZWZlcnJlZFN1YmZhbWlseSxcbiAgICAgICAgICAgIGlzVmFyaWFibGU6IGZvbnRPYmouaXNWYXJpYWJsZUZvbnQsXG4gICAgICAgICAgICBzdXBwb3J0ZWRBeGVzOiBmb250T2JqLmlzVmFyaWFibGVGb250ID8gcGFyc2VkRm9udERhdGEudGFibGVzLmZ2YXIuYXhlcy5yZWR1Y2UoKGFjYywgYXhpcykgPT4ge1xuICAgICAgICAgICAgICAgICBhY2NbYXhpcy50YWddID0geyBuYW1lOiBheGlzLm5hbWU/LmVuLCBtaW46IGF4aXMubWluVmFsdWUsIG1heDogYXhpcy5tYXhWYWx1ZSwgZGVmYXVsdDogYXhpcy5kZWZhdWx0VmFsdWUgfTtcbiAgICAgICAgICAgICAgICAgcmV0dXJuIGFjYztcbiAgICAgICAgICAgICAgICB9LCB7fSkgOiBudWxsLCAvLyDQodC+0YXRgNCw0L3Rj9C10LwgbnVsbCDQtdGB0LvQuCDQvdC1INCy0LDRgNC40LDRgtC40LLQvdGL0LlcbiAgICAgICAgICAgIC8vINCU0L7QsdCw0LLQuNGC0Ywg0LTRgNGD0LPQuNC1INC90YPQttC90YvQtSDQv9C+0LvRjyDQtdGB0LvQuCDQvdC10L7QsdGF0L7QtNC40LzQvlxuICAgICAgICB9O1xuICAgICAgICBsb2NhbEZvbnRDYWNoZVtjYWNoZUtleV0gPSBtZXRhZGF0YVRvQ2FjaGU7XG4gICAgICAgIC8vIGNvbnNvbGUubG9nKGBNZXRhZGF0YSBjYWNoZWQgZm9yICR7bmFtZX0gKGhhc2g6ICR7Y2FjaGVLZXkuc3Vic3RyaW5nKDAsIDgpfS4uLilgKTsgLy8g0KPQtNCw0LvRj9C10Lwg0LvQvtCzXG4gICAgICB9XG5cbiAgICB9IGVsc2Uge1xuICAgICAgLy8g0J/QsNGA0YHQuNC90LMg0L3QtSDRg9C00LDQu9GB0Y8gKHBhcnNlZEZvbnREYXRhIGlzIG51bGwpXG4gICAgICB0b2FzdC53YXJuaW5nKGDQndC1INGD0LTQsNC70L7RgdGMINC/0YDQvtCw0L3QsNC70LjQt9C40YDQvtCy0LDRgtGMINGI0YDQuNGE0YIgJHtuYW1lfS4g0JjRgdC/0L7Qu9GM0LfRg9GO0YLRgdGPINC30L3QsNGH0LXQvdC40Y8g0L/QviDRg9C80L7Qu9GH0LDQvdC40Y4uYCk7XG4gICAgICBmb250T2JqLmF2YWlsYWJsZVN0eWxlcyA9IFt7IG5hbWU6ICdSZWd1bGFyJywgd2VpZ2h0OiA0MDAsIHN0eWxlOiAnbm9ybWFsJyB9XTtcbiAgICB9XG5cbiAgICAvLyDQntC/0YDQtdC00LXQu9GP0LXQvCDQvdCw0YfQsNC70YzQvdGL0LUg0L3QsNGB0YLRgNC+0LnQutC4INC00LvRjyDQstCw0YDQuNCw0YLQuNCy0L3Ri9GFINGI0YDQuNGE0YLQvtCyXG4gICAgbGV0IGluaXRpYWxTZXR0aW5ncyA9IHt9O1xuICAgIGlmIChmb250T2JqLmlzVmFyaWFibGVGb250ICYmIGZvbnRPYmoudmFyaWFibGVBeGVzKSB7XG4gICAgICBpbml0aWFsU2V0dGluZ3MgPSBPYmplY3QuZW50cmllcyhmb250T2JqLnZhcmlhYmxlQXhlcykucmVkdWNlKChhY2MsIFt0YWcsIGF4aXNdKSA9PiB7XG4gICAgICAgIGFjY1t0YWddID0gYXhpcy5kZWZhdWx0O1xuICAgICAgICByZXR1cm4gYWNjO1xuICAgICAgfSwge30pO1xuICAgIH1cblxuICAgIC8vICEhISDQmNGB0L/QvtC70YzQt9GD0LXQvCBsb2FkRm9udEZhY2VJZk5lZWRlZCDQvdCw0L/RgNGP0LzRg9GOICEhIVxuICAgIHRyeSB7XG4gICAgICAvLyDQktGL0LfRi9Cy0LDQtdC8INGE0YPQvdC60YbQuNGOINGH0LXRgNC10Lcg0LjQvNC10L3QvtCy0LDQvdC90YvQuSDQuNC80L/QvtGA0YJcbiAgICAgIGF3YWl0IGxvYWRGb250RmFjZUlmTmVlZGVkKGZvbnRGYW1pbHlOYW1lLCBvYmplY3RVcmwsIGluaXRpYWxTZXR0aW5ncyk7XG4gICAgICBjb25zb2xlLmxvZyhgRm9udCAke2ZvbnRGYW1pbHlOYW1lfSBsb2FkZWQgc3VjY2Vzc2Z1bGx5IHVzaW5nIEZvbnRGYWNlIEFQSS5gKTtcbiAgICAgIC8vINCj0YHQv9C10YjQvdC+INC30LDQs9GA0YPQt9C40LvQuCwg0LLQvtC30LLRgNCw0YnQsNC10LwgZm9udE9ialxuICAgICAgcmV2b2tlT2JqZWN0VVJMKG9iamVjdFVybCk7IC8vINCe0YHQstC+0LHQvtC20LTQsNC10LwgYmxvYiBVUkwg0L/QvtGB0LvQtSDRg9GB0L/QtdGI0L3QvtC5INC30LDQs9GA0YPQt9C60LhcbiAgICAgIHJldHVybiBmb250T2JqO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcihgRmFpbGVkIHRvIGxvYWQgZm9udCAke2ZvbnRGYW1pbHlOYW1lfSB1c2luZyBGb250RmFjZSBBUEk6YCwgZXJyb3IpO1xuICAgICAgdG9hc3QuZXJyb3IoYNCe0YjQuNCx0LrQsCDQv9GA0Lgg0LfQsNCz0YDRg9C30LrQtSDRiNGA0LjRhNGC0LAgJHtmb250T2JqLm5hbWV9LmApO1xuICAgICAgcmV2b2tlT2JqZWN0VVJMKG9iamVjdFVybCk7IC8vINCe0YHQstC+0LHQvtC20LTQsNC10LwgYmxvYiBVUkwg0L/RgNC4INC+0YjQuNCx0LrQtVxuICAgICAgZm9udE9iai5lcnJvciA9ICdGYWlsZWQgdG8gbG9hZCB2aWEgRm9udEZhY2UgQVBJJztcbiAgICAgIHJldHVybiBmb250T2JqOyAvLyDQktC+0LfQstGA0LDRidCw0LXQvCDQvtCx0YrQtdC60YIg0YEg0L7RiNC40LHQutC+0LlcbiAgICB9XG5cbiAgfSBjYXRjaCAoZXJyb3IpIHsgLy8g0JPQu9C+0LHQsNC70YzQvdGL0LkgdHJ5Li4uY2F0Y2gg0LTQu9GPIHByb2Nlc3NMb2NhbEZvbnRcbiAgICBjb25zb2xlLmVycm9yKGBDcml0aWNhbCBlcnJvciBwcm9jZXNzaW5nIGZvbnQgJHtuYW1lfTpgLCBlcnJvcik7XG4gICAgdG9hc3QuZXJyb3IoYNCa0YDQuNGC0LjRh9C10YHQutCw0Y8g0L7RiNC40LHQutCwINC/0YDQuCDQvtCx0YDQsNCx0L7RgtC60LUg0YjRgNC40YTRgtCwICR7bmFtZX0uYCk7XG4gICAgaWYgKG9iamVjdFVybCkge1xuICAgICAgICByZXZva2VPYmplY3RVUkwob2JqZWN0VXJsKTsgLy8g0J7RgdCy0L7QsdC+0LbQtNCw0LXQvCBVUkwg0L/RgNC4INC70Y7QsdC+0Lkg0LrRgNC40YLQuNGH0LXRgdC60L7QuSDQvtGI0LjQsdC60LVcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7IC8vINCS0L7Qt9Cy0YDQsNGJ0LDQtdC8IG51bGwg0L/RgNC4INC60YDQuNGC0LjRh9C10YHQutC+0Lkg0L7RiNC40LHQutC1XG4gIH1cbn07ICJdLCJuYW1lcyI6WyJ0b2FzdCIsInBhcnNlRm9udEJ1ZmZlciIsImlzVmFyaWFibGVGb250IiwiZmluZFN0eWxlSW5mb0J5V2VpZ2h0QW5kU3R5bGUiLCJnZXRGb3JtYXRGcm9tRXh0ZW5zaW9uIiwibG9hZEZvbnRGYWNlSWZOZWVkZWQiLCJsb2NhbEZvbnRDYWNoZSIsInJldm9rZU9iamVjdFVSTCIsInVybCIsInN0YXJ0c1dpdGgiLCJVUkwiLCJlcnJvciIsImNvbnNvbGUiLCJ3YXJuIiwiY2FsY3VsYXRlRmlsZUhhc2giLCJmaWxlIiwiQmxvYiIsImJ1ZmZlciIsImFycmF5QnVmZmVyIiwiaGFzaEJ1ZmZlciIsImNyeXB0byIsInN1YnRsZSIsImRpZ2VzdCIsImhhc2hBcnJheSIsIkFycmF5IiwiZnJvbSIsIlVpbnQ4QXJyYXkiLCJoYXNoSGV4IiwibWFwIiwiYiIsInRvU3RyaW5nIiwicGFkU3RhcnQiLCJqb2luIiwicHJvY2Vzc0xvY2FsRm9udCIsImZvbnRJbnB1dCIsIm5hbWUiLCJmb250SWQiLCJNYXRoIiwicmFuZG9tIiwic3Vic3RyaW5nIiwiY2xlYW5lZE5hbWUiLCJyZXBsYWNlIiwib2JqZWN0VXJsIiwiY2FjaGVLZXkiLCJ3YXJuaW5nIiwiY2FjaGVkTWV0YWRhdGEiLCJsb2ciLCJjcmVhdGVPYmplY3RVUkwiLCJmb250RmFtaWx5TmFtZSIsImZvbnRPYmoiLCJpZCIsInByZWZlcnJlZEZhbWlseSIsIm5hbWVzIiwiZm9udEZhbWlseSIsIm9yaWdpbmFsTmFtZSIsInNvdXJjZSIsImN1cnJlbnRXZWlnaHQiLCJjdXJyZW50U3R5bGUiLCJpc1ZhcmlhYmxlIiwidmFyaWFibGVBeGVzIiwic3VwcG9ydGVkQXhlcyIsInZhcmlhdGlvblNldHRpbmdzIiwiYXZhaWxhYmxlU3R5bGVzIiwiT2JqZWN0IiwiZW50cmllcyIsInJlZHVjZSIsImFjYyIsInRhZyIsImF4aXNJbmZvIiwidG9VcHBlckNhc2UiLCJtaW4iLCJtYXgiLCJkZWZhdWx0Iiwia2V5cyIsInZhbHVlIiwid2VpZ2h0Iiwic3R5bGUiLCJzdWJmYW1pbHkiLCJwcmVmZXJyZWRTdWJmYW1pbHkiLCJmb250U3ViZmFtaWx5Iiwic3ViZmFtaWx5TG93ZXIiLCJ0b0xvd2VyQ2FzZSIsImluY2x1ZGVzIiwic3R5bGVJbmZvIiwiaW5pdGlhbFNldHRpbmdzIiwiYXhpcyIsInBhcnNlZEZvbnREYXRhIiwiZSIsImVuIiwidGFibGVzIiwiZnZhciIsImF4ZXMiLCJheGlzTmFtZSIsIm1pblZhbHVlIiwibWF4VmFsdWUiLCJkZWZhdWx0VmFsdWUiLCJtZXRhZGF0YVRvQ2FjaGUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./utils/localFontProcessor.js\n"));

/***/ }),

/***/ "./utils/staticFontGenerator.js":
/*!**************************************!*\
  !*** ./utils/staticFontGenerator.js ***!
  \**************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   checkGenerationCapabilities: function() { return /* binding */ checkGenerationCapabilities; },\n/* harmony export */   generateStaticFont: function() { return /* binding */ generateStaticFont; }\n/* harmony export */ });\n/* provided dependency */ var Buffer = __webpack_require__(/*! buffer */ \"../../node_modules/buffer/index.js\")[\"Buffer\"];\n/**\n * Утилита для генерации статических шрифтов из вариативных\n * Использует различные подходы в зависимости от доступности инструментов\n */ // Попытка загрузки HarfBuzz WASM (если доступен)\nlet harfbuzzWasm = null;\nconst loadHarfBuzz = async ()=>{\n    if (harfbuzzWasm) return harfbuzzWasm;\n    try {\n        // Пытаемся загрузить HarfBuzz WASM (пакет не установлен, будет fallback)\n        return null;\n    } catch (error) {\n        return null;\n    }\n};\n/**\n * Генерирует статический шрифт с использованием HarfBuzz WASM\n */ const generateWithHarfBuzz = async (fontBuffer, variableSettings)=>{\n    const hb = await loadHarfBuzz();\n    if (!hb) throw new Error(\"HarfBuzz WASM недоступен\");\n    // Создаем blob из font data\n    const blob = hb.createBlob(fontBuffer);\n    const face = hb.createFace(blob, 0);\n    const font = hb.createFont(face);\n    // Применяем вариативные настройки\n    const variations = Object.entries(variableSettings).map((param)=>{\n        let [tag, value] = param;\n        return {\n            tag: hb.tagFromString(tag),\n            value: parseFloat(value)\n        };\n    });\n    font.setVariations(variations);\n    // Получаем новые данные шрифта\n    const outputBlob = face.reference_table(hb.tagFromString(\"GDEF\")); // Это упрощенный пример\n    const outputBuffer = outputBlob.getData();\n    // Очищаем ресурсы\n    font.destroy();\n    face.destroy();\n    blob.destroy();\n    return outputBuffer;\n};\n/**\n * Генерирует статический шрифт через серверный API\n */ const generateViaAPI = async function(fontBuffer, variableSettings) {\n    let format = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : \"woff2\";\n    const response = await fetch(\"/api/generate-static-font\", {\n        method: \"POST\",\n        headers: {\n            \"Content-Type\": \"application/json\"\n        },\n        body: JSON.stringify({\n            fontData: Buffer.from(fontBuffer).toString(\"base64\"),\n            variableSettings,\n            format\n        })\n    });\n    if (!response.ok) {\n        const error = await response.json();\n        throw new Error(error.details || \"Серверная генерация не удалась\");\n    }\n    const result = await response.json();\n    return Buffer.from(result.data, \"base64\");\n};\n/**\n * Fallback: создает \"псевдо-статический\" шрифт с CSS переменными\n */ const generatePseudoStatic = (fontBuffer, variableSettings, fontName)=>{\n    // Возвращаем оригинальный шрифт + CSS с фиксированными настройками\n    const cssVariations = Object.entries(variableSettings).map((param)=>{\n        let [axis, value] = param;\n        return '\"'.concat(axis, '\" ').concat(value);\n    }).join(\", \");\n    const css = '\\n@font-face {\\n  font-family: \"'.concat(fontName, '-Static\";\\n  src: url(data:font/woff2;base64,').concat(Buffer.from(fontBuffer).toString(\"base64\"), ') format(\"woff2\");\\n  font-variation-settings: ').concat(cssVariations, ';\\n  font-display: swap;\\n}\\n\\n.static-font {\\n  font-family: \"').concat(fontName, '-Static\", sans-serif;\\n  font-variation-settings: ').concat(cssVariations, \";\\n}\\n\");\n    return {\n        fontBuffer,\n        css,\n        isPseudoStatic: true\n    };\n};\n/**\n * Основная функция генерации статического шрифта\n * Пробует разные методы в порядке приоритета\n */ const generateStaticFont = async function(fontBuffer, variableSettings) {\n    let options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};\n    const { format = \"woff2\", fontName = \"VariableFont\", preferredMethod = \"auto\" } = options;\n    // Метод 1: HarfBuzz WASM (наиболее качественный)\n    if (preferredMethod === \"auto\" || preferredMethod === \"harfbuzz\") {\n        try {\n            const result = await generateWithHarfBuzz(fontBuffer, variableSettings);\n            return {\n                buffer: result,\n                method: \"harfbuzz\",\n                isRealStatic: true\n            };\n        } catch (error) {\n        // Переходим к следующему методу\n        }\n    }\n    // Метод 2: Серверный API (второй по качеству)\n    if (preferredMethod === \"auto\" || preferredMethod === \"server\") {\n        try {\n            const result = await generateViaAPI(fontBuffer, variableSettings, format);\n            return {\n                buffer: result,\n                method: \"server\",\n                isRealStatic: true\n            };\n        } catch (error) {\n        // Переходим к следующему методу\n        }\n    }\n    // Метод 3: Псевдо-статический (fallback)\n    const result = generatePseudoStatic(fontBuffer, variableSettings, fontName);\n    return {\n        buffer: result.fontBuffer,\n        css: result.css,\n        method: \"pseudo-static\",\n        isRealStatic: false,\n        warning: \"Создан псевдо-статический шрифт. Для настоящей статической генерации требуется серверная поддержка.\"\n    };\n};\n/**\n * Проверяет доступность различных методов генерации\n */ const checkGenerationCapabilities = async ()=>{\n    const capabilities = {\n        harfbuzz: false,\n        server: false,\n        pseudoStatic: true // Всегда доступен\n    };\n    // Проверяем HarfBuzz\n    try {\n        await loadHarfBuzz();\n        capabilities.harfbuzz = true;\n    } catch (error) {\n    // HarfBuzz недоступен\n    }\n    // Проверяем серверный API\n    try {\n        const response = await fetch(\"/api/generate-static-font\", {\n            method: \"POST\",\n            headers: {\n                \"Content-Type\": \"application/json\"\n            },\n            body: JSON.stringify({\n                test: true\n            })\n        });\n        capabilities.server = response.status !== 404;\n    } catch (error) {\n    // Серверный API недоступен\n    }\n    return capabilities;\n};\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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O1lBQUs7UUFDcEM7UUFDQUosYUFBYUUsTUFBTSxHQUFHaEMsU0FBU21DLE1BQU0sS0FBSztJQUM1QyxFQUFFLE9BQU8vRCxPQUFPO0lBQ2QsMkJBQTJCO0lBQzdCO0lBRUEsT0FBTzBEO0FBQ1QsRUFBRSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi91dGlscy9zdGF0aWNGb250R2VuZXJhdG9yLmpzPzAzOWQiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiDQo9GC0LjQu9C40YLQsCDQtNC70Y8g0LPQtdC90LXRgNCw0YbQuNC4INGB0YLQsNGC0LjRh9C10YHQutC40YUg0YjRgNC40YTRgtC+0LIg0LjQtyDQstCw0YDQuNCw0YLQuNCy0L3Ri9GFXG4gKiDQmNGB0L/QvtC70YzQt9GD0LXRgiDRgNCw0LfQu9C40YfQvdGL0LUg0L/QvtC00YXQvtC00Ysg0LIg0LfQsNCy0LjRgdC40LzQvtGB0YLQuCDQvtGCINC00L7RgdGC0YPQv9C90L7RgdGC0Lgg0LjQvdGB0YLRgNGD0LzQtdC90YLQvtCyXG4gKi9cblxuLy8g0J/QvtC/0YvRgtC60LAg0LfQsNCz0YDRg9C30LrQuCBIYXJmQnV6eiBXQVNNICjQtdGB0LvQuCDQtNC+0YHRgtGD0L/QtdC9KVxubGV0IGhhcmZidXp6V2FzbSA9IG51bGw7XG5cbmNvbnN0IGxvYWRIYXJmQnV6eiA9IGFzeW5jICgpID0+IHtcbiAgaWYgKGhhcmZidXp6V2FzbSkgcmV0dXJuIGhhcmZidXp6V2FzbTtcbiAgXG4gIHRyeSB7XG4gICAgLy8g0J/Ri9GC0LDQtdC80YHRjyDQt9Cw0LPRgNGD0LfQuNGC0YwgSGFyZkJ1enogV0FTTSAo0L/QsNC60LXRgiDQvdC1INGD0YHRgtCw0L3QvtCy0LvQtdC9LCDQsdGD0LTQtdGCIGZhbGxiYWNrKVxuICAgIHJldHVybiBudWxsO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIHJldHVybiBudWxsO1xuICB9XG59O1xuXG4vKipcbiAqINCT0LXQvdC10YDQuNGA0YPQtdGCINGB0YLQsNGC0LjRh9C10YHQutC40Lkg0YjRgNC40YTRgiDRgSDQuNGB0L/QvtC70YzQt9C+0LLQsNC90LjQtdC8IEhhcmZCdXp6IFdBU01cbiAqL1xuY29uc3QgZ2VuZXJhdGVXaXRoSGFyZkJ1enogPSBhc3luYyAoZm9udEJ1ZmZlciwgdmFyaWFibGVTZXR0aW5ncykgPT4ge1xuICBjb25zdCBoYiA9IGF3YWl0IGxvYWRIYXJmQnV6eigpO1xuICBpZiAoIWhiKSB0aHJvdyBuZXcgRXJyb3IoJ0hhcmZCdXp6IFdBU00g0L3QtdC00L7RgdGC0YPQv9C10L0nKTtcbiAgXG4gIC8vINCh0L7Qt9C00LDQtdC8IGJsb2Ig0LjQtyBmb250IGRhdGFcbiAgY29uc3QgYmxvYiA9IGhiLmNyZWF0ZUJsb2IoZm9udEJ1ZmZlcik7XG4gIGNvbnN0IGZhY2UgPSBoYi5jcmVhdGVGYWNlKGJsb2IsIDApO1xuICBjb25zdCBmb250ID0gaGIuY3JlYXRlRm9udChmYWNlKTtcbiAgXG4gIC8vINCf0YDQuNC80LXQvdGP0LXQvCDQstCw0YDQuNCw0YLQuNCy0L3Ri9C1INC90LDRgdGC0YDQvtC50LrQuFxuICBjb25zdCB2YXJpYXRpb25zID0gT2JqZWN0LmVudHJpZXModmFyaWFibGVTZXR0aW5ncykubWFwKChbdGFnLCB2YWx1ZV0pID0+ICh7XG4gICAgdGFnOiBoYi50YWdGcm9tU3RyaW5nKHRhZyksXG4gICAgdmFsdWU6IHBhcnNlRmxvYXQodmFsdWUpXG4gIH0pKTtcbiAgXG4gIGZvbnQuc2V0VmFyaWF0aW9ucyh2YXJpYXRpb25zKTtcbiAgXG4gIC8vINCf0L7Qu9GD0YfQsNC10Lwg0L3QvtCy0YvQtSDQtNCw0L3QvdGL0LUg0YjRgNC40YTRgtCwXG4gIGNvbnN0IG91dHB1dEJsb2IgPSBmYWNlLnJlZmVyZW5jZV90YWJsZShoYi50YWdGcm9tU3RyaW5nKCdHREVGJykpOyAvLyDQrdGC0L4g0YPQv9GA0L7RidC10L3QvdGL0Lkg0L/RgNC40LzQtdGAXG4gIGNvbnN0IG91dHB1dEJ1ZmZlciA9IG91dHB1dEJsb2IuZ2V0RGF0YSgpO1xuICBcbiAgLy8g0J7Rh9C40YnQsNC10Lwg0YDQtdGB0YPRgNGB0YtcbiAgZm9udC5kZXN0cm95KCk7XG4gIGZhY2UuZGVzdHJveSgpO1xuICBibG9iLmRlc3Ryb3koKTtcbiAgXG4gIHJldHVybiBvdXRwdXRCdWZmZXI7XG59O1xuXG4vKipcbiAqINCT0LXQvdC10YDQuNGA0YPQtdGCINGB0YLQsNGC0LjRh9C10YHQutC40Lkg0YjRgNC40YTRgiDRh9C10YDQtdC3INGB0LXRgNCy0LXRgNC90YvQuSBBUElcbiAqL1xuY29uc3QgZ2VuZXJhdGVWaWFBUEkgPSBhc3luYyAoZm9udEJ1ZmZlciwgdmFyaWFibGVTZXR0aW5ncywgZm9ybWF0ID0gJ3dvZmYyJykgPT4ge1xuICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKCcvYXBpL2dlbmVyYXRlLXN0YXRpYy1mb250Jywge1xuICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgIGhlYWRlcnM6IHtcbiAgICAgICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgfSxcbiAgICBib2R5OiBKU09OLnN0cmluZ2lmeSh7XG4gICAgICBmb250RGF0YTogQnVmZmVyLmZyb20oZm9udEJ1ZmZlcikudG9TdHJpbmcoJ2Jhc2U2NCcpLFxuICAgICAgdmFyaWFibGVTZXR0aW5ncyxcbiAgICAgIGZvcm1hdFxuICAgIH0pXG4gIH0pO1xuICBcbiAgaWYgKCFyZXNwb25zZS5vaykge1xuICAgIGNvbnN0IGVycm9yID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xuICAgIHRocm93IG5ldyBFcnJvcihlcnJvci5kZXRhaWxzIHx8ICfQodC10YDQstC10YDQvdCw0Y8g0LPQtdC90LXRgNCw0YbQuNGPINC90LUg0YPQtNCw0LvQsNGB0YwnKTtcbiAgfVxuICBcbiAgY29uc3QgcmVzdWx0ID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xuICByZXR1cm4gQnVmZmVyLmZyb20ocmVzdWx0LmRhdGEsICdiYXNlNjQnKTtcbn07XG5cbi8qKlxuICogRmFsbGJhY2s6INGB0L7Qt9C00LDQtdGCIFwi0L/RgdC10LLQtNC+LdGB0YLQsNGC0LjRh9C10YHQutC40LlcIiDRiNGA0LjRhNGCINGBIENTUyDQv9C10YDQtdC80LXQvdC90YvQvNC4XG4gKi9cbmNvbnN0IGdlbmVyYXRlUHNldWRvU3RhdGljID0gKGZvbnRCdWZmZXIsIHZhcmlhYmxlU2V0dGluZ3MsIGZvbnROYW1lKSA9PiB7XG4gIC8vINCS0L7Qt9Cy0YDQsNGJ0LDQtdC8INC+0YDQuNCz0LjQvdCw0LvRjNC90YvQuSDRiNGA0LjRhNGCICsgQ1NTINGBINGE0LjQutGB0LjRgNC+0LLQsNC90L3Ri9C80Lgg0L3QsNGB0YLRgNC+0LnQutCw0LzQuFxuICBjb25zdCBjc3NWYXJpYXRpb25zID0gT2JqZWN0LmVudHJpZXModmFyaWFibGVTZXR0aW5ncylcbiAgICAubWFwKChbYXhpcywgdmFsdWVdKSA9PiBgXCIke2F4aXN9XCIgJHt2YWx1ZX1gKVxuICAgIC5qb2luKCcsICcpO1xuICBcbiAgY29uc3QgY3NzID0gYFxuQGZvbnQtZmFjZSB7XG4gIGZvbnQtZmFtaWx5OiBcIiR7Zm9udE5hbWV9LVN0YXRpY1wiO1xuICBzcmM6IHVybChkYXRhOmZvbnQvd29mZjI7YmFzZTY0LCR7QnVmZmVyLmZyb20oZm9udEJ1ZmZlcikudG9TdHJpbmcoJ2Jhc2U2NCcpfSkgZm9ybWF0KFwid29mZjJcIik7XG4gIGZvbnQtdmFyaWF0aW9uLXNldHRpbmdzOiAke2Nzc1ZhcmlhdGlvbnN9O1xuICBmb250LWRpc3BsYXk6IHN3YXA7XG59XG5cbi5zdGF0aWMtZm9udCB7XG4gIGZvbnQtZmFtaWx5OiBcIiR7Zm9udE5hbWV9LVN0YXRpY1wiLCBzYW5zLXNlcmlmO1xuICBmb250LXZhcmlhdGlvbi1zZXR0aW5nczogJHtjc3NWYXJpYXRpb25zfTtcbn1cbmA7XG4gIFxuICByZXR1cm4ge1xuICAgIGZvbnRCdWZmZXIsXG4gICAgY3NzLFxuICAgIGlzUHNldWRvU3RhdGljOiB0cnVlXG4gIH07XG59O1xuXG4vKipcbiAqINCe0YHQvdC+0LLQvdCw0Y8g0YTRg9C90LrRhtC40Y8g0LPQtdC90LXRgNCw0YbQuNC4INGB0YLQsNGC0LjRh9C10YHQutC+0LPQviDRiNGA0LjRhNGC0LBcbiAqINCf0YDQvtCx0YPQtdGCINGA0LDQt9C90YvQtSDQvNC10YLQvtC00Ysg0LIg0L/QvtGA0Y/QtNC60LUg0L/RgNC40L7RgNC40YLQtdGC0LBcbiAqL1xuZXhwb3J0IGNvbnN0IGdlbmVyYXRlU3RhdGljRm9udCA9IGFzeW5jIChmb250QnVmZmVyLCB2YXJpYWJsZVNldHRpbmdzLCBvcHRpb25zID0ge30pID0+IHtcbiAgY29uc3QgeyBmb3JtYXQgPSAnd29mZjInLCBmb250TmFtZSA9ICdWYXJpYWJsZUZvbnQnLCBwcmVmZXJyZWRNZXRob2QgPSAnYXV0bycgfSA9IG9wdGlvbnM7XG4gIFxuICAvLyDQnNC10YLQvtC0IDE6IEhhcmZCdXp6IFdBU00gKNC90LDQuNCx0L7Qu9C10LUg0LrQsNGH0LXRgdGC0LLQtdC90L3Ri9C5KVxuICBpZiAocHJlZmVycmVkTWV0aG9kID09PSAnYXV0bycgfHwgcHJlZmVycmVkTWV0aG9kID09PSAnaGFyZmJ1enonKSB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGdlbmVyYXRlV2l0aEhhcmZCdXp6KGZvbnRCdWZmZXIsIHZhcmlhYmxlU2V0dGluZ3MpO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgYnVmZmVyOiByZXN1bHQsXG4gICAgICAgIG1ldGhvZDogJ2hhcmZidXp6JyxcbiAgICAgICAgaXNSZWFsU3RhdGljOiB0cnVlXG4gICAgICB9O1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAvLyDQn9C10YDQtdGF0L7QtNC40Lwg0Log0YHQu9C10LTRg9GO0YnQtdC80YMg0LzQtdGC0L7QtNGDXG4gICAgfVxuICB9XG4gIFxuICAvLyDQnNC10YLQvtC0IDI6INCh0LXRgNCy0LXRgNC90YvQuSBBUEkgKNCy0YLQvtGA0L7QuSDQv9C+INC60LDRh9C10YHRgtCy0YMpXG4gIGlmIChwcmVmZXJyZWRNZXRob2QgPT09ICdhdXRvJyB8fCBwcmVmZXJyZWRNZXRob2QgPT09ICdzZXJ2ZXInKSB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGdlbmVyYXRlVmlhQVBJKGZvbnRCdWZmZXIsIHZhcmlhYmxlU2V0dGluZ3MsIGZvcm1hdCk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBidWZmZXI6IHJlc3VsdCxcbiAgICAgICAgbWV0aG9kOiAnc2VydmVyJyxcbiAgICAgICAgaXNSZWFsU3RhdGljOiB0cnVlXG4gICAgICB9O1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAvLyDQn9C10YDQtdGF0L7QtNC40Lwg0Log0YHQu9C10LTRg9GO0YnQtdC80YMg0LzQtdGC0L7QtNGDXG4gICAgfVxuICB9XG4gIFxuICAvLyDQnNC10YLQvtC0IDM6INCf0YHQtdCy0LTQvi3RgdGC0LDRgtC40YfQtdGB0LrQuNC5IChmYWxsYmFjaylcbiAgY29uc3QgcmVzdWx0ID0gZ2VuZXJhdGVQc2V1ZG9TdGF0aWMoZm9udEJ1ZmZlciwgdmFyaWFibGVTZXR0aW5ncywgZm9udE5hbWUpO1xuICByZXR1cm4ge1xuICAgIGJ1ZmZlcjogcmVzdWx0LmZvbnRCdWZmZXIsXG4gICAgY3NzOiByZXN1bHQuY3NzLFxuICAgIG1ldGhvZDogJ3BzZXVkby1zdGF0aWMnLFxuICAgIGlzUmVhbFN0YXRpYzogZmFsc2UsXG4gICAgd2FybmluZzogJ9Ch0L7Qt9C00LDQvSDQv9GB0LXQstC00L4t0YHRgtCw0YLQuNGH0LXRgdC60LjQuSDRiNGA0LjRhNGCLiDQlNC70Y8g0L3QsNGB0YLQvtGP0YnQtdC5INGB0YLQsNGC0LjRh9C10YHQutC+0Lkg0LPQtdC90LXRgNCw0YbQuNC4INGC0YDQtdCx0YPQtdGC0YHRjyDRgdC10YDQstC10YDQvdCw0Y8g0L/QvtC00LTQtdGA0LbQutCwLidcbiAgfTtcbn07XG5cbi8qKlxuICog0J/RgNC+0LLQtdGA0Y/QtdGCINC00L7RgdGC0YPQv9C90L7RgdGC0Ywg0YDQsNC30LvQuNGH0L3Ri9GFINC80LXRgtC+0LTQvtCyINCz0LXQvdC10YDQsNGG0LjQuFxuICovXG5leHBvcnQgY29uc3QgY2hlY2tHZW5lcmF0aW9uQ2FwYWJpbGl0aWVzID0gYXN5bmMgKCkgPT4ge1xuICBjb25zdCBjYXBhYmlsaXRpZXMgPSB7XG4gICAgaGFyZmJ1eno6IGZhbHNlLFxuICAgIHNlcnZlcjogZmFsc2UsXG4gICAgcHNldWRvU3RhdGljOiB0cnVlIC8vINCS0YHQtdCz0LTQsCDQtNC+0YHRgtGD0L/QtdC9XG4gIH07XG4gIFxuICAvLyDQn9GA0L7QstC10YDRj9C10LwgSGFyZkJ1enpcbiAgdHJ5IHtcbiAgICBhd2FpdCBsb2FkSGFyZkJ1enooKTtcbiAgICBjYXBhYmlsaXRpZXMuaGFyZmJ1enogPSB0cnVlO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIC8vIEhhcmZCdXp6INC90LXQtNC+0YHRgtGD0L/QtdC9XG4gIH1cbiAgXG4gIC8vINCf0YDQvtCy0LXRgNGP0LXQvCDRgdC10YDQstC10YDQvdGL0LkgQVBJXG4gIHRyeSB7XG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaCgnL2FwaS9nZW5lcmF0ZS1zdGF0aWMtZm9udCcsIHtcbiAgICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgICAgaGVhZGVyczogeyAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nIH0sXG4gICAgICBib2R5OiBKU09OLnN0cmluZ2lmeSh7IHRlc3Q6IHRydWUgfSlcbiAgICB9KTtcbiAgICBjYXBhYmlsaXRpZXMuc2VydmVyID0gcmVzcG9uc2Uuc3RhdHVzICE9PSA0MDQ7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgLy8g0KHQtdGA0LLQtdGA0L3Ri9C5IEFQSSDQvdC10LTQvtGB0YLRg9C/0LXQvVxuICB9XG4gIFxuICByZXR1cm4gY2FwYWJpbGl0aWVzO1xufTsgIl0sIm5hbWVzIjpbImhhcmZidXp6V2FzbSIsImxvYWRIYXJmQnV6eiIsImVycm9yIiwiZ2VuZXJhdGVXaXRoSGFyZkJ1enoiLCJmb250QnVmZmVyIiwidmFyaWFibGVTZXR0aW5ncyIsImhiIiwiRXJyb3IiLCJibG9iIiwiY3JlYXRlQmxvYiIsImZhY2UiLCJjcmVhdGVGYWNlIiwiZm9udCIsImNyZWF0ZUZvbnQiLCJ2YXJpYXRpb25zIiwiT2JqZWN0IiwiZW50cmllcyIsIm1hcCIsInRhZyIsInZhbHVlIiwidGFnRnJvbVN0cmluZyIsInBhcnNlRmxvYXQiLCJzZXRWYXJpYXRpb25zIiwib3V0cHV0QmxvYiIsInJlZmVyZW5jZV90YWJsZSIsIm91dHB1dEJ1ZmZlciIsImdldERhdGEiLCJkZXN0cm95IiwiZ2VuZXJhdGVWaWFBUEkiLCJmb3JtYXQiLCJyZXNwb25zZSIsImZldGNoIiwibWV0aG9kIiwiaGVhZGVycyIsImJvZHkiLCJKU09OIiwic3RyaW5naWZ5IiwiZm9udERhdGEiLCJCdWZmZXIiLCJmcm9tIiwidG9TdHJpbmciLCJvayIsImpzb24iLCJkZXRhaWxzIiwicmVzdWx0IiwiZGF0YSIsImdlbmVyYXRlUHNldWRvU3RhdGljIiwiZm9udE5hbWUiLCJjc3NWYXJpYXRpb25zIiwiYXhpcyIsImpvaW4iLCJjc3MiLCJpc1BzZXVkb1N0YXRpYyIsImdlbmVyYXRlU3RhdGljRm9udCIsIm9wdGlvbnMiLCJwcmVmZXJyZWRNZXRob2QiLCJidWZmZXIiLCJpc1JlYWxTdGF0aWMiLCJ3YXJuaW5nIiwiY2hlY2tHZW5lcmF0aW9uQ2FwYWJpbGl0aWVzIiwiY2FwYWJpbGl0aWVzIiwiaGFyZmJ1enoiLCJzZXJ2ZXIiLCJwc2V1ZG9TdGF0aWMiLCJ0ZXN0Iiwic3RhdHVzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./utils/staticFontGenerator.js\n"));

/***/ }),

/***/ "./node_modules/next/head.js":
/*!***********************************!*\
  !*** ./node_modules/next/head.js ***!
  \***********************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("module.exports = __webpack_require__(/*! ./dist/shared/lib/head */ \"./node_modules/next/dist/shared/lib/head.js\")\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbmV4dC9oZWFkLmpzIiwibWFwcGluZ3MiOiJBQUFBLGlIQUFrRCIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvbmV4dC9oZWFkLmpzPzg4NDkiXSwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2Rpc3Qvc2hhcmVkL2xpYi9oZWFkJylcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/next/head.js\n"));

/***/ }),

/***/ "./node_modules/opentype.js/dist/opentype.module.js":
/*!**********************************************************!*\
  !*** ./node_modules/opentype.js/dist/opentype.module.js ***!
  \**********************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   BoundingBox: function() { return /* binding */ BoundingBox; },\n/* harmony export */   Font: function() { return /* binding */ Font; },\n/* harmony export */   Glyph: function() { return /* binding */ Glyph; },\n/* harmony export */   Path: function() { return /* binding */ Path; },\n/* harmony export */   _parse: function() { return /* binding */ parse; },\n/* harmony export */   load: function() { return /* binding */ load; },\n/* harmony export */   loadSync: function() { return /* binding */ loadSync; },\n/* harmony export */   parse: function() { return /* binding */ parseBuffer; }\n/* harmony export */ });\n/* provided dependency */ var Buffer = __webpack_require__(/*! buffer */ \"../../node_modules/buffer/index.js\")[\"Buffer\"];\n/**\n * https://opentype.js.org v1.3.4 | (c) Frederik De Bleser and other contributors | MIT License | Uses tiny-inflate by Devon Govett and string.prototype.codepointat polyfill by Mathias Bynens\n */\n\n/*! https://mths.be/codepointat v0.2.0 by @mathias */\nif (!String.prototype.codePointAt) {\n\t(function() {\n\t\tvar defineProperty = (function() {\n\t\t\t// IE 8 only supports `Object.defineProperty` on DOM elements\n\t\t\ttry {\n\t\t\t\tvar object = {};\n\t\t\t\tvar $defineProperty = Object.defineProperty;\n\t\t\t\tvar result = $defineProperty(object, object, object) && $defineProperty;\n\t\t\t} catch(error) {}\n\t\t\treturn result;\n\t\t}());\n\t\tvar codePointAt = function(position) {\n\t\t\tif (this == null) {\n\t\t\t\tthrow TypeError();\n\t\t\t}\n\t\t\tvar string = String(this);\n\t\t\tvar size = string.length;\n\t\t\t// `ToInteger`\n\t\t\tvar index = position ? Number(position) : 0;\n\t\t\tif (index != index) { // better `isNaN`\n\t\t\t\tindex = 0;\n\t\t\t}\n\t\t\t// Account for out-of-bounds indices:\n\t\t\tif (index < 0 || index >= size) {\n\t\t\t\treturn undefined;\n\t\t\t}\n\t\t\t// Get the first code unit\n\t\t\tvar first = string.charCodeAt(index);\n\t\t\tvar second;\n\t\t\tif ( // check if it’s the start of a surrogate pair\n\t\t\t\tfirst >= 0xD800 && first <= 0xDBFF && // high surrogate\n\t\t\t\tsize > index + 1 // there is a next code unit\n\t\t\t) {\n\t\t\t\tsecond = string.charCodeAt(index + 1);\n\t\t\t\tif (second >= 0xDC00 && second <= 0xDFFF) { // low surrogate\n\t\t\t\t\t// https://mathiasbynens.be/notes/javascript-encoding#surrogate-formulae\n\t\t\t\t\treturn (first - 0xD800) * 0x400 + second - 0xDC00 + 0x10000;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn first;\n\t\t};\n\t\tif (defineProperty) {\n\t\t\tdefineProperty(String.prototype, 'codePointAt', {\n\t\t\t\t'value': codePointAt,\n\t\t\t\t'configurable': true,\n\t\t\t\t'writable': true\n\t\t\t});\n\t\t} else {\n\t\t\tString.prototype.codePointAt = codePointAt;\n\t\t}\n\t}());\n}\n\nvar TINF_OK = 0;\nvar TINF_DATA_ERROR = -3;\n\nfunction Tree() {\n  this.table = new Uint16Array(16);   /* table of code length counts */\n  this.trans = new Uint16Array(288);  /* code -> symbol translation table */\n}\n\nfunction Data(source, dest) {\n  this.source = source;\n  this.sourceIndex = 0;\n  this.tag = 0;\n  this.bitcount = 0;\n  \n  this.dest = dest;\n  this.destLen = 0;\n  \n  this.ltree = new Tree();  /* dynamic length/symbol tree */\n  this.dtree = new Tree();  /* dynamic distance tree */\n}\n\n/* --------------------------------------------------- *\n * -- uninitialized global data (static structures) -- *\n * --------------------------------------------------- */\n\nvar sltree = new Tree();\nvar sdtree = new Tree();\n\n/* extra bits and base tables for length codes */\nvar length_bits = new Uint8Array(30);\nvar length_base = new Uint16Array(30);\n\n/* extra bits and base tables for distance codes */\nvar dist_bits = new Uint8Array(30);\nvar dist_base = new Uint16Array(30);\n\n/* special ordering of code length codes */\nvar clcidx = new Uint8Array([\n  16, 17, 18, 0, 8, 7, 9, 6,\n  10, 5, 11, 4, 12, 3, 13, 2,\n  14, 1, 15\n]);\n\n/* used by tinf_decode_trees, avoids allocations every call */\nvar code_tree = new Tree();\nvar lengths = new Uint8Array(288 + 32);\n\n/* ----------------------- *\n * -- utility functions -- *\n * ----------------------- */\n\n/* build extra bits and base tables */\nfunction tinf_build_bits_base(bits, base, delta, first) {\n  var i, sum;\n\n  /* build bits table */\n  for (i = 0; i < delta; ++i) { bits[i] = 0; }\n  for (i = 0; i < 30 - delta; ++i) { bits[i + delta] = i / delta | 0; }\n\n  /* build base table */\n  for (sum = first, i = 0; i < 30; ++i) {\n    base[i] = sum;\n    sum += 1 << bits[i];\n  }\n}\n\n/* build the fixed huffman trees */\nfunction tinf_build_fixed_trees(lt, dt) {\n  var i;\n\n  /* build fixed length tree */\n  for (i = 0; i < 7; ++i) { lt.table[i] = 0; }\n\n  lt.table[7] = 24;\n  lt.table[8] = 152;\n  lt.table[9] = 112;\n\n  for (i = 0; i < 24; ++i) { lt.trans[i] = 256 + i; }\n  for (i = 0; i < 144; ++i) { lt.trans[24 + i] = i; }\n  for (i = 0; i < 8; ++i) { lt.trans[24 + 144 + i] = 280 + i; }\n  for (i = 0; i < 112; ++i) { lt.trans[24 + 144 + 8 + i] = 144 + i; }\n\n  /* build fixed distance tree */\n  for (i = 0; i < 5; ++i) { dt.table[i] = 0; }\n\n  dt.table[5] = 32;\n\n  for (i = 0; i < 32; ++i) { dt.trans[i] = i; }\n}\n\n/* given an array of code lengths, build a tree */\nvar offs = new Uint16Array(16);\n\nfunction tinf_build_tree(t, lengths, off, num) {\n  var i, sum;\n\n  /* clear code length count table */\n  for (i = 0; i < 16; ++i) { t.table[i] = 0; }\n\n  /* scan symbol lengths, and sum code length counts */\n  for (i = 0; i < num; ++i) { t.table[lengths[off + i]]++; }\n\n  t.table[0] = 0;\n\n  /* compute offset table for distribution sort */\n  for (sum = 0, i = 0; i < 16; ++i) {\n    offs[i] = sum;\n    sum += t.table[i];\n  }\n\n  /* create code->symbol translation table (symbols sorted by code) */\n  for (i = 0; i < num; ++i) {\n    if (lengths[off + i]) { t.trans[offs[lengths[off + i]]++] = i; }\n  }\n}\n\n/* ---------------------- *\n * -- decode functions -- *\n * ---------------------- */\n\n/* get one bit from source stream */\nfunction tinf_getbit(d) {\n  /* check if tag is empty */\n  if (!d.bitcount--) {\n    /* load next tag */\n    d.tag = d.source[d.sourceIndex++];\n    d.bitcount = 7;\n  }\n\n  /* shift bit out of tag */\n  var bit = d.tag & 1;\n  d.tag >>>= 1;\n\n  return bit;\n}\n\n/* read a num bit value from a stream and add base */\nfunction tinf_read_bits(d, num, base) {\n  if (!num)\n    { return base; }\n\n  while (d.bitcount < 24) {\n    d.tag |= d.source[d.sourceIndex++] << d.bitcount;\n    d.bitcount += 8;\n  }\n\n  var val = d.tag & (0xffff >>> (16 - num));\n  d.tag >>>= num;\n  d.bitcount -= num;\n  return val + base;\n}\n\n/* given a data stream and a tree, decode a symbol */\nfunction tinf_decode_symbol(d, t) {\n  while (d.bitcount < 24) {\n    d.tag |= d.source[d.sourceIndex++] << d.bitcount;\n    d.bitcount += 8;\n  }\n  \n  var sum = 0, cur = 0, len = 0;\n  var tag = d.tag;\n\n  /* get more bits while code value is above sum */\n  do {\n    cur = 2 * cur + (tag & 1);\n    tag >>>= 1;\n    ++len;\n\n    sum += t.table[len];\n    cur -= t.table[len];\n  } while (cur >= 0);\n  \n  d.tag = tag;\n  d.bitcount -= len;\n\n  return t.trans[sum + cur];\n}\n\n/* given a data stream, decode dynamic trees from it */\nfunction tinf_decode_trees(d, lt, dt) {\n  var hlit, hdist, hclen;\n  var i, num, length;\n\n  /* get 5 bits HLIT (257-286) */\n  hlit = tinf_read_bits(d, 5, 257);\n\n  /* get 5 bits HDIST (1-32) */\n  hdist = tinf_read_bits(d, 5, 1);\n\n  /* get 4 bits HCLEN (4-19) */\n  hclen = tinf_read_bits(d, 4, 4);\n\n  for (i = 0; i < 19; ++i) { lengths[i] = 0; }\n\n  /* read code lengths for code length alphabet */\n  for (i = 0; i < hclen; ++i) {\n    /* get 3 bits code length (0-7) */\n    var clen = tinf_read_bits(d, 3, 0);\n    lengths[clcidx[i]] = clen;\n  }\n\n  /* build code length tree */\n  tinf_build_tree(code_tree, lengths, 0, 19);\n\n  /* decode code lengths for the dynamic trees */\n  for (num = 0; num < hlit + hdist;) {\n    var sym = tinf_decode_symbol(d, code_tree);\n\n    switch (sym) {\n      case 16:\n        /* copy previous code length 3-6 times (read 2 bits) */\n        var prev = lengths[num - 1];\n        for (length = tinf_read_bits(d, 2, 3); length; --length) {\n          lengths[num++] = prev;\n        }\n        break;\n      case 17:\n        /* repeat code length 0 for 3-10 times (read 3 bits) */\n        for (length = tinf_read_bits(d, 3, 3); length; --length) {\n          lengths[num++] = 0;\n        }\n        break;\n      case 18:\n        /* repeat code length 0 for 11-138 times (read 7 bits) */\n        for (length = tinf_read_bits(d, 7, 11); length; --length) {\n          lengths[num++] = 0;\n        }\n        break;\n      default:\n        /* values 0-15 represent the actual code lengths */\n        lengths[num++] = sym;\n        break;\n    }\n  }\n\n  /* build dynamic trees */\n  tinf_build_tree(lt, lengths, 0, hlit);\n  tinf_build_tree(dt, lengths, hlit, hdist);\n}\n\n/* ----------------------------- *\n * -- block inflate functions -- *\n * ----------------------------- */\n\n/* given a stream and two trees, inflate a block of data */\nfunction tinf_inflate_block_data(d, lt, dt) {\n  while (1) {\n    var sym = tinf_decode_symbol(d, lt);\n\n    /* check for end of block */\n    if (sym === 256) {\n      return TINF_OK;\n    }\n\n    if (sym < 256) {\n      d.dest[d.destLen++] = sym;\n    } else {\n      var length, dist, offs;\n      var i;\n\n      sym -= 257;\n\n      /* possibly get more bits from length code */\n      length = tinf_read_bits(d, length_bits[sym], length_base[sym]);\n\n      dist = tinf_decode_symbol(d, dt);\n\n      /* possibly get more bits from distance code */\n      offs = d.destLen - tinf_read_bits(d, dist_bits[dist], dist_base[dist]);\n\n      /* copy match */\n      for (i = offs; i < offs + length; ++i) {\n        d.dest[d.destLen++] = d.dest[i];\n      }\n    }\n  }\n}\n\n/* inflate an uncompressed block of data */\nfunction tinf_inflate_uncompressed_block(d) {\n  var length, invlength;\n  var i;\n  \n  /* unread from bitbuffer */\n  while (d.bitcount > 8) {\n    d.sourceIndex--;\n    d.bitcount -= 8;\n  }\n\n  /* get length */\n  length = d.source[d.sourceIndex + 1];\n  length = 256 * length + d.source[d.sourceIndex];\n\n  /* get one's complement of length */\n  invlength = d.source[d.sourceIndex + 3];\n  invlength = 256 * invlength + d.source[d.sourceIndex + 2];\n\n  /* check length */\n  if (length !== (~invlength & 0x0000ffff))\n    { return TINF_DATA_ERROR; }\n\n  d.sourceIndex += 4;\n\n  /* copy block */\n  for (i = length; i; --i)\n    { d.dest[d.destLen++] = d.source[d.sourceIndex++]; }\n\n  /* make sure we start next block on a byte boundary */\n  d.bitcount = 0;\n\n  return TINF_OK;\n}\n\n/* inflate stream from source to dest */\nfunction tinf_uncompress(source, dest) {\n  var d = new Data(source, dest);\n  var bfinal, btype, res;\n\n  do {\n    /* read final block flag */\n    bfinal = tinf_getbit(d);\n\n    /* read block type (2 bits) */\n    btype = tinf_read_bits(d, 2, 0);\n\n    /* decompress block */\n    switch (btype) {\n      case 0:\n        /* decompress uncompressed block */\n        res = tinf_inflate_uncompressed_block(d);\n        break;\n      case 1:\n        /* decompress block with fixed huffman trees */\n        res = tinf_inflate_block_data(d, sltree, sdtree);\n        break;\n      case 2:\n        /* decompress block with dynamic huffman trees */\n        tinf_decode_trees(d, d.ltree, d.dtree);\n        res = tinf_inflate_block_data(d, d.ltree, d.dtree);\n        break;\n      default:\n        res = TINF_DATA_ERROR;\n    }\n\n    if (res !== TINF_OK)\n      { throw new Error('Data error'); }\n\n  } while (!bfinal);\n\n  if (d.destLen < d.dest.length) {\n    if (typeof d.dest.slice === 'function')\n      { return d.dest.slice(0, d.destLen); }\n    else\n      { return d.dest.subarray(0, d.destLen); }\n  }\n  \n  return d.dest;\n}\n\n/* -------------------- *\n * -- initialization -- *\n * -------------------- */\n\n/* build fixed huffman trees */\ntinf_build_fixed_trees(sltree, sdtree);\n\n/* build extra bits and base tables */\ntinf_build_bits_base(length_bits, length_base, 4, 3);\ntinf_build_bits_base(dist_bits, dist_base, 2, 1);\n\n/* fix a special case */\nlength_bits[28] = 0;\nlength_base[28] = 258;\n\nvar tinyInflate = tinf_uncompress;\n\n// The Bounding Box object\n\nfunction derive(v0, v1, v2, v3, t) {\n    return Math.pow(1 - t, 3) * v0 +\n        3 * Math.pow(1 - t, 2) * t * v1 +\n        3 * (1 - t) * Math.pow(t, 2) * v2 +\n        Math.pow(t, 3) * v3;\n}\n/**\n * A bounding box is an enclosing box that describes the smallest measure within which all the points lie.\n * It is used to calculate the bounding box of a glyph or text path.\n *\n * On initialization, x1/y1/x2/y2 will be NaN. Check if the bounding box is empty using `isEmpty()`.\n *\n * @exports opentype.BoundingBox\n * @class\n * @constructor\n */\nfunction BoundingBox() {\n    this.x1 = Number.NaN;\n    this.y1 = Number.NaN;\n    this.x2 = Number.NaN;\n    this.y2 = Number.NaN;\n}\n\n/**\n * Returns true if the bounding box is empty, that is, no points have been added to the box yet.\n */\nBoundingBox.prototype.isEmpty = function() {\n    return isNaN(this.x1) || isNaN(this.y1) || isNaN(this.x2) || isNaN(this.y2);\n};\n\n/**\n * Add the point to the bounding box.\n * The x1/y1/x2/y2 coordinates of the bounding box will now encompass the given point.\n * @param {number} x - The X coordinate of the point.\n * @param {number} y - The Y coordinate of the point.\n */\nBoundingBox.prototype.addPoint = function(x, y) {\n    if (typeof x === 'number') {\n        if (isNaN(this.x1) || isNaN(this.x2)) {\n            this.x1 = x;\n            this.x2 = x;\n        }\n        if (x < this.x1) {\n            this.x1 = x;\n        }\n        if (x > this.x2) {\n            this.x2 = x;\n        }\n    }\n    if (typeof y === 'number') {\n        if (isNaN(this.y1) || isNaN(this.y2)) {\n            this.y1 = y;\n            this.y2 = y;\n        }\n        if (y < this.y1) {\n            this.y1 = y;\n        }\n        if (y > this.y2) {\n            this.y2 = y;\n        }\n    }\n};\n\n/**\n * Add a X coordinate to the bounding box.\n * This extends the bounding box to include the X coordinate.\n * This function is used internally inside of addBezier.\n * @param {number} x - The X coordinate of the point.\n */\nBoundingBox.prototype.addX = function(x) {\n    this.addPoint(x, null);\n};\n\n/**\n * Add a Y coordinate to the bounding box.\n * This extends the bounding box to include the Y coordinate.\n * This function is used internally inside of addBezier.\n * @param {number} y - The Y coordinate of the point.\n */\nBoundingBox.prototype.addY = function(y) {\n    this.addPoint(null, y);\n};\n\n/**\n * Add a Bézier curve to the bounding box.\n * This extends the bounding box to include the entire Bézier.\n * @param {number} x0 - The starting X coordinate.\n * @param {number} y0 - The starting Y coordinate.\n * @param {number} x1 - The X coordinate of the first control point.\n * @param {number} y1 - The Y coordinate of the first control point.\n * @param {number} x2 - The X coordinate of the second control point.\n * @param {number} y2 - The Y coordinate of the second control point.\n * @param {number} x - The ending X coordinate.\n * @param {number} y - The ending Y coordinate.\n */\nBoundingBox.prototype.addBezier = function(x0, y0, x1, y1, x2, y2, x, y) {\n    // This code is based on http://nishiohirokazu.blogspot.com/2009/06/how-to-calculate-bezier-curves-bounding.html\n    // and https://github.com/icons8/svg-path-bounding-box\n\n    var p0 = [x0, y0];\n    var p1 = [x1, y1];\n    var p2 = [x2, y2];\n    var p3 = [x, y];\n\n    this.addPoint(x0, y0);\n    this.addPoint(x, y);\n\n    for (var i = 0; i <= 1; i++) {\n        var b = 6 * p0[i] - 12 * p1[i] + 6 * p2[i];\n        var a = -3 * p0[i] + 9 * p1[i] - 9 * p2[i] + 3 * p3[i];\n        var c = 3 * p1[i] - 3 * p0[i];\n\n        if (a === 0) {\n            if (b === 0) { continue; }\n            var t = -c / b;\n            if (0 < t && t < 1) {\n                if (i === 0) { this.addX(derive(p0[i], p1[i], p2[i], p3[i], t)); }\n                if (i === 1) { this.addY(derive(p0[i], p1[i], p2[i], p3[i], t)); }\n            }\n            continue;\n        }\n\n        var b2ac = Math.pow(b, 2) - 4 * c * a;\n        if (b2ac < 0) { continue; }\n        var t1 = (-b + Math.sqrt(b2ac)) / (2 * a);\n        if (0 < t1 && t1 < 1) {\n            if (i === 0) { this.addX(derive(p0[i], p1[i], p2[i], p3[i], t1)); }\n            if (i === 1) { this.addY(derive(p0[i], p1[i], p2[i], p3[i], t1)); }\n        }\n        var t2 = (-b - Math.sqrt(b2ac)) / (2 * a);\n        if (0 < t2 && t2 < 1) {\n            if (i === 0) { this.addX(derive(p0[i], p1[i], p2[i], p3[i], t2)); }\n            if (i === 1) { this.addY(derive(p0[i], p1[i], p2[i], p3[i], t2)); }\n        }\n    }\n};\n\n/**\n * Add a quadratic curve to the bounding box.\n * This extends the bounding box to include the entire quadratic curve.\n * @param {number} x0 - The starting X coordinate.\n * @param {number} y0 - The starting Y coordinate.\n * @param {number} x1 - The X coordinate of the control point.\n * @param {number} y1 - The Y coordinate of the control point.\n * @param {number} x - The ending X coordinate.\n * @param {number} y - The ending Y coordinate.\n */\nBoundingBox.prototype.addQuad = function(x0, y0, x1, y1, x, y) {\n    var cp1x = x0 + 2 / 3 * (x1 - x0);\n    var cp1y = y0 + 2 / 3 * (y1 - y0);\n    var cp2x = cp1x + 1 / 3 * (x - x0);\n    var cp2y = cp1y + 1 / 3 * (y - y0);\n    this.addBezier(x0, y0, cp1x, cp1y, cp2x, cp2y, x, y);\n};\n\n// Geometric objects\n\n/**\n * A bézier path containing a set of path commands similar to a SVG path.\n * Paths can be drawn on a context using `draw`.\n * @exports opentype.Path\n * @class\n * @constructor\n */\nfunction Path() {\n    this.commands = [];\n    this.fill = 'black';\n    this.stroke = null;\n    this.strokeWidth = 1;\n}\n\n/**\n * @param  {number} x\n * @param  {number} y\n */\nPath.prototype.moveTo = function(x, y) {\n    this.commands.push({\n        type: 'M',\n        x: x,\n        y: y\n    });\n};\n\n/**\n * @param  {number} x\n * @param  {number} y\n */\nPath.prototype.lineTo = function(x, y) {\n    this.commands.push({\n        type: 'L',\n        x: x,\n        y: y\n    });\n};\n\n/**\n * Draws cubic curve\n * @function\n * curveTo\n * @memberof opentype.Path.prototype\n * @param  {number} x1 - x of control 1\n * @param  {number} y1 - y of control 1\n * @param  {number} x2 - x of control 2\n * @param  {number} y2 - y of control 2\n * @param  {number} x - x of path point\n * @param  {number} y - y of path point\n */\n\n/**\n * Draws cubic curve\n * @function\n * bezierCurveTo\n * @memberof opentype.Path.prototype\n * @param  {number} x1 - x of control 1\n * @param  {number} y1 - y of control 1\n * @param  {number} x2 - x of control 2\n * @param  {number} y2 - y of control 2\n * @param  {number} x - x of path point\n * @param  {number} y - y of path point\n * @see curveTo\n */\nPath.prototype.curveTo = Path.prototype.bezierCurveTo = function(x1, y1, x2, y2, x, y) {\n    this.commands.push({\n        type: 'C',\n        x1: x1,\n        y1: y1,\n        x2: x2,\n        y2: y2,\n        x: x,\n        y: y\n    });\n};\n\n/**\n * Draws quadratic curve\n * @function\n * quadraticCurveTo\n * @memberof opentype.Path.prototype\n * @param  {number} x1 - x of control\n * @param  {number} y1 - y of control\n * @param  {number} x - x of path point\n * @param  {number} y - y of path point\n */\n\n/**\n * Draws quadratic curve\n * @function\n * quadTo\n * @memberof opentype.Path.prototype\n * @param  {number} x1 - x of control\n * @param  {number} y1 - y of control\n * @param  {number} x - x of path point\n * @param  {number} y - y of path point\n */\nPath.prototype.quadTo = Path.prototype.quadraticCurveTo = function(x1, y1, x, y) {\n    this.commands.push({\n        type: 'Q',\n        x1: x1,\n        y1: y1,\n        x: x,\n        y: y\n    });\n};\n\n/**\n * Closes the path\n * @function closePath\n * @memberof opentype.Path.prototype\n */\n\n/**\n * Close the path\n * @function close\n * @memberof opentype.Path.prototype\n */\nPath.prototype.close = Path.prototype.closePath = function() {\n    this.commands.push({\n        type: 'Z'\n    });\n};\n\n/**\n * Add the given path or list of commands to the commands of this path.\n * @param  {Array} pathOrCommands - another opentype.Path, an opentype.BoundingBox, or an array of commands.\n */\nPath.prototype.extend = function(pathOrCommands) {\n    if (pathOrCommands.commands) {\n        pathOrCommands = pathOrCommands.commands;\n    } else if (pathOrCommands instanceof BoundingBox) {\n        var box = pathOrCommands;\n        this.moveTo(box.x1, box.y1);\n        this.lineTo(box.x2, box.y1);\n        this.lineTo(box.x2, box.y2);\n        this.lineTo(box.x1, box.y2);\n        this.close();\n        return;\n    }\n\n    Array.prototype.push.apply(this.commands, pathOrCommands);\n};\n\n/**\n * Calculate the bounding box of the path.\n * @returns {opentype.BoundingBox}\n */\nPath.prototype.getBoundingBox = function() {\n    var box = new BoundingBox();\n\n    var startX = 0;\n    var startY = 0;\n    var prevX = 0;\n    var prevY = 0;\n    for (var i = 0; i < this.commands.length; i++) {\n        var cmd = this.commands[i];\n        switch (cmd.type) {\n            case 'M':\n                box.addPoint(cmd.x, cmd.y);\n                startX = prevX = cmd.x;\n                startY = prevY = cmd.y;\n                break;\n            case 'L':\n                box.addPoint(cmd.x, cmd.y);\n                prevX = cmd.x;\n                prevY = cmd.y;\n                break;\n            case 'Q':\n                box.addQuad(prevX, prevY, cmd.x1, cmd.y1, cmd.x, cmd.y);\n                prevX = cmd.x;\n                prevY = cmd.y;\n                break;\n            case 'C':\n                box.addBezier(prevX, prevY, cmd.x1, cmd.y1, cmd.x2, cmd.y2, cmd.x, cmd.y);\n                prevX = cmd.x;\n                prevY = cmd.y;\n                break;\n            case 'Z':\n                prevX = startX;\n                prevY = startY;\n                break;\n            default:\n                throw new Error('Unexpected path command ' + cmd.type);\n        }\n    }\n    if (box.isEmpty()) {\n        box.addPoint(0, 0);\n    }\n    return box;\n};\n\n/**\n * Draw the path to a 2D context.\n * @param {CanvasRenderingContext2D} ctx - A 2D drawing context.\n */\nPath.prototype.draw = function(ctx) {\n    ctx.beginPath();\n    for (var i = 0; i < this.commands.length; i += 1) {\n        var cmd = this.commands[i];\n        if (cmd.type === 'M') {\n            ctx.moveTo(cmd.x, cmd.y);\n        } else if (cmd.type === 'L') {\n            ctx.lineTo(cmd.x, cmd.y);\n        } else if (cmd.type === 'C') {\n            ctx.bezierCurveTo(cmd.x1, cmd.y1, cmd.x2, cmd.y2, cmd.x, cmd.y);\n        } else if (cmd.type === 'Q') {\n            ctx.quadraticCurveTo(cmd.x1, cmd.y1, cmd.x, cmd.y);\n        } else if (cmd.type === 'Z') {\n            ctx.closePath();\n        }\n    }\n\n    if (this.fill) {\n        ctx.fillStyle = this.fill;\n        ctx.fill();\n    }\n\n    if (this.stroke) {\n        ctx.strokeStyle = this.stroke;\n        ctx.lineWidth = this.strokeWidth;\n        ctx.stroke();\n    }\n};\n\n/**\n * Convert the Path to a string of path data instructions\n * See http://www.w3.org/TR/SVG/paths.html#PathData\n * @param  {number} [decimalPlaces=2] - The amount of decimal places for floating-point values\n * @return {string}\n */\nPath.prototype.toPathData = function(decimalPlaces) {\n    decimalPlaces = decimalPlaces !== undefined ? decimalPlaces : 2;\n\n    function floatToString(v) {\n        if (Math.round(v) === v) {\n            return '' + Math.round(v);\n        } else {\n            return v.toFixed(decimalPlaces);\n        }\n    }\n\n    function packValues() {\n        var arguments$1 = arguments;\n\n        var s = '';\n        for (var i = 0; i < arguments.length; i += 1) {\n            var v = arguments$1[i];\n            if (v >= 0 && i > 0) {\n                s += ' ';\n            }\n\n            s += floatToString(v);\n        }\n\n        return s;\n    }\n\n    var d = '';\n    for (var i = 0; i < this.commands.length; i += 1) {\n        var cmd = this.commands[i];\n        if (cmd.type === 'M') {\n            d += 'M' + packValues(cmd.x, cmd.y);\n        } else if (cmd.type === 'L') {\n            d += 'L' + packValues(cmd.x, cmd.y);\n        } else if (cmd.type === 'C') {\n            d += 'C' + packValues(cmd.x1, cmd.y1, cmd.x2, cmd.y2, cmd.x, cmd.y);\n        } else if (cmd.type === 'Q') {\n            d += 'Q' + packValues(cmd.x1, cmd.y1, cmd.x, cmd.y);\n        } else if (cmd.type === 'Z') {\n            d += 'Z';\n        }\n    }\n\n    return d;\n};\n\n/**\n * Convert the path to an SVG <path> element, as a string.\n * @param  {number} [decimalPlaces=2] - The amount of decimal places for floating-point values\n * @return {string}\n */\nPath.prototype.toSVG = function(decimalPlaces) {\n    var svg = '<path d=\"';\n    svg += this.toPathData(decimalPlaces);\n    svg += '\"';\n    if (this.fill && this.fill !== 'black') {\n        if (this.fill === null) {\n            svg += ' fill=\"none\"';\n        } else {\n            svg += ' fill=\"' + this.fill + '\"';\n        }\n    }\n\n    if (this.stroke) {\n        svg += ' stroke=\"' + this.stroke + '\" stroke-width=\"' + this.strokeWidth + '\"';\n    }\n\n    svg += '/>';\n    return svg;\n};\n\n/**\n * Convert the path to a DOM element.\n * @param  {number} [decimalPlaces=2] - The amount of decimal places for floating-point values\n * @return {SVGPathElement}\n */\nPath.prototype.toDOMElement = function(decimalPlaces) {\n    var temporaryPath = this.toPathData(decimalPlaces);\n    var newPath = document.createElementNS('http://www.w3.org/2000/svg', 'path');\n\n    newPath.setAttribute('d', temporaryPath);\n\n    return newPath;\n};\n\n// Run-time checking of preconditions.\n\nfunction fail(message) {\n    throw new Error(message);\n}\n\n// Precondition function that checks if the given predicate is true.\n// If not, it will throw an error.\nfunction argument(predicate, message) {\n    if (!predicate) {\n        fail(message);\n    }\n}\nvar check = { fail: fail, argument: argument, assert: argument };\n\n// Data types used in the OpenType font file.\n\nvar LIMIT16 = 32768; // The limit at which a 16-bit number switches signs == 2^15\nvar LIMIT32 = 2147483648; // The limit at which a 32-bit number switches signs == 2 ^ 31\n\n/**\n * @exports opentype.decode\n * @class\n */\nvar decode = {};\n/**\n * @exports opentype.encode\n * @class\n */\nvar encode = {};\n/**\n * @exports opentype.sizeOf\n * @class\n */\nvar sizeOf = {};\n\n// Return a function that always returns the same value.\nfunction constant(v) {\n    return function() {\n        return v;\n    };\n}\n\n// OpenType data types //////////////////////////////////////////////////////\n\n/**\n * Convert an 8-bit unsigned integer to a list of 1 byte.\n * @param {number}\n * @returns {Array}\n */\nencode.BYTE = function(v) {\n    check.argument(v >= 0 && v <= 255, 'Byte value should be between 0 and 255.');\n    return [v];\n};\n/**\n * @constant\n * @type {number}\n */\nsizeOf.BYTE = constant(1);\n\n/**\n * Convert a 8-bit signed integer to a list of 1 byte.\n * @param {string}\n * @returns {Array}\n */\nencode.CHAR = function(v) {\n    return [v.charCodeAt(0)];\n};\n\n/**\n * @constant\n * @type {number}\n */\nsizeOf.CHAR = constant(1);\n\n/**\n * Convert an ASCII string to a list of bytes.\n * @param {string}\n * @returns {Array}\n */\nencode.CHARARRAY = function(v) {\n    if (typeof v === 'undefined') {\n        v = '';\n        console.warn('Undefined CHARARRAY encountered and treated as an empty string. This is probably caused by a missing glyph name.');\n    }\n    var b = [];\n    for (var i = 0; i < v.length; i += 1) {\n        b[i] = v.charCodeAt(i);\n    }\n\n    return b;\n};\n\n/**\n * @param {Array}\n * @returns {number}\n */\nsizeOf.CHARARRAY = function(v) {\n    if (typeof v === 'undefined') {\n        return 0;\n    }\n    return v.length;\n};\n\n/**\n * Convert a 16-bit unsigned integer to a list of 2 bytes.\n * @param {number}\n * @returns {Array}\n */\nencode.USHORT = function(v) {\n    return [(v >> 8) & 0xFF, v & 0xFF];\n};\n\n/**\n * @constant\n * @type {number}\n */\nsizeOf.USHORT = constant(2);\n\n/**\n * Convert a 16-bit signed integer to a list of 2 bytes.\n * @param {number}\n * @returns {Array}\n */\nencode.SHORT = function(v) {\n    // Two's complement\n    if (v >= LIMIT16) {\n        v = -(2 * LIMIT16 - v);\n    }\n\n    return [(v >> 8) & 0xFF, v & 0xFF];\n};\n\n/**\n * @constant\n * @type {number}\n */\nsizeOf.SHORT = constant(2);\n\n/**\n * Convert a 24-bit unsigned integer to a list of 3 bytes.\n * @param {number}\n * @returns {Array}\n */\nencode.UINT24 = function(v) {\n    return [(v >> 16) & 0xFF, (v >> 8) & 0xFF, v & 0xFF];\n};\n\n/**\n * @constant\n * @type {number}\n */\nsizeOf.UINT24 = constant(3);\n\n/**\n * Convert a 32-bit unsigned integer to a list of 4 bytes.\n * @param {number}\n * @returns {Array}\n */\nencode.ULONG = function(v) {\n    return [(v >> 24) & 0xFF, (v >> 16) & 0xFF, (v >> 8) & 0xFF, v & 0xFF];\n};\n\n/**\n * @constant\n * @type {number}\n */\nsizeOf.ULONG = constant(4);\n\n/**\n * Convert a 32-bit unsigned integer to a list of 4 bytes.\n * @param {number}\n * @returns {Array}\n */\nencode.LONG = function(v) {\n    // Two's complement\n    if (v >= LIMIT32) {\n        v = -(2 * LIMIT32 - v);\n    }\n\n    return [(v >> 24) & 0xFF, (v >> 16) & 0xFF, (v >> 8) & 0xFF, v & 0xFF];\n};\n\n/**\n * @constant\n * @type {number}\n */\nsizeOf.LONG = constant(4);\n\nencode.FIXED = encode.ULONG;\nsizeOf.FIXED = sizeOf.ULONG;\n\nencode.FWORD = encode.SHORT;\nsizeOf.FWORD = sizeOf.SHORT;\n\nencode.UFWORD = encode.USHORT;\nsizeOf.UFWORD = sizeOf.USHORT;\n\n/**\n * Convert a 32-bit Apple Mac timestamp integer to a list of 8 bytes, 64-bit timestamp.\n * @param {number}\n * @returns {Array}\n */\nencode.LONGDATETIME = function(v) {\n    return [0, 0, 0, 0, (v >> 24) & 0xFF, (v >> 16) & 0xFF, (v >> 8) & 0xFF, v & 0xFF];\n};\n\n/**\n * @constant\n * @type {number}\n */\nsizeOf.LONGDATETIME = constant(8);\n\n/**\n * Convert a 4-char tag to a list of 4 bytes.\n * @param {string}\n * @returns {Array}\n */\nencode.TAG = function(v) {\n    check.argument(v.length === 4, 'Tag should be exactly 4 ASCII characters.');\n    return [v.charCodeAt(0),\n            v.charCodeAt(1),\n            v.charCodeAt(2),\n            v.charCodeAt(3)];\n};\n\n/**\n * @constant\n * @type {number}\n */\nsizeOf.TAG = constant(4);\n\n// CFF data types ///////////////////////////////////////////////////////////\n\nencode.Card8 = encode.BYTE;\nsizeOf.Card8 = sizeOf.BYTE;\n\nencode.Card16 = encode.USHORT;\nsizeOf.Card16 = sizeOf.USHORT;\n\nencode.OffSize = encode.BYTE;\nsizeOf.OffSize = sizeOf.BYTE;\n\nencode.SID = encode.USHORT;\nsizeOf.SID = sizeOf.USHORT;\n\n// Convert a numeric operand or charstring number to a variable-size list of bytes.\n/**\n * Convert a numeric operand or charstring number to a variable-size list of bytes.\n * @param {number}\n * @returns {Array}\n */\nencode.NUMBER = function(v) {\n    if (v >= -107 && v <= 107) {\n        return [v + 139];\n    } else if (v >= 108 && v <= 1131) {\n        v = v - 108;\n        return [(v >> 8) + 247, v & 0xFF];\n    } else if (v >= -1131 && v <= -108) {\n        v = -v - 108;\n        return [(v >> 8) + 251, v & 0xFF];\n    } else if (v >= -32768 && v <= 32767) {\n        return encode.NUMBER16(v);\n    } else {\n        return encode.NUMBER32(v);\n    }\n};\n\n/**\n * @param {number}\n * @returns {number}\n */\nsizeOf.NUMBER = function(v) {\n    return encode.NUMBER(v).length;\n};\n\n/**\n * Convert a signed number between -32768 and +32767 to a three-byte value.\n * This ensures we always use three bytes, but is not the most compact format.\n * @param {number}\n * @returns {Array}\n */\nencode.NUMBER16 = function(v) {\n    return [28, (v >> 8) & 0xFF, v & 0xFF];\n};\n\n/**\n * @constant\n * @type {number}\n */\nsizeOf.NUMBER16 = constant(3);\n\n/**\n * Convert a signed number between -(2^31) and +(2^31-1) to a five-byte value.\n * This is useful if you want to be sure you always use four bytes,\n * at the expense of wasting a few bytes for smaller numbers.\n * @param {number}\n * @returns {Array}\n */\nencode.NUMBER32 = function(v) {\n    return [29, (v >> 24) & 0xFF, (v >> 16) & 0xFF, (v >> 8) & 0xFF, v & 0xFF];\n};\n\n/**\n * @constant\n * @type {number}\n */\nsizeOf.NUMBER32 = constant(5);\n\n/**\n * @param {number}\n * @returns {Array}\n */\nencode.REAL = function(v) {\n    var value = v.toString();\n\n    // Some numbers use an epsilon to encode the value. (e.g. JavaScript will store 0.0000001 as 1e-7)\n    // This code converts it back to a number without the epsilon.\n    var m = /\\.(\\d*?)(?:9{5,20}|0{5,20})\\d{0,2}(?:e(.+)|$)/.exec(value);\n    if (m) {\n        var epsilon = parseFloat('1e' + ((m[2] ? +m[2] : 0) + m[1].length));\n        value = (Math.round(v * epsilon) / epsilon).toString();\n    }\n\n    var nibbles = '';\n    for (var i = 0, ii = value.length; i < ii; i += 1) {\n        var c = value[i];\n        if (c === 'e') {\n            nibbles += value[++i] === '-' ? 'c' : 'b';\n        } else if (c === '.') {\n            nibbles += 'a';\n        } else if (c === '-') {\n            nibbles += 'e';\n        } else {\n            nibbles += c;\n        }\n    }\n\n    nibbles += (nibbles.length & 1) ? 'f' : 'ff';\n    var out = [30];\n    for (var i$1 = 0, ii$1 = nibbles.length; i$1 < ii$1; i$1 += 2) {\n        out.push(parseInt(nibbles.substr(i$1, 2), 16));\n    }\n\n    return out;\n};\n\n/**\n * @param {number}\n * @returns {number}\n */\nsizeOf.REAL = function(v) {\n    return encode.REAL(v).length;\n};\n\nencode.NAME = encode.CHARARRAY;\nsizeOf.NAME = sizeOf.CHARARRAY;\n\nencode.STRING = encode.CHARARRAY;\nsizeOf.STRING = sizeOf.CHARARRAY;\n\n/**\n * @param {DataView} data\n * @param {number} offset\n * @param {number} numBytes\n * @returns {string}\n */\ndecode.UTF8 = function(data, offset, numBytes) {\n    var codePoints = [];\n    var numChars = numBytes;\n    for (var j = 0; j < numChars; j++, offset += 1) {\n        codePoints[j] = data.getUint8(offset);\n    }\n\n    return String.fromCharCode.apply(null, codePoints);\n};\n\n/**\n * @param {DataView} data\n * @param {number} offset\n * @param {number} numBytes\n * @returns {string}\n */\ndecode.UTF16 = function(data, offset, numBytes) {\n    var codePoints = [];\n    var numChars = numBytes / 2;\n    for (var j = 0; j < numChars; j++, offset += 2) {\n        codePoints[j] = data.getUint16(offset);\n    }\n\n    return String.fromCharCode.apply(null, codePoints);\n};\n\n/**\n * Convert a JavaScript string to UTF16-BE.\n * @param {string}\n * @returns {Array}\n */\nencode.UTF16 = function(v) {\n    var b = [];\n    for (var i = 0; i < v.length; i += 1) {\n        var codepoint = v.charCodeAt(i);\n        b[b.length] = (codepoint >> 8) & 0xFF;\n        b[b.length] = codepoint & 0xFF;\n    }\n\n    return b;\n};\n\n/**\n * @param {string}\n * @returns {number}\n */\nsizeOf.UTF16 = function(v) {\n    return v.length * 2;\n};\n\n// Data for converting old eight-bit Macintosh encodings to Unicode.\n// This representation is optimized for decoding; encoding is slower\n// and needs more memory. The assumption is that all opentype.js users\n// want to open fonts, but saving a font will be comparatively rare\n// so it can be more expensive. Keyed by IANA character set name.\n//\n// Python script for generating these strings:\n//\n//     s = u''.join([chr(c).decode('mac_greek') for c in range(128, 256)])\n//     print(s.encode('utf-8'))\n/**\n * @private\n */\nvar eightBitMacEncodings = {\n    'x-mac-croatian':  // Python: 'mac_croatian'\n    'ÄÅÇÉÑÖÜáàâäãåçéèêëíìîïñóòôöõúùûü†°¢£§•¶ß®Š™´¨≠ŽØ∞±≤≥∆µ∂∑∏š∫ªºΩžø' +\n    '¿¡¬√ƒ≈Ć«Č… ÀÃÕŒœĐ—“”‘’÷◊©⁄€‹›Æ»–·‚„‰ÂćÁčÈÍÎÏÌÓÔđÒÚÛÙıˆ˜¯πË˚¸Êæˇ',\n    'x-mac-cyrillic':  // Python: 'mac_cyrillic'\n    'АБВГДЕЖЗИЙКЛМНОПРСТУФХЦЧШЩЪЫЬЭЮЯ†°Ґ£§•¶І®©™Ђђ≠Ѓѓ∞±≤≥іµґЈЄєЇїЉљЊњ' +\n    'јЅ¬√ƒ≈∆«»… ЋћЌќѕ–—“”‘’÷„ЎўЏџ№Ёёяабвгдежзийклмнопрстуфхцчшщъыьэю',\n    'x-mac-gaelic': // http://unicode.org/Public/MAPPINGS/VENDORS/APPLE/GAELIC.TXT\n    'ÄÅÇÉÑÖÜáàâäãåçéèêëíìîïñóòôöõúùûü†°¢£§•¶ß®©™´¨≠ÆØḂ±≤≥ḃĊċḊḋḞḟĠġṀæø' +\n    'ṁṖṗɼƒſṠ«»… ÀÃÕŒœ–—“”‘’ṡẛÿŸṪ€‹›Ŷŷṫ·Ỳỳ⁊ÂÊÁËÈÍÎÏÌÓÔ♣ÒÚÛÙıÝýŴŵẄẅẀẁẂẃ',\n    'x-mac-greek':  // Python: 'mac_greek'\n    'Ä¹²É³ÖÜ΅àâä΄¨çéèêë£™îï•½‰ôö¦€ùûü†ΓΔΘΛΞΠß®©ΣΪ§≠°·Α±≤≥¥ΒΕΖΗΙΚΜΦΫΨΩ' +\n    'άΝ¬ΟΡ≈Τ«»… ΥΧΆΈœ–―“”‘’÷ΉΊΌΎέήίόΏύαβψδεφγηιξκλμνοπώρστθωςχυζϊϋΐΰ\\u00AD',\n    'x-mac-icelandic':  // Python: 'mac_iceland'\n    'ÄÅÇÉÑÖÜáàâäãåçéèêëíìîïñóòôöõúùûüÝ°¢£§•¶ß®©™´¨≠ÆØ∞±≤≥¥µ∂∑∏π∫ªºΩæø' +\n    '¿¡¬√ƒ≈∆«»… ÀÃÕŒœ–—“”‘’÷◊ÿŸ⁄€ÐðÞþý·‚„‰ÂÊÁËÈÍÎÏÌÓÔÒÚÛÙıˆ˜¯˘˙˚¸˝˛ˇ',\n    'x-mac-inuit': // http://unicode.org/Public/MAPPINGS/VENDORS/APPLE/INUIT.TXT\n    'ᐃᐄᐅᐆᐊᐋᐱᐲᐳᐴᐸᐹᑉᑎᑏᑐᑑᑕᑖᑦᑭᑮᑯᑰᑲᑳᒃᒋᒌᒍᒎᒐᒑ°ᒡᒥᒦ•¶ᒧ®©™ᒨᒪᒫᒻᓂᓃᓄᓅᓇᓈᓐᓯᓰᓱᓲᓴᓵᔅᓕᓖᓗ' +\n    'ᓘᓚᓛᓪᔨᔩᔪᔫᔭ… ᔮᔾᕕᕖᕗ–—“”‘’ᕘᕙᕚᕝᕆᕇᕈᕉᕋᕌᕐᕿᖀᖁᖂᖃᖄᖅᖏᖐᖑᖒᖓᖔᖕᙱᙲᙳᙴᙵᙶᖖᖠᖡᖢᖣᖤᖥᖦᕼŁł',\n    'x-mac-ce':  // Python: 'mac_latin2'\n    'ÄĀāÉĄÖÜáąČäčĆćéŹźĎíďĒēĖóėôöõúĚěü†°Ę£§•¶ß®©™ę¨≠ģĮįĪ≤≥īĶ∂∑łĻļĽľĹĺŅ' +\n    'ņŃ¬√ńŇ∆«»… ňŐÕőŌ–—“”‘’÷◊ōŔŕŘ‹›řŖŗŠ‚„šŚśÁŤťÍŽžŪÓÔūŮÚůŰűŲųÝýķŻŁżĢˇ',\n    macintosh:  // Python: 'mac_roman'\n    'ÄÅÇÉÑÖÜáàâäãåçéèêëíìîïñóòôöõúùûü†°¢£§•¶ß®©™´¨≠ÆØ∞±≤≥¥µ∂∑∏π∫ªºΩæø' +\n    '¿¡¬√ƒ≈∆«»… ÀÃÕŒœ–—“”‘’÷◊ÿŸ⁄€‹›ﬁﬂ‡·‚„‰ÂÊÁËÈÍÎÏÌÓÔÒÚÛÙıˆ˜¯˘˙˚¸˝˛ˇ',\n    'x-mac-romanian':  // Python: 'mac_romanian'\n    'ÄÅÇÉÑÖÜáàâäãåçéèêëíìîïñóòôöõúùûü†°¢£§•¶ß®©™´¨≠ĂȘ∞±≤≥¥µ∂∑∏π∫ªºΩăș' +\n    '¿¡¬√ƒ≈∆«»… ÀÃÕŒœ–—“”‘’÷◊ÿŸ⁄€‹›Țț‡·‚„‰ÂÊÁËÈÍÎÏÌÓÔÒÚÛÙıˆ˜¯˘˙˚¸˝˛ˇ',\n    'x-mac-turkish':  // Python: 'mac_turkish'\n    'ÄÅÇÉÑÖÜáàâäãåçéèêëíìîïñóòôöõúùûü†°¢£§•¶ß®©™´¨≠ÆØ∞±≤≥¥µ∂∑∏π∫ªºΩæø' +\n    '¿¡¬√ƒ≈∆«»… ÀÃÕŒœ–—“”‘’÷◊ÿŸĞğİıŞş‡·‚„‰ÂÊÁËÈÍÎÏÌÓÔÒÚÛÙˆ˜¯˘˙˚¸˝˛ˇ'\n};\n\n/**\n * Decodes an old-style Macintosh string. Returns either a Unicode JavaScript\n * string, or 'undefined' if the encoding is unsupported. For example, we do\n * not support Chinese, Japanese or Korean because these would need large\n * mapping tables.\n * @param {DataView} dataView\n * @param {number} offset\n * @param {number} dataLength\n * @param {string} encoding\n * @returns {string}\n */\ndecode.MACSTRING = function(dataView, offset, dataLength, encoding) {\n    var table = eightBitMacEncodings[encoding];\n    if (table === undefined) {\n        return undefined;\n    }\n\n    var result = '';\n    for (var i = 0; i < dataLength; i++) {\n        var c = dataView.getUint8(offset + i);\n        // In all eight-bit Mac encodings, the characters 0x00..0x7F are\n        // mapped to U+0000..U+007F; we only need to look up the others.\n        if (c <= 0x7F) {\n            result += String.fromCharCode(c);\n        } else {\n            result += table[c & 0x7F];\n        }\n    }\n\n    return result;\n};\n\n// Helper function for encode.MACSTRING. Returns a dictionary for mapping\n// Unicode character codes to their 8-bit MacOS equivalent. This table\n// is not exactly a super cheap data structure, but we do not care because\n// encoding Macintosh strings is only rarely needed in typical applications.\nvar macEncodingTableCache = typeof WeakMap === 'function' && new WeakMap();\nvar macEncodingCacheKeys;\nvar getMacEncodingTable = function (encoding) {\n    // Since we use encoding as a cache key for WeakMap, it has to be\n    // a String object and not a literal. And at least on NodeJS 2.10.1,\n    // WeakMap requires that the same String instance is passed for cache hits.\n    if (!macEncodingCacheKeys) {\n        macEncodingCacheKeys = {};\n        for (var e in eightBitMacEncodings) {\n            /*jshint -W053 */  // Suppress \"Do not use String as a constructor.\"\n            macEncodingCacheKeys[e] = new String(e);\n        }\n    }\n\n    var cacheKey = macEncodingCacheKeys[encoding];\n    if (cacheKey === undefined) {\n        return undefined;\n    }\n\n    // We can't do \"if (cache.has(key)) {return cache.get(key)}\" here:\n    // since garbage collection may run at any time, it could also kick in\n    // between the calls to cache.has() and cache.get(). In that case,\n    // we would return 'undefined' even though we do support the encoding.\n    if (macEncodingTableCache) {\n        var cachedTable = macEncodingTableCache.get(cacheKey);\n        if (cachedTable !== undefined) {\n            return cachedTable;\n        }\n    }\n\n    var decodingTable = eightBitMacEncodings[encoding];\n    if (decodingTable === undefined) {\n        return undefined;\n    }\n\n    var encodingTable = {};\n    for (var i = 0; i < decodingTable.length; i++) {\n        encodingTable[decodingTable.charCodeAt(i)] = i + 0x80;\n    }\n\n    if (macEncodingTableCache) {\n        macEncodingTableCache.set(cacheKey, encodingTable);\n    }\n\n    return encodingTable;\n};\n\n/**\n * Encodes an old-style Macintosh string. Returns a byte array upon success.\n * If the requested encoding is unsupported, or if the input string contains\n * a character that cannot be expressed in the encoding, the function returns\n * 'undefined'.\n * @param {string} str\n * @param {string} encoding\n * @returns {Array}\n */\nencode.MACSTRING = function(str, encoding) {\n    var table = getMacEncodingTable(encoding);\n    if (table === undefined) {\n        return undefined;\n    }\n\n    var result = [];\n    for (var i = 0; i < str.length; i++) {\n        var c = str.charCodeAt(i);\n\n        // In all eight-bit Mac encodings, the characters 0x00..0x7F are\n        // mapped to U+0000..U+007F; we only need to look up the others.\n        if (c >= 0x80) {\n            c = table[c];\n            if (c === undefined) {\n                // str contains a Unicode character that cannot be encoded\n                // in the requested encoding.\n                return undefined;\n            }\n        }\n        result[i] = c;\n        // result.push(c);\n    }\n\n    return result;\n};\n\n/**\n * @param {string} str\n * @param {string} encoding\n * @returns {number}\n */\nsizeOf.MACSTRING = function(str, encoding) {\n    var b = encode.MACSTRING(str, encoding);\n    if (b !== undefined) {\n        return b.length;\n    } else {\n        return 0;\n    }\n};\n\n// Helper for encode.VARDELTAS\nfunction isByteEncodable(value) {\n    return value >= -128 && value <= 127;\n}\n\n// Helper for encode.VARDELTAS\nfunction encodeVarDeltaRunAsZeroes(deltas, pos, result) {\n    var runLength = 0;\n    var numDeltas = deltas.length;\n    while (pos < numDeltas && runLength < 64 && deltas[pos] === 0) {\n        ++pos;\n        ++runLength;\n    }\n    result.push(0x80 | (runLength - 1));\n    return pos;\n}\n\n// Helper for encode.VARDELTAS\nfunction encodeVarDeltaRunAsBytes(deltas, offset, result) {\n    var runLength = 0;\n    var numDeltas = deltas.length;\n    var pos = offset;\n    while (pos < numDeltas && runLength < 64) {\n        var value = deltas[pos];\n        if (!isByteEncodable(value)) {\n            break;\n        }\n\n        // Within a byte-encoded run of deltas, a single zero is best\n        // stored literally as 0x00 value. However, if we have two or\n        // more zeroes in a sequence, it is better to start a new run.\n        // Fore example, the sequence of deltas [15, 15, 0, 15, 15]\n        // becomes 6 bytes (04 0F 0F 00 0F 0F) when storing the zero\n        // within the current run, but 7 bytes (01 0F 0F 80 01 0F 0F)\n        // when starting a new run.\n        if (value === 0 && pos + 1 < numDeltas && deltas[pos + 1] === 0) {\n            break;\n        }\n\n        ++pos;\n        ++runLength;\n    }\n    result.push(runLength - 1);\n    for (var i = offset; i < pos; ++i) {\n        result.push((deltas[i] + 256) & 0xff);\n    }\n    return pos;\n}\n\n// Helper for encode.VARDELTAS\nfunction encodeVarDeltaRunAsWords(deltas, offset, result) {\n    var runLength = 0;\n    var numDeltas = deltas.length;\n    var pos = offset;\n    while (pos < numDeltas && runLength < 64) {\n        var value = deltas[pos];\n\n        // Within a word-encoded run of deltas, it is easiest to start\n        // a new run (with a different encoding) whenever we encounter\n        // a zero value. For example, the sequence [0x6666, 0, 0x7777]\n        // needs 7 bytes when storing the zero inside the current run\n        // (42 66 66 00 00 77 77), and equally 7 bytes when starting a\n        // new run (40 66 66 80 40 77 77).\n        if (value === 0) {\n            break;\n        }\n\n        // Within a word-encoded run of deltas, a single value in the\n        // range (-128..127) should be encoded within the current run\n        // because it is more compact. For example, the sequence\n        // [0x6666, 2, 0x7777] becomes 7 bytes when storing the value\n        // literally (42 66 66 00 02 77 77), but 8 bytes when starting\n        // a new run (40 66 66 00 02 40 77 77).\n        if (isByteEncodable(value) && pos + 1 < numDeltas && isByteEncodable(deltas[pos + 1])) {\n            break;\n        }\n\n        ++pos;\n        ++runLength;\n    }\n    result.push(0x40 | (runLength - 1));\n    for (var i = offset; i < pos; ++i) {\n        var val = deltas[i];\n        result.push(((val + 0x10000) >> 8) & 0xff, (val + 0x100) & 0xff);\n    }\n    return pos;\n}\n\n/**\n * Encode a list of variation adjustment deltas.\n *\n * Variation adjustment deltas are used in ‘gvar’ and ‘cvar’ tables.\n * They indicate how points (in ‘gvar’) or values (in ‘cvar’) get adjusted\n * when generating instances of variation fonts.\n *\n * @see https://www.microsoft.com/typography/otspec/gvar.htm\n * @see https://developer.apple.com/fonts/TrueType-Reference-Manual/RM06/Chap6gvar.html\n * @param {Array}\n * @return {Array}\n */\nencode.VARDELTAS = function(deltas) {\n    var pos = 0;\n    var result = [];\n    while (pos < deltas.length) {\n        var value = deltas[pos];\n        if (value === 0) {\n            pos = encodeVarDeltaRunAsZeroes(deltas, pos, result);\n        } else if (value >= -128 && value <= 127) {\n            pos = encodeVarDeltaRunAsBytes(deltas, pos, result);\n        } else {\n            pos = encodeVarDeltaRunAsWords(deltas, pos, result);\n        }\n    }\n    return result;\n};\n\n// Convert a list of values to a CFF INDEX structure.\n// The values should be objects containing name / type / value.\n/**\n * @param {Array} l\n * @returns {Array}\n */\nencode.INDEX = function(l) {\n    //var offset, offsets, offsetEncoder, encodedOffsets, encodedOffset, data,\n    //    i, v;\n    // Because we have to know which data type to use to encode the offsets,\n    // we have to go through the values twice: once to encode the data and\n    // calculate the offsets, then again to encode the offsets using the fitting data type.\n    var offset = 1; // First offset is always 1.\n    var offsets = [offset];\n    var data = [];\n    for (var i = 0; i < l.length; i += 1) {\n        var v = encode.OBJECT(l[i]);\n        Array.prototype.push.apply(data, v);\n        offset += v.length;\n        offsets.push(offset);\n    }\n\n    if (data.length === 0) {\n        return [0, 0];\n    }\n\n    var encodedOffsets = [];\n    var offSize = (1 + Math.floor(Math.log(offset) / Math.log(2)) / 8) | 0;\n    var offsetEncoder = [undefined, encode.BYTE, encode.USHORT, encode.UINT24, encode.ULONG][offSize];\n    for (var i$1 = 0; i$1 < offsets.length; i$1 += 1) {\n        var encodedOffset = offsetEncoder(offsets[i$1]);\n        Array.prototype.push.apply(encodedOffsets, encodedOffset);\n    }\n\n    return Array.prototype.concat(encode.Card16(l.length),\n                           encode.OffSize(offSize),\n                           encodedOffsets,\n                           data);\n};\n\n/**\n * @param {Array}\n * @returns {number}\n */\nsizeOf.INDEX = function(v) {\n    return encode.INDEX(v).length;\n};\n\n/**\n * Convert an object to a CFF DICT structure.\n * The keys should be numeric.\n * The values should be objects containing name / type / value.\n * @param {Object} m\n * @returns {Array}\n */\nencode.DICT = function(m) {\n    var d = [];\n    var keys = Object.keys(m);\n    var length = keys.length;\n\n    for (var i = 0; i < length; i += 1) {\n        // Object.keys() return string keys, but our keys are always numeric.\n        var k = parseInt(keys[i], 0);\n        var v = m[k];\n        // Value comes before the key.\n        d = d.concat(encode.OPERAND(v.value, v.type));\n        d = d.concat(encode.OPERATOR(k));\n    }\n\n    return d;\n};\n\n/**\n * @param {Object}\n * @returns {number}\n */\nsizeOf.DICT = function(m) {\n    return encode.DICT(m).length;\n};\n\n/**\n * @param {number}\n * @returns {Array}\n */\nencode.OPERATOR = function(v) {\n    if (v < 1200) {\n        return [v];\n    } else {\n        return [12, v - 1200];\n    }\n};\n\n/**\n * @param {Array} v\n * @param {string}\n * @returns {Array}\n */\nencode.OPERAND = function(v, type) {\n    var d = [];\n    if (Array.isArray(type)) {\n        for (var i = 0; i < type.length; i += 1) {\n            check.argument(v.length === type.length, 'Not enough arguments given for type' + type);\n            d = d.concat(encode.OPERAND(v[i], type[i]));\n        }\n    } else {\n        if (type === 'SID') {\n            d = d.concat(encode.NUMBER(v));\n        } else if (type === 'offset') {\n            // We make it easy for ourselves and always encode offsets as\n            // 4 bytes. This makes offset calculation for the top dict easier.\n            d = d.concat(encode.NUMBER32(v));\n        } else if (type === 'number') {\n            d = d.concat(encode.NUMBER(v));\n        } else if (type === 'real') {\n            d = d.concat(encode.REAL(v));\n        } else {\n            throw new Error('Unknown operand type ' + type);\n            // FIXME Add support for booleans\n        }\n    }\n\n    return d;\n};\n\nencode.OP = encode.BYTE;\nsizeOf.OP = sizeOf.BYTE;\n\n// memoize charstring encoding using WeakMap if available\nvar wmm = typeof WeakMap === 'function' && new WeakMap();\n\n/**\n * Convert a list of CharString operations to bytes.\n * @param {Array}\n * @returns {Array}\n */\nencode.CHARSTRING = function(ops) {\n    // See encode.MACSTRING for why we don't do \"if (wmm && wmm.has(ops))\".\n    if (wmm) {\n        var cachedValue = wmm.get(ops);\n        if (cachedValue !== undefined) {\n            return cachedValue;\n        }\n    }\n\n    var d = [];\n    var length = ops.length;\n\n    for (var i = 0; i < length; i += 1) {\n        var op = ops[i];\n        d = d.concat(encode[op.type](op.value));\n    }\n\n    if (wmm) {\n        wmm.set(ops, d);\n    }\n\n    return d;\n};\n\n/**\n * @param {Array}\n * @returns {number}\n */\nsizeOf.CHARSTRING = function(ops) {\n    return encode.CHARSTRING(ops).length;\n};\n\n// Utility functions ////////////////////////////////////////////////////////\n\n/**\n * Convert an object containing name / type / value to bytes.\n * @param {Object}\n * @returns {Array}\n */\nencode.OBJECT = function(v) {\n    var encodingFunction = encode[v.type];\n    check.argument(encodingFunction !== undefined, 'No encoding function for type ' + v.type);\n    return encodingFunction(v.value);\n};\n\n/**\n * @param {Object}\n * @returns {number}\n */\nsizeOf.OBJECT = function(v) {\n    var sizeOfFunction = sizeOf[v.type];\n    check.argument(sizeOfFunction !== undefined, 'No sizeOf function for type ' + v.type);\n    return sizeOfFunction(v.value);\n};\n\n/**\n * Convert a table object to bytes.\n * A table contains a list of fields containing the metadata (name, type and default value).\n * The table itself has the field values set as attributes.\n * @param {opentype.Table}\n * @returns {Array}\n */\nencode.TABLE = function(table) {\n    var d = [];\n    var length = table.fields.length;\n    var subtables = [];\n    var subtableOffsets = [];\n\n    for (var i = 0; i < length; i += 1) {\n        var field = table.fields[i];\n        var encodingFunction = encode[field.type];\n        check.argument(encodingFunction !== undefined, 'No encoding function for field type ' + field.type + ' (' + field.name + ')');\n        var value = table[field.name];\n        if (value === undefined) {\n            value = field.value;\n        }\n\n        var bytes = encodingFunction(value);\n\n        if (field.type === 'TABLE') {\n            subtableOffsets.push(d.length);\n            d = d.concat([0, 0]);\n            subtables.push(bytes);\n        } else {\n            d = d.concat(bytes);\n        }\n    }\n\n    for (var i$1 = 0; i$1 < subtables.length; i$1 += 1) {\n        var o = subtableOffsets[i$1];\n        var offset = d.length;\n        check.argument(offset < 65536, 'Table ' + table.tableName + ' too big.');\n        d[o] = offset >> 8;\n        d[o + 1] = offset & 0xff;\n        d = d.concat(subtables[i$1]);\n    }\n\n    return d;\n};\n\n/**\n * @param {opentype.Table}\n * @returns {number}\n */\nsizeOf.TABLE = function(table) {\n    var numBytes = 0;\n    var length = table.fields.length;\n\n    for (var i = 0; i < length; i += 1) {\n        var field = table.fields[i];\n        var sizeOfFunction = sizeOf[field.type];\n        check.argument(sizeOfFunction !== undefined, 'No sizeOf function for field type ' + field.type + ' (' + field.name + ')');\n        var value = table[field.name];\n        if (value === undefined) {\n            value = field.value;\n        }\n\n        numBytes += sizeOfFunction(value);\n\n        // Subtables take 2 more bytes for offsets.\n        if (field.type === 'TABLE') {\n            numBytes += 2;\n        }\n    }\n\n    return numBytes;\n};\n\nencode.RECORD = encode.TABLE;\nsizeOf.RECORD = sizeOf.TABLE;\n\n// Merge in a list of bytes.\nencode.LITERAL = function(v) {\n    return v;\n};\n\nsizeOf.LITERAL = function(v) {\n    return v.length;\n};\n\n// Table metadata\n\n/**\n * @exports opentype.Table\n * @class\n * @param {string} tableName\n * @param {Array} fields\n * @param {Object} options\n * @constructor\n */\nfunction Table(tableName, fields, options) {\n    // For coverage tables with coverage format 2, we do not want to add the coverage data directly to the table object,\n    // as this will result in wrong encoding order of the coverage data on serialization to bytes.\n    // The fallback of using the field values directly when not present on the table is handled in types.encode.TABLE() already.\n    if (fields.length && (fields[0].name !== 'coverageFormat' || fields[0].value === 1)) {\n        for (var i = 0; i < fields.length; i += 1) {\n            var field = fields[i];\n            this[field.name] = field.value;\n        }\n    }\n\n    this.tableName = tableName;\n    this.fields = fields;\n    if (options) {\n        var optionKeys = Object.keys(options);\n        for (var i$1 = 0; i$1 < optionKeys.length; i$1 += 1) {\n            var k = optionKeys[i$1];\n            var v = options[k];\n            if (this[k] !== undefined) {\n                this[k] = v;\n            }\n        }\n    }\n}\n\n/**\n * Encodes the table and returns an array of bytes\n * @return {Array}\n */\nTable.prototype.encode = function() {\n    return encode.TABLE(this);\n};\n\n/**\n * Get the size of the table.\n * @return {number}\n */\nTable.prototype.sizeOf = function() {\n    return sizeOf.TABLE(this);\n};\n\n/**\n * @private\n */\nfunction ushortList(itemName, list, count) {\n    if (count === undefined) {\n        count = list.length;\n    }\n    var fields = new Array(list.length + 1);\n    fields[0] = {name: itemName + 'Count', type: 'USHORT', value: count};\n    for (var i = 0; i < list.length; i++) {\n        fields[i + 1] = {name: itemName + i, type: 'USHORT', value: list[i]};\n    }\n    return fields;\n}\n\n/**\n * @private\n */\nfunction tableList(itemName, records, itemCallback) {\n    var count = records.length;\n    var fields = new Array(count + 1);\n    fields[0] = {name: itemName + 'Count', type: 'USHORT', value: count};\n    for (var i = 0; i < count; i++) {\n        fields[i + 1] = {name: itemName + i, type: 'TABLE', value: itemCallback(records[i], i)};\n    }\n    return fields;\n}\n\n/**\n * @private\n */\nfunction recordList(itemName, records, itemCallback) {\n    var count = records.length;\n    var fields = [];\n    fields[0] = {name: itemName + 'Count', type: 'USHORT', value: count};\n    for (var i = 0; i < count; i++) {\n        fields = fields.concat(itemCallback(records[i], i));\n    }\n    return fields;\n}\n\n// Common Layout Tables\n\n/**\n * @exports opentype.Coverage\n * @class\n * @param {opentype.Table}\n * @constructor\n * @extends opentype.Table\n */\nfunction Coverage(coverageTable) {\n    if (coverageTable.format === 1) {\n        Table.call(this, 'coverageTable',\n            [{name: 'coverageFormat', type: 'USHORT', value: 1}]\n            .concat(ushortList('glyph', coverageTable.glyphs))\n        );\n    } else if (coverageTable.format === 2) {\n        Table.call(this, 'coverageTable',\n            [{name: 'coverageFormat', type: 'USHORT', value: 2}]\n            .concat(recordList('rangeRecord', coverageTable.ranges, function(RangeRecord) {\n                return [\n                    {name: 'startGlyphID', type: 'USHORT', value: RangeRecord.start},\n                    {name: 'endGlyphID', type: 'USHORT', value: RangeRecord.end},\n                    {name: 'startCoverageIndex', type: 'USHORT', value: RangeRecord.index} ];\n            }))\n        );\n    } else {\n        check.assert(false, 'Coverage format must be 1 or 2.');\n    }\n}\nCoverage.prototype = Object.create(Table.prototype);\nCoverage.prototype.constructor = Coverage;\n\nfunction ScriptList(scriptListTable) {\n    Table.call(this, 'scriptListTable',\n        recordList('scriptRecord', scriptListTable, function(scriptRecord, i) {\n            var script = scriptRecord.script;\n            var defaultLangSys = script.defaultLangSys;\n            check.assert(!!defaultLangSys, 'Unable to write GSUB: script ' + scriptRecord.tag + ' has no default language system.');\n            return [\n                {name: 'scriptTag' + i, type: 'TAG', value: scriptRecord.tag},\n                {name: 'script' + i, type: 'TABLE', value: new Table('scriptTable', [\n                    {name: 'defaultLangSys', type: 'TABLE', value: new Table('defaultLangSys', [\n                        {name: 'lookupOrder', type: 'USHORT', value: 0},\n                        {name: 'reqFeatureIndex', type: 'USHORT', value: defaultLangSys.reqFeatureIndex}]\n                        .concat(ushortList('featureIndex', defaultLangSys.featureIndexes)))}\n                    ].concat(recordList('langSys', script.langSysRecords, function(langSysRecord, i) {\n                        var langSys = langSysRecord.langSys;\n                        return [\n                            {name: 'langSysTag' + i, type: 'TAG', value: langSysRecord.tag},\n                            {name: 'langSys' + i, type: 'TABLE', value: new Table('langSys', [\n                                {name: 'lookupOrder', type: 'USHORT', value: 0},\n                                {name: 'reqFeatureIndex', type: 'USHORT', value: langSys.reqFeatureIndex}\n                                ].concat(ushortList('featureIndex', langSys.featureIndexes)))}\n                        ];\n                    })))}\n            ];\n        })\n    );\n}\nScriptList.prototype = Object.create(Table.prototype);\nScriptList.prototype.constructor = ScriptList;\n\n/**\n * @exports opentype.FeatureList\n * @class\n * @param {opentype.Table}\n * @constructor\n * @extends opentype.Table\n */\nfunction FeatureList(featureListTable) {\n    Table.call(this, 'featureListTable',\n        recordList('featureRecord', featureListTable, function(featureRecord, i) {\n            var feature = featureRecord.feature;\n            return [\n                {name: 'featureTag' + i, type: 'TAG', value: featureRecord.tag},\n                {name: 'feature' + i, type: 'TABLE', value: new Table('featureTable', [\n                    {name: 'featureParams', type: 'USHORT', value: feature.featureParams} ].concat(ushortList('lookupListIndex', feature.lookupListIndexes)))}\n            ];\n        })\n    );\n}\nFeatureList.prototype = Object.create(Table.prototype);\nFeatureList.prototype.constructor = FeatureList;\n\n/**\n * @exports opentype.LookupList\n * @class\n * @param {opentype.Table}\n * @param {Object}\n * @constructor\n * @extends opentype.Table\n */\nfunction LookupList(lookupListTable, subtableMakers) {\n    Table.call(this, 'lookupListTable', tableList('lookup', lookupListTable, function(lookupTable) {\n        var subtableCallback = subtableMakers[lookupTable.lookupType];\n        check.assert(!!subtableCallback, 'Unable to write GSUB lookup type ' + lookupTable.lookupType + ' tables.');\n        return new Table('lookupTable', [\n            {name: 'lookupType', type: 'USHORT', value: lookupTable.lookupType},\n            {name: 'lookupFlag', type: 'USHORT', value: lookupTable.lookupFlag}\n        ].concat(tableList('subtable', lookupTable.subtables, subtableCallback)));\n    }));\n}\nLookupList.prototype = Object.create(Table.prototype);\nLookupList.prototype.constructor = LookupList;\n\n// Record = same as Table, but inlined (a Table has an offset and its data is further in the stream)\n// Don't use offsets inside Records (probable bug), only in Tables.\nvar table = {\n    Table: Table,\n    Record: Table,\n    Coverage: Coverage,\n    ScriptList: ScriptList,\n    FeatureList: FeatureList,\n    LookupList: LookupList,\n    ushortList: ushortList,\n    tableList: tableList,\n    recordList: recordList,\n};\n\n// Parsing utility functions\n\n// Retrieve an unsigned byte from the DataView.\nfunction getByte(dataView, offset) {\n    return dataView.getUint8(offset);\n}\n\n// Retrieve an unsigned 16-bit short from the DataView.\n// The value is stored in big endian.\nfunction getUShort(dataView, offset) {\n    return dataView.getUint16(offset, false);\n}\n\n// Retrieve a signed 16-bit short from the DataView.\n// The value is stored in big endian.\nfunction getShort(dataView, offset) {\n    return dataView.getInt16(offset, false);\n}\n\n// Retrieve an unsigned 32-bit long from the DataView.\n// The value is stored in big endian.\nfunction getULong(dataView, offset) {\n    return dataView.getUint32(offset, false);\n}\n\n// Retrieve a 32-bit signed fixed-point number (16.16) from the DataView.\n// The value is stored in big endian.\nfunction getFixed(dataView, offset) {\n    var decimal = dataView.getInt16(offset, false);\n    var fraction = dataView.getUint16(offset + 2, false);\n    return decimal + fraction / 65535;\n}\n\n// Retrieve a 4-character tag from the DataView.\n// Tags are used to identify tables.\nfunction getTag(dataView, offset) {\n    var tag = '';\n    for (var i = offset; i < offset + 4; i += 1) {\n        tag += String.fromCharCode(dataView.getInt8(i));\n    }\n\n    return tag;\n}\n\n// Retrieve an offset from the DataView.\n// Offsets are 1 to 4 bytes in length, depending on the offSize argument.\nfunction getOffset(dataView, offset, offSize) {\n    var v = 0;\n    for (var i = 0; i < offSize; i += 1) {\n        v <<= 8;\n        v += dataView.getUint8(offset + i);\n    }\n\n    return v;\n}\n\n// Retrieve a number of bytes from start offset to the end offset from the DataView.\nfunction getBytes(dataView, startOffset, endOffset) {\n    var bytes = [];\n    for (var i = startOffset; i < endOffset; i += 1) {\n        bytes.push(dataView.getUint8(i));\n    }\n\n    return bytes;\n}\n\n// Convert the list of bytes to a string.\nfunction bytesToString(bytes) {\n    var s = '';\n    for (var i = 0; i < bytes.length; i += 1) {\n        s += String.fromCharCode(bytes[i]);\n    }\n\n    return s;\n}\n\nvar typeOffsets = {\n    byte: 1,\n    uShort: 2,\n    short: 2,\n    uLong: 4,\n    fixed: 4,\n    longDateTime: 8,\n    tag: 4\n};\n\n// A stateful parser that changes the offset whenever a value is retrieved.\n// The data is a DataView.\nfunction Parser(data, offset) {\n    this.data = data;\n    this.offset = offset;\n    this.relativeOffset = 0;\n}\n\nParser.prototype.parseByte = function() {\n    var v = this.data.getUint8(this.offset + this.relativeOffset);\n    this.relativeOffset += 1;\n    return v;\n};\n\nParser.prototype.parseChar = function() {\n    var v = this.data.getInt8(this.offset + this.relativeOffset);\n    this.relativeOffset += 1;\n    return v;\n};\n\nParser.prototype.parseCard8 = Parser.prototype.parseByte;\n\nParser.prototype.parseUShort = function() {\n    var v = this.data.getUint16(this.offset + this.relativeOffset);\n    this.relativeOffset += 2;\n    return v;\n};\n\nParser.prototype.parseCard16 = Parser.prototype.parseUShort;\nParser.prototype.parseSID = Parser.prototype.parseUShort;\nParser.prototype.parseOffset16 = Parser.prototype.parseUShort;\n\nParser.prototype.parseShort = function() {\n    var v = this.data.getInt16(this.offset + this.relativeOffset);\n    this.relativeOffset += 2;\n    return v;\n};\n\nParser.prototype.parseF2Dot14 = function() {\n    var v = this.data.getInt16(this.offset + this.relativeOffset) / 16384;\n    this.relativeOffset += 2;\n    return v;\n};\n\nParser.prototype.parseULong = function() {\n    var v = getULong(this.data, this.offset + this.relativeOffset);\n    this.relativeOffset += 4;\n    return v;\n};\n\nParser.prototype.parseOffset32 = Parser.prototype.parseULong;\n\nParser.prototype.parseFixed = function() {\n    var v = getFixed(this.data, this.offset + this.relativeOffset);\n    this.relativeOffset += 4;\n    return v;\n};\n\nParser.prototype.parseString = function(length) {\n    var dataView = this.data;\n    var offset = this.offset + this.relativeOffset;\n    var string = '';\n    this.relativeOffset += length;\n    for (var i = 0; i < length; i++) {\n        string += String.fromCharCode(dataView.getUint8(offset + i));\n    }\n\n    return string;\n};\n\nParser.prototype.parseTag = function() {\n    return this.parseString(4);\n};\n\n// LONGDATETIME is a 64-bit integer.\n// JavaScript and unix timestamps traditionally use 32 bits, so we\n// only take the last 32 bits.\n// + Since until 2038 those bits will be filled by zeros we can ignore them.\nParser.prototype.parseLongDateTime = function() {\n    var v = getULong(this.data, this.offset + this.relativeOffset + 4);\n    // Subtract seconds between 01/01/1904 and 01/01/1970\n    // to convert Apple Mac timestamp to Standard Unix timestamp\n    v -= 2082844800;\n    this.relativeOffset += 8;\n    return v;\n};\n\nParser.prototype.parseVersion = function(minorBase) {\n    var major = getUShort(this.data, this.offset + this.relativeOffset);\n\n    // How to interpret the minor version is very vague in the spec. 0x5000 is 5, 0x1000 is 1\n    // Default returns the correct number if minor = 0xN000 where N is 0-9\n    // Set minorBase to 1 for tables that use minor = N where N is 0-9\n    var minor = getUShort(this.data, this.offset + this.relativeOffset + 2);\n    this.relativeOffset += 4;\n    if (minorBase === undefined) { minorBase = 0x1000; }\n    return major + minor / minorBase / 10;\n};\n\nParser.prototype.skip = function(type, amount) {\n    if (amount === undefined) {\n        amount = 1;\n    }\n\n    this.relativeOffset += typeOffsets[type] * amount;\n};\n\n///// Parsing lists and records ///////////////////////////////\n\n// Parse a list of 32 bit unsigned integers.\nParser.prototype.parseULongList = function(count) {\n    if (count === undefined) { count = this.parseULong(); }\n    var offsets = new Array(count);\n    var dataView = this.data;\n    var offset = this.offset + this.relativeOffset;\n    for (var i = 0; i < count; i++) {\n        offsets[i] = dataView.getUint32(offset);\n        offset += 4;\n    }\n\n    this.relativeOffset += count * 4;\n    return offsets;\n};\n\n// Parse a list of 16 bit unsigned integers. The length of the list can be read on the stream\n// or provided as an argument.\nParser.prototype.parseOffset16List =\nParser.prototype.parseUShortList = function(count) {\n    if (count === undefined) { count = this.parseUShort(); }\n    var offsets = new Array(count);\n    var dataView = this.data;\n    var offset = this.offset + this.relativeOffset;\n    for (var i = 0; i < count; i++) {\n        offsets[i] = dataView.getUint16(offset);\n        offset += 2;\n    }\n\n    this.relativeOffset += count * 2;\n    return offsets;\n};\n\n// Parses a list of 16 bit signed integers.\nParser.prototype.parseShortList = function(count) {\n    var list = new Array(count);\n    var dataView = this.data;\n    var offset = this.offset + this.relativeOffset;\n    for (var i = 0; i < count; i++) {\n        list[i] = dataView.getInt16(offset);\n        offset += 2;\n    }\n\n    this.relativeOffset += count * 2;\n    return list;\n};\n\n// Parses a list of bytes.\nParser.prototype.parseByteList = function(count) {\n    var list = new Array(count);\n    var dataView = this.data;\n    var offset = this.offset + this.relativeOffset;\n    for (var i = 0; i < count; i++) {\n        list[i] = dataView.getUint8(offset++);\n    }\n\n    this.relativeOffset += count;\n    return list;\n};\n\n/**\n * Parse a list of items.\n * Record count is optional, if omitted it is read from the stream.\n * itemCallback is one of the Parser methods.\n */\nParser.prototype.parseList = function(count, itemCallback) {\n    if (!itemCallback) {\n        itemCallback = count;\n        count = this.parseUShort();\n    }\n    var list = new Array(count);\n    for (var i = 0; i < count; i++) {\n        list[i] = itemCallback.call(this);\n    }\n    return list;\n};\n\nParser.prototype.parseList32 = function(count, itemCallback) {\n    if (!itemCallback) {\n        itemCallback = count;\n        count = this.parseULong();\n    }\n    var list = new Array(count);\n    for (var i = 0; i < count; i++) {\n        list[i] = itemCallback.call(this);\n    }\n    return list;\n};\n\n/**\n * Parse a list of records.\n * Record count is optional, if omitted it is read from the stream.\n * Example of recordDescription: { sequenceIndex: Parser.uShort, lookupListIndex: Parser.uShort }\n */\nParser.prototype.parseRecordList = function(count, recordDescription) {\n    // If the count argument is absent, read it in the stream.\n    if (!recordDescription) {\n        recordDescription = count;\n        count = this.parseUShort();\n    }\n    var records = new Array(count);\n    var fields = Object.keys(recordDescription);\n    for (var i = 0; i < count; i++) {\n        var rec = {};\n        for (var j = 0; j < fields.length; j++) {\n            var fieldName = fields[j];\n            var fieldType = recordDescription[fieldName];\n            rec[fieldName] = fieldType.call(this);\n        }\n        records[i] = rec;\n    }\n    return records;\n};\n\nParser.prototype.parseRecordList32 = function(count, recordDescription) {\n    // If the count argument is absent, read it in the stream.\n    if (!recordDescription) {\n        recordDescription = count;\n        count = this.parseULong();\n    }\n    var records = new Array(count);\n    var fields = Object.keys(recordDescription);\n    for (var i = 0; i < count; i++) {\n        var rec = {};\n        for (var j = 0; j < fields.length; j++) {\n            var fieldName = fields[j];\n            var fieldType = recordDescription[fieldName];\n            rec[fieldName] = fieldType.call(this);\n        }\n        records[i] = rec;\n    }\n    return records;\n};\n\n// Parse a data structure into an object\n// Example of description: { sequenceIndex: Parser.uShort, lookupListIndex: Parser.uShort }\nParser.prototype.parseStruct = function(description) {\n    if (typeof description === 'function') {\n        return description.call(this);\n    } else {\n        var fields = Object.keys(description);\n        var struct = {};\n        for (var j = 0; j < fields.length; j++) {\n            var fieldName = fields[j];\n            var fieldType = description[fieldName];\n            struct[fieldName] = fieldType.call(this);\n        }\n        return struct;\n    }\n};\n\n/**\n * Parse a GPOS valueRecord\n * https://docs.microsoft.com/en-us/typography/opentype/spec/gpos#value-record\n * valueFormat is optional, if omitted it is read from the stream.\n */\nParser.prototype.parseValueRecord = function(valueFormat) {\n    if (valueFormat === undefined) {\n        valueFormat = this.parseUShort();\n    }\n    if (valueFormat === 0) {\n        // valueFormat2 in kerning pairs is most often 0\n        // in this case return undefined instead of an empty object, to save space\n        return;\n    }\n    var valueRecord = {};\n\n    if (valueFormat & 0x0001) { valueRecord.xPlacement = this.parseShort(); }\n    if (valueFormat & 0x0002) { valueRecord.yPlacement = this.parseShort(); }\n    if (valueFormat & 0x0004) { valueRecord.xAdvance = this.parseShort(); }\n    if (valueFormat & 0x0008) { valueRecord.yAdvance = this.parseShort(); }\n\n    // Device table (non-variable font) / VariationIndex table (variable font) not supported\n    // https://docs.microsoft.com/fr-fr/typography/opentype/spec/chapter2#devVarIdxTbls\n    if (valueFormat & 0x0010) { valueRecord.xPlaDevice = undefined; this.parseShort(); }\n    if (valueFormat & 0x0020) { valueRecord.yPlaDevice = undefined; this.parseShort(); }\n    if (valueFormat & 0x0040) { valueRecord.xAdvDevice = undefined; this.parseShort(); }\n    if (valueFormat & 0x0080) { valueRecord.yAdvDevice = undefined; this.parseShort(); }\n\n    return valueRecord;\n};\n\n/**\n * Parse a list of GPOS valueRecords\n * https://docs.microsoft.com/en-us/typography/opentype/spec/gpos#value-record\n * valueFormat and valueCount are read from the stream.\n */\nParser.prototype.parseValueRecordList = function() {\n    var valueFormat = this.parseUShort();\n    var valueCount = this.parseUShort();\n    var values = new Array(valueCount);\n    for (var i = 0; i < valueCount; i++) {\n        values[i] = this.parseValueRecord(valueFormat);\n    }\n    return values;\n};\n\nParser.prototype.parsePointer = function(description) {\n    var structOffset = this.parseOffset16();\n    if (structOffset > 0) {\n        // NULL offset => return undefined\n        return new Parser(this.data, this.offset + structOffset).parseStruct(description);\n    }\n    return undefined;\n};\n\nParser.prototype.parsePointer32 = function(description) {\n    var structOffset = this.parseOffset32();\n    if (structOffset > 0) {\n        // NULL offset => return undefined\n        return new Parser(this.data, this.offset + structOffset).parseStruct(description);\n    }\n    return undefined;\n};\n\n/**\n * Parse a list of offsets to lists of 16-bit integers,\n * or a list of offsets to lists of offsets to any kind of items.\n * If itemCallback is not provided, a list of list of UShort is assumed.\n * If provided, itemCallback is called on each item and must parse the item.\n * See examples in tables/gsub.js\n */\nParser.prototype.parseListOfLists = function(itemCallback) {\n    var offsets = this.parseOffset16List();\n    var count = offsets.length;\n    var relativeOffset = this.relativeOffset;\n    var list = new Array(count);\n    for (var i = 0; i < count; i++) {\n        var start = offsets[i];\n        if (start === 0) {\n            // NULL offset\n            // Add i as owned property to list. Convenient with assert.\n            list[i] = undefined;\n            continue;\n        }\n        this.relativeOffset = start;\n        if (itemCallback) {\n            var subOffsets = this.parseOffset16List();\n            var subList = new Array(subOffsets.length);\n            for (var j = 0; j < subOffsets.length; j++) {\n                this.relativeOffset = start + subOffsets[j];\n                subList[j] = itemCallback.call(this);\n            }\n            list[i] = subList;\n        } else {\n            list[i] = this.parseUShortList();\n        }\n    }\n    this.relativeOffset = relativeOffset;\n    return list;\n};\n\n///// Complex tables parsing //////////////////////////////////\n\n// Parse a coverage table in a GSUB, GPOS or GDEF table.\n// https://www.microsoft.com/typography/OTSPEC/chapter2.htm\n// parser.offset must point to the start of the table containing the coverage.\nParser.prototype.parseCoverage = function() {\n    var startOffset = this.offset + this.relativeOffset;\n    var format = this.parseUShort();\n    var count = this.parseUShort();\n    if (format === 1) {\n        return {\n            format: 1,\n            glyphs: this.parseUShortList(count)\n        };\n    } else if (format === 2) {\n        var ranges = new Array(count);\n        for (var i = 0; i < count; i++) {\n            ranges[i] = {\n                start: this.parseUShort(),\n                end: this.parseUShort(),\n                index: this.parseUShort()\n            };\n        }\n        return {\n            format: 2,\n            ranges: ranges\n        };\n    }\n    throw new Error('0x' + startOffset.toString(16) + ': Coverage format must be 1 or 2.');\n};\n\n// Parse a Class Definition Table in a GSUB, GPOS or GDEF table.\n// https://www.microsoft.com/typography/OTSPEC/chapter2.htm\nParser.prototype.parseClassDef = function() {\n    var startOffset = this.offset + this.relativeOffset;\n    var format = this.parseUShort();\n    if (format === 1) {\n        return {\n            format: 1,\n            startGlyph: this.parseUShort(),\n            classes: this.parseUShortList()\n        };\n    } else if (format === 2) {\n        return {\n            format: 2,\n            ranges: this.parseRecordList({\n                start: Parser.uShort,\n                end: Parser.uShort,\n                classId: Parser.uShort\n            })\n        };\n    }\n    throw new Error('0x' + startOffset.toString(16) + ': ClassDef format must be 1 or 2.');\n};\n\n///// Static methods ///////////////////////////////////\n// These convenience methods can be used as callbacks and should be called with \"this\" context set to a Parser instance.\n\nParser.list = function(count, itemCallback) {\n    return function() {\n        return this.parseList(count, itemCallback);\n    };\n};\n\nParser.list32 = function(count, itemCallback) {\n    return function() {\n        return this.parseList32(count, itemCallback);\n    };\n};\n\nParser.recordList = function(count, recordDescription) {\n    return function() {\n        return this.parseRecordList(count, recordDescription);\n    };\n};\n\nParser.recordList32 = function(count, recordDescription) {\n    return function() {\n        return this.parseRecordList32(count, recordDescription);\n    };\n};\n\nParser.pointer = function(description) {\n    return function() {\n        return this.parsePointer(description);\n    };\n};\n\nParser.pointer32 = function(description) {\n    return function() {\n        return this.parsePointer32(description);\n    };\n};\n\nParser.tag = Parser.prototype.parseTag;\nParser.byte = Parser.prototype.parseByte;\nParser.uShort = Parser.offset16 = Parser.prototype.parseUShort;\nParser.uShortList = Parser.prototype.parseUShortList;\nParser.uLong = Parser.offset32 = Parser.prototype.parseULong;\nParser.uLongList = Parser.prototype.parseULongList;\nParser.struct = Parser.prototype.parseStruct;\nParser.coverage = Parser.prototype.parseCoverage;\nParser.classDef = Parser.prototype.parseClassDef;\n\n///// Script, Feature, Lookup lists ///////////////////////////////////////////////\n// https://www.microsoft.com/typography/OTSPEC/chapter2.htm\n\nvar langSysTable = {\n    reserved: Parser.uShort,\n    reqFeatureIndex: Parser.uShort,\n    featureIndexes: Parser.uShortList\n};\n\nParser.prototype.parseScriptList = function() {\n    return this.parsePointer(Parser.recordList({\n        tag: Parser.tag,\n        script: Parser.pointer({\n            defaultLangSys: Parser.pointer(langSysTable),\n            langSysRecords: Parser.recordList({\n                tag: Parser.tag,\n                langSys: Parser.pointer(langSysTable)\n            })\n        })\n    })) || [];\n};\n\nParser.prototype.parseFeatureList = function() {\n    return this.parsePointer(Parser.recordList({\n        tag: Parser.tag,\n        feature: Parser.pointer({\n            featureParams: Parser.offset16,\n            lookupListIndexes: Parser.uShortList\n        })\n    })) || [];\n};\n\nParser.prototype.parseLookupList = function(lookupTableParsers) {\n    return this.parsePointer(Parser.list(Parser.pointer(function() {\n        var lookupType = this.parseUShort();\n        check.argument(1 <= lookupType && lookupType <= 9, 'GPOS/GSUB lookup type ' + lookupType + ' unknown.');\n        var lookupFlag = this.parseUShort();\n        var useMarkFilteringSet = lookupFlag & 0x10;\n        return {\n            lookupType: lookupType,\n            lookupFlag: lookupFlag,\n            subtables: this.parseList(Parser.pointer(lookupTableParsers[lookupType])),\n            markFilteringSet: useMarkFilteringSet ? this.parseUShort() : undefined\n        };\n    }))) || [];\n};\n\nParser.prototype.parseFeatureVariationsList = function() {\n    return this.parsePointer32(function() {\n        var majorVersion = this.parseUShort();\n        var minorVersion = this.parseUShort();\n        check.argument(majorVersion === 1 && minorVersion < 1, 'GPOS/GSUB feature variations table unknown.');\n        var featureVariations = this.parseRecordList32({\n            conditionSetOffset: Parser.offset32,\n            featureTableSubstitutionOffset: Parser.offset32\n        });\n        return featureVariations;\n    }) || [];\n};\n\nvar parse = {\n    getByte: getByte,\n    getCard8: getByte,\n    getUShort: getUShort,\n    getCard16: getUShort,\n    getShort: getShort,\n    getULong: getULong,\n    getFixed: getFixed,\n    getTag: getTag,\n    getOffset: getOffset,\n    getBytes: getBytes,\n    bytesToString: bytesToString,\n    Parser: Parser,\n};\n\n// The `cmap` table stores the mappings from characters to glyphs.\n\nfunction parseCmapTableFormat12(cmap, p) {\n    //Skip reserved.\n    p.parseUShort();\n\n    // Length in bytes of the sub-tables.\n    cmap.length = p.parseULong();\n    cmap.language = p.parseULong();\n\n    var groupCount;\n    cmap.groupCount = groupCount = p.parseULong();\n    cmap.glyphIndexMap = {};\n\n    for (var i = 0; i < groupCount; i += 1) {\n        var startCharCode = p.parseULong();\n        var endCharCode = p.parseULong();\n        var startGlyphId = p.parseULong();\n\n        for (var c = startCharCode; c <= endCharCode; c += 1) {\n            cmap.glyphIndexMap[c] = startGlyphId;\n            startGlyphId++;\n        }\n    }\n}\n\nfunction parseCmapTableFormat4(cmap, p, data, start, offset) {\n    // Length in bytes of the sub-tables.\n    cmap.length = p.parseUShort();\n    cmap.language = p.parseUShort();\n\n    // segCount is stored x 2.\n    var segCount;\n    cmap.segCount = segCount = p.parseUShort() >> 1;\n\n    // Skip searchRange, entrySelector, rangeShift.\n    p.skip('uShort', 3);\n\n    // The \"unrolled\" mapping from character codes to glyph indices.\n    cmap.glyphIndexMap = {};\n    var endCountParser = new parse.Parser(data, start + offset + 14);\n    var startCountParser = new parse.Parser(data, start + offset + 16 + segCount * 2);\n    var idDeltaParser = new parse.Parser(data, start + offset + 16 + segCount * 4);\n    var idRangeOffsetParser = new parse.Parser(data, start + offset + 16 + segCount * 6);\n    var glyphIndexOffset = start + offset + 16 + segCount * 8;\n    for (var i = 0; i < segCount - 1; i += 1) {\n        var glyphIndex = (void 0);\n        var endCount = endCountParser.parseUShort();\n        var startCount = startCountParser.parseUShort();\n        var idDelta = idDeltaParser.parseShort();\n        var idRangeOffset = idRangeOffsetParser.parseUShort();\n        for (var c = startCount; c <= endCount; c += 1) {\n            if (idRangeOffset !== 0) {\n                // The idRangeOffset is relative to the current position in the idRangeOffset array.\n                // Take the current offset in the idRangeOffset array.\n                glyphIndexOffset = (idRangeOffsetParser.offset + idRangeOffsetParser.relativeOffset - 2);\n\n                // Add the value of the idRangeOffset, which will move us into the glyphIndex array.\n                glyphIndexOffset += idRangeOffset;\n\n                // Then add the character index of the current segment, multiplied by 2 for USHORTs.\n                glyphIndexOffset += (c - startCount) * 2;\n                glyphIndex = parse.getUShort(data, glyphIndexOffset);\n                if (glyphIndex !== 0) {\n                    glyphIndex = (glyphIndex + idDelta) & 0xFFFF;\n                }\n            } else {\n                glyphIndex = (c + idDelta) & 0xFFFF;\n            }\n\n            cmap.glyphIndexMap[c] = glyphIndex;\n        }\n    }\n}\n\n// Parse the `cmap` table. This table stores the mappings from characters to glyphs.\n// There are many available formats, but we only support the Windows format 4 and 12.\n// This function returns a `CmapEncoding` object or null if no supported format could be found.\nfunction parseCmapTable(data, start) {\n    var cmap = {};\n    cmap.version = parse.getUShort(data, start);\n    check.argument(cmap.version === 0, 'cmap table version should be 0.');\n\n    // The cmap table can contain many sub-tables, each with their own format.\n    // We're only interested in a \"platform 0\" (Unicode format) and \"platform 3\" (Windows format) table.\n    cmap.numTables = parse.getUShort(data, start + 2);\n    var offset = -1;\n    for (var i = cmap.numTables - 1; i >= 0; i -= 1) {\n        var platformId = parse.getUShort(data, start + 4 + (i * 8));\n        var encodingId = parse.getUShort(data, start + 4 + (i * 8) + 2);\n        if ((platformId === 3 && (encodingId === 0 || encodingId === 1 || encodingId === 10)) ||\n            (platformId === 0 && (encodingId === 0 || encodingId === 1 || encodingId === 2 || encodingId === 3 || encodingId === 4))) {\n            offset = parse.getULong(data, start + 4 + (i * 8) + 4);\n            break;\n        }\n    }\n\n    if (offset === -1) {\n        // There is no cmap table in the font that we support.\n        throw new Error('No valid cmap sub-tables found.');\n    }\n\n    var p = new parse.Parser(data, start + offset);\n    cmap.format = p.parseUShort();\n\n    if (cmap.format === 12) {\n        parseCmapTableFormat12(cmap, p);\n    } else if (cmap.format === 4) {\n        parseCmapTableFormat4(cmap, p, data, start, offset);\n    } else {\n        throw new Error('Only format 4 and 12 cmap tables are supported (found format ' + cmap.format + ').');\n    }\n\n    return cmap;\n}\n\nfunction addSegment(t, code, glyphIndex) {\n    t.segments.push({\n        end: code,\n        start: code,\n        delta: -(code - glyphIndex),\n        offset: 0,\n        glyphIndex: glyphIndex\n    });\n}\n\nfunction addTerminatorSegment(t) {\n    t.segments.push({\n        end: 0xFFFF,\n        start: 0xFFFF,\n        delta: 1,\n        offset: 0\n    });\n}\n\n// Make cmap table, format 4 by default, 12 if needed only\nfunction makeCmapTable(glyphs) {\n    // Plan 0 is the base Unicode Plan but emojis, for example are on another plan, and needs cmap 12 format (with 32bit)\n    var isPlan0Only = true;\n    var i;\n\n    // Check if we need to add cmap format 12 or if format 4 only is fine\n    for (i = glyphs.length - 1; i > 0; i -= 1) {\n        var g = glyphs.get(i);\n        if (g.unicode > 65535) {\n            console.log('Adding CMAP format 12 (needed!)');\n            isPlan0Only = false;\n            break;\n        }\n    }\n\n    var cmapTable = [\n        {name: 'version', type: 'USHORT', value: 0},\n        {name: 'numTables', type: 'USHORT', value: isPlan0Only ? 1 : 2},\n\n        // CMAP 4 header\n        {name: 'platformID', type: 'USHORT', value: 3},\n        {name: 'encodingID', type: 'USHORT', value: 1},\n        {name: 'offset', type: 'ULONG', value: isPlan0Only ? 12 : (12 + 8)}\n    ];\n\n    if (!isPlan0Only)\n        { cmapTable = cmapTable.concat([\n            // CMAP 12 header\n            {name: 'cmap12PlatformID', type: 'USHORT', value: 3}, // We encode only for PlatformID = 3 (Windows) because it is supported everywhere\n            {name: 'cmap12EncodingID', type: 'USHORT', value: 10},\n            {name: 'cmap12Offset', type: 'ULONG', value: 0}\n        ]); }\n\n    cmapTable = cmapTable.concat([\n        // CMAP 4 Subtable\n        {name: 'format', type: 'USHORT', value: 4},\n        {name: 'cmap4Length', type: 'USHORT', value: 0},\n        {name: 'language', type: 'USHORT', value: 0},\n        {name: 'segCountX2', type: 'USHORT', value: 0},\n        {name: 'searchRange', type: 'USHORT', value: 0},\n        {name: 'entrySelector', type: 'USHORT', value: 0},\n        {name: 'rangeShift', type: 'USHORT', value: 0}\n    ]);\n\n    var t = new table.Table('cmap', cmapTable);\n\n    t.segments = [];\n    for (i = 0; i < glyphs.length; i += 1) {\n        var glyph = glyphs.get(i);\n        for (var j = 0; j < glyph.unicodes.length; j += 1) {\n            addSegment(t, glyph.unicodes[j], i);\n        }\n\n        t.segments = t.segments.sort(function (a, b) {\n            return a.start - b.start;\n        });\n    }\n\n    addTerminatorSegment(t);\n\n    var segCount = t.segments.length;\n    var segCountToRemove = 0;\n\n    // CMAP 4\n    // Set up parallel segment arrays.\n    var endCounts = [];\n    var startCounts = [];\n    var idDeltas = [];\n    var idRangeOffsets = [];\n    var glyphIds = [];\n\n    // CMAP 12\n    var cmap12Groups = [];\n\n    // Reminder this loop is not following the specification at 100%\n    // The specification -> find suites of characters and make a group\n    // Here we're doing one group for each letter\n    // Doing as the spec can save 8 times (or more) space\n    for (i = 0; i < segCount; i += 1) {\n        var segment = t.segments[i];\n\n        // CMAP 4\n        if (segment.end <= 65535 && segment.start <= 65535) {\n            endCounts = endCounts.concat({name: 'end_' + i, type: 'USHORT', value: segment.end});\n            startCounts = startCounts.concat({name: 'start_' + i, type: 'USHORT', value: segment.start});\n            idDeltas = idDeltas.concat({name: 'idDelta_' + i, type: 'SHORT', value: segment.delta});\n            idRangeOffsets = idRangeOffsets.concat({name: 'idRangeOffset_' + i, type: 'USHORT', value: segment.offset});\n            if (segment.glyphId !== undefined) {\n                glyphIds = glyphIds.concat({name: 'glyph_' + i, type: 'USHORT', value: segment.glyphId});\n            }\n        } else {\n            // Skip Unicode > 65535 (16bit unsigned max) for CMAP 4, will be added in CMAP 12\n            segCountToRemove += 1;\n        }\n\n        // CMAP 12\n        // Skip Terminator Segment\n        if (!isPlan0Only && segment.glyphIndex !== undefined) {\n            cmap12Groups = cmap12Groups.concat({name: 'cmap12Start_' + i, type: 'ULONG', value: segment.start});\n            cmap12Groups = cmap12Groups.concat({name: 'cmap12End_' + i, type: 'ULONG', value: segment.end});\n            cmap12Groups = cmap12Groups.concat({name: 'cmap12Glyph_' + i, type: 'ULONG', value: segment.glyphIndex});\n        }\n    }\n\n    // CMAP 4 Subtable\n    t.segCountX2 = (segCount - segCountToRemove) * 2;\n    t.searchRange = Math.pow(2, Math.floor(Math.log((segCount - segCountToRemove)) / Math.log(2))) * 2;\n    t.entrySelector = Math.log(t.searchRange / 2) / Math.log(2);\n    t.rangeShift = t.segCountX2 - t.searchRange;\n\n    t.fields = t.fields.concat(endCounts);\n    t.fields.push({name: 'reservedPad', type: 'USHORT', value: 0});\n    t.fields = t.fields.concat(startCounts);\n    t.fields = t.fields.concat(idDeltas);\n    t.fields = t.fields.concat(idRangeOffsets);\n    t.fields = t.fields.concat(glyphIds);\n\n    t.cmap4Length = 14 + // Subtable header\n        endCounts.length * 2 +\n        2 + // reservedPad\n        startCounts.length * 2 +\n        idDeltas.length * 2 +\n        idRangeOffsets.length * 2 +\n        glyphIds.length * 2;\n\n    if (!isPlan0Only) {\n        // CMAP 12 Subtable\n        var cmap12Length = 16 + // Subtable header\n            cmap12Groups.length * 4;\n\n        t.cmap12Offset = 12 + (2 * 2) + 4 + t.cmap4Length;\n        t.fields = t.fields.concat([\n            {name: 'cmap12Format', type: 'USHORT', value: 12},\n            {name: 'cmap12Reserved', type: 'USHORT', value: 0},\n            {name: 'cmap12Length', type: 'ULONG', value: cmap12Length},\n            {name: 'cmap12Language', type: 'ULONG', value: 0},\n            {name: 'cmap12nGroups', type: 'ULONG', value: cmap12Groups.length / 3}\n        ]);\n\n        t.fields = t.fields.concat(cmap12Groups);\n    }\n\n    return t;\n}\n\nvar cmap = { parse: parseCmapTable, make: makeCmapTable };\n\n// Glyph encoding\n\nvar cffStandardStrings = [\n    '.notdef', 'space', 'exclam', 'quotedbl', 'numbersign', 'dollar', 'percent', 'ampersand', 'quoteright',\n    'parenleft', 'parenright', 'asterisk', 'plus', 'comma', 'hyphen', 'period', 'slash', 'zero', 'one', 'two',\n    'three', 'four', 'five', 'six', 'seven', 'eight', 'nine', 'colon', 'semicolon', 'less', 'equal', 'greater',\n    'question', 'at', 'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S',\n    'T', 'U', 'V', 'W', 'X', 'Y', 'Z', 'bracketleft', 'backslash', 'bracketright', 'asciicircum', 'underscore',\n    'quoteleft', 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't',\n    'u', 'v', 'w', 'x', 'y', 'z', 'braceleft', 'bar', 'braceright', 'asciitilde', 'exclamdown', 'cent', 'sterling',\n    'fraction', 'yen', 'florin', 'section', 'currency', 'quotesingle', 'quotedblleft', 'guillemotleft',\n    'guilsinglleft', 'guilsinglright', 'fi', 'fl', 'endash', 'dagger', 'daggerdbl', 'periodcentered', 'paragraph',\n    'bullet', 'quotesinglbase', 'quotedblbase', 'quotedblright', 'guillemotright', 'ellipsis', 'perthousand',\n    'questiondown', 'grave', 'acute', 'circumflex', 'tilde', 'macron', 'breve', 'dotaccent', 'dieresis', 'ring',\n    'cedilla', 'hungarumlaut', 'ogonek', 'caron', 'emdash', 'AE', 'ordfeminine', 'Lslash', 'Oslash', 'OE',\n    'ordmasculine', 'ae', 'dotlessi', 'lslash', 'oslash', 'oe', 'germandbls', 'onesuperior', 'logicalnot', 'mu',\n    'trademark', 'Eth', 'onehalf', 'plusminus', 'Thorn', 'onequarter', 'divide', 'brokenbar', 'degree', 'thorn',\n    'threequarters', 'twosuperior', 'registered', 'minus', 'eth', 'multiply', 'threesuperior', 'copyright',\n    'Aacute', 'Acircumflex', 'Adieresis', 'Agrave', 'Aring', 'Atilde', 'Ccedilla', 'Eacute', 'Ecircumflex',\n    'Edieresis', 'Egrave', 'Iacute', 'Icircumflex', 'Idieresis', 'Igrave', 'Ntilde', 'Oacute', 'Ocircumflex',\n    'Odieresis', 'Ograve', 'Otilde', 'Scaron', 'Uacute', 'Ucircumflex', 'Udieresis', 'Ugrave', 'Yacute',\n    'Ydieresis', 'Zcaron', 'aacute', 'acircumflex', 'adieresis', 'agrave', 'aring', 'atilde', 'ccedilla', 'eacute',\n    'ecircumflex', 'edieresis', 'egrave', 'iacute', 'icircumflex', 'idieresis', 'igrave', 'ntilde', 'oacute',\n    'ocircumflex', 'odieresis', 'ograve', 'otilde', 'scaron', 'uacute', 'ucircumflex', 'udieresis', 'ugrave',\n    'yacute', 'ydieresis', 'zcaron', 'exclamsmall', 'Hungarumlautsmall', 'dollaroldstyle', 'dollarsuperior',\n    'ampersandsmall', 'Acutesmall', 'parenleftsuperior', 'parenrightsuperior', '266 ff', 'onedotenleader',\n    'zerooldstyle', 'oneoldstyle', 'twooldstyle', 'threeoldstyle', 'fouroldstyle', 'fiveoldstyle', 'sixoldstyle',\n    'sevenoldstyle', 'eightoldstyle', 'nineoldstyle', 'commasuperior', 'threequartersemdash', 'periodsuperior',\n    'questionsmall', 'asuperior', 'bsuperior', 'centsuperior', 'dsuperior', 'esuperior', 'isuperior', 'lsuperior',\n    'msuperior', 'nsuperior', 'osuperior', 'rsuperior', 'ssuperior', 'tsuperior', 'ff', 'ffi', 'ffl',\n    'parenleftinferior', 'parenrightinferior', 'Circumflexsmall', 'hyphensuperior', 'Gravesmall', 'Asmall',\n    'Bsmall', 'Csmall', 'Dsmall', 'Esmall', 'Fsmall', 'Gsmall', 'Hsmall', 'Ismall', 'Jsmall', 'Ksmall', 'Lsmall',\n    'Msmall', 'Nsmall', 'Osmall', 'Psmall', 'Qsmall', 'Rsmall', 'Ssmall', 'Tsmall', 'Usmall', 'Vsmall', 'Wsmall',\n    'Xsmall', 'Ysmall', 'Zsmall', 'colonmonetary', 'onefitted', 'rupiah', 'Tildesmall', 'exclamdownsmall',\n    'centoldstyle', 'Lslashsmall', 'Scaronsmall', 'Zcaronsmall', 'Dieresissmall', 'Brevesmall', 'Caronsmall',\n    'Dotaccentsmall', 'Macronsmall', 'figuredash', 'hypheninferior', 'Ogoneksmall', 'Ringsmall', 'Cedillasmall',\n    'questiondownsmall', 'oneeighth', 'threeeighths', 'fiveeighths', 'seveneighths', 'onethird', 'twothirds',\n    'zerosuperior', 'foursuperior', 'fivesuperior', 'sixsuperior', 'sevensuperior', 'eightsuperior', 'ninesuperior',\n    'zeroinferior', 'oneinferior', 'twoinferior', 'threeinferior', 'fourinferior', 'fiveinferior', 'sixinferior',\n    'seveninferior', 'eightinferior', 'nineinferior', 'centinferior', 'dollarinferior', 'periodinferior',\n    'commainferior', 'Agravesmall', 'Aacutesmall', 'Acircumflexsmall', 'Atildesmall', 'Adieresissmall',\n    'Aringsmall', 'AEsmall', 'Ccedillasmall', 'Egravesmall', 'Eacutesmall', 'Ecircumflexsmall', 'Edieresissmall',\n    'Igravesmall', 'Iacutesmall', 'Icircumflexsmall', 'Idieresissmall', 'Ethsmall', 'Ntildesmall', 'Ogravesmall',\n    'Oacutesmall', 'Ocircumflexsmall', 'Otildesmall', 'Odieresissmall', 'OEsmall', 'Oslashsmall', 'Ugravesmall',\n    'Uacutesmall', 'Ucircumflexsmall', 'Udieresissmall', 'Yacutesmall', 'Thornsmall', 'Ydieresissmall', '001.000',\n    '001.001', '001.002', '001.003', 'Black', 'Bold', 'Book', 'Light', 'Medium', 'Regular', 'Roman', 'Semibold'];\n\nvar cffStandardEncoding = [\n    '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '',\n    '', '', '', '', 'space', 'exclam', 'quotedbl', 'numbersign', 'dollar', 'percent', 'ampersand', 'quoteright',\n    'parenleft', 'parenright', 'asterisk', 'plus', 'comma', 'hyphen', 'period', 'slash', 'zero', 'one', 'two',\n    'three', 'four', 'five', 'six', 'seven', 'eight', 'nine', 'colon', 'semicolon', 'less', 'equal', 'greater',\n    'question', 'at', 'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S',\n    'T', 'U', 'V', 'W', 'X', 'Y', 'Z', 'bracketleft', 'backslash', 'bracketright', 'asciicircum', 'underscore',\n    'quoteleft', 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't',\n    'u', 'v', 'w', 'x', 'y', 'z', 'braceleft', 'bar', 'braceright', 'asciitilde', '', '', '', '', '', '', '', '',\n    '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '',\n    'exclamdown', 'cent', 'sterling', 'fraction', 'yen', 'florin', 'section', 'currency', 'quotesingle',\n    'quotedblleft', 'guillemotleft', 'guilsinglleft', 'guilsinglright', 'fi', 'fl', '', 'endash', 'dagger',\n    'daggerdbl', 'periodcentered', '', 'paragraph', 'bullet', 'quotesinglbase', 'quotedblbase', 'quotedblright',\n    'guillemotright', 'ellipsis', 'perthousand', '', 'questiondown', '', 'grave', 'acute', 'circumflex', 'tilde',\n    'macron', 'breve', 'dotaccent', 'dieresis', '', 'ring', 'cedilla', '', 'hungarumlaut', 'ogonek', 'caron',\n    'emdash', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', 'AE', '', 'ordfeminine', '', '', '',\n    '', 'Lslash', 'Oslash', 'OE', 'ordmasculine', '', '', '', '', '', 'ae', '', '', '', 'dotlessi', '', '',\n    'lslash', 'oslash', 'oe', 'germandbls'];\n\nvar cffExpertEncoding = [\n    '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '',\n    '', '', '', '', 'space', 'exclamsmall', 'Hungarumlautsmall', '', 'dollaroldstyle', 'dollarsuperior',\n    'ampersandsmall', 'Acutesmall', 'parenleftsuperior', 'parenrightsuperior', 'twodotenleader', 'onedotenleader',\n    'comma', 'hyphen', 'period', 'fraction', 'zerooldstyle', 'oneoldstyle', 'twooldstyle', 'threeoldstyle',\n    'fouroldstyle', 'fiveoldstyle', 'sixoldstyle', 'sevenoldstyle', 'eightoldstyle', 'nineoldstyle', 'colon',\n    'semicolon', 'commasuperior', 'threequartersemdash', 'periodsuperior', 'questionsmall', '', 'asuperior',\n    'bsuperior', 'centsuperior', 'dsuperior', 'esuperior', '', '', 'isuperior', '', '', 'lsuperior', 'msuperior',\n    'nsuperior', 'osuperior', '', '', 'rsuperior', 'ssuperior', 'tsuperior', '', 'ff', 'fi', 'fl', 'ffi', 'ffl',\n    'parenleftinferior', '', 'parenrightinferior', 'Circumflexsmall', 'hyphensuperior', 'Gravesmall', 'Asmall',\n    'Bsmall', 'Csmall', 'Dsmall', 'Esmall', 'Fsmall', 'Gsmall', 'Hsmall', 'Ismall', 'Jsmall', 'Ksmall', 'Lsmall',\n    'Msmall', 'Nsmall', 'Osmall', 'Psmall', 'Qsmall', 'Rsmall', 'Ssmall', 'Tsmall', 'Usmall', 'Vsmall', 'Wsmall',\n    'Xsmall', 'Ysmall', 'Zsmall', 'colonmonetary', 'onefitted', 'rupiah', 'Tildesmall', '', '', '', '', '', '', '',\n    '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '',\n    'exclamdownsmall', 'centoldstyle', 'Lslashsmall', '', '', 'Scaronsmall', 'Zcaronsmall', 'Dieresissmall',\n    'Brevesmall', 'Caronsmall', '', 'Dotaccentsmall', '', '', 'Macronsmall', '', '', 'figuredash', 'hypheninferior',\n    '', '', 'Ogoneksmall', 'Ringsmall', 'Cedillasmall', '', '', '', 'onequarter', 'onehalf', 'threequarters',\n    'questiondownsmall', 'oneeighth', 'threeeighths', 'fiveeighths', 'seveneighths', 'onethird', 'twothirds', '',\n    '', 'zerosuperior', 'onesuperior', 'twosuperior', 'threesuperior', 'foursuperior', 'fivesuperior',\n    'sixsuperior', 'sevensuperior', 'eightsuperior', 'ninesuperior', 'zeroinferior', 'oneinferior', 'twoinferior',\n    'threeinferior', 'fourinferior', 'fiveinferior', 'sixinferior', 'seveninferior', 'eightinferior',\n    'nineinferior', 'centinferior', 'dollarinferior', 'periodinferior', 'commainferior', 'Agravesmall',\n    'Aacutesmall', 'Acircumflexsmall', 'Atildesmall', 'Adieresissmall', 'Aringsmall', 'AEsmall', 'Ccedillasmall',\n    'Egravesmall', 'Eacutesmall', 'Ecircumflexsmall', 'Edieresissmall', 'Igravesmall', 'Iacutesmall',\n    'Icircumflexsmall', 'Idieresissmall', 'Ethsmall', 'Ntildesmall', 'Ogravesmall', 'Oacutesmall',\n    'Ocircumflexsmall', 'Otildesmall', 'Odieresissmall', 'OEsmall', 'Oslashsmall', 'Ugravesmall', 'Uacutesmall',\n    'Ucircumflexsmall', 'Udieresissmall', 'Yacutesmall', 'Thornsmall', 'Ydieresissmall'];\n\nvar standardNames = [\n    '.notdef', '.null', 'nonmarkingreturn', 'space', 'exclam', 'quotedbl', 'numbersign', 'dollar', 'percent',\n    'ampersand', 'quotesingle', 'parenleft', 'parenright', 'asterisk', 'plus', 'comma', 'hyphen', 'period', 'slash',\n    'zero', 'one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight', 'nine', 'colon', 'semicolon', 'less',\n    'equal', 'greater', 'question', 'at', 'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O',\n    'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z', 'bracketleft', 'backslash', 'bracketright',\n    'asciicircum', 'underscore', 'grave', 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o',\n    'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z', 'braceleft', 'bar', 'braceright', 'asciitilde',\n    'Adieresis', 'Aring', 'Ccedilla', 'Eacute', 'Ntilde', 'Odieresis', 'Udieresis', 'aacute', 'agrave',\n    'acircumflex', 'adieresis', 'atilde', 'aring', 'ccedilla', 'eacute', 'egrave', 'ecircumflex', 'edieresis',\n    'iacute', 'igrave', 'icircumflex', 'idieresis', 'ntilde', 'oacute', 'ograve', 'ocircumflex', 'odieresis',\n    'otilde', 'uacute', 'ugrave', 'ucircumflex', 'udieresis', 'dagger', 'degree', 'cent', 'sterling', 'section',\n    'bullet', 'paragraph', 'germandbls', 'registered', 'copyright', 'trademark', 'acute', 'dieresis', 'notequal',\n    'AE', 'Oslash', 'infinity', 'plusminus', 'lessequal', 'greaterequal', 'yen', 'mu', 'partialdiff', 'summation',\n    'product', 'pi', 'integral', 'ordfeminine', 'ordmasculine', 'Omega', 'ae', 'oslash', 'questiondown',\n    'exclamdown', 'logicalnot', 'radical', 'florin', 'approxequal', 'Delta', 'guillemotleft', 'guillemotright',\n    'ellipsis', 'nonbreakingspace', 'Agrave', 'Atilde', 'Otilde', 'OE', 'oe', 'endash', 'emdash', 'quotedblleft',\n    'quotedblright', 'quoteleft', 'quoteright', 'divide', 'lozenge', 'ydieresis', 'Ydieresis', 'fraction',\n    'currency', 'guilsinglleft', 'guilsinglright', 'fi', 'fl', 'daggerdbl', 'periodcentered', 'quotesinglbase',\n    'quotedblbase', 'perthousand', 'Acircumflex', 'Ecircumflex', 'Aacute', 'Edieresis', 'Egrave', 'Iacute',\n    'Icircumflex', 'Idieresis', 'Igrave', 'Oacute', 'Ocircumflex', 'apple', 'Ograve', 'Uacute', 'Ucircumflex',\n    'Ugrave', 'dotlessi', 'circumflex', 'tilde', 'macron', 'breve', 'dotaccent', 'ring', 'cedilla', 'hungarumlaut',\n    'ogonek', 'caron', 'Lslash', 'lslash', 'Scaron', 'scaron', 'Zcaron', 'zcaron', 'brokenbar', 'Eth', 'eth',\n    'Yacute', 'yacute', 'Thorn', 'thorn', 'minus', 'multiply', 'onesuperior', 'twosuperior', 'threesuperior',\n    'onehalf', 'onequarter', 'threequarters', 'franc', 'Gbreve', 'gbreve', 'Idotaccent', 'Scedilla', 'scedilla',\n    'Cacute', 'cacute', 'Ccaron', 'ccaron', 'dcroat'];\n\n/**\n * This is the encoding used for fonts created from scratch.\n * It loops through all glyphs and finds the appropriate unicode value.\n * Since it's linear time, other encodings will be faster.\n * @exports opentype.DefaultEncoding\n * @class\n * @constructor\n * @param {opentype.Font}\n */\nfunction DefaultEncoding(font) {\n    this.font = font;\n}\n\nDefaultEncoding.prototype.charToGlyphIndex = function(c) {\n    var code = c.codePointAt(0);\n    var glyphs = this.font.glyphs;\n    if (glyphs) {\n        for (var i = 0; i < glyphs.length; i += 1) {\n            var glyph = glyphs.get(i);\n            for (var j = 0; j < glyph.unicodes.length; j += 1) {\n                if (glyph.unicodes[j] === code) {\n                    return i;\n                }\n            }\n        }\n    }\n    return null;\n};\n\n/**\n * @exports opentype.CmapEncoding\n * @class\n * @constructor\n * @param {Object} cmap - a object with the cmap encoded data\n */\nfunction CmapEncoding(cmap) {\n    this.cmap = cmap;\n}\n\n/**\n * @param  {string} c - the character\n * @return {number} The glyph index.\n */\nCmapEncoding.prototype.charToGlyphIndex = function(c) {\n    return this.cmap.glyphIndexMap[c.codePointAt(0)] || 0;\n};\n\n/**\n * @exports opentype.CffEncoding\n * @class\n * @constructor\n * @param {string} encoding - The encoding\n * @param {Array} charset - The character set.\n */\nfunction CffEncoding(encoding, charset) {\n    this.encoding = encoding;\n    this.charset = charset;\n}\n\n/**\n * @param  {string} s - The character\n * @return {number} The index.\n */\nCffEncoding.prototype.charToGlyphIndex = function(s) {\n    var code = s.codePointAt(0);\n    var charName = this.encoding[code];\n    return this.charset.indexOf(charName);\n};\n\n/**\n * @exports opentype.GlyphNames\n * @class\n * @constructor\n * @param {Object} post\n */\nfunction GlyphNames(post) {\n    switch (post.version) {\n        case 1:\n            this.names = standardNames.slice();\n            break;\n        case 2:\n            this.names = new Array(post.numberOfGlyphs);\n            for (var i = 0; i < post.numberOfGlyphs; i++) {\n                if (post.glyphNameIndex[i] < standardNames.length) {\n                    this.names[i] = standardNames[post.glyphNameIndex[i]];\n                } else {\n                    this.names[i] = post.names[post.glyphNameIndex[i] - standardNames.length];\n                }\n            }\n\n            break;\n        case 2.5:\n            this.names = new Array(post.numberOfGlyphs);\n            for (var i$1 = 0; i$1 < post.numberOfGlyphs; i$1++) {\n                this.names[i$1] = standardNames[i$1 + post.glyphNameIndex[i$1]];\n            }\n\n            break;\n        case 3:\n            this.names = [];\n            break;\n        default:\n            this.names = [];\n            break;\n    }\n}\n\n/**\n * Gets the index of a glyph by name.\n * @param  {string} name - The glyph name\n * @return {number} The index\n */\nGlyphNames.prototype.nameToGlyphIndex = function(name) {\n    return this.names.indexOf(name);\n};\n\n/**\n * @param  {number} gid\n * @return {string}\n */\nGlyphNames.prototype.glyphIndexToName = function(gid) {\n    return this.names[gid];\n};\n\nfunction addGlyphNamesAll(font) {\n    var glyph;\n    var glyphIndexMap = font.tables.cmap.glyphIndexMap;\n    var charCodes = Object.keys(glyphIndexMap);\n\n    for (var i = 0; i < charCodes.length; i += 1) {\n        var c = charCodes[i];\n        var glyphIndex = glyphIndexMap[c];\n        glyph = font.glyphs.get(glyphIndex);\n        glyph.addUnicode(parseInt(c));\n    }\n\n    for (var i$1 = 0; i$1 < font.glyphs.length; i$1 += 1) {\n        glyph = font.glyphs.get(i$1);\n        if (font.cffEncoding) {\n            if (font.isCIDFont) {\n                glyph.name = 'gid' + i$1;\n            } else {\n                glyph.name = font.cffEncoding.charset[i$1];\n            }\n        } else if (font.glyphNames.names) {\n            glyph.name = font.glyphNames.glyphIndexToName(i$1);\n        }\n    }\n}\n\nfunction addGlyphNamesToUnicodeMap(font) {\n    font._IndexToUnicodeMap = {};\n\n    var glyphIndexMap = font.tables.cmap.glyphIndexMap;\n    var charCodes = Object.keys(glyphIndexMap);\n\n    for (var i = 0; i < charCodes.length; i += 1) {\n        var c = charCodes[i];\n        var glyphIndex = glyphIndexMap[c];\n        if (font._IndexToUnicodeMap[glyphIndex] === undefined) {\n            font._IndexToUnicodeMap[glyphIndex] = {\n                unicodes: [parseInt(c)]\n            };\n        } else {\n            font._IndexToUnicodeMap[glyphIndex].unicodes.push(parseInt(c));\n        }\n    }\n}\n\n/**\n * @alias opentype.addGlyphNames\n * @param {opentype.Font}\n * @param {Object}\n */\nfunction addGlyphNames(font, opt) {\n    if (opt.lowMemory) {\n        addGlyphNamesToUnicodeMap(font);\n    } else {\n        addGlyphNamesAll(font);\n    }\n}\n\n// Drawing utility functions.\n\n// Draw a line on the given context from point `x1,y1` to point `x2,y2`.\nfunction line(ctx, x1, y1, x2, y2) {\n    ctx.beginPath();\n    ctx.moveTo(x1, y1);\n    ctx.lineTo(x2, y2);\n    ctx.stroke();\n}\n\nvar draw = { line: line };\n\n// The Glyph object\n// import glyf from './tables/glyf' Can't be imported here, because it's a circular dependency\n\nfunction getPathDefinition(glyph, path) {\n    var _path = path || new Path();\n    return {\n        configurable: true,\n\n        get: function() {\n            if (typeof _path === 'function') {\n                _path = _path();\n            }\n\n            return _path;\n        },\n\n        set: function(p) {\n            _path = p;\n        }\n    };\n}\n/**\n * @typedef GlyphOptions\n * @type Object\n * @property {string} [name] - The glyph name\n * @property {number} [unicode]\n * @property {Array} [unicodes]\n * @property {number} [xMin]\n * @property {number} [yMin]\n * @property {number} [xMax]\n * @property {number} [yMax]\n * @property {number} [advanceWidth]\n */\n\n// A Glyph is an individual mark that often corresponds to a character.\n// Some glyphs, such as ligatures, are a combination of many characters.\n// Glyphs are the basic building blocks of a font.\n//\n// The `Glyph` class contains utility methods for drawing the path and its points.\n/**\n * @exports opentype.Glyph\n * @class\n * @param {GlyphOptions}\n * @constructor\n */\nfunction Glyph(options) {\n    // By putting all the code on a prototype function (which is only declared once)\n    // we reduce the memory requirements for larger fonts by some 2%\n    this.bindConstructorValues(options);\n}\n\n/**\n * @param  {GlyphOptions}\n */\nGlyph.prototype.bindConstructorValues = function(options) {\n    this.index = options.index || 0;\n\n    // These three values cannot be deferred for memory optimization:\n    this.name = options.name || null;\n    this.unicode = options.unicode || undefined;\n    this.unicodes = options.unicodes || options.unicode !== undefined ? [options.unicode] : [];\n\n    // But by binding these values only when necessary, we reduce can\n    // the memory requirements by almost 3% for larger fonts.\n    if ('xMin' in options) {\n        this.xMin = options.xMin;\n    }\n\n    if ('yMin' in options) {\n        this.yMin = options.yMin;\n    }\n\n    if ('xMax' in options) {\n        this.xMax = options.xMax;\n    }\n\n    if ('yMax' in options) {\n        this.yMax = options.yMax;\n    }\n\n    if ('advanceWidth' in options) {\n        this.advanceWidth = options.advanceWidth;\n    }\n\n    // The path for a glyph is the most memory intensive, and is bound as a value\n    // with a getter/setter to ensure we actually do path parsing only once the\n    // path is actually needed by anything.\n    Object.defineProperty(this, 'path', getPathDefinition(this, options.path));\n};\n\n/**\n * @param {number}\n */\nGlyph.prototype.addUnicode = function(unicode) {\n    if (this.unicodes.length === 0) {\n        this.unicode = unicode;\n    }\n\n    this.unicodes.push(unicode);\n};\n\n/**\n * Calculate the minimum bounding box for this glyph.\n * @return {opentype.BoundingBox}\n */\nGlyph.prototype.getBoundingBox = function() {\n    return this.path.getBoundingBox();\n};\n\n/**\n * Convert the glyph to a Path we can draw on a drawing context.\n * @param  {number} [x=0] - Horizontal position of the beginning of the text.\n * @param  {number} [y=0] - Vertical position of the *baseline* of the text.\n * @param  {number} [fontSize=72] - Font size in pixels. We scale the glyph units by `1 / unitsPerEm * fontSize`.\n * @param  {Object=} options - xScale, yScale to stretch the glyph.\n * @param  {opentype.Font} if hinting is to be used, the font\n * @return {opentype.Path}\n */\nGlyph.prototype.getPath = function(x, y, fontSize, options, font) {\n    x = x !== undefined ? x : 0;\n    y = y !== undefined ? y : 0;\n    fontSize = fontSize !== undefined ? fontSize : 72;\n    var commands;\n    var hPoints;\n    if (!options) { options = { }; }\n    var xScale = options.xScale;\n    var yScale = options.yScale;\n\n    if (options.hinting && font && font.hinting) {\n        // in case of hinting, the hinting engine takes care\n        // of scaling the points (not the path) before hinting.\n        hPoints = this.path && font.hinting.exec(this, fontSize);\n        // in case the hinting engine failed hPoints is undefined\n        // and thus reverts to plain rending\n    }\n\n    if (hPoints) {\n        // Call font.hinting.getCommands instead of `glyf.getPath(hPoints).commands` to avoid a circular dependency\n        commands = font.hinting.getCommands(hPoints);\n        x = Math.round(x);\n        y = Math.round(y);\n        // TODO in case of hinting xyScaling is not yet supported\n        xScale = yScale = 1;\n    } else {\n        commands = this.path.commands;\n        var scale = 1 / (this.path.unitsPerEm || 1000) * fontSize;\n        if (xScale === undefined) { xScale = scale; }\n        if (yScale === undefined) { yScale = scale; }\n    }\n\n    var p = new Path();\n    for (var i = 0; i < commands.length; i += 1) {\n        var cmd = commands[i];\n        if (cmd.type === 'M') {\n            p.moveTo(x + (cmd.x * xScale), y + (-cmd.y * yScale));\n        } else if (cmd.type === 'L') {\n            p.lineTo(x + (cmd.x * xScale), y + (-cmd.y * yScale));\n        } else if (cmd.type === 'Q') {\n            p.quadraticCurveTo(x + (cmd.x1 * xScale), y + (-cmd.y1 * yScale),\n                               x + (cmd.x * xScale), y + (-cmd.y * yScale));\n        } else if (cmd.type === 'C') {\n            p.curveTo(x + (cmd.x1 * xScale), y + (-cmd.y1 * yScale),\n                      x + (cmd.x2 * xScale), y + (-cmd.y2 * yScale),\n                      x + (cmd.x * xScale), y + (-cmd.y * yScale));\n        } else if (cmd.type === 'Z') {\n            p.closePath();\n        }\n    }\n\n    return p;\n};\n\n/**\n * Split the glyph into contours.\n * This function is here for backwards compatibility, and to\n * provide raw access to the TrueType glyph outlines.\n * @return {Array}\n */\nGlyph.prototype.getContours = function() {\n    if (this.points === undefined) {\n        return [];\n    }\n\n    var contours = [];\n    var currentContour = [];\n    for (var i = 0; i < this.points.length; i += 1) {\n        var pt = this.points[i];\n        currentContour.push(pt);\n        if (pt.lastPointOfContour) {\n            contours.push(currentContour);\n            currentContour = [];\n        }\n    }\n\n    check.argument(currentContour.length === 0, 'There are still points left in the current contour.');\n    return contours;\n};\n\n/**\n * Calculate the xMin/yMin/xMax/yMax/lsb/rsb for a Glyph.\n * @return {Object}\n */\nGlyph.prototype.getMetrics = function() {\n    var commands = this.path.commands;\n    var xCoords = [];\n    var yCoords = [];\n    for (var i = 0; i < commands.length; i += 1) {\n        var cmd = commands[i];\n        if (cmd.type !== 'Z') {\n            xCoords.push(cmd.x);\n            yCoords.push(cmd.y);\n        }\n\n        if (cmd.type === 'Q' || cmd.type === 'C') {\n            xCoords.push(cmd.x1);\n            yCoords.push(cmd.y1);\n        }\n\n        if (cmd.type === 'C') {\n            xCoords.push(cmd.x2);\n            yCoords.push(cmd.y2);\n        }\n    }\n\n    var metrics = {\n        xMin: Math.min.apply(null, xCoords),\n        yMin: Math.min.apply(null, yCoords),\n        xMax: Math.max.apply(null, xCoords),\n        yMax: Math.max.apply(null, yCoords),\n        leftSideBearing: this.leftSideBearing\n    };\n\n    if (!isFinite(metrics.xMin)) {\n        metrics.xMin = 0;\n    }\n\n    if (!isFinite(metrics.xMax)) {\n        metrics.xMax = this.advanceWidth;\n    }\n\n    if (!isFinite(metrics.yMin)) {\n        metrics.yMin = 0;\n    }\n\n    if (!isFinite(metrics.yMax)) {\n        metrics.yMax = 0;\n    }\n\n    metrics.rightSideBearing = this.advanceWidth - metrics.leftSideBearing - (metrics.xMax - metrics.xMin);\n    return metrics;\n};\n\n/**\n * Draw the glyph on the given context.\n * @param  {CanvasRenderingContext2D} ctx - A 2D drawing context, like Canvas.\n * @param  {number} [x=0] - Horizontal position of the beginning of the text.\n * @param  {number} [y=0] - Vertical position of the *baseline* of the text.\n * @param  {number} [fontSize=72] - Font size in pixels. We scale the glyph units by `1 / unitsPerEm * fontSize`.\n * @param  {Object=} options - xScale, yScale to stretch the glyph.\n */\nGlyph.prototype.draw = function(ctx, x, y, fontSize, options) {\n    this.getPath(x, y, fontSize, options).draw(ctx);\n};\n\n/**\n * Draw the points of the glyph.\n * On-curve points will be drawn in blue, off-curve points will be drawn in red.\n * @param  {CanvasRenderingContext2D} ctx - A 2D drawing context, like Canvas.\n * @param  {number} [x=0] - Horizontal position of the beginning of the text.\n * @param  {number} [y=0] - Vertical position of the *baseline* of the text.\n * @param  {number} [fontSize=72] - Font size in pixels. We scale the glyph units by `1 / unitsPerEm * fontSize`.\n */\nGlyph.prototype.drawPoints = function(ctx, x, y, fontSize) {\n    function drawCircles(l, x, y, scale) {\n        ctx.beginPath();\n        for (var j = 0; j < l.length; j += 1) {\n            ctx.moveTo(x + (l[j].x * scale), y + (l[j].y * scale));\n            ctx.arc(x + (l[j].x * scale), y + (l[j].y * scale), 2, 0, Math.PI * 2, false);\n        }\n\n        ctx.closePath();\n        ctx.fill();\n    }\n\n    x = x !== undefined ? x : 0;\n    y = y !== undefined ? y : 0;\n    fontSize = fontSize !== undefined ? fontSize : 24;\n    var scale = 1 / this.path.unitsPerEm * fontSize;\n\n    var blueCircles = [];\n    var redCircles = [];\n    var path = this.path;\n    for (var i = 0; i < path.commands.length; i += 1) {\n        var cmd = path.commands[i];\n        if (cmd.x !== undefined) {\n            blueCircles.push({x: cmd.x, y: -cmd.y});\n        }\n\n        if (cmd.x1 !== undefined) {\n            redCircles.push({x: cmd.x1, y: -cmd.y1});\n        }\n\n        if (cmd.x2 !== undefined) {\n            redCircles.push({x: cmd.x2, y: -cmd.y2});\n        }\n    }\n\n    ctx.fillStyle = 'blue';\n    drawCircles(blueCircles, x, y, scale);\n    ctx.fillStyle = 'red';\n    drawCircles(redCircles, x, y, scale);\n};\n\n/**\n * Draw lines indicating important font measurements.\n * Black lines indicate the origin of the coordinate system (point 0,0).\n * Blue lines indicate the glyph bounding box.\n * Green line indicates the advance width of the glyph.\n * @param  {CanvasRenderingContext2D} ctx - A 2D drawing context, like Canvas.\n * @param  {number} [x=0] - Horizontal position of the beginning of the text.\n * @param  {number} [y=0] - Vertical position of the *baseline* of the text.\n * @param  {number} [fontSize=72] - Font size in pixels. We scale the glyph units by `1 / unitsPerEm * fontSize`.\n */\nGlyph.prototype.drawMetrics = function(ctx, x, y, fontSize) {\n    var scale;\n    x = x !== undefined ? x : 0;\n    y = y !== undefined ? y : 0;\n    fontSize = fontSize !== undefined ? fontSize : 24;\n    scale = 1 / this.path.unitsPerEm * fontSize;\n    ctx.lineWidth = 1;\n\n    // Draw the origin\n    ctx.strokeStyle = 'black';\n    draw.line(ctx, x, -10000, x, 10000);\n    draw.line(ctx, -10000, y, 10000, y);\n\n    // This code is here due to memory optimization: by not using\n    // defaults in the constructor, we save a notable amount of memory.\n    var xMin = this.xMin || 0;\n    var yMin = this.yMin || 0;\n    var xMax = this.xMax || 0;\n    var yMax = this.yMax || 0;\n    var advanceWidth = this.advanceWidth || 0;\n\n    // Draw the glyph box\n    ctx.strokeStyle = 'blue';\n    draw.line(ctx, x + (xMin * scale), -10000, x + (xMin * scale), 10000);\n    draw.line(ctx, x + (xMax * scale), -10000, x + (xMax * scale), 10000);\n    draw.line(ctx, -10000, y + (-yMin * scale), 10000, y + (-yMin * scale));\n    draw.line(ctx, -10000, y + (-yMax * scale), 10000, y + (-yMax * scale));\n\n    // Draw the advance width\n    ctx.strokeStyle = 'green';\n    draw.line(ctx, x + (advanceWidth * scale), -10000, x + (advanceWidth * scale), 10000);\n};\n\n// The GlyphSet object\n\n// Define a property on the glyph that depends on the path being loaded.\nfunction defineDependentProperty(glyph, externalName, internalName) {\n    Object.defineProperty(glyph, externalName, {\n        get: function() {\n            // Request the path property to make sure the path is loaded.\n            glyph.path; // jshint ignore:line\n            return glyph[internalName];\n        },\n        set: function(newValue) {\n            glyph[internalName] = newValue;\n        },\n        enumerable: true,\n        configurable: true\n    });\n}\n\n/**\n * A GlyphSet represents all glyphs available in the font, but modelled using\n * a deferred glyph loader, for retrieving glyphs only once they are absolutely\n * necessary, to keep the memory footprint down.\n * @exports opentype.GlyphSet\n * @class\n * @param {opentype.Font}\n * @param {Array}\n */\nfunction GlyphSet(font, glyphs) {\n    this.font = font;\n    this.glyphs = {};\n    if (Array.isArray(glyphs)) {\n        for (var i = 0; i < glyphs.length; i++) {\n            var glyph = glyphs[i];\n            glyph.path.unitsPerEm = font.unitsPerEm;\n            this.glyphs[i] = glyph;\n        }\n    }\n\n    this.length = (glyphs && glyphs.length) || 0;\n}\n\n/**\n * @param  {number} index\n * @return {opentype.Glyph}\n */\nGlyphSet.prototype.get = function(index) {\n    // this.glyphs[index] is 'undefined' when low memory mode is on. glyph is pushed on request only.\n    if (this.glyphs[index] === undefined) {\n        this.font._push(index);\n        if (typeof this.glyphs[index] === 'function') {\n            this.glyphs[index] = this.glyphs[index]();\n        }\n\n        var glyph = this.glyphs[index];\n        var unicodeObj = this.font._IndexToUnicodeMap[index];\n\n        if (unicodeObj) {\n            for (var j = 0; j < unicodeObj.unicodes.length; j++)\n                { glyph.addUnicode(unicodeObj.unicodes[j]); }\n        }\n\n        if (this.font.cffEncoding) {\n            if (this.font.isCIDFont) {\n                glyph.name = 'gid' + index;\n            } else {\n                glyph.name = this.font.cffEncoding.charset[index];\n            }\n        } else if (this.font.glyphNames.names) {\n            glyph.name = this.font.glyphNames.glyphIndexToName(index);\n        }\n\n        this.glyphs[index].advanceWidth = this.font._hmtxTableData[index].advanceWidth;\n        this.glyphs[index].leftSideBearing = this.font._hmtxTableData[index].leftSideBearing;\n    } else {\n        if (typeof this.glyphs[index] === 'function') {\n            this.glyphs[index] = this.glyphs[index]();\n        }\n    }\n\n    return this.glyphs[index];\n};\n\n/**\n * @param  {number} index\n * @param  {Object}\n */\nGlyphSet.prototype.push = function(index, loader) {\n    this.glyphs[index] = loader;\n    this.length++;\n};\n\n/**\n * @alias opentype.glyphLoader\n * @param  {opentype.Font} font\n * @param  {number} index\n * @return {opentype.Glyph}\n */\nfunction glyphLoader(font, index) {\n    return new Glyph({index: index, font: font});\n}\n\n/**\n * Generate a stub glyph that can be filled with all metadata *except*\n * the \"points\" and \"path\" properties, which must be loaded only once\n * the glyph's path is actually requested for text shaping.\n * @alias opentype.ttfGlyphLoader\n * @param  {opentype.Font} font\n * @param  {number} index\n * @param  {Function} parseGlyph\n * @param  {Object} data\n * @param  {number} position\n * @param  {Function} buildPath\n * @return {opentype.Glyph}\n */\nfunction ttfGlyphLoader(font, index, parseGlyph, data, position, buildPath) {\n    return function() {\n        var glyph = new Glyph({index: index, font: font});\n\n        glyph.path = function() {\n            parseGlyph(glyph, data, position);\n            var path = buildPath(font.glyphs, glyph);\n            path.unitsPerEm = font.unitsPerEm;\n            return path;\n        };\n\n        defineDependentProperty(glyph, 'xMin', '_xMin');\n        defineDependentProperty(glyph, 'xMax', '_xMax');\n        defineDependentProperty(glyph, 'yMin', '_yMin');\n        defineDependentProperty(glyph, 'yMax', '_yMax');\n\n        return glyph;\n    };\n}\n/**\n * @alias opentype.cffGlyphLoader\n * @param  {opentype.Font} font\n * @param  {number} index\n * @param  {Function} parseCFFCharstring\n * @param  {string} charstring\n * @return {opentype.Glyph}\n */\nfunction cffGlyphLoader(font, index, parseCFFCharstring, charstring) {\n    return function() {\n        var glyph = new Glyph({index: index, font: font});\n\n        glyph.path = function() {\n            var path = parseCFFCharstring(font, glyph, charstring);\n            path.unitsPerEm = font.unitsPerEm;\n            return path;\n        };\n\n        return glyph;\n    };\n}\n\nvar glyphset = { GlyphSet: GlyphSet, glyphLoader: glyphLoader, ttfGlyphLoader: ttfGlyphLoader, cffGlyphLoader: cffGlyphLoader };\n\n// The `CFF` table contains the glyph outlines in PostScript format.\n\n// Custom equals function that can also check lists.\nfunction equals(a, b) {\n    if (a === b) {\n        return true;\n    } else if (Array.isArray(a) && Array.isArray(b)) {\n        if (a.length !== b.length) {\n            return false;\n        }\n\n        for (var i = 0; i < a.length; i += 1) {\n            if (!equals(a[i], b[i])) {\n                return false;\n            }\n        }\n\n        return true;\n    } else {\n        return false;\n    }\n}\n\n// Subroutines are encoded using the negative half of the number space.\n// See type 2 chapter 4.7 \"Subroutine operators\".\nfunction calcCFFSubroutineBias(subrs) {\n    var bias;\n    if (subrs.length < 1240) {\n        bias = 107;\n    } else if (subrs.length < 33900) {\n        bias = 1131;\n    } else {\n        bias = 32768;\n    }\n\n    return bias;\n}\n\n// Parse a `CFF` INDEX array.\n// An index array consists of a list of offsets, then a list of objects at those offsets.\nfunction parseCFFIndex(data, start, conversionFn) {\n    var offsets = [];\n    var objects = [];\n    var count = parse.getCard16(data, start);\n    var objectOffset;\n    var endOffset;\n    if (count !== 0) {\n        var offsetSize = parse.getByte(data, start + 2);\n        objectOffset = start + ((count + 1) * offsetSize) + 2;\n        var pos = start + 3;\n        for (var i = 0; i < count + 1; i += 1) {\n            offsets.push(parse.getOffset(data, pos, offsetSize));\n            pos += offsetSize;\n        }\n\n        // The total size of the index array is 4 header bytes + the value of the last offset.\n        endOffset = objectOffset + offsets[count];\n    } else {\n        endOffset = start + 2;\n    }\n\n    for (var i$1 = 0; i$1 < offsets.length - 1; i$1 += 1) {\n        var value = parse.getBytes(data, objectOffset + offsets[i$1], objectOffset + offsets[i$1 + 1]);\n        if (conversionFn) {\n            value = conversionFn(value);\n        }\n\n        objects.push(value);\n    }\n\n    return {objects: objects, startOffset: start, endOffset: endOffset};\n}\n\nfunction parseCFFIndexLowMemory(data, start) {\n    var offsets = [];\n    var count = parse.getCard16(data, start);\n    var objectOffset;\n    var endOffset;\n    if (count !== 0) {\n        var offsetSize = parse.getByte(data, start + 2);\n        objectOffset = start + ((count + 1) * offsetSize) + 2;\n        var pos = start + 3;\n        for (var i = 0; i < count + 1; i += 1) {\n            offsets.push(parse.getOffset(data, pos, offsetSize));\n            pos += offsetSize;\n        }\n\n        // The total size of the index array is 4 header bytes + the value of the last offset.\n        endOffset = objectOffset + offsets[count];\n    } else {\n        endOffset = start + 2;\n    }\n\n    return {offsets: offsets, startOffset: start, endOffset: endOffset};\n}\nfunction getCffIndexObject(i, offsets, data, start, conversionFn) {\n    var count = parse.getCard16(data, start);\n    var objectOffset = 0;\n    if (count !== 0) {\n        var offsetSize = parse.getByte(data, start + 2);\n        objectOffset = start + ((count + 1) * offsetSize) + 2;\n    }\n\n    var value = parse.getBytes(data, objectOffset + offsets[i], objectOffset + offsets[i + 1]);\n    if (conversionFn) {\n        value = conversionFn(value);\n    }\n    return value;\n}\n\n// Parse a `CFF` DICT real value.\nfunction parseFloatOperand(parser) {\n    var s = '';\n    var eof = 15;\n    var lookup = ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '.', 'E', 'E-', null, '-'];\n    while (true) {\n        var b = parser.parseByte();\n        var n1 = b >> 4;\n        var n2 = b & 15;\n\n        if (n1 === eof) {\n            break;\n        }\n\n        s += lookup[n1];\n\n        if (n2 === eof) {\n            break;\n        }\n\n        s += lookup[n2];\n    }\n\n    return parseFloat(s);\n}\n\n// Parse a `CFF` DICT operand.\nfunction parseOperand(parser, b0) {\n    var b1;\n    var b2;\n    var b3;\n    var b4;\n    if (b0 === 28) {\n        b1 = parser.parseByte();\n        b2 = parser.parseByte();\n        return b1 << 8 | b2;\n    }\n\n    if (b0 === 29) {\n        b1 = parser.parseByte();\n        b2 = parser.parseByte();\n        b3 = parser.parseByte();\n        b4 = parser.parseByte();\n        return b1 << 24 | b2 << 16 | b3 << 8 | b4;\n    }\n\n    if (b0 === 30) {\n        return parseFloatOperand(parser);\n    }\n\n    if (b0 >= 32 && b0 <= 246) {\n        return b0 - 139;\n    }\n\n    if (b0 >= 247 && b0 <= 250) {\n        b1 = parser.parseByte();\n        return (b0 - 247) * 256 + b1 + 108;\n    }\n\n    if (b0 >= 251 && b0 <= 254) {\n        b1 = parser.parseByte();\n        return -(b0 - 251) * 256 - b1 - 108;\n    }\n\n    throw new Error('Invalid b0 ' + b0);\n}\n\n// Convert the entries returned by `parseDict` to a proper dictionary.\n// If a value is a list of one, it is unpacked.\nfunction entriesToObject(entries) {\n    var o = {};\n    for (var i = 0; i < entries.length; i += 1) {\n        var key = entries[i][0];\n        var values = entries[i][1];\n        var value = (void 0);\n        if (values.length === 1) {\n            value = values[0];\n        } else {\n            value = values;\n        }\n\n        if (o.hasOwnProperty(key) && !isNaN(o[key])) {\n            throw new Error('Object ' + o + ' already has key ' + key);\n        }\n\n        o[key] = value;\n    }\n\n    return o;\n}\n\n// Parse a `CFF` DICT object.\n// A dictionary contains key-value pairs in a compact tokenized format.\nfunction parseCFFDict(data, start, size) {\n    start = start !== undefined ? start : 0;\n    var parser = new parse.Parser(data, start);\n    var entries = [];\n    var operands = [];\n    size = size !== undefined ? size : data.length;\n\n    while (parser.relativeOffset < size) {\n        var op = parser.parseByte();\n\n        // The first byte for each dict item distinguishes between operator (key) and operand (value).\n        // Values <= 21 are operators.\n        if (op <= 21) {\n            // Two-byte operators have an initial escape byte of 12.\n            if (op === 12) {\n                op = 1200 + parser.parseByte();\n            }\n\n            entries.push([op, operands]);\n            operands = [];\n        } else {\n            // Since the operands (values) come before the operators (keys), we store all operands in a list\n            // until we encounter an operator.\n            operands.push(parseOperand(parser, op));\n        }\n    }\n\n    return entriesToObject(entries);\n}\n\n// Given a String Index (SID), return the value of the string.\n// Strings below index 392 are standard CFF strings and are not encoded in the font.\nfunction getCFFString(strings, index) {\n    if (index <= 390) {\n        index = cffStandardStrings[index];\n    } else {\n        index = strings[index - 391];\n    }\n\n    return index;\n}\n\n// Interpret a dictionary and return a new dictionary with readable keys and values for missing entries.\n// This function takes `meta` which is a list of objects containing `operand`, `name` and `default`.\nfunction interpretDict(dict, meta, strings) {\n    var newDict = {};\n    var value;\n\n    // Because we also want to include missing values, we start out from the meta list\n    // and lookup values in the dict.\n    for (var i = 0; i < meta.length; i += 1) {\n        var m = meta[i];\n\n        if (Array.isArray(m.type)) {\n            var values = [];\n            values.length = m.type.length;\n            for (var j = 0; j < m.type.length; j++) {\n                value = dict[m.op] !== undefined ? dict[m.op][j] : undefined;\n                if (value === undefined) {\n                    value = m.value !== undefined && m.value[j] !== undefined ? m.value[j] : null;\n                }\n                if (m.type[j] === 'SID') {\n                    value = getCFFString(strings, value);\n                }\n                values[j] = value;\n            }\n            newDict[m.name] = values;\n        } else {\n            value = dict[m.op];\n            if (value === undefined) {\n                value = m.value !== undefined ? m.value : null;\n            }\n\n            if (m.type === 'SID') {\n                value = getCFFString(strings, value);\n            }\n            newDict[m.name] = value;\n        }\n    }\n\n    return newDict;\n}\n\n// Parse the CFF header.\nfunction parseCFFHeader(data, start) {\n    var header = {};\n    header.formatMajor = parse.getCard8(data, start);\n    header.formatMinor = parse.getCard8(data, start + 1);\n    header.size = parse.getCard8(data, start + 2);\n    header.offsetSize = parse.getCard8(data, start + 3);\n    header.startOffset = start;\n    header.endOffset = start + 4;\n    return header;\n}\n\nvar TOP_DICT_META = [\n    {name: 'version', op: 0, type: 'SID'},\n    {name: 'notice', op: 1, type: 'SID'},\n    {name: 'copyright', op: 1200, type: 'SID'},\n    {name: 'fullName', op: 2, type: 'SID'},\n    {name: 'familyName', op: 3, type: 'SID'},\n    {name: 'weight', op: 4, type: 'SID'},\n    {name: 'isFixedPitch', op: 1201, type: 'number', value: 0},\n    {name: 'italicAngle', op: 1202, type: 'number', value: 0},\n    {name: 'underlinePosition', op: 1203, type: 'number', value: -100},\n    {name: 'underlineThickness', op: 1204, type: 'number', value: 50},\n    {name: 'paintType', op: 1205, type: 'number', value: 0},\n    {name: 'charstringType', op: 1206, type: 'number', value: 2},\n    {\n        name: 'fontMatrix',\n        op: 1207,\n        type: ['real', 'real', 'real', 'real', 'real', 'real'],\n        value: [0.001, 0, 0, 0.001, 0, 0]\n    },\n    {name: 'uniqueId', op: 13, type: 'number'},\n    {name: 'fontBBox', op: 5, type: ['number', 'number', 'number', 'number'], value: [0, 0, 0, 0]},\n    {name: 'strokeWidth', op: 1208, type: 'number', value: 0},\n    {name: 'xuid', op: 14, type: [], value: null},\n    {name: 'charset', op: 15, type: 'offset', value: 0},\n    {name: 'encoding', op: 16, type: 'offset', value: 0},\n    {name: 'charStrings', op: 17, type: 'offset', value: 0},\n    {name: 'private', op: 18, type: ['number', 'offset'], value: [0, 0]},\n    {name: 'ros', op: 1230, type: ['SID', 'SID', 'number']},\n    {name: 'cidFontVersion', op: 1231, type: 'number', value: 0},\n    {name: 'cidFontRevision', op: 1232, type: 'number', value: 0},\n    {name: 'cidFontType', op: 1233, type: 'number', value: 0},\n    {name: 'cidCount', op: 1234, type: 'number', value: 8720},\n    {name: 'uidBase', op: 1235, type: 'number'},\n    {name: 'fdArray', op: 1236, type: 'offset'},\n    {name: 'fdSelect', op: 1237, type: 'offset'},\n    {name: 'fontName', op: 1238, type: 'SID'}\n];\n\nvar PRIVATE_DICT_META = [\n    {name: 'subrs', op: 19, type: 'offset', value: 0},\n    {name: 'defaultWidthX', op: 20, type: 'number', value: 0},\n    {name: 'nominalWidthX', op: 21, type: 'number', value: 0}\n];\n\n// Parse the CFF top dictionary. A CFF table can contain multiple fonts, each with their own top dictionary.\n// The top dictionary contains the essential metadata for the font, together with the private dictionary.\nfunction parseCFFTopDict(data, strings) {\n    var dict = parseCFFDict(data, 0, data.byteLength);\n    return interpretDict(dict, TOP_DICT_META, strings);\n}\n\n// Parse the CFF private dictionary. We don't fully parse out all the values, only the ones we need.\nfunction parseCFFPrivateDict(data, start, size, strings) {\n    var dict = parseCFFDict(data, start, size);\n    return interpretDict(dict, PRIVATE_DICT_META, strings);\n}\n\n// Returns a list of \"Top DICT\"s found using an INDEX list.\n// Used to read both the usual high-level Top DICTs and also the FDArray\n// discovered inside CID-keyed fonts.  When a Top DICT has a reference to\n// a Private DICT that is read and saved into the Top DICT.\n//\n// In addition to the expected/optional values as outlined in TOP_DICT_META\n// the following values might be saved into the Top DICT.\n//\n//    _subrs []        array of local CFF subroutines from Private DICT\n//    _subrsBias       bias value computed from number of subroutines\n//                      (see calcCFFSubroutineBias() and parseCFFCharstring())\n//    _defaultWidthX   default widths for CFF characters\n//    _nominalWidthX   bias added to width embedded within glyph description\n//\n//    _privateDict     saved copy of parsed Private DICT from Top DICT\nfunction gatherCFFTopDicts(data, start, cffIndex, strings) {\n    var topDictArray = [];\n    for (var iTopDict = 0; iTopDict < cffIndex.length; iTopDict += 1) {\n        var topDictData = new DataView(new Uint8Array(cffIndex[iTopDict]).buffer);\n        var topDict = parseCFFTopDict(topDictData, strings);\n        topDict._subrs = [];\n        topDict._subrsBias = 0;\n        topDict._defaultWidthX = 0;\n        topDict._nominalWidthX = 0;\n        var privateSize = topDict.private[0];\n        var privateOffset = topDict.private[1];\n        if (privateSize !== 0 && privateOffset !== 0) {\n            var privateDict = parseCFFPrivateDict(data, privateOffset + start, privateSize, strings);\n            topDict._defaultWidthX = privateDict.defaultWidthX;\n            topDict._nominalWidthX = privateDict.nominalWidthX;\n            if (privateDict.subrs !== 0) {\n                var subrOffset = privateOffset + privateDict.subrs;\n                var subrIndex = parseCFFIndex(data, subrOffset + start);\n                topDict._subrs = subrIndex.objects;\n                topDict._subrsBias = calcCFFSubroutineBias(topDict._subrs);\n            }\n            topDict._privateDict = privateDict;\n        }\n        topDictArray.push(topDict);\n    }\n    return topDictArray;\n}\n\n// Parse the CFF charset table, which contains internal names for all the glyphs.\n// This function will return a list of glyph names.\n// See Adobe TN #5176 chapter 13, \"Charsets\".\nfunction parseCFFCharset(data, start, nGlyphs, strings) {\n    var sid;\n    var count;\n    var parser = new parse.Parser(data, start);\n\n    // The .notdef glyph is not included, so subtract 1.\n    nGlyphs -= 1;\n    var charset = ['.notdef'];\n\n    var format = parser.parseCard8();\n    if (format === 0) {\n        for (var i = 0; i < nGlyphs; i += 1) {\n            sid = parser.parseSID();\n            charset.push(getCFFString(strings, sid));\n        }\n    } else if (format === 1) {\n        while (charset.length <= nGlyphs) {\n            sid = parser.parseSID();\n            count = parser.parseCard8();\n            for (var i$1 = 0; i$1 <= count; i$1 += 1) {\n                charset.push(getCFFString(strings, sid));\n                sid += 1;\n            }\n        }\n    } else if (format === 2) {\n        while (charset.length <= nGlyphs) {\n            sid = parser.parseSID();\n            count = parser.parseCard16();\n            for (var i$2 = 0; i$2 <= count; i$2 += 1) {\n                charset.push(getCFFString(strings, sid));\n                sid += 1;\n            }\n        }\n    } else {\n        throw new Error('Unknown charset format ' + format);\n    }\n\n    return charset;\n}\n\n// Parse the CFF encoding data. Only one encoding can be specified per font.\n// See Adobe TN #5176 chapter 12, \"Encodings\".\nfunction parseCFFEncoding(data, start, charset) {\n    var code;\n    var enc = {};\n    var parser = new parse.Parser(data, start);\n    var format = parser.parseCard8();\n    if (format === 0) {\n        var nCodes = parser.parseCard8();\n        for (var i = 0; i < nCodes; i += 1) {\n            code = parser.parseCard8();\n            enc[code] = i;\n        }\n    } else if (format === 1) {\n        var nRanges = parser.parseCard8();\n        code = 1;\n        for (var i$1 = 0; i$1 < nRanges; i$1 += 1) {\n            var first = parser.parseCard8();\n            var nLeft = parser.parseCard8();\n            for (var j = first; j <= first + nLeft; j += 1) {\n                enc[j] = code;\n                code += 1;\n            }\n        }\n    } else {\n        throw new Error('Unknown encoding format ' + format);\n    }\n\n    return new CffEncoding(enc, charset);\n}\n\n// Take in charstring code and return a Glyph object.\n// The encoding is described in the Type 2 Charstring Format\n// https://www.microsoft.com/typography/OTSPEC/charstr2.htm\nfunction parseCFFCharstring(font, glyph, code) {\n    var c1x;\n    var c1y;\n    var c2x;\n    var c2y;\n    var p = new Path();\n    var stack = [];\n    var nStems = 0;\n    var haveWidth = false;\n    var open = false;\n    var x = 0;\n    var y = 0;\n    var subrs;\n    var subrsBias;\n    var defaultWidthX;\n    var nominalWidthX;\n    if (font.isCIDFont) {\n        var fdIndex = font.tables.cff.topDict._fdSelect[glyph.index];\n        var fdDict = font.tables.cff.topDict._fdArray[fdIndex];\n        subrs = fdDict._subrs;\n        subrsBias = fdDict._subrsBias;\n        defaultWidthX = fdDict._defaultWidthX;\n        nominalWidthX = fdDict._nominalWidthX;\n    } else {\n        subrs = font.tables.cff.topDict._subrs;\n        subrsBias = font.tables.cff.topDict._subrsBias;\n        defaultWidthX = font.tables.cff.topDict._defaultWidthX;\n        nominalWidthX = font.tables.cff.topDict._nominalWidthX;\n    }\n    var width = defaultWidthX;\n\n    function newContour(x, y) {\n        if (open) {\n            p.closePath();\n        }\n\n        p.moveTo(x, y);\n        open = true;\n    }\n\n    function parseStems() {\n        var hasWidthArg;\n\n        // The number of stem operators on the stack is always even.\n        // If the value is uneven, that means a width is specified.\n        hasWidthArg = stack.length % 2 !== 0;\n        if (hasWidthArg && !haveWidth) {\n            width = stack.shift() + nominalWidthX;\n        }\n\n        nStems += stack.length >> 1;\n        stack.length = 0;\n        haveWidth = true;\n    }\n\n    function parse(code) {\n        var b1;\n        var b2;\n        var b3;\n        var b4;\n        var codeIndex;\n        var subrCode;\n        var jpx;\n        var jpy;\n        var c3x;\n        var c3y;\n        var c4x;\n        var c4y;\n\n        var i = 0;\n        while (i < code.length) {\n            var v = code[i];\n            i += 1;\n            switch (v) {\n                case 1: // hstem\n                    parseStems();\n                    break;\n                case 3: // vstem\n                    parseStems();\n                    break;\n                case 4: // vmoveto\n                    if (stack.length > 1 && !haveWidth) {\n                        width = stack.shift() + nominalWidthX;\n                        haveWidth = true;\n                    }\n\n                    y += stack.pop();\n                    newContour(x, y);\n                    break;\n                case 5: // rlineto\n                    while (stack.length > 0) {\n                        x += stack.shift();\n                        y += stack.shift();\n                        p.lineTo(x, y);\n                    }\n\n                    break;\n                case 6: // hlineto\n                    while (stack.length > 0) {\n                        x += stack.shift();\n                        p.lineTo(x, y);\n                        if (stack.length === 0) {\n                            break;\n                        }\n\n                        y += stack.shift();\n                        p.lineTo(x, y);\n                    }\n\n                    break;\n                case 7: // vlineto\n                    while (stack.length > 0) {\n                        y += stack.shift();\n                        p.lineTo(x, y);\n                        if (stack.length === 0) {\n                            break;\n                        }\n\n                        x += stack.shift();\n                        p.lineTo(x, y);\n                    }\n\n                    break;\n                case 8: // rrcurveto\n                    while (stack.length > 0) {\n                        c1x = x + stack.shift();\n                        c1y = y + stack.shift();\n                        c2x = c1x + stack.shift();\n                        c2y = c1y + stack.shift();\n                        x = c2x + stack.shift();\n                        y = c2y + stack.shift();\n                        p.curveTo(c1x, c1y, c2x, c2y, x, y);\n                    }\n\n                    break;\n                case 10: // callsubr\n                    codeIndex = stack.pop() + subrsBias;\n                    subrCode = subrs[codeIndex];\n                    if (subrCode) {\n                        parse(subrCode);\n                    }\n\n                    break;\n                case 11: // return\n                    return;\n                case 12: // flex operators\n                    v = code[i];\n                    i += 1;\n                    switch (v) {\n                        case 35: // flex\n                            // |- dx1 dy1 dx2 dy2 dx3 dy3 dx4 dy4 dx5 dy5 dx6 dy6 fd flex (12 35) |-\n                            c1x = x   + stack.shift();    // dx1\n                            c1y = y   + stack.shift();    // dy1\n                            c2x = c1x + stack.shift();    // dx2\n                            c2y = c1y + stack.shift();    // dy2\n                            jpx = c2x + stack.shift();    // dx3\n                            jpy = c2y + stack.shift();    // dy3\n                            c3x = jpx + stack.shift();    // dx4\n                            c3y = jpy + stack.shift();    // dy4\n                            c4x = c3x + stack.shift();    // dx5\n                            c4y = c3y + stack.shift();    // dy5\n                            x = c4x   + stack.shift();    // dx6\n                            y = c4y   + stack.shift();    // dy6\n                            stack.shift();                // flex depth\n                            p.curveTo(c1x, c1y, c2x, c2y, jpx, jpy);\n                            p.curveTo(c3x, c3y, c4x, c4y, x, y);\n                            break;\n                        case 34: // hflex\n                            // |- dx1 dx2 dy2 dx3 dx4 dx5 dx6 hflex (12 34) |-\n                            c1x = x   + stack.shift();    // dx1\n                            c1y = y;                      // dy1\n                            c2x = c1x + stack.shift();    // dx2\n                            c2y = c1y + stack.shift();    // dy2\n                            jpx = c2x + stack.shift();    // dx3\n                            jpy = c2y;                    // dy3\n                            c3x = jpx + stack.shift();    // dx4\n                            c3y = c2y;                    // dy4\n                            c4x = c3x + stack.shift();    // dx5\n                            c4y = y;                      // dy5\n                            x = c4x + stack.shift();      // dx6\n                            p.curveTo(c1x, c1y, c2x, c2y, jpx, jpy);\n                            p.curveTo(c3x, c3y, c4x, c4y, x, y);\n                            break;\n                        case 36: // hflex1\n                            // |- dx1 dy1 dx2 dy2 dx3 dx4 dx5 dy5 dx6 hflex1 (12 36) |-\n                            c1x = x   + stack.shift();    // dx1\n                            c1y = y   + stack.shift();    // dy1\n                            c2x = c1x + stack.shift();    // dx2\n                            c2y = c1y + stack.shift();    // dy2\n                            jpx = c2x + stack.shift();    // dx3\n                            jpy = c2y;                    // dy3\n                            c3x = jpx + stack.shift();    // dx4\n                            c3y = c2y;                    // dy4\n                            c4x = c3x + stack.shift();    // dx5\n                            c4y = c3y + stack.shift();    // dy5\n                            x = c4x + stack.shift();      // dx6\n                            p.curveTo(c1x, c1y, c2x, c2y, jpx, jpy);\n                            p.curveTo(c3x, c3y, c4x, c4y, x, y);\n                            break;\n                        case 37: // flex1\n                            // |- dx1 dy1 dx2 dy2 dx3 dy3 dx4 dy4 dx5 dy5 d6 flex1 (12 37) |-\n                            c1x = x   + stack.shift();    // dx1\n                            c1y = y   + stack.shift();    // dy1\n                            c2x = c1x + stack.shift();    // dx2\n                            c2y = c1y + stack.shift();    // dy2\n                            jpx = c2x + stack.shift();    // dx3\n                            jpy = c2y + stack.shift();    // dy3\n                            c3x = jpx + stack.shift();    // dx4\n                            c3y = jpy + stack.shift();    // dy4\n                            c4x = c3x + stack.shift();    // dx5\n                            c4y = c3y + stack.shift();    // dy5\n                            if (Math.abs(c4x - x) > Math.abs(c4y - y)) {\n                                x = c4x + stack.shift();\n                            } else {\n                                y = c4y + stack.shift();\n                            }\n\n                            p.curveTo(c1x, c1y, c2x, c2y, jpx, jpy);\n                            p.curveTo(c3x, c3y, c4x, c4y, x, y);\n                            break;\n                        default:\n                            console.log('Glyph ' + glyph.index + ': unknown operator ' + 1200 + v);\n                            stack.length = 0;\n                    }\n                    break;\n                case 14: // endchar\n                    if (stack.length > 0 && !haveWidth) {\n                        width = stack.shift() + nominalWidthX;\n                        haveWidth = true;\n                    }\n\n                    if (open) {\n                        p.closePath();\n                        open = false;\n                    }\n\n                    break;\n                case 18: // hstemhm\n                    parseStems();\n                    break;\n                case 19: // hintmask\n                case 20: // cntrmask\n                    parseStems();\n                    i += (nStems + 7) >> 3;\n                    break;\n                case 21: // rmoveto\n                    if (stack.length > 2 && !haveWidth) {\n                        width = stack.shift() + nominalWidthX;\n                        haveWidth = true;\n                    }\n\n                    y += stack.pop();\n                    x += stack.pop();\n                    newContour(x, y);\n                    break;\n                case 22: // hmoveto\n                    if (stack.length > 1 && !haveWidth) {\n                        width = stack.shift() + nominalWidthX;\n                        haveWidth = true;\n                    }\n\n                    x += stack.pop();\n                    newContour(x, y);\n                    break;\n                case 23: // vstemhm\n                    parseStems();\n                    break;\n                case 24: // rcurveline\n                    while (stack.length > 2) {\n                        c1x = x + stack.shift();\n                        c1y = y + stack.shift();\n                        c2x = c1x + stack.shift();\n                        c2y = c1y + stack.shift();\n                        x = c2x + stack.shift();\n                        y = c2y + stack.shift();\n                        p.curveTo(c1x, c1y, c2x, c2y, x, y);\n                    }\n\n                    x += stack.shift();\n                    y += stack.shift();\n                    p.lineTo(x, y);\n                    break;\n                case 25: // rlinecurve\n                    while (stack.length > 6) {\n                        x += stack.shift();\n                        y += stack.shift();\n                        p.lineTo(x, y);\n                    }\n\n                    c1x = x + stack.shift();\n                    c1y = y + stack.shift();\n                    c2x = c1x + stack.shift();\n                    c2y = c1y + stack.shift();\n                    x = c2x + stack.shift();\n                    y = c2y + stack.shift();\n                    p.curveTo(c1x, c1y, c2x, c2y, x, y);\n                    break;\n                case 26: // vvcurveto\n                    if (stack.length % 2) {\n                        x += stack.shift();\n                    }\n\n                    while (stack.length > 0) {\n                        c1x = x;\n                        c1y = y + stack.shift();\n                        c2x = c1x + stack.shift();\n                        c2y = c1y + stack.shift();\n                        x = c2x;\n                        y = c2y + stack.shift();\n                        p.curveTo(c1x, c1y, c2x, c2y, x, y);\n                    }\n\n                    break;\n                case 27: // hhcurveto\n                    if (stack.length % 2) {\n                        y += stack.shift();\n                    }\n\n                    while (stack.length > 0) {\n                        c1x = x + stack.shift();\n                        c1y = y;\n                        c2x = c1x + stack.shift();\n                        c2y = c1y + stack.shift();\n                        x = c2x + stack.shift();\n                        y = c2y;\n                        p.curveTo(c1x, c1y, c2x, c2y, x, y);\n                    }\n\n                    break;\n                case 28: // shortint\n                    b1 = code[i];\n                    b2 = code[i + 1];\n                    stack.push(((b1 << 24) | (b2 << 16)) >> 16);\n                    i += 2;\n                    break;\n                case 29: // callgsubr\n                    codeIndex = stack.pop() + font.gsubrsBias;\n                    subrCode = font.gsubrs[codeIndex];\n                    if (subrCode) {\n                        parse(subrCode);\n                    }\n\n                    break;\n                case 30: // vhcurveto\n                    while (stack.length > 0) {\n                        c1x = x;\n                        c1y = y + stack.shift();\n                        c2x = c1x + stack.shift();\n                        c2y = c1y + stack.shift();\n                        x = c2x + stack.shift();\n                        y = c2y + (stack.length === 1 ? stack.shift() : 0);\n                        p.curveTo(c1x, c1y, c2x, c2y, x, y);\n                        if (stack.length === 0) {\n                            break;\n                        }\n\n                        c1x = x + stack.shift();\n                        c1y = y;\n                        c2x = c1x + stack.shift();\n                        c2y = c1y + stack.shift();\n                        y = c2y + stack.shift();\n                        x = c2x + (stack.length === 1 ? stack.shift() : 0);\n                        p.curveTo(c1x, c1y, c2x, c2y, x, y);\n                    }\n\n                    break;\n                case 31: // hvcurveto\n                    while (stack.length > 0) {\n                        c1x = x + stack.shift();\n                        c1y = y;\n                        c2x = c1x + stack.shift();\n                        c2y = c1y + stack.shift();\n                        y = c2y + stack.shift();\n                        x = c2x + (stack.length === 1 ? stack.shift() : 0);\n                        p.curveTo(c1x, c1y, c2x, c2y, x, y);\n                        if (stack.length === 0) {\n                            break;\n                        }\n\n                        c1x = x;\n                        c1y = y + stack.shift();\n                        c2x = c1x + stack.shift();\n                        c2y = c1y + stack.shift();\n                        x = c2x + stack.shift();\n                        y = c2y + (stack.length === 1 ? stack.shift() : 0);\n                        p.curveTo(c1x, c1y, c2x, c2y, x, y);\n                    }\n\n                    break;\n                default:\n                    if (v < 32) {\n                        console.log('Glyph ' + glyph.index + ': unknown operator ' + v);\n                    } else if (v < 247) {\n                        stack.push(v - 139);\n                    } else if (v < 251) {\n                        b1 = code[i];\n                        i += 1;\n                        stack.push((v - 247) * 256 + b1 + 108);\n                    } else if (v < 255) {\n                        b1 = code[i];\n                        i += 1;\n                        stack.push(-(v - 251) * 256 - b1 - 108);\n                    } else {\n                        b1 = code[i];\n                        b2 = code[i + 1];\n                        b3 = code[i + 2];\n                        b4 = code[i + 3];\n                        i += 4;\n                        stack.push(((b1 << 24) | (b2 << 16) | (b3 << 8) | b4) / 65536);\n                    }\n            }\n        }\n    }\n\n    parse(code);\n\n    glyph.advanceWidth = width;\n    return p;\n}\n\nfunction parseCFFFDSelect(data, start, nGlyphs, fdArrayCount) {\n    var fdSelect = [];\n    var fdIndex;\n    var parser = new parse.Parser(data, start);\n    var format = parser.parseCard8();\n    if (format === 0) {\n        // Simple list of nGlyphs elements\n        for (var iGid = 0; iGid < nGlyphs; iGid++) {\n            fdIndex = parser.parseCard8();\n            if (fdIndex >= fdArrayCount) {\n                throw new Error('CFF table CID Font FDSelect has bad FD index value ' + fdIndex + ' (FD count ' + fdArrayCount + ')');\n            }\n            fdSelect.push(fdIndex);\n        }\n    } else if (format === 3) {\n        // Ranges\n        var nRanges = parser.parseCard16();\n        var first = parser.parseCard16();\n        if (first !== 0) {\n            throw new Error('CFF Table CID Font FDSelect format 3 range has bad initial GID ' + first);\n        }\n        var next;\n        for (var iRange = 0; iRange < nRanges; iRange++) {\n            fdIndex = parser.parseCard8();\n            next = parser.parseCard16();\n            if (fdIndex >= fdArrayCount) {\n                throw new Error('CFF table CID Font FDSelect has bad FD index value ' + fdIndex + ' (FD count ' + fdArrayCount + ')');\n            }\n            if (next > nGlyphs) {\n                throw new Error('CFF Table CID Font FDSelect format 3 range has bad GID ' + next);\n            }\n            for (; first < next; first++) {\n                fdSelect.push(fdIndex);\n            }\n            first = next;\n        }\n        if (next !== nGlyphs) {\n            throw new Error('CFF Table CID Font FDSelect format 3 range has bad final GID ' + next);\n        }\n    } else {\n        throw new Error('CFF Table CID Font FDSelect table has unsupported format ' + format);\n    }\n    return fdSelect;\n}\n\n// Parse the `CFF` table, which contains the glyph outlines in PostScript format.\nfunction parseCFFTable(data, start, font, opt) {\n    font.tables.cff = {};\n    var header = parseCFFHeader(data, start);\n    var nameIndex = parseCFFIndex(data, header.endOffset, parse.bytesToString);\n    var topDictIndex = parseCFFIndex(data, nameIndex.endOffset);\n    var stringIndex = parseCFFIndex(data, topDictIndex.endOffset, parse.bytesToString);\n    var globalSubrIndex = parseCFFIndex(data, stringIndex.endOffset);\n    font.gsubrs = globalSubrIndex.objects;\n    font.gsubrsBias = calcCFFSubroutineBias(font.gsubrs);\n\n    var topDictArray = gatherCFFTopDicts(data, start, topDictIndex.objects, stringIndex.objects);\n    if (topDictArray.length !== 1) {\n        throw new Error('CFF table has too many fonts in \\'FontSet\\' - count of fonts NameIndex.length = ' + topDictArray.length);\n    }\n\n    var topDict = topDictArray[0];\n    font.tables.cff.topDict = topDict;\n\n    if (topDict._privateDict) {\n        font.defaultWidthX = topDict._privateDict.defaultWidthX;\n        font.nominalWidthX = topDict._privateDict.nominalWidthX;\n    }\n\n    if (topDict.ros[0] !== undefined && topDict.ros[1] !== undefined) {\n        font.isCIDFont = true;\n    }\n\n    if (font.isCIDFont) {\n        var fdArrayOffset = topDict.fdArray;\n        var fdSelectOffset = topDict.fdSelect;\n        if (fdArrayOffset === 0 || fdSelectOffset === 0) {\n            throw new Error('Font is marked as a CID font, but FDArray and/or FDSelect information is missing');\n        }\n        fdArrayOffset += start;\n        var fdArrayIndex = parseCFFIndex(data, fdArrayOffset);\n        var fdArray = gatherCFFTopDicts(data, start, fdArrayIndex.objects, stringIndex.objects);\n        topDict._fdArray = fdArray;\n        fdSelectOffset += start;\n        topDict._fdSelect = parseCFFFDSelect(data, fdSelectOffset, font.numGlyphs, fdArray.length);\n    }\n\n    var privateDictOffset = start + topDict.private[1];\n    var privateDict = parseCFFPrivateDict(data, privateDictOffset, topDict.private[0], stringIndex.objects);\n    font.defaultWidthX = privateDict.defaultWidthX;\n    font.nominalWidthX = privateDict.nominalWidthX;\n\n    if (privateDict.subrs !== 0) {\n        var subrOffset = privateDictOffset + privateDict.subrs;\n        var subrIndex = parseCFFIndex(data, subrOffset);\n        font.subrs = subrIndex.objects;\n        font.subrsBias = calcCFFSubroutineBias(font.subrs);\n    } else {\n        font.subrs = [];\n        font.subrsBias = 0;\n    }\n\n    // Offsets in the top dict are relative to the beginning of the CFF data, so add the CFF start offset.\n    var charStringsIndex;\n    if (opt.lowMemory) {\n        charStringsIndex = parseCFFIndexLowMemory(data, start + topDict.charStrings);\n        font.nGlyphs = charStringsIndex.offsets.length;\n    } else {\n        charStringsIndex = parseCFFIndex(data, start + topDict.charStrings);\n        font.nGlyphs = charStringsIndex.objects.length;\n    }\n\n    var charset = parseCFFCharset(data, start + topDict.charset, font.nGlyphs, stringIndex.objects);\n    if (topDict.encoding === 0) {\n        // Standard encoding\n        font.cffEncoding = new CffEncoding(cffStandardEncoding, charset);\n    } else if (topDict.encoding === 1) {\n        // Expert encoding\n        font.cffEncoding = new CffEncoding(cffExpertEncoding, charset);\n    } else {\n        font.cffEncoding = parseCFFEncoding(data, start + topDict.encoding, charset);\n    }\n\n    // Prefer the CMAP encoding to the CFF encoding.\n    font.encoding = font.encoding || font.cffEncoding;\n\n    font.glyphs = new glyphset.GlyphSet(font);\n    if (opt.lowMemory) {\n        font._push = function(i) {\n            var charString = getCffIndexObject(i, charStringsIndex.offsets, data, start + topDict.charStrings);\n            font.glyphs.push(i, glyphset.cffGlyphLoader(font, i, parseCFFCharstring, charString));\n        };\n    } else {\n        for (var i = 0; i < font.nGlyphs; i += 1) {\n            var charString = charStringsIndex.objects[i];\n            font.glyphs.push(i, glyphset.cffGlyphLoader(font, i, parseCFFCharstring, charString));\n        }\n    }\n}\n\n// Convert a string to a String ID (SID).\n// The list of strings is modified in place.\nfunction encodeString(s, strings) {\n    var sid;\n\n    // Is the string in the CFF standard strings?\n    var i = cffStandardStrings.indexOf(s);\n    if (i >= 0) {\n        sid = i;\n    }\n\n    // Is the string already in the string index?\n    i = strings.indexOf(s);\n    if (i >= 0) {\n        sid = i + cffStandardStrings.length;\n    } else {\n        sid = cffStandardStrings.length + strings.length;\n        strings.push(s);\n    }\n\n    return sid;\n}\n\nfunction makeHeader() {\n    return new table.Record('Header', [\n        {name: 'major', type: 'Card8', value: 1},\n        {name: 'minor', type: 'Card8', value: 0},\n        {name: 'hdrSize', type: 'Card8', value: 4},\n        {name: 'major', type: 'Card8', value: 1}\n    ]);\n}\n\nfunction makeNameIndex(fontNames) {\n    var t = new table.Record('Name INDEX', [\n        {name: 'names', type: 'INDEX', value: []}\n    ]);\n    t.names = [];\n    for (var i = 0; i < fontNames.length; i += 1) {\n        t.names.push({name: 'name_' + i, type: 'NAME', value: fontNames[i]});\n    }\n\n    return t;\n}\n\n// Given a dictionary's metadata, create a DICT structure.\nfunction makeDict(meta, attrs, strings) {\n    var m = {};\n    for (var i = 0; i < meta.length; i += 1) {\n        var entry = meta[i];\n        var value = attrs[entry.name];\n        if (value !== undefined && !equals(value, entry.value)) {\n            if (entry.type === 'SID') {\n                value = encodeString(value, strings);\n            }\n\n            m[entry.op] = {name: entry.name, type: entry.type, value: value};\n        }\n    }\n\n    return m;\n}\n\n// The Top DICT houses the global font attributes.\nfunction makeTopDict(attrs, strings) {\n    var t = new table.Record('Top DICT', [\n        {name: 'dict', type: 'DICT', value: {}}\n    ]);\n    t.dict = makeDict(TOP_DICT_META, attrs, strings);\n    return t;\n}\n\nfunction makeTopDictIndex(topDict) {\n    var t = new table.Record('Top DICT INDEX', [\n        {name: 'topDicts', type: 'INDEX', value: []}\n    ]);\n    t.topDicts = [{name: 'topDict_0', type: 'TABLE', value: topDict}];\n    return t;\n}\n\nfunction makeStringIndex(strings) {\n    var t = new table.Record('String INDEX', [\n        {name: 'strings', type: 'INDEX', value: []}\n    ]);\n    t.strings = [];\n    for (var i = 0; i < strings.length; i += 1) {\n        t.strings.push({name: 'string_' + i, type: 'STRING', value: strings[i]});\n    }\n\n    return t;\n}\n\nfunction makeGlobalSubrIndex() {\n    // Currently we don't use subroutines.\n    return new table.Record('Global Subr INDEX', [\n        {name: 'subrs', type: 'INDEX', value: []}\n    ]);\n}\n\nfunction makeCharsets(glyphNames, strings) {\n    var t = new table.Record('Charsets', [\n        {name: 'format', type: 'Card8', value: 0}\n    ]);\n    for (var i = 0; i < glyphNames.length; i += 1) {\n        var glyphName = glyphNames[i];\n        var glyphSID = encodeString(glyphName, strings);\n        t.fields.push({name: 'glyph_' + i, type: 'SID', value: glyphSID});\n    }\n\n    return t;\n}\n\nfunction glyphToOps(glyph) {\n    var ops = [];\n    var path = glyph.path;\n    ops.push({name: 'width', type: 'NUMBER', value: glyph.advanceWidth});\n    var x = 0;\n    var y = 0;\n    for (var i = 0; i < path.commands.length; i += 1) {\n        var dx = (void 0);\n        var dy = (void 0);\n        var cmd = path.commands[i];\n        if (cmd.type === 'Q') {\n            // CFF only supports bézier curves, so convert the quad to a bézier.\n            var _13 = 1 / 3;\n            var _23 = 2 / 3;\n\n            // We're going to create a new command so we don't change the original path.\n            // Since all coordinates are relative, we round() them ASAP to avoid propagating errors.\n            cmd = {\n                type: 'C',\n                x: cmd.x,\n                y: cmd.y,\n                x1: Math.round(_13 * x + _23 * cmd.x1),\n                y1: Math.round(_13 * y + _23 * cmd.y1),\n                x2: Math.round(_13 * cmd.x + _23 * cmd.x1),\n                y2: Math.round(_13 * cmd.y + _23 * cmd.y1)\n            };\n        }\n\n        if (cmd.type === 'M') {\n            dx = Math.round(cmd.x - x);\n            dy = Math.round(cmd.y - y);\n            ops.push({name: 'dx', type: 'NUMBER', value: dx});\n            ops.push({name: 'dy', type: 'NUMBER', value: dy});\n            ops.push({name: 'rmoveto', type: 'OP', value: 21});\n            x = Math.round(cmd.x);\n            y = Math.round(cmd.y);\n        } else if (cmd.type === 'L') {\n            dx = Math.round(cmd.x - x);\n            dy = Math.round(cmd.y - y);\n            ops.push({name: 'dx', type: 'NUMBER', value: dx});\n            ops.push({name: 'dy', type: 'NUMBER', value: dy});\n            ops.push({name: 'rlineto', type: 'OP', value: 5});\n            x = Math.round(cmd.x);\n            y = Math.round(cmd.y);\n        } else if (cmd.type === 'C') {\n            var dx1 = Math.round(cmd.x1 - x);\n            var dy1 = Math.round(cmd.y1 - y);\n            var dx2 = Math.round(cmd.x2 - cmd.x1);\n            var dy2 = Math.round(cmd.y2 - cmd.y1);\n            dx = Math.round(cmd.x - cmd.x2);\n            dy = Math.round(cmd.y - cmd.y2);\n            ops.push({name: 'dx1', type: 'NUMBER', value: dx1});\n            ops.push({name: 'dy1', type: 'NUMBER', value: dy1});\n            ops.push({name: 'dx2', type: 'NUMBER', value: dx2});\n            ops.push({name: 'dy2', type: 'NUMBER', value: dy2});\n            ops.push({name: 'dx', type: 'NUMBER', value: dx});\n            ops.push({name: 'dy', type: 'NUMBER', value: dy});\n            ops.push({name: 'rrcurveto', type: 'OP', value: 8});\n            x = Math.round(cmd.x);\n            y = Math.round(cmd.y);\n        }\n\n        // Contours are closed automatically.\n    }\n\n    ops.push({name: 'endchar', type: 'OP', value: 14});\n    return ops;\n}\n\nfunction makeCharStringsIndex(glyphs) {\n    var t = new table.Record('CharStrings INDEX', [\n        {name: 'charStrings', type: 'INDEX', value: []}\n    ]);\n\n    for (var i = 0; i < glyphs.length; i += 1) {\n        var glyph = glyphs.get(i);\n        var ops = glyphToOps(glyph);\n        t.charStrings.push({name: glyph.name, type: 'CHARSTRING', value: ops});\n    }\n\n    return t;\n}\n\nfunction makePrivateDict(attrs, strings) {\n    var t = new table.Record('Private DICT', [\n        {name: 'dict', type: 'DICT', value: {}}\n    ]);\n    t.dict = makeDict(PRIVATE_DICT_META, attrs, strings);\n    return t;\n}\n\nfunction makeCFFTable(glyphs, options) {\n    var t = new table.Table('CFF ', [\n        {name: 'header', type: 'RECORD'},\n        {name: 'nameIndex', type: 'RECORD'},\n        {name: 'topDictIndex', type: 'RECORD'},\n        {name: 'stringIndex', type: 'RECORD'},\n        {name: 'globalSubrIndex', type: 'RECORD'},\n        {name: 'charsets', type: 'RECORD'},\n        {name: 'charStringsIndex', type: 'RECORD'},\n        {name: 'privateDict', type: 'RECORD'}\n    ]);\n\n    var fontScale = 1 / options.unitsPerEm;\n    // We use non-zero values for the offsets so that the DICT encodes them.\n    // This is important because the size of the Top DICT plays a role in offset calculation,\n    // and the size shouldn't change after we've written correct offsets.\n    var attrs = {\n        version: options.version,\n        fullName: options.fullName,\n        familyName: options.familyName,\n        weight: options.weightName,\n        fontBBox: options.fontBBox || [0, 0, 0, 0],\n        fontMatrix: [fontScale, 0, 0, fontScale, 0, 0],\n        charset: 999,\n        encoding: 0,\n        charStrings: 999,\n        private: [0, 999]\n    };\n\n    var privateAttrs = {};\n\n    var glyphNames = [];\n    var glyph;\n\n    // Skip first glyph (.notdef)\n    for (var i = 1; i < glyphs.length; i += 1) {\n        glyph = glyphs.get(i);\n        glyphNames.push(glyph.name);\n    }\n\n    var strings = [];\n\n    t.header = makeHeader();\n    t.nameIndex = makeNameIndex([options.postScriptName]);\n    var topDict = makeTopDict(attrs, strings);\n    t.topDictIndex = makeTopDictIndex(topDict);\n    t.globalSubrIndex = makeGlobalSubrIndex();\n    t.charsets = makeCharsets(glyphNames, strings);\n    t.charStringsIndex = makeCharStringsIndex(glyphs);\n    t.privateDict = makePrivateDict(privateAttrs, strings);\n\n    // Needs to come at the end, to encode all custom strings used in the font.\n    t.stringIndex = makeStringIndex(strings);\n\n    var startOffset = t.header.sizeOf() +\n        t.nameIndex.sizeOf() +\n        t.topDictIndex.sizeOf() +\n        t.stringIndex.sizeOf() +\n        t.globalSubrIndex.sizeOf();\n    attrs.charset = startOffset;\n\n    // We use the CFF standard encoding; proper encoding will be handled in cmap.\n    attrs.encoding = 0;\n    attrs.charStrings = attrs.charset + t.charsets.sizeOf();\n    attrs.private[1] = attrs.charStrings + t.charStringsIndex.sizeOf();\n\n    // Recreate the Top DICT INDEX with the correct offsets.\n    topDict = makeTopDict(attrs, strings);\n    t.topDictIndex = makeTopDictIndex(topDict);\n\n    return t;\n}\n\nvar cff = { parse: parseCFFTable, make: makeCFFTable };\n\n// The `head` table contains global information about the font.\n\n// Parse the header `head` table\nfunction parseHeadTable(data, start) {\n    var head = {};\n    var p = new parse.Parser(data, start);\n    head.version = p.parseVersion();\n    head.fontRevision = Math.round(p.parseFixed() * 1000) / 1000;\n    head.checkSumAdjustment = p.parseULong();\n    head.magicNumber = p.parseULong();\n    check.argument(head.magicNumber === 0x5F0F3CF5, 'Font header has wrong magic number.');\n    head.flags = p.parseUShort();\n    head.unitsPerEm = p.parseUShort();\n    head.created = p.parseLongDateTime();\n    head.modified = p.parseLongDateTime();\n    head.xMin = p.parseShort();\n    head.yMin = p.parseShort();\n    head.xMax = p.parseShort();\n    head.yMax = p.parseShort();\n    head.macStyle = p.parseUShort();\n    head.lowestRecPPEM = p.parseUShort();\n    head.fontDirectionHint = p.parseShort();\n    head.indexToLocFormat = p.parseShort();\n    head.glyphDataFormat = p.parseShort();\n    return head;\n}\n\nfunction makeHeadTable(options) {\n    // Apple Mac timestamp epoch is 01/01/1904 not 01/01/1970\n    var timestamp = Math.round(new Date().getTime() / 1000) + 2082844800;\n    var createdTimestamp = timestamp;\n\n    if (options.createdTimestamp) {\n        createdTimestamp = options.createdTimestamp + 2082844800;\n    }\n\n    return new table.Table('head', [\n        {name: 'version', type: 'FIXED', value: 0x00010000},\n        {name: 'fontRevision', type: 'FIXED', value: 0x00010000},\n        {name: 'checkSumAdjustment', type: 'ULONG', value: 0},\n        {name: 'magicNumber', type: 'ULONG', value: 0x5F0F3CF5},\n        {name: 'flags', type: 'USHORT', value: 0},\n        {name: 'unitsPerEm', type: 'USHORT', value: 1000},\n        {name: 'created', type: 'LONGDATETIME', value: createdTimestamp},\n        {name: 'modified', type: 'LONGDATETIME', value: timestamp},\n        {name: 'xMin', type: 'SHORT', value: 0},\n        {name: 'yMin', type: 'SHORT', value: 0},\n        {name: 'xMax', type: 'SHORT', value: 0},\n        {name: 'yMax', type: 'SHORT', value: 0},\n        {name: 'macStyle', type: 'USHORT', value: 0},\n        {name: 'lowestRecPPEM', type: 'USHORT', value: 0},\n        {name: 'fontDirectionHint', type: 'SHORT', value: 2},\n        {name: 'indexToLocFormat', type: 'SHORT', value: 0},\n        {name: 'glyphDataFormat', type: 'SHORT', value: 0}\n    ], options);\n}\n\nvar head = { parse: parseHeadTable, make: makeHeadTable };\n\n// The `hhea` table contains information for horizontal layout.\n\n// Parse the horizontal header `hhea` table\nfunction parseHheaTable(data, start) {\n    var hhea = {};\n    var p = new parse.Parser(data, start);\n    hhea.version = p.parseVersion();\n    hhea.ascender = p.parseShort();\n    hhea.descender = p.parseShort();\n    hhea.lineGap = p.parseShort();\n    hhea.advanceWidthMax = p.parseUShort();\n    hhea.minLeftSideBearing = p.parseShort();\n    hhea.minRightSideBearing = p.parseShort();\n    hhea.xMaxExtent = p.parseShort();\n    hhea.caretSlopeRise = p.parseShort();\n    hhea.caretSlopeRun = p.parseShort();\n    hhea.caretOffset = p.parseShort();\n    p.relativeOffset += 8;\n    hhea.metricDataFormat = p.parseShort();\n    hhea.numberOfHMetrics = p.parseUShort();\n    return hhea;\n}\n\nfunction makeHheaTable(options) {\n    return new table.Table('hhea', [\n        {name: 'version', type: 'FIXED', value: 0x00010000},\n        {name: 'ascender', type: 'FWORD', value: 0},\n        {name: 'descender', type: 'FWORD', value: 0},\n        {name: 'lineGap', type: 'FWORD', value: 0},\n        {name: 'advanceWidthMax', type: 'UFWORD', value: 0},\n        {name: 'minLeftSideBearing', type: 'FWORD', value: 0},\n        {name: 'minRightSideBearing', type: 'FWORD', value: 0},\n        {name: 'xMaxExtent', type: 'FWORD', value: 0},\n        {name: 'caretSlopeRise', type: 'SHORT', value: 1},\n        {name: 'caretSlopeRun', type: 'SHORT', value: 0},\n        {name: 'caretOffset', type: 'SHORT', value: 0},\n        {name: 'reserved1', type: 'SHORT', value: 0},\n        {name: 'reserved2', type: 'SHORT', value: 0},\n        {name: 'reserved3', type: 'SHORT', value: 0},\n        {name: 'reserved4', type: 'SHORT', value: 0},\n        {name: 'metricDataFormat', type: 'SHORT', value: 0},\n        {name: 'numberOfHMetrics', type: 'USHORT', value: 0}\n    ], options);\n}\n\nvar hhea = { parse: parseHheaTable, make: makeHheaTable };\n\n// The `hmtx` table contains the horizontal metrics for all glyphs.\n\nfunction parseHmtxTableAll(data, start, numMetrics, numGlyphs, glyphs) {\n    var advanceWidth;\n    var leftSideBearing;\n    var p = new parse.Parser(data, start);\n    for (var i = 0; i < numGlyphs; i += 1) {\n        // If the font is monospaced, only one entry is needed. This last entry applies to all subsequent glyphs.\n        if (i < numMetrics) {\n            advanceWidth = p.parseUShort();\n            leftSideBearing = p.parseShort();\n        }\n\n        var glyph = glyphs.get(i);\n        glyph.advanceWidth = advanceWidth;\n        glyph.leftSideBearing = leftSideBearing;\n    }\n}\n\nfunction parseHmtxTableOnLowMemory(font, data, start, numMetrics, numGlyphs) {\n    font._hmtxTableData = {};\n\n    var advanceWidth;\n    var leftSideBearing;\n    var p = new parse.Parser(data, start);\n    for (var i = 0; i < numGlyphs; i += 1) {\n        // If the font is monospaced, only one entry is needed. This last entry applies to all subsequent glyphs.\n        if (i < numMetrics) {\n            advanceWidth = p.parseUShort();\n            leftSideBearing = p.parseShort();\n        }\n\n        font._hmtxTableData[i] = {\n            advanceWidth: advanceWidth,\n            leftSideBearing: leftSideBearing\n        };\n    }\n}\n\n// Parse the `hmtx` table, which contains the horizontal metrics for all glyphs.\n// This function augments the glyph array, adding the advanceWidth and leftSideBearing to each glyph.\nfunction parseHmtxTable(font, data, start, numMetrics, numGlyphs, glyphs, opt) {\n    if (opt.lowMemory)\n        { parseHmtxTableOnLowMemory(font, data, start, numMetrics, numGlyphs); }\n    else\n        { parseHmtxTableAll(data, start, numMetrics, numGlyphs, glyphs); }\n}\n\nfunction makeHmtxTable(glyphs) {\n    var t = new table.Table('hmtx', []);\n    for (var i = 0; i < glyphs.length; i += 1) {\n        var glyph = glyphs.get(i);\n        var advanceWidth = glyph.advanceWidth || 0;\n        var leftSideBearing = glyph.leftSideBearing || 0;\n        t.fields.push({name: 'advanceWidth_' + i, type: 'USHORT', value: advanceWidth});\n        t.fields.push({name: 'leftSideBearing_' + i, type: 'SHORT', value: leftSideBearing});\n    }\n\n    return t;\n}\n\nvar hmtx = { parse: parseHmtxTable, make: makeHmtxTable };\n\n// The `ltag` table stores IETF BCP-47 language tags. It allows supporting\n\nfunction makeLtagTable(tags) {\n    var result = new table.Table('ltag', [\n        {name: 'version', type: 'ULONG', value: 1},\n        {name: 'flags', type: 'ULONG', value: 0},\n        {name: 'numTags', type: 'ULONG', value: tags.length}\n    ]);\n\n    var stringPool = '';\n    var stringPoolOffset = 12 + tags.length * 4;\n    for (var i = 0; i < tags.length; ++i) {\n        var pos = stringPool.indexOf(tags[i]);\n        if (pos < 0) {\n            pos = stringPool.length;\n            stringPool += tags[i];\n        }\n\n        result.fields.push({name: 'offset ' + i, type: 'USHORT', value: stringPoolOffset + pos});\n        result.fields.push({name: 'length ' + i, type: 'USHORT', value: tags[i].length});\n    }\n\n    result.fields.push({name: 'stringPool', type: 'CHARARRAY', value: stringPool});\n    return result;\n}\n\nfunction parseLtagTable(data, start) {\n    var p = new parse.Parser(data, start);\n    var tableVersion = p.parseULong();\n    check.argument(tableVersion === 1, 'Unsupported ltag table version.');\n    // The 'ltag' specification does not define any flags; skip the field.\n    p.skip('uLong', 1);\n    var numTags = p.parseULong();\n\n    var tags = [];\n    for (var i = 0; i < numTags; i++) {\n        var tag = '';\n        var offset = start + p.parseUShort();\n        var length = p.parseUShort();\n        for (var j = offset; j < offset + length; ++j) {\n            tag += String.fromCharCode(data.getInt8(j));\n        }\n\n        tags.push(tag);\n    }\n\n    return tags;\n}\n\nvar ltag = { make: makeLtagTable, parse: parseLtagTable };\n\n// The `maxp` table establishes the memory requirements for the font.\n\n// Parse the maximum profile `maxp` table.\nfunction parseMaxpTable(data, start) {\n    var maxp = {};\n    var p = new parse.Parser(data, start);\n    maxp.version = p.parseVersion();\n    maxp.numGlyphs = p.parseUShort();\n    if (maxp.version === 1.0) {\n        maxp.maxPoints = p.parseUShort();\n        maxp.maxContours = p.parseUShort();\n        maxp.maxCompositePoints = p.parseUShort();\n        maxp.maxCompositeContours = p.parseUShort();\n        maxp.maxZones = p.parseUShort();\n        maxp.maxTwilightPoints = p.parseUShort();\n        maxp.maxStorage = p.parseUShort();\n        maxp.maxFunctionDefs = p.parseUShort();\n        maxp.maxInstructionDefs = p.parseUShort();\n        maxp.maxStackElements = p.parseUShort();\n        maxp.maxSizeOfInstructions = p.parseUShort();\n        maxp.maxComponentElements = p.parseUShort();\n        maxp.maxComponentDepth = p.parseUShort();\n    }\n\n    return maxp;\n}\n\nfunction makeMaxpTable(numGlyphs) {\n    return new table.Table('maxp', [\n        {name: 'version', type: 'FIXED', value: 0x00005000},\n        {name: 'numGlyphs', type: 'USHORT', value: numGlyphs}\n    ]);\n}\n\nvar maxp = { parse: parseMaxpTable, make: makeMaxpTable };\n\n// The `name` naming table.\n\n// NameIDs for the name table.\nvar nameTableNames = [\n    'copyright',              // 0\n    'fontFamily',             // 1\n    'fontSubfamily',          // 2\n    'uniqueID',               // 3\n    'fullName',               // 4\n    'version',                // 5\n    'postScriptName',         // 6\n    'trademark',              // 7\n    'manufacturer',           // 8\n    'designer',               // 9\n    'description',            // 10\n    'manufacturerURL',        // 11\n    'designerURL',            // 12\n    'license',                // 13\n    'licenseURL',             // 14\n    'reserved',               // 15\n    'preferredFamily',        // 16\n    'preferredSubfamily',     // 17\n    'compatibleFullName',     // 18\n    'sampleText',             // 19\n    'postScriptFindFontName', // 20\n    'wwsFamily',              // 21\n    'wwsSubfamily'            // 22\n];\n\nvar macLanguages = {\n    0: 'en',\n    1: 'fr',\n    2: 'de',\n    3: 'it',\n    4: 'nl',\n    5: 'sv',\n    6: 'es',\n    7: 'da',\n    8: 'pt',\n    9: 'no',\n    10: 'he',\n    11: 'ja',\n    12: 'ar',\n    13: 'fi',\n    14: 'el',\n    15: 'is',\n    16: 'mt',\n    17: 'tr',\n    18: 'hr',\n    19: 'zh-Hant',\n    20: 'ur',\n    21: 'hi',\n    22: 'th',\n    23: 'ko',\n    24: 'lt',\n    25: 'pl',\n    26: 'hu',\n    27: 'es',\n    28: 'lv',\n    29: 'se',\n    30: 'fo',\n    31: 'fa',\n    32: 'ru',\n    33: 'zh',\n    34: 'nl-BE',\n    35: 'ga',\n    36: 'sq',\n    37: 'ro',\n    38: 'cz',\n    39: 'sk',\n    40: 'si',\n    41: 'yi',\n    42: 'sr',\n    43: 'mk',\n    44: 'bg',\n    45: 'uk',\n    46: 'be',\n    47: 'uz',\n    48: 'kk',\n    49: 'az-Cyrl',\n    50: 'az-Arab',\n    51: 'hy',\n    52: 'ka',\n    53: 'mo',\n    54: 'ky',\n    55: 'tg',\n    56: 'tk',\n    57: 'mn-CN',\n    58: 'mn',\n    59: 'ps',\n    60: 'ks',\n    61: 'ku',\n    62: 'sd',\n    63: 'bo',\n    64: 'ne',\n    65: 'sa',\n    66: 'mr',\n    67: 'bn',\n    68: 'as',\n    69: 'gu',\n    70: 'pa',\n    71: 'or',\n    72: 'ml',\n    73: 'kn',\n    74: 'ta',\n    75: 'te',\n    76: 'si',\n    77: 'my',\n    78: 'km',\n    79: 'lo',\n    80: 'vi',\n    81: 'id',\n    82: 'tl',\n    83: 'ms',\n    84: 'ms-Arab',\n    85: 'am',\n    86: 'ti',\n    87: 'om',\n    88: 'so',\n    89: 'sw',\n    90: 'rw',\n    91: 'rn',\n    92: 'ny',\n    93: 'mg',\n    94: 'eo',\n    128: 'cy',\n    129: 'eu',\n    130: 'ca',\n    131: 'la',\n    132: 'qu',\n    133: 'gn',\n    134: 'ay',\n    135: 'tt',\n    136: 'ug',\n    137: 'dz',\n    138: 'jv',\n    139: 'su',\n    140: 'gl',\n    141: 'af',\n    142: 'br',\n    143: 'iu',\n    144: 'gd',\n    145: 'gv',\n    146: 'ga',\n    147: 'to',\n    148: 'el-polyton',\n    149: 'kl',\n    150: 'az',\n    151: 'nn'\n};\n\n// MacOS language ID → MacOS script ID\n//\n// Note that the script ID is not sufficient to determine what encoding\n// to use in TrueType files. For some languages, MacOS used a modification\n// of a mainstream script. For example, an Icelandic name would be stored\n// with smRoman in the TrueType naming table, but the actual encoding\n// is a special Icelandic version of the normal Macintosh Roman encoding.\n// As another example, Inuktitut uses an 8-bit encoding for Canadian Aboriginal\n// Syllables but MacOS had run out of available script codes, so this was\n// done as a (pretty radical) \"modification\" of Ethiopic.\n//\n// http://unicode.org/Public/MAPPINGS/VENDORS/APPLE/Readme.txt\nvar macLanguageToScript = {\n    0: 0,  // langEnglish → smRoman\n    1: 0,  // langFrench → smRoman\n    2: 0,  // langGerman → smRoman\n    3: 0,  // langItalian → smRoman\n    4: 0,  // langDutch → smRoman\n    5: 0,  // langSwedish → smRoman\n    6: 0,  // langSpanish → smRoman\n    7: 0,  // langDanish → smRoman\n    8: 0,  // langPortuguese → smRoman\n    9: 0,  // langNorwegian → smRoman\n    10: 5,  // langHebrew → smHebrew\n    11: 1,  // langJapanese → smJapanese\n    12: 4,  // langArabic → smArabic\n    13: 0,  // langFinnish → smRoman\n    14: 6,  // langGreek → smGreek\n    15: 0,  // langIcelandic → smRoman (modified)\n    16: 0,  // langMaltese → smRoman\n    17: 0,  // langTurkish → smRoman (modified)\n    18: 0,  // langCroatian → smRoman (modified)\n    19: 2,  // langTradChinese → smTradChinese\n    20: 4,  // langUrdu → smArabic\n    21: 9,  // langHindi → smDevanagari\n    22: 21,  // langThai → smThai\n    23: 3,  // langKorean → smKorean\n    24: 29,  // langLithuanian → smCentralEuroRoman\n    25: 29,  // langPolish → smCentralEuroRoman\n    26: 29,  // langHungarian → smCentralEuroRoman\n    27: 29,  // langEstonian → smCentralEuroRoman\n    28: 29,  // langLatvian → smCentralEuroRoman\n    29: 0,  // langSami → smRoman\n    30: 0,  // langFaroese → smRoman (modified)\n    31: 4,  // langFarsi → smArabic (modified)\n    32: 7,  // langRussian → smCyrillic\n    33: 25,  // langSimpChinese → smSimpChinese\n    34: 0,  // langFlemish → smRoman\n    35: 0,  // langIrishGaelic → smRoman (modified)\n    36: 0,  // langAlbanian → smRoman\n    37: 0,  // langRomanian → smRoman (modified)\n    38: 29,  // langCzech → smCentralEuroRoman\n    39: 29,  // langSlovak → smCentralEuroRoman\n    40: 0,  // langSlovenian → smRoman (modified)\n    41: 5,  // langYiddish → smHebrew\n    42: 7,  // langSerbian → smCyrillic\n    43: 7,  // langMacedonian → smCyrillic\n    44: 7,  // langBulgarian → smCyrillic\n    45: 7,  // langUkrainian → smCyrillic (modified)\n    46: 7,  // langByelorussian → smCyrillic\n    47: 7,  // langUzbek → smCyrillic\n    48: 7,  // langKazakh → smCyrillic\n    49: 7,  // langAzerbaijani → smCyrillic\n    50: 4,  // langAzerbaijanAr → smArabic\n    51: 24,  // langArmenian → smArmenian\n    52: 23,  // langGeorgian → smGeorgian\n    53: 7,  // langMoldavian → smCyrillic\n    54: 7,  // langKirghiz → smCyrillic\n    55: 7,  // langTajiki → smCyrillic\n    56: 7,  // langTurkmen → smCyrillic\n    57: 27,  // langMongolian → smMongolian\n    58: 7,  // langMongolianCyr → smCyrillic\n    59: 4,  // langPashto → smArabic\n    60: 4,  // langKurdish → smArabic\n    61: 4,  // langKashmiri → smArabic\n    62: 4,  // langSindhi → smArabic\n    63: 26,  // langTibetan → smTibetan\n    64: 9,  // langNepali → smDevanagari\n    65: 9,  // langSanskrit → smDevanagari\n    66: 9,  // langMarathi → smDevanagari\n    67: 13,  // langBengali → smBengali\n    68: 13,  // langAssamese → smBengali\n    69: 11,  // langGujarati → smGujarati\n    70: 10,  // langPunjabi → smGurmukhi\n    71: 12,  // langOriya → smOriya\n    72: 17,  // langMalayalam → smMalayalam\n    73: 16,  // langKannada → smKannada\n    74: 14,  // langTamil → smTamil\n    75: 15,  // langTelugu → smTelugu\n    76: 18,  // langSinhalese → smSinhalese\n    77: 19,  // langBurmese → smBurmese\n    78: 20,  // langKhmer → smKhmer\n    79: 22,  // langLao → smLao\n    80: 30,  // langVietnamese → smVietnamese\n    81: 0,  // langIndonesian → smRoman\n    82: 0,  // langTagalog → smRoman\n    83: 0,  // langMalayRoman → smRoman\n    84: 4,  // langMalayArabic → smArabic\n    85: 28,  // langAmharic → smEthiopic\n    86: 28,  // langTigrinya → smEthiopic\n    87: 28,  // langOromo → smEthiopic\n    88: 0,  // langSomali → smRoman\n    89: 0,  // langSwahili → smRoman\n    90: 0,  // langKinyarwanda → smRoman\n    91: 0,  // langRundi → smRoman\n    92: 0,  // langNyanja → smRoman\n    93: 0,  // langMalagasy → smRoman\n    94: 0,  // langEsperanto → smRoman\n    128: 0,  // langWelsh → smRoman (modified)\n    129: 0,  // langBasque → smRoman\n    130: 0,  // langCatalan → smRoman\n    131: 0,  // langLatin → smRoman\n    132: 0,  // langQuechua → smRoman\n    133: 0,  // langGuarani → smRoman\n    134: 0,  // langAymara → smRoman\n    135: 7,  // langTatar → smCyrillic\n    136: 4,  // langUighur → smArabic\n    137: 26,  // langDzongkha → smTibetan\n    138: 0,  // langJavaneseRom → smRoman\n    139: 0,  // langSundaneseRom → smRoman\n    140: 0,  // langGalician → smRoman\n    141: 0,  // langAfrikaans → smRoman\n    142: 0,  // langBreton → smRoman (modified)\n    143: 28,  // langInuktitut → smEthiopic (modified)\n    144: 0,  // langScottishGaelic → smRoman (modified)\n    145: 0,  // langManxGaelic → smRoman (modified)\n    146: 0,  // langIrishGaelicScript → smRoman (modified)\n    147: 0,  // langTongan → smRoman\n    148: 6,  // langGreekAncient → smRoman\n    149: 0,  // langGreenlandic → smRoman\n    150: 0,  // langAzerbaijanRoman → smRoman\n    151: 0   // langNynorsk → smRoman\n};\n\n// While Microsoft indicates a region/country for all its language\n// IDs, we omit the region code if it's equal to the \"most likely\n// region subtag\" according to Unicode CLDR. For scripts, we omit\n// the subtag if it is equal to the Suppress-Script entry in the\n// IANA language subtag registry for IETF BCP 47.\n//\n// For example, Microsoft states that its language code 0x041A is\n// Croatian in Croatia. We transform this to the BCP 47 language code 'hr'\n// and not 'hr-HR' because Croatia is the default country for Croatian,\n// according to Unicode CLDR. As another example, Microsoft states\n// that 0x101A is Croatian (Latin) in Bosnia-Herzegovina. We transform\n// this to 'hr-BA' and not 'hr-Latn-BA' because Latin is the default script\n// for the Croatian language, according to IANA.\n//\n// http://www.unicode.org/cldr/charts/latest/supplemental/likely_subtags.html\n// http://www.iana.org/assignments/language-subtag-registry/language-subtag-registry\nvar windowsLanguages = {\n    0x0436: 'af',\n    0x041C: 'sq',\n    0x0484: 'gsw',\n    0x045E: 'am',\n    0x1401: 'ar-DZ',\n    0x3C01: 'ar-BH',\n    0x0C01: 'ar',\n    0x0801: 'ar-IQ',\n    0x2C01: 'ar-JO',\n    0x3401: 'ar-KW',\n    0x3001: 'ar-LB',\n    0x1001: 'ar-LY',\n    0x1801: 'ary',\n    0x2001: 'ar-OM',\n    0x4001: 'ar-QA',\n    0x0401: 'ar-SA',\n    0x2801: 'ar-SY',\n    0x1C01: 'aeb',\n    0x3801: 'ar-AE',\n    0x2401: 'ar-YE',\n    0x042B: 'hy',\n    0x044D: 'as',\n    0x082C: 'az-Cyrl',\n    0x042C: 'az',\n    0x046D: 'ba',\n    0x042D: 'eu',\n    0x0423: 'be',\n    0x0845: 'bn',\n    0x0445: 'bn-IN',\n    0x201A: 'bs-Cyrl',\n    0x141A: 'bs',\n    0x047E: 'br',\n    0x0402: 'bg',\n    0x0403: 'ca',\n    0x0C04: 'zh-HK',\n    0x1404: 'zh-MO',\n    0x0804: 'zh',\n    0x1004: 'zh-SG',\n    0x0404: 'zh-TW',\n    0x0483: 'co',\n    0x041A: 'hr',\n    0x101A: 'hr-BA',\n    0x0405: 'cs',\n    0x0406: 'da',\n    0x048C: 'prs',\n    0x0465: 'dv',\n    0x0813: 'nl-BE',\n    0x0413: 'nl',\n    0x0C09: 'en-AU',\n    0x2809: 'en-BZ',\n    0x1009: 'en-CA',\n    0x2409: 'en-029',\n    0x4009: 'en-IN',\n    0x1809: 'en-IE',\n    0x2009: 'en-JM',\n    0x4409: 'en-MY',\n    0x1409: 'en-NZ',\n    0x3409: 'en-PH',\n    0x4809: 'en-SG',\n    0x1C09: 'en-ZA',\n    0x2C09: 'en-TT',\n    0x0809: 'en-GB',\n    0x0409: 'en',\n    0x3009: 'en-ZW',\n    0x0425: 'et',\n    0x0438: 'fo',\n    0x0464: 'fil',\n    0x040B: 'fi',\n    0x080C: 'fr-BE',\n    0x0C0C: 'fr-CA',\n    0x040C: 'fr',\n    0x140C: 'fr-LU',\n    0x180C: 'fr-MC',\n    0x100C: 'fr-CH',\n    0x0462: 'fy',\n    0x0456: 'gl',\n    0x0437: 'ka',\n    0x0C07: 'de-AT',\n    0x0407: 'de',\n    0x1407: 'de-LI',\n    0x1007: 'de-LU',\n    0x0807: 'de-CH',\n    0x0408: 'el',\n    0x046F: 'kl',\n    0x0447: 'gu',\n    0x0468: 'ha',\n    0x040D: 'he',\n    0x0439: 'hi',\n    0x040E: 'hu',\n    0x040F: 'is',\n    0x0470: 'ig',\n    0x0421: 'id',\n    0x045D: 'iu',\n    0x085D: 'iu-Latn',\n    0x083C: 'ga',\n    0x0434: 'xh',\n    0x0435: 'zu',\n    0x0410: 'it',\n    0x0810: 'it-CH',\n    0x0411: 'ja',\n    0x044B: 'kn',\n    0x043F: 'kk',\n    0x0453: 'km',\n    0x0486: 'quc',\n    0x0487: 'rw',\n    0x0441: 'sw',\n    0x0457: 'kok',\n    0x0412: 'ko',\n    0x0440: 'ky',\n    0x0454: 'lo',\n    0x0426: 'lv',\n    0x0427: 'lt',\n    0x082E: 'dsb',\n    0x046E: 'lb',\n    0x042F: 'mk',\n    0x083E: 'ms-BN',\n    0x043E: 'ms',\n    0x044C: 'ml',\n    0x043A: 'mt',\n    0x0481: 'mi',\n    0x047A: 'arn',\n    0x044E: 'mr',\n    0x047C: 'moh',\n    0x0450: 'mn',\n    0x0850: 'mn-CN',\n    0x0461: 'ne',\n    0x0414: 'nb',\n    0x0814: 'nn',\n    0x0482: 'oc',\n    0x0448: 'or',\n    0x0463: 'ps',\n    0x0415: 'pl',\n    0x0416: 'pt',\n    0x0816: 'pt-PT',\n    0x0446: 'pa',\n    0x046B: 'qu-BO',\n    0x086B: 'qu-EC',\n    0x0C6B: 'qu',\n    0x0418: 'ro',\n    0x0417: 'rm',\n    0x0419: 'ru',\n    0x243B: 'smn',\n    0x103B: 'smj-NO',\n    0x143B: 'smj',\n    0x0C3B: 'se-FI',\n    0x043B: 'se',\n    0x083B: 'se-SE',\n    0x203B: 'sms',\n    0x183B: 'sma-NO',\n    0x1C3B: 'sms',\n    0x044F: 'sa',\n    0x1C1A: 'sr-Cyrl-BA',\n    0x0C1A: 'sr',\n    0x181A: 'sr-Latn-BA',\n    0x081A: 'sr-Latn',\n    0x046C: 'nso',\n    0x0432: 'tn',\n    0x045B: 'si',\n    0x041B: 'sk',\n    0x0424: 'sl',\n    0x2C0A: 'es-AR',\n    0x400A: 'es-BO',\n    0x340A: 'es-CL',\n    0x240A: 'es-CO',\n    0x140A: 'es-CR',\n    0x1C0A: 'es-DO',\n    0x300A: 'es-EC',\n    0x440A: 'es-SV',\n    0x100A: 'es-GT',\n    0x480A: 'es-HN',\n    0x080A: 'es-MX',\n    0x4C0A: 'es-NI',\n    0x180A: 'es-PA',\n    0x3C0A: 'es-PY',\n    0x280A: 'es-PE',\n    0x500A: 'es-PR',\n\n    // Microsoft has defined two different language codes for\n    // “Spanish with modern sorting” and “Spanish with traditional\n    // sorting”. This makes sense for collation APIs, and it would be\n    // possible to express this in BCP 47 language tags via Unicode\n    // extensions (eg., es-u-co-trad is Spanish with traditional\n    // sorting). However, for storing names in fonts, the distinction\n    // does not make sense, so we give “es” in both cases.\n    0x0C0A: 'es',\n    0x040A: 'es',\n\n    0x540A: 'es-US',\n    0x380A: 'es-UY',\n    0x200A: 'es-VE',\n    0x081D: 'sv-FI',\n    0x041D: 'sv',\n    0x045A: 'syr',\n    0x0428: 'tg',\n    0x085F: 'tzm',\n    0x0449: 'ta',\n    0x0444: 'tt',\n    0x044A: 'te',\n    0x041E: 'th',\n    0x0451: 'bo',\n    0x041F: 'tr',\n    0x0442: 'tk',\n    0x0480: 'ug',\n    0x0422: 'uk',\n    0x042E: 'hsb',\n    0x0420: 'ur',\n    0x0843: 'uz-Cyrl',\n    0x0443: 'uz',\n    0x042A: 'vi',\n    0x0452: 'cy',\n    0x0488: 'wo',\n    0x0485: 'sah',\n    0x0478: 'ii',\n    0x046A: 'yo'\n};\n\n// Returns a IETF BCP 47 language code, for example 'zh-Hant'\n// for 'Chinese in the traditional script'.\nfunction getLanguageCode(platformID, languageID, ltag) {\n    switch (platformID) {\n        case 0:  // Unicode\n            if (languageID === 0xFFFF) {\n                return 'und';\n            } else if (ltag) {\n                return ltag[languageID];\n            }\n\n            break;\n\n        case 1:  // Macintosh\n            return macLanguages[languageID];\n\n        case 3:  // Windows\n            return windowsLanguages[languageID];\n    }\n\n    return undefined;\n}\n\nvar utf16 = 'utf-16';\n\n// MacOS script ID → encoding. This table stores the default case,\n// which can be overridden by macLanguageEncodings.\nvar macScriptEncodings = {\n    0: 'macintosh',           // smRoman\n    1: 'x-mac-japanese',      // smJapanese\n    2: 'x-mac-chinesetrad',   // smTradChinese\n    3: 'x-mac-korean',        // smKorean\n    6: 'x-mac-greek',         // smGreek\n    7: 'x-mac-cyrillic',      // smCyrillic\n    9: 'x-mac-devanagai',     // smDevanagari\n    10: 'x-mac-gurmukhi',     // smGurmukhi\n    11: 'x-mac-gujarati',     // smGujarati\n    12: 'x-mac-oriya',        // smOriya\n    13: 'x-mac-bengali',      // smBengali\n    14: 'x-mac-tamil',        // smTamil\n    15: 'x-mac-telugu',       // smTelugu\n    16: 'x-mac-kannada',      // smKannada\n    17: 'x-mac-malayalam',    // smMalayalam\n    18: 'x-mac-sinhalese',    // smSinhalese\n    19: 'x-mac-burmese',      // smBurmese\n    20: 'x-mac-khmer',        // smKhmer\n    21: 'x-mac-thai',         // smThai\n    22: 'x-mac-lao',          // smLao\n    23: 'x-mac-georgian',     // smGeorgian\n    24: 'x-mac-armenian',     // smArmenian\n    25: 'x-mac-chinesesimp',  // smSimpChinese\n    26: 'x-mac-tibetan',      // smTibetan\n    27: 'x-mac-mongolian',    // smMongolian\n    28: 'x-mac-ethiopic',     // smEthiopic\n    29: 'x-mac-ce',           // smCentralEuroRoman\n    30: 'x-mac-vietnamese',   // smVietnamese\n    31: 'x-mac-extarabic'     // smExtArabic\n};\n\n// MacOS language ID → encoding. This table stores the exceptional\n// cases, which override macScriptEncodings. For writing MacOS naming\n// tables, we need to emit a MacOS script ID. Therefore, we cannot\n// merge macScriptEncodings into macLanguageEncodings.\n//\n// http://unicode.org/Public/MAPPINGS/VENDORS/APPLE/Readme.txt\nvar macLanguageEncodings = {\n    15: 'x-mac-icelandic',    // langIcelandic\n    17: 'x-mac-turkish',      // langTurkish\n    18: 'x-mac-croatian',     // langCroatian\n    24: 'x-mac-ce',           // langLithuanian\n    25: 'x-mac-ce',           // langPolish\n    26: 'x-mac-ce',           // langHungarian\n    27: 'x-mac-ce',           // langEstonian\n    28: 'x-mac-ce',           // langLatvian\n    30: 'x-mac-icelandic',    // langFaroese\n    37: 'x-mac-romanian',     // langRomanian\n    38: 'x-mac-ce',           // langCzech\n    39: 'x-mac-ce',           // langSlovak\n    40: 'x-mac-ce',           // langSlovenian\n    143: 'x-mac-inuit',       // langInuktitut\n    146: 'x-mac-gaelic'       // langIrishGaelicScript\n};\n\nfunction getEncoding(platformID, encodingID, languageID) {\n    switch (platformID) {\n        case 0:  // Unicode\n            return utf16;\n\n        case 1:  // Apple Macintosh\n            return macLanguageEncodings[languageID] || macScriptEncodings[encodingID];\n\n        case 3:  // Microsoft Windows\n            if (encodingID === 1 || encodingID === 10) {\n                return utf16;\n            }\n\n            break;\n    }\n\n    return undefined;\n}\n\n// Parse the naming `name` table.\n// FIXME: Format 1 additional fields are not supported yet.\n// ltag is the content of the `ltag' table, such as ['en', 'zh-Hans', 'de-CH-1904'].\nfunction parseNameTable(data, start, ltag) {\n    var name = {};\n    var p = new parse.Parser(data, start);\n    var format = p.parseUShort();\n    var count = p.parseUShort();\n    var stringOffset = p.offset + p.parseUShort();\n    for (var i = 0; i < count; i++) {\n        var platformID = p.parseUShort();\n        var encodingID = p.parseUShort();\n        var languageID = p.parseUShort();\n        var nameID = p.parseUShort();\n        var property = nameTableNames[nameID] || nameID;\n        var byteLength = p.parseUShort();\n        var offset = p.parseUShort();\n        var language = getLanguageCode(platformID, languageID, ltag);\n        var encoding = getEncoding(platformID, encodingID, languageID);\n        if (encoding !== undefined && language !== undefined) {\n            var text = (void 0);\n            if (encoding === utf16) {\n                text = decode.UTF16(data, stringOffset + offset, byteLength);\n            } else {\n                text = decode.MACSTRING(data, stringOffset + offset, byteLength, encoding);\n            }\n\n            if (text) {\n                var translations = name[property];\n                if (translations === undefined) {\n                    translations = name[property] = {};\n                }\n\n                translations[language] = text;\n            }\n        }\n    }\n\n    var langTagCount = 0;\n    if (format === 1) {\n        // FIXME: Also handle Microsoft's 'name' table 1.\n        langTagCount = p.parseUShort();\n    }\n\n    return name;\n}\n\n// {23: 'foo'} → {'foo': 23}\n// ['bar', 'baz'] → {'bar': 0, 'baz': 1}\nfunction reverseDict(dict) {\n    var result = {};\n    for (var key in dict) {\n        result[dict[key]] = parseInt(key);\n    }\n\n    return result;\n}\n\nfunction makeNameRecord(platformID, encodingID, languageID, nameID, length, offset) {\n    return new table.Record('NameRecord', [\n        {name: 'platformID', type: 'USHORT', value: platformID},\n        {name: 'encodingID', type: 'USHORT', value: encodingID},\n        {name: 'languageID', type: 'USHORT', value: languageID},\n        {name: 'nameID', type: 'USHORT', value: nameID},\n        {name: 'length', type: 'USHORT', value: length},\n        {name: 'offset', type: 'USHORT', value: offset}\n    ]);\n}\n\n// Finds the position of needle in haystack, or -1 if not there.\n// Like String.indexOf(), but for arrays.\nfunction findSubArray(needle, haystack) {\n    var needleLength = needle.length;\n    var limit = haystack.length - needleLength + 1;\n\n    loop:\n    for (var pos = 0; pos < limit; pos++) {\n        for (; pos < limit; pos++) {\n            for (var k = 0; k < needleLength; k++) {\n                if (haystack[pos + k] !== needle[k]) {\n                    continue loop;\n                }\n            }\n\n            return pos;\n        }\n    }\n\n    return -1;\n}\n\nfunction addStringToPool(s, pool) {\n    var offset = findSubArray(s, pool);\n    if (offset < 0) {\n        offset = pool.length;\n        var i = 0;\n        var len = s.length;\n        for (; i < len; ++i) {\n            pool.push(s[i]);\n        }\n\n    }\n\n    return offset;\n}\n\nfunction makeNameTable(names, ltag) {\n    var nameID;\n    var nameIDs = [];\n\n    var namesWithNumericKeys = {};\n    var nameTableIds = reverseDict(nameTableNames);\n    for (var key in names) {\n        var id = nameTableIds[key];\n        if (id === undefined) {\n            id = key;\n        }\n\n        nameID = parseInt(id);\n\n        if (isNaN(nameID)) {\n            throw new Error('Name table entry \"' + key + '\" does not exist, see nameTableNames for complete list.');\n        }\n\n        namesWithNumericKeys[nameID] = names[key];\n        nameIDs.push(nameID);\n    }\n\n    var macLanguageIds = reverseDict(macLanguages);\n    var windowsLanguageIds = reverseDict(windowsLanguages);\n\n    var nameRecords = [];\n    var stringPool = [];\n\n    for (var i = 0; i < nameIDs.length; i++) {\n        nameID = nameIDs[i];\n        var translations = namesWithNumericKeys[nameID];\n        for (var lang in translations) {\n            var text = translations[lang];\n\n            // For MacOS, we try to emit the name in the form that was introduced\n            // in the initial version of the TrueType spec (in the late 1980s).\n            // However, this can fail for various reasons: the requested BCP 47\n            // language code might not have an old-style Mac equivalent;\n            // we might not have a codec for the needed character encoding;\n            // or the name might contain characters that cannot be expressed\n            // in the old-style Macintosh encoding. In case of failure, we emit\n            // the name in a more modern fashion (Unicode encoding with BCP 47\n            // language tags) that is recognized by MacOS 10.5, released in 2009.\n            // If fonts were only read by operating systems, we could simply\n            // emit all names in the modern form; this would be much easier.\n            // However, there are many applications and libraries that read\n            // 'name' tables directly, and these will usually only recognize\n            // the ancient form (silently skipping the unrecognized names).\n            var macPlatform = 1;  // Macintosh\n            var macLanguage = macLanguageIds[lang];\n            var macScript = macLanguageToScript[macLanguage];\n            var macEncoding = getEncoding(macPlatform, macScript, macLanguage);\n            var macName = encode.MACSTRING(text, macEncoding);\n            if (macName === undefined) {\n                macPlatform = 0;  // Unicode\n                macLanguage = ltag.indexOf(lang);\n                if (macLanguage < 0) {\n                    macLanguage = ltag.length;\n                    ltag.push(lang);\n                }\n\n                macScript = 4;  // Unicode 2.0 and later\n                macName = encode.UTF16(text);\n            }\n\n            var macNameOffset = addStringToPool(macName, stringPool);\n            nameRecords.push(makeNameRecord(macPlatform, macScript, macLanguage,\n                                            nameID, macName.length, macNameOffset));\n\n            var winLanguage = windowsLanguageIds[lang];\n            if (winLanguage !== undefined) {\n                var winName = encode.UTF16(text);\n                var winNameOffset = addStringToPool(winName, stringPool);\n                nameRecords.push(makeNameRecord(3, 1, winLanguage,\n                                                nameID, winName.length, winNameOffset));\n            }\n        }\n    }\n\n    nameRecords.sort(function(a, b) {\n        return ((a.platformID - b.platformID) ||\n                (a.encodingID - b.encodingID) ||\n                (a.languageID - b.languageID) ||\n                (a.nameID - b.nameID));\n    });\n\n    var t = new table.Table('name', [\n        {name: 'format', type: 'USHORT', value: 0},\n        {name: 'count', type: 'USHORT', value: nameRecords.length},\n        {name: 'stringOffset', type: 'USHORT', value: 6 + nameRecords.length * 12}\n    ]);\n\n    for (var r = 0; r < nameRecords.length; r++) {\n        t.fields.push({name: 'record_' + r, type: 'RECORD', value: nameRecords[r]});\n    }\n\n    t.fields.push({name: 'strings', type: 'LITERAL', value: stringPool});\n    return t;\n}\n\nvar _name = { parse: parseNameTable, make: makeNameTable };\n\n// The `OS/2` table contains metrics required in OpenType fonts.\n\nvar unicodeRanges = [\n    {begin: 0x0000, end: 0x007F}, // Basic Latin\n    {begin: 0x0080, end: 0x00FF}, // Latin-1 Supplement\n    {begin: 0x0100, end: 0x017F}, // Latin Extended-A\n    {begin: 0x0180, end: 0x024F}, // Latin Extended-B\n    {begin: 0x0250, end: 0x02AF}, // IPA Extensions\n    {begin: 0x02B0, end: 0x02FF}, // Spacing Modifier Letters\n    {begin: 0x0300, end: 0x036F}, // Combining Diacritical Marks\n    {begin: 0x0370, end: 0x03FF}, // Greek and Coptic\n    {begin: 0x2C80, end: 0x2CFF}, // Coptic\n    {begin: 0x0400, end: 0x04FF}, // Cyrillic\n    {begin: 0x0530, end: 0x058F}, // Armenian\n    {begin: 0x0590, end: 0x05FF}, // Hebrew\n    {begin: 0xA500, end: 0xA63F}, // Vai\n    {begin: 0x0600, end: 0x06FF}, // Arabic\n    {begin: 0x07C0, end: 0x07FF}, // NKo\n    {begin: 0x0900, end: 0x097F}, // Devanagari\n    {begin: 0x0980, end: 0x09FF}, // Bengali\n    {begin: 0x0A00, end: 0x0A7F}, // Gurmukhi\n    {begin: 0x0A80, end: 0x0AFF}, // Gujarati\n    {begin: 0x0B00, end: 0x0B7F}, // Oriya\n    {begin: 0x0B80, end: 0x0BFF}, // Tamil\n    {begin: 0x0C00, end: 0x0C7F}, // Telugu\n    {begin: 0x0C80, end: 0x0CFF}, // Kannada\n    {begin: 0x0D00, end: 0x0D7F}, // Malayalam\n    {begin: 0x0E00, end: 0x0E7F}, // Thai\n    {begin: 0x0E80, end: 0x0EFF}, // Lao\n    {begin: 0x10A0, end: 0x10FF}, // Georgian\n    {begin: 0x1B00, end: 0x1B7F}, // Balinese\n    {begin: 0x1100, end: 0x11FF}, // Hangul Jamo\n    {begin: 0x1E00, end: 0x1EFF}, // Latin Extended Additional\n    {begin: 0x1F00, end: 0x1FFF}, // Greek Extended\n    {begin: 0x2000, end: 0x206F}, // General Punctuation\n    {begin: 0x2070, end: 0x209F}, // Superscripts And Subscripts\n    {begin: 0x20A0, end: 0x20CF}, // Currency Symbol\n    {begin: 0x20D0, end: 0x20FF}, // Combining Diacritical Marks For Symbols\n    {begin: 0x2100, end: 0x214F}, // Letterlike Symbols\n    {begin: 0x2150, end: 0x218F}, // Number Forms\n    {begin: 0x2190, end: 0x21FF}, // Arrows\n    {begin: 0x2200, end: 0x22FF}, // Mathematical Operators\n    {begin: 0x2300, end: 0x23FF}, // Miscellaneous Technical\n    {begin: 0x2400, end: 0x243F}, // Control Pictures\n    {begin: 0x2440, end: 0x245F}, // Optical Character Recognition\n    {begin: 0x2460, end: 0x24FF}, // Enclosed Alphanumerics\n    {begin: 0x2500, end: 0x257F}, // Box Drawing\n    {begin: 0x2580, end: 0x259F}, // Block Elements\n    {begin: 0x25A0, end: 0x25FF}, // Geometric Shapes\n    {begin: 0x2600, end: 0x26FF}, // Miscellaneous Symbols\n    {begin: 0x2700, end: 0x27BF}, // Dingbats\n    {begin: 0x3000, end: 0x303F}, // CJK Symbols And Punctuation\n    {begin: 0x3040, end: 0x309F}, // Hiragana\n    {begin: 0x30A0, end: 0x30FF}, // Katakana\n    {begin: 0x3100, end: 0x312F}, // Bopomofo\n    {begin: 0x3130, end: 0x318F}, // Hangul Compatibility Jamo\n    {begin: 0xA840, end: 0xA87F}, // Phags-pa\n    {begin: 0x3200, end: 0x32FF}, // Enclosed CJK Letters And Months\n    {begin: 0x3300, end: 0x33FF}, // CJK Compatibility\n    {begin: 0xAC00, end: 0xD7AF}, // Hangul Syllables\n    {begin: 0xD800, end: 0xDFFF}, // Non-Plane 0 *\n    {begin: 0x10900, end: 0x1091F}, // Phoenicia\n    {begin: 0x4E00, end: 0x9FFF}, // CJK Unified Ideographs\n    {begin: 0xE000, end: 0xF8FF}, // Private Use Area (plane 0)\n    {begin: 0x31C0, end: 0x31EF}, // CJK Strokes\n    {begin: 0xFB00, end: 0xFB4F}, // Alphabetic Presentation Forms\n    {begin: 0xFB50, end: 0xFDFF}, // Arabic Presentation Forms-A\n    {begin: 0xFE20, end: 0xFE2F}, // Combining Half Marks\n    {begin: 0xFE10, end: 0xFE1F}, // Vertical Forms\n    {begin: 0xFE50, end: 0xFE6F}, // Small Form Variants\n    {begin: 0xFE70, end: 0xFEFF}, // Arabic Presentation Forms-B\n    {begin: 0xFF00, end: 0xFFEF}, // Halfwidth And Fullwidth Forms\n    {begin: 0xFFF0, end: 0xFFFF}, // Specials\n    {begin: 0x0F00, end: 0x0FFF}, // Tibetan\n    {begin: 0x0700, end: 0x074F}, // Syriac\n    {begin: 0x0780, end: 0x07BF}, // Thaana\n    {begin: 0x0D80, end: 0x0DFF}, // Sinhala\n    {begin: 0x1000, end: 0x109F}, // Myanmar\n    {begin: 0x1200, end: 0x137F}, // Ethiopic\n    {begin: 0x13A0, end: 0x13FF}, // Cherokee\n    {begin: 0x1400, end: 0x167F}, // Unified Canadian Aboriginal Syllabics\n    {begin: 0x1680, end: 0x169F}, // Ogham\n    {begin: 0x16A0, end: 0x16FF}, // Runic\n    {begin: 0x1780, end: 0x17FF}, // Khmer\n    {begin: 0x1800, end: 0x18AF}, // Mongolian\n    {begin: 0x2800, end: 0x28FF}, // Braille Patterns\n    {begin: 0xA000, end: 0xA48F}, // Yi Syllables\n    {begin: 0x1700, end: 0x171F}, // Tagalog\n    {begin: 0x10300, end: 0x1032F}, // Old Italic\n    {begin: 0x10330, end: 0x1034F}, // Gothic\n    {begin: 0x10400, end: 0x1044F}, // Deseret\n    {begin: 0x1D000, end: 0x1D0FF}, // Byzantine Musical Symbols\n    {begin: 0x1D400, end: 0x1D7FF}, // Mathematical Alphanumeric Symbols\n    {begin: 0xFF000, end: 0xFFFFD}, // Private Use (plane 15)\n    {begin: 0xFE00, end: 0xFE0F}, // Variation Selectors\n    {begin: 0xE0000, end: 0xE007F}, // Tags\n    {begin: 0x1900, end: 0x194F}, // Limbu\n    {begin: 0x1950, end: 0x197F}, // Tai Le\n    {begin: 0x1980, end: 0x19DF}, // New Tai Lue\n    {begin: 0x1A00, end: 0x1A1F}, // Buginese\n    {begin: 0x2C00, end: 0x2C5F}, // Glagolitic\n    {begin: 0x2D30, end: 0x2D7F}, // Tifinagh\n    {begin: 0x4DC0, end: 0x4DFF}, // Yijing Hexagram Symbols\n    {begin: 0xA800, end: 0xA82F}, // Syloti Nagri\n    {begin: 0x10000, end: 0x1007F}, // Linear B Syllabary\n    {begin: 0x10140, end: 0x1018F}, // Ancient Greek Numbers\n    {begin: 0x10380, end: 0x1039F}, // Ugaritic\n    {begin: 0x103A0, end: 0x103DF}, // Old Persian\n    {begin: 0x10450, end: 0x1047F}, // Shavian\n    {begin: 0x10480, end: 0x104AF}, // Osmanya\n    {begin: 0x10800, end: 0x1083F}, // Cypriot Syllabary\n    {begin: 0x10A00, end: 0x10A5F}, // Kharoshthi\n    {begin: 0x1D300, end: 0x1D35F}, // Tai Xuan Jing Symbols\n    {begin: 0x12000, end: 0x123FF}, // Cuneiform\n    {begin: 0x1D360, end: 0x1D37F}, // Counting Rod Numerals\n    {begin: 0x1B80, end: 0x1BBF}, // Sundanese\n    {begin: 0x1C00, end: 0x1C4F}, // Lepcha\n    {begin: 0x1C50, end: 0x1C7F}, // Ol Chiki\n    {begin: 0xA880, end: 0xA8DF}, // Saurashtra\n    {begin: 0xA900, end: 0xA92F}, // Kayah Li\n    {begin: 0xA930, end: 0xA95F}, // Rejang\n    {begin: 0xAA00, end: 0xAA5F}, // Cham\n    {begin: 0x10190, end: 0x101CF}, // Ancient Symbols\n    {begin: 0x101D0, end: 0x101FF}, // Phaistos Disc\n    {begin: 0x102A0, end: 0x102DF}, // Carian\n    {begin: 0x1F030, end: 0x1F09F}  // Domino Tiles\n];\n\nfunction getUnicodeRange(unicode) {\n    for (var i = 0; i < unicodeRanges.length; i += 1) {\n        var range = unicodeRanges[i];\n        if (unicode >= range.begin && unicode < range.end) {\n            return i;\n        }\n    }\n\n    return -1;\n}\n\n// Parse the OS/2 and Windows metrics `OS/2` table\nfunction parseOS2Table(data, start) {\n    var os2 = {};\n    var p = new parse.Parser(data, start);\n    os2.version = p.parseUShort();\n    os2.xAvgCharWidth = p.parseShort();\n    os2.usWeightClass = p.parseUShort();\n    os2.usWidthClass = p.parseUShort();\n    os2.fsType = p.parseUShort();\n    os2.ySubscriptXSize = p.parseShort();\n    os2.ySubscriptYSize = p.parseShort();\n    os2.ySubscriptXOffset = p.parseShort();\n    os2.ySubscriptYOffset = p.parseShort();\n    os2.ySuperscriptXSize = p.parseShort();\n    os2.ySuperscriptYSize = p.parseShort();\n    os2.ySuperscriptXOffset = p.parseShort();\n    os2.ySuperscriptYOffset = p.parseShort();\n    os2.yStrikeoutSize = p.parseShort();\n    os2.yStrikeoutPosition = p.parseShort();\n    os2.sFamilyClass = p.parseShort();\n    os2.panose = [];\n    for (var i = 0; i < 10; i++) {\n        os2.panose[i] = p.parseByte();\n    }\n\n    os2.ulUnicodeRange1 = p.parseULong();\n    os2.ulUnicodeRange2 = p.parseULong();\n    os2.ulUnicodeRange3 = p.parseULong();\n    os2.ulUnicodeRange4 = p.parseULong();\n    os2.achVendID = String.fromCharCode(p.parseByte(), p.parseByte(), p.parseByte(), p.parseByte());\n    os2.fsSelection = p.parseUShort();\n    os2.usFirstCharIndex = p.parseUShort();\n    os2.usLastCharIndex = p.parseUShort();\n    os2.sTypoAscender = p.parseShort();\n    os2.sTypoDescender = p.parseShort();\n    os2.sTypoLineGap = p.parseShort();\n    os2.usWinAscent = p.parseUShort();\n    os2.usWinDescent = p.parseUShort();\n    if (os2.version >= 1) {\n        os2.ulCodePageRange1 = p.parseULong();\n        os2.ulCodePageRange2 = p.parseULong();\n    }\n\n    if (os2.version >= 2) {\n        os2.sxHeight = p.parseShort();\n        os2.sCapHeight = p.parseShort();\n        os2.usDefaultChar = p.parseUShort();\n        os2.usBreakChar = p.parseUShort();\n        os2.usMaxContent = p.parseUShort();\n    }\n\n    return os2;\n}\n\nfunction makeOS2Table(options) {\n    return new table.Table('OS/2', [\n        {name: 'version', type: 'USHORT', value: 0x0003},\n        {name: 'xAvgCharWidth', type: 'SHORT', value: 0},\n        {name: 'usWeightClass', type: 'USHORT', value: 0},\n        {name: 'usWidthClass', type: 'USHORT', value: 0},\n        {name: 'fsType', type: 'USHORT', value: 0},\n        {name: 'ySubscriptXSize', type: 'SHORT', value: 650},\n        {name: 'ySubscriptYSize', type: 'SHORT', value: 699},\n        {name: 'ySubscriptXOffset', type: 'SHORT', value: 0},\n        {name: 'ySubscriptYOffset', type: 'SHORT', value: 140},\n        {name: 'ySuperscriptXSize', type: 'SHORT', value: 650},\n        {name: 'ySuperscriptYSize', type: 'SHORT', value: 699},\n        {name: 'ySuperscriptXOffset', type: 'SHORT', value: 0},\n        {name: 'ySuperscriptYOffset', type: 'SHORT', value: 479},\n        {name: 'yStrikeoutSize', type: 'SHORT', value: 49},\n        {name: 'yStrikeoutPosition', type: 'SHORT', value: 258},\n        {name: 'sFamilyClass', type: 'SHORT', value: 0},\n        {name: 'bFamilyType', type: 'BYTE', value: 0},\n        {name: 'bSerifStyle', type: 'BYTE', value: 0},\n        {name: 'bWeight', type: 'BYTE', value: 0},\n        {name: 'bProportion', type: 'BYTE', value: 0},\n        {name: 'bContrast', type: 'BYTE', value: 0},\n        {name: 'bStrokeVariation', type: 'BYTE', value: 0},\n        {name: 'bArmStyle', type: 'BYTE', value: 0},\n        {name: 'bLetterform', type: 'BYTE', value: 0},\n        {name: 'bMidline', type: 'BYTE', value: 0},\n        {name: 'bXHeight', type: 'BYTE', value: 0},\n        {name: 'ulUnicodeRange1', type: 'ULONG', value: 0},\n        {name: 'ulUnicodeRange2', type: 'ULONG', value: 0},\n        {name: 'ulUnicodeRange3', type: 'ULONG', value: 0},\n        {name: 'ulUnicodeRange4', type: 'ULONG', value: 0},\n        {name: 'achVendID', type: 'CHARARRAY', value: 'XXXX'},\n        {name: 'fsSelection', type: 'USHORT', value: 0},\n        {name: 'usFirstCharIndex', type: 'USHORT', value: 0},\n        {name: 'usLastCharIndex', type: 'USHORT', value: 0},\n        {name: 'sTypoAscender', type: 'SHORT', value: 0},\n        {name: 'sTypoDescender', type: 'SHORT', value: 0},\n        {name: 'sTypoLineGap', type: 'SHORT', value: 0},\n        {name: 'usWinAscent', type: 'USHORT', value: 0},\n        {name: 'usWinDescent', type: 'USHORT', value: 0},\n        {name: 'ulCodePageRange1', type: 'ULONG', value: 0},\n        {name: 'ulCodePageRange2', type: 'ULONG', value: 0},\n        {name: 'sxHeight', type: 'SHORT', value: 0},\n        {name: 'sCapHeight', type: 'SHORT', value: 0},\n        {name: 'usDefaultChar', type: 'USHORT', value: 0},\n        {name: 'usBreakChar', type: 'USHORT', value: 0},\n        {name: 'usMaxContext', type: 'USHORT', value: 0}\n    ], options);\n}\n\nvar os2 = { parse: parseOS2Table, make: makeOS2Table, unicodeRanges: unicodeRanges, getUnicodeRange: getUnicodeRange };\n\n// The `post` table stores additional PostScript information, such as glyph names.\n\n// Parse the PostScript `post` table\nfunction parsePostTable(data, start) {\n    var post = {};\n    var p = new parse.Parser(data, start);\n    post.version = p.parseVersion();\n    post.italicAngle = p.parseFixed();\n    post.underlinePosition = p.parseShort();\n    post.underlineThickness = p.parseShort();\n    post.isFixedPitch = p.parseULong();\n    post.minMemType42 = p.parseULong();\n    post.maxMemType42 = p.parseULong();\n    post.minMemType1 = p.parseULong();\n    post.maxMemType1 = p.parseULong();\n    switch (post.version) {\n        case 1:\n            post.names = standardNames.slice();\n            break;\n        case 2:\n            post.numberOfGlyphs = p.parseUShort();\n            post.glyphNameIndex = new Array(post.numberOfGlyphs);\n            for (var i = 0; i < post.numberOfGlyphs; i++) {\n                post.glyphNameIndex[i] = p.parseUShort();\n            }\n\n            post.names = [];\n            for (var i$1 = 0; i$1 < post.numberOfGlyphs; i$1++) {\n                if (post.glyphNameIndex[i$1] >= standardNames.length) {\n                    var nameLength = p.parseChar();\n                    post.names.push(p.parseString(nameLength));\n                }\n            }\n\n            break;\n        case 2.5:\n            post.numberOfGlyphs = p.parseUShort();\n            post.offset = new Array(post.numberOfGlyphs);\n            for (var i$2 = 0; i$2 < post.numberOfGlyphs; i$2++) {\n                post.offset[i$2] = p.parseChar();\n            }\n\n            break;\n    }\n    return post;\n}\n\nfunction makePostTable() {\n    return new table.Table('post', [\n        {name: 'version', type: 'FIXED', value: 0x00030000},\n        {name: 'italicAngle', type: 'FIXED', value: 0},\n        {name: 'underlinePosition', type: 'FWORD', value: 0},\n        {name: 'underlineThickness', type: 'FWORD', value: 0},\n        {name: 'isFixedPitch', type: 'ULONG', value: 0},\n        {name: 'minMemType42', type: 'ULONG', value: 0},\n        {name: 'maxMemType42', type: 'ULONG', value: 0},\n        {name: 'minMemType1', type: 'ULONG', value: 0},\n        {name: 'maxMemType1', type: 'ULONG', value: 0}\n    ]);\n}\n\nvar post = { parse: parsePostTable, make: makePostTable };\n\n// The `GSUB` table contains ligatures, among other things.\n\nvar subtableParsers = new Array(9);         // subtableParsers[0] is unused\n\n// https://www.microsoft.com/typography/OTSPEC/GSUB.htm#SS\nsubtableParsers[1] = function parseLookup1() {\n    var start = this.offset + this.relativeOffset;\n    var substFormat = this.parseUShort();\n    if (substFormat === 1) {\n        return {\n            substFormat: 1,\n            coverage: this.parsePointer(Parser.coverage),\n            deltaGlyphId: this.parseUShort()\n        };\n    } else if (substFormat === 2) {\n        return {\n            substFormat: 2,\n            coverage: this.parsePointer(Parser.coverage),\n            substitute: this.parseOffset16List()\n        };\n    }\n    check.assert(false, '0x' + start.toString(16) + ': lookup type 1 format must be 1 or 2.');\n};\n\n// https://www.microsoft.com/typography/OTSPEC/GSUB.htm#MS\nsubtableParsers[2] = function parseLookup2() {\n    var substFormat = this.parseUShort();\n    check.argument(substFormat === 1, 'GSUB Multiple Substitution Subtable identifier-format must be 1');\n    return {\n        substFormat: substFormat,\n        coverage: this.parsePointer(Parser.coverage),\n        sequences: this.parseListOfLists()\n    };\n};\n\n// https://www.microsoft.com/typography/OTSPEC/GSUB.htm#AS\nsubtableParsers[3] = function parseLookup3() {\n    var substFormat = this.parseUShort();\n    check.argument(substFormat === 1, 'GSUB Alternate Substitution Subtable identifier-format must be 1');\n    return {\n        substFormat: substFormat,\n        coverage: this.parsePointer(Parser.coverage),\n        alternateSets: this.parseListOfLists()\n    };\n};\n\n// https://www.microsoft.com/typography/OTSPEC/GSUB.htm#LS\nsubtableParsers[4] = function parseLookup4() {\n    var substFormat = this.parseUShort();\n    check.argument(substFormat === 1, 'GSUB ligature table identifier-format must be 1');\n    return {\n        substFormat: substFormat,\n        coverage: this.parsePointer(Parser.coverage),\n        ligatureSets: this.parseListOfLists(function() {\n            return {\n                ligGlyph: this.parseUShort(),\n                components: this.parseUShortList(this.parseUShort() - 1)\n            };\n        })\n    };\n};\n\nvar lookupRecordDesc = {\n    sequenceIndex: Parser.uShort,\n    lookupListIndex: Parser.uShort\n};\n\n// https://www.microsoft.com/typography/OTSPEC/GSUB.htm#CSF\nsubtableParsers[5] = function parseLookup5() {\n    var start = this.offset + this.relativeOffset;\n    var substFormat = this.parseUShort();\n\n    if (substFormat === 1) {\n        return {\n            substFormat: substFormat,\n            coverage: this.parsePointer(Parser.coverage),\n            ruleSets: this.parseListOfLists(function() {\n                var glyphCount = this.parseUShort();\n                var substCount = this.parseUShort();\n                return {\n                    input: this.parseUShortList(glyphCount - 1),\n                    lookupRecords: this.parseRecordList(substCount, lookupRecordDesc)\n                };\n            })\n        };\n    } else if (substFormat === 2) {\n        return {\n            substFormat: substFormat,\n            coverage: this.parsePointer(Parser.coverage),\n            classDef: this.parsePointer(Parser.classDef),\n            classSets: this.parseListOfLists(function() {\n                var glyphCount = this.parseUShort();\n                var substCount = this.parseUShort();\n                return {\n                    classes: this.parseUShortList(glyphCount - 1),\n                    lookupRecords: this.parseRecordList(substCount, lookupRecordDesc)\n                };\n            })\n        };\n    } else if (substFormat === 3) {\n        var glyphCount = this.parseUShort();\n        var substCount = this.parseUShort();\n        return {\n            substFormat: substFormat,\n            coverages: this.parseList(glyphCount, Parser.pointer(Parser.coverage)),\n            lookupRecords: this.parseRecordList(substCount, lookupRecordDesc)\n        };\n    }\n    check.assert(false, '0x' + start.toString(16) + ': lookup type 5 format must be 1, 2 or 3.');\n};\n\n// https://www.microsoft.com/typography/OTSPEC/GSUB.htm#CC\nsubtableParsers[6] = function parseLookup6() {\n    var start = this.offset + this.relativeOffset;\n    var substFormat = this.parseUShort();\n    if (substFormat === 1) {\n        return {\n            substFormat: 1,\n            coverage: this.parsePointer(Parser.coverage),\n            chainRuleSets: this.parseListOfLists(function() {\n                return {\n                    backtrack: this.parseUShortList(),\n                    input: this.parseUShortList(this.parseShort() - 1),\n                    lookahead: this.parseUShortList(),\n                    lookupRecords: this.parseRecordList(lookupRecordDesc)\n                };\n            })\n        };\n    } else if (substFormat === 2) {\n        return {\n            substFormat: 2,\n            coverage: this.parsePointer(Parser.coverage),\n            backtrackClassDef: this.parsePointer(Parser.classDef),\n            inputClassDef: this.parsePointer(Parser.classDef),\n            lookaheadClassDef: this.parsePointer(Parser.classDef),\n            chainClassSet: this.parseListOfLists(function() {\n                return {\n                    backtrack: this.parseUShortList(),\n                    input: this.parseUShortList(this.parseShort() - 1),\n                    lookahead: this.parseUShortList(),\n                    lookupRecords: this.parseRecordList(lookupRecordDesc)\n                };\n            })\n        };\n    } else if (substFormat === 3) {\n        return {\n            substFormat: 3,\n            backtrackCoverage: this.parseList(Parser.pointer(Parser.coverage)),\n            inputCoverage: this.parseList(Parser.pointer(Parser.coverage)),\n            lookaheadCoverage: this.parseList(Parser.pointer(Parser.coverage)),\n            lookupRecords: this.parseRecordList(lookupRecordDesc)\n        };\n    }\n    check.assert(false, '0x' + start.toString(16) + ': lookup type 6 format must be 1, 2 or 3.');\n};\n\n// https://www.microsoft.com/typography/OTSPEC/GSUB.htm#ES\nsubtableParsers[7] = function parseLookup7() {\n    // Extension Substitution subtable\n    var substFormat = this.parseUShort();\n    check.argument(substFormat === 1, 'GSUB Extension Substitution subtable identifier-format must be 1');\n    var extensionLookupType = this.parseUShort();\n    var extensionParser = new Parser(this.data, this.offset + this.parseULong());\n    return {\n        substFormat: 1,\n        lookupType: extensionLookupType,\n        extension: subtableParsers[extensionLookupType].call(extensionParser)\n    };\n};\n\n// https://www.microsoft.com/typography/OTSPEC/GSUB.htm#RCCS\nsubtableParsers[8] = function parseLookup8() {\n    var substFormat = this.parseUShort();\n    check.argument(substFormat === 1, 'GSUB Reverse Chaining Contextual Single Substitution Subtable identifier-format must be 1');\n    return {\n        substFormat: substFormat,\n        coverage: this.parsePointer(Parser.coverage),\n        backtrackCoverage: this.parseList(Parser.pointer(Parser.coverage)),\n        lookaheadCoverage: this.parseList(Parser.pointer(Parser.coverage)),\n        substitutes: this.parseUShortList()\n    };\n};\n\n// https://www.microsoft.com/typography/OTSPEC/gsub.htm\nfunction parseGsubTable(data, start) {\n    start = start || 0;\n    var p = new Parser(data, start);\n    var tableVersion = p.parseVersion(1);\n    check.argument(tableVersion === 1 || tableVersion === 1.1, 'Unsupported GSUB table version.');\n    if (tableVersion === 1) {\n        return {\n            version: tableVersion,\n            scripts: p.parseScriptList(),\n            features: p.parseFeatureList(),\n            lookups: p.parseLookupList(subtableParsers)\n        };\n    } else {\n        return {\n            version: tableVersion,\n            scripts: p.parseScriptList(),\n            features: p.parseFeatureList(),\n            lookups: p.parseLookupList(subtableParsers),\n            variations: p.parseFeatureVariationsList()\n        };\n    }\n\n}\n\n// GSUB Writing //////////////////////////////////////////////\nvar subtableMakers = new Array(9);\n\nsubtableMakers[1] = function makeLookup1(subtable) {\n    if (subtable.substFormat === 1) {\n        return new table.Table('substitutionTable', [\n            {name: 'substFormat', type: 'USHORT', value: 1},\n            {name: 'coverage', type: 'TABLE', value: new table.Coverage(subtable.coverage)},\n            {name: 'deltaGlyphID', type: 'USHORT', value: subtable.deltaGlyphId}\n        ]);\n    } else {\n        return new table.Table('substitutionTable', [\n            {name: 'substFormat', type: 'USHORT', value: 2},\n            {name: 'coverage', type: 'TABLE', value: new table.Coverage(subtable.coverage)}\n        ].concat(table.ushortList('substitute', subtable.substitute)));\n    }\n};\n\nsubtableMakers[2] = function makeLookup2(subtable) {\n    check.assert(subtable.substFormat === 1, 'Lookup type 2 substFormat must be 1.');\n    return new table.Table('substitutionTable', [\n        {name: 'substFormat', type: 'USHORT', value: 1},\n        {name: 'coverage', type: 'TABLE', value: new table.Coverage(subtable.coverage)}\n    ].concat(table.tableList('seqSet', subtable.sequences, function(sequenceSet) {\n        return new table.Table('sequenceSetTable', table.ushortList('sequence', sequenceSet));\n    })));\n};\n\nsubtableMakers[3] = function makeLookup3(subtable) {\n    check.assert(subtable.substFormat === 1, 'Lookup type 3 substFormat must be 1.');\n    return new table.Table('substitutionTable', [\n        {name: 'substFormat', type: 'USHORT', value: 1},\n        {name: 'coverage', type: 'TABLE', value: new table.Coverage(subtable.coverage)}\n    ].concat(table.tableList('altSet', subtable.alternateSets, function(alternateSet) {\n        return new table.Table('alternateSetTable', table.ushortList('alternate', alternateSet));\n    })));\n};\n\nsubtableMakers[4] = function makeLookup4(subtable) {\n    check.assert(subtable.substFormat === 1, 'Lookup type 4 substFormat must be 1.');\n    return new table.Table('substitutionTable', [\n        {name: 'substFormat', type: 'USHORT', value: 1},\n        {name: 'coverage', type: 'TABLE', value: new table.Coverage(subtable.coverage)}\n    ].concat(table.tableList('ligSet', subtable.ligatureSets, function(ligatureSet) {\n        return new table.Table('ligatureSetTable', table.tableList('ligature', ligatureSet, function(ligature) {\n            return new table.Table('ligatureTable',\n                [{name: 'ligGlyph', type: 'USHORT', value: ligature.ligGlyph}]\n                .concat(table.ushortList('component', ligature.components, ligature.components.length + 1))\n            );\n        }));\n    })));\n};\n\nsubtableMakers[6] = function makeLookup6(subtable) {\n    if (subtable.substFormat === 1) {\n        var returnTable = new table.Table('chainContextTable', [\n            {name: 'substFormat', type: 'USHORT', value: subtable.substFormat},\n            {name: 'coverage', type: 'TABLE', value: new table.Coverage(subtable.coverage)}\n        ].concat(table.tableList('chainRuleSet', subtable.chainRuleSets, function(chainRuleSet) {\n            return new table.Table('chainRuleSetTable', table.tableList('chainRule', chainRuleSet, function(chainRule) {\n                var tableData = table.ushortList('backtrackGlyph', chainRule.backtrack, chainRule.backtrack.length)\n                    .concat(table.ushortList('inputGlyph', chainRule.input, chainRule.input.length + 1))\n                    .concat(table.ushortList('lookaheadGlyph', chainRule.lookahead, chainRule.lookahead.length))\n                    .concat(table.ushortList('substitution', [], chainRule.lookupRecords.length));\n\n                chainRule.lookupRecords.forEach(function (record, i) {\n                    tableData = tableData\n                        .concat({name: 'sequenceIndex' + i, type: 'USHORT', value: record.sequenceIndex})\n                        .concat({name: 'lookupListIndex' + i, type: 'USHORT', value: record.lookupListIndex});\n                });\n                return new table.Table('chainRuleTable', tableData);\n            }));\n        })));\n        return returnTable;\n    } else if (subtable.substFormat === 2) {\n        check.assert(false, 'lookup type 6 format 2 is not yet supported.');\n    } else if (subtable.substFormat === 3) {\n        var tableData = [\n            {name: 'substFormat', type: 'USHORT', value: subtable.substFormat} ];\n\n        tableData.push({name: 'backtrackGlyphCount', type: 'USHORT', value: subtable.backtrackCoverage.length});\n        subtable.backtrackCoverage.forEach(function (coverage, i) {\n            tableData.push({name: 'backtrackCoverage' + i, type: 'TABLE', value: new table.Coverage(coverage)});\n        });\n        tableData.push({name: 'inputGlyphCount', type: 'USHORT', value: subtable.inputCoverage.length});\n        subtable.inputCoverage.forEach(function (coverage, i) {\n            tableData.push({name: 'inputCoverage' + i, type: 'TABLE', value: new table.Coverage(coverage)});\n        });\n        tableData.push({name: 'lookaheadGlyphCount', type: 'USHORT', value: subtable.lookaheadCoverage.length});\n        subtable.lookaheadCoverage.forEach(function (coverage, i) {\n            tableData.push({name: 'lookaheadCoverage' + i, type: 'TABLE', value: new table.Coverage(coverage)});\n        });\n\n        tableData.push({name: 'substitutionCount', type: 'USHORT', value: subtable.lookupRecords.length});\n        subtable.lookupRecords.forEach(function (record, i) {\n            tableData = tableData\n                .concat({name: 'sequenceIndex' + i, type: 'USHORT', value: record.sequenceIndex})\n                .concat({name: 'lookupListIndex' + i, type: 'USHORT', value: record.lookupListIndex});\n        });\n\n        var returnTable$1 = new table.Table('chainContextTable', tableData);\n\n        return returnTable$1;\n    }\n\n    check.assert(false, 'lookup type 6 format must be 1, 2 or 3.');\n};\n\nfunction makeGsubTable(gsub) {\n    return new table.Table('GSUB', [\n        {name: 'version', type: 'ULONG', value: 0x10000},\n        {name: 'scripts', type: 'TABLE', value: new table.ScriptList(gsub.scripts)},\n        {name: 'features', type: 'TABLE', value: new table.FeatureList(gsub.features)},\n        {name: 'lookups', type: 'TABLE', value: new table.LookupList(gsub.lookups, subtableMakers)}\n    ]);\n}\n\nvar gsub = { parse: parseGsubTable, make: makeGsubTable };\n\n// The `GPOS` table contains kerning pairs, among other things.\n\n// Parse the metadata `meta` table.\n// https://developer.apple.com/fonts/TrueType-Reference-Manual/RM06/Chap6meta.html\nfunction parseMetaTable(data, start) {\n    var p = new parse.Parser(data, start);\n    var tableVersion = p.parseULong();\n    check.argument(tableVersion === 1, 'Unsupported META table version.');\n    p.parseULong(); // flags - currently unused and set to 0\n    p.parseULong(); // tableOffset\n    var numDataMaps = p.parseULong();\n\n    var tags = {};\n    for (var i = 0; i < numDataMaps; i++) {\n        var tag = p.parseTag();\n        var dataOffset = p.parseULong();\n        var dataLength = p.parseULong();\n        var text = decode.UTF8(data, start + dataOffset, dataLength);\n\n        tags[tag] = text;\n    }\n    return tags;\n}\n\nfunction makeMetaTable(tags) {\n    var numTags = Object.keys(tags).length;\n    var stringPool = '';\n    var stringPoolOffset = 16 + numTags * 12;\n\n    var result = new table.Table('meta', [\n        {name: 'version', type: 'ULONG', value: 1},\n        {name: 'flags', type: 'ULONG', value: 0},\n        {name: 'offset', type: 'ULONG', value: stringPoolOffset},\n        {name: 'numTags', type: 'ULONG', value: numTags}\n    ]);\n\n    for (var tag in tags) {\n        var pos = stringPool.length;\n        stringPool += tags[tag];\n\n        result.fields.push({name: 'tag ' + tag, type: 'TAG', value: tag});\n        result.fields.push({name: 'offset ' + tag, type: 'ULONG', value: stringPoolOffset + pos});\n        result.fields.push({name: 'length ' + tag, type: 'ULONG', value: tags[tag].length});\n    }\n\n    result.fields.push({name: 'stringPool', type: 'CHARARRAY', value: stringPool});\n\n    return result;\n}\n\nvar meta = { parse: parseMetaTable, make: makeMetaTable };\n\n// The `sfnt` wrapper provides organization for the tables in the font.\n\nfunction log2(v) {\n    return Math.log(v) / Math.log(2) | 0;\n}\n\nfunction computeCheckSum(bytes) {\n    while (bytes.length % 4 !== 0) {\n        bytes.push(0);\n    }\n\n    var sum = 0;\n    for (var i = 0; i < bytes.length; i += 4) {\n        sum += (bytes[i] << 24) +\n            (bytes[i + 1] << 16) +\n            (bytes[i + 2] << 8) +\n            (bytes[i + 3]);\n    }\n\n    sum %= Math.pow(2, 32);\n    return sum;\n}\n\nfunction makeTableRecord(tag, checkSum, offset, length) {\n    return new table.Record('Table Record', [\n        {name: 'tag', type: 'TAG', value: tag !== undefined ? tag : ''},\n        {name: 'checkSum', type: 'ULONG', value: checkSum !== undefined ? checkSum : 0},\n        {name: 'offset', type: 'ULONG', value: offset !== undefined ? offset : 0},\n        {name: 'length', type: 'ULONG', value: length !== undefined ? length : 0}\n    ]);\n}\n\nfunction makeSfntTable(tables) {\n    var sfnt = new table.Table('sfnt', [\n        {name: 'version', type: 'TAG', value: 'OTTO'},\n        {name: 'numTables', type: 'USHORT', value: 0},\n        {name: 'searchRange', type: 'USHORT', value: 0},\n        {name: 'entrySelector', type: 'USHORT', value: 0},\n        {name: 'rangeShift', type: 'USHORT', value: 0}\n    ]);\n    sfnt.tables = tables;\n    sfnt.numTables = tables.length;\n    var highestPowerOf2 = Math.pow(2, log2(sfnt.numTables));\n    sfnt.searchRange = 16 * highestPowerOf2;\n    sfnt.entrySelector = log2(highestPowerOf2);\n    sfnt.rangeShift = sfnt.numTables * 16 - sfnt.searchRange;\n\n    var recordFields = [];\n    var tableFields = [];\n\n    var offset = sfnt.sizeOf() + (makeTableRecord().sizeOf() * sfnt.numTables);\n    while (offset % 4 !== 0) {\n        offset += 1;\n        tableFields.push({name: 'padding', type: 'BYTE', value: 0});\n    }\n\n    for (var i = 0; i < tables.length; i += 1) {\n        var t = tables[i];\n        check.argument(t.tableName.length === 4, 'Table name' + t.tableName + ' is invalid.');\n        var tableLength = t.sizeOf();\n        var tableRecord = makeTableRecord(t.tableName, computeCheckSum(t.encode()), offset, tableLength);\n        recordFields.push({name: tableRecord.tag + ' Table Record', type: 'RECORD', value: tableRecord});\n        tableFields.push({name: t.tableName + ' table', type: 'RECORD', value: t});\n        offset += tableLength;\n        check.argument(!isNaN(offset), 'Something went wrong calculating the offset.');\n        while (offset % 4 !== 0) {\n            offset += 1;\n            tableFields.push({name: 'padding', type: 'BYTE', value: 0});\n        }\n    }\n\n    // Table records need to be sorted alphabetically.\n    recordFields.sort(function(r1, r2) {\n        if (r1.value.tag > r2.value.tag) {\n            return 1;\n        } else {\n            return -1;\n        }\n    });\n\n    sfnt.fields = sfnt.fields.concat(recordFields);\n    sfnt.fields = sfnt.fields.concat(tableFields);\n    return sfnt;\n}\n\n// Get the metrics for a character. If the string has more than one character\n// this function returns metrics for the first available character.\n// You can provide optional fallback metrics if no characters are available.\nfunction metricsForChar(font, chars, notFoundMetrics) {\n    for (var i = 0; i < chars.length; i += 1) {\n        var glyphIndex = font.charToGlyphIndex(chars[i]);\n        if (glyphIndex > 0) {\n            var glyph = font.glyphs.get(glyphIndex);\n            return glyph.getMetrics();\n        }\n    }\n\n    return notFoundMetrics;\n}\n\nfunction average(vs) {\n    var sum = 0;\n    for (var i = 0; i < vs.length; i += 1) {\n        sum += vs[i];\n    }\n\n    return sum / vs.length;\n}\n\n// Convert the font object to a SFNT data structure.\n// This structure contains all the necessary tables and metadata to create a binary OTF file.\nfunction fontToSfntTable(font) {\n    var xMins = [];\n    var yMins = [];\n    var xMaxs = [];\n    var yMaxs = [];\n    var advanceWidths = [];\n    var leftSideBearings = [];\n    var rightSideBearings = [];\n    var firstCharIndex;\n    var lastCharIndex = 0;\n    var ulUnicodeRange1 = 0;\n    var ulUnicodeRange2 = 0;\n    var ulUnicodeRange3 = 0;\n    var ulUnicodeRange4 = 0;\n\n    for (var i = 0; i < font.glyphs.length; i += 1) {\n        var glyph = font.glyphs.get(i);\n        var unicode = glyph.unicode | 0;\n\n        if (isNaN(glyph.advanceWidth)) {\n            throw new Error('Glyph ' + glyph.name + ' (' + i + '): advanceWidth is not a number.');\n        }\n\n        if (firstCharIndex > unicode || firstCharIndex === undefined) {\n            // ignore .notdef char\n            if (unicode > 0) {\n                firstCharIndex = unicode;\n            }\n        }\n\n        if (lastCharIndex < unicode) {\n            lastCharIndex = unicode;\n        }\n\n        var position = os2.getUnicodeRange(unicode);\n        if (position < 32) {\n            ulUnicodeRange1 |= 1 << position;\n        } else if (position < 64) {\n            ulUnicodeRange2 |= 1 << position - 32;\n        } else if (position < 96) {\n            ulUnicodeRange3 |= 1 << position - 64;\n        } else if (position < 123) {\n            ulUnicodeRange4 |= 1 << position - 96;\n        } else {\n            throw new Error('Unicode ranges bits > 123 are reserved for internal usage');\n        }\n        // Skip non-important characters.\n        if (glyph.name === '.notdef') { continue; }\n        var metrics = glyph.getMetrics();\n        xMins.push(metrics.xMin);\n        yMins.push(metrics.yMin);\n        xMaxs.push(metrics.xMax);\n        yMaxs.push(metrics.yMax);\n        leftSideBearings.push(metrics.leftSideBearing);\n        rightSideBearings.push(metrics.rightSideBearing);\n        advanceWidths.push(glyph.advanceWidth);\n    }\n\n    var globals = {\n        xMin: Math.min.apply(null, xMins),\n        yMin: Math.min.apply(null, yMins),\n        xMax: Math.max.apply(null, xMaxs),\n        yMax: Math.max.apply(null, yMaxs),\n        advanceWidthMax: Math.max.apply(null, advanceWidths),\n        advanceWidthAvg: average(advanceWidths),\n        minLeftSideBearing: Math.min.apply(null, leftSideBearings),\n        maxLeftSideBearing: Math.max.apply(null, leftSideBearings),\n        minRightSideBearing: Math.min.apply(null, rightSideBearings)\n    };\n    globals.ascender = font.ascender;\n    globals.descender = font.descender;\n\n    var headTable = head.make({\n        flags: 3, // 00000011 (baseline for font at y=0; left sidebearing point at x=0)\n        unitsPerEm: font.unitsPerEm,\n        xMin: globals.xMin,\n        yMin: globals.yMin,\n        xMax: globals.xMax,\n        yMax: globals.yMax,\n        lowestRecPPEM: 3,\n        createdTimestamp: font.createdTimestamp\n    });\n\n    var hheaTable = hhea.make({\n        ascender: globals.ascender,\n        descender: globals.descender,\n        advanceWidthMax: globals.advanceWidthMax,\n        minLeftSideBearing: globals.minLeftSideBearing,\n        minRightSideBearing: globals.minRightSideBearing,\n        xMaxExtent: globals.maxLeftSideBearing + (globals.xMax - globals.xMin),\n        numberOfHMetrics: font.glyphs.length\n    });\n\n    var maxpTable = maxp.make(font.glyphs.length);\n\n    var os2Table = os2.make(Object.assign({\n        xAvgCharWidth: Math.round(globals.advanceWidthAvg),\n        usFirstCharIndex: firstCharIndex,\n        usLastCharIndex: lastCharIndex,\n        ulUnicodeRange1: ulUnicodeRange1,\n        ulUnicodeRange2: ulUnicodeRange2,\n        ulUnicodeRange3: ulUnicodeRange3,\n        ulUnicodeRange4: ulUnicodeRange4,\n        // See http://typophile.com/node/13081 for more info on vertical metrics.\n        // We get metrics for typical characters (such as \"x\" for xHeight).\n        // We provide some fallback characters if characters are unavailable: their\n        // ordering was chosen experimentally.\n        sTypoAscender: globals.ascender,\n        sTypoDescender: globals.descender,\n        sTypoLineGap: 0,\n        usWinAscent: globals.yMax,\n        usWinDescent: Math.abs(globals.yMin),\n        ulCodePageRange1: 1, // FIXME: hard-code Latin 1 support for now\n        sxHeight: metricsForChar(font, 'xyvw', {yMax: Math.round(globals.ascender / 2)}).yMax,\n        sCapHeight: metricsForChar(font, 'HIKLEFJMNTZBDPRAGOQSUVWXY', globals).yMax,\n        usDefaultChar: font.hasChar(' ') ? 32 : 0, // Use space as the default character, if available.\n        usBreakChar: font.hasChar(' ') ? 32 : 0, // Use space as the break character, if available.\n    }, font.tables.os2));\n\n    var hmtxTable = hmtx.make(font.glyphs);\n    var cmapTable = cmap.make(font.glyphs);\n\n    var englishFamilyName = font.getEnglishName('fontFamily');\n    var englishStyleName = font.getEnglishName('fontSubfamily');\n    var englishFullName = englishFamilyName + ' ' + englishStyleName;\n    var postScriptName = font.getEnglishName('postScriptName');\n    if (!postScriptName) {\n        postScriptName = englishFamilyName.replace(/\\s/g, '') + '-' + englishStyleName;\n    }\n\n    var names = {};\n    for (var n in font.names) {\n        names[n] = font.names[n];\n    }\n\n    if (!names.uniqueID) {\n        names.uniqueID = {en: font.getEnglishName('manufacturer') + ':' + englishFullName};\n    }\n\n    if (!names.postScriptName) {\n        names.postScriptName = {en: postScriptName};\n    }\n\n    if (!names.preferredFamily) {\n        names.preferredFamily = font.names.fontFamily;\n    }\n\n    if (!names.preferredSubfamily) {\n        names.preferredSubfamily = font.names.fontSubfamily;\n    }\n\n    var languageTags = [];\n    var nameTable = _name.make(names, languageTags);\n    var ltagTable = (languageTags.length > 0 ? ltag.make(languageTags) : undefined);\n\n    var postTable = post.make();\n    var cffTable = cff.make(font.glyphs, {\n        version: font.getEnglishName('version'),\n        fullName: englishFullName,\n        familyName: englishFamilyName,\n        weightName: englishStyleName,\n        postScriptName: postScriptName,\n        unitsPerEm: font.unitsPerEm,\n        fontBBox: [0, globals.yMin, globals.ascender, globals.advanceWidthMax]\n    });\n\n    var metaTable = (font.metas && Object.keys(font.metas).length > 0) ? meta.make(font.metas) : undefined;\n\n    // The order does not matter because makeSfntTable() will sort them.\n    var tables = [headTable, hheaTable, maxpTable, os2Table, nameTable, cmapTable, postTable, cffTable, hmtxTable];\n    if (ltagTable) {\n        tables.push(ltagTable);\n    }\n    // Optional tables\n    if (font.tables.gsub) {\n        tables.push(gsub.make(font.tables.gsub));\n    }\n    if (metaTable) {\n        tables.push(metaTable);\n    }\n\n    var sfntTable = makeSfntTable(tables);\n\n    // Compute the font's checkSum and store it in head.checkSumAdjustment.\n    var bytes = sfntTable.encode();\n    var checkSum = computeCheckSum(bytes);\n    var tableFields = sfntTable.fields;\n    var checkSumAdjusted = false;\n    for (var i$1 = 0; i$1 < tableFields.length; i$1 += 1) {\n        if (tableFields[i$1].name === 'head table') {\n            tableFields[i$1].value.checkSumAdjustment = 0xB1B0AFBA - checkSum;\n            checkSumAdjusted = true;\n            break;\n        }\n    }\n\n    if (!checkSumAdjusted) {\n        throw new Error('Could not find head table with checkSum to adjust.');\n    }\n\n    return sfntTable;\n}\n\nvar sfnt = { make: makeSfntTable, fontToTable: fontToSfntTable, computeCheckSum: computeCheckSum };\n\n// The Layout object is the prototype of Substitution objects, and provides\n\nfunction searchTag(arr, tag) {\n    /* jshint bitwise: false */\n    var imin = 0;\n    var imax = arr.length - 1;\n    while (imin <= imax) {\n        var imid = (imin + imax) >>> 1;\n        var val = arr[imid].tag;\n        if (val === tag) {\n            return imid;\n        } else if (val < tag) {\n            imin = imid + 1;\n        } else { imax = imid - 1; }\n    }\n    // Not found: return -1-insertion point\n    return -imin - 1;\n}\n\nfunction binSearch(arr, value) {\n    /* jshint bitwise: false */\n    var imin = 0;\n    var imax = arr.length - 1;\n    while (imin <= imax) {\n        var imid = (imin + imax) >>> 1;\n        var val = arr[imid];\n        if (val === value) {\n            return imid;\n        } else if (val < value) {\n            imin = imid + 1;\n        } else { imax = imid - 1; }\n    }\n    // Not found: return -1-insertion point\n    return -imin - 1;\n}\n\n// binary search in a list of ranges (coverage, class definition)\nfunction searchRange(ranges, value) {\n    // jshint bitwise: false\n    var range;\n    var imin = 0;\n    var imax = ranges.length - 1;\n    while (imin <= imax) {\n        var imid = (imin + imax) >>> 1;\n        range = ranges[imid];\n        var start = range.start;\n        if (start === value) {\n            return range;\n        } else if (start < value) {\n            imin = imid + 1;\n        } else { imax = imid - 1; }\n    }\n    if (imin > 0) {\n        range = ranges[imin - 1];\n        if (value > range.end) { return 0; }\n        return range;\n    }\n}\n\n/**\n * @exports opentype.Layout\n * @class\n */\nfunction Layout(font, tableName) {\n    this.font = font;\n    this.tableName = tableName;\n}\n\nLayout.prototype = {\n\n    /**\n     * Binary search an object by \"tag\" property\n     * @instance\n     * @function searchTag\n     * @memberof opentype.Layout\n     * @param  {Array} arr\n     * @param  {string} tag\n     * @return {number}\n     */\n    searchTag: searchTag,\n\n    /**\n     * Binary search in a list of numbers\n     * @instance\n     * @function binSearch\n     * @memberof opentype.Layout\n     * @param  {Array} arr\n     * @param  {number} value\n     * @return {number}\n     */\n    binSearch: binSearch,\n\n    /**\n     * Get or create the Layout table (GSUB, GPOS etc).\n     * @param  {boolean} create - Whether to create a new one.\n     * @return {Object} The GSUB or GPOS table.\n     */\n    getTable: function(create) {\n        var layout = this.font.tables[this.tableName];\n        if (!layout && create) {\n            layout = this.font.tables[this.tableName] = this.createDefaultTable();\n        }\n        return layout;\n    },\n\n    /**\n     * Returns all scripts in the substitution table.\n     * @instance\n     * @return {Array}\n     */\n    getScriptNames: function() {\n        var layout = this.getTable();\n        if (!layout) { return []; }\n        return layout.scripts.map(function(script) {\n            return script.tag;\n        });\n    },\n\n    /**\n     * Returns the best bet for a script name.\n     * Returns 'DFLT' if it exists.\n     * If not, returns 'latn' if it exists.\n     * If neither exist, returns undefined.\n     */\n    getDefaultScriptName: function() {\n        var layout = this.getTable();\n        if (!layout) { return; }\n        var hasLatn = false;\n        for (var i = 0; i < layout.scripts.length; i++) {\n            var name = layout.scripts[i].tag;\n            if (name === 'DFLT') { return name; }\n            if (name === 'latn') { hasLatn = true; }\n        }\n        if (hasLatn) { return 'latn'; }\n    },\n\n    /**\n     * Returns all LangSysRecords in the given script.\n     * @instance\n     * @param {string} [script='DFLT']\n     * @param {boolean} create - forces the creation of this script table if it doesn't exist.\n     * @return {Object} An object with tag and script properties.\n     */\n    getScriptTable: function(script, create) {\n        var layout = this.getTable(create);\n        if (layout) {\n            script = script || 'DFLT';\n            var scripts = layout.scripts;\n            var pos = searchTag(layout.scripts, script);\n            if (pos >= 0) {\n                return scripts[pos].script;\n            } else if (create) {\n                var scr = {\n                    tag: script,\n                    script: {\n                        defaultLangSys: {reserved: 0, reqFeatureIndex: 0xffff, featureIndexes: []},\n                        langSysRecords: []\n                    }\n                };\n                scripts.splice(-1 - pos, 0, scr);\n                return scr.script;\n            }\n        }\n    },\n\n    /**\n     * Returns a language system table\n     * @instance\n     * @param {string} [script='DFLT']\n     * @param {string} [language='dlft']\n     * @param {boolean} create - forces the creation of this langSysTable if it doesn't exist.\n     * @return {Object}\n     */\n    getLangSysTable: function(script, language, create) {\n        var scriptTable = this.getScriptTable(script, create);\n        if (scriptTable) {\n            if (!language || language === 'dflt' || language === 'DFLT') {\n                return scriptTable.defaultLangSys;\n            }\n            var pos = searchTag(scriptTable.langSysRecords, language);\n            if (pos >= 0) {\n                return scriptTable.langSysRecords[pos].langSys;\n            } else if (create) {\n                var langSysRecord = {\n                    tag: language,\n                    langSys: {reserved: 0, reqFeatureIndex: 0xffff, featureIndexes: []}\n                };\n                scriptTable.langSysRecords.splice(-1 - pos, 0, langSysRecord);\n                return langSysRecord.langSys;\n            }\n        }\n    },\n\n    /**\n     * Get a specific feature table.\n     * @instance\n     * @param {string} [script='DFLT']\n     * @param {string} [language='dlft']\n     * @param {string} feature - One of the codes listed at https://www.microsoft.com/typography/OTSPEC/featurelist.htm\n     * @param {boolean} create - forces the creation of the feature table if it doesn't exist.\n     * @return {Object}\n     */\n    getFeatureTable: function(script, language, feature, create) {\n        var langSysTable = this.getLangSysTable(script, language, create);\n        if (langSysTable) {\n            var featureRecord;\n            var featIndexes = langSysTable.featureIndexes;\n            var allFeatures = this.font.tables[this.tableName].features;\n            // The FeatureIndex array of indices is in arbitrary order,\n            // even if allFeatures is sorted alphabetically by feature tag.\n            for (var i = 0; i < featIndexes.length; i++) {\n                featureRecord = allFeatures[featIndexes[i]];\n                if (featureRecord.tag === feature) {\n                    return featureRecord.feature;\n                }\n            }\n            if (create) {\n                var index = allFeatures.length;\n                // Automatic ordering of features would require to shift feature indexes in the script list.\n                check.assert(index === 0 || feature >= allFeatures[index - 1].tag, 'Features must be added in alphabetical order.');\n                featureRecord = {\n                    tag: feature,\n                    feature: { params: 0, lookupListIndexes: [] }\n                };\n                allFeatures.push(featureRecord);\n                featIndexes.push(index);\n                return featureRecord.feature;\n            }\n        }\n    },\n\n    /**\n     * Get the lookup tables of a given type for a script/language/feature.\n     * @instance\n     * @param {string} [script='DFLT']\n     * @param {string} [language='dlft']\n     * @param {string} feature - 4-letter feature code\n     * @param {number} lookupType - 1 to 9\n     * @param {boolean} create - forces the creation of the lookup table if it doesn't exist, with no subtables.\n     * @return {Object[]}\n     */\n    getLookupTables: function(script, language, feature, lookupType, create) {\n        var featureTable = this.getFeatureTable(script, language, feature, create);\n        var tables = [];\n        if (featureTable) {\n            var lookupTable;\n            var lookupListIndexes = featureTable.lookupListIndexes;\n            var allLookups = this.font.tables[this.tableName].lookups;\n            // lookupListIndexes are in no particular order, so use naive search.\n            for (var i = 0; i < lookupListIndexes.length; i++) {\n                lookupTable = allLookups[lookupListIndexes[i]];\n                if (lookupTable.lookupType === lookupType) {\n                    tables.push(lookupTable);\n                }\n            }\n            if (tables.length === 0 && create) {\n                lookupTable = {\n                    lookupType: lookupType,\n                    lookupFlag: 0,\n                    subtables: [],\n                    markFilteringSet: undefined\n                };\n                var index = allLookups.length;\n                allLookups.push(lookupTable);\n                lookupListIndexes.push(index);\n                return [lookupTable];\n            }\n        }\n        return tables;\n    },\n\n    /**\n     * Find a glyph in a class definition table\n     * https://docs.microsoft.com/en-us/typography/opentype/spec/chapter2#class-definition-table\n     * @param {object} classDefTable - an OpenType Layout class definition table\n     * @param {number} glyphIndex - the index of the glyph to find\n     * @returns {number} -1 if not found\n     */\n    getGlyphClass: function(classDefTable, glyphIndex) {\n        switch (classDefTable.format) {\n            case 1:\n                if (classDefTable.startGlyph <= glyphIndex && glyphIndex < classDefTable.startGlyph + classDefTable.classes.length) {\n                    return classDefTable.classes[glyphIndex - classDefTable.startGlyph];\n                }\n                return 0;\n            case 2:\n                var range = searchRange(classDefTable.ranges, glyphIndex);\n                return range ? range.classId : 0;\n        }\n    },\n\n    /**\n     * Find a glyph in a coverage table\n     * https://docs.microsoft.com/en-us/typography/opentype/spec/chapter2#coverage-table\n     * @param {object} coverageTable - an OpenType Layout coverage table\n     * @param {number} glyphIndex - the index of the glyph to find\n     * @returns {number} -1 if not found\n     */\n    getCoverageIndex: function(coverageTable, glyphIndex) {\n        switch (coverageTable.format) {\n            case 1:\n                var index = binSearch(coverageTable.glyphs, glyphIndex);\n                return index >= 0 ? index : -1;\n            case 2:\n                var range = searchRange(coverageTable.ranges, glyphIndex);\n                return range ? range.index + glyphIndex - range.start : -1;\n        }\n    },\n\n    /**\n     * Returns the list of glyph indexes of a coverage table.\n     * Format 1: the list is stored raw\n     * Format 2: compact list as range records.\n     * @instance\n     * @param  {Object} coverageTable\n     * @return {Array}\n     */\n    expandCoverage: function(coverageTable) {\n        if (coverageTable.format === 1) {\n            return coverageTable.glyphs;\n        } else {\n            var glyphs = [];\n            var ranges = coverageTable.ranges;\n            for (var i = 0; i < ranges.length; i++) {\n                var range = ranges[i];\n                var start = range.start;\n                var end = range.end;\n                for (var j = start; j <= end; j++) {\n                    glyphs.push(j);\n                }\n            }\n            return glyphs;\n        }\n    }\n\n};\n\n// The Position object provides utility methods to manipulate\n\n/**\n * @exports opentype.Position\n * @class\n * @extends opentype.Layout\n * @param {opentype.Font}\n * @constructor\n */\nfunction Position(font) {\n    Layout.call(this, font, 'gpos');\n}\n\nPosition.prototype = Layout.prototype;\n\n/**\n * Init some data for faster and easier access later.\n */\nPosition.prototype.init = function() {\n    var script = this.getDefaultScriptName();\n    this.defaultKerningTables = this.getKerningTables(script);\n};\n\n/**\n * Find a glyph pair in a list of lookup tables of type 2 and retrieve the xAdvance kerning value.\n *\n * @param {integer} leftIndex - left glyph index\n * @param {integer} rightIndex - right glyph index\n * @returns {integer}\n */\nPosition.prototype.getKerningValue = function(kerningLookups, leftIndex, rightIndex) {\n    for (var i = 0; i < kerningLookups.length; i++) {\n        var subtables = kerningLookups[i].subtables;\n        for (var j = 0; j < subtables.length; j++) {\n            var subtable = subtables[j];\n            var covIndex = this.getCoverageIndex(subtable.coverage, leftIndex);\n            if (covIndex < 0) { continue; }\n            switch (subtable.posFormat) {\n                case 1:\n                    // Search Pair Adjustment Positioning Format 1\n                    var pairSet = subtable.pairSets[covIndex];\n                    for (var k = 0; k < pairSet.length; k++) {\n                        var pair = pairSet[k];\n                        if (pair.secondGlyph === rightIndex) {\n                            return pair.value1 && pair.value1.xAdvance || 0;\n                        }\n                    }\n                    break;      // left glyph found, not right glyph - try next subtable\n                case 2:\n                    // Search Pair Adjustment Positioning Format 2\n                    var class1 = this.getGlyphClass(subtable.classDef1, leftIndex);\n                    var class2 = this.getGlyphClass(subtable.classDef2, rightIndex);\n                    var pair$1 = subtable.classRecords[class1][class2];\n                    return pair$1.value1 && pair$1.value1.xAdvance || 0;\n            }\n        }\n    }\n    return 0;\n};\n\n/**\n * List all kerning lookup tables.\n *\n * @param {string} [script='DFLT'] - use font.position.getDefaultScriptName() for a better default value\n * @param {string} [language='dflt']\n * @return {object[]} The list of kerning lookup tables (may be empty), or undefined if there is no GPOS table (and we should use the kern table)\n */\nPosition.prototype.getKerningTables = function(script, language) {\n    if (this.font.tables.gpos) {\n        return this.getLookupTables(script, language, 'kern', 2);\n    }\n};\n\n// The Substitution object provides utility methods to manipulate\n\n/**\n * @exports opentype.Substitution\n * @class\n * @extends opentype.Layout\n * @param {opentype.Font}\n * @constructor\n */\nfunction Substitution(font) {\n    Layout.call(this, font, 'gsub');\n}\n\n// Check if 2 arrays of primitives are equal.\nfunction arraysEqual(ar1, ar2) {\n    var n = ar1.length;\n    if (n !== ar2.length) { return false; }\n    for (var i = 0; i < n; i++) {\n        if (ar1[i] !== ar2[i]) { return false; }\n    }\n    return true;\n}\n\n// Find the first subtable of a lookup table in a particular format.\nfunction getSubstFormat(lookupTable, format, defaultSubtable) {\n    var subtables = lookupTable.subtables;\n    for (var i = 0; i < subtables.length; i++) {\n        var subtable = subtables[i];\n        if (subtable.substFormat === format) {\n            return subtable;\n        }\n    }\n    if (defaultSubtable) {\n        subtables.push(defaultSubtable);\n        return defaultSubtable;\n    }\n    return undefined;\n}\n\nSubstitution.prototype = Layout.prototype;\n\n/**\n * Create a default GSUB table.\n * @return {Object} gsub - The GSUB table.\n */\nSubstitution.prototype.createDefaultTable = function() {\n    // Generate a default empty GSUB table with just a DFLT script and dflt lang sys.\n    return {\n        version: 1,\n        scripts: [{\n            tag: 'DFLT',\n            script: {\n                defaultLangSys: { reserved: 0, reqFeatureIndex: 0xffff, featureIndexes: [] },\n                langSysRecords: []\n            }\n        }],\n        features: [],\n        lookups: []\n    };\n};\n\n/**\n * List all single substitutions (lookup type 1) for a given script, language, and feature.\n * @param {string} [script='DFLT']\n * @param {string} [language='dflt']\n * @param {string} feature - 4-character feature name ('aalt', 'salt', 'ss01'...)\n * @return {Array} substitutions - The list of substitutions.\n */\nSubstitution.prototype.getSingle = function(feature, script, language) {\n    var substitutions = [];\n    var lookupTables = this.getLookupTables(script, language, feature, 1);\n    for (var idx = 0; idx < lookupTables.length; idx++) {\n        var subtables = lookupTables[idx].subtables;\n        for (var i = 0; i < subtables.length; i++) {\n            var subtable = subtables[i];\n            var glyphs = this.expandCoverage(subtable.coverage);\n            var j = (void 0);\n            if (subtable.substFormat === 1) {\n                var delta = subtable.deltaGlyphId;\n                for (j = 0; j < glyphs.length; j++) {\n                    var glyph = glyphs[j];\n                    substitutions.push({ sub: glyph, by: glyph + delta });\n                }\n            } else {\n                var substitute = subtable.substitute;\n                for (j = 0; j < glyphs.length; j++) {\n                    substitutions.push({ sub: glyphs[j], by: substitute[j] });\n                }\n            }\n        }\n    }\n    return substitutions;\n};\n\n/**\n * List all multiple substitutions (lookup type 2) for a given script, language, and feature.\n * @param {string} [script='DFLT']\n * @param {string} [language='dflt']\n * @param {string} feature - 4-character feature name ('ccmp', 'stch')\n * @return {Array} substitutions - The list of substitutions.\n */\nSubstitution.prototype.getMultiple = function(feature, script, language) {\n    var substitutions = [];\n    var lookupTables = this.getLookupTables(script, language, feature, 2);\n    for (var idx = 0; idx < lookupTables.length; idx++) {\n        var subtables = lookupTables[idx].subtables;\n        for (var i = 0; i < subtables.length; i++) {\n            var subtable = subtables[i];\n            var glyphs = this.expandCoverage(subtable.coverage);\n            var j = (void 0);\n\n            for (j = 0; j < glyphs.length; j++) {\n                var glyph = glyphs[j];\n                var replacements = subtable.sequences[j];\n                substitutions.push({ sub: glyph, by: replacements });\n            }\n        }\n    }\n    return substitutions;\n};\n\n/**\n * List all alternates (lookup type 3) for a given script, language, and feature.\n * @param {string} [script='DFLT']\n * @param {string} [language='dflt']\n * @param {string} feature - 4-character feature name ('aalt', 'salt'...)\n * @return {Array} alternates - The list of alternates\n */\nSubstitution.prototype.getAlternates = function(feature, script, language) {\n    var alternates = [];\n    var lookupTables = this.getLookupTables(script, language, feature, 3);\n    for (var idx = 0; idx < lookupTables.length; idx++) {\n        var subtables = lookupTables[idx].subtables;\n        for (var i = 0; i < subtables.length; i++) {\n            var subtable = subtables[i];\n            var glyphs = this.expandCoverage(subtable.coverage);\n            var alternateSets = subtable.alternateSets;\n            for (var j = 0; j < glyphs.length; j++) {\n                alternates.push({ sub: glyphs[j], by: alternateSets[j] });\n            }\n        }\n    }\n    return alternates;\n};\n\n/**\n * List all ligatures (lookup type 4) for a given script, language, and feature.\n * The result is an array of ligature objects like { sub: [ids], by: id }\n * @param {string} feature - 4-letter feature name ('liga', 'rlig', 'dlig'...)\n * @param {string} [script='DFLT']\n * @param {string} [language='dflt']\n * @return {Array} ligatures - The list of ligatures.\n */\nSubstitution.prototype.getLigatures = function(feature, script, language) {\n    var ligatures = [];\n    var lookupTables = this.getLookupTables(script, language, feature, 4);\n    for (var idx = 0; idx < lookupTables.length; idx++) {\n        var subtables = lookupTables[idx].subtables;\n        for (var i = 0; i < subtables.length; i++) {\n            var subtable = subtables[i];\n            var glyphs = this.expandCoverage(subtable.coverage);\n            var ligatureSets = subtable.ligatureSets;\n            for (var j = 0; j < glyphs.length; j++) {\n                var startGlyph = glyphs[j];\n                var ligSet = ligatureSets[j];\n                for (var k = 0; k < ligSet.length; k++) {\n                    var lig = ligSet[k];\n                    ligatures.push({\n                        sub: [startGlyph].concat(lig.components),\n                        by: lig.ligGlyph\n                    });\n                }\n            }\n        }\n    }\n    return ligatures;\n};\n\n/**\n * Add or modify a single substitution (lookup type 1)\n * Format 2, more flexible, is always used.\n * @param {string} feature - 4-letter feature name ('liga', 'rlig', 'dlig'...)\n * @param {Object} substitution - { sub: id, by: id } (format 1 is not supported)\n * @param {string} [script='DFLT']\n * @param {string} [language='dflt']\n */\nSubstitution.prototype.addSingle = function(feature, substitution, script, language) {\n    var lookupTable = this.getLookupTables(script, language, feature, 1, true)[0];\n    var subtable = getSubstFormat(lookupTable, 2, {                // lookup type 1 subtable, format 2, coverage format 1\n        substFormat: 2,\n        coverage: {format: 1, glyphs: []},\n        substitute: []\n    });\n    check.assert(subtable.coverage.format === 1, 'Single: unable to modify coverage table format ' + subtable.coverage.format);\n    var coverageGlyph = substitution.sub;\n    var pos = this.binSearch(subtable.coverage.glyphs, coverageGlyph);\n    if (pos < 0) {\n        pos = -1 - pos;\n        subtable.coverage.glyphs.splice(pos, 0, coverageGlyph);\n        subtable.substitute.splice(pos, 0, 0);\n    }\n    subtable.substitute[pos] = substitution.by;\n};\n\n/**\n * Add or modify a multiple substitution (lookup type 2)\n * @param {string} feature - 4-letter feature name ('ccmp', 'stch')\n * @param {Object} substitution - { sub: id, by: [id] } for format 2.\n * @param {string} [script='DFLT']\n * @param {string} [language='dflt']\n */\nSubstitution.prototype.addMultiple = function(feature, substitution, script, language) {\n    check.assert(substitution.by instanceof Array && substitution.by.length > 1, 'Multiple: \"by\" must be an array of two or more ids');\n    var lookupTable = this.getLookupTables(script, language, feature, 2, true)[0];\n    var subtable = getSubstFormat(lookupTable, 1, {                // lookup type 2 subtable, format 1, coverage format 1\n        substFormat: 1,\n        coverage: {format: 1, glyphs: []},\n        sequences: []\n    });\n    check.assert(subtable.coverage.format === 1, 'Multiple: unable to modify coverage table format ' + subtable.coverage.format);\n    var coverageGlyph = substitution.sub;\n    var pos = this.binSearch(subtable.coverage.glyphs, coverageGlyph);\n    if (pos < 0) {\n        pos = -1 - pos;\n        subtable.coverage.glyphs.splice(pos, 0, coverageGlyph);\n        subtable.sequences.splice(pos, 0, 0);\n    }\n    subtable.sequences[pos] = substitution.by;\n};\n\n/**\n * Add or modify an alternate substitution (lookup type 3)\n * @param {string} feature - 4-letter feature name ('liga', 'rlig', 'dlig'...)\n * @param {Object} substitution - { sub: id, by: [ids] }\n * @param {string} [script='DFLT']\n * @param {string} [language='dflt']\n */\nSubstitution.prototype.addAlternate = function(feature, substitution, script, language) {\n    var lookupTable = this.getLookupTables(script, language, feature, 3, true)[0];\n    var subtable = getSubstFormat(lookupTable, 1, {                // lookup type 3 subtable, format 1, coverage format 1\n        substFormat: 1,\n        coverage: {format: 1, glyphs: []},\n        alternateSets: []\n    });\n    check.assert(subtable.coverage.format === 1, 'Alternate: unable to modify coverage table format ' + subtable.coverage.format);\n    var coverageGlyph = substitution.sub;\n    var pos = this.binSearch(subtable.coverage.glyphs, coverageGlyph);\n    if (pos < 0) {\n        pos = -1 - pos;\n        subtable.coverage.glyphs.splice(pos, 0, coverageGlyph);\n        subtable.alternateSets.splice(pos, 0, 0);\n    }\n    subtable.alternateSets[pos] = substitution.by;\n};\n\n/**\n * Add a ligature (lookup type 4)\n * Ligatures with more components must be stored ahead of those with fewer components in order to be found\n * @param {string} feature - 4-letter feature name ('liga', 'rlig', 'dlig'...)\n * @param {Object} ligature - { sub: [ids], by: id }\n * @param {string} [script='DFLT']\n * @param {string} [language='dflt']\n */\nSubstitution.prototype.addLigature = function(feature, ligature, script, language) {\n    var lookupTable = this.getLookupTables(script, language, feature, 4, true)[0];\n    var subtable = lookupTable.subtables[0];\n    if (!subtable) {\n        subtable = {                // lookup type 4 subtable, format 1, coverage format 1\n            substFormat: 1,\n            coverage: { format: 1, glyphs: [] },\n            ligatureSets: []\n        };\n        lookupTable.subtables[0] = subtable;\n    }\n    check.assert(subtable.coverage.format === 1, 'Ligature: unable to modify coverage table format ' + subtable.coverage.format);\n    var coverageGlyph = ligature.sub[0];\n    var ligComponents = ligature.sub.slice(1);\n    var ligatureTable = {\n        ligGlyph: ligature.by,\n        components: ligComponents\n    };\n    var pos = this.binSearch(subtable.coverage.glyphs, coverageGlyph);\n    if (pos >= 0) {\n        // ligatureSet already exists\n        var ligatureSet = subtable.ligatureSets[pos];\n        for (var i = 0; i < ligatureSet.length; i++) {\n            // If ligature already exists, return.\n            if (arraysEqual(ligatureSet[i].components, ligComponents)) {\n                return;\n            }\n        }\n        // ligature does not exist: add it.\n        ligatureSet.push(ligatureTable);\n    } else {\n        // Create a new ligatureSet and add coverage for the first glyph.\n        pos = -1 - pos;\n        subtable.coverage.glyphs.splice(pos, 0, coverageGlyph);\n        subtable.ligatureSets.splice(pos, 0, [ligatureTable]);\n    }\n};\n\n/**\n * List all feature data for a given script and language.\n * @param {string} feature - 4-letter feature name\n * @param {string} [script='DFLT']\n * @param {string} [language='dflt']\n * @return {Array} substitutions - The list of substitutions.\n */\nSubstitution.prototype.getFeature = function(feature, script, language) {\n    if (/ss\\d\\d/.test(feature)) {\n        // ss01 - ss20\n        return this.getSingle(feature, script, language);\n    }\n    switch (feature) {\n        case 'aalt':\n        case 'salt':\n            return this.getSingle(feature, script, language)\n                    .concat(this.getAlternates(feature, script, language));\n        case 'dlig':\n        case 'liga':\n        case 'rlig':\n            return this.getLigatures(feature, script, language);\n        case 'ccmp':\n            return this.getMultiple(feature, script, language)\n                .concat(this.getLigatures(feature, script, language));\n        case 'stch':\n            return this.getMultiple(feature, script, language);\n    }\n    return undefined;\n};\n\n/**\n * Add a substitution to a feature for a given script and language.\n * @param {string} feature - 4-letter feature name\n * @param {Object} sub - the substitution to add (an object like { sub: id or [ids], by: id or [ids] })\n * @param {string} [script='DFLT']\n * @param {string} [language='dflt']\n */\nSubstitution.prototype.add = function(feature, sub, script, language) {\n    if (/ss\\d\\d/.test(feature)) {\n        // ss01 - ss20\n        return this.addSingle(feature, sub, script, language);\n    }\n    switch (feature) {\n        case 'aalt':\n        case 'salt':\n            if (typeof sub.by === 'number') {\n                return this.addSingle(feature, sub, script, language);\n            }\n            return this.addAlternate(feature, sub, script, language);\n        case 'dlig':\n        case 'liga':\n        case 'rlig':\n            return this.addLigature(feature, sub, script, language);\n        case 'ccmp':\n            if (sub.by instanceof Array) {\n                return this.addMultiple(feature, sub, script, language);\n            }\n            return this.addLigature(feature, sub, script, language);\n    }\n    return undefined;\n};\n\nfunction isBrowser() {\n    return typeof window !== 'undefined';\n}\n\nfunction nodeBufferToArrayBuffer(buffer) {\n    var ab = new ArrayBuffer(buffer.length);\n    var view = new Uint8Array(ab);\n    for (var i = 0; i < buffer.length; ++i) {\n        view[i] = buffer[i];\n    }\n\n    return ab;\n}\n\nfunction arrayBufferToNodeBuffer(ab) {\n    var buffer = new Buffer(ab.byteLength);\n    var view = new Uint8Array(ab);\n    for (var i = 0; i < buffer.length; ++i) {\n        buffer[i] = view[i];\n    }\n\n    return buffer;\n}\n\nfunction checkArgument(expression, message) {\n    if (!expression) {\n        throw message;\n    }\n}\n\n// The `glyf` table describes the glyphs in TrueType outline format.\n\n// Parse the coordinate data for a glyph.\nfunction parseGlyphCoordinate(p, flag, previousValue, shortVectorBitMask, sameBitMask) {\n    var v;\n    if ((flag & shortVectorBitMask) > 0) {\n        // The coordinate is 1 byte long.\n        v = p.parseByte();\n        // The `same` bit is re-used for short values to signify the sign of the value.\n        if ((flag & sameBitMask) === 0) {\n            v = -v;\n        }\n\n        v = previousValue + v;\n    } else {\n        //  The coordinate is 2 bytes long.\n        // If the `same` bit is set, the coordinate is the same as the previous coordinate.\n        if ((flag & sameBitMask) > 0) {\n            v = previousValue;\n        } else {\n            // Parse the coordinate as a signed 16-bit delta value.\n            v = previousValue + p.parseShort();\n        }\n    }\n\n    return v;\n}\n\n// Parse a TrueType glyph.\nfunction parseGlyph(glyph, data, start) {\n    var p = new parse.Parser(data, start);\n    glyph.numberOfContours = p.parseShort();\n    glyph._xMin = p.parseShort();\n    glyph._yMin = p.parseShort();\n    glyph._xMax = p.parseShort();\n    glyph._yMax = p.parseShort();\n    var flags;\n    var flag;\n\n    if (glyph.numberOfContours > 0) {\n        // This glyph is not a composite.\n        var endPointIndices = glyph.endPointIndices = [];\n        for (var i = 0; i < glyph.numberOfContours; i += 1) {\n            endPointIndices.push(p.parseUShort());\n        }\n\n        glyph.instructionLength = p.parseUShort();\n        glyph.instructions = [];\n        for (var i$1 = 0; i$1 < glyph.instructionLength; i$1 += 1) {\n            glyph.instructions.push(p.parseByte());\n        }\n\n        var numberOfCoordinates = endPointIndices[endPointIndices.length - 1] + 1;\n        flags = [];\n        for (var i$2 = 0; i$2 < numberOfCoordinates; i$2 += 1) {\n            flag = p.parseByte();\n            flags.push(flag);\n            // If bit 3 is set, we repeat this flag n times, where n is the next byte.\n            if ((flag & 8) > 0) {\n                var repeatCount = p.parseByte();\n                for (var j = 0; j < repeatCount; j += 1) {\n                    flags.push(flag);\n                    i$2 += 1;\n                }\n            }\n        }\n\n        check.argument(flags.length === numberOfCoordinates, 'Bad flags.');\n\n        if (endPointIndices.length > 0) {\n            var points = [];\n            var point;\n            // X/Y coordinates are relative to the previous point, except for the first point which is relative to 0,0.\n            if (numberOfCoordinates > 0) {\n                for (var i$3 = 0; i$3 < numberOfCoordinates; i$3 += 1) {\n                    flag = flags[i$3];\n                    point = {};\n                    point.onCurve = !!(flag & 1);\n                    point.lastPointOfContour = endPointIndices.indexOf(i$3) >= 0;\n                    points.push(point);\n                }\n\n                var px = 0;\n                for (var i$4 = 0; i$4 < numberOfCoordinates; i$4 += 1) {\n                    flag = flags[i$4];\n                    point = points[i$4];\n                    point.x = parseGlyphCoordinate(p, flag, px, 2, 16);\n                    px = point.x;\n                }\n\n                var py = 0;\n                for (var i$5 = 0; i$5 < numberOfCoordinates; i$5 += 1) {\n                    flag = flags[i$5];\n                    point = points[i$5];\n                    point.y = parseGlyphCoordinate(p, flag, py, 4, 32);\n                    py = point.y;\n                }\n            }\n\n            glyph.points = points;\n        } else {\n            glyph.points = [];\n        }\n    } else if (glyph.numberOfContours === 0) {\n        glyph.points = [];\n    } else {\n        glyph.isComposite = true;\n        glyph.points = [];\n        glyph.components = [];\n        var moreComponents = true;\n        while (moreComponents) {\n            flags = p.parseUShort();\n            var component = {\n                glyphIndex: p.parseUShort(),\n                xScale: 1,\n                scale01: 0,\n                scale10: 0,\n                yScale: 1,\n                dx: 0,\n                dy: 0\n            };\n            if ((flags & 1) > 0) {\n                // The arguments are words\n                if ((flags & 2) > 0) {\n                    // values are offset\n                    component.dx = p.parseShort();\n                    component.dy = p.parseShort();\n                } else {\n                    // values are matched points\n                    component.matchedPoints = [p.parseUShort(), p.parseUShort()];\n                }\n\n            } else {\n                // The arguments are bytes\n                if ((flags & 2) > 0) {\n                    // values are offset\n                    component.dx = p.parseChar();\n                    component.dy = p.parseChar();\n                } else {\n                    // values are matched points\n                    component.matchedPoints = [p.parseByte(), p.parseByte()];\n                }\n            }\n\n            if ((flags & 8) > 0) {\n                // We have a scale\n                component.xScale = component.yScale = p.parseF2Dot14();\n            } else if ((flags & 64) > 0) {\n                // We have an X / Y scale\n                component.xScale = p.parseF2Dot14();\n                component.yScale = p.parseF2Dot14();\n            } else if ((flags & 128) > 0) {\n                // We have a 2x2 transformation\n                component.xScale = p.parseF2Dot14();\n                component.scale01 = p.parseF2Dot14();\n                component.scale10 = p.parseF2Dot14();\n                component.yScale = p.parseF2Dot14();\n            }\n\n            glyph.components.push(component);\n            moreComponents = !!(flags & 32);\n        }\n        if (flags & 0x100) {\n            // We have instructions\n            glyph.instructionLength = p.parseUShort();\n            glyph.instructions = [];\n            for (var i$6 = 0; i$6 < glyph.instructionLength; i$6 += 1) {\n                glyph.instructions.push(p.parseByte());\n            }\n        }\n    }\n}\n\n// Transform an array of points and return a new array.\nfunction transformPoints(points, transform) {\n    var newPoints = [];\n    for (var i = 0; i < points.length; i += 1) {\n        var pt = points[i];\n        var newPt = {\n            x: transform.xScale * pt.x + transform.scale01 * pt.y + transform.dx,\n            y: transform.scale10 * pt.x + transform.yScale * pt.y + transform.dy,\n            onCurve: pt.onCurve,\n            lastPointOfContour: pt.lastPointOfContour\n        };\n        newPoints.push(newPt);\n    }\n\n    return newPoints;\n}\n\nfunction getContours(points) {\n    var contours = [];\n    var currentContour = [];\n    for (var i = 0; i < points.length; i += 1) {\n        var pt = points[i];\n        currentContour.push(pt);\n        if (pt.lastPointOfContour) {\n            contours.push(currentContour);\n            currentContour = [];\n        }\n    }\n\n    check.argument(currentContour.length === 0, 'There are still points left in the current contour.');\n    return contours;\n}\n\n// Convert the TrueType glyph outline to a Path.\nfunction getPath(points) {\n    var p = new Path();\n    if (!points) {\n        return p;\n    }\n\n    var contours = getContours(points);\n\n    for (var contourIndex = 0; contourIndex < contours.length; ++contourIndex) {\n        var contour = contours[contourIndex];\n\n        var prev = null;\n        var curr = contour[contour.length - 1];\n        var next = contour[0];\n\n        if (curr.onCurve) {\n            p.moveTo(curr.x, curr.y);\n        } else {\n            if (next.onCurve) {\n                p.moveTo(next.x, next.y);\n            } else {\n                // If both first and last points are off-curve, start at their middle.\n                var start = {x: (curr.x + next.x) * 0.5, y: (curr.y + next.y) * 0.5};\n                p.moveTo(start.x, start.y);\n            }\n        }\n\n        for (var i = 0; i < contour.length; ++i) {\n            prev = curr;\n            curr = next;\n            next = contour[(i + 1) % contour.length];\n\n            if (curr.onCurve) {\n                // This is a straight line.\n                p.lineTo(curr.x, curr.y);\n            } else {\n                var prev2 = prev;\n                var next2 = next;\n\n                if (!prev.onCurve) {\n                    prev2 = { x: (curr.x + prev.x) * 0.5, y: (curr.y + prev.y) * 0.5 };\n                }\n\n                if (!next.onCurve) {\n                    next2 = { x: (curr.x + next.x) * 0.5, y: (curr.y + next.y) * 0.5 };\n                }\n\n                p.quadraticCurveTo(curr.x, curr.y, next2.x, next2.y);\n            }\n        }\n\n        p.closePath();\n    }\n    return p;\n}\n\nfunction buildPath(glyphs, glyph) {\n    if (glyph.isComposite) {\n        for (var j = 0; j < glyph.components.length; j += 1) {\n            var component = glyph.components[j];\n            var componentGlyph = glyphs.get(component.glyphIndex);\n            // Force the ttfGlyphLoader to parse the glyph.\n            componentGlyph.getPath();\n            if (componentGlyph.points) {\n                var transformedPoints = (void 0);\n                if (component.matchedPoints === undefined) {\n                    // component positioned by offset\n                    transformedPoints = transformPoints(componentGlyph.points, component);\n                } else {\n                    // component positioned by matched points\n                    if ((component.matchedPoints[0] > glyph.points.length - 1) ||\n                        (component.matchedPoints[1] > componentGlyph.points.length - 1)) {\n                        throw Error('Matched points out of range in ' + glyph.name);\n                    }\n                    var firstPt = glyph.points[component.matchedPoints[0]];\n                    var secondPt = componentGlyph.points[component.matchedPoints[1]];\n                    var transform = {\n                        xScale: component.xScale, scale01: component.scale01,\n                        scale10: component.scale10, yScale: component.yScale,\n                        dx: 0, dy: 0\n                    };\n                    secondPt = transformPoints([secondPt], transform)[0];\n                    transform.dx = firstPt.x - secondPt.x;\n                    transform.dy = firstPt.y - secondPt.y;\n                    transformedPoints = transformPoints(componentGlyph.points, transform);\n                }\n                glyph.points = glyph.points.concat(transformedPoints);\n            }\n        }\n    }\n\n    return getPath(glyph.points);\n}\n\nfunction parseGlyfTableAll(data, start, loca, font) {\n    var glyphs = new glyphset.GlyphSet(font);\n\n    // The last element of the loca table is invalid.\n    for (var i = 0; i < loca.length - 1; i += 1) {\n        var offset = loca[i];\n        var nextOffset = loca[i + 1];\n        if (offset !== nextOffset) {\n            glyphs.push(i, glyphset.ttfGlyphLoader(font, i, parseGlyph, data, start + offset, buildPath));\n        } else {\n            glyphs.push(i, glyphset.glyphLoader(font, i));\n        }\n    }\n\n    return glyphs;\n}\n\nfunction parseGlyfTableOnLowMemory(data, start, loca, font) {\n    var glyphs = new glyphset.GlyphSet(font);\n\n    font._push = function(i) {\n        var offset = loca[i];\n        var nextOffset = loca[i + 1];\n        if (offset !== nextOffset) {\n            glyphs.push(i, glyphset.ttfGlyphLoader(font, i, parseGlyph, data, start + offset, buildPath));\n        } else {\n            glyphs.push(i, glyphset.glyphLoader(font, i));\n        }\n    };\n\n    return glyphs;\n}\n\n// Parse all the glyphs according to the offsets from the `loca` table.\nfunction parseGlyfTable(data, start, loca, font, opt) {\n    if (opt.lowMemory)\n        { return parseGlyfTableOnLowMemory(data, start, loca, font); }\n    else\n        { return parseGlyfTableAll(data, start, loca, font); }\n}\n\nvar glyf = { getPath: getPath, parse: parseGlyfTable};\n\n/* A TrueType font hinting interpreter.\n*\n* (c) 2017 Axel Kittenberger\n*\n* This interpreter has been implemented according to this documentation:\n* https://developer.apple.com/fonts/TrueType-Reference-Manual/RM05/Chap5.html\n*\n* According to the documentation F24DOT6 values are used for pixels.\n* That means calculation is 1/64 pixel accurate and uses integer operations.\n* However, Javascript has floating point operations by default and only\n* those are available. One could make a case to simulate the 1/64 accuracy\n* exactly by truncating after every division operation\n* (for example with << 0) to get pixel exactly results as other TrueType\n* implementations. It may make sense since some fonts are pixel optimized\n* by hand using DELTAP instructions. The current implementation doesn't\n* and rather uses full floating point precision.\n*\n* xScale, yScale and rotation is currently ignored.\n*\n* A few non-trivial instructions are missing as I didn't encounter yet\n* a font that used them to test a possible implementation.\n*\n* Some fonts seem to use undocumented features regarding the twilight zone.\n* Only some of them are implemented as they were encountered.\n*\n* The exports.DEBUG statements are removed on the minified distribution file.\n*/\n\nvar instructionTable;\nvar exec;\nvar execGlyph;\nvar execComponent;\n\n/*\n* Creates a hinting object.\n*\n* There ought to be exactly one\n* for each truetype font that is used for hinting.\n*/\nfunction Hinting(font) {\n    // the font this hinting object is for\n    this.font = font;\n\n    this.getCommands = function (hPoints) {\n        return glyf.getPath(hPoints).commands;\n    };\n\n    // cached states\n    this._fpgmState  =\n    this._prepState  =\n        undefined;\n\n    // errorState\n    // 0 ... all okay\n    // 1 ... had an error in a glyf,\n    //       continue working but stop spamming\n    //       the console\n    // 2 ... error at prep, stop hinting at this ppem\n    // 3 ... error at fpeg, stop hinting for this font at all\n    this._errorState = 0;\n}\n\n/*\n* Not rounding.\n*/\nfunction roundOff(v) {\n    return v;\n}\n\n/*\n* Rounding to grid.\n*/\nfunction roundToGrid(v) {\n    //Rounding in TT is supposed to \"symmetrical around zero\"\n    return Math.sign(v) * Math.round(Math.abs(v));\n}\n\n/*\n* Rounding to double grid.\n*/\nfunction roundToDoubleGrid(v) {\n    return Math.sign(v) * Math.round(Math.abs(v * 2)) / 2;\n}\n\n/*\n* Rounding to half grid.\n*/\nfunction roundToHalfGrid(v) {\n    return Math.sign(v) * (Math.round(Math.abs(v) + 0.5) - 0.5);\n}\n\n/*\n* Rounding to up to grid.\n*/\nfunction roundUpToGrid(v) {\n    return Math.sign(v) * Math.ceil(Math.abs(v));\n}\n\n/*\n* Rounding to down to grid.\n*/\nfunction roundDownToGrid(v) {\n    return Math.sign(v) * Math.floor(Math.abs(v));\n}\n\n/*\n* Super rounding.\n*/\nvar roundSuper = function (v) {\n    var period = this.srPeriod;\n    var phase = this.srPhase;\n    var threshold = this.srThreshold;\n    var sign = 1;\n\n    if (v < 0) {\n        v = -v;\n        sign = -1;\n    }\n\n    v += threshold - phase;\n\n    v = Math.trunc(v / period) * period;\n\n    v += phase;\n\n    // according to http://xgridfit.sourceforge.net/round.html\n    if (v < 0) { return phase * sign; }\n\n    return v * sign;\n};\n\n/*\n* Unit vector of x-axis.\n*/\nvar xUnitVector = {\n    x: 1,\n\n    y: 0,\n\n    axis: 'x',\n\n    // Gets the projected distance between two points.\n    // o1/o2 ... if true, respective original position is used.\n    distance: function (p1, p2, o1, o2) {\n        return (o1 ? p1.xo : p1.x) - (o2 ? p2.xo : p2.x);\n    },\n\n    // Moves point p so the moved position has the same relative\n    // position to the moved positions of rp1 and rp2 than the\n    // original positions had.\n    //\n    // See APPENDIX on INTERPOLATE at the bottom of this file.\n    interpolate: function (p, rp1, rp2, pv) {\n        var do1;\n        var do2;\n        var doa1;\n        var doa2;\n        var dm1;\n        var dm2;\n        var dt;\n\n        if (!pv || pv === this) {\n            do1 = p.xo - rp1.xo;\n            do2 = p.xo - rp2.xo;\n            dm1 = rp1.x - rp1.xo;\n            dm2 = rp2.x - rp2.xo;\n            doa1 = Math.abs(do1);\n            doa2 = Math.abs(do2);\n            dt = doa1 + doa2;\n\n            if (dt === 0) {\n                p.x = p.xo + (dm1 + dm2) / 2;\n                return;\n            }\n\n            p.x = p.xo + (dm1 * doa2 + dm2 * doa1) / dt;\n            return;\n        }\n\n        do1 = pv.distance(p, rp1, true, true);\n        do2 = pv.distance(p, rp2, true, true);\n        dm1 = pv.distance(rp1, rp1, false, true);\n        dm2 = pv.distance(rp2, rp2, false, true);\n        doa1 = Math.abs(do1);\n        doa2 = Math.abs(do2);\n        dt = doa1 + doa2;\n\n        if (dt === 0) {\n            xUnitVector.setRelative(p, p, (dm1 + dm2) / 2, pv, true);\n            return;\n        }\n\n        xUnitVector.setRelative(p, p, (dm1 * doa2 + dm2 * doa1) / dt, pv, true);\n    },\n\n    // Slope of line normal to this\n    normalSlope: Number.NEGATIVE_INFINITY,\n\n    // Sets the point 'p' relative to point 'rp'\n    // by the distance 'd'.\n    //\n    // See APPENDIX on SETRELATIVE at the bottom of this file.\n    //\n    // p   ... point to set\n    // rp  ... reference point\n    // d   ... distance on projection vector\n    // pv  ... projection vector (undefined = this)\n    // org ... if true, uses the original position of rp as reference.\n    setRelative: function (p, rp, d, pv, org) {\n        if (!pv || pv === this) {\n            p.x = (org ? rp.xo : rp.x) + d;\n            return;\n        }\n\n        var rpx = org ? rp.xo : rp.x;\n        var rpy = org ? rp.yo : rp.y;\n        var rpdx = rpx + d * pv.x;\n        var rpdy = rpy + d * pv.y;\n\n        p.x = rpdx + (p.y - rpdy) / pv.normalSlope;\n    },\n\n    // Slope of vector line.\n    slope: 0,\n\n    // Touches the point p.\n    touch: function (p) {\n        p.xTouched = true;\n    },\n\n    // Tests if a point p is touched.\n    touched: function (p) {\n        return p.xTouched;\n    },\n\n    // Untouches the point p.\n    untouch: function (p) {\n        p.xTouched = false;\n    }\n};\n\n/*\n* Unit vector of y-axis.\n*/\nvar yUnitVector = {\n    x: 0,\n\n    y: 1,\n\n    axis: 'y',\n\n    // Gets the projected distance between two points.\n    // o1/o2 ... if true, respective original position is used.\n    distance: function (p1, p2, o1, o2) {\n        return (o1 ? p1.yo : p1.y) - (o2 ? p2.yo : p2.y);\n    },\n\n    // Moves point p so the moved position has the same relative\n    // position to the moved positions of rp1 and rp2 than the\n    // original positions had.\n    //\n    // See APPENDIX on INTERPOLATE at the bottom of this file.\n    interpolate: function (p, rp1, rp2, pv) {\n        var do1;\n        var do2;\n        var doa1;\n        var doa2;\n        var dm1;\n        var dm2;\n        var dt;\n\n        if (!pv || pv === this) {\n            do1 = p.yo - rp1.yo;\n            do2 = p.yo - rp2.yo;\n            dm1 = rp1.y - rp1.yo;\n            dm2 = rp2.y - rp2.yo;\n            doa1 = Math.abs(do1);\n            doa2 = Math.abs(do2);\n            dt = doa1 + doa2;\n\n            if (dt === 0) {\n                p.y = p.yo + (dm1 + dm2) / 2;\n                return;\n            }\n\n            p.y = p.yo + (dm1 * doa2 + dm2 * doa1) / dt;\n            return;\n        }\n\n        do1 = pv.distance(p, rp1, true, true);\n        do2 = pv.distance(p, rp2, true, true);\n        dm1 = pv.distance(rp1, rp1, false, true);\n        dm2 = pv.distance(rp2, rp2, false, true);\n        doa1 = Math.abs(do1);\n        doa2 = Math.abs(do2);\n        dt = doa1 + doa2;\n\n        if (dt === 0) {\n            yUnitVector.setRelative(p, p, (dm1 + dm2) / 2, pv, true);\n            return;\n        }\n\n        yUnitVector.setRelative(p, p, (dm1 * doa2 + dm2 * doa1) / dt, pv, true);\n    },\n\n    // Slope of line normal to this.\n    normalSlope: 0,\n\n    // Sets the point 'p' relative to point 'rp'\n    // by the distance 'd'\n    //\n    // See APPENDIX on SETRELATIVE at the bottom of this file.\n    //\n    // p   ... point to set\n    // rp  ... reference point\n    // d   ... distance on projection vector\n    // pv  ... projection vector (undefined = this)\n    // org ... if true, uses the original position of rp as reference.\n    setRelative: function (p, rp, d, pv, org) {\n        if (!pv || pv === this) {\n            p.y = (org ? rp.yo : rp.y) + d;\n            return;\n        }\n\n        var rpx = org ? rp.xo : rp.x;\n        var rpy = org ? rp.yo : rp.y;\n        var rpdx = rpx + d * pv.x;\n        var rpdy = rpy + d * pv.y;\n\n        p.y = rpdy + pv.normalSlope * (p.x - rpdx);\n    },\n\n    // Slope of vector line.\n    slope: Number.POSITIVE_INFINITY,\n\n    // Touches the point p.\n    touch: function (p) {\n        p.yTouched = true;\n    },\n\n    // Tests if a point p is touched.\n    touched: function (p) {\n        return p.yTouched;\n    },\n\n    // Untouches the point p.\n    untouch: function (p) {\n        p.yTouched = false;\n    }\n};\n\nObject.freeze(xUnitVector);\nObject.freeze(yUnitVector);\n\n/*\n* Creates a unit vector that is not x- or y-axis.\n*/\nfunction UnitVector(x, y) {\n    this.x = x;\n    this.y = y;\n    this.axis = undefined;\n    this.slope = y / x;\n    this.normalSlope = -x / y;\n    Object.freeze(this);\n}\n\n/*\n* Gets the projected distance between two points.\n* o1/o2 ... if true, respective original position is used.\n*/\nUnitVector.prototype.distance = function(p1, p2, o1, o2) {\n    return (\n        this.x * xUnitVector.distance(p1, p2, o1, o2) +\n        this.y * yUnitVector.distance(p1, p2, o1, o2)\n    );\n};\n\n/*\n* Moves point p so the moved position has the same relative\n* position to the moved positions of rp1 and rp2 than the\n* original positions had.\n*\n* See APPENDIX on INTERPOLATE at the bottom of this file.\n*/\nUnitVector.prototype.interpolate = function(p, rp1, rp2, pv) {\n    var dm1;\n    var dm2;\n    var do1;\n    var do2;\n    var doa1;\n    var doa2;\n    var dt;\n\n    do1 = pv.distance(p, rp1, true, true);\n    do2 = pv.distance(p, rp2, true, true);\n    dm1 = pv.distance(rp1, rp1, false, true);\n    dm2 = pv.distance(rp2, rp2, false, true);\n    doa1 = Math.abs(do1);\n    doa2 = Math.abs(do2);\n    dt = doa1 + doa2;\n\n    if (dt === 0) {\n        this.setRelative(p, p, (dm1 + dm2) / 2, pv, true);\n        return;\n    }\n\n    this.setRelative(p, p, (dm1 * doa2 + dm2 * doa1) / dt, pv, true);\n};\n\n/*\n* Sets the point 'p' relative to point 'rp'\n* by the distance 'd'\n*\n* See APPENDIX on SETRELATIVE at the bottom of this file.\n*\n* p   ...  point to set\n* rp  ... reference point\n* d   ... distance on projection vector\n* pv  ... projection vector (undefined = this)\n* org ... if true, uses the original position of rp as reference.\n*/\nUnitVector.prototype.setRelative = function(p, rp, d, pv, org) {\n    pv = pv || this;\n\n    var rpx = org ? rp.xo : rp.x;\n    var rpy = org ? rp.yo : rp.y;\n    var rpdx = rpx + d * pv.x;\n    var rpdy = rpy + d * pv.y;\n\n    var pvns = pv.normalSlope;\n    var fvs = this.slope;\n\n    var px = p.x;\n    var py = p.y;\n\n    p.x = (fvs * px - pvns * rpdx + rpdy - py) / (fvs - pvns);\n    p.y = fvs * (p.x - px) + py;\n};\n\n/*\n* Touches the point p.\n*/\nUnitVector.prototype.touch = function(p) {\n    p.xTouched = true;\n    p.yTouched = true;\n};\n\n/*\n* Returns a unit vector with x/y coordinates.\n*/\nfunction getUnitVector(x, y) {\n    var d = Math.sqrt(x * x + y * y);\n\n    x /= d;\n    y /= d;\n\n    if (x === 1 && y === 0) { return xUnitVector; }\n    else if (x === 0 && y === 1) { return yUnitVector; }\n    else { return new UnitVector(x, y); }\n}\n\n/*\n* Creates a point in the hinting engine.\n*/\nfunction HPoint(\n    x,\n    y,\n    lastPointOfContour,\n    onCurve\n) {\n    this.x = this.xo = Math.round(x * 64) / 64; // hinted x value and original x-value\n    this.y = this.yo = Math.round(y * 64) / 64; // hinted y value and original y-value\n\n    this.lastPointOfContour = lastPointOfContour;\n    this.onCurve = onCurve;\n    this.prevPointOnContour = undefined;\n    this.nextPointOnContour = undefined;\n    this.xTouched = false;\n    this.yTouched = false;\n\n    Object.preventExtensions(this);\n}\n\n/*\n* Returns the next touched point on the contour.\n*\n* v  ... unit vector to test touch axis.\n*/\nHPoint.prototype.nextTouched = function(v) {\n    var p = this.nextPointOnContour;\n\n    while (!v.touched(p) && p !== this) { p = p.nextPointOnContour; }\n\n    return p;\n};\n\n/*\n* Returns the previous touched point on the contour\n*\n* v  ... unit vector to test touch axis.\n*/\nHPoint.prototype.prevTouched = function(v) {\n    var p = this.prevPointOnContour;\n\n    while (!v.touched(p) && p !== this) { p = p.prevPointOnContour; }\n\n    return p;\n};\n\n/*\n* The zero point.\n*/\nvar HPZero = Object.freeze(new HPoint(0, 0));\n\n/*\n* The default state of the interpreter.\n*\n* Note: Freezing the defaultState and then deriving from it\n* makes the V8 Javascript engine going awkward,\n* so this is avoided, albeit the defaultState shouldn't\n* ever change.\n*/\nvar defaultState = {\n    cvCutIn: 17 / 16,    // control value cut in\n    deltaBase: 9,\n    deltaShift: 0.125,\n    loop: 1,             // loops some instructions\n    minDis: 1,           // minimum distance\n    autoFlip: true\n};\n\n/*\n* The current state of the interpreter.\n*\n* env  ... 'fpgm' or 'prep' or 'glyf'\n* prog ... the program\n*/\nfunction State(env, prog) {\n    this.env = env;\n    this.stack = [];\n    this.prog = prog;\n\n    switch (env) {\n        case 'glyf' :\n            this.zp0 = this.zp1 = this.zp2 = 1;\n            this.rp0 = this.rp1 = this.rp2 = 0;\n            /* fall through */\n        case 'prep' :\n            this.fv = this.pv = this.dpv = xUnitVector;\n            this.round = roundToGrid;\n    }\n}\n\n/*\n* Executes a glyph program.\n*\n* This does the hinting for each glyph.\n*\n* Returns an array of moved points.\n*\n* glyph: the glyph to hint\n* ppem: the size the glyph is rendered for\n*/\nHinting.prototype.exec = function(glyph, ppem) {\n    if (typeof ppem !== 'number') {\n        throw new Error('Point size is not a number!');\n    }\n\n    // Received a fatal error, don't do any hinting anymore.\n    if (this._errorState > 2) { return; }\n\n    var font = this.font;\n    var prepState = this._prepState;\n\n    if (!prepState || prepState.ppem !== ppem) {\n        var fpgmState = this._fpgmState;\n\n        if (!fpgmState) {\n            // Executes the fpgm state.\n            // This is used by fonts to define functions.\n            State.prototype = defaultState;\n\n            fpgmState =\n            this._fpgmState =\n                new State('fpgm', font.tables.fpgm);\n\n            fpgmState.funcs = [ ];\n            fpgmState.font = font;\n\n            if (exports.DEBUG) {\n                console.log('---EXEC FPGM---');\n                fpgmState.step = -1;\n            }\n\n            try {\n                exec(fpgmState);\n            } catch (e) {\n                console.log('Hinting error in FPGM:' + e);\n                this._errorState = 3;\n                return;\n            }\n        }\n\n        // Executes the prep program for this ppem setting.\n        // This is used by fonts to set cvt values\n        // depending on to be rendered font size.\n\n        State.prototype = fpgmState;\n        prepState =\n        this._prepState =\n            new State('prep', font.tables.prep);\n\n        prepState.ppem = ppem;\n\n        // Creates a copy of the cvt table\n        // and scales it to the current ppem setting.\n        var oCvt = font.tables.cvt;\n        if (oCvt) {\n            var cvt = prepState.cvt = new Array(oCvt.length);\n            var scale = ppem / font.unitsPerEm;\n            for (var c = 0; c < oCvt.length; c++) {\n                cvt[c] = oCvt[c] * scale;\n            }\n        } else {\n            prepState.cvt = [];\n        }\n\n        if (exports.DEBUG) {\n            console.log('---EXEC PREP---');\n            prepState.step = -1;\n        }\n\n        try {\n            exec(prepState);\n        } catch (e) {\n            if (this._errorState < 2) {\n                console.log('Hinting error in PREP:' + e);\n            }\n            this._errorState = 2;\n        }\n    }\n\n    if (this._errorState > 1) { return; }\n\n    try {\n        return execGlyph(glyph, prepState);\n    } catch (e) {\n        if (this._errorState < 1) {\n            console.log('Hinting error:' + e);\n            console.log('Note: further hinting errors are silenced');\n        }\n        this._errorState = 1;\n        return undefined;\n    }\n};\n\n/*\n* Executes the hinting program for a glyph.\n*/\nexecGlyph = function(glyph, prepState) {\n    // original point positions\n    var xScale = prepState.ppem / prepState.font.unitsPerEm;\n    var yScale = xScale;\n    var components = glyph.components;\n    var contours;\n    var gZone;\n    var state;\n\n    State.prototype = prepState;\n    if (!components) {\n        state = new State('glyf', glyph.instructions);\n        if (exports.DEBUG) {\n            console.log('---EXEC GLYPH---');\n            state.step = -1;\n        }\n        execComponent(glyph, state, xScale, yScale);\n        gZone = state.gZone;\n    } else {\n        var font = prepState.font;\n        gZone = [];\n        contours = [];\n        for (var i = 0; i < components.length; i++) {\n            var c = components[i];\n            var cg = font.glyphs.get(c.glyphIndex);\n\n            state = new State('glyf', cg.instructions);\n\n            if (exports.DEBUG) {\n                console.log('---EXEC COMP ' + i + '---');\n                state.step = -1;\n            }\n\n            execComponent(cg, state, xScale, yScale);\n            // appends the computed points to the result array\n            // post processes the component points\n            var dx = Math.round(c.dx * xScale);\n            var dy = Math.round(c.dy * yScale);\n            var gz = state.gZone;\n            var cc = state.contours;\n            for (var pi = 0; pi < gz.length; pi++) {\n                var p = gz[pi];\n                p.xTouched = p.yTouched = false;\n                p.xo = p.x = p.x + dx;\n                p.yo = p.y = p.y + dy;\n            }\n\n            var gLen = gZone.length;\n            gZone.push.apply(gZone, gz);\n            for (var j = 0; j < cc.length; j++) {\n                contours.push(cc[j] + gLen);\n            }\n        }\n\n        if (glyph.instructions && !state.inhibitGridFit) {\n            // the composite has instructions on its own\n            state = new State('glyf', glyph.instructions);\n\n            state.gZone = state.z0 = state.z1 = state.z2 = gZone;\n\n            state.contours = contours;\n\n            // note: HPZero cannot be used here, since\n            //       the point might be modified\n            gZone.push(\n                new HPoint(0, 0),\n                new HPoint(Math.round(glyph.advanceWidth * xScale), 0)\n            );\n\n            if (exports.DEBUG) {\n                console.log('---EXEC COMPOSITE---');\n                state.step = -1;\n            }\n\n            exec(state);\n\n            gZone.length -= 2;\n        }\n    }\n\n    return gZone;\n};\n\n/*\n* Executes the hinting program for a component of a multi-component glyph\n* or of the glyph itself for a non-component glyph.\n*/\nexecComponent = function(glyph, state, xScale, yScale)\n{\n    var points = glyph.points || [];\n    var pLen = points.length;\n    var gZone = state.gZone = state.z0 = state.z1 = state.z2 = [];\n    var contours = state.contours = [];\n\n    // Scales the original points and\n    // makes copies for the hinted points.\n    var cp; // current point\n    for (var i = 0; i < pLen; i++) {\n        cp = points[i];\n\n        gZone[i] = new HPoint(\n            cp.x * xScale,\n            cp.y * yScale,\n            cp.lastPointOfContour,\n            cp.onCurve\n        );\n    }\n\n    // Chain links the contours.\n    var sp; // start point\n    var np; // next point\n\n    for (var i$1 = 0; i$1 < pLen; i$1++) {\n        cp = gZone[i$1];\n\n        if (!sp) {\n            sp = cp;\n            contours.push(i$1);\n        }\n\n        if (cp.lastPointOfContour) {\n            cp.nextPointOnContour = sp;\n            sp.prevPointOnContour = cp;\n            sp = undefined;\n        } else {\n            np = gZone[i$1 + 1];\n            cp.nextPointOnContour = np;\n            np.prevPointOnContour = cp;\n        }\n    }\n\n    if (state.inhibitGridFit) { return; }\n\n    if (exports.DEBUG) {\n        console.log('PROCESSING GLYPH', state.stack);\n        for (var i$2 = 0; i$2 < pLen; i$2++) {\n            console.log(i$2, gZone[i$2].x, gZone[i$2].y);\n        }\n    }\n\n    gZone.push(\n        new HPoint(0, 0),\n        new HPoint(Math.round(glyph.advanceWidth * xScale), 0)\n    );\n\n    exec(state);\n\n    // Removes the extra points.\n    gZone.length -= 2;\n\n    if (exports.DEBUG) {\n        console.log('FINISHED GLYPH', state.stack);\n        for (var i$3 = 0; i$3 < pLen; i$3++) {\n            console.log(i$3, gZone[i$3].x, gZone[i$3].y);\n        }\n    }\n};\n\n/*\n* Executes the program loaded in state.\n*/\nexec = function(state) {\n    var prog = state.prog;\n\n    if (!prog) { return; }\n\n    var pLen = prog.length;\n    var ins;\n\n    for (state.ip = 0; state.ip < pLen; state.ip++) {\n        if (exports.DEBUG) { state.step++; }\n        ins = instructionTable[prog[state.ip]];\n\n        if (!ins) {\n            throw new Error(\n                'unknown instruction: 0x' +\n                Number(prog[state.ip]).toString(16)\n            );\n        }\n\n        ins(state);\n\n        // very extensive debugging for each step\n        /*\n        if (exports.DEBUG) {\n            var da;\n            if (state.gZone) {\n                da = [];\n                for (let i = 0; i < state.gZone.length; i++)\n                {\n                    da.push(i + ' ' +\n                        state.gZone[i].x * 64 + ' ' +\n                        state.gZone[i].y * 64 + ' ' +\n                        (state.gZone[i].xTouched ? 'x' : '') +\n                        (state.gZone[i].yTouched ? 'y' : '')\n                    );\n                }\n                console.log('GZ', da);\n            }\n\n            if (state.tZone) {\n                da = [];\n                for (let i = 0; i < state.tZone.length; i++) {\n                    da.push(i + ' ' +\n                        state.tZone[i].x * 64 + ' ' +\n                        state.tZone[i].y * 64 + ' ' +\n                        (state.tZone[i].xTouched ? 'x' : '') +\n                        (state.tZone[i].yTouched ? 'y' : '')\n                    );\n                }\n                console.log('TZ', da);\n            }\n\n            if (state.stack.length > 10) {\n                console.log(\n                    state.stack.length,\n                    '...', state.stack.slice(state.stack.length - 10)\n                );\n            } else {\n                console.log(state.stack.length, state.stack);\n            }\n        }\n        */\n    }\n};\n\n/*\n* Initializes the twilight zone.\n*\n* This is only done if a SZPx instruction\n* refers to the twilight zone.\n*/\nfunction initTZone(state)\n{\n    var tZone = state.tZone = new Array(state.gZone.length);\n\n    // no idea if this is actually correct...\n    for (var i = 0; i < tZone.length; i++)\n    {\n        tZone[i] = new HPoint(0, 0);\n    }\n}\n\n/*\n* Skips the instruction pointer ahead over an IF/ELSE block.\n* handleElse .. if true breaks on matching ELSE\n*/\nfunction skip(state, handleElse)\n{\n    var prog = state.prog;\n    var ip = state.ip;\n    var nesting = 1;\n    var ins;\n\n    do {\n        ins = prog[++ip];\n        if (ins === 0x58) // IF\n            { nesting++; }\n        else if (ins === 0x59) // EIF\n            { nesting--; }\n        else if (ins === 0x40) // NPUSHB\n            { ip += prog[ip + 1] + 1; }\n        else if (ins === 0x41) // NPUSHW\n            { ip += 2 * prog[ip + 1] + 1; }\n        else if (ins >= 0xB0 && ins <= 0xB7) // PUSHB\n            { ip += ins - 0xB0 + 1; }\n        else if (ins >= 0xB8 && ins <= 0xBF) // PUSHW\n            { ip += (ins - 0xB8 + 1) * 2; }\n        else if (handleElse && nesting === 1 && ins === 0x1B) // ELSE\n            { break; }\n    } while (nesting > 0);\n\n    state.ip = ip;\n}\n\n/*----------------------------------------------------------*\n*          And then a lot of instructions...                *\n*----------------------------------------------------------*/\n\n// SVTCA[a] Set freedom and projection Vectors To Coordinate Axis\n// 0x00-0x01\nfunction SVTCA(v, state) {\n    if (exports.DEBUG) { console.log(state.step, 'SVTCA[' + v.axis + ']'); }\n\n    state.fv = state.pv = state.dpv = v;\n}\n\n// SPVTCA[a] Set Projection Vector to Coordinate Axis\n// 0x02-0x03\nfunction SPVTCA(v, state) {\n    if (exports.DEBUG) { console.log(state.step, 'SPVTCA[' + v.axis + ']'); }\n\n    state.pv = state.dpv = v;\n}\n\n// SFVTCA[a] Set Freedom Vector to Coordinate Axis\n// 0x04-0x05\nfunction SFVTCA(v, state) {\n    if (exports.DEBUG) { console.log(state.step, 'SFVTCA[' + v.axis + ']'); }\n\n    state.fv = v;\n}\n\n// SPVTL[a] Set Projection Vector To Line\n// 0x06-0x07\nfunction SPVTL(a, state) {\n    var stack = state.stack;\n    var p2i = stack.pop();\n    var p1i = stack.pop();\n    var p2 = state.z2[p2i];\n    var p1 = state.z1[p1i];\n\n    if (exports.DEBUG) { console.log('SPVTL[' + a + ']', p2i, p1i); }\n\n    var dx;\n    var dy;\n\n    if (!a) {\n        dx = p1.x - p2.x;\n        dy = p1.y - p2.y;\n    } else {\n        dx = p2.y - p1.y;\n        dy = p1.x - p2.x;\n    }\n\n    state.pv = state.dpv = getUnitVector(dx, dy);\n}\n\n// SFVTL[a] Set Freedom Vector To Line\n// 0x08-0x09\nfunction SFVTL(a, state) {\n    var stack = state.stack;\n    var p2i = stack.pop();\n    var p1i = stack.pop();\n    var p2 = state.z2[p2i];\n    var p1 = state.z1[p1i];\n\n    if (exports.DEBUG) { console.log('SFVTL[' + a + ']', p2i, p1i); }\n\n    var dx;\n    var dy;\n\n    if (!a) {\n        dx = p1.x - p2.x;\n        dy = p1.y - p2.y;\n    } else {\n        dx = p2.y - p1.y;\n        dy = p1.x - p2.x;\n    }\n\n    state.fv = getUnitVector(dx, dy);\n}\n\n// SPVFS[] Set Projection Vector From Stack\n// 0x0A\nfunction SPVFS(state) {\n    var stack = state.stack;\n    var y = stack.pop();\n    var x = stack.pop();\n\n    if (exports.DEBUG) { console.log(state.step, 'SPVFS[]', y, x); }\n\n    state.pv = state.dpv = getUnitVector(x, y);\n}\n\n// SFVFS[] Set Freedom Vector From Stack\n// 0x0B\nfunction SFVFS(state) {\n    var stack = state.stack;\n    var y = stack.pop();\n    var x = stack.pop();\n\n    if (exports.DEBUG) { console.log(state.step, 'SPVFS[]', y, x); }\n\n    state.fv = getUnitVector(x, y);\n}\n\n// GPV[] Get Projection Vector\n// 0x0C\nfunction GPV(state) {\n    var stack = state.stack;\n    var pv = state.pv;\n\n    if (exports.DEBUG) { console.log(state.step, 'GPV[]'); }\n\n    stack.push(pv.x * 0x4000);\n    stack.push(pv.y * 0x4000);\n}\n\n// GFV[] Get Freedom Vector\n// 0x0C\nfunction GFV(state) {\n    var stack = state.stack;\n    var fv = state.fv;\n\n    if (exports.DEBUG) { console.log(state.step, 'GFV[]'); }\n\n    stack.push(fv.x * 0x4000);\n    stack.push(fv.y * 0x4000);\n}\n\n// SFVTPV[] Set Freedom Vector To Projection Vector\n// 0x0E\nfunction SFVTPV(state) {\n    state.fv = state.pv;\n\n    if (exports.DEBUG) { console.log(state.step, 'SFVTPV[]'); }\n}\n\n// ISECT[] moves point p to the InterSECTion of two lines\n// 0x0F\nfunction ISECT(state)\n{\n    var stack = state.stack;\n    var pa0i = stack.pop();\n    var pa1i = stack.pop();\n    var pb0i = stack.pop();\n    var pb1i = stack.pop();\n    var pi = stack.pop();\n    var z0 = state.z0;\n    var z1 = state.z1;\n    var pa0 = z0[pa0i];\n    var pa1 = z0[pa1i];\n    var pb0 = z1[pb0i];\n    var pb1 = z1[pb1i];\n    var p = state.z2[pi];\n\n    if (exports.DEBUG) { console.log('ISECT[], ', pa0i, pa1i, pb0i, pb1i, pi); }\n\n    // math from\n    // en.wikipedia.org/wiki/Line%E2%80%93line_intersection#Given_two_points_on_each_line\n\n    var x1 = pa0.x;\n    var y1 = pa0.y;\n    var x2 = pa1.x;\n    var y2 = pa1.y;\n    var x3 = pb0.x;\n    var y3 = pb0.y;\n    var x4 = pb1.x;\n    var y4 = pb1.y;\n\n    var div = (x1 - x2) * (y3 - y4) - (y1 - y2) * (x3 - x4);\n    var f1 = x1 * y2 - y1 * x2;\n    var f2 = x3 * y4 - y3 * x4;\n\n    p.x = (f1 * (x3 - x4) - f2 * (x1 - x2)) / div;\n    p.y = (f1 * (y3 - y4) - f2 * (y1 - y2)) / div;\n}\n\n// SRP0[] Set Reference Point 0\n// 0x10\nfunction SRP0(state) {\n    state.rp0 = state.stack.pop();\n\n    if (exports.DEBUG) { console.log(state.step, 'SRP0[]', state.rp0); }\n}\n\n// SRP1[] Set Reference Point 1\n// 0x11\nfunction SRP1(state) {\n    state.rp1 = state.stack.pop();\n\n    if (exports.DEBUG) { console.log(state.step, 'SRP1[]', state.rp1); }\n}\n\n// SRP1[] Set Reference Point 2\n// 0x12\nfunction SRP2(state) {\n    state.rp2 = state.stack.pop();\n\n    if (exports.DEBUG) { console.log(state.step, 'SRP2[]', state.rp2); }\n}\n\n// SZP0[] Set Zone Pointer 0\n// 0x13\nfunction SZP0(state) {\n    var n = state.stack.pop();\n\n    if (exports.DEBUG) { console.log(state.step, 'SZP0[]', n); }\n\n    state.zp0 = n;\n\n    switch (n) {\n        case 0:\n            if (!state.tZone) { initTZone(state); }\n            state.z0 = state.tZone;\n            break;\n        case 1 :\n            state.z0 = state.gZone;\n            break;\n        default :\n            throw new Error('Invalid zone pointer');\n    }\n}\n\n// SZP1[] Set Zone Pointer 1\n// 0x14\nfunction SZP1(state) {\n    var n = state.stack.pop();\n\n    if (exports.DEBUG) { console.log(state.step, 'SZP1[]', n); }\n\n    state.zp1 = n;\n\n    switch (n) {\n        case 0:\n            if (!state.tZone) { initTZone(state); }\n            state.z1 = state.tZone;\n            break;\n        case 1 :\n            state.z1 = state.gZone;\n            break;\n        default :\n            throw new Error('Invalid zone pointer');\n    }\n}\n\n// SZP2[] Set Zone Pointer 2\n// 0x15\nfunction SZP2(state) {\n    var n = state.stack.pop();\n\n    if (exports.DEBUG) { console.log(state.step, 'SZP2[]', n); }\n\n    state.zp2 = n;\n\n    switch (n) {\n        case 0:\n            if (!state.tZone) { initTZone(state); }\n            state.z2 = state.tZone;\n            break;\n        case 1 :\n            state.z2 = state.gZone;\n            break;\n        default :\n            throw new Error('Invalid zone pointer');\n    }\n}\n\n// SZPS[] Set Zone PointerS\n// 0x16\nfunction SZPS(state) {\n    var n = state.stack.pop();\n\n    if (exports.DEBUG) { console.log(state.step, 'SZPS[]', n); }\n\n    state.zp0 = state.zp1 = state.zp2 = n;\n\n    switch (n) {\n        case 0:\n            if (!state.tZone) { initTZone(state); }\n            state.z0 = state.z1 = state.z2 = state.tZone;\n            break;\n        case 1 :\n            state.z0 = state.z1 = state.z2 = state.gZone;\n            break;\n        default :\n            throw new Error('Invalid zone pointer');\n    }\n}\n\n// SLOOP[] Set LOOP variable\n// 0x17\nfunction SLOOP(state) {\n    state.loop = state.stack.pop();\n\n    if (exports.DEBUG) { console.log(state.step, 'SLOOP[]', state.loop); }\n}\n\n// RTG[] Round To Grid\n// 0x18\nfunction RTG(state) {\n    if (exports.DEBUG) { console.log(state.step, 'RTG[]'); }\n\n    state.round = roundToGrid;\n}\n\n// RTHG[] Round To Half Grid\n// 0x19\nfunction RTHG(state) {\n    if (exports.DEBUG) { console.log(state.step, 'RTHG[]'); }\n\n    state.round = roundToHalfGrid;\n}\n\n// SMD[] Set Minimum Distance\n// 0x1A\nfunction SMD(state) {\n    var d = state.stack.pop();\n\n    if (exports.DEBUG) { console.log(state.step, 'SMD[]', d); }\n\n    state.minDis = d / 0x40;\n}\n\n// ELSE[] ELSE clause\n// 0x1B\nfunction ELSE(state) {\n    // This instruction has been reached by executing a then branch\n    // so it just skips ahead until matching EIF.\n    //\n    // In case the IF was negative the IF[] instruction already\n    // skipped forward over the ELSE[]\n\n    if (exports.DEBUG) { console.log(state.step, 'ELSE[]'); }\n\n    skip(state, false);\n}\n\n// JMPR[] JuMP Relative\n// 0x1C\nfunction JMPR(state) {\n    var o = state.stack.pop();\n\n    if (exports.DEBUG) { console.log(state.step, 'JMPR[]', o); }\n\n    // A jump by 1 would do nothing.\n    state.ip += o - 1;\n}\n\n// SCVTCI[] Set Control Value Table Cut-In\n// 0x1D\nfunction SCVTCI(state) {\n    var n = state.stack.pop();\n\n    if (exports.DEBUG) { console.log(state.step, 'SCVTCI[]', n); }\n\n    state.cvCutIn = n / 0x40;\n}\n\n// DUP[] DUPlicate top stack element\n// 0x20\nfunction DUP(state) {\n    var stack = state.stack;\n\n    if (exports.DEBUG) { console.log(state.step, 'DUP[]'); }\n\n    stack.push(stack[stack.length - 1]);\n}\n\n// POP[] POP top stack element\n// 0x21\nfunction POP(state) {\n    if (exports.DEBUG) { console.log(state.step, 'POP[]'); }\n\n    state.stack.pop();\n}\n\n// CLEAR[] CLEAR the stack\n// 0x22\nfunction CLEAR(state) {\n    if (exports.DEBUG) { console.log(state.step, 'CLEAR[]'); }\n\n    state.stack.length = 0;\n}\n\n// SWAP[] SWAP the top two elements on the stack\n// 0x23\nfunction SWAP(state) {\n    var stack = state.stack;\n\n    var a = stack.pop();\n    var b = stack.pop();\n\n    if (exports.DEBUG) { console.log(state.step, 'SWAP[]'); }\n\n    stack.push(a);\n    stack.push(b);\n}\n\n// DEPTH[] DEPTH of the stack\n// 0x24\nfunction DEPTH(state) {\n    var stack = state.stack;\n\n    if (exports.DEBUG) { console.log(state.step, 'DEPTH[]'); }\n\n    stack.push(stack.length);\n}\n\n// LOOPCALL[] LOOPCALL function\n// 0x2A\nfunction LOOPCALL(state) {\n    var stack = state.stack;\n    var fn = stack.pop();\n    var c = stack.pop();\n\n    if (exports.DEBUG) { console.log(state.step, 'LOOPCALL[]', fn, c); }\n\n    // saves callers program\n    var cip = state.ip;\n    var cprog = state.prog;\n\n    state.prog = state.funcs[fn];\n\n    // executes the function\n    for (var i = 0; i < c; i++) {\n        exec(state);\n\n        if (exports.DEBUG) { console.log(\n            ++state.step,\n            i + 1 < c ? 'next loopcall' : 'done loopcall',\n            i\n        ); }\n    }\n\n    // restores the callers program\n    state.ip = cip;\n    state.prog = cprog;\n}\n\n// CALL[] CALL function\n// 0x2B\nfunction CALL(state) {\n    var fn = state.stack.pop();\n\n    if (exports.DEBUG) { console.log(state.step, 'CALL[]', fn); }\n\n    // saves callers program\n    var cip = state.ip;\n    var cprog = state.prog;\n\n    state.prog = state.funcs[fn];\n\n    // executes the function\n    exec(state);\n\n    // restores the callers program\n    state.ip = cip;\n    state.prog = cprog;\n\n    if (exports.DEBUG) { console.log(++state.step, 'returning from', fn); }\n}\n\n// CINDEX[] Copy the INDEXed element to the top of the stack\n// 0x25\nfunction CINDEX(state) {\n    var stack = state.stack;\n    var k = stack.pop();\n\n    if (exports.DEBUG) { console.log(state.step, 'CINDEX[]', k); }\n\n    // In case of k == 1, it copies the last element after popping\n    // thus stack.length - k.\n    stack.push(stack[stack.length - k]);\n}\n\n// MINDEX[] Move the INDEXed element to the top of the stack\n// 0x26\nfunction MINDEX(state) {\n    var stack = state.stack;\n    var k = stack.pop();\n\n    if (exports.DEBUG) { console.log(state.step, 'MINDEX[]', k); }\n\n    stack.push(stack.splice(stack.length - k, 1)[0]);\n}\n\n// FDEF[] Function DEFinition\n// 0x2C\nfunction FDEF(state) {\n    if (state.env !== 'fpgm') { throw new Error('FDEF not allowed here'); }\n    var stack = state.stack;\n    var prog = state.prog;\n    var ip = state.ip;\n\n    var fn = stack.pop();\n    var ipBegin = ip;\n\n    if (exports.DEBUG) { console.log(state.step, 'FDEF[]', fn); }\n\n    while (prog[++ip] !== 0x2D){ }\n\n    state.ip = ip;\n    state.funcs[fn] = prog.slice(ipBegin + 1, ip);\n}\n\n// MDAP[a] Move Direct Absolute Point\n// 0x2E-0x2F\nfunction MDAP(round, state) {\n    var pi = state.stack.pop();\n    var p = state.z0[pi];\n    var fv = state.fv;\n    var pv = state.pv;\n\n    if (exports.DEBUG) { console.log(state.step, 'MDAP[' + round + ']', pi); }\n\n    var d = pv.distance(p, HPZero);\n\n    if (round) { d = state.round(d); }\n\n    fv.setRelative(p, HPZero, d, pv);\n    fv.touch(p);\n\n    state.rp0 = state.rp1 = pi;\n}\n\n// IUP[a] Interpolate Untouched Points through the outline\n// 0x30\nfunction IUP(v, state) {\n    var z2 = state.z2;\n    var pLen = z2.length - 2;\n    var cp;\n    var pp;\n    var np;\n\n    if (exports.DEBUG) { console.log(state.step, 'IUP[' + v.axis + ']'); }\n\n    for (var i = 0; i < pLen; i++) {\n        cp = z2[i]; // current point\n\n        // if this point has been touched go on\n        if (v.touched(cp)) { continue; }\n\n        pp = cp.prevTouched(v);\n\n        // no point on the contour has been touched?\n        if (pp === cp) { continue; }\n\n        np = cp.nextTouched(v);\n\n        if (pp === np) {\n            // only one point on the contour has been touched\n            // so simply moves the point like that\n\n            v.setRelative(cp, cp, v.distance(pp, pp, false, true), v, true);\n        }\n\n        v.interpolate(cp, pp, np, v);\n    }\n}\n\n// SHP[] SHift Point using reference point\n// 0x32-0x33\nfunction SHP(a, state) {\n    var stack = state.stack;\n    var rpi = a ? state.rp1 : state.rp2;\n    var rp = (a ? state.z0 : state.z1)[rpi];\n    var fv = state.fv;\n    var pv = state.pv;\n    var loop = state.loop;\n    var z2 = state.z2;\n\n    while (loop--)\n    {\n        var pi = stack.pop();\n        var p = z2[pi];\n\n        var d = pv.distance(rp, rp, false, true);\n        fv.setRelative(p, p, d, pv);\n        fv.touch(p);\n\n        if (exports.DEBUG) {\n            console.log(\n                state.step,\n                (state.loop > 1 ?\n                   'loop ' + (state.loop - loop) + ': ' :\n                   ''\n                ) +\n                'SHP[' + (a ? 'rp1' : 'rp2') + ']', pi\n            );\n        }\n    }\n\n    state.loop = 1;\n}\n\n// SHC[] SHift Contour using reference point\n// 0x36-0x37\nfunction SHC(a, state) {\n    var stack = state.stack;\n    var rpi = a ? state.rp1 : state.rp2;\n    var rp = (a ? state.z0 : state.z1)[rpi];\n    var fv = state.fv;\n    var pv = state.pv;\n    var ci = stack.pop();\n    var sp = state.z2[state.contours[ci]];\n    var p = sp;\n\n    if (exports.DEBUG) { console.log(state.step, 'SHC[' + a + ']', ci); }\n\n    var d = pv.distance(rp, rp, false, true);\n\n    do {\n        if (p !== rp) { fv.setRelative(p, p, d, pv); }\n        p = p.nextPointOnContour;\n    } while (p !== sp);\n}\n\n// SHZ[] SHift Zone using reference point\n// 0x36-0x37\nfunction SHZ(a, state) {\n    var stack = state.stack;\n    var rpi = a ? state.rp1 : state.rp2;\n    var rp = (a ? state.z0 : state.z1)[rpi];\n    var fv = state.fv;\n    var pv = state.pv;\n\n    var e = stack.pop();\n\n    if (exports.DEBUG) { console.log(state.step, 'SHZ[' + a + ']', e); }\n\n    var z;\n    switch (e) {\n        case 0 : z = state.tZone; break;\n        case 1 : z = state.gZone; break;\n        default : throw new Error('Invalid zone');\n    }\n\n    var p;\n    var d = pv.distance(rp, rp, false, true);\n    var pLen = z.length - 2;\n    for (var i = 0; i < pLen; i++)\n    {\n        p = z[i];\n        fv.setRelative(p, p, d, pv);\n        //if (p !== rp) fv.setRelative(p, p, d, pv);\n    }\n}\n\n// SHPIX[] SHift point by a PIXel amount\n// 0x38\nfunction SHPIX(state) {\n    var stack = state.stack;\n    var loop = state.loop;\n    var fv = state.fv;\n    var d = stack.pop() / 0x40;\n    var z2 = state.z2;\n\n    while (loop--) {\n        var pi = stack.pop();\n        var p = z2[pi];\n\n        if (exports.DEBUG) {\n            console.log(\n                state.step,\n                (state.loop > 1 ? 'loop ' + (state.loop - loop) + ': ' : '') +\n                'SHPIX[]', pi, d\n            );\n        }\n\n        fv.setRelative(p, p, d);\n        fv.touch(p);\n    }\n\n    state.loop = 1;\n}\n\n// IP[] Interpolate Point\n// 0x39\nfunction IP(state) {\n    var stack = state.stack;\n    var rp1i = state.rp1;\n    var rp2i = state.rp2;\n    var loop = state.loop;\n    var rp1 = state.z0[rp1i];\n    var rp2 = state.z1[rp2i];\n    var fv = state.fv;\n    var pv = state.dpv;\n    var z2 = state.z2;\n\n    while (loop--) {\n        var pi = stack.pop();\n        var p = z2[pi];\n\n        if (exports.DEBUG) {\n            console.log(\n                state.step,\n                (state.loop > 1 ? 'loop ' + (state.loop - loop) + ': ' : '') +\n                'IP[]', pi, rp1i, '<->', rp2i\n            );\n        }\n\n        fv.interpolate(p, rp1, rp2, pv);\n\n        fv.touch(p);\n    }\n\n    state.loop = 1;\n}\n\n// MSIRP[a] Move Stack Indirect Relative Point\n// 0x3A-0x3B\nfunction MSIRP(a, state) {\n    var stack = state.stack;\n    var d = stack.pop() / 64;\n    var pi = stack.pop();\n    var p = state.z1[pi];\n    var rp0 = state.z0[state.rp0];\n    var fv = state.fv;\n    var pv = state.pv;\n\n    fv.setRelative(p, rp0, d, pv);\n    fv.touch(p);\n\n    if (exports.DEBUG) { console.log(state.step, 'MSIRP[' + a + ']', d, pi); }\n\n    state.rp1 = state.rp0;\n    state.rp2 = pi;\n    if (a) { state.rp0 = pi; }\n}\n\n// ALIGNRP[] Align to reference point.\n// 0x3C\nfunction ALIGNRP(state) {\n    var stack = state.stack;\n    var rp0i = state.rp0;\n    var rp0 = state.z0[rp0i];\n    var loop = state.loop;\n    var fv = state.fv;\n    var pv = state.pv;\n    var z1 = state.z1;\n\n    while (loop--) {\n        var pi = stack.pop();\n        var p = z1[pi];\n\n        if (exports.DEBUG) {\n            console.log(\n                state.step,\n                (state.loop > 1 ? 'loop ' + (state.loop - loop) + ': ' : '') +\n                'ALIGNRP[]', pi\n            );\n        }\n\n        fv.setRelative(p, rp0, 0, pv);\n        fv.touch(p);\n    }\n\n    state.loop = 1;\n}\n\n// RTG[] Round To Double Grid\n// 0x3D\nfunction RTDG(state) {\n    if (exports.DEBUG) { console.log(state.step, 'RTDG[]'); }\n\n    state.round = roundToDoubleGrid;\n}\n\n// MIAP[a] Move Indirect Absolute Point\n// 0x3E-0x3F\nfunction MIAP(round, state) {\n    var stack = state.stack;\n    var n = stack.pop();\n    var pi = stack.pop();\n    var p = state.z0[pi];\n    var fv = state.fv;\n    var pv = state.pv;\n    var cv = state.cvt[n];\n\n    if (exports.DEBUG) {\n        console.log(\n            state.step,\n            'MIAP[' + round + ']',\n            n, '(', cv, ')', pi\n        );\n    }\n\n    var d = pv.distance(p, HPZero);\n\n    if (round) {\n        if (Math.abs(d - cv) < state.cvCutIn) { d = cv; }\n\n        d = state.round(d);\n    }\n\n    fv.setRelative(p, HPZero, d, pv);\n\n    if (state.zp0 === 0) {\n        p.xo = p.x;\n        p.yo = p.y;\n    }\n\n    fv.touch(p);\n\n    state.rp0 = state.rp1 = pi;\n}\n\n// NPUSB[] PUSH N Bytes\n// 0x40\nfunction NPUSHB(state) {\n    var prog = state.prog;\n    var ip = state.ip;\n    var stack = state.stack;\n\n    var n = prog[++ip];\n\n    if (exports.DEBUG) { console.log(state.step, 'NPUSHB[]', n); }\n\n    for (var i = 0; i < n; i++) { stack.push(prog[++ip]); }\n\n    state.ip = ip;\n}\n\n// NPUSHW[] PUSH N Words\n// 0x41\nfunction NPUSHW(state) {\n    var ip = state.ip;\n    var prog = state.prog;\n    var stack = state.stack;\n    var n = prog[++ip];\n\n    if (exports.DEBUG) { console.log(state.step, 'NPUSHW[]', n); }\n\n    for (var i = 0; i < n; i++) {\n        var w = (prog[++ip] << 8) | prog[++ip];\n        if (w & 0x8000) { w = -((w ^ 0xffff) + 1); }\n        stack.push(w);\n    }\n\n    state.ip = ip;\n}\n\n// WS[] Write Store\n// 0x42\nfunction WS(state) {\n    var stack = state.stack;\n    var store = state.store;\n\n    if (!store) { store = state.store = []; }\n\n    var v = stack.pop();\n    var l = stack.pop();\n\n    if (exports.DEBUG) { console.log(state.step, 'WS', v, l); }\n\n    store[l] = v;\n}\n\n// RS[] Read Store\n// 0x43\nfunction RS(state) {\n    var stack = state.stack;\n    var store = state.store;\n\n    var l = stack.pop();\n\n    if (exports.DEBUG) { console.log(state.step, 'RS', l); }\n\n    var v = (store && store[l]) || 0;\n\n    stack.push(v);\n}\n\n// WCVTP[] Write Control Value Table in Pixel units\n// 0x44\nfunction WCVTP(state) {\n    var stack = state.stack;\n\n    var v = stack.pop();\n    var l = stack.pop();\n\n    if (exports.DEBUG) { console.log(state.step, 'WCVTP', v, l); }\n\n    state.cvt[l] = v / 0x40;\n}\n\n// RCVT[] Read Control Value Table entry\n// 0x45\nfunction RCVT(state) {\n    var stack = state.stack;\n    var cvte = stack.pop();\n\n    if (exports.DEBUG) { console.log(state.step, 'RCVT', cvte); }\n\n    stack.push(state.cvt[cvte] * 0x40);\n}\n\n// GC[] Get Coordinate projected onto the projection vector\n// 0x46-0x47\nfunction GC(a, state) {\n    var stack = state.stack;\n    var pi = stack.pop();\n    var p = state.z2[pi];\n\n    if (exports.DEBUG) { console.log(state.step, 'GC[' + a + ']', pi); }\n\n    stack.push(state.dpv.distance(p, HPZero, a, false) * 0x40);\n}\n\n// MD[a] Measure Distance\n// 0x49-0x4A\nfunction MD(a, state) {\n    var stack = state.stack;\n    var pi2 = stack.pop();\n    var pi1 = stack.pop();\n    var p2 = state.z1[pi2];\n    var p1 = state.z0[pi1];\n    var d = state.dpv.distance(p1, p2, a, a);\n\n    if (exports.DEBUG) { console.log(state.step, 'MD[' + a + ']', pi2, pi1, '->', d); }\n\n    state.stack.push(Math.round(d * 64));\n}\n\n// MPPEM[] Measure Pixels Per EM\n// 0x4B\nfunction MPPEM(state) {\n    if (exports.DEBUG) { console.log(state.step, 'MPPEM[]'); }\n    state.stack.push(state.ppem);\n}\n\n// FLIPON[] set the auto FLIP Boolean to ON\n// 0x4D\nfunction FLIPON(state) {\n    if (exports.DEBUG) { console.log(state.step, 'FLIPON[]'); }\n    state.autoFlip = true;\n}\n\n// LT[] Less Than\n// 0x50\nfunction LT(state) {\n    var stack = state.stack;\n    var e2 = stack.pop();\n    var e1 = stack.pop();\n\n    if (exports.DEBUG) { console.log(state.step, 'LT[]', e2, e1); }\n\n    stack.push(e1 < e2 ? 1 : 0);\n}\n\n// LTEQ[] Less Than or EQual\n// 0x53\nfunction LTEQ(state) {\n    var stack = state.stack;\n    var e2 = stack.pop();\n    var e1 = stack.pop();\n\n    if (exports.DEBUG) { console.log(state.step, 'LTEQ[]', e2, e1); }\n\n    stack.push(e1 <= e2 ? 1 : 0);\n}\n\n// GTEQ[] Greater Than\n// 0x52\nfunction GT(state) {\n    var stack = state.stack;\n    var e2 = stack.pop();\n    var e1 = stack.pop();\n\n    if (exports.DEBUG) { console.log(state.step, 'GT[]', e2, e1); }\n\n    stack.push(e1 > e2 ? 1 : 0);\n}\n\n// GTEQ[] Greater Than or EQual\n// 0x53\nfunction GTEQ(state) {\n    var stack = state.stack;\n    var e2 = stack.pop();\n    var e1 = stack.pop();\n\n    if (exports.DEBUG) { console.log(state.step, 'GTEQ[]', e2, e1); }\n\n    stack.push(e1 >= e2 ? 1 : 0);\n}\n\n// EQ[] EQual\n// 0x54\nfunction EQ(state) {\n    var stack = state.stack;\n    var e2 = stack.pop();\n    var e1 = stack.pop();\n\n    if (exports.DEBUG) { console.log(state.step, 'EQ[]', e2, e1); }\n\n    stack.push(e2 === e1 ? 1 : 0);\n}\n\n// NEQ[] Not EQual\n// 0x55\nfunction NEQ(state) {\n    var stack = state.stack;\n    var e2 = stack.pop();\n    var e1 = stack.pop();\n\n    if (exports.DEBUG) { console.log(state.step, 'NEQ[]', e2, e1); }\n\n    stack.push(e2 !== e1 ? 1 : 0);\n}\n\n// ODD[] ODD\n// 0x56\nfunction ODD(state) {\n    var stack = state.stack;\n    var n = stack.pop();\n\n    if (exports.DEBUG) { console.log(state.step, 'ODD[]', n); }\n\n    stack.push(Math.trunc(n) % 2 ? 1 : 0);\n}\n\n// EVEN[] EVEN\n// 0x57\nfunction EVEN(state) {\n    var stack = state.stack;\n    var n = stack.pop();\n\n    if (exports.DEBUG) { console.log(state.step, 'EVEN[]', n); }\n\n    stack.push(Math.trunc(n) % 2 ? 0 : 1);\n}\n\n// IF[] IF test\n// 0x58\nfunction IF(state) {\n    var test = state.stack.pop();\n\n    if (exports.DEBUG) { console.log(state.step, 'IF[]', test); }\n\n    // if test is true it just continues\n    // if not the ip is skipped until matching ELSE or EIF\n    if (!test) {\n        skip(state, true);\n\n        if (exports.DEBUG) { console.log(state.step,  'EIF[]'); }\n    }\n}\n\n// EIF[] End IF\n// 0x59\nfunction EIF(state) {\n    // this can be reached normally when\n    // executing an else branch.\n    // -> just ignore it\n\n    if (exports.DEBUG) { console.log(state.step, 'EIF[]'); }\n}\n\n// AND[] logical AND\n// 0x5A\nfunction AND(state) {\n    var stack = state.stack;\n    var e2 = stack.pop();\n    var e1 = stack.pop();\n\n    if (exports.DEBUG) { console.log(state.step, 'AND[]', e2, e1); }\n\n    stack.push(e2 && e1 ? 1 : 0);\n}\n\n// OR[] logical OR\n// 0x5B\nfunction OR(state) {\n    var stack = state.stack;\n    var e2 = stack.pop();\n    var e1 = stack.pop();\n\n    if (exports.DEBUG) { console.log(state.step, 'OR[]', e2, e1); }\n\n    stack.push(e2 || e1 ? 1 : 0);\n}\n\n// NOT[] logical NOT\n// 0x5C\nfunction NOT(state) {\n    var stack = state.stack;\n    var e = stack.pop();\n\n    if (exports.DEBUG) { console.log(state.step, 'NOT[]', e); }\n\n    stack.push(e ? 0 : 1);\n}\n\n// DELTAP1[] DELTA exception P1\n// DELTAP2[] DELTA exception P2\n// DELTAP3[] DELTA exception P3\n// 0x5D, 0x71, 0x72\nfunction DELTAP123(b, state) {\n    var stack = state.stack;\n    var n = stack.pop();\n    var fv = state.fv;\n    var pv = state.pv;\n    var ppem = state.ppem;\n    var base = state.deltaBase + (b - 1) * 16;\n    var ds = state.deltaShift;\n    var z0 = state.z0;\n\n    if (exports.DEBUG) { console.log(state.step, 'DELTAP[' + b + ']', n, stack); }\n\n    for (var i = 0; i < n; i++) {\n        var pi = stack.pop();\n        var arg = stack.pop();\n        var appem = base + ((arg & 0xF0) >> 4);\n        if (appem !== ppem) { continue; }\n\n        var mag = (arg & 0x0F) - 8;\n        if (mag >= 0) { mag++; }\n        if (exports.DEBUG) { console.log(state.step, 'DELTAPFIX', pi, 'by', mag * ds); }\n\n        var p = z0[pi];\n        fv.setRelative(p, p, mag * ds, pv);\n    }\n}\n\n// SDB[] Set Delta Base in the graphics state\n// 0x5E\nfunction SDB(state) {\n    var stack = state.stack;\n    var n = stack.pop();\n\n    if (exports.DEBUG) { console.log(state.step, 'SDB[]', n); }\n\n    state.deltaBase = n;\n}\n\n// SDS[] Set Delta Shift in the graphics state\n// 0x5F\nfunction SDS(state) {\n    var stack = state.stack;\n    var n = stack.pop();\n\n    if (exports.DEBUG) { console.log(state.step, 'SDS[]', n); }\n\n    state.deltaShift = Math.pow(0.5, n);\n}\n\n// ADD[] ADD\n// 0x60\nfunction ADD(state) {\n    var stack = state.stack;\n    var n2 = stack.pop();\n    var n1 = stack.pop();\n\n    if (exports.DEBUG) { console.log(state.step, 'ADD[]', n2, n1); }\n\n    stack.push(n1 + n2);\n}\n\n// SUB[] SUB\n// 0x61\nfunction SUB(state) {\n    var stack = state.stack;\n    var n2 = stack.pop();\n    var n1 = stack.pop();\n\n    if (exports.DEBUG) { console.log(state.step, 'SUB[]', n2, n1); }\n\n    stack.push(n1 - n2);\n}\n\n// DIV[] DIV\n// 0x62\nfunction DIV(state) {\n    var stack = state.stack;\n    var n2 = stack.pop();\n    var n1 = stack.pop();\n\n    if (exports.DEBUG) { console.log(state.step, 'DIV[]', n2, n1); }\n\n    stack.push(n1 * 64 / n2);\n}\n\n// MUL[] MUL\n// 0x63\nfunction MUL(state) {\n    var stack = state.stack;\n    var n2 = stack.pop();\n    var n1 = stack.pop();\n\n    if (exports.DEBUG) { console.log(state.step, 'MUL[]', n2, n1); }\n\n    stack.push(n1 * n2 / 64);\n}\n\n// ABS[] ABSolute value\n// 0x64\nfunction ABS(state) {\n    var stack = state.stack;\n    var n = stack.pop();\n\n    if (exports.DEBUG) { console.log(state.step, 'ABS[]', n); }\n\n    stack.push(Math.abs(n));\n}\n\n// NEG[] NEGate\n// 0x65\nfunction NEG(state) {\n    var stack = state.stack;\n    var n = stack.pop();\n\n    if (exports.DEBUG) { console.log(state.step, 'NEG[]', n); }\n\n    stack.push(-n);\n}\n\n// FLOOR[] FLOOR\n// 0x66\nfunction FLOOR(state) {\n    var stack = state.stack;\n    var n = stack.pop();\n\n    if (exports.DEBUG) { console.log(state.step, 'FLOOR[]', n); }\n\n    stack.push(Math.floor(n / 0x40) * 0x40);\n}\n\n// CEILING[] CEILING\n// 0x67\nfunction CEILING(state) {\n    var stack = state.stack;\n    var n = stack.pop();\n\n    if (exports.DEBUG) { console.log(state.step, 'CEILING[]', n); }\n\n    stack.push(Math.ceil(n / 0x40) * 0x40);\n}\n\n// ROUND[ab] ROUND value\n// 0x68-0x6B\nfunction ROUND(dt, state) {\n    var stack = state.stack;\n    var n = stack.pop();\n\n    if (exports.DEBUG) { console.log(state.step, 'ROUND[]'); }\n\n    stack.push(state.round(n / 0x40) * 0x40);\n}\n\n// WCVTF[] Write Control Value Table in Funits\n// 0x70\nfunction WCVTF(state) {\n    var stack = state.stack;\n    var v = stack.pop();\n    var l = stack.pop();\n\n    if (exports.DEBUG) { console.log(state.step, 'WCVTF[]', v, l); }\n\n    state.cvt[l] = v * state.ppem / state.font.unitsPerEm;\n}\n\n// DELTAC1[] DELTA exception C1\n// DELTAC2[] DELTA exception C2\n// DELTAC3[] DELTA exception C3\n// 0x73, 0x74, 0x75\nfunction DELTAC123(b, state) {\n    var stack = state.stack;\n    var n = stack.pop();\n    var ppem = state.ppem;\n    var base = state.deltaBase + (b - 1) * 16;\n    var ds = state.deltaShift;\n\n    if (exports.DEBUG) { console.log(state.step, 'DELTAC[' + b + ']', n, stack); }\n\n    for (var i = 0; i < n; i++) {\n        var c = stack.pop();\n        var arg = stack.pop();\n        var appem = base + ((arg & 0xF0) >> 4);\n        if (appem !== ppem) { continue; }\n\n        var mag = (arg & 0x0F) - 8;\n        if (mag >= 0) { mag++; }\n\n        var delta = mag * ds;\n\n        if (exports.DEBUG) { console.log(state.step, 'DELTACFIX', c, 'by', delta); }\n\n        state.cvt[c] += delta;\n    }\n}\n\n// SROUND[] Super ROUND\n// 0x76\nfunction SROUND(state) {\n    var n = state.stack.pop();\n\n    if (exports.DEBUG) { console.log(state.step, 'SROUND[]', n); }\n\n    state.round = roundSuper;\n\n    var period;\n\n    switch (n & 0xC0) {\n        case 0x00:\n            period = 0.5;\n            break;\n        case 0x40:\n            period = 1;\n            break;\n        case 0x80:\n            period = 2;\n            break;\n        default:\n            throw new Error('invalid SROUND value');\n    }\n\n    state.srPeriod = period;\n\n    switch (n & 0x30) {\n        case 0x00:\n            state.srPhase = 0;\n            break;\n        case 0x10:\n            state.srPhase = 0.25 * period;\n            break;\n        case 0x20:\n            state.srPhase = 0.5  * period;\n            break;\n        case 0x30:\n            state.srPhase = 0.75 * period;\n            break;\n        default: throw new Error('invalid SROUND value');\n    }\n\n    n &= 0x0F;\n\n    if (n === 0) { state.srThreshold = 0; }\n    else { state.srThreshold = (n / 8 - 0.5) * period; }\n}\n\n// S45ROUND[] Super ROUND 45 degrees\n// 0x77\nfunction S45ROUND(state) {\n    var n = state.stack.pop();\n\n    if (exports.DEBUG) { console.log(state.step, 'S45ROUND[]', n); }\n\n    state.round = roundSuper;\n\n    var period;\n\n    switch (n & 0xC0) {\n        case 0x00:\n            period = Math.sqrt(2) / 2;\n            break;\n        case 0x40:\n            period = Math.sqrt(2);\n            break;\n        case 0x80:\n            period = 2 * Math.sqrt(2);\n            break;\n        default:\n            throw new Error('invalid S45ROUND value');\n    }\n\n    state.srPeriod = period;\n\n    switch (n & 0x30) {\n        case 0x00:\n            state.srPhase = 0;\n            break;\n        case 0x10:\n            state.srPhase = 0.25 * period;\n            break;\n        case 0x20:\n            state.srPhase = 0.5  * period;\n            break;\n        case 0x30:\n            state.srPhase = 0.75 * period;\n            break;\n        default:\n            throw new Error('invalid S45ROUND value');\n    }\n\n    n &= 0x0F;\n\n    if (n === 0) { state.srThreshold = 0; }\n    else { state.srThreshold = (n / 8 - 0.5) * period; }\n}\n\n// ROFF[] Round Off\n// 0x7A\nfunction ROFF(state) {\n    if (exports.DEBUG) { console.log(state.step, 'ROFF[]'); }\n\n    state.round = roundOff;\n}\n\n// RUTG[] Round Up To Grid\n// 0x7C\nfunction RUTG(state) {\n    if (exports.DEBUG) { console.log(state.step, 'RUTG[]'); }\n\n    state.round = roundUpToGrid;\n}\n\n// RDTG[] Round Down To Grid\n// 0x7D\nfunction RDTG(state) {\n    if (exports.DEBUG) { console.log(state.step, 'RDTG[]'); }\n\n    state.round = roundDownToGrid;\n}\n\n// SCANCTRL[] SCAN conversion ConTRoL\n// 0x85\nfunction SCANCTRL(state) {\n    var n = state.stack.pop();\n\n    // ignored by opentype.js\n\n    if (exports.DEBUG) { console.log(state.step, 'SCANCTRL[]', n); }\n}\n\n// SDPVTL[a] Set Dual Projection Vector To Line\n// 0x86-0x87\nfunction SDPVTL(a, state) {\n    var stack = state.stack;\n    var p2i = stack.pop();\n    var p1i = stack.pop();\n    var p2 = state.z2[p2i];\n    var p1 = state.z1[p1i];\n\n    if (exports.DEBUG) { console.log(state.step, 'SDPVTL[' + a + ']', p2i, p1i); }\n\n    var dx;\n    var dy;\n\n    if (!a) {\n        dx = p1.x - p2.x;\n        dy = p1.y - p2.y;\n    } else {\n        dx = p2.y - p1.y;\n        dy = p1.x - p2.x;\n    }\n\n    state.dpv = getUnitVector(dx, dy);\n}\n\n// GETINFO[] GET INFOrmation\n// 0x88\nfunction GETINFO(state) {\n    var stack = state.stack;\n    var sel = stack.pop();\n    var r = 0;\n\n    if (exports.DEBUG) { console.log(state.step, 'GETINFO[]', sel); }\n\n    // v35 as in no subpixel hinting\n    if (sel & 0x01) { r = 35; }\n\n    // TODO rotation and stretch currently not supported\n    // and thus those GETINFO are always 0.\n\n    // opentype.js is always gray scaling\n    if (sel & 0x20) { r |= 0x1000; }\n\n    stack.push(r);\n}\n\n// ROLL[] ROLL the top three stack elements\n// 0x8A\nfunction ROLL(state) {\n    var stack = state.stack;\n    var a = stack.pop();\n    var b = stack.pop();\n    var c = stack.pop();\n\n    if (exports.DEBUG) { console.log(state.step, 'ROLL[]'); }\n\n    stack.push(b);\n    stack.push(a);\n    stack.push(c);\n}\n\n// MAX[] MAXimum of top two stack elements\n// 0x8B\nfunction MAX(state) {\n    var stack = state.stack;\n    var e2 = stack.pop();\n    var e1 = stack.pop();\n\n    if (exports.DEBUG) { console.log(state.step, 'MAX[]', e2, e1); }\n\n    stack.push(Math.max(e1, e2));\n}\n\n// MIN[] MINimum of top two stack elements\n// 0x8C\nfunction MIN(state) {\n    var stack = state.stack;\n    var e2 = stack.pop();\n    var e1 = stack.pop();\n\n    if (exports.DEBUG) { console.log(state.step, 'MIN[]', e2, e1); }\n\n    stack.push(Math.min(e1, e2));\n}\n\n// SCANTYPE[] SCANTYPE\n// 0x8D\nfunction SCANTYPE(state) {\n    var n = state.stack.pop();\n    // ignored by opentype.js\n    if (exports.DEBUG) { console.log(state.step, 'SCANTYPE[]', n); }\n}\n\n// INSTCTRL[] INSTCTRL\n// 0x8D\nfunction INSTCTRL(state) {\n    var s = state.stack.pop();\n    var v = state.stack.pop();\n\n    if (exports.DEBUG) { console.log(state.step, 'INSTCTRL[]', s, v); }\n\n    switch (s) {\n        case 1 : state.inhibitGridFit = !!v; return;\n        case 2 : state.ignoreCvt = !!v; return;\n        default: throw new Error('invalid INSTCTRL[] selector');\n    }\n}\n\n// PUSHB[abc] PUSH Bytes\n// 0xB0-0xB7\nfunction PUSHB(n, state) {\n    var stack = state.stack;\n    var prog = state.prog;\n    var ip = state.ip;\n\n    if (exports.DEBUG) { console.log(state.step, 'PUSHB[' + n + ']'); }\n\n    for (var i = 0; i < n; i++) { stack.push(prog[++ip]); }\n\n    state.ip = ip;\n}\n\n// PUSHW[abc] PUSH Words\n// 0xB8-0xBF\nfunction PUSHW(n, state) {\n    var ip = state.ip;\n    var prog = state.prog;\n    var stack = state.stack;\n\n    if (exports.DEBUG) { console.log(state.ip, 'PUSHW[' + n + ']'); }\n\n    for (var i = 0; i < n; i++) {\n        var w = (prog[++ip] << 8) | prog[++ip];\n        if (w & 0x8000) { w = -((w ^ 0xffff) + 1); }\n        stack.push(w);\n    }\n\n    state.ip = ip;\n}\n\n// MDRP[abcde] Move Direct Relative Point\n// 0xD0-0xEF\n// (if indirect is 0)\n//\n// and\n//\n// MIRP[abcde] Move Indirect Relative Point\n// 0xE0-0xFF\n// (if indirect is 1)\n\nfunction MDRP_MIRP(indirect, setRp0, keepD, ro, dt, state) {\n    var stack = state.stack;\n    var cvte = indirect && stack.pop();\n    var pi = stack.pop();\n    var rp0i = state.rp0;\n    var rp = state.z0[rp0i];\n    var p = state.z1[pi];\n\n    var md = state.minDis;\n    var fv = state.fv;\n    var pv = state.dpv;\n    var od; // original distance\n    var d; // moving distance\n    var sign; // sign of distance\n    var cv;\n\n    d = od = pv.distance(p, rp, true, true);\n    sign = d >= 0 ? 1 : -1; // Math.sign would be 0 in case of 0\n\n    // TODO consider autoFlip\n    d = Math.abs(d);\n\n    if (indirect) {\n        cv = state.cvt[cvte];\n\n        if (ro && Math.abs(d - cv) < state.cvCutIn) { d = cv; }\n    }\n\n    if (keepD && d < md) { d = md; }\n\n    if (ro) { d = state.round(d); }\n\n    fv.setRelative(p, rp, sign * d, pv);\n    fv.touch(p);\n\n    if (exports.DEBUG) {\n        console.log(\n            state.step,\n            (indirect ? 'MIRP[' : 'MDRP[') +\n            (setRp0 ? 'M' : 'm') +\n            (keepD ? '>' : '_') +\n            (ro ? 'R' : '_') +\n            (dt === 0 ? 'Gr' : (dt === 1 ? 'Bl' : (dt === 2 ? 'Wh' : ''))) +\n            ']',\n            indirect ?\n                cvte + '(' + state.cvt[cvte] + ',' +  cv + ')' :\n                '',\n            pi,\n            '(d =', od, '->', sign * d, ')'\n        );\n    }\n\n    state.rp1 = state.rp0;\n    state.rp2 = pi;\n    if (setRp0) { state.rp0 = pi; }\n}\n\n/*\n* The instruction table.\n*/\ninstructionTable = [\n    /* 0x00 */ SVTCA.bind(undefined, yUnitVector),\n    /* 0x01 */ SVTCA.bind(undefined, xUnitVector),\n    /* 0x02 */ SPVTCA.bind(undefined, yUnitVector),\n    /* 0x03 */ SPVTCA.bind(undefined, xUnitVector),\n    /* 0x04 */ SFVTCA.bind(undefined, yUnitVector),\n    /* 0x05 */ SFVTCA.bind(undefined, xUnitVector),\n    /* 0x06 */ SPVTL.bind(undefined, 0),\n    /* 0x07 */ SPVTL.bind(undefined, 1),\n    /* 0x08 */ SFVTL.bind(undefined, 0),\n    /* 0x09 */ SFVTL.bind(undefined, 1),\n    /* 0x0A */ SPVFS,\n    /* 0x0B */ SFVFS,\n    /* 0x0C */ GPV,\n    /* 0x0D */ GFV,\n    /* 0x0E */ SFVTPV,\n    /* 0x0F */ ISECT,\n    /* 0x10 */ SRP0,\n    /* 0x11 */ SRP1,\n    /* 0x12 */ SRP2,\n    /* 0x13 */ SZP0,\n    /* 0x14 */ SZP1,\n    /* 0x15 */ SZP2,\n    /* 0x16 */ SZPS,\n    /* 0x17 */ SLOOP,\n    /* 0x18 */ RTG,\n    /* 0x19 */ RTHG,\n    /* 0x1A */ SMD,\n    /* 0x1B */ ELSE,\n    /* 0x1C */ JMPR,\n    /* 0x1D */ SCVTCI,\n    /* 0x1E */ undefined,   // TODO SSWCI\n    /* 0x1F */ undefined,   // TODO SSW\n    /* 0x20 */ DUP,\n    /* 0x21 */ POP,\n    /* 0x22 */ CLEAR,\n    /* 0x23 */ SWAP,\n    /* 0x24 */ DEPTH,\n    /* 0x25 */ CINDEX,\n    /* 0x26 */ MINDEX,\n    /* 0x27 */ undefined,   // TODO ALIGNPTS\n    /* 0x28 */ undefined,\n    /* 0x29 */ undefined,   // TODO UTP\n    /* 0x2A */ LOOPCALL,\n    /* 0x2B */ CALL,\n    /* 0x2C */ FDEF,\n    /* 0x2D */ undefined,   // ENDF (eaten by FDEF)\n    /* 0x2E */ MDAP.bind(undefined, 0),\n    /* 0x2F */ MDAP.bind(undefined, 1),\n    /* 0x30 */ IUP.bind(undefined, yUnitVector),\n    /* 0x31 */ IUP.bind(undefined, xUnitVector),\n    /* 0x32 */ SHP.bind(undefined, 0),\n    /* 0x33 */ SHP.bind(undefined, 1),\n    /* 0x34 */ SHC.bind(undefined, 0),\n    /* 0x35 */ SHC.bind(undefined, 1),\n    /* 0x36 */ SHZ.bind(undefined, 0),\n    /* 0x37 */ SHZ.bind(undefined, 1),\n    /* 0x38 */ SHPIX,\n    /* 0x39 */ IP,\n    /* 0x3A */ MSIRP.bind(undefined, 0),\n    /* 0x3B */ MSIRP.bind(undefined, 1),\n    /* 0x3C */ ALIGNRP,\n    /* 0x3D */ RTDG,\n    /* 0x3E */ MIAP.bind(undefined, 0),\n    /* 0x3F */ MIAP.bind(undefined, 1),\n    /* 0x40 */ NPUSHB,\n    /* 0x41 */ NPUSHW,\n    /* 0x42 */ WS,\n    /* 0x43 */ RS,\n    /* 0x44 */ WCVTP,\n    /* 0x45 */ RCVT,\n    /* 0x46 */ GC.bind(undefined, 0),\n    /* 0x47 */ GC.bind(undefined, 1),\n    /* 0x48 */ undefined,   // TODO SCFS\n    /* 0x49 */ MD.bind(undefined, 0),\n    /* 0x4A */ MD.bind(undefined, 1),\n    /* 0x4B */ MPPEM,\n    /* 0x4C */ undefined,   // TODO MPS\n    /* 0x4D */ FLIPON,\n    /* 0x4E */ undefined,   // TODO FLIPOFF\n    /* 0x4F */ undefined,   // TODO DEBUG\n    /* 0x50 */ LT,\n    /* 0x51 */ LTEQ,\n    /* 0x52 */ GT,\n    /* 0x53 */ GTEQ,\n    /* 0x54 */ EQ,\n    /* 0x55 */ NEQ,\n    /* 0x56 */ ODD,\n    /* 0x57 */ EVEN,\n    /* 0x58 */ IF,\n    /* 0x59 */ EIF,\n    /* 0x5A */ AND,\n    /* 0x5B */ OR,\n    /* 0x5C */ NOT,\n    /* 0x5D */ DELTAP123.bind(undefined, 1),\n    /* 0x5E */ SDB,\n    /* 0x5F */ SDS,\n    /* 0x60 */ ADD,\n    /* 0x61 */ SUB,\n    /* 0x62 */ DIV,\n    /* 0x63 */ MUL,\n    /* 0x64 */ ABS,\n    /* 0x65 */ NEG,\n    /* 0x66 */ FLOOR,\n    /* 0x67 */ CEILING,\n    /* 0x68 */ ROUND.bind(undefined, 0),\n    /* 0x69 */ ROUND.bind(undefined, 1),\n    /* 0x6A */ ROUND.bind(undefined, 2),\n    /* 0x6B */ ROUND.bind(undefined, 3),\n    /* 0x6C */ undefined,   // TODO NROUND[ab]\n    /* 0x6D */ undefined,   // TODO NROUND[ab]\n    /* 0x6E */ undefined,   // TODO NROUND[ab]\n    /* 0x6F */ undefined,   // TODO NROUND[ab]\n    /* 0x70 */ WCVTF,\n    /* 0x71 */ DELTAP123.bind(undefined, 2),\n    /* 0x72 */ DELTAP123.bind(undefined, 3),\n    /* 0x73 */ DELTAC123.bind(undefined, 1),\n    /* 0x74 */ DELTAC123.bind(undefined, 2),\n    /* 0x75 */ DELTAC123.bind(undefined, 3),\n    /* 0x76 */ SROUND,\n    /* 0x77 */ S45ROUND,\n    /* 0x78 */ undefined,   // TODO JROT[]\n    /* 0x79 */ undefined,   // TODO JROF[]\n    /* 0x7A */ ROFF,\n    /* 0x7B */ undefined,\n    /* 0x7C */ RUTG,\n    /* 0x7D */ RDTG,\n    /* 0x7E */ POP, // actually SANGW, supposed to do only a pop though\n    /* 0x7F */ POP, // actually AA, supposed to do only a pop though\n    /* 0x80 */ undefined,   // TODO FLIPPT\n    /* 0x81 */ undefined,   // TODO FLIPRGON\n    /* 0x82 */ undefined,   // TODO FLIPRGOFF\n    /* 0x83 */ undefined,\n    /* 0x84 */ undefined,\n    /* 0x85 */ SCANCTRL,\n    /* 0x86 */ SDPVTL.bind(undefined, 0),\n    /* 0x87 */ SDPVTL.bind(undefined, 1),\n    /* 0x88 */ GETINFO,\n    /* 0x89 */ undefined,   // TODO IDEF\n    /* 0x8A */ ROLL,\n    /* 0x8B */ MAX,\n    /* 0x8C */ MIN,\n    /* 0x8D */ SCANTYPE,\n    /* 0x8E */ INSTCTRL,\n    /* 0x8F */ undefined,\n    /* 0x90 */ undefined,\n    /* 0x91 */ undefined,\n    /* 0x92 */ undefined,\n    /* 0x93 */ undefined,\n    /* 0x94 */ undefined,\n    /* 0x95 */ undefined,\n    /* 0x96 */ undefined,\n    /* 0x97 */ undefined,\n    /* 0x98 */ undefined,\n    /* 0x99 */ undefined,\n    /* 0x9A */ undefined,\n    /* 0x9B */ undefined,\n    /* 0x9C */ undefined,\n    /* 0x9D */ undefined,\n    /* 0x9E */ undefined,\n    /* 0x9F */ undefined,\n    /* 0xA0 */ undefined,\n    /* 0xA1 */ undefined,\n    /* 0xA2 */ undefined,\n    /* 0xA3 */ undefined,\n    /* 0xA4 */ undefined,\n    /* 0xA5 */ undefined,\n    /* 0xA6 */ undefined,\n    /* 0xA7 */ undefined,\n    /* 0xA8 */ undefined,\n    /* 0xA9 */ undefined,\n    /* 0xAA */ undefined,\n    /* 0xAB */ undefined,\n    /* 0xAC */ undefined,\n    /* 0xAD */ undefined,\n    /* 0xAE */ undefined,\n    /* 0xAF */ undefined,\n    /* 0xB0 */ PUSHB.bind(undefined, 1),\n    /* 0xB1 */ PUSHB.bind(undefined, 2),\n    /* 0xB2 */ PUSHB.bind(undefined, 3),\n    /* 0xB3 */ PUSHB.bind(undefined, 4),\n    /* 0xB4 */ PUSHB.bind(undefined, 5),\n    /* 0xB5 */ PUSHB.bind(undefined, 6),\n    /* 0xB6 */ PUSHB.bind(undefined, 7),\n    /* 0xB7 */ PUSHB.bind(undefined, 8),\n    /* 0xB8 */ PUSHW.bind(undefined, 1),\n    /* 0xB9 */ PUSHW.bind(undefined, 2),\n    /* 0xBA */ PUSHW.bind(undefined, 3),\n    /* 0xBB */ PUSHW.bind(undefined, 4),\n    /* 0xBC */ PUSHW.bind(undefined, 5),\n    /* 0xBD */ PUSHW.bind(undefined, 6),\n    /* 0xBE */ PUSHW.bind(undefined, 7),\n    /* 0xBF */ PUSHW.bind(undefined, 8),\n    /* 0xC0 */ MDRP_MIRP.bind(undefined, 0, 0, 0, 0, 0),\n    /* 0xC1 */ MDRP_MIRP.bind(undefined, 0, 0, 0, 0, 1),\n    /* 0xC2 */ MDRP_MIRP.bind(undefined, 0, 0, 0, 0, 2),\n    /* 0xC3 */ MDRP_MIRP.bind(undefined, 0, 0, 0, 0, 3),\n    /* 0xC4 */ MDRP_MIRP.bind(undefined, 0, 0, 0, 1, 0),\n    /* 0xC5 */ MDRP_MIRP.bind(undefined, 0, 0, 0, 1, 1),\n    /* 0xC6 */ MDRP_MIRP.bind(undefined, 0, 0, 0, 1, 2),\n    /* 0xC7 */ MDRP_MIRP.bind(undefined, 0, 0, 0, 1, 3),\n    /* 0xC8 */ MDRP_MIRP.bind(undefined, 0, 0, 1, 0, 0),\n    /* 0xC9 */ MDRP_MIRP.bind(undefined, 0, 0, 1, 0, 1),\n    /* 0xCA */ MDRP_MIRP.bind(undefined, 0, 0, 1, 0, 2),\n    /* 0xCB */ MDRP_MIRP.bind(undefined, 0, 0, 1, 0, 3),\n    /* 0xCC */ MDRP_MIRP.bind(undefined, 0, 0, 1, 1, 0),\n    /* 0xCD */ MDRP_MIRP.bind(undefined, 0, 0, 1, 1, 1),\n    /* 0xCE */ MDRP_MIRP.bind(undefined, 0, 0, 1, 1, 2),\n    /* 0xCF */ MDRP_MIRP.bind(undefined, 0, 0, 1, 1, 3),\n    /* 0xD0 */ MDRP_MIRP.bind(undefined, 0, 1, 0, 0, 0),\n    /* 0xD1 */ MDRP_MIRP.bind(undefined, 0, 1, 0, 0, 1),\n    /* 0xD2 */ MDRP_MIRP.bind(undefined, 0, 1, 0, 0, 2),\n    /* 0xD3 */ MDRP_MIRP.bind(undefined, 0, 1, 0, 0, 3),\n    /* 0xD4 */ MDRP_MIRP.bind(undefined, 0, 1, 0, 1, 0),\n    /* 0xD5 */ MDRP_MIRP.bind(undefined, 0, 1, 0, 1, 1),\n    /* 0xD6 */ MDRP_MIRP.bind(undefined, 0, 1, 0, 1, 2),\n    /* 0xD7 */ MDRP_MIRP.bind(undefined, 0, 1, 0, 1, 3),\n    /* 0xD8 */ MDRP_MIRP.bind(undefined, 0, 1, 1, 0, 0),\n    /* 0xD9 */ MDRP_MIRP.bind(undefined, 0, 1, 1, 0, 1),\n    /* 0xDA */ MDRP_MIRP.bind(undefined, 0, 1, 1, 0, 2),\n    /* 0xDB */ MDRP_MIRP.bind(undefined, 0, 1, 1, 0, 3),\n    /* 0xDC */ MDRP_MIRP.bind(undefined, 0, 1, 1, 1, 0),\n    /* 0xDD */ MDRP_MIRP.bind(undefined, 0, 1, 1, 1, 1),\n    /* 0xDE */ MDRP_MIRP.bind(undefined, 0, 1, 1, 1, 2),\n    /* 0xDF */ MDRP_MIRP.bind(undefined, 0, 1, 1, 1, 3),\n    /* 0xE0 */ MDRP_MIRP.bind(undefined, 1, 0, 0, 0, 0),\n    /* 0xE1 */ MDRP_MIRP.bind(undefined, 1, 0, 0, 0, 1),\n    /* 0xE2 */ MDRP_MIRP.bind(undefined, 1, 0, 0, 0, 2),\n    /* 0xE3 */ MDRP_MIRP.bind(undefined, 1, 0, 0, 0, 3),\n    /* 0xE4 */ MDRP_MIRP.bind(undefined, 1, 0, 0, 1, 0),\n    /* 0xE5 */ MDRP_MIRP.bind(undefined, 1, 0, 0, 1, 1),\n    /* 0xE6 */ MDRP_MIRP.bind(undefined, 1, 0, 0, 1, 2),\n    /* 0xE7 */ MDRP_MIRP.bind(undefined, 1, 0, 0, 1, 3),\n    /* 0xE8 */ MDRP_MIRP.bind(undefined, 1, 0, 1, 0, 0),\n    /* 0xE9 */ MDRP_MIRP.bind(undefined, 1, 0, 1, 0, 1),\n    /* 0xEA */ MDRP_MIRP.bind(undefined, 1, 0, 1, 0, 2),\n    /* 0xEB */ MDRP_MIRP.bind(undefined, 1, 0, 1, 0, 3),\n    /* 0xEC */ MDRP_MIRP.bind(undefined, 1, 0, 1, 1, 0),\n    /* 0xED */ MDRP_MIRP.bind(undefined, 1, 0, 1, 1, 1),\n    /* 0xEE */ MDRP_MIRP.bind(undefined, 1, 0, 1, 1, 2),\n    /* 0xEF */ MDRP_MIRP.bind(undefined, 1, 0, 1, 1, 3),\n    /* 0xF0 */ MDRP_MIRP.bind(undefined, 1, 1, 0, 0, 0),\n    /* 0xF1 */ MDRP_MIRP.bind(undefined, 1, 1, 0, 0, 1),\n    /* 0xF2 */ MDRP_MIRP.bind(undefined, 1, 1, 0, 0, 2),\n    /* 0xF3 */ MDRP_MIRP.bind(undefined, 1, 1, 0, 0, 3),\n    /* 0xF4 */ MDRP_MIRP.bind(undefined, 1, 1, 0, 1, 0),\n    /* 0xF5 */ MDRP_MIRP.bind(undefined, 1, 1, 0, 1, 1),\n    /* 0xF6 */ MDRP_MIRP.bind(undefined, 1, 1, 0, 1, 2),\n    /* 0xF7 */ MDRP_MIRP.bind(undefined, 1, 1, 0, 1, 3),\n    /* 0xF8 */ MDRP_MIRP.bind(undefined, 1, 1, 1, 0, 0),\n    /* 0xF9 */ MDRP_MIRP.bind(undefined, 1, 1, 1, 0, 1),\n    /* 0xFA */ MDRP_MIRP.bind(undefined, 1, 1, 1, 0, 2),\n    /* 0xFB */ MDRP_MIRP.bind(undefined, 1, 1, 1, 0, 3),\n    /* 0xFC */ MDRP_MIRP.bind(undefined, 1, 1, 1, 1, 0),\n    /* 0xFD */ MDRP_MIRP.bind(undefined, 1, 1, 1, 1, 1),\n    /* 0xFE */ MDRP_MIRP.bind(undefined, 1, 1, 1, 1, 2),\n    /* 0xFF */ MDRP_MIRP.bind(undefined, 1, 1, 1, 1, 3)\n];\n\n/*****************************\n  Mathematical Considerations\n******************************\n\nfv ... refers to freedom vector\npv ... refers to projection vector\nrp ... refers to reference point\np  ... refers to to point being operated on\nd  ... refers to distance\n\nSETRELATIVE:\n============\n\ncase freedom vector == x-axis:\n------------------------------\n\n                        (pv)\n                     .-'\n              rpd .-'\n               .-*\n          d .-'90°'\n         .-'       '\n      .-'           '\n   *-'               ' b\n  rp                  '\n                       '\n                        '\n            p *----------*-------------- (fv)\n                          pm\n\n  rpdx = rpx + d * pv.x\n  rpdy = rpy + d * pv.y\n\n  equation of line b\n\n   y - rpdy = pvns * (x- rpdx)\n\n   y = p.y\n\n   x = rpdx + ( p.y - rpdy ) / pvns\n\n\ncase freedom vector == y-axis:\n------------------------------\n\n    * pm\n    |\\\n    | \\\n    |  \\\n    |   \\\n    |    \\\n    |     \\\n    |      \\\n    |       \\\n    |        \\\n    |         \\ b\n    |          \\\n    |           \\\n    |            \\    .-' (pv)\n    |         90° \\.-'\n    |           .-'* rpd\n    |        .-'\n    *     *-'  d\n    p     rp\n\n  rpdx = rpx + d * pv.x\n  rpdy = rpy + d * pv.y\n\n  equation of line b:\n           pvns ... normal slope to pv\n\n   y - rpdy = pvns * (x - rpdx)\n\n   x = p.x\n\n   y = rpdy +  pvns * (p.x - rpdx)\n\n\n\ngeneric case:\n-------------\n\n\n                              .'(fv)\n                            .'\n                          .* pm\n                        .' !\n                      .'    .\n                    .'      !\n                  .'         . b\n                .'           !\n               *              .\n              p               !\n                         90°   .    ... (pv)\n                           ...-*-'''\n                  ...---'''    rpd\n         ...---'''   d\n   *--'''\n  rp\n\n    rpdx = rpx + d * pv.x\n    rpdy = rpy + d * pv.y\n\n equation of line b:\n    pvns... normal slope to pv\n\n    y - rpdy = pvns * (x - rpdx)\n\n equation of freedom vector line:\n    fvs ... slope of freedom vector (=fy/fx)\n\n    y - py = fvs * (x - px)\n\n\n  on pm both equations are true for same x/y\n\n    y - rpdy = pvns * (x - rpdx)\n\n    y - py = fvs * (x - px)\n\n  form to y and set equal:\n\n    pvns * (x - rpdx) + rpdy = fvs * (x - px) + py\n\n  expand:\n\n    pvns * x - pvns * rpdx + rpdy = fvs * x - fvs * px + py\n\n  switch:\n\n    fvs * x - fvs * px + py = pvns * x - pvns * rpdx + rpdy\n\n  solve for x:\n\n    fvs * x - pvns * x = fvs * px - pvns * rpdx - py + rpdy\n\n\n\n          fvs * px - pvns * rpdx + rpdy - py\n    x =  -----------------------------------\n                 fvs - pvns\n\n  and:\n\n    y = fvs * (x - px) + py\n\n\n\nINTERPOLATE:\n============\n\nExamples of point interpolation.\n\nThe weight of the movement of the reference point gets bigger\nthe further the other reference point is away, thus the safest\noption (that is avoiding 0/0 divisions) is to weight the\noriginal distance of the other point by the sum of both distances.\n\nIf the sum of both distances is 0, then move the point by the\narithmetic average of the movement of both reference points.\n\n\n\n\n           (+6)\n    rp1o *---->*rp1\n         .     .                          (+12)\n         .     .                  rp2o *---------->* rp2\n         .     .                       .           .\n         .     .                       .           .\n         .    10          20           .           .\n         |.........|...................|           .\n               .   .                               .\n               .   . (+8)                          .\n                po *------>*p                      .\n               .           .                       .\n               .    12     .          24           .\n               |...........|.......................|\n                                  36\n\n\n-------\n\n\n\n           (+10)\n    rp1o *-------->*rp1\n         .         .                      (-10)\n         .         .              rp2 *<---------* rpo2\n         .         .                   .         .\n         .         .                   .         .\n         .    10   .          30       .         .\n         |.........|.............................|\n                   .                   .\n                   . (+5)              .\n                po *--->* p            .\n                   .    .              .\n                   .    .   20         .\n                   |....|..............|\n                     5        15\n\n\n-------\n\n\n           (+10)\n    rp1o *-------->*rp1\n         .         .\n         .         .\n    rp2o *-------->*rp2\n\n\n                               (+10)\n                          po *-------->* p\n\n-------\n\n\n           (+10)\n    rp1o *-------->*rp1\n         .         .\n         .         .(+30)\n    rp2o *---------------------------->*rp2\n\n\n                                        (+25)\n                          po *----------------------->* p\n\n\n\nvim: set ts=4 sw=4 expandtab:\n*****/\n\n/**\n * Converts a string into a list of tokens.\n */\n\n/**\n * Create a new token\n * @param {string} char a single char\n */\nfunction Token(char) {\n    this.char = char;\n    this.state = {};\n    this.activeState = null;\n}\n\n/**\n * Create a new context range\n * @param {number} startIndex range start index\n * @param {number} endOffset range end index offset\n * @param {string} contextName owner context name\n */\nfunction ContextRange(startIndex, endOffset, contextName) {\n    this.contextName = contextName;\n    this.startIndex = startIndex;\n    this.endOffset = endOffset;\n}\n\n/**\n * Check context start and end\n * @param {string} contextName a unique context name\n * @param {function} checkStart a predicate function the indicates a context's start\n * @param {function} checkEnd a predicate function the indicates a context's end\n */\nfunction ContextChecker(contextName, checkStart, checkEnd) {\n    this.contextName = contextName;\n    this.openRange = null;\n    this.ranges = [];\n    this.checkStart = checkStart;\n    this.checkEnd = checkEnd;\n}\n\n/**\n * @typedef ContextParams\n * @type Object\n * @property {array} context context items\n * @property {number} currentIndex current item index\n */\n\n/**\n * Create a context params\n * @param {array} context a list of items\n * @param {number} currentIndex current item index\n */\nfunction ContextParams(context, currentIndex) {\n    this.context = context;\n    this.index = currentIndex;\n    this.length = context.length;\n    this.current = context[currentIndex];\n    this.backtrack = context.slice(0, currentIndex);\n    this.lookahead = context.slice(currentIndex + 1);\n}\n\n/**\n * Create an event instance\n * @param {string} eventId event unique id\n */\nfunction Event(eventId) {\n    this.eventId = eventId;\n    this.subscribers = [];\n}\n\n/**\n * Initialize a core events and auto subscribe required event handlers\n * @param {any} events an object that enlists core events handlers\n */\nfunction initializeCoreEvents(events) {\n    var this$1 = this;\n\n    var coreEvents = [\n        'start', 'end', 'next', 'newToken', 'contextStart',\n        'contextEnd', 'insertToken', 'removeToken', 'removeRange',\n        'replaceToken', 'replaceRange', 'composeRUD', 'updateContextsRanges'\n    ];\n\n    coreEvents.forEach(function (eventId) {\n        Object.defineProperty(this$1.events, eventId, {\n            value: new Event(eventId)\n        });\n    });\n\n    if (!!events) {\n        coreEvents.forEach(function (eventId) {\n            var event = events[eventId];\n            if (typeof event === 'function') {\n                this$1.events[eventId].subscribe(event);\n            }\n        });\n    }\n    var requiresContextUpdate = [\n        'insertToken', 'removeToken', 'removeRange',\n        'replaceToken', 'replaceRange', 'composeRUD'\n    ];\n    requiresContextUpdate.forEach(function (eventId) {\n        this$1.events[eventId].subscribe(\n            this$1.updateContextsRanges\n        );\n    });\n}\n\n/**\n * Converts a string into a list of tokens\n * @param {any} events tokenizer core events\n */\nfunction Tokenizer(events) {\n    this.tokens = [];\n    this.registeredContexts = {};\n    this.contextCheckers = [];\n    this.events = {};\n    this.registeredModifiers = [];\n\n    initializeCoreEvents.call(this, events);\n}\n\n/**\n * Sets the state of a token, usually called by a state modifier.\n * @param {string} key state item key\n * @param {any} value state item value\n */\nToken.prototype.setState = function(key, value) {\n    this.state[key] = value;\n    this.activeState = { key: key, value: this.state[key] };\n    return this.activeState;\n};\n\nToken.prototype.getState = function (stateId) {\n    return this.state[stateId] || null;\n};\n\n/**\n * Checks if an index exists in the tokens list.\n * @param {number} index token index\n */\nTokenizer.prototype.inboundIndex = function(index) {\n    return index >= 0 && index < this.tokens.length;\n};\n\n/**\n * Compose and apply a list of operations (replace, update, delete)\n * @param {array} RUDs replace, update and delete operations\n * TODO: Perf. Optimization (lengthBefore === lengthAfter ? dispatch once)\n */\nTokenizer.prototype.composeRUD = function (RUDs) {\n    var this$1 = this;\n\n    var silent = true;\n    var state = RUDs.map(function (RUD) { return (\n        this$1[RUD[0]].apply(this$1, RUD.slice(1).concat(silent))\n    ); });\n    var hasFAILObject = function (obj) { return (\n        typeof obj === 'object' &&\n        obj.hasOwnProperty('FAIL')\n    ); };\n    if (state.every(hasFAILObject)) {\n        return {\n            FAIL: \"composeRUD: one or more operations hasn't completed successfully\",\n            report: state.filter(hasFAILObject)\n        };\n    }\n    this.dispatch('composeRUD', [state.filter(function (op) { return !hasFAILObject(op); })]);\n};\n\n/**\n * Replace a range of tokens with a list of tokens\n * @param {number} startIndex range start index\n * @param {number} offset range offset\n * @param {token} tokens a list of tokens to replace\n * @param {boolean} silent dispatch events and update context ranges\n */\nTokenizer.prototype.replaceRange = function (startIndex, offset, tokens, silent) {\n    offset = offset !== null ? offset : this.tokens.length;\n    var isTokenType = tokens.every(function (token) { return token instanceof Token; });\n    if (!isNaN(startIndex) && this.inboundIndex(startIndex) && isTokenType) {\n        var replaced = this.tokens.splice.apply(\n            this.tokens, [startIndex, offset].concat(tokens)\n        );\n        if (!silent) { this.dispatch('replaceToken', [startIndex, offset, tokens]); }\n        return [replaced, tokens];\n    } else {\n        return { FAIL: 'replaceRange: invalid tokens or startIndex.' };\n    }\n};\n\n/**\n * Replace a token with another token\n * @param {number} index token index\n * @param {token} token a token to replace\n * @param {boolean} silent dispatch events and update context ranges\n */\nTokenizer.prototype.replaceToken = function (index, token, silent) {\n    if (!isNaN(index) && this.inboundIndex(index) && token instanceof Token) {\n        var replaced = this.tokens.splice(index, 1, token);\n        if (!silent) { this.dispatch('replaceToken', [index, token]); }\n        return [replaced[0], token];\n    } else {\n        return { FAIL: 'replaceToken: invalid token or index.' };\n    }\n};\n\n/**\n * Removes a range of tokens\n * @param {number} startIndex range start index\n * @param {number} offset range offset\n * @param {boolean} silent dispatch events and update context ranges\n */\nTokenizer.prototype.removeRange = function(startIndex, offset, silent) {\n    offset = !isNaN(offset) ? offset : this.tokens.length;\n    var tokens = this.tokens.splice(startIndex, offset);\n    if (!silent) { this.dispatch('removeRange', [tokens, startIndex, offset]); }\n    return tokens;\n};\n\n/**\n * Remove a token at a certain index\n * @param {number} index token index\n * @param {boolean} silent dispatch events and update context ranges\n */\nTokenizer.prototype.removeToken = function(index, silent) {\n    if (!isNaN(index) && this.inboundIndex(index)) {\n        var token = this.tokens.splice(index, 1);\n        if (!silent) { this.dispatch('removeToken', [token, index]); }\n        return token;\n    } else {\n        return { FAIL: 'removeToken: invalid token index.' };\n    }\n};\n\n/**\n * Insert a list of tokens at a certain index\n * @param {array} tokens a list of tokens to insert\n * @param {number} index insert the list of tokens at index\n * @param {boolean} silent dispatch events and update context ranges\n */\nTokenizer.prototype.insertToken = function (tokens, index, silent) {\n    var tokenType = tokens.every(\n        function (token) { return token instanceof Token; }\n    );\n    if (tokenType) {\n        this.tokens.splice.apply(\n            this.tokens, [index, 0].concat(tokens)\n        );\n        if (!silent) { this.dispatch('insertToken', [tokens, index]); }\n        return tokens;\n    } else {\n        return { FAIL: 'insertToken: invalid token(s).' };\n    }\n};\n\n/**\n * A state modifier that is called on 'newToken' event\n * @param {string} modifierId state modifier id\n * @param {function} condition a predicate function that returns true or false\n * @param {function} modifier a function to update token state\n */\nTokenizer.prototype.registerModifier = function(modifierId, condition, modifier) {\n    this.events.newToken.subscribe(function(token, contextParams) {\n        var conditionParams = [token, contextParams];\n        var canApplyModifier = (\n            condition === null ||\n            condition.apply(this, conditionParams) === true\n        );\n        var modifierParams = [token, contextParams];\n        if (canApplyModifier) {\n            var newStateValue = modifier.apply(this, modifierParams);\n            token.setState(modifierId, newStateValue);\n        }\n    });\n    this.registeredModifiers.push(modifierId);\n};\n\n/**\n * Subscribe a handler to an event\n * @param {function} eventHandler an event handler function\n */\nEvent.prototype.subscribe = function (eventHandler) {\n    if (typeof eventHandler === 'function') {\n        return ((this.subscribers.push(eventHandler)) - 1);\n    } else {\n        return { FAIL: (\"invalid '\" + (this.eventId) + \"' event handler\")};\n    }\n};\n\n/**\n * Unsubscribe an event handler\n * @param {string} subsId subscription id\n */\nEvent.prototype.unsubscribe = function (subsId) {\n    this.subscribers.splice(subsId, 1);\n};\n\n/**\n * Sets context params current value index\n * @param {number} index context params current value index\n */\nContextParams.prototype.setCurrentIndex = function(index) {\n    this.index = index;\n    this.current = this.context[index];\n    this.backtrack = this.context.slice(0, index);\n    this.lookahead = this.context.slice(index + 1);\n};\n\n/**\n * Get an item at an offset from the current value\n * example (current value is 3):\n *  1    2   [3]   4    5   |   items values\n * -2   -1    0    1    2   |   offset values\n * @param {number} offset an offset from current value index\n */\nContextParams.prototype.get = function (offset) {\n    switch (true) {\n        case (offset === 0):\n            return this.current;\n        case (offset < 0 && Math.abs(offset) <= this.backtrack.length):\n            return this.backtrack.slice(offset)[0];\n        case (offset > 0 && offset <= this.lookahead.length):\n            return this.lookahead[offset - 1];\n        default:\n            return null;\n    }\n};\n\n/**\n * Converts a context range into a string value\n * @param {contextRange} range a context range\n */\nTokenizer.prototype.rangeToText = function (range) {\n    if (range instanceof ContextRange) {\n        return (\n            this.getRangeTokens(range)\n                .map(function (token) { return token.char; }).join('')\n        );\n    }\n};\n\n/**\n * Converts all tokens into a string\n */\nTokenizer.prototype.getText = function () {\n    return this.tokens.map(function (token) { return token.char; }).join('');\n};\n\n/**\n * Get a context by name\n * @param {string} contextName context name to get\n */\nTokenizer.prototype.getContext = function (contextName) {\n    var context = this.registeredContexts[contextName];\n    return !!context ? context : null;\n};\n\n/**\n * Subscribes a new event handler to an event\n * @param {string} eventName event name to subscribe to\n * @param {function} eventHandler a function to be invoked on event\n */\nTokenizer.prototype.on = function(eventName, eventHandler) {\n    var event = this.events[eventName];\n    if (!!event) {\n        return event.subscribe(eventHandler);\n    } else {\n        return null;\n    }\n};\n\n/**\n * Dispatches an event\n * @param {string} eventName event name\n * @param {any} args event handler arguments\n */\nTokenizer.prototype.dispatch = function(eventName, args) {\n    var this$1 = this;\n\n    var event = this.events[eventName];\n    if (event instanceof Event) {\n        event.subscribers.forEach(function (subscriber) {\n            subscriber.apply(this$1, args || []);\n        });\n    }\n};\n\n/**\n * Register a new context checker\n * @param {string} contextName a unique context name\n * @param {function} contextStartCheck a predicate function that returns true on context start\n * @param {function} contextEndCheck  a predicate function that returns true on context end\n * TODO: call tokenize on registration to update context ranges with the new context.\n */\nTokenizer.prototype.registerContextChecker = function(contextName, contextStartCheck, contextEndCheck) {\n    if (!!this.getContext(contextName)) { return {\n        FAIL:\n        (\"context name '\" + contextName + \"' is already registered.\")\n    }; }\n    if (typeof contextStartCheck !== 'function') { return {\n        FAIL:\n        \"missing context start check.\"\n    }; }\n    if (typeof contextEndCheck !== 'function') { return {\n        FAIL:\n        \"missing context end check.\"\n    }; }\n    var contextCheckers = new ContextChecker(\n        contextName, contextStartCheck, contextEndCheck\n    );\n    this.registeredContexts[contextName] = contextCheckers;\n    this.contextCheckers.push(contextCheckers);\n    return contextCheckers;\n};\n\n/**\n * Gets a context range tokens\n * @param {contextRange} range a context range\n */\nTokenizer.prototype.getRangeTokens = function(range) {\n    var endIndex = range.startIndex + range.endOffset;\n    return [].concat(\n        this.tokens\n            .slice(range.startIndex, endIndex)\n    );\n};\n\n/**\n * Gets the ranges of a context\n * @param {string} contextName context name\n */\nTokenizer.prototype.getContextRanges = function(contextName) {\n    var context = this.getContext(contextName);\n    if (!!context) {\n        return context.ranges;\n    } else {\n        return { FAIL: (\"context checker '\" + contextName + \"' is not registered.\") };\n    }\n};\n\n/**\n * Resets context ranges to run context update\n */\nTokenizer.prototype.resetContextsRanges = function () {\n    var registeredContexts = this.registeredContexts;\n    for (var contextName in registeredContexts) {\n        if (registeredContexts.hasOwnProperty(contextName)) {\n            var context = registeredContexts[contextName];\n            context.ranges = [];\n        }\n    }\n};\n\n/**\n * Updates context ranges\n */\nTokenizer.prototype.updateContextsRanges = function () {\n    this.resetContextsRanges();\n    var chars = this.tokens.map(function (token) { return token.char; });\n    for (var i = 0; i < chars.length; i++) {\n        var contextParams = new ContextParams(chars, i);\n        this.runContextCheck(contextParams);\n    }\n    this.dispatch('updateContextsRanges', [this.registeredContexts]);\n};\n\n/**\n * Sets the end offset of an open range\n * @param {number} offset range end offset\n * @param {string} contextName context name\n */\nTokenizer.prototype.setEndOffset = function (offset, contextName) {\n    var startIndex = this.getContext(contextName).openRange.startIndex;\n    var range = new ContextRange(startIndex, offset, contextName);\n    var ranges = this.getContext(contextName).ranges;\n    range.rangeId = contextName + \".\" + (ranges.length);\n    ranges.push(range);\n    this.getContext(contextName).openRange = null;\n    return range;\n};\n\n/**\n * Runs a context check on the current context\n * @param {contextParams} contextParams current context params\n */\nTokenizer.prototype.runContextCheck = function(contextParams) {\n    var this$1 = this;\n\n    var index = contextParams.index;\n    this.contextCheckers.forEach(function (contextChecker) {\n        var contextName = contextChecker.contextName;\n        var openRange = this$1.getContext(contextName).openRange;\n        if (!openRange && contextChecker.checkStart(contextParams)) {\n            openRange = new ContextRange(index, null, contextName);\n            this$1.getContext(contextName).openRange = openRange;\n            this$1.dispatch('contextStart', [contextName, index]);\n        }\n        if (!!openRange && contextChecker.checkEnd(contextParams)) {\n            var offset = (index - openRange.startIndex) + 1;\n            var range = this$1.setEndOffset(offset, contextName);\n            this$1.dispatch('contextEnd', [contextName, range]);\n        }\n    });\n};\n\n/**\n * Converts a text into a list of tokens\n * @param {string} text a text to tokenize\n */\nTokenizer.prototype.tokenize = function (text) {\n    this.tokens = [];\n    this.resetContextsRanges();\n    var chars = Array.from(text);\n    this.dispatch('start');\n    for (var i = 0; i < chars.length; i++) {\n        var char = chars[i];\n        var contextParams = new ContextParams(chars, i);\n        this.dispatch('next', [contextParams]);\n        this.runContextCheck(contextParams);\n        var token = new Token(char);\n        this.tokens.push(token);\n        this.dispatch('newToken', [token, contextParams]);\n    }\n    this.dispatch('end', [this.tokens]);\n    return this.tokens;\n};\n\n// ╭─┄┄┄────────────────────────┄─────────────────────────────────────────────╮\n// ┊ Character Class Assertions ┊ Checks if a char belongs to a certain class ┊\n// ╰─╾──────────────────────────┄─────────────────────────────────────────────╯\n// jscs:disable maximumLineLength\n/**\n * Check if a char is Arabic\n * @param {string} c a single char\n */\nfunction isArabicChar(c) {\n    return /[\\u0600-\\u065F\\u066A-\\u06D2\\u06FA-\\u06FF]/.test(c);\n}\n\n/**\n * Check if a char is an isolated arabic char\n * @param {string} c a single char\n */\nfunction isIsolatedArabicChar(char) {\n    return /[\\u0630\\u0690\\u0621\\u0631\\u0661\\u0671\\u0622\\u0632\\u0672\\u0692\\u06C2\\u0623\\u0673\\u0693\\u06C3\\u0624\\u0694\\u06C4\\u0625\\u0675\\u0695\\u06C5\\u06E5\\u0676\\u0696\\u06C6\\u0627\\u0677\\u0697\\u06C7\\u0648\\u0688\\u0698\\u06C8\\u0689\\u0699\\u06C9\\u068A\\u06CA\\u066B\\u068B\\u06CB\\u068C\\u068D\\u06CD\\u06FD\\u068E\\u06EE\\u06FE\\u062F\\u068F\\u06CF\\u06EF]/.test(char);\n}\n\n/**\n * Check if a char is an Arabic Tashkeel char\n * @param {string} c a single char\n */\nfunction isTashkeelArabicChar(char) {\n    return /[\\u0600-\\u0605\\u060C-\\u060E\\u0610-\\u061B\\u061E\\u064B-\\u065F\\u0670\\u06D6-\\u06DC\\u06DF-\\u06E4\\u06E7\\u06E8\\u06EA-\\u06ED]/.test(char);\n}\n\n/**\n * Check if a char is Latin\n * @param {string} c a single char\n */\nfunction isLatinChar(c) {\n    return /[A-z]/.test(c);\n}\n\n/**\n * Check if a char is whitespace char\n * @param {string} c a single char\n */\nfunction isWhiteSpace(c) {\n    return /\\s/.test(c);\n}\n\n/**\n * Query a feature by some of it's properties to lookup a glyph substitution.\n */\n\n/**\n * Create feature query instance\n * @param {Font} font opentype font instance\n */\nfunction FeatureQuery(font) {\n    this.font = font;\n    this.features = {};\n}\n\n/**\n * @typedef SubstitutionAction\n * @type Object\n * @property {number} id substitution type\n * @property {string} tag feature tag\n * @property {any} substitution substitution value(s)\n */\n\n/**\n * Create a substitution action instance\n * @param {SubstitutionAction} action\n */\nfunction SubstitutionAction(action) {\n    this.id = action.id;\n    this.tag = action.tag;\n    this.substitution = action.substitution;\n}\n\n/**\n * Lookup a coverage table\n * @param {number} glyphIndex glyph index\n * @param {CoverageTable} coverage coverage table\n */\nfunction lookupCoverage(glyphIndex, coverage) {\n    if (!glyphIndex) { return -1; }\n    switch (coverage.format) {\n        case 1:\n            return coverage.glyphs.indexOf(glyphIndex);\n\n        case 2:\n            var ranges = coverage.ranges;\n            for (var i = 0; i < ranges.length; i++) {\n                var range = ranges[i];\n                if (glyphIndex >= range.start && glyphIndex <= range.end) {\n                    var offset = glyphIndex - range.start;\n                    return range.index + offset;\n                }\n            }\n            break;\n        default:\n            return -1; // not found\n    }\n    return -1;\n}\n\n/**\n * Handle a single substitution - format 1\n * @param {ContextParams} contextParams context params to lookup\n */\nfunction singleSubstitutionFormat1(glyphIndex, subtable) {\n    var substituteIndex = lookupCoverage(glyphIndex, subtable.coverage);\n    if (substituteIndex === -1) { return null; }\n    return glyphIndex + subtable.deltaGlyphId;\n}\n\n/**\n * Handle a single substitution - format 2\n * @param {ContextParams} contextParams context params to lookup\n */\nfunction singleSubstitutionFormat2(glyphIndex, subtable) {\n    var substituteIndex = lookupCoverage(glyphIndex, subtable.coverage);\n    if (substituteIndex === -1) { return null; }\n    return subtable.substitute[substituteIndex];\n}\n\n/**\n * Lookup a list of coverage tables\n * @param {any} coverageList a list of coverage tables\n * @param {ContextParams} contextParams context params to lookup\n */\nfunction lookupCoverageList(coverageList, contextParams) {\n    var lookupList = [];\n    for (var i = 0; i < coverageList.length; i++) {\n        var coverage = coverageList[i];\n        var glyphIndex = contextParams.current;\n        glyphIndex = Array.isArray(glyphIndex) ? glyphIndex[0] : glyphIndex;\n        var lookupIndex = lookupCoverage(glyphIndex, coverage);\n        if (lookupIndex !== -1) {\n            lookupList.push(lookupIndex);\n        }\n    }\n    if (lookupList.length !== coverageList.length) { return -1; }\n    return lookupList;\n}\n\n/**\n * Handle chaining context substitution - format 3\n * @param {ContextParams} contextParams context params to lookup\n */\nfunction chainingSubstitutionFormat3(contextParams, subtable) {\n    var lookupsCount = (\n        subtable.inputCoverage.length +\n        subtable.lookaheadCoverage.length +\n        subtable.backtrackCoverage.length\n    );\n    if (contextParams.context.length < lookupsCount) { return []; }\n    // INPUT LOOKUP //\n    var inputLookups = lookupCoverageList(\n        subtable.inputCoverage, contextParams\n    );\n    if (inputLookups === -1) { return []; }\n    // LOOKAHEAD LOOKUP //\n    var lookaheadOffset = subtable.inputCoverage.length - 1;\n    if (contextParams.lookahead.length < subtable.lookaheadCoverage.length) { return []; }\n    var lookaheadContext = contextParams.lookahead.slice(lookaheadOffset);\n    while (lookaheadContext.length && isTashkeelArabicChar(lookaheadContext[0].char)) {\n        lookaheadContext.shift();\n    }\n    var lookaheadParams = new ContextParams(lookaheadContext, 0);\n    var lookaheadLookups = lookupCoverageList(\n        subtable.lookaheadCoverage, lookaheadParams\n    );\n    // BACKTRACK LOOKUP //\n    var backtrackContext = [].concat(contextParams.backtrack);\n    backtrackContext.reverse();\n    while (backtrackContext.length && isTashkeelArabicChar(backtrackContext[0].char)) {\n        backtrackContext.shift();\n    }\n    if (backtrackContext.length < subtable.backtrackCoverage.length) { return []; }\n    var backtrackParams = new ContextParams(backtrackContext, 0);\n    var backtrackLookups = lookupCoverageList(\n        subtable.backtrackCoverage, backtrackParams\n    );\n    var contextRulesMatch = (\n        inputLookups.length === subtable.inputCoverage.length &&\n        lookaheadLookups.length === subtable.lookaheadCoverage.length &&\n        backtrackLookups.length === subtable.backtrackCoverage.length\n    );\n    var substitutions = [];\n    if (contextRulesMatch) {\n        for (var i = 0; i < subtable.lookupRecords.length; i++) {\n            var lookupRecord = subtable.lookupRecords[i];\n            var lookupListIndex = lookupRecord.lookupListIndex;\n            var lookupTable = this.getLookupByIndex(lookupListIndex);\n            for (var s = 0; s < lookupTable.subtables.length; s++) {\n                var subtable$1 = lookupTable.subtables[s];\n                var lookup = this.getLookupMethod(lookupTable, subtable$1);\n                var substitutionType = this.getSubstitutionType(lookupTable, subtable$1);\n                if (substitutionType === '12') {\n                    for (var n = 0; n < inputLookups.length; n++) {\n                        var glyphIndex = contextParams.get(n);\n                        var substitution = lookup(glyphIndex);\n                        if (substitution) { substitutions.push(substitution); }\n                    }\n                }\n            }\n        }\n    }\n    return substitutions;\n}\n\n/**\n * Handle ligature substitution - format 1\n * @param {ContextParams} contextParams context params to lookup\n */\nfunction ligatureSubstitutionFormat1(contextParams, subtable) {\n    // COVERAGE LOOKUP //\n    var glyphIndex = contextParams.current;\n    var ligSetIndex = lookupCoverage(glyphIndex, subtable.coverage);\n    if (ligSetIndex === -1) { return null; }\n    // COMPONENTS LOOKUP\n    // (!) note, components are ordered in the written direction.\n    var ligature;\n    var ligatureSet = subtable.ligatureSets[ligSetIndex];\n    for (var s = 0; s < ligatureSet.length; s++) {\n        ligature = ligatureSet[s];\n        for (var l = 0; l < ligature.components.length; l++) {\n            var lookaheadItem = contextParams.lookahead[l];\n            var component = ligature.components[l];\n            if (lookaheadItem !== component) { break; }\n            if (l === ligature.components.length - 1) { return ligature; }\n        }\n    }\n    return null;\n}\n\n/**\n * Handle decomposition substitution - format 1\n * @param {number} glyphIndex glyph index\n * @param {any} subtable subtable\n */\nfunction decompositionSubstitutionFormat1(glyphIndex, subtable) {\n    var substituteIndex = lookupCoverage(glyphIndex, subtable.coverage);\n    if (substituteIndex === -1) { return null; }\n    return subtable.sequences[substituteIndex];\n}\n\n/**\n * Get default script features indexes\n */\nFeatureQuery.prototype.getDefaultScriptFeaturesIndexes = function () {\n    var scripts = this.font.tables.gsub.scripts;\n    for (var s = 0; s < scripts.length; s++) {\n        var script = scripts[s];\n        if (script.tag === 'DFLT') { return (\n            script.script.defaultLangSys.featureIndexes\n        ); }\n    }\n    return [];\n};\n\n/**\n * Get feature indexes of a specific script\n * @param {string} scriptTag script tag\n */\nFeatureQuery.prototype.getScriptFeaturesIndexes = function(scriptTag) {\n    var tables = this.font.tables;\n    if (!tables.gsub) { return []; }\n    if (!scriptTag) { return this.getDefaultScriptFeaturesIndexes(); }\n    var scripts = this.font.tables.gsub.scripts;\n    for (var i = 0; i < scripts.length; i++) {\n        var script = scripts[i];\n        if (script.tag === scriptTag && script.script.defaultLangSys) {\n            return script.script.defaultLangSys.featureIndexes;\n        } else {\n            var langSysRecords = script.langSysRecords;\n            if (!!langSysRecords) {\n                for (var j = 0; j < langSysRecords.length; j++) {\n                    var langSysRecord = langSysRecords[j];\n                    if (langSysRecord.tag === scriptTag) {\n                        var langSys = langSysRecord.langSys;\n                        return langSys.featureIndexes;\n                    }\n                }\n            }\n        }\n    }\n    return this.getDefaultScriptFeaturesIndexes();\n};\n\n/**\n * Map a feature tag to a gsub feature\n * @param {any} features gsub features\n * @param {string} scriptTag script tag\n */\nFeatureQuery.prototype.mapTagsToFeatures = function (features, scriptTag) {\n    var tags = {};\n    for (var i = 0; i < features.length; i++) {\n        var tag = features[i].tag;\n        var feature = features[i].feature;\n        tags[tag] = feature;\n    }\n    this.features[scriptTag].tags = tags;\n};\n\n/**\n * Get features of a specific script\n * @param {string} scriptTag script tag\n */\nFeatureQuery.prototype.getScriptFeatures = function (scriptTag) {\n    var features = this.features[scriptTag];\n    if (this.features.hasOwnProperty(scriptTag)) { return features; }\n    var featuresIndexes = this.getScriptFeaturesIndexes(scriptTag);\n    if (!featuresIndexes) { return null; }\n    var gsub = this.font.tables.gsub;\n    features = featuresIndexes.map(function (index) { return gsub.features[index]; });\n    this.features[scriptTag] = features;\n    this.mapTagsToFeatures(features, scriptTag);\n    return features;\n};\n\n/**\n * Get substitution type\n * @param {any} lookupTable lookup table\n * @param {any} subtable subtable\n */\nFeatureQuery.prototype.getSubstitutionType = function(lookupTable, subtable) {\n    var lookupType = lookupTable.lookupType.toString();\n    var substFormat = subtable.substFormat.toString();\n    return lookupType + substFormat;\n};\n\n/**\n * Get lookup method\n * @param {any} lookupTable lookup table\n * @param {any} subtable subtable\n */\nFeatureQuery.prototype.getLookupMethod = function(lookupTable, subtable) {\n    var this$1 = this;\n\n    var substitutionType = this.getSubstitutionType(lookupTable, subtable);\n    switch (substitutionType) {\n        case '11':\n            return function (glyphIndex) { return singleSubstitutionFormat1.apply(\n                this$1, [glyphIndex, subtable]\n            ); };\n        case '12':\n            return function (glyphIndex) { return singleSubstitutionFormat2.apply(\n                this$1, [glyphIndex, subtable]\n            ); };\n        case '63':\n            return function (contextParams) { return chainingSubstitutionFormat3.apply(\n                this$1, [contextParams, subtable]\n            ); };\n        case '41':\n            return function (contextParams) { return ligatureSubstitutionFormat1.apply(\n                this$1, [contextParams, subtable]\n            ); };\n        case '21':\n            return function (glyphIndex) { return decompositionSubstitutionFormat1.apply(\n                this$1, [glyphIndex, subtable]\n            ); };\n        default:\n            throw new Error(\n                \"lookupType: \" + (lookupTable.lookupType) + \" - \" +\n                \"substFormat: \" + (subtable.substFormat) + \" \" +\n                \"is not yet supported\"\n            );\n    }\n};\n\n/**\n * [ LOOKUP TYPES ]\n * -------------------------------\n * Single                        1;\n * Multiple                      2;\n * Alternate                     3;\n * Ligature                      4;\n * Context                       5;\n * ChainingContext               6;\n * ExtensionSubstitution         7;\n * ReverseChainingContext        8;\n * -------------------------------\n *\n */\n\n/**\n * @typedef FQuery\n * @type Object\n * @param {string} tag feature tag\n * @param {string} script feature script\n * @param {ContextParams} contextParams context params\n */\n\n/**\n * Lookup a feature using a query parameters\n * @param {FQuery} query feature query\n */\nFeatureQuery.prototype.lookupFeature = function (query) {\n    var contextParams = query.contextParams;\n    var currentIndex = contextParams.index;\n    var feature = this.getFeature({\n        tag: query.tag, script: query.script\n    });\n    if (!feature) { return new Error(\n        \"font '\" + (this.font.names.fullName.en) + \"' \" +\n        \"doesn't support feature '\" + (query.tag) + \"' \" +\n        \"for script '\" + (query.script) + \"'.\"\n    ); }\n    var lookups = this.getFeatureLookups(feature);\n    var substitutions = [].concat(contextParams.context);\n    for (var l = 0; l < lookups.length; l++) {\n        var lookupTable = lookups[l];\n        var subtables = this.getLookupSubtables(lookupTable);\n        for (var s = 0; s < subtables.length; s++) {\n            var subtable = subtables[s];\n            var substType = this.getSubstitutionType(lookupTable, subtable);\n            var lookup = this.getLookupMethod(lookupTable, subtable);\n            var substitution = (void 0);\n            switch (substType) {\n                case '11':\n                    substitution = lookup(contextParams.current);\n                    if (substitution) {\n                        substitutions.splice(currentIndex, 1, new SubstitutionAction({\n                            id: 11, tag: query.tag, substitution: substitution\n                        }));\n                    }\n                    break;\n                case '12':\n                    substitution = lookup(contextParams.current);\n                    if (substitution) {\n                        substitutions.splice(currentIndex, 1, new SubstitutionAction({\n                            id: 12, tag: query.tag, substitution: substitution\n                        }));\n                    }\n                    break;\n                case '63':\n                    substitution = lookup(contextParams);\n                    if (Array.isArray(substitution) && substitution.length) {\n                        substitutions.splice(currentIndex, 1, new SubstitutionAction({\n                            id: 63, tag: query.tag, substitution: substitution\n                        }));\n                    }\n                    break;\n                case '41':\n                    substitution = lookup(contextParams);\n                    if (substitution) {\n                        substitutions.splice(currentIndex, 1, new SubstitutionAction({\n                            id: 41, tag: query.tag, substitution: substitution\n                        }));\n                    }\n                    break;\n                case '21':\n                    substitution = lookup(contextParams.current);\n                    if (substitution) {\n                        substitutions.splice(currentIndex, 1, new SubstitutionAction({\n                            id: 21, tag: query.tag, substitution: substitution\n                        }));\n                    }\n                    break;\n            }\n            contextParams = new ContextParams(substitutions, currentIndex);\n            if (Array.isArray(substitution) && !substitution.length) { continue; }\n            substitution = null;\n        }\n    }\n    return substitutions.length ? substitutions : null;\n};\n\n/**\n * Checks if a font supports a specific features\n * @param {FQuery} query feature query object\n */\nFeatureQuery.prototype.supports = function (query) {\n    if (!query.script) { return false; }\n    this.getScriptFeatures(query.script);\n    var supportedScript = this.features.hasOwnProperty(query.script);\n    if (!query.tag) { return supportedScript; }\n    var supportedFeature = (\n        this.features[query.script].some(function (feature) { return feature.tag === query.tag; })\n    );\n    return supportedScript && supportedFeature;\n};\n\n/**\n * Get lookup table subtables\n * @param {any} lookupTable lookup table\n */\nFeatureQuery.prototype.getLookupSubtables = function (lookupTable) {\n    return lookupTable.subtables || null;\n};\n\n/**\n * Get lookup table by index\n * @param {number} index lookup table index\n */\nFeatureQuery.prototype.getLookupByIndex = function (index) {\n    var lookups = this.font.tables.gsub.lookups;\n    return lookups[index] || null;\n};\n\n/**\n * Get lookup tables for a feature\n * @param {string} feature\n */\nFeatureQuery.prototype.getFeatureLookups = function (feature) {\n    // TODO: memoize\n    return feature.lookupListIndexes.map(this.getLookupByIndex.bind(this));\n};\n\n/**\n * Query a feature by it's properties\n * @param {any} query an object that describes the properties of a query\n */\nFeatureQuery.prototype.getFeature = function getFeature(query) {\n    if (!this.font) { return { FAIL: \"No font was found\"}; }\n    if (!this.features.hasOwnProperty(query.script)) {\n        this.getScriptFeatures(query.script);\n    }\n    var scriptFeatures = this.features[query.script];\n    if (!scriptFeatures) { return (\n        { FAIL: (\"No feature for script \" + (query.script))}\n    ); }\n    if (!scriptFeatures.tags[query.tag]) { return null; }\n    return this.features[query.script].tags[query.tag];\n};\n\n/**\n * Arabic word context checkers\n */\n\nfunction arabicWordStartCheck(contextParams) {\n    var char = contextParams.current;\n    var prevChar = contextParams.get(-1);\n    return (\n        // ? arabic first char\n        (prevChar === null && isArabicChar(char)) ||\n        // ? arabic char preceded with a non arabic char\n        (!isArabicChar(prevChar) && isArabicChar(char))\n    );\n}\n\nfunction arabicWordEndCheck(contextParams) {\n    var nextChar = contextParams.get(1);\n    return (\n        // ? last arabic char\n        (nextChar === null) ||\n        // ? next char is not arabic\n        (!isArabicChar(nextChar))\n    );\n}\n\nvar arabicWordCheck = {\n    startCheck: arabicWordStartCheck,\n    endCheck: arabicWordEndCheck\n};\n\n/**\n * Arabic sentence context checkers\n */\n\nfunction arabicSentenceStartCheck(contextParams) {\n    var char = contextParams.current;\n    var prevChar = contextParams.get(-1);\n    return (\n        // ? an arabic char preceded with a non arabic char\n        (isArabicChar(char) || isTashkeelArabicChar(char)) &&\n        !isArabicChar(prevChar)\n    );\n}\n\nfunction arabicSentenceEndCheck(contextParams) {\n    var nextChar = contextParams.get(1);\n    switch (true) {\n        case nextChar === null:\n            return true;\n        case (!isArabicChar(nextChar) && !isTashkeelArabicChar(nextChar)):\n            var nextIsWhitespace = isWhiteSpace(nextChar);\n            if (!nextIsWhitespace) { return true; }\n            if (nextIsWhitespace) {\n                var arabicCharAhead = false;\n                arabicCharAhead = (\n                    contextParams.lookahead.some(\n                        function (c) { return isArabicChar(c) || isTashkeelArabicChar(c); }\n                    )\n                );\n                if (!arabicCharAhead) { return true; }\n            }\n            break;\n        default:\n            return false;\n    }\n}\n\nvar arabicSentenceCheck = {\n    startCheck: arabicSentenceStartCheck,\n    endCheck: arabicSentenceEndCheck\n};\n\n/**\n * Apply single substitution format 1\n * @param {Array} substitutions substitutions\n * @param {any} tokens a list of tokens\n * @param {number} index token index\n */\nfunction singleSubstitutionFormat1$1(action, tokens, index) {\n    tokens[index].setState(action.tag, action.substitution);\n}\n\n/**\n * Apply single substitution format 2\n * @param {Array} substitutions substitutions\n * @param {any} tokens a list of tokens\n * @param {number} index token index\n */\nfunction singleSubstitutionFormat2$1(action, tokens, index) {\n    tokens[index].setState(action.tag, action.substitution);\n}\n\n/**\n * Apply chaining context substitution format 3\n * @param {Array} substitutions substitutions\n * @param {any} tokens a list of tokens\n * @param {number} index token index\n */\nfunction chainingSubstitutionFormat3$1(action, tokens, index) {\n    action.substitution.forEach(function (subst, offset) {\n        var token = tokens[index + offset];\n        token.setState(action.tag, subst);\n    });\n}\n\n/**\n * Apply ligature substitution format 1\n * @param {Array} substitutions substitutions\n * @param {any} tokens a list of tokens\n * @param {number} index token index\n */\nfunction ligatureSubstitutionFormat1$1(action, tokens, index) {\n    var token = tokens[index];\n    token.setState(action.tag, action.substitution.ligGlyph);\n    var compsCount = action.substitution.components.length;\n    for (var i = 0; i < compsCount; i++) {\n        token = tokens[index + i + 1];\n        token.setState('deleted', true);\n    }\n}\n\n/**\n * Supported substitutions\n */\nvar SUBSTITUTIONS = {\n    11: singleSubstitutionFormat1$1,\n    12: singleSubstitutionFormat2$1,\n    63: chainingSubstitutionFormat3$1,\n    41: ligatureSubstitutionFormat1$1\n};\n\n/**\n * Apply substitutions to a list of tokens\n * @param {Array} substitutions substitutions\n * @param {any} tokens a list of tokens\n * @param {number} index token index\n */\nfunction applySubstitution(action, tokens, index) {\n    if (action instanceof SubstitutionAction && SUBSTITUTIONS[action.id]) {\n        SUBSTITUTIONS[action.id](action, tokens, index);\n    }\n}\n\n/**\n * Apply Arabic presentation forms to a range of tokens\n */\n\n/**\n * Check if a char can be connected to it's preceding char\n * @param {ContextParams} charContextParams context params of a char\n */\nfunction willConnectPrev(charContextParams) {\n    var backtrack = [].concat(charContextParams.backtrack);\n    for (var i = backtrack.length - 1; i >= 0; i--) {\n        var prevChar = backtrack[i];\n        var isolated = isIsolatedArabicChar(prevChar);\n        var tashkeel = isTashkeelArabicChar(prevChar);\n        if (!isolated && !tashkeel) { return true; }\n        if (isolated) { return false; }\n    }\n    return false;\n}\n\n/**\n * Check if a char can be connected to it's proceeding char\n * @param {ContextParams} charContextParams context params of a char\n */\nfunction willConnectNext(charContextParams) {\n    if (isIsolatedArabicChar(charContextParams.current)) { return false; }\n    for (var i = 0; i < charContextParams.lookahead.length; i++) {\n        var nextChar = charContextParams.lookahead[i];\n        var tashkeel = isTashkeelArabicChar(nextChar);\n        if (!tashkeel) { return true; }\n    }\n    return false;\n}\n\n/**\n * Apply arabic presentation forms to a list of tokens\n * @param {ContextRange} range a range of tokens\n */\nfunction arabicPresentationForms(range) {\n    var this$1 = this;\n\n    var script = 'arab';\n    var tags = this.featuresTags[script];\n    var tokens = this.tokenizer.getRangeTokens(range);\n    if (tokens.length === 1) { return; }\n    var contextParams = new ContextParams(\n        tokens.map(function (token) { return token.getState('glyphIndex'); }\n    ), 0);\n    var charContextParams = new ContextParams(\n        tokens.map(function (token) { return token.char; }\n    ), 0);\n    tokens.forEach(function (token, index) {\n        if (isTashkeelArabicChar(token.char)) { return; }\n        contextParams.setCurrentIndex(index);\n        charContextParams.setCurrentIndex(index);\n        var CONNECT = 0; // 2 bits 00 (10: can connect next) (01: can connect prev)\n        if (willConnectPrev(charContextParams)) { CONNECT |= 1; }\n        if (willConnectNext(charContextParams)) { CONNECT |= 2; }\n        var tag;\n        switch (CONNECT) {\n            case 1: (tag = 'fina'); break;\n            case 2: (tag = 'init'); break;\n            case 3: (tag = 'medi'); break;\n        }\n        if (tags.indexOf(tag) === -1) { return; }\n        var substitutions = this$1.query.lookupFeature({\n            tag: tag, script: script, contextParams: contextParams\n        });\n        if (substitutions instanceof Error) { return console.info(substitutions.message); }\n        substitutions.forEach(function (action, index) {\n            if (action instanceof SubstitutionAction) {\n                applySubstitution(action, tokens, index);\n                contextParams.context[index] = action.substitution;\n            }\n        });\n    });\n}\n\n/**\n * Apply Arabic required ligatures feature to a range of tokens\n */\n\n/**\n * Update context params\n * @param {any} tokens a list of tokens\n * @param {number} index current item index\n */\nfunction getContextParams(tokens, index) {\n    var context = tokens.map(function (token) { return token.activeState.value; });\n    return new ContextParams(context, index || 0);\n}\n\n/**\n * Apply Arabic required ligatures to a context range\n * @param {ContextRange} range a range of tokens\n */\nfunction arabicRequiredLigatures(range) {\n    var this$1 = this;\n\n    var script = 'arab';\n    var tokens = this.tokenizer.getRangeTokens(range);\n    var contextParams = getContextParams(tokens);\n    contextParams.context.forEach(function (glyphIndex, index) {\n        contextParams.setCurrentIndex(index);\n        var substitutions = this$1.query.lookupFeature({\n            tag: 'rlig', script: script, contextParams: contextParams\n        });\n        if (substitutions.length) {\n            substitutions.forEach(\n                function (action) { return applySubstitution(action, tokens, index); }\n            );\n            contextParams = getContextParams(tokens);\n        }\n    });\n}\n\n/**\n * Latin word context checkers\n */\n\nfunction latinWordStartCheck(contextParams) {\n    var char = contextParams.current;\n    var prevChar = contextParams.get(-1);\n    return (\n        // ? latin first char\n        (prevChar === null && isLatinChar(char)) ||\n        // ? latin char preceded with a non latin char\n        (!isLatinChar(prevChar) && isLatinChar(char))\n    );\n}\n\nfunction latinWordEndCheck(contextParams) {\n    var nextChar = contextParams.get(1);\n    return (\n        // ? last latin char\n        (nextChar === null) ||\n        // ? next char is not latin\n        (!isLatinChar(nextChar))\n    );\n}\n\nvar latinWordCheck = {\n    startCheck: latinWordStartCheck,\n    endCheck: latinWordEndCheck\n};\n\n/**\n * Apply Latin ligature feature to a range of tokens\n */\n\n/**\n * Update context params\n * @param {any} tokens a list of tokens\n * @param {number} index current item index\n */\nfunction getContextParams$1(tokens, index) {\n    var context = tokens.map(function (token) { return token.activeState.value; });\n    return new ContextParams(context, index || 0);\n}\n\n/**\n * Apply Arabic required ligatures to a context range\n * @param {ContextRange} range a range of tokens\n */\nfunction latinLigature(range) {\n    var this$1 = this;\n\n    var script = 'latn';\n    var tokens = this.tokenizer.getRangeTokens(range);\n    var contextParams = getContextParams$1(tokens);\n    contextParams.context.forEach(function (glyphIndex, index) {\n        contextParams.setCurrentIndex(index);\n        var substitutions = this$1.query.lookupFeature({\n            tag: 'liga', script: script, contextParams: contextParams\n        });\n        if (substitutions.length) {\n            substitutions.forEach(\n                function (action) { return applySubstitution(action, tokens, index); }\n            );\n            contextParams = getContextParams$1(tokens);\n        }\n    });\n}\n\n/**\n * Infer bidirectional properties for a given text and apply\n * the corresponding layout rules.\n */\n\n/**\n * Create Bidi. features\n * @param {string} baseDir text base direction. value either 'ltr' or 'rtl'\n */\nfunction Bidi(baseDir) {\n    this.baseDir = baseDir || 'ltr';\n    this.tokenizer = new Tokenizer();\n    this.featuresTags = {};\n}\n\n/**\n * Sets Bidi text\n * @param {string} text a text input\n */\nBidi.prototype.setText = function (text) {\n    this.text = text;\n};\n\n/**\n * Store essential context checks:\n * arabic word check for applying gsub features\n * arabic sentence check for adjusting arabic layout\n */\nBidi.prototype.contextChecks = ({\n    latinWordCheck: latinWordCheck,\n    arabicWordCheck: arabicWordCheck,\n    arabicSentenceCheck: arabicSentenceCheck\n});\n\n/**\n * Register arabic word check\n */\nfunction registerContextChecker(checkId) {\n    var check = this.contextChecks[(checkId + \"Check\")];\n    return this.tokenizer.registerContextChecker(\n        checkId, check.startCheck, check.endCheck\n    );\n}\n\n/**\n * Perform pre tokenization procedure then\n * tokenize text input\n */\nfunction tokenizeText() {\n    registerContextChecker.call(this, 'latinWord');\n    registerContextChecker.call(this, 'arabicWord');\n    registerContextChecker.call(this, 'arabicSentence');\n    return this.tokenizer.tokenize(this.text);\n}\n\n/**\n * Reverse arabic sentence layout\n * TODO: check base dir before applying adjustments - priority low\n */\nfunction reverseArabicSentences() {\n    var this$1 = this;\n\n    var ranges = this.tokenizer.getContextRanges('arabicSentence');\n    ranges.forEach(function (range) {\n        var rangeTokens = this$1.tokenizer.getRangeTokens(range);\n        this$1.tokenizer.replaceRange(\n            range.startIndex,\n            range.endOffset,\n            rangeTokens.reverse()\n        );\n    });\n}\n\n/**\n * Register supported features tags\n * @param {script} script script tag\n * @param {Array} tags features tags list\n */\nBidi.prototype.registerFeatures = function (script, tags) {\n    var this$1 = this;\n\n    var supportedTags = tags.filter(\n        function (tag) { return this$1.query.supports({script: script, tag: tag}); }\n    );\n    if (!this.featuresTags.hasOwnProperty(script)) {\n        this.featuresTags[script] = supportedTags;\n    } else {\n        this.featuresTags[script] =\n        this.featuresTags[script].concat(supportedTags);\n    }\n};\n\n/**\n * Apply GSUB features\n * @param {Array} tagsList a list of features tags\n * @param {string} script a script tag\n * @param {Font} font opentype font instance\n */\nBidi.prototype.applyFeatures = function (font, features) {\n    if (!font) { throw new Error(\n        'No valid font was provided to apply features'\n    ); }\n    if (!this.query) { this.query = new FeatureQuery(font); }\n    for (var f = 0; f < features.length; f++) {\n        var feature = features[f];\n        if (!this.query.supports({script: feature.script})) { continue; }\n        this.registerFeatures(feature.script, feature.tags);\n    }\n};\n\n/**\n * Register a state modifier\n * @param {string} modifierId state modifier id\n * @param {function} condition a predicate function that returns true or false\n * @param {function} modifier a modifier function to set token state\n */\nBidi.prototype.registerModifier = function (modifierId, condition, modifier) {\n    this.tokenizer.registerModifier(modifierId, condition, modifier);\n};\n\n/**\n * Check if 'glyphIndex' is registered\n */\nfunction checkGlyphIndexStatus() {\n    if (this.tokenizer.registeredModifiers.indexOf('glyphIndex') === -1) {\n        throw new Error(\n            'glyphIndex modifier is required to apply ' +\n            'arabic presentation features.'\n        );\n    }\n}\n\n/**\n * Apply arabic presentation forms features\n */\nfunction applyArabicPresentationForms() {\n    var this$1 = this;\n\n    var script = 'arab';\n    if (!this.featuresTags.hasOwnProperty(script)) { return; }\n    checkGlyphIndexStatus.call(this);\n    var ranges = this.tokenizer.getContextRanges('arabicWord');\n    ranges.forEach(function (range) {\n        arabicPresentationForms.call(this$1, range);\n    });\n}\n\n/**\n * Apply required arabic ligatures\n */\nfunction applyArabicRequireLigatures() {\n    var this$1 = this;\n\n    var script = 'arab';\n    if (!this.featuresTags.hasOwnProperty(script)) { return; }\n    var tags = this.featuresTags[script];\n    if (tags.indexOf('rlig') === -1) { return; }\n    checkGlyphIndexStatus.call(this);\n    var ranges = this.tokenizer.getContextRanges('arabicWord');\n    ranges.forEach(function (range) {\n        arabicRequiredLigatures.call(this$1, range);\n    });\n}\n\n/**\n * Apply required arabic ligatures\n */\nfunction applyLatinLigatures() {\n    var this$1 = this;\n\n    var script = 'latn';\n    if (!this.featuresTags.hasOwnProperty(script)) { return; }\n    var tags = this.featuresTags[script];\n    if (tags.indexOf('liga') === -1) { return; }\n    checkGlyphIndexStatus.call(this);\n    var ranges = this.tokenizer.getContextRanges('latinWord');\n    ranges.forEach(function (range) {\n        latinLigature.call(this$1, range);\n    });\n}\n\n/**\n * Check if a context is registered\n * @param {string} contextId context id\n */\nBidi.prototype.checkContextReady = function (contextId) {\n    return !!this.tokenizer.getContext(contextId);\n};\n\n/**\n * Apply features to registered contexts\n */\nBidi.prototype.applyFeaturesToContexts = function () {\n    if (this.checkContextReady('arabicWord')) {\n        applyArabicPresentationForms.call(this);\n        applyArabicRequireLigatures.call(this);\n    }\n    if (this.checkContextReady('latinWord')) {\n        applyLatinLigatures.call(this);\n    }\n    if (this.checkContextReady('arabicSentence')) {\n        reverseArabicSentences.call(this);\n    }\n};\n\n/**\n * process text input\n * @param {string} text an input text\n */\nBidi.prototype.processText = function(text) {\n    if (!this.text || this.text !== text) {\n        this.setText(text);\n        tokenizeText.call(this);\n        this.applyFeaturesToContexts();\n    }\n};\n\n/**\n * Process a string of text to identify and adjust\n * bidirectional text entities.\n * @param {string} text input text\n */\nBidi.prototype.getBidiText = function (text) {\n    this.processText(text);\n    return this.tokenizer.getText();\n};\n\n/**\n * Get the current state index of each token\n * @param {text} text an input text\n */\nBidi.prototype.getTextGlyphs = function (text) {\n    this.processText(text);\n    var indexes = [];\n    for (var i = 0; i < this.tokenizer.tokens.length; i++) {\n        var token = this.tokenizer.tokens[i];\n        if (token.state.deleted) { continue; }\n        var index = token.activeState.value;\n        indexes.push(Array.isArray(index) ? index[0] : index);\n    }\n    return indexes;\n};\n\n// The Font object\n\n/**\n * @typedef FontOptions\n * @type Object\n * @property {Boolean} empty - whether to create a new empty font\n * @property {string} familyName\n * @property {string} styleName\n * @property {string=} fullName\n * @property {string=} postScriptName\n * @property {string=} designer\n * @property {string=} designerURL\n * @property {string=} manufacturer\n * @property {string=} manufacturerURL\n * @property {string=} license\n * @property {string=} licenseURL\n * @property {string=} version\n * @property {string=} description\n * @property {string=} copyright\n * @property {string=} trademark\n * @property {Number} unitsPerEm\n * @property {Number} ascender\n * @property {Number} descender\n * @property {Number} createdTimestamp\n * @property {string=} weightClass\n * @property {string=} widthClass\n * @property {string=} fsSelection\n */\n\n/**\n * A Font represents a loaded OpenType font file.\n * It contains a set of glyphs and methods to draw text on a drawing context,\n * or to get a path representing the text.\n * @exports opentype.Font\n * @class\n * @param {FontOptions}\n * @constructor\n */\nfunction Font(options) {\n    options = options || {};\n    options.tables = options.tables || {};\n\n    if (!options.empty) {\n        // Check that we've provided the minimum set of names.\n        checkArgument(options.familyName, 'When creating a new Font object, familyName is required.');\n        checkArgument(options.styleName, 'When creating a new Font object, styleName is required.');\n        checkArgument(options.unitsPerEm, 'When creating a new Font object, unitsPerEm is required.');\n        checkArgument(options.ascender, 'When creating a new Font object, ascender is required.');\n        checkArgument(options.descender <= 0, 'When creating a new Font object, negative descender value is required.');\n\n        // OS X will complain if the names are empty, so we put a single space everywhere by default.\n        this.names = {\n            fontFamily: {en: options.familyName || ' '},\n            fontSubfamily: {en: options.styleName || ' '},\n            fullName: {en: options.fullName || options.familyName + ' ' + options.styleName},\n            // postScriptName may not contain any whitespace\n            postScriptName: {en: options.postScriptName || (options.familyName + options.styleName).replace(/\\s/g, '')},\n            designer: {en: options.designer || ' '},\n            designerURL: {en: options.designerURL || ' '},\n            manufacturer: {en: options.manufacturer || ' '},\n            manufacturerURL: {en: options.manufacturerURL || ' '},\n            license: {en: options.license || ' '},\n            licenseURL: {en: options.licenseURL || ' '},\n            version: {en: options.version || 'Version 0.1'},\n            description: {en: options.description || ' '},\n            copyright: {en: options.copyright || ' '},\n            trademark: {en: options.trademark || ' '}\n        };\n        this.unitsPerEm = options.unitsPerEm || 1000;\n        this.ascender = options.ascender;\n        this.descender = options.descender;\n        this.createdTimestamp = options.createdTimestamp;\n        this.tables = Object.assign(options.tables, {\n            os2: Object.assign({\n                usWeightClass: options.weightClass || this.usWeightClasses.MEDIUM,\n                usWidthClass: options.widthClass || this.usWidthClasses.MEDIUM,\n                fsSelection: options.fsSelection || this.fsSelectionValues.REGULAR,\n            }, options.tables.os2)\n        });\n    }\n\n    this.supported = true; // Deprecated: parseBuffer will throw an error if font is not supported.\n    this.glyphs = new glyphset.GlyphSet(this, options.glyphs || []);\n    this.encoding = new DefaultEncoding(this);\n    this.position = new Position(this);\n    this.substitution = new Substitution(this);\n    this.tables = this.tables || {};\n\n    // needed for low memory mode only.\n    this._push = null;\n    this._hmtxTableData = {};\n\n    Object.defineProperty(this, 'hinting', {\n        get: function() {\n            if (this._hinting) { return this._hinting; }\n            if (this.outlinesFormat === 'truetype') {\n                return (this._hinting = new Hinting(this));\n            }\n        }\n    });\n}\n\n/**\n * Check if the font has a glyph for the given character.\n * @param  {string}\n * @return {Boolean}\n */\nFont.prototype.hasChar = function(c) {\n    return this.encoding.charToGlyphIndex(c) !== null;\n};\n\n/**\n * Convert the given character to a single glyph index.\n * Note that this function assumes that there is a one-to-one mapping between\n * the given character and a glyph; for complex scripts this might not be the case.\n * @param  {string}\n * @return {Number}\n */\nFont.prototype.charToGlyphIndex = function(s) {\n    return this.encoding.charToGlyphIndex(s);\n};\n\n/**\n * Convert the given character to a single Glyph object.\n * Note that this function assumes that there is a one-to-one mapping between\n * the given character and a glyph; for complex scripts this might not be the case.\n * @param  {string}\n * @return {opentype.Glyph}\n */\nFont.prototype.charToGlyph = function(c) {\n    var glyphIndex = this.charToGlyphIndex(c);\n    var glyph = this.glyphs.get(glyphIndex);\n    if (!glyph) {\n        // .notdef\n        glyph = this.glyphs.get(0);\n    }\n\n    return glyph;\n};\n\n/**\n * Update features\n * @param {any} options features options\n */\nFont.prototype.updateFeatures = function (options) {\n    // TODO: update all features options not only 'latn'.\n    return this.defaultRenderOptions.features.map(function (feature) {\n        if (feature.script === 'latn') {\n            return {\n                script: 'latn',\n                tags: feature.tags.filter(function (tag) { return options[tag]; })\n            };\n        } else {\n            return feature;\n        }\n    });\n};\n\n/**\n * Convert the given text to a list of Glyph objects.\n * Note that there is no strict one-to-one mapping between characters and\n * glyphs, so the list of returned glyphs can be larger or smaller than the\n * length of the given string.\n * @param  {string}\n * @param  {GlyphRenderOptions} [options]\n * @return {opentype.Glyph[]}\n */\nFont.prototype.stringToGlyphs = function(s, options) {\n    var this$1 = this;\n\n\n    var bidi = new Bidi();\n\n    // Create and register 'glyphIndex' state modifier\n    var charToGlyphIndexMod = function (token) { return this$1.charToGlyphIndex(token.char); };\n    bidi.registerModifier('glyphIndex', null, charToGlyphIndexMod);\n\n    // roll-back to default features\n    var features = options ?\n    this.updateFeatures(options.features) :\n    this.defaultRenderOptions.features;\n\n    bidi.applyFeatures(this, features);\n\n    var indexes = bidi.getTextGlyphs(s);\n\n    var length = indexes.length;\n\n    // convert glyph indexes to glyph objects\n    var glyphs = new Array(length);\n    var notdef = this.glyphs.get(0);\n    for (var i = 0; i < length; i += 1) {\n        glyphs[i] = this.glyphs.get(indexes[i]) || notdef;\n    }\n    return glyphs;\n};\n\n/**\n * @param  {string}\n * @return {Number}\n */\nFont.prototype.nameToGlyphIndex = function(name) {\n    return this.glyphNames.nameToGlyphIndex(name);\n};\n\n/**\n * @param  {string}\n * @return {opentype.Glyph}\n */\nFont.prototype.nameToGlyph = function(name) {\n    var glyphIndex = this.nameToGlyphIndex(name);\n    var glyph = this.glyphs.get(glyphIndex);\n    if (!glyph) {\n        // .notdef\n        glyph = this.glyphs.get(0);\n    }\n\n    return glyph;\n};\n\n/**\n * @param  {Number}\n * @return {String}\n */\nFont.prototype.glyphIndexToName = function(gid) {\n    if (!this.glyphNames.glyphIndexToName) {\n        return '';\n    }\n\n    return this.glyphNames.glyphIndexToName(gid);\n};\n\n/**\n * Retrieve the value of the kerning pair between the left glyph (or its index)\n * and the right glyph (or its index). If no kerning pair is found, return 0.\n * The kerning value gets added to the advance width when calculating the spacing\n * between glyphs.\n * For GPOS kerning, this method uses the default script and language, which covers\n * most use cases. To have greater control, use font.position.getKerningValue .\n * @param  {opentype.Glyph} leftGlyph\n * @param  {opentype.Glyph} rightGlyph\n * @return {Number}\n */\nFont.prototype.getKerningValue = function(leftGlyph, rightGlyph) {\n    leftGlyph = leftGlyph.index || leftGlyph;\n    rightGlyph = rightGlyph.index || rightGlyph;\n    var gposKerning = this.position.defaultKerningTables;\n    if (gposKerning) {\n        return this.position.getKerningValue(gposKerning, leftGlyph, rightGlyph);\n    }\n    // \"kern\" table\n    return this.kerningPairs[leftGlyph + ',' + rightGlyph] || 0;\n};\n\n/**\n * @typedef GlyphRenderOptions\n * @type Object\n * @property {string} [script] - script used to determine which features to apply. By default, 'DFLT' or 'latn' is used.\n *                               See https://www.microsoft.com/typography/otspec/scripttags.htm\n * @property {string} [language='dflt'] - language system used to determine which features to apply.\n *                                        See https://www.microsoft.com/typography/developers/opentype/languagetags.aspx\n * @property {boolean} [kerning=true] - whether to include kerning values\n * @property {object} [features] - OpenType Layout feature tags. Used to enable or disable the features of the given script/language system.\n *                                 See https://www.microsoft.com/typography/otspec/featuretags.htm\n */\nFont.prototype.defaultRenderOptions = {\n    kerning: true,\n    features: [\n        /**\n         * these 4 features are required to render Arabic text properly\n         * and shouldn't be turned off when rendering arabic text.\n         */\n        { script: 'arab', tags: ['init', 'medi', 'fina', 'rlig'] },\n        { script: 'latn', tags: ['liga', 'rlig'] }\n    ]\n};\n\n/**\n * Helper function that invokes the given callback for each glyph in the given text.\n * The callback gets `(glyph, x, y, fontSize, options)`.* @param  {string} text\n * @param {string} text - The text to apply.\n * @param  {number} [x=0] - Horizontal position of the beginning of the text.\n * @param  {number} [y=0] - Vertical position of the *baseline* of the text.\n * @param  {number} [fontSize=72] - Font size in pixels. We scale the glyph units by `1 / unitsPerEm * fontSize`.\n * @param  {GlyphRenderOptions=} options\n * @param  {Function} callback\n */\nFont.prototype.forEachGlyph = function(text, x, y, fontSize, options, callback) {\n    x = x !== undefined ? x : 0;\n    y = y !== undefined ? y : 0;\n    fontSize = fontSize !== undefined ? fontSize : 72;\n    options = Object.assign({}, this.defaultRenderOptions, options);\n    var fontScale = 1 / this.unitsPerEm * fontSize;\n    var glyphs = this.stringToGlyphs(text, options);\n    var kerningLookups;\n    if (options.kerning) {\n        var script = options.script || this.position.getDefaultScriptName();\n        kerningLookups = this.position.getKerningTables(script, options.language);\n    }\n    for (var i = 0; i < glyphs.length; i += 1) {\n        var glyph = glyphs[i];\n        callback.call(this, glyph, x, y, fontSize, options);\n        if (glyph.advanceWidth) {\n            x += glyph.advanceWidth * fontScale;\n        }\n\n        if (options.kerning && i < glyphs.length - 1) {\n            // We should apply position adjustment lookups in a more generic way.\n            // Here we only use the xAdvance value.\n            var kerningValue = kerningLookups ?\n                  this.position.getKerningValue(kerningLookups, glyph.index, glyphs[i + 1].index) :\n                  this.getKerningValue(glyph, glyphs[i + 1]);\n            x += kerningValue * fontScale;\n        }\n\n        if (options.letterSpacing) {\n            x += options.letterSpacing * fontSize;\n        } else if (options.tracking) {\n            x += (options.tracking / 1000) * fontSize;\n        }\n    }\n    return x;\n};\n\n/**\n * Create a Path object that represents the given text.\n * @param  {string} text - The text to create.\n * @param  {number} [x=0] - Horizontal position of the beginning of the text.\n * @param  {number} [y=0] - Vertical position of the *baseline* of the text.\n * @param  {number} [fontSize=72] - Font size in pixels. We scale the glyph units by `1 / unitsPerEm * fontSize`.\n * @param  {GlyphRenderOptions=} options\n * @return {opentype.Path}\n */\nFont.prototype.getPath = function(text, x, y, fontSize, options) {\n    var fullPath = new Path();\n    this.forEachGlyph(text, x, y, fontSize, options, function(glyph, gX, gY, gFontSize) {\n        var glyphPath = glyph.getPath(gX, gY, gFontSize, options, this);\n        fullPath.extend(glyphPath);\n    });\n    return fullPath;\n};\n\n/**\n * Create an array of Path objects that represent the glyphs of a given text.\n * @param  {string} text - The text to create.\n * @param  {number} [x=0] - Horizontal position of the beginning of the text.\n * @param  {number} [y=0] - Vertical position of the *baseline* of the text.\n * @param  {number} [fontSize=72] - Font size in pixels. We scale the glyph units by `1 / unitsPerEm * fontSize`.\n * @param  {GlyphRenderOptions=} options\n * @return {opentype.Path[]}\n */\nFont.prototype.getPaths = function(text, x, y, fontSize, options) {\n    var glyphPaths = [];\n    this.forEachGlyph(text, x, y, fontSize, options, function(glyph, gX, gY, gFontSize) {\n        var glyphPath = glyph.getPath(gX, gY, gFontSize, options, this);\n        glyphPaths.push(glyphPath);\n    });\n\n    return glyphPaths;\n};\n\n/**\n * Returns the advance width of a text.\n *\n * This is something different than Path.getBoundingBox() as for example a\n * suffixed whitespace increases the advanceWidth but not the bounding box\n * or an overhanging letter like a calligraphic 'f' might have a quite larger\n * bounding box than its advance width.\n *\n * This corresponds to canvas2dContext.measureText(text).width\n *\n * @param  {string} text - The text to create.\n * @param  {number} [fontSize=72] - Font size in pixels. We scale the glyph units by `1 / unitsPerEm * fontSize`.\n * @param  {GlyphRenderOptions=} options\n * @return advance width\n */\nFont.prototype.getAdvanceWidth = function(text, fontSize, options) {\n    return this.forEachGlyph(text, 0, 0, fontSize, options, function() {});\n};\n\n/**\n * Draw the text on the given drawing context.\n * @param  {CanvasRenderingContext2D} ctx - A 2D drawing context, like Canvas.\n * @param  {string} text - The text to create.\n * @param  {number} [x=0] - Horizontal position of the beginning of the text.\n * @param  {number} [y=0] - Vertical position of the *baseline* of the text.\n * @param  {number} [fontSize=72] - Font size in pixels. We scale the glyph units by `1 / unitsPerEm * fontSize`.\n * @param  {GlyphRenderOptions=} options\n */\nFont.prototype.draw = function(ctx, text, x, y, fontSize, options) {\n    this.getPath(text, x, y, fontSize, options).draw(ctx);\n};\n\n/**\n * Draw the points of all glyphs in the text.\n * On-curve points will be drawn in blue, off-curve points will be drawn in red.\n * @param {CanvasRenderingContext2D} ctx - A 2D drawing context, like Canvas.\n * @param {string} text - The text to create.\n * @param {number} [x=0] - Horizontal position of the beginning of the text.\n * @param {number} [y=0] - Vertical position of the *baseline* of the text.\n * @param {number} [fontSize=72] - Font size in pixels. We scale the glyph units by `1 / unitsPerEm * fontSize`.\n * @param {GlyphRenderOptions=} options\n */\nFont.prototype.drawPoints = function(ctx, text, x, y, fontSize, options) {\n    this.forEachGlyph(text, x, y, fontSize, options, function(glyph, gX, gY, gFontSize) {\n        glyph.drawPoints(ctx, gX, gY, gFontSize);\n    });\n};\n\n/**\n * Draw lines indicating important font measurements for all glyphs in the text.\n * Black lines indicate the origin of the coordinate system (point 0,0).\n * Blue lines indicate the glyph bounding box.\n * Green line indicates the advance width of the glyph.\n * @param {CanvasRenderingContext2D} ctx - A 2D drawing context, like Canvas.\n * @param {string} text - The text to create.\n * @param {number} [x=0] - Horizontal position of the beginning of the text.\n * @param {number} [y=0] - Vertical position of the *baseline* of the text.\n * @param {number} [fontSize=72] - Font size in pixels. We scale the glyph units by `1 / unitsPerEm * fontSize`.\n * @param {GlyphRenderOptions=} options\n */\nFont.prototype.drawMetrics = function(ctx, text, x, y, fontSize, options) {\n    this.forEachGlyph(text, x, y, fontSize, options, function(glyph, gX, gY, gFontSize) {\n        glyph.drawMetrics(ctx, gX, gY, gFontSize);\n    });\n};\n\n/**\n * @param  {string}\n * @return {string}\n */\nFont.prototype.getEnglishName = function(name) {\n    var translations = this.names[name];\n    if (translations) {\n        return translations.en;\n    }\n};\n\n/**\n * Validate\n */\nFont.prototype.validate = function() {\n    var _this = this;\n\n    function assert(predicate, message) {\n    }\n\n    function assertNamePresent(name) {\n        var englishName = _this.getEnglishName(name);\n        assert(englishName && englishName.trim().length > 0);\n    }\n\n    // Identification information\n    assertNamePresent('fontFamily');\n    assertNamePresent('weightName');\n    assertNamePresent('manufacturer');\n    assertNamePresent('copyright');\n    assertNamePresent('version');\n\n    // Dimension information\n    assert(this.unitsPerEm > 0);\n};\n\n/**\n * Convert the font object to a SFNT data structure.\n * This structure contains all the necessary tables and metadata to create a binary OTF file.\n * @return {opentype.Table}\n */\nFont.prototype.toTables = function() {\n    return sfnt.fontToTable(this);\n};\n/**\n * @deprecated Font.toBuffer is deprecated. Use Font.toArrayBuffer instead.\n */\nFont.prototype.toBuffer = function() {\n    console.warn('Font.toBuffer is deprecated. Use Font.toArrayBuffer instead.');\n    return this.toArrayBuffer();\n};\n/**\n * Converts a `opentype.Font` into an `ArrayBuffer`\n * @return {ArrayBuffer}\n */\nFont.prototype.toArrayBuffer = function() {\n    var sfntTable = this.toTables();\n    var bytes = sfntTable.encode();\n    var buffer = new ArrayBuffer(bytes.length);\n    var intArray = new Uint8Array(buffer);\n    for (var i = 0; i < bytes.length; i++) {\n        intArray[i] = bytes[i];\n    }\n\n    return buffer;\n};\n\n/**\n * Initiate a download of the OpenType font.\n */\nFont.prototype.download = function(fileName) {\n    var familyName = this.getEnglishName('fontFamily');\n    var styleName = this.getEnglishName('fontSubfamily');\n    fileName = fileName || familyName.replace(/\\s/g, '') + '-' + styleName + '.otf';\n    var arrayBuffer = this.toArrayBuffer();\n\n    if (isBrowser()) {\n        window.URL = window.URL || window.webkitURL;\n\n        if (window.URL) {\n            var dataView = new DataView(arrayBuffer);\n            var blob = new Blob([dataView], {type: 'font/opentype'});\n\n            var link = document.createElement('a');\n            link.href = window.URL.createObjectURL(blob);\n            link.download = fileName;\n\n            var event = document.createEvent('MouseEvents');\n            event.initEvent('click', true, false);\n            link.dispatchEvent(event);\n        } else {\n            console.warn('Font file could not be downloaded. Try using a different browser.');\n        }\n    } else {\n        var fs = __webpack_require__(/*! fs */ \"?3514\");\n        var buffer = arrayBufferToNodeBuffer(arrayBuffer);\n        fs.writeFileSync(fileName, buffer);\n    }\n};\n/**\n * @private\n */\nFont.prototype.fsSelectionValues = {\n    ITALIC:              0x001, //1\n    UNDERSCORE:          0x002, //2\n    NEGATIVE:            0x004, //4\n    OUTLINED:            0x008, //8\n    STRIKEOUT:           0x010, //16\n    BOLD:                0x020, //32\n    REGULAR:             0x040, //64\n    USER_TYPO_METRICS:   0x080, //128\n    WWS:                 0x100, //256\n    OBLIQUE:             0x200  //512\n};\n\n/**\n * @private\n */\nFont.prototype.usWidthClasses = {\n    ULTRA_CONDENSED: 1,\n    EXTRA_CONDENSED: 2,\n    CONDENSED: 3,\n    SEMI_CONDENSED: 4,\n    MEDIUM: 5,\n    SEMI_EXPANDED: 6,\n    EXPANDED: 7,\n    EXTRA_EXPANDED: 8,\n    ULTRA_EXPANDED: 9\n};\n\n/**\n * @private\n */\nFont.prototype.usWeightClasses = {\n    THIN: 100,\n    EXTRA_LIGHT: 200,\n    LIGHT: 300,\n    NORMAL: 400,\n    MEDIUM: 500,\n    SEMI_BOLD: 600,\n    BOLD: 700,\n    EXTRA_BOLD: 800,\n    BLACK:    900\n};\n\n// The `fvar` table stores font variation axes and instances.\n\nfunction addName(name, names) {\n    var nameString = JSON.stringify(name);\n    var nameID = 256;\n    for (var nameKey in names) {\n        var n = parseInt(nameKey);\n        if (!n || n < 256) {\n            continue;\n        }\n\n        if (JSON.stringify(names[nameKey]) === nameString) {\n            return n;\n        }\n\n        if (nameID <= n) {\n            nameID = n + 1;\n        }\n    }\n\n    names[nameID] = name;\n    return nameID;\n}\n\nfunction makeFvarAxis(n, axis, names) {\n    var nameID = addName(axis.name, names);\n    return [\n        {name: 'tag_' + n, type: 'TAG', value: axis.tag},\n        {name: 'minValue_' + n, type: 'FIXED', value: axis.minValue << 16},\n        {name: 'defaultValue_' + n, type: 'FIXED', value: axis.defaultValue << 16},\n        {name: 'maxValue_' + n, type: 'FIXED', value: axis.maxValue << 16},\n        {name: 'flags_' + n, type: 'USHORT', value: 0},\n        {name: 'nameID_' + n, type: 'USHORT', value: nameID}\n    ];\n}\n\nfunction parseFvarAxis(data, start, names) {\n    var axis = {};\n    var p = new parse.Parser(data, start);\n    axis.tag = p.parseTag();\n    axis.minValue = p.parseFixed();\n    axis.defaultValue = p.parseFixed();\n    axis.maxValue = p.parseFixed();\n    p.skip('uShort', 1);  // reserved for flags; no values defined\n    axis.name = names[p.parseUShort()] || {};\n    return axis;\n}\n\nfunction makeFvarInstance(n, inst, axes, names) {\n    var nameID = addName(inst.name, names);\n    var fields = [\n        {name: 'nameID_' + n, type: 'USHORT', value: nameID},\n        {name: 'flags_' + n, type: 'USHORT', value: 0}\n    ];\n\n    for (var i = 0; i < axes.length; ++i) {\n        var axisTag = axes[i].tag;\n        fields.push({\n            name: 'axis_' + n + ' ' + axisTag,\n            type: 'FIXED',\n            value: inst.coordinates[axisTag] << 16\n        });\n    }\n\n    return fields;\n}\n\nfunction parseFvarInstance(data, start, axes, names) {\n    var inst = {};\n    var p = new parse.Parser(data, start);\n    inst.name = names[p.parseUShort()] || {};\n    p.skip('uShort', 1);  // reserved for flags; no values defined\n\n    inst.coordinates = {};\n    for (var i = 0; i < axes.length; ++i) {\n        inst.coordinates[axes[i].tag] = p.parseFixed();\n    }\n\n    return inst;\n}\n\nfunction makeFvarTable(fvar, names) {\n    var result = new table.Table('fvar', [\n        {name: 'version', type: 'ULONG', value: 0x10000},\n        {name: 'offsetToData', type: 'USHORT', value: 0},\n        {name: 'countSizePairs', type: 'USHORT', value: 2},\n        {name: 'axisCount', type: 'USHORT', value: fvar.axes.length},\n        {name: 'axisSize', type: 'USHORT', value: 20},\n        {name: 'instanceCount', type: 'USHORT', value: fvar.instances.length},\n        {name: 'instanceSize', type: 'USHORT', value: 4 + fvar.axes.length * 4}\n    ]);\n    result.offsetToData = result.sizeOf();\n\n    for (var i = 0; i < fvar.axes.length; i++) {\n        result.fields = result.fields.concat(makeFvarAxis(i, fvar.axes[i], names));\n    }\n\n    for (var j = 0; j < fvar.instances.length; j++) {\n        result.fields = result.fields.concat(makeFvarInstance(j, fvar.instances[j], fvar.axes, names));\n    }\n\n    return result;\n}\n\nfunction parseFvarTable(data, start, names) {\n    var p = new parse.Parser(data, start);\n    var tableVersion = p.parseULong();\n    check.argument(tableVersion === 0x00010000, 'Unsupported fvar table version.');\n    var offsetToData = p.parseOffset16();\n    // Skip countSizePairs.\n    p.skip('uShort', 1);\n    var axisCount = p.parseUShort();\n    var axisSize = p.parseUShort();\n    var instanceCount = p.parseUShort();\n    var instanceSize = p.parseUShort();\n\n    var axes = [];\n    for (var i = 0; i < axisCount; i++) {\n        axes.push(parseFvarAxis(data, start + offsetToData + i * axisSize, names));\n    }\n\n    var instances = [];\n    var instanceStart = start + offsetToData + axisCount * axisSize;\n    for (var j = 0; j < instanceCount; j++) {\n        instances.push(parseFvarInstance(data, instanceStart + j * instanceSize, axes, names));\n    }\n\n    return {axes: axes, instances: instances};\n}\n\nvar fvar = { make: makeFvarTable, parse: parseFvarTable };\n\n// The `GDEF` table contains various glyph properties\n\nvar attachList = function() {\n    return {\n        coverage: this.parsePointer(Parser.coverage),\n        attachPoints: this.parseList(Parser.pointer(Parser.uShortList))\n    };\n};\n\nvar caretValue = function() {\n    var format = this.parseUShort();\n    check.argument(format === 1 || format === 2 || format === 3,\n        'Unsupported CaretValue table version.');\n    if (format === 1) {\n        return { coordinate: this.parseShort() };\n    } else if (format === 2) {\n        return { pointindex: this.parseShort() };\n    } else if (format === 3) {\n        // Device / Variation Index tables unsupported\n        return { coordinate: this.parseShort() };\n    }\n};\n\nvar ligGlyph = function() {\n    return this.parseList(Parser.pointer(caretValue));\n};\n\nvar ligCaretList = function() {\n    return {\n        coverage: this.parsePointer(Parser.coverage),\n        ligGlyphs: this.parseList(Parser.pointer(ligGlyph))\n    };\n};\n\nvar markGlyphSets = function() {\n    this.parseUShort(); // Version\n    return this.parseList(Parser.pointer(Parser.coverage));\n};\n\nfunction parseGDEFTable(data, start) {\n    start = start || 0;\n    var p = new Parser(data, start);\n    var tableVersion = p.parseVersion(1);\n    check.argument(tableVersion === 1 || tableVersion === 1.2 || tableVersion === 1.3,\n        'Unsupported GDEF table version.');\n    var gdef = {\n        version: tableVersion,\n        classDef: p.parsePointer(Parser.classDef),\n        attachList: p.parsePointer(attachList),\n        ligCaretList: p.parsePointer(ligCaretList),\n        markAttachClassDef: p.parsePointer(Parser.classDef)\n    };\n    if (tableVersion >= 1.2) {\n        gdef.markGlyphSets = p.parsePointer(markGlyphSets);\n    }\n    return gdef;\n}\nvar gdef = { parse: parseGDEFTable };\n\n// The `GPOS` table contains kerning pairs, among other things.\n\nvar subtableParsers$1 = new Array(10);         // subtableParsers[0] is unused\n\n// https://docs.microsoft.com/en-us/typography/opentype/spec/gpos#lookup-type-1-single-adjustment-positioning-subtable\n// this = Parser instance\nsubtableParsers$1[1] = function parseLookup1() {\n    var start = this.offset + this.relativeOffset;\n    var posformat = this.parseUShort();\n    if (posformat === 1) {\n        return {\n            posFormat: 1,\n            coverage: this.parsePointer(Parser.coverage),\n            value: this.parseValueRecord()\n        };\n    } else if (posformat === 2) {\n        return {\n            posFormat: 2,\n            coverage: this.parsePointer(Parser.coverage),\n            values: this.parseValueRecordList()\n        };\n    }\n    check.assert(false, '0x' + start.toString(16) + ': GPOS lookup type 1 format must be 1 or 2.');\n};\n\n// https://docs.microsoft.com/en-us/typography/opentype/spec/gpos#lookup-type-2-pair-adjustment-positioning-subtable\nsubtableParsers$1[2] = function parseLookup2() {\n    var start = this.offset + this.relativeOffset;\n    var posFormat = this.parseUShort();\n    check.assert(posFormat === 1 || posFormat === 2, '0x' + start.toString(16) + ': GPOS lookup type 2 format must be 1 or 2.');\n    var coverage = this.parsePointer(Parser.coverage);\n    var valueFormat1 = this.parseUShort();\n    var valueFormat2 = this.parseUShort();\n    if (posFormat === 1) {\n        // Adjustments for Glyph Pairs\n        return {\n            posFormat: posFormat,\n            coverage: coverage,\n            valueFormat1: valueFormat1,\n            valueFormat2: valueFormat2,\n            pairSets: this.parseList(Parser.pointer(Parser.list(function() {\n                return {        // pairValueRecord\n                    secondGlyph: this.parseUShort(),\n                    value1: this.parseValueRecord(valueFormat1),\n                    value2: this.parseValueRecord(valueFormat2)\n                };\n            })))\n        };\n    } else if (posFormat === 2) {\n        var classDef1 = this.parsePointer(Parser.classDef);\n        var classDef2 = this.parsePointer(Parser.classDef);\n        var class1Count = this.parseUShort();\n        var class2Count = this.parseUShort();\n        return {\n            // Class Pair Adjustment\n            posFormat: posFormat,\n            coverage: coverage,\n            valueFormat1: valueFormat1,\n            valueFormat2: valueFormat2,\n            classDef1: classDef1,\n            classDef2: classDef2,\n            class1Count: class1Count,\n            class2Count: class2Count,\n            classRecords: this.parseList(class1Count, Parser.list(class2Count, function() {\n                return {\n                    value1: this.parseValueRecord(valueFormat1),\n                    value2: this.parseValueRecord(valueFormat2)\n                };\n            }))\n        };\n    }\n};\n\nsubtableParsers$1[3] = function parseLookup3() { return { error: 'GPOS Lookup 3 not supported' }; };\nsubtableParsers$1[4] = function parseLookup4() { return { error: 'GPOS Lookup 4 not supported' }; };\nsubtableParsers$1[5] = function parseLookup5() { return { error: 'GPOS Lookup 5 not supported' }; };\nsubtableParsers$1[6] = function parseLookup6() { return { error: 'GPOS Lookup 6 not supported' }; };\nsubtableParsers$1[7] = function parseLookup7() { return { error: 'GPOS Lookup 7 not supported' }; };\nsubtableParsers$1[8] = function parseLookup8() { return { error: 'GPOS Lookup 8 not supported' }; };\nsubtableParsers$1[9] = function parseLookup9() { return { error: 'GPOS Lookup 9 not supported' }; };\n\n// https://docs.microsoft.com/en-us/typography/opentype/spec/gpos\nfunction parseGposTable(data, start) {\n    start = start || 0;\n    var p = new Parser(data, start);\n    var tableVersion = p.parseVersion(1);\n    check.argument(tableVersion === 1 || tableVersion === 1.1, 'Unsupported GPOS table version ' + tableVersion);\n\n    if (tableVersion === 1) {\n        return {\n            version: tableVersion,\n            scripts: p.parseScriptList(),\n            features: p.parseFeatureList(),\n            lookups: p.parseLookupList(subtableParsers$1)\n        };\n    } else {\n        return {\n            version: tableVersion,\n            scripts: p.parseScriptList(),\n            features: p.parseFeatureList(),\n            lookups: p.parseLookupList(subtableParsers$1),\n            variations: p.parseFeatureVariationsList()\n        };\n    }\n\n}\n\n// GPOS Writing //////////////////////////////////////////////\n// NOT SUPPORTED\nvar subtableMakers$1 = new Array(10);\n\nfunction makeGposTable(gpos) {\n    return new table.Table('GPOS', [\n        {name: 'version', type: 'ULONG', value: 0x10000},\n        {name: 'scripts', type: 'TABLE', value: new table.ScriptList(gpos.scripts)},\n        {name: 'features', type: 'TABLE', value: new table.FeatureList(gpos.features)},\n        {name: 'lookups', type: 'TABLE', value: new table.LookupList(gpos.lookups, subtableMakers$1)}\n    ]);\n}\n\nvar gpos = { parse: parseGposTable, make: makeGposTable };\n\n// The `kern` table contains kerning pairs.\n\nfunction parseWindowsKernTable(p) {\n    var pairs = {};\n    // Skip nTables.\n    p.skip('uShort');\n    var subtableVersion = p.parseUShort();\n    check.argument(subtableVersion === 0, 'Unsupported kern sub-table version.');\n    // Skip subtableLength, subtableCoverage\n    p.skip('uShort', 2);\n    var nPairs = p.parseUShort();\n    // Skip searchRange, entrySelector, rangeShift.\n    p.skip('uShort', 3);\n    for (var i = 0; i < nPairs; i += 1) {\n        var leftIndex = p.parseUShort();\n        var rightIndex = p.parseUShort();\n        var value = p.parseShort();\n        pairs[leftIndex + ',' + rightIndex] = value;\n    }\n    return pairs;\n}\n\nfunction parseMacKernTable(p) {\n    var pairs = {};\n    // The Mac kern table stores the version as a fixed (32 bits) but we only loaded the first 16 bits.\n    // Skip the rest.\n    p.skip('uShort');\n    var nTables = p.parseULong();\n    //check.argument(nTables === 1, 'Only 1 subtable is supported (got ' + nTables + ').');\n    if (nTables > 1) {\n        console.warn('Only the first kern subtable is supported.');\n    }\n    p.skip('uLong');\n    var coverage = p.parseUShort();\n    var subtableVersion = coverage & 0xFF;\n    p.skip('uShort');\n    if (subtableVersion === 0) {\n        var nPairs = p.parseUShort();\n        // Skip searchRange, entrySelector, rangeShift.\n        p.skip('uShort', 3);\n        for (var i = 0; i < nPairs; i += 1) {\n            var leftIndex = p.parseUShort();\n            var rightIndex = p.parseUShort();\n            var value = p.parseShort();\n            pairs[leftIndex + ',' + rightIndex] = value;\n        }\n    }\n    return pairs;\n}\n\n// Parse the `kern` table which contains kerning pairs.\nfunction parseKernTable(data, start) {\n    var p = new parse.Parser(data, start);\n    var tableVersion = p.parseUShort();\n    if (tableVersion === 0) {\n        return parseWindowsKernTable(p);\n    } else if (tableVersion === 1) {\n        return parseMacKernTable(p);\n    } else {\n        throw new Error('Unsupported kern table version (' + tableVersion + ').');\n    }\n}\n\nvar kern = { parse: parseKernTable };\n\n// The `loca` table stores the offsets to the locations of the glyphs in the font.\n\n// Parse the `loca` table. This table stores the offsets to the locations of the glyphs in the font,\n// relative to the beginning of the glyphData table.\n// The number of glyphs stored in the `loca` table is specified in the `maxp` table (under numGlyphs)\n// The loca table has two versions: a short version where offsets are stored as uShorts, and a long\n// version where offsets are stored as uLongs. The `head` table specifies which version to use\n// (under indexToLocFormat).\nfunction parseLocaTable(data, start, numGlyphs, shortVersion) {\n    var p = new parse.Parser(data, start);\n    var parseFn = shortVersion ? p.parseUShort : p.parseULong;\n    // There is an extra entry after the last index element to compute the length of the last glyph.\n    // That's why we use numGlyphs + 1.\n    var glyphOffsets = [];\n    for (var i = 0; i < numGlyphs + 1; i += 1) {\n        var glyphOffset = parseFn.call(p);\n        if (shortVersion) {\n            // The short table version stores the actual offset divided by 2.\n            glyphOffset *= 2;\n        }\n\n        glyphOffsets.push(glyphOffset);\n    }\n\n    return glyphOffsets;\n}\n\nvar loca = { parse: parseLocaTable };\n\n// opentype.js\n\n/**\n * The opentype library.\n * @namespace opentype\n */\n\n// File loaders /////////////////////////////////////////////////////////\n/**\n * Loads a font from a file. The callback throws an error message as the first parameter if it fails\n * and the font as an ArrayBuffer in the second parameter if it succeeds.\n * @param  {string} path - The path of the file\n * @param  {Function} callback - The function to call when the font load completes\n */\nfunction loadFromFile(path, callback) {\n    var fs = __webpack_require__(/*! fs */ \"?3514\");\n    fs.readFile(path, function(err, buffer) {\n        if (err) {\n            return callback(err.message);\n        }\n\n        callback(null, nodeBufferToArrayBuffer(buffer));\n    });\n}\n/**\n * Loads a font from a URL. The callback throws an error message as the first parameter if it fails\n * and the font as an ArrayBuffer in the second parameter if it succeeds.\n * @param  {string} url - The URL of the font file.\n * @param  {Function} callback - The function to call when the font load completes\n */\nfunction loadFromUrl(url, callback) {\n    var request = new XMLHttpRequest();\n    request.open('get', url, true);\n    request.responseType = 'arraybuffer';\n    request.onload = function() {\n        if (request.response) {\n            return callback(null, request.response);\n        } else {\n            return callback('Font could not be loaded: ' + request.statusText);\n        }\n    };\n\n    request.onerror = function () {\n        callback('Font could not be loaded');\n    };\n\n    request.send();\n}\n\n// Table Directory Entries //////////////////////////////////////////////\n/**\n * Parses OpenType table entries.\n * @param  {DataView}\n * @param  {Number}\n * @return {Object[]}\n */\nfunction parseOpenTypeTableEntries(data, numTables) {\n    var tableEntries = [];\n    var p = 12;\n    for (var i = 0; i < numTables; i += 1) {\n        var tag = parse.getTag(data, p);\n        var checksum = parse.getULong(data, p + 4);\n        var offset = parse.getULong(data, p + 8);\n        var length = parse.getULong(data, p + 12);\n        tableEntries.push({tag: tag, checksum: checksum, offset: offset, length: length, compression: false});\n        p += 16;\n    }\n\n    return tableEntries;\n}\n\n/**\n * Parses WOFF table entries.\n * @param  {DataView}\n * @param  {Number}\n * @return {Object[]}\n */\nfunction parseWOFFTableEntries(data, numTables) {\n    var tableEntries = [];\n    var p = 44; // offset to the first table directory entry.\n    for (var i = 0; i < numTables; i += 1) {\n        var tag = parse.getTag(data, p);\n        var offset = parse.getULong(data, p + 4);\n        var compLength = parse.getULong(data, p + 8);\n        var origLength = parse.getULong(data, p + 12);\n        var compression = (void 0);\n        if (compLength < origLength) {\n            compression = 'WOFF';\n        } else {\n            compression = false;\n        }\n\n        tableEntries.push({tag: tag, offset: offset, compression: compression,\n            compressedLength: compLength, length: origLength});\n        p += 20;\n    }\n\n    return tableEntries;\n}\n\n/**\n * @typedef TableData\n * @type Object\n * @property {DataView} data - The DataView\n * @property {number} offset - The data offset.\n */\n\n/**\n * @param  {DataView}\n * @param  {Object}\n * @return {TableData}\n */\nfunction uncompressTable(data, tableEntry) {\n    if (tableEntry.compression === 'WOFF') {\n        var inBuffer = new Uint8Array(data.buffer, tableEntry.offset + 2, tableEntry.compressedLength - 2);\n        var outBuffer = new Uint8Array(tableEntry.length);\n        tinyInflate(inBuffer, outBuffer);\n        if (outBuffer.byteLength !== tableEntry.length) {\n            throw new Error('Decompression error: ' + tableEntry.tag + ' decompressed length doesn\\'t match recorded length');\n        }\n\n        var view = new DataView(outBuffer.buffer, 0);\n        return {data: view, offset: 0};\n    } else {\n        return {data: data, offset: tableEntry.offset};\n    }\n}\n\n// Public API ///////////////////////////////////////////////////////////\n\n/**\n * Parse the OpenType file data (as an ArrayBuffer) and return a Font object.\n * Throws an error if the font could not be parsed.\n * @param  {ArrayBuffer}\n * @param  {Object} opt - options for parsing\n * @return {opentype.Font}\n */\nfunction parseBuffer(buffer, opt) {\n    opt = (opt === undefined || opt === null) ?  {} : opt;\n\n    var indexToLocFormat;\n    var ltagTable;\n\n    // Since the constructor can also be called to create new fonts from scratch, we indicate this\n    // should be an empty font that we'll fill with our own data.\n    var font = new Font({empty: true});\n\n    // OpenType fonts use big endian byte ordering.\n    // We can't rely on typed array view types, because they operate with the endianness of the host computer.\n    // Instead we use DataViews where we can specify endianness.\n    var data = new DataView(buffer, 0);\n    var numTables;\n    var tableEntries = [];\n    var signature = parse.getTag(data, 0);\n    if (signature === String.fromCharCode(0, 1, 0, 0) || signature === 'true' || signature === 'typ1') {\n        font.outlinesFormat = 'truetype';\n        numTables = parse.getUShort(data, 4);\n        tableEntries = parseOpenTypeTableEntries(data, numTables);\n    } else if (signature === 'OTTO') {\n        font.outlinesFormat = 'cff';\n        numTables = parse.getUShort(data, 4);\n        tableEntries = parseOpenTypeTableEntries(data, numTables);\n    } else if (signature === 'wOFF') {\n        var flavor = parse.getTag(data, 4);\n        if (flavor === String.fromCharCode(0, 1, 0, 0)) {\n            font.outlinesFormat = 'truetype';\n        } else if (flavor === 'OTTO') {\n            font.outlinesFormat = 'cff';\n        } else {\n            throw new Error('Unsupported OpenType flavor ' + signature);\n        }\n\n        numTables = parse.getUShort(data, 12);\n        tableEntries = parseWOFFTableEntries(data, numTables);\n    } else {\n        throw new Error('Unsupported OpenType signature ' + signature);\n    }\n\n    var cffTableEntry;\n    var fvarTableEntry;\n    var glyfTableEntry;\n    var gdefTableEntry;\n    var gposTableEntry;\n    var gsubTableEntry;\n    var hmtxTableEntry;\n    var kernTableEntry;\n    var locaTableEntry;\n    var nameTableEntry;\n    var metaTableEntry;\n    var p;\n\n    for (var i = 0; i < numTables; i += 1) {\n        var tableEntry = tableEntries[i];\n        var table = (void 0);\n        switch (tableEntry.tag) {\n            case 'cmap':\n                table = uncompressTable(data, tableEntry);\n                font.tables.cmap = cmap.parse(table.data, table.offset);\n                font.encoding = new CmapEncoding(font.tables.cmap);\n                break;\n            case 'cvt ' :\n                table = uncompressTable(data, tableEntry);\n                p = new parse.Parser(table.data, table.offset);\n                font.tables.cvt = p.parseShortList(tableEntry.length / 2);\n                break;\n            case 'fvar':\n                fvarTableEntry = tableEntry;\n                break;\n            case 'fpgm' :\n                table = uncompressTable(data, tableEntry);\n                p = new parse.Parser(table.data, table.offset);\n                font.tables.fpgm = p.parseByteList(tableEntry.length);\n                break;\n            case 'head':\n                table = uncompressTable(data, tableEntry);\n                font.tables.head = head.parse(table.data, table.offset);\n                font.unitsPerEm = font.tables.head.unitsPerEm;\n                indexToLocFormat = font.tables.head.indexToLocFormat;\n                break;\n            case 'hhea':\n                table = uncompressTable(data, tableEntry);\n                font.tables.hhea = hhea.parse(table.data, table.offset);\n                font.ascender = font.tables.hhea.ascender;\n                font.descender = font.tables.hhea.descender;\n                font.numberOfHMetrics = font.tables.hhea.numberOfHMetrics;\n                break;\n            case 'hmtx':\n                hmtxTableEntry = tableEntry;\n                break;\n            case 'ltag':\n                table = uncompressTable(data, tableEntry);\n                ltagTable = ltag.parse(table.data, table.offset);\n                break;\n            case 'maxp':\n                table = uncompressTable(data, tableEntry);\n                font.tables.maxp = maxp.parse(table.data, table.offset);\n                font.numGlyphs = font.tables.maxp.numGlyphs;\n                break;\n            case 'name':\n                nameTableEntry = tableEntry;\n                break;\n            case 'OS/2':\n                table = uncompressTable(data, tableEntry);\n                font.tables.os2 = os2.parse(table.data, table.offset);\n                break;\n            case 'post':\n                table = uncompressTable(data, tableEntry);\n                font.tables.post = post.parse(table.data, table.offset);\n                font.glyphNames = new GlyphNames(font.tables.post);\n                break;\n            case 'prep' :\n                table = uncompressTable(data, tableEntry);\n                p = new parse.Parser(table.data, table.offset);\n                font.tables.prep = p.parseByteList(tableEntry.length);\n                break;\n            case 'glyf':\n                glyfTableEntry = tableEntry;\n                break;\n            case 'loca':\n                locaTableEntry = tableEntry;\n                break;\n            case 'CFF ':\n                cffTableEntry = tableEntry;\n                break;\n            case 'kern':\n                kernTableEntry = tableEntry;\n                break;\n            case 'GDEF':\n                gdefTableEntry = tableEntry;\n                break;\n            case 'GPOS':\n                gposTableEntry = tableEntry;\n                break;\n            case 'GSUB':\n                gsubTableEntry = tableEntry;\n                break;\n            case 'meta':\n                metaTableEntry = tableEntry;\n                break;\n        }\n    }\n\n    var nameTable = uncompressTable(data, nameTableEntry);\n    font.tables.name = _name.parse(nameTable.data, nameTable.offset, ltagTable);\n    font.names = font.tables.name;\n\n    if (glyfTableEntry && locaTableEntry) {\n        var shortVersion = indexToLocFormat === 0;\n        var locaTable = uncompressTable(data, locaTableEntry);\n        var locaOffsets = loca.parse(locaTable.data, locaTable.offset, font.numGlyphs, shortVersion);\n        var glyfTable = uncompressTable(data, glyfTableEntry);\n        font.glyphs = glyf.parse(glyfTable.data, glyfTable.offset, locaOffsets, font, opt);\n    } else if (cffTableEntry) {\n        var cffTable = uncompressTable(data, cffTableEntry);\n        cff.parse(cffTable.data, cffTable.offset, font, opt);\n    } else {\n        throw new Error('Font doesn\\'t contain TrueType or CFF outlines.');\n    }\n\n    var hmtxTable = uncompressTable(data, hmtxTableEntry);\n    hmtx.parse(font, hmtxTable.data, hmtxTable.offset, font.numberOfHMetrics, font.numGlyphs, font.glyphs, opt);\n    addGlyphNames(font, opt);\n\n    if (kernTableEntry) {\n        var kernTable = uncompressTable(data, kernTableEntry);\n        font.kerningPairs = kern.parse(kernTable.data, kernTable.offset);\n    } else {\n        font.kerningPairs = {};\n    }\n\n    if (gdefTableEntry) {\n        var gdefTable = uncompressTable(data, gdefTableEntry);\n        font.tables.gdef = gdef.parse(gdefTable.data, gdefTable.offset);\n    }\n\n    if (gposTableEntry) {\n        var gposTable = uncompressTable(data, gposTableEntry);\n        font.tables.gpos = gpos.parse(gposTable.data, gposTable.offset);\n        font.position.init();\n    }\n\n    if (gsubTableEntry) {\n        var gsubTable = uncompressTable(data, gsubTableEntry);\n        font.tables.gsub = gsub.parse(gsubTable.data, gsubTable.offset);\n    }\n\n    if (fvarTableEntry) {\n        var fvarTable = uncompressTable(data, fvarTableEntry);\n        font.tables.fvar = fvar.parse(fvarTable.data, fvarTable.offset, font.names);\n    }\n\n    if (metaTableEntry) {\n        var metaTable = uncompressTable(data, metaTableEntry);\n        font.tables.meta = meta.parse(metaTable.data, metaTable.offset);\n        font.metas = font.tables.meta;\n    }\n\n    return font;\n}\n\n/**\n * Asynchronously load the font from a URL or a filesystem. When done, call the callback\n * with two arguments `(err, font)`. The `err` will be null on success,\n * the `font` is a Font object.\n * We use the node.js callback convention so that\n * opentype.js can integrate with frameworks like async.js.\n * @alias opentype.load\n * @param  {string} url - The URL of the font to load.\n * @param  {Function} callback - The callback.\n */\nfunction load(url, callback, opt) {\n    opt = (opt === undefined || opt === null) ?  {} : opt;\n    var isNode = typeof window === 'undefined';\n    var loadFn = isNode && !opt.isUrl ? loadFromFile : loadFromUrl;\n\n    return new Promise(function (resolve, reject) {\n        loadFn(url, function(err, arrayBuffer) {\n            if (err) {\n                if (callback) {\n                    return callback(err);\n                } else {\n                    reject(err);\n                }\n            }\n            var font;\n            try {\n                font = parseBuffer(arrayBuffer, opt);\n            } catch (e) {\n                if (callback) {\n                    return callback(e, null);\n                } else {\n                    reject(e);\n                }\n            }\n            if (callback) {\n                return callback(null, font);\n            } else {\n                resolve(font);\n            }\n        });\n    });\n}\n\n/**\n * Synchronously load the font from a URL or file.\n * When done, returns the font object or throws an error.\n * @alias opentype.loadSync\n * @param  {string} url - The URL of the font to load.\n * @param  {Object} opt - opt.lowMemory\n * @return {opentype.Font}\n */\nfunction loadSync(url, opt) {\n    var fs = __webpack_require__(/*! fs */ \"?3514\");\n    var buffer = fs.readFileSync(url);\n    return parseBuffer(nodeBufferToArrayBuffer(buffer), opt);\n}\n\nvar opentype = /*#__PURE__*/Object.freeze({\n\t__proto__: null,\n\tFont: Font,\n\tGlyph: Glyph,\n\tPath: Path,\n\tBoundingBox: BoundingBox,\n\t_parse: parse,\n\tparse: parseBuffer,\n\tload: load,\n\tloadSync: loadSync\n});\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (opentype);\n\n//# sourceMappingURL=opentype.module.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvb3BlbnR5cGUuanMvZGlzdC9vcGVudHlwZS5tb2R1bGUuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0Q7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSixJQUFJO0FBQ0o7QUFDQTtBQUNBLEVBQUU7QUFDRjs7QUFFQTtBQUNBOztBQUVBO0FBQ0Esc0NBQXNDO0FBQ3RDLHNDQUFzQztBQUN0Qzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEI7QUFDNUIsNEJBQTRCO0FBQzVCOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsY0FBYyxXQUFXLE9BQU87QUFDaEMsY0FBYyxnQkFBZ0IsT0FBTzs7QUFFckM7QUFDQSwyQkFBMkIsUUFBUTtBQUNuQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxjQUFjLE9BQU8sT0FBTzs7QUFFNUI7QUFDQTtBQUNBOztBQUVBLGNBQWMsUUFBUSxPQUFPO0FBQzdCLGNBQWMsU0FBUyxPQUFPO0FBQzlCLGNBQWMsT0FBTyxPQUFPO0FBQzVCLGNBQWMsU0FBUyxPQUFPOztBQUU5QjtBQUNBLGNBQWMsT0FBTyxPQUFPOztBQUU1Qjs7QUFFQSxjQUFjLFFBQVEsT0FBTztBQUM3Qjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxjQUFjLFFBQVEsT0FBTzs7QUFFN0I7QUFDQSxjQUFjLFNBQVMsT0FBTzs7QUFFOUI7O0FBRUE7QUFDQSx1QkFBdUIsUUFBUTtBQUMvQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxjQUFjLFNBQVM7QUFDdkIsNEJBQTRCO0FBQzVCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTs7QUFFTjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsY0FBYyxRQUFRLE9BQU87O0FBRTdCO0FBQ0EsY0FBYyxXQUFXO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxnQkFBZ0IsbUJBQW1CO0FBQ25DOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDLFFBQVE7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQyxRQUFRO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0QsUUFBUTtBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxxQkFBcUIsbUJBQW1CO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTs7QUFFTjs7QUFFQTtBQUNBLG1CQUFtQixHQUFHO0FBQ3RCLE1BQU07O0FBRU47QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFFBQVE7O0FBRVIsSUFBSTs7QUFFSjtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxvQkFBb0IsUUFBUTtBQUM1QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBLCtCQUErQjtBQUMvQiwrQkFBK0I7QUFDL0I7QUFDQTtBQUNBOztBQUVBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQSwyQkFBMkI7QUFDM0IsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQiwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxZQUFZLFFBQVE7QUFDcEIsWUFBWSxRQUFRO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBLFlBQVksUUFBUTtBQUNwQixZQUFZLFFBQVE7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLFFBQVE7QUFDcEIsWUFBWSxRQUFRO0FBQ3BCLFlBQVksUUFBUTtBQUNwQixZQUFZLFFBQVE7QUFDcEIsWUFBWSxRQUFRO0FBQ3BCLFlBQVksUUFBUTtBQUNwQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxRQUFRO0FBQ3BCLFlBQVksUUFBUTtBQUNwQixZQUFZLFFBQVE7QUFDcEIsWUFBWSxRQUFRO0FBQ3BCLFlBQVksUUFBUTtBQUNwQixZQUFZLFFBQVE7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxRQUFRO0FBQ3BCLFlBQVksUUFBUTtBQUNwQixZQUFZLFFBQVE7QUFDcEIsWUFBWSxRQUFRO0FBQ3BCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLFFBQVE7QUFDcEIsWUFBWSxRQUFRO0FBQ3BCLFlBQVksUUFBUTtBQUNwQixZQUFZLFFBQVE7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBLFlBQVksT0FBTztBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsMEJBQTBCO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVcsMEJBQTBCO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQiwwQkFBMEI7QUFDOUM7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBWSxRQUFRO0FBQ3BCLFlBQVk7QUFDWjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0Esd0JBQXdCLHNCQUFzQjtBQUM5QztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxvQkFBb0IsMEJBQTBCO0FBQzlDO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBLFVBQVU7QUFDVjtBQUNBLFVBQVU7QUFDVjtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsWUFBWSxRQUFRO0FBQ3BCLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxZQUFZLFFBQVE7QUFDcEIsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYzs7QUFFZDs7QUFFQSxxQkFBcUI7QUFDckIsMEJBQTBCOztBQUUxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVc7QUFDWCxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGNBQWM7QUFDbEM7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsV0FBVztBQUNYLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVztBQUNYLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVc7QUFDWCxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVztBQUNYLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVc7QUFDWCxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FB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RUE7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGtCQUFrQjtBQUN0QztBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsWUFBWTtBQUNoQztBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUM7QUFDbkM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSwrQkFBK0I7QUFDL0I7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFdBQVc7QUFDL0I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsV0FBVztBQUMvQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsV0FBVztBQUMvQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsV0FBVztBQUMvQjtBQUNB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QUFDQTtBQUNBOztBQUVBO0FBQ0EsbUJBQW1CLDhDQUE4QztBQUNqRTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsYUFBYSxnREFBZ0Q7QUFDN0QsYUFBYSxpREFBaUQ7QUFDOUQsYUFBYSx5REFBeUQ7QUFDdEUsYUFBYSxnREFBZ0Q7QUFDN0QsYUFBYTtBQUNiOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxhQUFhOztBQUViOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBOztBQUVB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Q0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBEQUEwRDtBQUMxRCwwREFBMEQ7QUFDMUQsMERBQTBEO0FBQzFELDBEQUEwRDtBQUMxRCwwREFBMEQ7QUFDMUQsMERBQTBEO0FBQzFELDBEQUEwRDtBQUMxRCwwREFBMEQ7QUFDMUQsMERBQTBEO0FBQzFELDBEQUEwRDtBQUMxRCwwREFBMEQ7QUFDMUQsMERBQTBEO0FBQzFELDBEQUEwRDtBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMERBQTBEO0FBQzFELDBEQUEwRDtBQUMxRCwwREFBMEQ7QUFDMUQsMERBQTBEO0FBQzFELDBEQUEwRDtBQUMxRCwwREFBMEQ7QUFDMUQsMERBQTBEO0FBQzFELDBEQUEwRDtBQUMxRCwwREFBMEQ7QUFDMUQsMERBQTBEO0FBQzFELDBEQUEwRDtBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMERBQTBEO0FBQzFELDBEQUEwRDtBQUMxRCwwREFBMEQ7QUFDMUQsMERBQTBEO0FBQzFELDBEQUEwRDtBQUMxRCwwREFBMEQ7QUFDMUQsMERBQTBEO0FBQzFELDBEQUEwRDtBQUMxRCwwREFBMEQ7QUFDMUQsMERBQTBEO0FBQzFELDBEQUEwRDtBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMERBQTBEO0FBQzFELDBEQUEwRDtBQUMxRCwwREFBMEQ7QUFDMUQsMERBQTBEO0FBQzFELDBEQUEwRDtBQUMxRCwwREFBMEQ7QUFDMUQsMERBQTBEO0FBQzFELDBEQUEwRDtBQUMxRCwwREFBMEQ7QUFDMUQsMERBQTBEO0FBQzFEO0FBQ0E7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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QTtBQUNBO0FBQ0E7QUFDQSwyREFBMkQ7QUFDM0Q7QUFDQTs7QUFFQTtBQUNBLG9CQUFvQixhQUFhO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixxQkFBcUI7QUFDbEQ7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsYUFBYTs7QUFFYjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUyxrREFBa0Q7QUFDM0QsU0FBUztBQUNUO0FBQ0E7O0FBRUEsYUFBYTs7QUFFYjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFdBQVc7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxJQUFJLFdBQVcsR0FBRztBQUNsQixxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxTQUFTLHNEQUFzRDtBQUMvRCxTQUFTLHNEQUFzRDtBQUMvRCxTQUFTLHNEQUFzRDtBQUMvRCxTQUFTLDhDQUE4QztBQUN2RCxTQUFTLDhDQUE4QztBQUN2RCxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esc0JBQXNCLGFBQWE7QUFDbkMsZUFBZSxhQUFhO0FBQzVCLDRCQUE0QixrQkFBa0I7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxTQUFTO0FBQ3hCO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsb0JBQW9CLG9CQUFvQjtBQUN4QztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtEQUFrRDtBQUNsRDtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0M7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGdDQUFnQztBQUNoQztBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQSxTQUFTLHlDQUF5QztBQUNsRCxTQUFTLHlEQUF5RDtBQUNsRSxTQUFTO0FBQ1Q7O0FBRUEsb0JBQW9CLHdCQUF3QjtBQUM1Qyx1QkFBdUIsMkRBQTJEO0FBQ2xGOztBQUVBLG1CQUFtQixvREFBb0Q7QUFDdkU7QUFDQTs7QUFFQSxjQUFjOztBQUVkOztBQUVBO0FBQ0EsS0FBSywyQkFBMkI7QUFDaEMsS0FBSywyQkFBMkI7QUFDaEMsS0FBSywyQkFBMkI7QUFDaEMsS0FBSywyQkFBMkI7QUFDaEMsS0FBSywyQkFBMkI7QUFDaEMsS0FBSywyQkFBMkI7QUFDaEMsS0FBSywyQkFBMkI7QUFDaEMsS0FBSywyQkFBMkI7QUFDaEMsS0FBSywyQkFBMkI7QUFDaEMsS0FBSywyQkFBMkI7QUFDaEMsS0FBSywyQkFBMkI7QUFDaEMsS0FBSywyQkFBMkI7QUFDaEMsS0FBSywyQkFBMkI7QUFDaEMsS0FBSywyQkFBMkI7QUFDaEMsS0FBSywyQkFBMkI7QUFDaEMsS0FBSywyQkFBMkI7QUFDaEMsS0FBSywyQkFBMkI7QUFDaEMsS0FBSywyQkFBMkI7QUFDaEMsS0FBSywyQkFBMkI7QUFDaEMsS0FBSywyQkFBMkI7QUFDaEMsS0FBSywyQkFBMkI7QUFDaEMsS0FBSywyQkFBMkI7QUFDaEMsS0FBSywyQkFBMkI7QUFDaEMsS0FBSywyQkFBMkI7QUFDaEMsS0FBSywyQkFBMkI7QUFDaEMsS0FBSywyQkFBMkI7QUFDaEMsS0FBSywyQkFBMkI7QUFDaEMsS0FBSywyQkFBMkI7QUFDaEMsS0FBSywyQkFBMkI7QUFDaEMsS0FBSywyQkFBMkI7QUFDaEMsS0FBSywyQkFBMkI7QUFDaEMsS0FBSywyQkFBMkI7QUFDaEMsS0FBSywyQkFBMkI7QUFDaEMsS0FBSywyQkFBMkI7QUFDaEMsS0FBSywyQkFBMkI7QUFDaEMsS0FBSywyQkFBMkI7QUFDaEMsS0FBSywyQkFBMkI7QUFDaEMsS0FBSywyQkFBMkI7QUFDaEMsS0FBSywyQkFBMkI7QUFDaEMsS0FBSywyQkFBMkI7QUFDaEMsS0FBSywyQkFBMkI7QUFDaEMsS0FBSywyQkFBMkI7QUFDaEMsS0FBSywyQkFBMkI7QUFDaEMsS0FBSywyQkFBMkI7QUFDaEMsS0FBSywyQkFBMkI7QUFDaEMsS0FBSywyQkFBMkI7QUFDaEMsS0FBSywyQkFBMkI7QUFDaEMsS0FBSywyQkFBMkI7QUFDaEMsS0FBSywyQkFBMkI7QUFDaEMsS0FBSywyQkFBMkI7QUFDaEMsS0FBSywyQkFBMkI7QUFDaEMsS0FBSywyQkFBMkI7QUFDaEMsS0FBSywyQkFBMkI7QUFDaEMsS0FBSywyQkFBMkI7QUFDaEMsS0FBSywyQkFBMkI7QUFDaEMsS0FBSywyQkFBMkI7QUFDaEMsS0FBSywyQkFBMkI7QUFDaEMsS0FBSywyQkFBMkI7QUFDaEMsS0FBSyw2QkFBNkI7QUFDbEMsS0FBSywyQkFBMkI7QUFDaEMsS0FBSywyQkFBMkI7QUFDaEMsS0FBSywyQkFBMkI7QUFDaEMsS0FBSywyQkFBMkI7QUFDaEMsS0FBSywyQkFBMkI7QUFDaEMsS0FBSywyQkFBMkI7QUFDaEMsS0FBSywyQkFBMkI7QUFDaEMsS0FBSywyQkFBMkI7QUFDaEMsS0FBSywyQkFBMkI7QUFDaEMsS0FBSywyQkFBMkI7QUFDaEMsS0FBSywyQkFBMkI7QUFDaEMsS0FBSywyQkFBMkI7QUFDaEMsS0FBSywyQkFBMkI7QUFDaEMsS0FBSywyQkFBMkI7QUFDaEMsS0FBSywyQkFBMkI7QUFDaEMsS0FBSywyQkFBMkI7QUFDaEMsS0FBSywyQkFBMkI7QUFDaEMsS0FBSywyQkFBMkI7QUFDaEMsS0FBSywyQkFBMkI7QUFDaEMsS0FBSywyQkFBMkI7QUFDaEMsS0FBSywyQkFBMkI7QUFDaEMsS0FBSywyQkFBMkI7QUFDaEMsS0FBSywyQkFBMkI7QUFDaEMsS0FBSywyQkFBMkI7QUFDaEMsS0FBSywyQkFBMkI7QUFDaEMsS0FBSywyQkFBMkI7QUFDaEMsS0FBSyw2QkFBNkI7QUFDbEMsS0FBSyw2QkFBNkI7QUFDbEMsS0FBSyw2QkFBNkI7QUFDbEMsS0FBSyw2QkFBNkI7QUFDbEMsS0FBSyw2QkFBNkI7QUFDbEMsS0FBSyw2QkFBNkI7QUFDbEMsS0FBSywyQkFBMkI7QUFDaEMsS0FBSyw2QkFBNkI7QUFDbEMsS0FBSywyQkFBMkI7QUFDaEMsS0FBSywyQkFBMkI7QUFDaEMsS0FBSywyQkFBMkI7QUFDaEMsS0FBSywyQkFBMkI7QUFDaEMsS0FBSywyQkFBMkI7QUFDaEMsS0FBSywyQkFBMkI7QUFDaEMsS0FBSywyQkFBMkI7QUFDaEMsS0FBSywyQkFBMkI7QUFDaEMsS0FBSyw2QkFBNkI7QUFDbEMsS0FBSyw2QkFBNkI7QUFDbEMsS0FBSyw2QkFBNkI7QUFDbEMsS0FBSyw2QkFBNkI7QUFDbEMsS0FBSyw2QkFBNkI7QUFDbEMsS0FBSyw2QkFBNkI7QUFDbEMsS0FBSyw2QkFBNkI7QUFDbEMsS0FBSyw2QkFBNkI7QUFDbEMsS0FBSyw2QkFBNkI7QUFDbEMsS0FBSyw2QkFBNkI7QUFDbEMsS0FBSyw2QkFBNkI7QUFDbEMsS0FBSywyQkFBMkI7QUFDaEMsS0FBSywyQkFBMkI7QUFDaEMsS0FBSywyQkFBMkI7QUFDaEMsS0FBSywyQkFBMkI7QUFDaEMsS0FBSywyQkFBMkI7QUFDaEMsS0FBSywyQkFBMkI7QUFDaEMsS0FBSywyQkFBMkI7QUFDaEMsS0FBSyw2QkFBNkI7QUFDbEMsS0FBSyw2QkFBNkI7QUFDbEMsS0FBSyw2QkFBNkI7QUFDbEMsS0FBSywrQkFBK0I7QUFDcEM7O0FBRUE7QUFDQSxvQkFBb0IsMEJBQTBCO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsUUFBUTtBQUM1QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUywrQ0FBK0M7QUFDeEQsU0FBUywrQ0FBK0M7QUFDeEQsU0FBUyxnREFBZ0Q7QUFDekQsU0FBUywrQ0FBK0M7QUFDeEQsU0FBUyx5Q0FBeUM7QUFDbEQsU0FBUyxtREFBbUQ7QUFDNUQsU0FBUyxtREFBbUQ7QUFDNUQsU0FBUyxtREFBbUQ7QUFDNUQsU0FBUyxxREFBcUQ7QUFDOUQsU0FBUyxxREFBcUQ7QUFDOUQsU0FBUyxxREFBcUQ7QUFDOUQsU0FBUyxxREFBcUQ7QUFDOUQsU0FBUyx1REFBdUQ7QUFDaEUsU0FBUyxpREFBaUQ7QUFDMUQsU0FBUyxzREFBc0Q7QUFDL0QsU0FBUyw4Q0FBOEM7QUFDdkQsU0FBUyw0Q0FBNEM7QUFDckQsU0FBUyw0Q0FBNEM7QUFDckQsU0FBUyx3Q0FBd0M7QUFDakQsU0FBUyw0Q0FBNEM7QUFDckQsU0FBUywwQ0FBMEM7QUFDbkQsU0FBUyxpREFBaUQ7QUFDMUQsU0FBUywwQ0FBMEM7QUFDbkQsU0FBUyw0Q0FBNEM7QUFDckQsU0FBUyx5Q0FBeUM7QUFDbEQsU0FBUyx5Q0FBeUM7QUFDbEQsU0FBUyxpREFBaUQ7QUFDMUQsU0FBUyxpREFBaUQ7QUFDMUQsU0FBUyxpREFBaUQ7QUFDMUQsU0FBUyxpREFBaUQ7QUFDMUQsU0FBUyxvREFBb0Q7QUFDN0QsU0FBUyw4Q0FBOEM7QUFDdkQsU0FBUyxtREFBbUQ7QUFDNUQsU0FBUyxrREFBa0Q7QUFDM0QsU0FBUywrQ0FBK0M7QUFDeEQsU0FBUyxnREFBZ0Q7QUFDekQsU0FBUyw4Q0FBOEM7QUFDdkQsU0FBUyw4Q0FBOEM7QUFDdkQsU0FBUywrQ0FBK0M7QUFDeEQsU0FBUyxrREFBa0Q7QUFDM0QsU0FBUyxrREFBa0Q7QUFDM0QsU0FBUywwQ0FBMEM7QUFDbkQsU0FBUyw0Q0FBNEM7QUFDckQsU0FBUyxnREFBZ0Q7QUFDekQsU0FBUyw4Q0FBOEM7QUFDdkQsU0FBUztBQUNUO0FBQ0E7O0FBRUEsWUFBWTs7QUFFWjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLHlCQUF5QjtBQUNyRDtBQUNBOztBQUVBO0FBQ0EsOEJBQThCLDJCQUEyQjtBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLDJCQUEyQjtBQUN6RDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxTQUFTLGtEQUFrRDtBQUMzRCxTQUFTLDZDQUE2QztBQUN0RCxTQUFTLG1EQUFtRDtBQUM1RCxTQUFTLG9EQUFvRDtBQUM3RCxTQUFTLDhDQUE4QztBQUN2RCxTQUFTLDhDQUE4QztBQUN2RCxTQUFTLDhDQUE4QztBQUN2RCxTQUFTLDZDQUE2QztBQUN0RCxTQUFTO0FBQ1Q7QUFDQTs7QUFFQSxhQUFhOztBQUViOztBQUVBLDRDQUE0Qzs7QUFFNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYSw4Q0FBOEM7QUFDM0QsYUFBYSw4RUFBOEU7QUFDM0YsYUFBYTtBQUNiO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsYUFBYSw4Q0FBOEM7QUFDM0QsYUFBYTtBQUNiO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLDhDQUE4QztBQUN2RCxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLDhDQUE4QztBQUN2RCxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLDhDQUE4QztBQUN2RCxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLDJEQUEyRDtBQUM3RTtBQUNBO0FBQ0EsU0FBUztBQUNULEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLGlFQUFpRTtBQUM5RSxhQUFhO0FBQ2I7QUFDQTtB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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLG9CQUFvQixxQkFBcUI7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBLFVBQVU7QUFDVjs7QUFFQSxhQUFhOztBQUViO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQSxpQkFBaUI7O0FBRWpCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSw4QkFBOEI7QUFDOUIsbUNBQW1DO0FBQ25DLFdBQVc7QUFDWDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0Q7QUFDaEQsZ0RBQWdEOztBQUVoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSwwQ0FBMEM7O0FBRTFDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsMENBQTBDOztBQUUxQztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxnQ0FBZ0M7O0FBRWhDO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixpQkFBaUI7QUFDN0M7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGdDQUFnQzs7QUFFaEM7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLHdCQUF3Qix1QkFBdUI7QUFDL0M7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixnQkFBZ0I7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsNEJBQTRCLGVBQWU7QUFD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QSx5QkFBeUI7QUFDekI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx5QkFBeUI7O0FBRXpCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHlCQUF5QjtBQUN6Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx5QkFBeUI7QUFDekI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEseUJBQXlCO0FBQ3pCOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHlCQUF5Qjs7QUFFekI7O0FBRUE7QUFDQTtBQUNBLGdDQUFnQztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEseUJBQXlCOztBQUV6Qjs7QUFFQTtBQUNBO0FBQ0EsZ0NBQWdDO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx5QkFBeUI7O0FBRXpCOztBQUVBO0FBQ0E7QUFDQSxnQ0FBZ0M7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHlCQUF5Qjs7QUFFekI7O0FBRUE7QUFDQTtBQUNBLGdDQUFnQztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEseUJBQXlCO0FBQ3pCOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5Qjs7QUFFekI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7O0FBRXpCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7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QUNBO0FBQ0E7QUFDQTs7QUFFQSx5QkFBeUI7O0FBRXpCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHlCQUF5Qjs7QUFFekI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEseUJBQXlCOztBQUV6QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx5QkFBeUI7O0FBRXpCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHlCQUF5Qjs7QUFFekI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEseUJBQXlCOztBQUV6QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx5QkFBeUI7O0FBRXpCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHlCQUF5Qjs7QUFFekI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEseUJBQXlCOztBQUV6QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEseUJBQXlCOztBQUV6QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEseUJBQXlCOztBQUV6QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHlCQUF5Qjs7QUFFekI7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsNkJBQTZCO0FBQzdCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHlCQUF5QjtBQUN6Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEseUJBQXlCOztBQUV6QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7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QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7Ozs7QUFJQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7O0FBR0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7Ozs7QUFJQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7Ozs7QUFJQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7Ozs7O0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTs7OztBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7O0FBRUE7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7Ozs7QUFJQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxVQUFVO0FBQ3JCLFdBQVcsVUFBVTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsT0FBTztBQUNyQixjQUFjLFFBQVE7QUFDdEI7O0FBRUE7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixXQUFXLFFBQVE7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxL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QUFZLFFBQVE7QUFDcEIsWUFBWTtBQUNaO0FBQ0E7QUFDQSxvREFBb0Q7O0FBRXBEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHlCQUF5QixZQUFZOztBQUVyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxVQUFVO0FBQ1Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG9CQUFvQixlQUFlO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxRQUFRO0FBQ3BCLFlBQVksVUFBVTtBQUN0QjtBQUNBO0FBQ0Esb0RBQW9EO0FBQ3BEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxRQUFRO0FBQ3BCLFlBQVksUUFBUTtBQUNwQixZQUFZO0FBQ1o7QUFDQTtBQUNBLGFBQWEsbUJBQU8sQ0FBQyxpQkFBSTtBQUN6QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVELCtEQUFlLFFBQVEsRUFBQztBQUN5RTtBQUNqRyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvb3BlbnR5cGUuanMvZGlzdC9vcGVudHlwZS5tb2R1bGUuanM/NmRiNSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIGh0dHBzOi8vb3BlbnR5cGUuanMub3JnIHYxLjMuNCB8IChjKSBGcmVkZXJpayBEZSBCbGVzZXIgYW5kIG90aGVyIGNvbnRyaWJ1dG9ycyB8IE1JVCBMaWNlbnNlIHwgVXNlcyB0aW55LWluZmxhdGUgYnkgRGV2b24gR292ZXR0IGFuZCBzdHJpbmcucHJvdG90eXBlLmNvZGVwb2ludGF0IHBvbHlmaWxsIGJ5IE1hdGhpYXMgQnluZW5zXG4gKi9cblxuLyohIGh0dHBzOi8vbXRocy5iZS9jb2RlcG9pbnRhdCB2MC4yLjAgYnkgQG1hdGhpYXMgKi9cbmlmICghU3RyaW5nLnByb3RvdHlwZS5jb2RlUG9pbnRBdCkge1xuXHQoZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGRlZmluZVByb3BlcnR5ID0gKGZ1bmN0aW9uKCkge1xuXHRcdFx0Ly8gSUUgOCBvbmx5IHN1cHBvcnRzIGBPYmplY3QuZGVmaW5lUHJvcGVydHlgIG9uIERPTSBlbGVtZW50c1xuXHRcdFx0dHJ5IHtcblx0XHRcdFx0dmFyIG9iamVjdCA9IHt9O1xuXHRcdFx0XHR2YXIgJGRlZmluZVByb3BlcnR5ID0gT2JqZWN0LmRlZmluZVByb3BlcnR5O1xuXHRcdFx0XHR2YXIgcmVzdWx0ID0gJGRlZmluZVByb3BlcnR5KG9iamVjdCwgb2JqZWN0LCBvYmplY3QpICYmICRkZWZpbmVQcm9wZXJ0eTtcblx0XHRcdH0gY2F0Y2goZXJyb3IpIHt9XG5cdFx0XHRyZXR1cm4gcmVzdWx0O1xuXHRcdH0oKSk7XG5cdFx0dmFyIGNvZGVQb2ludEF0ID0gZnVuY3Rpb24ocG9zaXRpb24pIHtcblx0XHRcdGlmICh0aGlzID09IG51bGwpIHtcblx0XHRcdFx0dGhyb3cgVHlwZUVycm9yKCk7XG5cdFx0XHR9XG5cdFx0XHR2YXIgc3RyaW5nID0gU3RyaW5nKHRoaXMpO1xuXHRcdFx0dmFyIHNpemUgPSBzdHJpbmcubGVuZ3RoO1xuXHRcdFx0Ly8gYFRvSW50ZWdlcmBcblx0XHRcdHZhciBpbmRleCA9IHBvc2l0aW9uID8gTnVtYmVyKHBvc2l0aW9uKSA6IDA7XG5cdFx0XHRpZiAoaW5kZXggIT0gaW5kZXgpIHsgLy8gYmV0dGVyIGBpc05hTmBcblx0XHRcdFx0aW5kZXggPSAwO1xuXHRcdFx0fVxuXHRcdFx0Ly8gQWNjb3VudCBmb3Igb3V0LW9mLWJvdW5kcyBpbmRpY2VzOlxuXHRcdFx0aWYgKGluZGV4IDwgMCB8fCBpbmRleCA+PSBzaXplKSB7XG5cdFx0XHRcdHJldHVybiB1bmRlZmluZWQ7XG5cdFx0XHR9XG5cdFx0XHQvLyBHZXQgdGhlIGZpcnN0IGNvZGUgdW5pdFxuXHRcdFx0dmFyIGZpcnN0ID0gc3RyaW5nLmNoYXJDb2RlQXQoaW5kZXgpO1xuXHRcdFx0dmFyIHNlY29uZDtcblx0XHRcdGlmICggLy8gY2hlY2sgaWYgaXTigJlzIHRoZSBzdGFydCBvZiBhIHN1cnJvZ2F0ZSBwYWlyXG5cdFx0XHRcdGZpcnN0ID49IDB4RDgwMCAmJiBmaXJzdCA8PSAweERCRkYgJiYgLy8gaGlnaCBzdXJyb2dhdGVcblx0XHRcdFx0c2l6ZSA+IGluZGV4ICsgMSAvLyB0aGVyZSBpcyBhIG5leHQgY29kZSB1bml0XG5cdFx0XHQpIHtcblx0XHRcdFx0c2Vjb25kID0gc3RyaW5nLmNoYXJDb2RlQXQoaW5kZXggKyAxKTtcblx0XHRcdFx0aWYgKHNlY29uZCA+PSAweERDMDAgJiYgc2Vjb25kIDw9IDB4REZGRikgeyAvLyBsb3cgc3Vycm9nYXRlXG5cdFx0XHRcdFx0Ly8gaHR0cHM6Ly9tYXRoaWFzYnluZW5zLmJlL25vdGVzL2phdmFzY3JpcHQtZW5jb2Rpbmcjc3Vycm9nYXRlLWZvcm11bGFlXG5cdFx0XHRcdFx0cmV0dXJuIChmaXJzdCAtIDB4RDgwMCkgKiAweDQwMCArIHNlY29uZCAtIDB4REMwMCArIDB4MTAwMDA7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHJldHVybiBmaXJzdDtcblx0XHR9O1xuXHRcdGlmIChkZWZpbmVQcm9wZXJ0eSkge1xuXHRcdFx0ZGVmaW5lUHJvcGVydHkoU3RyaW5nLnByb3RvdHlwZSwgJ2NvZGVQb2ludEF0Jywge1xuXHRcdFx0XHQndmFsdWUnOiBjb2RlUG9pbnRBdCxcblx0XHRcdFx0J2NvbmZpZ3VyYWJsZSc6IHRydWUsXG5cdFx0XHRcdCd3cml0YWJsZSc6IHRydWVcblx0XHRcdH0pO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRTdHJpbmcucHJvdG90eXBlLmNvZGVQb2ludEF0ID0gY29kZVBvaW50QXQ7XG5cdFx0fVxuXHR9KCkpO1xufVxuXG52YXIgVElORl9PSyA9IDA7XG52YXIgVElORl9EQVRBX0VSUk9SID0gLTM7XG5cbmZ1bmN0aW9uIFRyZWUoKSB7XG4gIHRoaXMudGFibGUgPSBuZXcgVWludDE2QXJyYXkoMTYpOyAgIC8qIHRhYmxlIG9mIGNvZGUgbGVuZ3RoIGNvdW50cyAqL1xuICB0aGlzLnRyYW5zID0gbmV3IFVpbnQxNkFycmF5KDI4OCk7ICAvKiBjb2RlIC0+IHN5bWJvbCB0cmFuc2xhdGlvbiB0YWJsZSAqL1xufVxuXG5mdW5jdGlvbiBEYXRhKHNvdXJjZSwgZGVzdCkge1xuICB0aGlzLnNvdXJjZSA9IHNvdXJjZTtcbiAgdGhpcy5zb3VyY2VJbmRleCA9IDA7XG4gIHRoaXMudGFnID0gMDtcbiAgdGhpcy5iaXRjb3VudCA9IDA7XG4gIFxuICB0aGlzLmRlc3QgPSBkZXN0O1xuICB0aGlzLmRlc3RMZW4gPSAwO1xuICBcbiAgdGhpcy5sdHJlZSA9IG5ldyBUcmVlKCk7ICAvKiBkeW5hbWljIGxlbmd0aC9zeW1ib2wgdHJlZSAqL1xuICB0aGlzLmR0cmVlID0gbmV3IFRyZWUoKTsgIC8qIGR5bmFtaWMgZGlzdGFuY2UgdHJlZSAqL1xufVxuXG4vKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKlxuICogLS0gdW5pbml0aWFsaXplZCBnbG9iYWwgZGF0YSAoc3RhdGljIHN0cnVjdHVyZXMpIC0tICpcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqL1xuXG52YXIgc2x0cmVlID0gbmV3IFRyZWUoKTtcbnZhciBzZHRyZWUgPSBuZXcgVHJlZSgpO1xuXG4vKiBleHRyYSBiaXRzIGFuZCBiYXNlIHRhYmxlcyBmb3IgbGVuZ3RoIGNvZGVzICovXG52YXIgbGVuZ3RoX2JpdHMgPSBuZXcgVWludDhBcnJheSgzMCk7XG52YXIgbGVuZ3RoX2Jhc2UgPSBuZXcgVWludDE2QXJyYXkoMzApO1xuXG4vKiBleHRyYSBiaXRzIGFuZCBiYXNlIHRhYmxlcyBmb3IgZGlzdGFuY2UgY29kZXMgKi9cbnZhciBkaXN0X2JpdHMgPSBuZXcgVWludDhBcnJheSgzMCk7XG52YXIgZGlzdF9iYXNlID0gbmV3IFVpbnQxNkFycmF5KDMwKTtcblxuLyogc3BlY2lhbCBvcmRlcmluZyBvZiBjb2RlIGxlbmd0aCBjb2RlcyAqL1xudmFyIGNsY2lkeCA9IG5ldyBVaW50OEFycmF5KFtcbiAgMTYsIDE3LCAxOCwgMCwgOCwgNywgOSwgNixcbiAgMTAsIDUsIDExLCA0LCAxMiwgMywgMTMsIDIsXG4gIDE0LCAxLCAxNVxuXSk7XG5cbi8qIHVzZWQgYnkgdGluZl9kZWNvZGVfdHJlZXMsIGF2b2lkcyBhbGxvY2F0aW9ucyBldmVyeSBjYWxsICovXG52YXIgY29kZV90cmVlID0gbmV3IFRyZWUoKTtcbnZhciBsZW5ndGhzID0gbmV3IFVpbnQ4QXJyYXkoMjg4ICsgMzIpO1xuXG4vKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqXG4gKiAtLSB1dGlsaXR5IGZ1bmN0aW9ucyAtLSAqXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqL1xuXG4vKiBidWlsZCBleHRyYSBiaXRzIGFuZCBiYXNlIHRhYmxlcyAqL1xuZnVuY3Rpb24gdGluZl9idWlsZF9iaXRzX2Jhc2UoYml0cywgYmFzZSwgZGVsdGEsIGZpcnN0KSB7XG4gIHZhciBpLCBzdW07XG5cbiAgLyogYnVpbGQgYml0cyB0YWJsZSAqL1xuICBmb3IgKGkgPSAwOyBpIDwgZGVsdGE7ICsraSkgeyBiaXRzW2ldID0gMDsgfVxuICBmb3IgKGkgPSAwOyBpIDwgMzAgLSBkZWx0YTsgKytpKSB7IGJpdHNbaSArIGRlbHRhXSA9IGkgLyBkZWx0YSB8IDA7IH1cblxuICAvKiBidWlsZCBiYXNlIHRhYmxlICovXG4gIGZvciAoc3VtID0gZmlyc3QsIGkgPSAwOyBpIDwgMzA7ICsraSkge1xuICAgIGJhc2VbaV0gPSBzdW07XG4gICAgc3VtICs9IDEgPDwgYml0c1tpXTtcbiAgfVxufVxuXG4vKiBidWlsZCB0aGUgZml4ZWQgaHVmZm1hbiB0cmVlcyAqL1xuZnVuY3Rpb24gdGluZl9idWlsZF9maXhlZF90cmVlcyhsdCwgZHQpIHtcbiAgdmFyIGk7XG5cbiAgLyogYnVpbGQgZml4ZWQgbGVuZ3RoIHRyZWUgKi9cbiAgZm9yIChpID0gMDsgaSA8IDc7ICsraSkgeyBsdC50YWJsZVtpXSA9IDA7IH1cblxuICBsdC50YWJsZVs3XSA9IDI0O1xuICBsdC50YWJsZVs4XSA9IDE1MjtcbiAgbHQudGFibGVbOV0gPSAxMTI7XG5cbiAgZm9yIChpID0gMDsgaSA8IDI0OyArK2kpIHsgbHQudHJhbnNbaV0gPSAyNTYgKyBpOyB9XG4gIGZvciAoaSA9IDA7IGkgPCAxNDQ7ICsraSkgeyBsdC50cmFuc1syNCArIGldID0gaTsgfVxuICBmb3IgKGkgPSAwOyBpIDwgODsgKytpKSB7IGx0LnRyYW5zWzI0ICsgMTQ0ICsgaV0gPSAyODAgKyBpOyB9XG4gIGZvciAoaSA9IDA7IGkgPCAxMTI7ICsraSkgeyBsdC50cmFuc1syNCArIDE0NCArIDggKyBpXSA9IDE0NCArIGk7IH1cblxuICAvKiBidWlsZCBmaXhlZCBkaXN0YW5jZSB0cmVlICovXG4gIGZvciAoaSA9IDA7IGkgPCA1OyArK2kpIHsgZHQudGFibGVbaV0gPSAwOyB9XG5cbiAgZHQudGFibGVbNV0gPSAzMjtcblxuICBmb3IgKGkgPSAwOyBpIDwgMzI7ICsraSkgeyBkdC50cmFuc1tpXSA9IGk7IH1cbn1cblxuLyogZ2l2ZW4gYW4gYXJyYXkgb2YgY29kZSBsZW5ndGhzLCBidWlsZCBhIHRyZWUgKi9cbnZhciBvZmZzID0gbmV3IFVpbnQxNkFycmF5KDE2KTtcblxuZnVuY3Rpb24gdGluZl9idWlsZF90cmVlKHQsIGxlbmd0aHMsIG9mZiwgbnVtKSB7XG4gIHZhciBpLCBzdW07XG5cbiAgLyogY2xlYXIgY29kZSBsZW5ndGggY291bnQgdGFibGUgKi9cbiAgZm9yIChpID0gMDsgaSA8IDE2OyArK2kpIHsgdC50YWJsZVtpXSA9IDA7IH1cblxuICAvKiBzY2FuIHN5bWJvbCBsZW5ndGhzLCBhbmQgc3VtIGNvZGUgbGVuZ3RoIGNvdW50cyAqL1xuICBmb3IgKGkgPSAwOyBpIDwgbnVtOyArK2kpIHsgdC50YWJsZVtsZW5ndGhzW29mZiArIGldXSsrOyB9XG5cbiAgdC50YWJsZVswXSA9IDA7XG5cbiAgLyogY29tcHV0ZSBvZmZzZXQgdGFibGUgZm9yIGRpc3RyaWJ1dGlvbiBzb3J0ICovXG4gIGZvciAoc3VtID0gMCwgaSA9IDA7IGkgPCAxNjsgKytpKSB7XG4gICAgb2Zmc1tpXSA9IHN1bTtcbiAgICBzdW0gKz0gdC50YWJsZVtpXTtcbiAgfVxuXG4gIC8qIGNyZWF0ZSBjb2RlLT5zeW1ib2wgdHJhbnNsYXRpb24gdGFibGUgKHN5bWJvbHMgc29ydGVkIGJ5IGNvZGUpICovXG4gIGZvciAoaSA9IDA7IGkgPCBudW07ICsraSkge1xuICAgIGlmIChsZW5ndGhzW29mZiArIGldKSB7IHQudHJhbnNbb2Zmc1tsZW5ndGhzW29mZiArIGldXSsrXSA9IGk7IH1cbiAgfVxufVxuXG4vKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tICpcbiAqIC0tIGRlY29kZSBmdW5jdGlvbnMgLS0gKlxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqL1xuXG4vKiBnZXQgb25lIGJpdCBmcm9tIHNvdXJjZSBzdHJlYW0gKi9cbmZ1bmN0aW9uIHRpbmZfZ2V0Yml0KGQpIHtcbiAgLyogY2hlY2sgaWYgdGFnIGlzIGVtcHR5ICovXG4gIGlmICghZC5iaXRjb3VudC0tKSB7XG4gICAgLyogbG9hZCBuZXh0IHRhZyAqL1xuICAgIGQudGFnID0gZC5zb3VyY2VbZC5zb3VyY2VJbmRleCsrXTtcbiAgICBkLmJpdGNvdW50ID0gNztcbiAgfVxuXG4gIC8qIHNoaWZ0IGJpdCBvdXQgb2YgdGFnICovXG4gIHZhciBiaXQgPSBkLnRhZyAmIDE7XG4gIGQudGFnID4+Pj0gMTtcblxuICByZXR1cm4gYml0O1xufVxuXG4vKiByZWFkIGEgbnVtIGJpdCB2YWx1ZSBmcm9tIGEgc3RyZWFtIGFuZCBhZGQgYmFzZSAqL1xuZnVuY3Rpb24gdGluZl9yZWFkX2JpdHMoZCwgbnVtLCBiYXNlKSB7XG4gIGlmICghbnVtKVxuICAgIHsgcmV0dXJuIGJhc2U7IH1cblxuICB3aGlsZSAoZC5iaXRjb3VudCA8IDI0KSB7XG4gICAgZC50YWcgfD0gZC5zb3VyY2VbZC5zb3VyY2VJbmRleCsrXSA8PCBkLmJpdGNvdW50O1xuICAgIGQuYml0Y291bnQgKz0gODtcbiAgfVxuXG4gIHZhciB2YWwgPSBkLnRhZyAmICgweGZmZmYgPj4+ICgxNiAtIG51bSkpO1xuICBkLnRhZyA+Pj49IG51bTtcbiAgZC5iaXRjb3VudCAtPSBudW07XG4gIHJldHVybiB2YWwgKyBiYXNlO1xufVxuXG4vKiBnaXZlbiBhIGRhdGEgc3RyZWFtIGFuZCBhIHRyZWUsIGRlY29kZSBhIHN5bWJvbCAqL1xuZnVuY3Rpb24gdGluZl9kZWNvZGVfc3ltYm9sKGQsIHQpIHtcbiAgd2hpbGUgKGQuYml0Y291bnQgPCAyNCkge1xuICAgIGQudGFnIHw9IGQuc291cmNlW2Quc291cmNlSW5kZXgrK10gPDwgZC5iaXRjb3VudDtcbiAgICBkLmJpdGNvdW50ICs9IDg7XG4gIH1cbiAgXG4gIHZhciBzdW0gPSAwLCBjdXIgPSAwLCBsZW4gPSAwO1xuICB2YXIgdGFnID0gZC50YWc7XG5cbiAgLyogZ2V0IG1vcmUgYml0cyB3aGlsZSBjb2RlIHZhbHVlIGlzIGFib3ZlIHN1bSAqL1xuICBkbyB7XG4gICAgY3VyID0gMiAqIGN1ciArICh0YWcgJiAxKTtcbiAgICB0YWcgPj4+PSAxO1xuICAgICsrbGVuO1xuXG4gICAgc3VtICs9IHQudGFibGVbbGVuXTtcbiAgICBjdXIgLT0gdC50YWJsZVtsZW5dO1xuICB9IHdoaWxlIChjdXIgPj0gMCk7XG4gIFxuICBkLnRhZyA9IHRhZztcbiAgZC5iaXRjb3VudCAtPSBsZW47XG5cbiAgcmV0dXJuIHQudHJhbnNbc3VtICsgY3VyXTtcbn1cblxuLyogZ2l2ZW4gYSBkYXRhIHN0cmVhbSwgZGVjb2RlIGR5bmFtaWMgdHJlZXMgZnJvbSBpdCAqL1xuZnVuY3Rpb24gdGluZl9kZWNvZGVfdHJlZXMoZCwgbHQsIGR0KSB7XG4gIHZhciBobGl0LCBoZGlzdCwgaGNsZW47XG4gIHZhciBpLCBudW0sIGxlbmd0aDtcblxuICAvKiBnZXQgNSBiaXRzIEhMSVQgKDI1Ny0yODYpICovXG4gIGhsaXQgPSB0aW5mX3JlYWRfYml0cyhkLCA1LCAyNTcpO1xuXG4gIC8qIGdldCA1IGJpdHMgSERJU1QgKDEtMzIpICovXG4gIGhkaXN0ID0gdGluZl9yZWFkX2JpdHMoZCwgNSwgMSk7XG5cbiAgLyogZ2V0IDQgYml0cyBIQ0xFTiAoNC0xOSkgKi9cbiAgaGNsZW4gPSB0aW5mX3JlYWRfYml0cyhkLCA0LCA0KTtcblxuICBmb3IgKGkgPSAwOyBpIDwgMTk7ICsraSkgeyBsZW5ndGhzW2ldID0gMDsgfVxuXG4gIC8qIHJlYWQgY29kZSBsZW5ndGhzIGZvciBjb2RlIGxlbmd0aCBhbHBoYWJldCAqL1xuICBmb3IgKGkgPSAwOyBpIDwgaGNsZW47ICsraSkge1xuICAgIC8qIGdldCAzIGJpdHMgY29kZSBsZW5ndGggKDAtNykgKi9cbiAgICB2YXIgY2xlbiA9IHRpbmZfcmVhZF9iaXRzKGQsIDMsIDApO1xuICAgIGxlbmd0aHNbY2xjaWR4W2ldXSA9IGNsZW47XG4gIH1cblxuICAvKiBidWlsZCBjb2RlIGxlbmd0aCB0cmVlICovXG4gIHRpbmZfYnVpbGRfdHJlZShjb2RlX3RyZWUsIGxlbmd0aHMsIDAsIDE5KTtcblxuICAvKiBkZWNvZGUgY29kZSBsZW5ndGhzIGZvciB0aGUgZHluYW1pYyB0cmVlcyAqL1xuICBmb3IgKG51bSA9IDA7IG51bSA8IGhsaXQgKyBoZGlzdDspIHtcbiAgICB2YXIgc3ltID0gdGluZl9kZWNvZGVfc3ltYm9sKGQsIGNvZGVfdHJlZSk7XG5cbiAgICBzd2l0Y2ggKHN5bSkge1xuICAgICAgY2FzZSAxNjpcbiAgICAgICAgLyogY29weSBwcmV2aW91cyBjb2RlIGxlbmd0aCAzLTYgdGltZXMgKHJlYWQgMiBiaXRzKSAqL1xuICAgICAgICB2YXIgcHJldiA9IGxlbmd0aHNbbnVtIC0gMV07XG4gICAgICAgIGZvciAobGVuZ3RoID0gdGluZl9yZWFkX2JpdHMoZCwgMiwgMyk7IGxlbmd0aDsgLS1sZW5ndGgpIHtcbiAgICAgICAgICBsZW5ndGhzW251bSsrXSA9IHByZXY7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDE3OlxuICAgICAgICAvKiByZXBlYXQgY29kZSBsZW5ndGggMCBmb3IgMy0xMCB0aW1lcyAocmVhZCAzIGJpdHMpICovXG4gICAgICAgIGZvciAobGVuZ3RoID0gdGluZl9yZWFkX2JpdHMoZCwgMywgMyk7IGxlbmd0aDsgLS1sZW5ndGgpIHtcbiAgICAgICAgICBsZW5ndGhzW251bSsrXSA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDE4OlxuICAgICAgICAvKiByZXBlYXQgY29kZSBsZW5ndGggMCBmb3IgMTEtMTM4IHRpbWVzIChyZWFkIDcgYml0cykgKi9cbiAgICAgICAgZm9yIChsZW5ndGggPSB0aW5mX3JlYWRfYml0cyhkLCA3LCAxMSk7IGxlbmd0aDsgLS1sZW5ndGgpIHtcbiAgICAgICAgICBsZW5ndGhzW251bSsrXSA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICAvKiB2YWx1ZXMgMC0xNSByZXByZXNlbnQgdGhlIGFjdHVhbCBjb2RlIGxlbmd0aHMgKi9cbiAgICAgICAgbGVuZ3Roc1tudW0rK10gPSBzeW07XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuXG4gIC8qIGJ1aWxkIGR5bmFtaWMgdHJlZXMgKi9cbiAgdGluZl9idWlsZF90cmVlKGx0LCBsZW5ndGhzLCAwLCBobGl0KTtcbiAgdGluZl9idWlsZF90cmVlKGR0LCBsZW5ndGhzLCBobGl0LCBoZGlzdCk7XG59XG5cbi8qIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICpcbiAqIC0tIGJsb2NrIGluZmxhdGUgZnVuY3Rpb25zIC0tICpcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICovXG5cbi8qIGdpdmVuIGEgc3RyZWFtIGFuZCB0d28gdHJlZXMsIGluZmxhdGUgYSBibG9jayBvZiBkYXRhICovXG5mdW5jdGlvbiB0aW5mX2luZmxhdGVfYmxvY2tfZGF0YShkLCBsdCwgZHQpIHtcbiAgd2hpbGUgKDEpIHtcbiAgICB2YXIgc3ltID0gdGluZl9kZWNvZGVfc3ltYm9sKGQsIGx0KTtcblxuICAgIC8qIGNoZWNrIGZvciBlbmQgb2YgYmxvY2sgKi9cbiAgICBpZiAoc3ltID09PSAyNTYpIHtcbiAgICAgIHJldHVybiBUSU5GX09LO1xuICAgIH1cblxuICAgIGlmIChzeW0gPCAyNTYpIHtcbiAgICAgIGQuZGVzdFtkLmRlc3RMZW4rK10gPSBzeW07XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBsZW5ndGgsIGRpc3QsIG9mZnM7XG4gICAgICB2YXIgaTtcblxuICAgICAgc3ltIC09IDI1NztcblxuICAgICAgLyogcG9zc2libHkgZ2V0IG1vcmUgYml0cyBmcm9tIGxlbmd0aCBjb2RlICovXG4gICAgICBsZW5ndGggPSB0aW5mX3JlYWRfYml0cyhkLCBsZW5ndGhfYml0c1tzeW1dLCBsZW5ndGhfYmFzZVtzeW1dKTtcblxuICAgICAgZGlzdCA9IHRpbmZfZGVjb2RlX3N5bWJvbChkLCBkdCk7XG5cbiAgICAgIC8qIHBvc3NpYmx5IGdldCBtb3JlIGJpdHMgZnJvbSBkaXN0YW5jZSBjb2RlICovXG4gICAgICBvZmZzID0gZC5kZXN0TGVuIC0gdGluZl9yZWFkX2JpdHMoZCwgZGlzdF9iaXRzW2Rpc3RdLCBkaXN0X2Jhc2VbZGlzdF0pO1xuXG4gICAgICAvKiBjb3B5IG1hdGNoICovXG4gICAgICBmb3IgKGkgPSBvZmZzOyBpIDwgb2ZmcyArIGxlbmd0aDsgKytpKSB7XG4gICAgICAgIGQuZGVzdFtkLmRlc3RMZW4rK10gPSBkLmRlc3RbaV07XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbi8qIGluZmxhdGUgYW4gdW5jb21wcmVzc2VkIGJsb2NrIG9mIGRhdGEgKi9cbmZ1bmN0aW9uIHRpbmZfaW5mbGF0ZV91bmNvbXByZXNzZWRfYmxvY2soZCkge1xuICB2YXIgbGVuZ3RoLCBpbnZsZW5ndGg7XG4gIHZhciBpO1xuICBcbiAgLyogdW5yZWFkIGZyb20gYml0YnVmZmVyICovXG4gIHdoaWxlIChkLmJpdGNvdW50ID4gOCkge1xuICAgIGQuc291cmNlSW5kZXgtLTtcbiAgICBkLmJpdGNvdW50IC09IDg7XG4gIH1cblxuICAvKiBnZXQgbGVuZ3RoICovXG4gIGxlbmd0aCA9IGQuc291cmNlW2Quc291cmNlSW5kZXggKyAxXTtcbiAgbGVuZ3RoID0gMjU2ICogbGVuZ3RoICsgZC5zb3VyY2VbZC5zb3VyY2VJbmRleF07XG5cbiAgLyogZ2V0IG9uZSdzIGNvbXBsZW1lbnQgb2YgbGVuZ3RoICovXG4gIGludmxlbmd0aCA9IGQuc291cmNlW2Quc291cmNlSW5kZXggKyAzXTtcbiAgaW52bGVuZ3RoID0gMjU2ICogaW52bGVuZ3RoICsgZC5zb3VyY2VbZC5zb3VyY2VJbmRleCArIDJdO1xuXG4gIC8qIGNoZWNrIGxlbmd0aCAqL1xuICBpZiAobGVuZ3RoICE9PSAofmludmxlbmd0aCAmIDB4MDAwMGZmZmYpKVxuICAgIHsgcmV0dXJuIFRJTkZfREFUQV9FUlJPUjsgfVxuXG4gIGQuc291cmNlSW5kZXggKz0gNDtcblxuICAvKiBjb3B5IGJsb2NrICovXG4gIGZvciAoaSA9IGxlbmd0aDsgaTsgLS1pKVxuICAgIHsgZC5kZXN0W2QuZGVzdExlbisrXSA9IGQuc291cmNlW2Quc291cmNlSW5kZXgrK107IH1cblxuICAvKiBtYWtlIHN1cmUgd2Ugc3RhcnQgbmV4dCBibG9jayBvbiBhIGJ5dGUgYm91bmRhcnkgKi9cbiAgZC5iaXRjb3VudCA9IDA7XG5cbiAgcmV0dXJuIFRJTkZfT0s7XG59XG5cbi8qIGluZmxhdGUgc3RyZWFtIGZyb20gc291cmNlIHRvIGRlc3QgKi9cbmZ1bmN0aW9uIHRpbmZfdW5jb21wcmVzcyhzb3VyY2UsIGRlc3QpIHtcbiAgdmFyIGQgPSBuZXcgRGF0YShzb3VyY2UsIGRlc3QpO1xuICB2YXIgYmZpbmFsLCBidHlwZSwgcmVzO1xuXG4gIGRvIHtcbiAgICAvKiByZWFkIGZpbmFsIGJsb2NrIGZsYWcgKi9cbiAgICBiZmluYWwgPSB0aW5mX2dldGJpdChkKTtcblxuICAgIC8qIHJlYWQgYmxvY2sgdHlwZSAoMiBiaXRzKSAqL1xuICAgIGJ0eXBlID0gdGluZl9yZWFkX2JpdHMoZCwgMiwgMCk7XG5cbiAgICAvKiBkZWNvbXByZXNzIGJsb2NrICovXG4gICAgc3dpdGNoIChidHlwZSkge1xuICAgICAgY2FzZSAwOlxuICAgICAgICAvKiBkZWNvbXByZXNzIHVuY29tcHJlc3NlZCBibG9jayAqL1xuICAgICAgICByZXMgPSB0aW5mX2luZmxhdGVfdW5jb21wcmVzc2VkX2Jsb2NrKGQpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMTpcbiAgICAgICAgLyogZGVjb21wcmVzcyBibG9jayB3aXRoIGZpeGVkIGh1ZmZtYW4gdHJlZXMgKi9cbiAgICAgICAgcmVzID0gdGluZl9pbmZsYXRlX2Jsb2NrX2RhdGEoZCwgc2x0cmVlLCBzZHRyZWUpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMjpcbiAgICAgICAgLyogZGVjb21wcmVzcyBibG9jayB3aXRoIGR5bmFtaWMgaHVmZm1hbiB0cmVlcyAqL1xuICAgICAgICB0aW5mX2RlY29kZV90cmVlcyhkLCBkLmx0cmVlLCBkLmR0cmVlKTtcbiAgICAgICAgcmVzID0gdGluZl9pbmZsYXRlX2Jsb2NrX2RhdGEoZCwgZC5sdHJlZSwgZC5kdHJlZSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmVzID0gVElORl9EQVRBX0VSUk9SO1xuICAgIH1cblxuICAgIGlmIChyZXMgIT09IFRJTkZfT0spXG4gICAgICB7IHRocm93IG5ldyBFcnJvcignRGF0YSBlcnJvcicpOyB9XG5cbiAgfSB3aGlsZSAoIWJmaW5hbCk7XG5cbiAgaWYgKGQuZGVzdExlbiA8IGQuZGVzdC5sZW5ndGgpIHtcbiAgICBpZiAodHlwZW9mIGQuZGVzdC5zbGljZSA9PT0gJ2Z1bmN0aW9uJylcbiAgICAgIHsgcmV0dXJuIGQuZGVzdC5zbGljZSgwLCBkLmRlc3RMZW4pOyB9XG4gICAgZWxzZVxuICAgICAgeyByZXR1cm4gZC5kZXN0LnN1YmFycmF5KDAsIGQuZGVzdExlbik7IH1cbiAgfVxuICBcbiAgcmV0dXJuIGQuZGVzdDtcbn1cblxuLyogLS0tLS0tLS0tLS0tLS0tLS0tLS0gKlxuICogLS0gaW5pdGlhbGl6YXRpb24gLS0gKlxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0gKi9cblxuLyogYnVpbGQgZml4ZWQgaHVmZm1hbiB0cmVlcyAqL1xudGluZl9idWlsZF9maXhlZF90cmVlcyhzbHRyZWUsIHNkdHJlZSk7XG5cbi8qIGJ1aWxkIGV4dHJhIGJpdHMgYW5kIGJhc2UgdGFibGVzICovXG50aW5mX2J1aWxkX2JpdHNfYmFzZShsZW5ndGhfYml0cywgbGVuZ3RoX2Jhc2UsIDQsIDMpO1xudGluZl9idWlsZF9iaXRzX2Jhc2UoZGlzdF9iaXRzLCBkaXN0X2Jhc2UsIDIsIDEpO1xuXG4vKiBmaXggYSBzcGVjaWFsIGNhc2UgKi9cbmxlbmd0aF9iaXRzWzI4XSA9IDA7XG5sZW5ndGhfYmFzZVsyOF0gPSAyNTg7XG5cbnZhciB0aW55SW5mbGF0ZSA9IHRpbmZfdW5jb21wcmVzcztcblxuLy8gVGhlIEJvdW5kaW5nIEJveCBvYmplY3RcblxuZnVuY3Rpb24gZGVyaXZlKHYwLCB2MSwgdjIsIHYzLCB0KSB7XG4gICAgcmV0dXJuIE1hdGgucG93KDEgLSB0LCAzKSAqIHYwICtcbiAgICAgICAgMyAqIE1hdGgucG93KDEgLSB0LCAyKSAqIHQgKiB2MSArXG4gICAgICAgIDMgKiAoMSAtIHQpICogTWF0aC5wb3codCwgMikgKiB2MiArXG4gICAgICAgIE1hdGgucG93KHQsIDMpICogdjM7XG59XG4vKipcbiAqIEEgYm91bmRpbmcgYm94IGlzIGFuIGVuY2xvc2luZyBib3ggdGhhdCBkZXNjcmliZXMgdGhlIHNtYWxsZXN0IG1lYXN1cmUgd2l0aGluIHdoaWNoIGFsbCB0aGUgcG9pbnRzIGxpZS5cbiAqIEl0IGlzIHVzZWQgdG8gY2FsY3VsYXRlIHRoZSBib3VuZGluZyBib3ggb2YgYSBnbHlwaCBvciB0ZXh0IHBhdGguXG4gKlxuICogT24gaW5pdGlhbGl6YXRpb24sIHgxL3kxL3gyL3kyIHdpbGwgYmUgTmFOLiBDaGVjayBpZiB0aGUgYm91bmRpbmcgYm94IGlzIGVtcHR5IHVzaW5nIGBpc0VtcHR5KClgLlxuICpcbiAqIEBleHBvcnRzIG9wZW50eXBlLkJvdW5kaW5nQm94XG4gKiBAY2xhc3NcbiAqIEBjb25zdHJ1Y3RvclxuICovXG5mdW5jdGlvbiBCb3VuZGluZ0JveCgpIHtcbiAgICB0aGlzLngxID0gTnVtYmVyLk5hTjtcbiAgICB0aGlzLnkxID0gTnVtYmVyLk5hTjtcbiAgICB0aGlzLngyID0gTnVtYmVyLk5hTjtcbiAgICB0aGlzLnkyID0gTnVtYmVyLk5hTjtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgdGhlIGJvdW5kaW5nIGJveCBpcyBlbXB0eSwgdGhhdCBpcywgbm8gcG9pbnRzIGhhdmUgYmVlbiBhZGRlZCB0byB0aGUgYm94IHlldC5cbiAqL1xuQm91bmRpbmdCb3gucHJvdG90eXBlLmlzRW1wdHkgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gaXNOYU4odGhpcy54MSkgfHwgaXNOYU4odGhpcy55MSkgfHwgaXNOYU4odGhpcy54MikgfHwgaXNOYU4odGhpcy55Mik7XG59O1xuXG4vKipcbiAqIEFkZCB0aGUgcG9pbnQgdG8gdGhlIGJvdW5kaW5nIGJveC5cbiAqIFRoZSB4MS95MS94Mi95MiBjb29yZGluYXRlcyBvZiB0aGUgYm91bmRpbmcgYm94IHdpbGwgbm93IGVuY29tcGFzcyB0aGUgZ2l2ZW4gcG9pbnQuXG4gKiBAcGFyYW0ge251bWJlcn0geCAtIFRoZSBYIGNvb3JkaW5hdGUgb2YgdGhlIHBvaW50LlxuICogQHBhcmFtIHtudW1iZXJ9IHkgLSBUaGUgWSBjb29yZGluYXRlIG9mIHRoZSBwb2ludC5cbiAqL1xuQm91bmRpbmdCb3gucHJvdG90eXBlLmFkZFBvaW50ID0gZnVuY3Rpb24oeCwgeSkge1xuICAgIGlmICh0eXBlb2YgeCA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgaWYgKGlzTmFOKHRoaXMueDEpIHx8IGlzTmFOKHRoaXMueDIpKSB7XG4gICAgICAgICAgICB0aGlzLngxID0geDtcbiAgICAgICAgICAgIHRoaXMueDIgPSB4O1xuICAgICAgICB9XG4gICAgICAgIGlmICh4IDwgdGhpcy54MSkge1xuICAgICAgICAgICAgdGhpcy54MSA9IHg7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHggPiB0aGlzLngyKSB7XG4gICAgICAgICAgICB0aGlzLngyID0geDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAodHlwZW9mIHkgPT09ICdudW1iZXInKSB7XG4gICAgICAgIGlmIChpc05hTih0aGlzLnkxKSB8fCBpc05hTih0aGlzLnkyKSkge1xuICAgICAgICAgICAgdGhpcy55MSA9IHk7XG4gICAgICAgICAgICB0aGlzLnkyID0geTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoeSA8IHRoaXMueTEpIHtcbiAgICAgICAgICAgIHRoaXMueTEgPSB5O1xuICAgICAgICB9XG4gICAgICAgIGlmICh5ID4gdGhpcy55Mikge1xuICAgICAgICAgICAgdGhpcy55MiA9IHk7XG4gICAgICAgIH1cbiAgICB9XG59O1xuXG4vKipcbiAqIEFkZCBhIFggY29vcmRpbmF0ZSB0byB0aGUgYm91bmRpbmcgYm94LlxuICogVGhpcyBleHRlbmRzIHRoZSBib3VuZGluZyBib3ggdG8gaW5jbHVkZSB0aGUgWCBjb29yZGluYXRlLlxuICogVGhpcyBmdW5jdGlvbiBpcyB1c2VkIGludGVybmFsbHkgaW5zaWRlIG9mIGFkZEJlemllci5cbiAqIEBwYXJhbSB7bnVtYmVyfSB4IC0gVGhlIFggY29vcmRpbmF0ZSBvZiB0aGUgcG9pbnQuXG4gKi9cbkJvdW5kaW5nQm94LnByb3RvdHlwZS5hZGRYID0gZnVuY3Rpb24oeCkge1xuICAgIHRoaXMuYWRkUG9pbnQoeCwgbnVsbCk7XG59O1xuXG4vKipcbiAqIEFkZCBhIFkgY29vcmRpbmF0ZSB0byB0aGUgYm91bmRpbmcgYm94LlxuICogVGhpcyBleHRlbmRzIHRoZSBib3VuZGluZyBib3ggdG8gaW5jbHVkZSB0aGUgWSBjb29yZGluYXRlLlxuICogVGhpcyBmdW5jdGlvbiBpcyB1c2VkIGludGVybmFsbHkgaW5zaWRlIG9mIGFkZEJlemllci5cbiAqIEBwYXJhbSB7bnVtYmVyfSB5IC0gVGhlIFkgY29vcmRpbmF0ZSBvZiB0aGUgcG9pbnQuXG4gKi9cbkJvdW5kaW5nQm94LnByb3RvdHlwZS5hZGRZID0gZnVuY3Rpb24oeSkge1xuICAgIHRoaXMuYWRkUG9pbnQobnVsbCwgeSk7XG59O1xuXG4vKipcbiAqIEFkZCBhIELDqXppZXIgY3VydmUgdG8gdGhlIGJvdW5kaW5nIGJveC5cbiAqIFRoaXMgZXh0ZW5kcyB0aGUgYm91bmRpbmcgYm94IHRvIGluY2x1ZGUgdGhlIGVudGlyZSBCw6l6aWVyLlxuICogQHBhcmFtIHtudW1iZXJ9IHgwIC0gVGhlIHN0YXJ0aW5nIFggY29vcmRpbmF0ZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSB5MCAtIFRoZSBzdGFydGluZyBZIGNvb3JkaW5hdGUuXG4gKiBAcGFyYW0ge251bWJlcn0geDEgLSBUaGUgWCBjb29yZGluYXRlIG9mIHRoZSBmaXJzdCBjb250cm9sIHBvaW50LlxuICogQHBhcmFtIHtudW1iZXJ9IHkxIC0gVGhlIFkgY29vcmRpbmF0ZSBvZiB0aGUgZmlyc3QgY29udHJvbCBwb2ludC5cbiAqIEBwYXJhbSB7bnVtYmVyfSB4MiAtIFRoZSBYIGNvb3JkaW5hdGUgb2YgdGhlIHNlY29uZCBjb250cm9sIHBvaW50LlxuICogQHBhcmFtIHtudW1iZXJ9IHkyIC0gVGhlIFkgY29vcmRpbmF0ZSBvZiB0aGUgc2Vjb25kIGNvbnRyb2wgcG9pbnQuXG4gKiBAcGFyYW0ge251bWJlcn0geCAtIFRoZSBlbmRpbmcgWCBjb29yZGluYXRlLlxuICogQHBhcmFtIHtudW1iZXJ9IHkgLSBUaGUgZW5kaW5nIFkgY29vcmRpbmF0ZS5cbiAqL1xuQm91bmRpbmdCb3gucHJvdG90eXBlLmFkZEJlemllciA9IGZ1bmN0aW9uKHgwLCB5MCwgeDEsIHkxLCB4MiwgeTIsIHgsIHkpIHtcbiAgICAvLyBUaGlzIGNvZGUgaXMgYmFzZWQgb24gaHR0cDovL25pc2hpb2hpcm9rYXp1LmJsb2dzcG90LmNvbS8yMDA5LzA2L2hvdy10by1jYWxjdWxhdGUtYmV6aWVyLWN1cnZlcy1ib3VuZGluZy5odG1sXG4gICAgLy8gYW5kIGh0dHBzOi8vZ2l0aHViLmNvbS9pY29uczgvc3ZnLXBhdGgtYm91bmRpbmctYm94XG5cbiAgICB2YXIgcDAgPSBbeDAsIHkwXTtcbiAgICB2YXIgcDEgPSBbeDEsIHkxXTtcbiAgICB2YXIgcDIgPSBbeDIsIHkyXTtcbiAgICB2YXIgcDMgPSBbeCwgeV07XG5cbiAgICB0aGlzLmFkZFBvaW50KHgwLCB5MCk7XG4gICAgdGhpcy5hZGRQb2ludCh4LCB5KTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDw9IDE7IGkrKykge1xuICAgICAgICB2YXIgYiA9IDYgKiBwMFtpXSAtIDEyICogcDFbaV0gKyA2ICogcDJbaV07XG4gICAgICAgIHZhciBhID0gLTMgKiBwMFtpXSArIDkgKiBwMVtpXSAtIDkgKiBwMltpXSArIDMgKiBwM1tpXTtcbiAgICAgICAgdmFyIGMgPSAzICogcDFbaV0gLSAzICogcDBbaV07XG5cbiAgICAgICAgaWYgKGEgPT09IDApIHtcbiAgICAgICAgICAgIGlmIChiID09PSAwKSB7IGNvbnRpbnVlOyB9XG4gICAgICAgICAgICB2YXIgdCA9IC1jIC8gYjtcbiAgICAgICAgICAgIGlmICgwIDwgdCAmJiB0IDwgMSkge1xuICAgICAgICAgICAgICAgIGlmIChpID09PSAwKSB7IHRoaXMuYWRkWChkZXJpdmUocDBbaV0sIHAxW2ldLCBwMltpXSwgcDNbaV0sIHQpKTsgfVxuICAgICAgICAgICAgICAgIGlmIChpID09PSAxKSB7IHRoaXMuYWRkWShkZXJpdmUocDBbaV0sIHAxW2ldLCBwMltpXSwgcDNbaV0sIHQpKTsgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgYjJhYyA9IE1hdGgucG93KGIsIDIpIC0gNCAqIGMgKiBhO1xuICAgICAgICBpZiAoYjJhYyA8IDApIHsgY29udGludWU7IH1cbiAgICAgICAgdmFyIHQxID0gKC1iICsgTWF0aC5zcXJ0KGIyYWMpKSAvICgyICogYSk7XG4gICAgICAgIGlmICgwIDwgdDEgJiYgdDEgPCAxKSB7XG4gICAgICAgICAgICBpZiAoaSA9PT0gMCkgeyB0aGlzLmFkZFgoZGVyaXZlKHAwW2ldLCBwMVtpXSwgcDJbaV0sIHAzW2ldLCB0MSkpOyB9XG4gICAgICAgICAgICBpZiAoaSA9PT0gMSkgeyB0aGlzLmFkZFkoZGVyaXZlKHAwW2ldLCBwMVtpXSwgcDJbaV0sIHAzW2ldLCB0MSkpOyB9XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHQyID0gKC1iIC0gTWF0aC5zcXJ0KGIyYWMpKSAvICgyICogYSk7XG4gICAgICAgIGlmICgwIDwgdDIgJiYgdDIgPCAxKSB7XG4gICAgICAgICAgICBpZiAoaSA9PT0gMCkgeyB0aGlzLmFkZFgoZGVyaXZlKHAwW2ldLCBwMVtpXSwgcDJbaV0sIHAzW2ldLCB0MikpOyB9XG4gICAgICAgICAgICBpZiAoaSA9PT0gMSkgeyB0aGlzLmFkZFkoZGVyaXZlKHAwW2ldLCBwMVtpXSwgcDJbaV0sIHAzW2ldLCB0MikpOyB9XG4gICAgICAgIH1cbiAgICB9XG59O1xuXG4vKipcbiAqIEFkZCBhIHF1YWRyYXRpYyBjdXJ2ZSB0byB0aGUgYm91bmRpbmcgYm94LlxuICogVGhpcyBleHRlbmRzIHRoZSBib3VuZGluZyBib3ggdG8gaW5jbHVkZSB0aGUgZW50aXJlIHF1YWRyYXRpYyBjdXJ2ZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSB4MCAtIFRoZSBzdGFydGluZyBYIGNvb3JkaW5hdGUuXG4gKiBAcGFyYW0ge251bWJlcn0geTAgLSBUaGUgc3RhcnRpbmcgWSBjb29yZGluYXRlLlxuICogQHBhcmFtIHtudW1iZXJ9IHgxIC0gVGhlIFggY29vcmRpbmF0ZSBvZiB0aGUgY29udHJvbCBwb2ludC5cbiAqIEBwYXJhbSB7bnVtYmVyfSB5MSAtIFRoZSBZIGNvb3JkaW5hdGUgb2YgdGhlIGNvbnRyb2wgcG9pbnQuXG4gKiBAcGFyYW0ge251bWJlcn0geCAtIFRoZSBlbmRpbmcgWCBjb29yZGluYXRlLlxuICogQHBhcmFtIHtudW1iZXJ9IHkgLSBUaGUgZW5kaW5nIFkgY29vcmRpbmF0ZS5cbiAqL1xuQm91bmRpbmdCb3gucHJvdG90eXBlLmFkZFF1YWQgPSBmdW5jdGlvbih4MCwgeTAsIHgxLCB5MSwgeCwgeSkge1xuICAgIHZhciBjcDF4ID0geDAgKyAyIC8gMyAqICh4MSAtIHgwKTtcbiAgICB2YXIgY3AxeSA9IHkwICsgMiAvIDMgKiAoeTEgLSB5MCk7XG4gICAgdmFyIGNwMnggPSBjcDF4ICsgMSAvIDMgKiAoeCAtIHgwKTtcbiAgICB2YXIgY3AyeSA9IGNwMXkgKyAxIC8gMyAqICh5IC0geTApO1xuICAgIHRoaXMuYWRkQmV6aWVyKHgwLCB5MCwgY3AxeCwgY3AxeSwgY3AyeCwgY3AyeSwgeCwgeSk7XG59O1xuXG4vLyBHZW9tZXRyaWMgb2JqZWN0c1xuXG4vKipcbiAqIEEgYsOpemllciBwYXRoIGNvbnRhaW5pbmcgYSBzZXQgb2YgcGF0aCBjb21tYW5kcyBzaW1pbGFyIHRvIGEgU1ZHIHBhdGguXG4gKiBQYXRocyBjYW4gYmUgZHJhd24gb24gYSBjb250ZXh0IHVzaW5nIGBkcmF3YC5cbiAqIEBleHBvcnRzIG9wZW50eXBlLlBhdGhcbiAqIEBjbGFzc1xuICogQGNvbnN0cnVjdG9yXG4gKi9cbmZ1bmN0aW9uIFBhdGgoKSB7XG4gICAgdGhpcy5jb21tYW5kcyA9IFtdO1xuICAgIHRoaXMuZmlsbCA9ICdibGFjayc7XG4gICAgdGhpcy5zdHJva2UgPSBudWxsO1xuICAgIHRoaXMuc3Ryb2tlV2lkdGggPSAxO1xufVxuXG4vKipcbiAqIEBwYXJhbSAge251bWJlcn0geFxuICogQHBhcmFtICB7bnVtYmVyfSB5XG4gKi9cblBhdGgucHJvdG90eXBlLm1vdmVUbyA9IGZ1bmN0aW9uKHgsIHkpIHtcbiAgICB0aGlzLmNvbW1hbmRzLnB1c2goe1xuICAgICAgICB0eXBlOiAnTScsXG4gICAgICAgIHg6IHgsXG4gICAgICAgIHk6IHlcbiAgICB9KTtcbn07XG5cbi8qKlxuICogQHBhcmFtICB7bnVtYmVyfSB4XG4gKiBAcGFyYW0gIHtudW1iZXJ9IHlcbiAqL1xuUGF0aC5wcm90b3R5cGUubGluZVRvID0gZnVuY3Rpb24oeCwgeSkge1xuICAgIHRoaXMuY29tbWFuZHMucHVzaCh7XG4gICAgICAgIHR5cGU6ICdMJyxcbiAgICAgICAgeDogeCxcbiAgICAgICAgeTogeVxuICAgIH0pO1xufTtcblxuLyoqXG4gKiBEcmF3cyBjdWJpYyBjdXJ2ZVxuICogQGZ1bmN0aW9uXG4gKiBjdXJ2ZVRvXG4gKiBAbWVtYmVyb2Ygb3BlbnR5cGUuUGF0aC5wcm90b3R5cGVcbiAqIEBwYXJhbSAge251bWJlcn0geDEgLSB4IG9mIGNvbnRyb2wgMVxuICogQHBhcmFtICB7bnVtYmVyfSB5MSAtIHkgb2YgY29udHJvbCAxXG4gKiBAcGFyYW0gIHtudW1iZXJ9IHgyIC0geCBvZiBjb250cm9sIDJcbiAqIEBwYXJhbSAge251bWJlcn0geTIgLSB5IG9mIGNvbnRyb2wgMlxuICogQHBhcmFtICB7bnVtYmVyfSB4IC0geCBvZiBwYXRoIHBvaW50XG4gKiBAcGFyYW0gIHtudW1iZXJ9IHkgLSB5IG9mIHBhdGggcG9pbnRcbiAqL1xuXG4vKipcbiAqIERyYXdzIGN1YmljIGN1cnZlXG4gKiBAZnVuY3Rpb25cbiAqIGJlemllckN1cnZlVG9cbiAqIEBtZW1iZXJvZiBvcGVudHlwZS5QYXRoLnByb3RvdHlwZVxuICogQHBhcmFtICB7bnVtYmVyfSB4MSAtIHggb2YgY29udHJvbCAxXG4gKiBAcGFyYW0gIHtudW1iZXJ9IHkxIC0geSBvZiBjb250cm9sIDFcbiAqIEBwYXJhbSAge251bWJlcn0geDIgLSB4IG9mIGNvbnRyb2wgMlxuICogQHBhcmFtICB7bnVtYmVyfSB5MiAtIHkgb2YgY29udHJvbCAyXG4gKiBAcGFyYW0gIHtudW1iZXJ9IHggLSB4IG9mIHBhdGggcG9pbnRcbiAqIEBwYXJhbSAge251bWJlcn0geSAtIHkgb2YgcGF0aCBwb2ludFxuICogQHNlZSBjdXJ2ZVRvXG4gKi9cblBhdGgucHJvdG90eXBlLmN1cnZlVG8gPSBQYXRoLnByb3RvdHlwZS5iZXppZXJDdXJ2ZVRvID0gZnVuY3Rpb24oeDEsIHkxLCB4MiwgeTIsIHgsIHkpIHtcbiAgICB0aGlzLmNvbW1hbmRzLnB1c2goe1xuICAgICAgICB0eXBlOiAnQycsXG4gICAgICAgIHgxOiB4MSxcbiAgICAgICAgeTE6IHkxLFxuICAgICAgICB4MjogeDIsXG4gICAgICAgIHkyOiB5MixcbiAgICAgICAgeDogeCxcbiAgICAgICAgeTogeVxuICAgIH0pO1xufTtcblxuLyoqXG4gKiBEcmF3cyBxdWFkcmF0aWMgY3VydmVcbiAqIEBmdW5jdGlvblxuICogcXVhZHJhdGljQ3VydmVUb1xuICogQG1lbWJlcm9mIG9wZW50eXBlLlBhdGgucHJvdG90eXBlXG4gKiBAcGFyYW0gIHtudW1iZXJ9IHgxIC0geCBvZiBjb250cm9sXG4gKiBAcGFyYW0gIHtudW1iZXJ9IHkxIC0geSBvZiBjb250cm9sXG4gKiBAcGFyYW0gIHtudW1iZXJ9IHggLSB4IG9mIHBhdGggcG9pbnRcbiAqIEBwYXJhbSAge251bWJlcn0geSAtIHkgb2YgcGF0aCBwb2ludFxuICovXG5cbi8qKlxuICogRHJhd3MgcXVhZHJhdGljIGN1cnZlXG4gKiBAZnVuY3Rpb25cbiAqIHF1YWRUb1xuICogQG1lbWJlcm9mIG9wZW50eXBlLlBhdGgucHJvdG90eXBlXG4gKiBAcGFyYW0gIHtudW1iZXJ9IHgxIC0geCBvZiBjb250cm9sXG4gKiBAcGFyYW0gIHtudW1iZXJ9IHkxIC0geSBvZiBjb250cm9sXG4gKiBAcGFyYW0gIHtudW1iZXJ9IHggLSB4IG9mIHBhdGggcG9pbnRcbiAqIEBwYXJhbSAge251bWJlcn0geSAtIHkgb2YgcGF0aCBwb2ludFxuICovXG5QYXRoLnByb3RvdHlwZS5xdWFkVG8gPSBQYXRoLnByb3RvdHlwZS5xdWFkcmF0aWNDdXJ2ZVRvID0gZnVuY3Rpb24oeDEsIHkxLCB4LCB5KSB7XG4gICAgdGhpcy5jb21tYW5kcy5wdXNoKHtcbiAgICAgICAgdHlwZTogJ1EnLFxuICAgICAgICB4MTogeDEsXG4gICAgICAgIHkxOiB5MSxcbiAgICAgICAgeDogeCxcbiAgICAgICAgeTogeVxuICAgIH0pO1xufTtcblxuLyoqXG4gKiBDbG9zZXMgdGhlIHBhdGhcbiAqIEBmdW5jdGlvbiBjbG9zZVBhdGhcbiAqIEBtZW1iZXJvZiBvcGVudHlwZS5QYXRoLnByb3RvdHlwZVxuICovXG5cbi8qKlxuICogQ2xvc2UgdGhlIHBhdGhcbiAqIEBmdW5jdGlvbiBjbG9zZVxuICogQG1lbWJlcm9mIG9wZW50eXBlLlBhdGgucHJvdG90eXBlXG4gKi9cblBhdGgucHJvdG90eXBlLmNsb3NlID0gUGF0aC5wcm90b3R5cGUuY2xvc2VQYXRoID0gZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5jb21tYW5kcy5wdXNoKHtcbiAgICAgICAgdHlwZTogJ1onXG4gICAgfSk7XG59O1xuXG4vKipcbiAqIEFkZCB0aGUgZ2l2ZW4gcGF0aCBvciBsaXN0IG9mIGNvbW1hbmRzIHRvIHRoZSBjb21tYW5kcyBvZiB0aGlzIHBhdGguXG4gKiBAcGFyYW0gIHtBcnJheX0gcGF0aE9yQ29tbWFuZHMgLSBhbm90aGVyIG9wZW50eXBlLlBhdGgsIGFuIG9wZW50eXBlLkJvdW5kaW5nQm94LCBvciBhbiBhcnJheSBvZiBjb21tYW5kcy5cbiAqL1xuUGF0aC5wcm90b3R5cGUuZXh0ZW5kID0gZnVuY3Rpb24ocGF0aE9yQ29tbWFuZHMpIHtcbiAgICBpZiAocGF0aE9yQ29tbWFuZHMuY29tbWFuZHMpIHtcbiAgICAgICAgcGF0aE9yQ29tbWFuZHMgPSBwYXRoT3JDb21tYW5kcy5jb21tYW5kcztcbiAgICB9IGVsc2UgaWYgKHBhdGhPckNvbW1hbmRzIGluc3RhbmNlb2YgQm91bmRpbmdCb3gpIHtcbiAgICAgICAgdmFyIGJveCA9IHBhdGhPckNvbW1hbmRzO1xuICAgICAgICB0aGlzLm1vdmVUbyhib3gueDEsIGJveC55MSk7XG4gICAgICAgIHRoaXMubGluZVRvKGJveC54MiwgYm94LnkxKTtcbiAgICAgICAgdGhpcy5saW5lVG8oYm94LngyLCBib3gueTIpO1xuICAgICAgICB0aGlzLmxpbmVUbyhib3gueDEsIGJveC55Mik7XG4gICAgICAgIHRoaXMuY2xvc2UoKTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIEFycmF5LnByb3RvdHlwZS5wdXNoLmFwcGx5KHRoaXMuY29tbWFuZHMsIHBhdGhPckNvbW1hbmRzKTtcbn07XG5cbi8qKlxuICogQ2FsY3VsYXRlIHRoZSBib3VuZGluZyBib3ggb2YgdGhlIHBhdGguXG4gKiBAcmV0dXJucyB7b3BlbnR5cGUuQm91bmRpbmdCb3h9XG4gKi9cblBhdGgucHJvdG90eXBlLmdldEJvdW5kaW5nQm94ID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGJveCA9IG5ldyBCb3VuZGluZ0JveCgpO1xuXG4gICAgdmFyIHN0YXJ0WCA9IDA7XG4gICAgdmFyIHN0YXJ0WSA9IDA7XG4gICAgdmFyIHByZXZYID0gMDtcbiAgICB2YXIgcHJldlkgPSAwO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5jb21tYW5kcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgY21kID0gdGhpcy5jb21tYW5kc1tpXTtcbiAgICAgICAgc3dpdGNoIChjbWQudHlwZSkge1xuICAgICAgICAgICAgY2FzZSAnTSc6XG4gICAgICAgICAgICAgICAgYm94LmFkZFBvaW50KGNtZC54LCBjbWQueSk7XG4gICAgICAgICAgICAgICAgc3RhcnRYID0gcHJldlggPSBjbWQueDtcbiAgICAgICAgICAgICAgICBzdGFydFkgPSBwcmV2WSA9IGNtZC55O1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnTCc6XG4gICAgICAgICAgICAgICAgYm94LmFkZFBvaW50KGNtZC54LCBjbWQueSk7XG4gICAgICAgICAgICAgICAgcHJldlggPSBjbWQueDtcbiAgICAgICAgICAgICAgICBwcmV2WSA9IGNtZC55O1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnUSc6XG4gICAgICAgICAgICAgICAgYm94LmFkZFF1YWQocHJldlgsIHByZXZZLCBjbWQueDEsIGNtZC55MSwgY21kLngsIGNtZC55KTtcbiAgICAgICAgICAgICAgICBwcmV2WCA9IGNtZC54O1xuICAgICAgICAgICAgICAgIHByZXZZID0gY21kLnk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdDJzpcbiAgICAgICAgICAgICAgICBib3guYWRkQmV6aWVyKHByZXZYLCBwcmV2WSwgY21kLngxLCBjbWQueTEsIGNtZC54MiwgY21kLnkyLCBjbWQueCwgY21kLnkpO1xuICAgICAgICAgICAgICAgIHByZXZYID0gY21kLng7XG4gICAgICAgICAgICAgICAgcHJldlkgPSBjbWQueTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ1onOlxuICAgICAgICAgICAgICAgIHByZXZYID0gc3RhcnRYO1xuICAgICAgICAgICAgICAgIHByZXZZID0gc3RhcnRZO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1VuZXhwZWN0ZWQgcGF0aCBjb21tYW5kICcgKyBjbWQudHlwZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKGJveC5pc0VtcHR5KCkpIHtcbiAgICAgICAgYm94LmFkZFBvaW50KDAsIDApO1xuICAgIH1cbiAgICByZXR1cm4gYm94O1xufTtcblxuLyoqXG4gKiBEcmF3IHRoZSBwYXRoIHRvIGEgMkQgY29udGV4dC5cbiAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHggLSBBIDJEIGRyYXdpbmcgY29udGV4dC5cbiAqL1xuUGF0aC5wcm90b3R5cGUuZHJhdyA9IGZ1bmN0aW9uKGN0eCkge1xuICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuY29tbWFuZHMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgdmFyIGNtZCA9IHRoaXMuY29tbWFuZHNbaV07XG4gICAgICAgIGlmIChjbWQudHlwZSA9PT0gJ00nKSB7XG4gICAgICAgICAgICBjdHgubW92ZVRvKGNtZC54LCBjbWQueSk7XG4gICAgICAgIH0gZWxzZSBpZiAoY21kLnR5cGUgPT09ICdMJykge1xuICAgICAgICAgICAgY3R4LmxpbmVUbyhjbWQueCwgY21kLnkpO1xuICAgICAgICB9IGVsc2UgaWYgKGNtZC50eXBlID09PSAnQycpIHtcbiAgICAgICAgICAgIGN0eC5iZXppZXJDdXJ2ZVRvKGNtZC54MSwgY21kLnkxLCBjbWQueDIsIGNtZC55MiwgY21kLngsIGNtZC55KTtcbiAgICAgICAgfSBlbHNlIGlmIChjbWQudHlwZSA9PT0gJ1EnKSB7XG4gICAgICAgICAgICBjdHgucXVhZHJhdGljQ3VydmVUbyhjbWQueDEsIGNtZC55MSwgY21kLngsIGNtZC55KTtcbiAgICAgICAgfSBlbHNlIGlmIChjbWQudHlwZSA9PT0gJ1onKSB7XG4gICAgICAgICAgICBjdHguY2xvc2VQYXRoKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAodGhpcy5maWxsKSB7XG4gICAgICAgIGN0eC5maWxsU3R5bGUgPSB0aGlzLmZpbGw7XG4gICAgICAgIGN0eC5maWxsKCk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuc3Ryb2tlKSB7XG4gICAgICAgIGN0eC5zdHJva2VTdHlsZSA9IHRoaXMuc3Ryb2tlO1xuICAgICAgICBjdHgubGluZVdpZHRoID0gdGhpcy5zdHJva2VXaWR0aDtcbiAgICAgICAgY3R4LnN0cm9rZSgpO1xuICAgIH1cbn07XG5cbi8qKlxuICogQ29udmVydCB0aGUgUGF0aCB0byBhIHN0cmluZyBvZiBwYXRoIGRhdGEgaW5zdHJ1Y3Rpb25zXG4gKiBTZWUgaHR0cDovL3d3dy53My5vcmcvVFIvU1ZHL3BhdGhzLmh0bWwjUGF0aERhdGFcbiAqIEBwYXJhbSAge251bWJlcn0gW2RlY2ltYWxQbGFjZXM9Ml0gLSBUaGUgYW1vdW50IG9mIGRlY2ltYWwgcGxhY2VzIGZvciBmbG9hdGluZy1wb2ludCB2YWx1ZXNcbiAqIEByZXR1cm4ge3N0cmluZ31cbiAqL1xuUGF0aC5wcm90b3R5cGUudG9QYXRoRGF0YSA9IGZ1bmN0aW9uKGRlY2ltYWxQbGFjZXMpIHtcbiAgICBkZWNpbWFsUGxhY2VzID0gZGVjaW1hbFBsYWNlcyAhPT0gdW5kZWZpbmVkID8gZGVjaW1hbFBsYWNlcyA6IDI7XG5cbiAgICBmdW5jdGlvbiBmbG9hdFRvU3RyaW5nKHYpIHtcbiAgICAgICAgaWYgKE1hdGgucm91bmQodikgPT09IHYpIHtcbiAgICAgICAgICAgIHJldHVybiAnJyArIE1hdGgucm91bmQodik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdi50b0ZpeGVkKGRlY2ltYWxQbGFjZXMpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcGFja1ZhbHVlcygpIHtcbiAgICAgICAgdmFyIGFyZ3VtZW50cyQxID0gYXJndW1lbnRzO1xuXG4gICAgICAgIHZhciBzID0gJyc7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgICAgICB2YXIgdiA9IGFyZ3VtZW50cyQxW2ldO1xuICAgICAgICAgICAgaWYgKHYgPj0gMCAmJiBpID4gMCkge1xuICAgICAgICAgICAgICAgIHMgKz0gJyAnO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBzICs9IGZsb2F0VG9TdHJpbmcodik7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcztcbiAgICB9XG5cbiAgICB2YXIgZCA9ICcnO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5jb21tYW5kcy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICB2YXIgY21kID0gdGhpcy5jb21tYW5kc1tpXTtcbiAgICAgICAgaWYgKGNtZC50eXBlID09PSAnTScpIHtcbiAgICAgICAgICAgIGQgKz0gJ00nICsgcGFja1ZhbHVlcyhjbWQueCwgY21kLnkpO1xuICAgICAgICB9IGVsc2UgaWYgKGNtZC50eXBlID09PSAnTCcpIHtcbiAgICAgICAgICAgIGQgKz0gJ0wnICsgcGFja1ZhbHVlcyhjbWQueCwgY21kLnkpO1xuICAgICAgICB9IGVsc2UgaWYgKGNtZC50eXBlID09PSAnQycpIHtcbiAgICAgICAgICAgIGQgKz0gJ0MnICsgcGFja1ZhbHVlcyhjbWQueDEsIGNtZC55MSwgY21kLngyLCBjbWQueTIsIGNtZC54LCBjbWQueSk7XG4gICAgICAgIH0gZWxzZSBpZiAoY21kLnR5cGUgPT09ICdRJykge1xuICAgICAgICAgICAgZCArPSAnUScgKyBwYWNrVmFsdWVzKGNtZC54MSwgY21kLnkxLCBjbWQueCwgY21kLnkpO1xuICAgICAgICB9IGVsc2UgaWYgKGNtZC50eXBlID09PSAnWicpIHtcbiAgICAgICAgICAgIGQgKz0gJ1onO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGQ7XG59O1xuXG4vKipcbiAqIENvbnZlcnQgdGhlIHBhdGggdG8gYW4gU1ZHIDxwYXRoPiBlbGVtZW50LCBhcyBhIHN0cmluZy5cbiAqIEBwYXJhbSAge251bWJlcn0gW2RlY2ltYWxQbGFjZXM9Ml0gLSBUaGUgYW1vdW50IG9mIGRlY2ltYWwgcGxhY2VzIGZvciBmbG9hdGluZy1wb2ludCB2YWx1ZXNcbiAqIEByZXR1cm4ge3N0cmluZ31cbiAqL1xuUGF0aC5wcm90b3R5cGUudG9TVkcgPSBmdW5jdGlvbihkZWNpbWFsUGxhY2VzKSB7XG4gICAgdmFyIHN2ZyA9ICc8cGF0aCBkPVwiJztcbiAgICBzdmcgKz0gdGhpcy50b1BhdGhEYXRhKGRlY2ltYWxQbGFjZXMpO1xuICAgIHN2ZyArPSAnXCInO1xuICAgIGlmICh0aGlzLmZpbGwgJiYgdGhpcy5maWxsICE9PSAnYmxhY2snKSB7XG4gICAgICAgIGlmICh0aGlzLmZpbGwgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHN2ZyArPSAnIGZpbGw9XCJub25lXCInO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc3ZnICs9ICcgZmlsbD1cIicgKyB0aGlzLmZpbGwgKyAnXCInO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuc3Ryb2tlKSB7XG4gICAgICAgIHN2ZyArPSAnIHN0cm9rZT1cIicgKyB0aGlzLnN0cm9rZSArICdcIiBzdHJva2Utd2lkdGg9XCInICsgdGhpcy5zdHJva2VXaWR0aCArICdcIic7XG4gICAgfVxuXG4gICAgc3ZnICs9ICcvPic7XG4gICAgcmV0dXJuIHN2Zztcbn07XG5cbi8qKlxuICogQ29udmVydCB0aGUgcGF0aCB0byBhIERPTSBlbGVtZW50LlxuICogQHBhcmFtICB7bnVtYmVyfSBbZGVjaW1hbFBsYWNlcz0yXSAtIFRoZSBhbW91bnQgb2YgZGVjaW1hbCBwbGFjZXMgZm9yIGZsb2F0aW5nLXBvaW50IHZhbHVlc1xuICogQHJldHVybiB7U1ZHUGF0aEVsZW1lbnR9XG4gKi9cblBhdGgucHJvdG90eXBlLnRvRE9NRWxlbWVudCA9IGZ1bmN0aW9uKGRlY2ltYWxQbGFjZXMpIHtcbiAgICB2YXIgdGVtcG9yYXJ5UGF0aCA9IHRoaXMudG9QYXRoRGF0YShkZWNpbWFsUGxhY2VzKTtcbiAgICB2YXIgbmV3UGF0aCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUygnaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmcnLCAncGF0aCcpO1xuXG4gICAgbmV3UGF0aC5zZXRBdHRyaWJ1dGUoJ2QnLCB0ZW1wb3JhcnlQYXRoKTtcblxuICAgIHJldHVybiBuZXdQYXRoO1xufTtcblxuLy8gUnVuLXRpbWUgY2hlY2tpbmcgb2YgcHJlY29uZGl0aW9ucy5cblxuZnVuY3Rpb24gZmFpbChtZXNzYWdlKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKG1lc3NhZ2UpO1xufVxuXG4vLyBQcmVjb25kaXRpb24gZnVuY3Rpb24gdGhhdCBjaGVja3MgaWYgdGhlIGdpdmVuIHByZWRpY2F0ZSBpcyB0cnVlLlxuLy8gSWYgbm90LCBpdCB3aWxsIHRocm93IGFuIGVycm9yLlxuZnVuY3Rpb24gYXJndW1lbnQocHJlZGljYXRlLCBtZXNzYWdlKSB7XG4gICAgaWYgKCFwcmVkaWNhdGUpIHtcbiAgICAgICAgZmFpbChtZXNzYWdlKTtcbiAgICB9XG59XG52YXIgY2hlY2sgPSB7IGZhaWw6IGZhaWwsIGFyZ3VtZW50OiBhcmd1bWVudCwgYXNzZXJ0OiBhcmd1bWVudCB9O1xuXG4vLyBEYXRhIHR5cGVzIHVzZWQgaW4gdGhlIE9wZW5UeXBlIGZvbnQgZmlsZS5cblxudmFyIExJTUlUMTYgPSAzMjc2ODsgLy8gVGhlIGxpbWl0IGF0IHdoaWNoIGEgMTYtYml0IG51bWJlciBzd2l0Y2hlcyBzaWducyA9PSAyXjE1XG52YXIgTElNSVQzMiA9IDIxNDc0ODM2NDg7IC8vIFRoZSBsaW1pdCBhdCB3aGljaCBhIDMyLWJpdCBudW1iZXIgc3dpdGNoZXMgc2lnbnMgPT0gMiBeIDMxXG5cbi8qKlxuICogQGV4cG9ydHMgb3BlbnR5cGUuZGVjb2RlXG4gKiBAY2xhc3NcbiAqL1xudmFyIGRlY29kZSA9IHt9O1xuLyoqXG4gKiBAZXhwb3J0cyBvcGVudHlwZS5lbmNvZGVcbiAqIEBjbGFzc1xuICovXG52YXIgZW5jb2RlID0ge307XG4vKipcbiAqIEBleHBvcnRzIG9wZW50eXBlLnNpemVPZlxuICogQGNsYXNzXG4gKi9cbnZhciBzaXplT2YgPSB7fTtcblxuLy8gUmV0dXJuIGEgZnVuY3Rpb24gdGhhdCBhbHdheXMgcmV0dXJucyB0aGUgc2FtZSB2YWx1ZS5cbmZ1bmN0aW9uIGNvbnN0YW50KHYpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB2O1xuICAgIH07XG59XG5cbi8vIE9wZW5UeXBlIGRhdGEgdHlwZXMgLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5cbi8qKlxuICogQ29udmVydCBhbiA4LWJpdCB1bnNpZ25lZCBpbnRlZ2VyIHRvIGEgbGlzdCBvZiAxIGJ5dGUuXG4gKiBAcGFyYW0ge251bWJlcn1cbiAqIEByZXR1cm5zIHtBcnJheX1cbiAqL1xuZW5jb2RlLkJZVEUgPSBmdW5jdGlvbih2KSB7XG4gICAgY2hlY2suYXJndW1lbnQodiA+PSAwICYmIHYgPD0gMjU1LCAnQnl0ZSB2YWx1ZSBzaG91bGQgYmUgYmV0d2VlbiAwIGFuZCAyNTUuJyk7XG4gICAgcmV0dXJuIFt2XTtcbn07XG4vKipcbiAqIEBjb25zdGFudFxuICogQHR5cGUge251bWJlcn1cbiAqL1xuc2l6ZU9mLkJZVEUgPSBjb25zdGFudCgxKTtcblxuLyoqXG4gKiBDb252ZXJ0IGEgOC1iaXQgc2lnbmVkIGludGVnZXIgdG8gYSBsaXN0IG9mIDEgYnl0ZS5cbiAqIEBwYXJhbSB7c3RyaW5nfVxuICogQHJldHVybnMge0FycmF5fVxuICovXG5lbmNvZGUuQ0hBUiA9IGZ1bmN0aW9uKHYpIHtcbiAgICByZXR1cm4gW3YuY2hhckNvZGVBdCgwKV07XG59O1xuXG4vKipcbiAqIEBjb25zdGFudFxuICogQHR5cGUge251bWJlcn1cbiAqL1xuc2l6ZU9mLkNIQVIgPSBjb25zdGFudCgxKTtcblxuLyoqXG4gKiBDb252ZXJ0IGFuIEFTQ0lJIHN0cmluZyB0byBhIGxpc3Qgb2YgYnl0ZXMuXG4gKiBAcGFyYW0ge3N0cmluZ31cbiAqIEByZXR1cm5zIHtBcnJheX1cbiAqL1xuZW5jb2RlLkNIQVJBUlJBWSA9IGZ1bmN0aW9uKHYpIHtcbiAgICBpZiAodHlwZW9mIHYgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHYgPSAnJztcbiAgICAgICAgY29uc29sZS53YXJuKCdVbmRlZmluZWQgQ0hBUkFSUkFZIGVuY291bnRlcmVkIGFuZCB0cmVhdGVkIGFzIGFuIGVtcHR5IHN0cmluZy4gVGhpcyBpcyBwcm9iYWJseSBjYXVzZWQgYnkgYSBtaXNzaW5nIGdseXBoIG5hbWUuJyk7XG4gICAgfVxuICAgIHZhciBiID0gW107XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB2Lmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgIGJbaV0gPSB2LmNoYXJDb2RlQXQoaSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGI7XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7QXJyYXl9XG4gKiBAcmV0dXJucyB7bnVtYmVyfVxuICovXG5zaXplT2YuQ0hBUkFSUkFZID0gZnVuY3Rpb24odikge1xuICAgIGlmICh0eXBlb2YgdiA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgfVxuICAgIHJldHVybiB2Lmxlbmd0aDtcbn07XG5cbi8qKlxuICogQ29udmVydCBhIDE2LWJpdCB1bnNpZ25lZCBpbnRlZ2VyIHRvIGEgbGlzdCBvZiAyIGJ5dGVzLlxuICogQHBhcmFtIHtudW1iZXJ9XG4gKiBAcmV0dXJucyB7QXJyYXl9XG4gKi9cbmVuY29kZS5VU0hPUlQgPSBmdW5jdGlvbih2KSB7XG4gICAgcmV0dXJuIFsodiA+PiA4KSAmIDB4RkYsIHYgJiAweEZGXTtcbn07XG5cbi8qKlxuICogQGNvbnN0YW50XG4gKiBAdHlwZSB7bnVtYmVyfVxuICovXG5zaXplT2YuVVNIT1JUID0gY29uc3RhbnQoMik7XG5cbi8qKlxuICogQ29udmVydCBhIDE2LWJpdCBzaWduZWQgaW50ZWdlciB0byBhIGxpc3Qgb2YgMiBieXRlcy5cbiAqIEBwYXJhbSB7bnVtYmVyfVxuICogQHJldHVybnMge0FycmF5fVxuICovXG5lbmNvZGUuU0hPUlQgPSBmdW5jdGlvbih2KSB7XG4gICAgLy8gVHdvJ3MgY29tcGxlbWVudFxuICAgIGlmICh2ID49IExJTUlUMTYpIHtcbiAgICAgICAgdiA9IC0oMiAqIExJTUlUMTYgLSB2KTtcbiAgICB9XG5cbiAgICByZXR1cm4gWyh2ID4+IDgpICYgMHhGRiwgdiAmIDB4RkZdO1xufTtcblxuLyoqXG4gKiBAY29uc3RhbnRcbiAqIEB0eXBlIHtudW1iZXJ9XG4gKi9cbnNpemVPZi5TSE9SVCA9IGNvbnN0YW50KDIpO1xuXG4vKipcbiAqIENvbnZlcnQgYSAyNC1iaXQgdW5zaWduZWQgaW50ZWdlciB0byBhIGxpc3Qgb2YgMyBieXRlcy5cbiAqIEBwYXJhbSB7bnVtYmVyfVxuICogQHJldHVybnMge0FycmF5fVxuICovXG5lbmNvZGUuVUlOVDI0ID0gZnVuY3Rpb24odikge1xuICAgIHJldHVybiBbKHYgPj4gMTYpICYgMHhGRiwgKHYgPj4gOCkgJiAweEZGLCB2ICYgMHhGRl07XG59O1xuXG4vKipcbiAqIEBjb25zdGFudFxuICogQHR5cGUge251bWJlcn1cbiAqL1xuc2l6ZU9mLlVJTlQyNCA9IGNvbnN0YW50KDMpO1xuXG4vKipcbiAqIENvbnZlcnQgYSAzMi1iaXQgdW5zaWduZWQgaW50ZWdlciB0byBhIGxpc3Qgb2YgNCBieXRlcy5cbiAqIEBwYXJhbSB7bnVtYmVyfVxuICogQHJldHVybnMge0FycmF5fVxuICovXG5lbmNvZGUuVUxPTkcgPSBmdW5jdGlvbih2KSB7XG4gICAgcmV0dXJuIFsodiA+PiAyNCkgJiAweEZGLCAodiA+PiAxNikgJiAweEZGLCAodiA+PiA4KSAmIDB4RkYsIHYgJiAweEZGXTtcbn07XG5cbi8qKlxuICogQGNvbnN0YW50XG4gKiBAdHlwZSB7bnVtYmVyfVxuICovXG5zaXplT2YuVUxPTkcgPSBjb25zdGFudCg0KTtcblxuLyoqXG4gKiBDb252ZXJ0IGEgMzItYml0IHVuc2lnbmVkIGludGVnZXIgdG8gYSBsaXN0IG9mIDQgYnl0ZXMuXG4gKiBAcGFyYW0ge251bWJlcn1cbiAqIEByZXR1cm5zIHtBcnJheX1cbiAqL1xuZW5jb2RlLkxPTkcgPSBmdW5jdGlvbih2KSB7XG4gICAgLy8gVHdvJ3MgY29tcGxlbWVudFxuICAgIGlmICh2ID49IExJTUlUMzIpIHtcbiAgICAgICAgdiA9IC0oMiAqIExJTUlUMzIgLSB2KTtcbiAgICB9XG5cbiAgICByZXR1cm4gWyh2ID4+IDI0KSAmIDB4RkYsICh2ID4+IDE2KSAmIDB4RkYsICh2ID4+IDgpICYgMHhGRiwgdiAmIDB4RkZdO1xufTtcblxuLyoqXG4gKiBAY29uc3RhbnRcbiAqIEB0eXBlIHtudW1iZXJ9XG4gKi9cbnNpemVPZi5MT05HID0gY29uc3RhbnQoNCk7XG5cbmVuY29kZS5GSVhFRCA9IGVuY29kZS5VTE9ORztcbnNpemVPZi5GSVhFRCA9IHNpemVPZi5VTE9ORztcblxuZW5jb2RlLkZXT1JEID0gZW5jb2RlLlNIT1JUO1xuc2l6ZU9mLkZXT1JEID0gc2l6ZU9mLlNIT1JUO1xuXG5lbmNvZGUuVUZXT1JEID0gZW5jb2RlLlVTSE9SVDtcbnNpemVPZi5VRldPUkQgPSBzaXplT2YuVVNIT1JUO1xuXG4vKipcbiAqIENvbnZlcnQgYSAzMi1iaXQgQXBwbGUgTWFjIHRpbWVzdGFtcCBpbnRlZ2VyIHRvIGEgbGlzdCBvZiA4IGJ5dGVzLCA2NC1iaXQgdGltZXN0YW1wLlxuICogQHBhcmFtIHtudW1iZXJ9XG4gKiBAcmV0dXJucyB7QXJyYXl9XG4gKi9cbmVuY29kZS5MT05HREFURVRJTUUgPSBmdW5jdGlvbih2KSB7XG4gICAgcmV0dXJuIFswLCAwLCAwLCAwLCAodiA+PiAyNCkgJiAweEZGLCAodiA+PiAxNikgJiAweEZGLCAodiA+PiA4KSAmIDB4RkYsIHYgJiAweEZGXTtcbn07XG5cbi8qKlxuICogQGNvbnN0YW50XG4gKiBAdHlwZSB7bnVtYmVyfVxuICovXG5zaXplT2YuTE9OR0RBVEVUSU1FID0gY29uc3RhbnQoOCk7XG5cbi8qKlxuICogQ29udmVydCBhIDQtY2hhciB0YWcgdG8gYSBsaXN0IG9mIDQgYnl0ZXMuXG4gKiBAcGFyYW0ge3N0cmluZ31cbiAqIEByZXR1cm5zIHtBcnJheX1cbiAqL1xuZW5jb2RlLlRBRyA9IGZ1bmN0aW9uKHYpIHtcbiAgICBjaGVjay5hcmd1bWVudCh2Lmxlbmd0aCA9PT0gNCwgJ1RhZyBzaG91bGQgYmUgZXhhY3RseSA0IEFTQ0lJIGNoYXJhY3RlcnMuJyk7XG4gICAgcmV0dXJuIFt2LmNoYXJDb2RlQXQoMCksXG4gICAgICAgICAgICB2LmNoYXJDb2RlQXQoMSksXG4gICAgICAgICAgICB2LmNoYXJDb2RlQXQoMiksXG4gICAgICAgICAgICB2LmNoYXJDb2RlQXQoMyldO1xufTtcblxuLyoqXG4gKiBAY29uc3RhbnRcbiAqIEB0eXBlIHtudW1iZXJ9XG4gKi9cbnNpemVPZi5UQUcgPSBjb25zdGFudCg0KTtcblxuLy8gQ0ZGIGRhdGEgdHlwZXMgLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cblxuZW5jb2RlLkNhcmQ4ID0gZW5jb2RlLkJZVEU7XG5zaXplT2YuQ2FyZDggPSBzaXplT2YuQllURTtcblxuZW5jb2RlLkNhcmQxNiA9IGVuY29kZS5VU0hPUlQ7XG5zaXplT2YuQ2FyZDE2ID0gc2l6ZU9mLlVTSE9SVDtcblxuZW5jb2RlLk9mZlNpemUgPSBlbmNvZGUuQllURTtcbnNpemVPZi5PZmZTaXplID0gc2l6ZU9mLkJZVEU7XG5cbmVuY29kZS5TSUQgPSBlbmNvZGUuVVNIT1JUO1xuc2l6ZU9mLlNJRCA9IHNpemVPZi5VU0hPUlQ7XG5cbi8vIENvbnZlcnQgYSBudW1lcmljIG9wZXJhbmQgb3IgY2hhcnN0cmluZyBudW1iZXIgdG8gYSB2YXJpYWJsZS1zaXplIGxpc3Qgb2YgYnl0ZXMuXG4vKipcbiAqIENvbnZlcnQgYSBudW1lcmljIG9wZXJhbmQgb3IgY2hhcnN0cmluZyBudW1iZXIgdG8gYSB2YXJpYWJsZS1zaXplIGxpc3Qgb2YgYnl0ZXMuXG4gKiBAcGFyYW0ge251bWJlcn1cbiAqIEByZXR1cm5zIHtBcnJheX1cbiAqL1xuZW5jb2RlLk5VTUJFUiA9IGZ1bmN0aW9uKHYpIHtcbiAgICBpZiAodiA+PSAtMTA3ICYmIHYgPD0gMTA3KSB7XG4gICAgICAgIHJldHVybiBbdiArIDEzOV07XG4gICAgfSBlbHNlIGlmICh2ID49IDEwOCAmJiB2IDw9IDExMzEpIHtcbiAgICAgICAgdiA9IHYgLSAxMDg7XG4gICAgICAgIHJldHVybiBbKHYgPj4gOCkgKyAyNDcsIHYgJiAweEZGXTtcbiAgICB9IGVsc2UgaWYgKHYgPj0gLTExMzEgJiYgdiA8PSAtMTA4KSB7XG4gICAgICAgIHYgPSAtdiAtIDEwODtcbiAgICAgICAgcmV0dXJuIFsodiA+PiA4KSArIDI1MSwgdiAmIDB4RkZdO1xuICAgIH0gZWxzZSBpZiAodiA+PSAtMzI3NjggJiYgdiA8PSAzMjc2Nykge1xuICAgICAgICByZXR1cm4gZW5jb2RlLk5VTUJFUjE2KHYpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBlbmNvZGUuTlVNQkVSMzIodik7XG4gICAgfVxufTtcblxuLyoqXG4gKiBAcGFyYW0ge251bWJlcn1cbiAqIEByZXR1cm5zIHtudW1iZXJ9XG4gKi9cbnNpemVPZi5OVU1CRVIgPSBmdW5jdGlvbih2KSB7XG4gICAgcmV0dXJuIGVuY29kZS5OVU1CRVIodikubGVuZ3RoO1xufTtcblxuLyoqXG4gKiBDb252ZXJ0IGEgc2lnbmVkIG51bWJlciBiZXR3ZWVuIC0zMjc2OCBhbmQgKzMyNzY3IHRvIGEgdGhyZWUtYnl0ZSB2YWx1ZS5cbiAqIFRoaXMgZW5zdXJlcyB3ZSBhbHdheXMgdXNlIHRocmVlIGJ5dGVzLCBidXQgaXMgbm90IHRoZSBtb3N0IGNvbXBhY3QgZm9ybWF0LlxuICogQHBhcmFtIHtudW1iZXJ9XG4gKiBAcmV0dXJucyB7QXJyYXl9XG4gKi9cbmVuY29kZS5OVU1CRVIxNiA9IGZ1bmN0aW9uKHYpIHtcbiAgICByZXR1cm4gWzI4LCAodiA+PiA4KSAmIDB4RkYsIHYgJiAweEZGXTtcbn07XG5cbi8qKlxuICogQGNvbnN0YW50XG4gKiBAdHlwZSB7bnVtYmVyfVxuICovXG5zaXplT2YuTlVNQkVSMTYgPSBjb25zdGFudCgzKTtcblxuLyoqXG4gKiBDb252ZXJ0IGEgc2lnbmVkIG51bWJlciBiZXR3ZWVuIC0oMl4zMSkgYW5kICsoMl4zMS0xKSB0byBhIGZpdmUtYnl0ZSB2YWx1ZS5cbiAqIFRoaXMgaXMgdXNlZnVsIGlmIHlvdSB3YW50IHRvIGJlIHN1cmUgeW91IGFsd2F5cyB1c2UgZm91ciBieXRlcyxcbiAqIGF0IHRoZSBleHBlbnNlIG9mIHdhc3RpbmcgYSBmZXcgYnl0ZXMgZm9yIHNtYWxsZXIgbnVtYmVycy5cbiAqIEBwYXJhbSB7bnVtYmVyfVxuICogQHJldHVybnMge0FycmF5fVxuICovXG5lbmNvZGUuTlVNQkVSMzIgPSBmdW5jdGlvbih2KSB7XG4gICAgcmV0dXJuIFsyOSwgKHYgPj4gMjQpICYgMHhGRiwgKHYgPj4gMTYpICYgMHhGRiwgKHYgPj4gOCkgJiAweEZGLCB2ICYgMHhGRl07XG59O1xuXG4vKipcbiAqIEBjb25zdGFudFxuICogQHR5cGUge251bWJlcn1cbiAqL1xuc2l6ZU9mLk5VTUJFUjMyID0gY29uc3RhbnQoNSk7XG5cbi8qKlxuICogQHBhcmFtIHtudW1iZXJ9XG4gKiBAcmV0dXJucyB7QXJyYXl9XG4gKi9cbmVuY29kZS5SRUFMID0gZnVuY3Rpb24odikge1xuICAgIHZhciB2YWx1ZSA9IHYudG9TdHJpbmcoKTtcblxuICAgIC8vIFNvbWUgbnVtYmVycyB1c2UgYW4gZXBzaWxvbiB0byBlbmNvZGUgdGhlIHZhbHVlLiAoZS5nLiBKYXZhU2NyaXB0IHdpbGwgc3RvcmUgMC4wMDAwMDAxIGFzIDFlLTcpXG4gICAgLy8gVGhpcyBjb2RlIGNvbnZlcnRzIGl0IGJhY2sgdG8gYSBudW1iZXIgd2l0aG91dCB0aGUgZXBzaWxvbi5cbiAgICB2YXIgbSA9IC9cXC4oXFxkKj8pKD86OXs1LDIwfXwwezUsMjB9KVxcZHswLDJ9KD86ZSguKyl8JCkvLmV4ZWModmFsdWUpO1xuICAgIGlmIChtKSB7XG4gICAgICAgIHZhciBlcHNpbG9uID0gcGFyc2VGbG9hdCgnMWUnICsgKChtWzJdID8gK21bMl0gOiAwKSArIG1bMV0ubGVuZ3RoKSk7XG4gICAgICAgIHZhbHVlID0gKE1hdGgucm91bmQodiAqIGVwc2lsb24pIC8gZXBzaWxvbikudG9TdHJpbmcoKTtcbiAgICB9XG5cbiAgICB2YXIgbmliYmxlcyA9ICcnO1xuICAgIGZvciAodmFyIGkgPSAwLCBpaSA9IHZhbHVlLmxlbmd0aDsgaSA8IGlpOyBpICs9IDEpIHtcbiAgICAgICAgdmFyIGMgPSB2YWx1ZVtpXTtcbiAgICAgICAgaWYgKGMgPT09ICdlJykge1xuICAgICAgICAgICAgbmliYmxlcyArPSB2YWx1ZVsrK2ldID09PSAnLScgPyAnYycgOiAnYic7XG4gICAgICAgIH0gZWxzZSBpZiAoYyA9PT0gJy4nKSB7XG4gICAgICAgICAgICBuaWJibGVzICs9ICdhJztcbiAgICAgICAgfSBlbHNlIGlmIChjID09PSAnLScpIHtcbiAgICAgICAgICAgIG5pYmJsZXMgKz0gJ2UnO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbmliYmxlcyArPSBjO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgbmliYmxlcyArPSAobmliYmxlcy5sZW5ndGggJiAxKSA/ICdmJyA6ICdmZic7XG4gICAgdmFyIG91dCA9IFszMF07XG4gICAgZm9yICh2YXIgaSQxID0gMCwgaWkkMSA9IG5pYmJsZXMubGVuZ3RoOyBpJDEgPCBpaSQxOyBpJDEgKz0gMikge1xuICAgICAgICBvdXQucHVzaChwYXJzZUludChuaWJibGVzLnN1YnN0cihpJDEsIDIpLCAxNikpO1xuICAgIH1cblxuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7bnVtYmVyfVxuICogQHJldHVybnMge251bWJlcn1cbiAqL1xuc2l6ZU9mLlJFQUwgPSBmdW5jdGlvbih2KSB7XG4gICAgcmV0dXJuIGVuY29kZS5SRUFMKHYpLmxlbmd0aDtcbn07XG5cbmVuY29kZS5OQU1FID0gZW5jb2RlLkNIQVJBUlJBWTtcbnNpemVPZi5OQU1FID0gc2l6ZU9mLkNIQVJBUlJBWTtcblxuZW5jb2RlLlNUUklORyA9IGVuY29kZS5DSEFSQVJSQVk7XG5zaXplT2YuU1RSSU5HID0gc2l6ZU9mLkNIQVJBUlJBWTtcblxuLyoqXG4gKiBAcGFyYW0ge0RhdGFWaWV3fSBkYXRhXG4gKiBAcGFyYW0ge251bWJlcn0gb2Zmc2V0XG4gKiBAcGFyYW0ge251bWJlcn0gbnVtQnl0ZXNcbiAqIEByZXR1cm5zIHtzdHJpbmd9XG4gKi9cbmRlY29kZS5VVEY4ID0gZnVuY3Rpb24oZGF0YSwgb2Zmc2V0LCBudW1CeXRlcykge1xuICAgIHZhciBjb2RlUG9pbnRzID0gW107XG4gICAgdmFyIG51bUNoYXJzID0gbnVtQnl0ZXM7XG4gICAgZm9yICh2YXIgaiA9IDA7IGogPCBudW1DaGFyczsgaisrLCBvZmZzZXQgKz0gMSkge1xuICAgICAgICBjb2RlUG9pbnRzW2pdID0gZGF0YS5nZXRVaW50OChvZmZzZXQpO1xuICAgIH1cblxuICAgIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KG51bGwsIGNvZGVQb2ludHMpO1xufTtcblxuLyoqXG4gKiBAcGFyYW0ge0RhdGFWaWV3fSBkYXRhXG4gKiBAcGFyYW0ge251bWJlcn0gb2Zmc2V0XG4gKiBAcGFyYW0ge251bWJlcn0gbnVtQnl0ZXNcbiAqIEByZXR1cm5zIHtzdHJpbmd9XG4gKi9cbmRlY29kZS5VVEYxNiA9IGZ1bmN0aW9uKGRhdGEsIG9mZnNldCwgbnVtQnl0ZXMpIHtcbiAgICB2YXIgY29kZVBvaW50cyA9IFtdO1xuICAgIHZhciBudW1DaGFycyA9IG51bUJ5dGVzIC8gMjtcbiAgICBmb3IgKHZhciBqID0gMDsgaiA8IG51bUNoYXJzOyBqKyssIG9mZnNldCArPSAyKSB7XG4gICAgICAgIGNvZGVQb2ludHNbal0gPSBkYXRhLmdldFVpbnQxNihvZmZzZXQpO1xuICAgIH1cblxuICAgIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KG51bGwsIGNvZGVQb2ludHMpO1xufTtcblxuLyoqXG4gKiBDb252ZXJ0IGEgSmF2YVNjcmlwdCBzdHJpbmcgdG8gVVRGMTYtQkUuXG4gKiBAcGFyYW0ge3N0cmluZ31cbiAqIEByZXR1cm5zIHtBcnJheX1cbiAqL1xuZW5jb2RlLlVURjE2ID0gZnVuY3Rpb24odikge1xuICAgIHZhciBiID0gW107XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB2Lmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgIHZhciBjb2RlcG9pbnQgPSB2LmNoYXJDb2RlQXQoaSk7XG4gICAgICAgIGJbYi5sZW5ndGhdID0gKGNvZGVwb2ludCA+PiA4KSAmIDB4RkY7XG4gICAgICAgIGJbYi5sZW5ndGhdID0gY29kZXBvaW50ICYgMHhGRjtcbiAgICB9XG5cbiAgICByZXR1cm4gYjtcbn07XG5cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9XG4gKiBAcmV0dXJucyB7bnVtYmVyfVxuICovXG5zaXplT2YuVVRGMTYgPSBmdW5jdGlvbih2KSB7XG4gICAgcmV0dXJuIHYubGVuZ3RoICogMjtcbn07XG5cbi8vIERhdGEgZm9yIGNvbnZlcnRpbmcgb2xkIGVpZ2h0LWJpdCBNYWNpbnRvc2ggZW5jb2RpbmdzIHRvIFVuaWNvZGUuXG4vLyBUaGlzIHJlcHJlc2VudGF0aW9uIGlzIG9wdGltaXplZCBmb3IgZGVjb2Rpbmc7IGVuY29kaW5nIGlzIHNsb3dlclxuLy8gYW5kIG5lZWRzIG1vcmUgbWVtb3J5LiBUaGUgYXNzdW1wdGlvbiBpcyB0aGF0IGFsbCBvcGVudHlwZS5qcyB1c2Vyc1xuLy8gd2FudCB0byBvcGVuIGZvbnRzLCBidXQgc2F2aW5nIGEgZm9udCB3aWxsIGJlIGNvbXBhcmF0aXZlbHkgcmFyZVxuLy8gc28gaXQgY2FuIGJlIG1vcmUgZXhwZW5zaXZlLiBLZXllZCBieSBJQU5BIGNoYXJhY3RlciBzZXQgbmFtZS5cbi8vXG4vLyBQeXRob24gc2NyaXB0IGZvciBnZW5lcmF0aW5nIHRoZXNlIHN0cmluZ3M6XG4vL1xuLy8gICAgIHMgPSB1Jycuam9pbihbY2hyKGMpLmRlY29kZSgnbWFjX2dyZWVrJykgZm9yIGMgaW4gcmFuZ2UoMTI4LCAyNTYpXSlcbi8vICAgICBwcmludChzLmVuY29kZSgndXRmLTgnKSlcbi8qKlxuICogQHByaXZhdGVcbiAqL1xudmFyIGVpZ2h0Qml0TWFjRW5jb2RpbmdzID0ge1xuICAgICd4LW1hYy1jcm9hdGlhbic6ICAvLyBQeXRob246ICdtYWNfY3JvYXRpYW4nXG4gICAgJ8OEw4XDh8OJw5HDlsOcw6HDoMOiw6TDo8Olw6fDqcOow6rDq8Otw6zDrsOvw7HDs8Oyw7TDtsO1w7rDucO7w7zigKDCsMKiwqPCp+KAosK2w5/CrsWg4oSiwrTCqOKJoMW9w5jiiJ7CseKJpOKJpeKIhsK14oiC4oiR4oiPxaHiiKvCqsK6zqnFvsO4JyArXG4gICAgJ8K/wqHCrOKImsaS4omIxIbCq8SM4oCmwqDDgMODw5XFksWTxJDigJTigJzigJ3igJjigJnDt+KXiu+jv8Kp4oGE4oKs4oC54oC6w4bCu+KAk8K34oCa4oCe4oCww4LEh8OBxI3DiMONw47Dj8OMw5PDlMSRw5LDmsObw5nEscuGy5zCr8+Aw4vLmsK4w4rDpsuHJyxcbiAgICAneC1tYWMtY3lyaWxsaWMnOiAgLy8gUHl0aG9uOiAnbWFjX2N5cmlsbGljJ1xuICAgICfQkNCR0JLQk9CU0JXQltCX0JjQmdCa0JvQnNCd0J7Qn9Cg0KHQotCj0KTQpdCm0KfQqNCp0KrQq9Cs0K3QrtCv4oCgwrDSkMKjwqfigKLCttCGwq7CqeKEotCC0ZLiiaDQg9GT4oiewrHiiaTiiaXRlsK10pHQiNCE0ZTQh9GX0InRmdCK0ZonICtcbiAgICAn0ZjQhcKs4oiaxpLiiYjiiIbCq8K74oCmwqDQi9Gb0IzRnNGV4oCT4oCU4oCc4oCd4oCY4oCZw7figJ7QjtGe0I/Rn+KEltCB0ZHRj9Cw0LHQstCz0LTQtdC20LfQuNC50LrQu9C80L3QvtC/0YDRgdGC0YPRhNGF0YbRh9GI0YnRitGL0YzRjdGOJyxcbiAgICAneC1tYWMtZ2FlbGljJzogLy8gaHR0cDovL3VuaWNvZGUub3JnL1B1YmxpYy9NQVBQSU5HUy9WRU5ET1JTL0FQUExFL0dBRUxJQy5UWFRcbiAgICAnw4TDhcOHw4nDkcOWw5zDocOgw6LDpMOjw6XDp8Opw6jDqsOrw63DrMOuw6/DscOzw7LDtMO2w7XDusO5w7vDvOKAoMKwwqLCo8Kn4oCiwrbDn8KuwqnihKLCtMKo4omgw4bDmOG4gsKx4omk4oml4biDxIrEi+G4iuG4i+G4nuG4n8SgxKHhuYDDpsO4JyArXG4gICAgJ+G5geG5luG5l8m8xpLFv+G5oMKrwrvigKbCoMOAw4PDlcWSxZPigJPigJTigJzigJ3igJjigJnhuaHhupvDv8W44bmq4oKs4oC54oC6xbbFt+G5q8K34buy4buz4oGKw4LDisOBw4vDiMONw47Dj8OMw5PDlOKZo8OSw5rDm8OZxLHDncO9xbTFteG6hOG6heG6gOG6geG6guG6gycsXG4gICAgJ3gtbWFjLWdyZWVrJzogIC8vIFB5dGhvbjogJ21hY19ncmVlaydcbiAgICAnw4TCucKyw4nCs8OWw5zOhcOgw6LDpM6EwqjDp8Opw6jDqsOrwqPihKLDrsOv4oCiwr3igLDDtMO2wqbigqzDucO7w7zigKDOk86UzpjOm86ezqDDn8KuwqnOo86qwqfiiaDCsMK3zpHCseKJpOKJpcKlzpLOlc6WzpfOmc6azpzOps6rzqjOqScgK1xuICAgICfOrM6dwqzOn86h4omIzqTCq8K74oCmwqDOpc6nzobOiMWT4oCT4oCV4oCc4oCd4oCY4oCZw7fOic6KzozOjs6tzq7Or8+Mzo/Pjc6xzrLPiM60zrXPhs6zzrfOuc6+zrrOu868zr3Ov8+Az47Pgc+Dz4TOuM+Jz4LPh8+FzrbPis+LzpDOsFxcdTAwQUQnLFxuICAgICd4LW1hYy1pY2VsYW5kaWMnOiAgLy8gUHl0aG9uOiAnbWFjX2ljZWxhbmQnXG4gICAgJ8OEw4XDh8OJw5HDlsOcw6HDoMOiw6TDo8Olw6fDqcOow6rDq8Otw6zDrsOvw7HDs8Oyw7TDtsO1w7rDucO7w7zDncKwwqLCo8Kn4oCiwrbDn8KuwqnihKLCtMKo4omgw4bDmOKInsKx4omk4omlwqXCteKIguKIkeKIj8+A4oirwqrCus6pw6bDuCcgK1xuICAgICfCv8KhwqziiJrGkuKJiOKIhsKrwrvigKbCoMOAw4PDlcWSxZPigJPigJTigJzigJ3igJjigJnDt+KXisO/xbjigYTigqzDkMOww57DvsO9wrfigJrigJ7igLDDgsOKw4HDi8OIw43DjsOPw4zDk8OU76O/w5LDmsObw5nEscuGy5zCr8uYy5nLmsK4y53Lm8uHJyxcbiAgICAneC1tYWMtaW51aXQnOiAvLyBodHRwOi8vdW5pY29kZS5vcmcvUHVibGljL01BUFBJTkdTL1ZFTkRPUlMvQVBQTEUvSU5VSVQuVFhUXG4gICAgJ+GQg+GQhOGQheGQhuGQiuGQi+GQseGQsuGQs+GQtOGQuOGQueGRieGRjuGRj+GRkOGRkeGRleGRluGRpuGRreGRruGRr+GRsOGRsuGRs+GSg+GSi+GSjOGSjeGSjuGSkOGSkcKw4ZKh4ZKl4ZKm4oCiwrbhkqfCrsKp4oSi4ZKo4ZKq4ZKr4ZK74ZOC4ZOD4ZOE4ZOF4ZOH4ZOI4ZOQ4ZOv4ZOw4ZOx4ZOy4ZO04ZO14ZSF4ZOV4ZOW4ZOXJyArXG4gICAgJ+GTmOGTmuGTm+GTquGUqOGUqeGUquGUq+GUreKApsKg4ZSu4ZS+4ZWV4ZWW4ZWX4oCT4oCU4oCc4oCd4oCY4oCZ4ZWY4ZWZ4ZWa4ZWd4ZWG4ZWH4ZWI4ZWJ4ZWL4ZWM4ZWQ4ZW/4ZaA4ZaB4ZaC4ZaD4ZaE4ZaF4ZaP4ZaQ4ZaR4ZaS4ZaT4ZaU4ZaV4Zmx4Zmy4Zmz4Zm04Zm14Zm24ZaW4Zag4Zah4Zai4Zaj4Zak4Zal4Zam4ZW8xYHFgicsXG4gICAgJ3gtbWFjLWNlJzogIC8vIFB5dGhvbjogJ21hY19sYXRpbjInXG4gICAgJ8OExIDEgcOJxITDlsOcw6HEhcSMw6TEjcSGxIfDqcW5xbrEjsOtxI/EksSTxJbDs8SXw7TDtsO1w7rEmsSbw7zigKDCsMSYwqPCp+KAosK2w5/CrsKp4oSixJnCqOKJoMSjxK7Er8Sq4omk4omlxKvEtuKIguKIkcWCxLvEvMS9xL7EucS6xYUnICtcbiAgICAnxYbFg8Ks4oiaxYTFh+KIhsKrwrvigKbCoMWIxZDDlcWRxYzigJPigJTigJzigJ3igJjigJnDt+KXisWNxZTFlcWY4oC54oC6xZnFlsWXxaDigJrigJ7FocWaxZvDgcWkxaXDjcW9xb7FqsOTw5TFq8Wuw5rFr8WwxbHFssWzw53DvcS3xbvFgcW8xKLLhycsXG4gICAgbWFjaW50b3NoOiAgLy8gUHl0aG9uOiAnbWFjX3JvbWFuJ1xuICAgICfDhMOFw4fDicORw5bDnMOhw6DDosOkw6PDpcOnw6nDqMOqw6vDrcOsw67Dr8Oxw7PDssO0w7bDtcO6w7nDu8O84oCgwrDCosKjwqfigKLCtsOfwq7CqeKEosK0wqjiiaDDhsOY4oiewrHiiaTiiaXCpcK14oiC4oiR4oiPz4DiiKvCqsK6zqnDpsO4JyArXG4gICAgJ8K/wqHCrOKImsaS4omI4oiGwqvCu+KApsKgw4DDg8OVxZLFk+KAk+KAlOKAnOKAneKAmOKAmcO34peKw7/FuOKBhOKCrOKAueKAuu+sge+sguKAocK34oCa4oCe4oCww4LDisOBw4vDiMONw47Dj8OMw5PDlO+jv8OSw5rDm8OZxLHLhsucwq/LmMuZy5rCuMudy5vLhycsXG4gICAgJ3gtbWFjLXJvbWFuaWFuJzogIC8vIFB5dGhvbjogJ21hY19yb21hbmlhbidcbiAgICAnw4TDhcOHw4nDkcOWw5zDocOgw6LDpMOjw6XDp8Opw6jDqsOrw63DrMOuw6/DscOzw7LDtMO2w7XDusO5w7vDvOKAoMKwwqLCo8Kn4oCiwrbDn8KuwqnihKLCtMKo4omgxILImOKInsKx4omk4omlwqXCteKIguKIkeKIj8+A4oirwqrCus6pxIPImScgK1xuICAgICfCv8KhwqziiJrGkuKJiOKIhsKrwrvigKbCoMOAw4PDlcWSxZPigJPigJTigJzigJ3igJjigJnDt+KXisO/xbjigYTigqzigLnigLrImsib4oChwrfigJrigJ7igLDDgsOKw4HDi8OIw43DjsOPw4zDk8OU76O/w5LDmsObw5nEscuGy5zCr8uYy5nLmsK4y53Lm8uHJyxcbiAgICAneC1tYWMtdHVya2lzaCc6ICAvLyBQeXRob246ICdtYWNfdHVya2lzaCdcbiAgICAnw4TDhcOHw4nDkcOWw5zDocOgw6LDpMOjw6XDp8Opw6jDqsOrw63DrMOuw6/DscOzw7LDtMO2w7XDusO5w7vDvOKAoMKwwqLCo8Kn4oCiwrbDn8KuwqnihKLCtMKo4omgw4bDmOKInsKx4omk4omlwqXCteKIguKIkeKIj8+A4oirwqrCus6pw6bDuCcgK1xuICAgICfCv8KhwqziiJrGkuKJiOKIhsKrwrvigKbCoMOAw4PDlcWSxZPigJPigJTigJzigJ3igJjigJnDt+KXisO/xbjEnsSfxLDEscWexZ/igKHCt+KAmuKAnuKAsMOCw4rDgcOLw4jDjcOOw4/DjMOTw5Tvo7/DksOaw5vDme+ioMuGy5zCr8uYy5nLmsK4y53Lm8uHJ1xufTtcblxuLyoqXG4gKiBEZWNvZGVzIGFuIG9sZC1zdHlsZSBNYWNpbnRvc2ggc3RyaW5nLiBSZXR1cm5zIGVpdGhlciBhIFVuaWNvZGUgSmF2YVNjcmlwdFxuICogc3RyaW5nLCBvciAndW5kZWZpbmVkJyBpZiB0aGUgZW5jb2RpbmcgaXMgdW5zdXBwb3J0ZWQuIEZvciBleGFtcGxlLCB3ZSBkb1xuICogbm90IHN1cHBvcnQgQ2hpbmVzZSwgSmFwYW5lc2Ugb3IgS29yZWFuIGJlY2F1c2UgdGhlc2Ugd291bGQgbmVlZCBsYXJnZVxuICogbWFwcGluZyB0YWJsZXMuXG4gKiBAcGFyYW0ge0RhdGFWaWV3fSBkYXRhVmlld1xuICogQHBhcmFtIHtudW1iZXJ9IG9mZnNldFxuICogQHBhcmFtIHtudW1iZXJ9IGRhdGFMZW5ndGhcbiAqIEBwYXJhbSB7c3RyaW5nfSBlbmNvZGluZ1xuICogQHJldHVybnMge3N0cmluZ31cbiAqL1xuZGVjb2RlLk1BQ1NUUklORyA9IGZ1bmN0aW9uKGRhdGFWaWV3LCBvZmZzZXQsIGRhdGFMZW5ndGgsIGVuY29kaW5nKSB7XG4gICAgdmFyIHRhYmxlID0gZWlnaHRCaXRNYWNFbmNvZGluZ3NbZW5jb2RpbmddO1xuICAgIGlmICh0YWJsZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgdmFyIHJlc3VsdCA9ICcnO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZGF0YUxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBjID0gZGF0YVZpZXcuZ2V0VWludDgob2Zmc2V0ICsgaSk7XG4gICAgICAgIC8vIEluIGFsbCBlaWdodC1iaXQgTWFjIGVuY29kaW5ncywgdGhlIGNoYXJhY3RlcnMgMHgwMC4uMHg3RiBhcmVcbiAgICAgICAgLy8gbWFwcGVkIHRvIFUrMDAwMC4uVSswMDdGOyB3ZSBvbmx5IG5lZWQgdG8gbG9vayB1cCB0aGUgb3RoZXJzLlxuICAgICAgICBpZiAoYyA8PSAweDdGKSB7XG4gICAgICAgICAgICByZXN1bHQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShjKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlc3VsdCArPSB0YWJsZVtjICYgMHg3Rl07XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gcmVzdWx0O1xufTtcblxuLy8gSGVscGVyIGZ1bmN0aW9uIGZvciBlbmNvZGUuTUFDU1RSSU5HLiBSZXR1cm5zIGEgZGljdGlvbmFyeSBmb3IgbWFwcGluZ1xuLy8gVW5pY29kZSBjaGFyYWN0ZXIgY29kZXMgdG8gdGhlaXIgOC1iaXQgTWFjT1MgZXF1aXZhbGVudC4gVGhpcyB0YWJsZVxuLy8gaXMgbm90IGV4YWN0bHkgYSBzdXBlciBjaGVhcCBkYXRhIHN0cnVjdHVyZSwgYnV0IHdlIGRvIG5vdCBjYXJlIGJlY2F1c2Vcbi8vIGVuY29kaW5nIE1hY2ludG9zaCBzdHJpbmdzIGlzIG9ubHkgcmFyZWx5IG5lZWRlZCBpbiB0eXBpY2FsIGFwcGxpY2F0aW9ucy5cbnZhciBtYWNFbmNvZGluZ1RhYmxlQ2FjaGUgPSB0eXBlb2YgV2Vha01hcCA9PT0gJ2Z1bmN0aW9uJyAmJiBuZXcgV2Vha01hcCgpO1xudmFyIG1hY0VuY29kaW5nQ2FjaGVLZXlzO1xudmFyIGdldE1hY0VuY29kaW5nVGFibGUgPSBmdW5jdGlvbiAoZW5jb2RpbmcpIHtcbiAgICAvLyBTaW5jZSB3ZSB1c2UgZW5jb2RpbmcgYXMgYSBjYWNoZSBrZXkgZm9yIFdlYWtNYXAsIGl0IGhhcyB0byBiZVxuICAgIC8vIGEgU3RyaW5nIG9iamVjdCBhbmQgbm90IGEgbGl0ZXJhbC4gQW5kIGF0IGxlYXN0IG9uIE5vZGVKUyAyLjEwLjEsXG4gICAgLy8gV2Vha01hcCByZXF1aXJlcyB0aGF0IHRoZSBzYW1lIFN0cmluZyBpbnN0YW5jZSBpcyBwYXNzZWQgZm9yIGNhY2hlIGhpdHMuXG4gICAgaWYgKCFtYWNFbmNvZGluZ0NhY2hlS2V5cykge1xuICAgICAgICBtYWNFbmNvZGluZ0NhY2hlS2V5cyA9IHt9O1xuICAgICAgICBmb3IgKHZhciBlIGluIGVpZ2h0Qml0TWFjRW5jb2RpbmdzKSB7XG4gICAgICAgICAgICAvKmpzaGludCAtVzA1MyAqLyAgLy8gU3VwcHJlc3MgXCJEbyBub3QgdXNlIFN0cmluZyBhcyBhIGNvbnN0cnVjdG9yLlwiXG4gICAgICAgICAgICBtYWNFbmNvZGluZ0NhY2hlS2V5c1tlXSA9IG5ldyBTdHJpbmcoZSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgY2FjaGVLZXkgPSBtYWNFbmNvZGluZ0NhY2hlS2V5c1tlbmNvZGluZ107XG4gICAgaWYgKGNhY2hlS2V5ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG5cbiAgICAvLyBXZSBjYW4ndCBkbyBcImlmIChjYWNoZS5oYXMoa2V5KSkge3JldHVybiBjYWNoZS5nZXQoa2V5KX1cIiBoZXJlOlxuICAgIC8vIHNpbmNlIGdhcmJhZ2UgY29sbGVjdGlvbiBtYXkgcnVuIGF0IGFueSB0aW1lLCBpdCBjb3VsZCBhbHNvIGtpY2sgaW5cbiAgICAvLyBiZXR3ZWVuIHRoZSBjYWxscyB0byBjYWNoZS5oYXMoKSBhbmQgY2FjaGUuZ2V0KCkuIEluIHRoYXQgY2FzZSxcbiAgICAvLyB3ZSB3b3VsZCByZXR1cm4gJ3VuZGVmaW5lZCcgZXZlbiB0aG91Z2ggd2UgZG8gc3VwcG9ydCB0aGUgZW5jb2RpbmcuXG4gICAgaWYgKG1hY0VuY29kaW5nVGFibGVDYWNoZSkge1xuICAgICAgICB2YXIgY2FjaGVkVGFibGUgPSBtYWNFbmNvZGluZ1RhYmxlQ2FjaGUuZ2V0KGNhY2hlS2V5KTtcbiAgICAgICAgaWYgKGNhY2hlZFRhYmxlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRUYWJsZTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHZhciBkZWNvZGluZ1RhYmxlID0gZWlnaHRCaXRNYWNFbmNvZGluZ3NbZW5jb2RpbmddO1xuICAgIGlmIChkZWNvZGluZ1RhYmxlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG5cbiAgICB2YXIgZW5jb2RpbmdUYWJsZSA9IHt9O1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZGVjb2RpbmdUYWJsZS5sZW5ndGg7IGkrKykge1xuICAgICAgICBlbmNvZGluZ1RhYmxlW2RlY29kaW5nVGFibGUuY2hhckNvZGVBdChpKV0gPSBpICsgMHg4MDtcbiAgICB9XG5cbiAgICBpZiAobWFjRW5jb2RpbmdUYWJsZUNhY2hlKSB7XG4gICAgICAgIG1hY0VuY29kaW5nVGFibGVDYWNoZS5zZXQoY2FjaGVLZXksIGVuY29kaW5nVGFibGUpO1xuICAgIH1cblxuICAgIHJldHVybiBlbmNvZGluZ1RhYmxlO1xufTtcblxuLyoqXG4gKiBFbmNvZGVzIGFuIG9sZC1zdHlsZSBNYWNpbnRvc2ggc3RyaW5nLiBSZXR1cm5zIGEgYnl0ZSBhcnJheSB1cG9uIHN1Y2Nlc3MuXG4gKiBJZiB0aGUgcmVxdWVzdGVkIGVuY29kaW5nIGlzIHVuc3VwcG9ydGVkLCBvciBpZiB0aGUgaW5wdXQgc3RyaW5nIGNvbnRhaW5zXG4gKiBhIGNoYXJhY3RlciB0aGF0IGNhbm5vdCBiZSBleHByZXNzZWQgaW4gdGhlIGVuY29kaW5nLCB0aGUgZnVuY3Rpb24gcmV0dXJuc1xuICogJ3VuZGVmaW5lZCcuXG4gKiBAcGFyYW0ge3N0cmluZ30gc3RyXG4gKiBAcGFyYW0ge3N0cmluZ30gZW5jb2RpbmdcbiAqIEByZXR1cm5zIHtBcnJheX1cbiAqL1xuZW5jb2RlLk1BQ1NUUklORyA9IGZ1bmN0aW9uKHN0ciwgZW5jb2RpbmcpIHtcbiAgICB2YXIgdGFibGUgPSBnZXRNYWNFbmNvZGluZ1RhYmxlKGVuY29kaW5nKTtcbiAgICBpZiAodGFibGUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIHZhciByZXN1bHQgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHN0ci5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgYyA9IHN0ci5jaGFyQ29kZUF0KGkpO1xuXG4gICAgICAgIC8vIEluIGFsbCBlaWdodC1iaXQgTWFjIGVuY29kaW5ncywgdGhlIGNoYXJhY3RlcnMgMHgwMC4uMHg3RiBhcmVcbiAgICAgICAgLy8gbWFwcGVkIHRvIFUrMDAwMC4uVSswMDdGOyB3ZSBvbmx5IG5lZWQgdG8gbG9vayB1cCB0aGUgb3RoZXJzLlxuICAgICAgICBpZiAoYyA+PSAweDgwKSB7XG4gICAgICAgICAgICBjID0gdGFibGVbY107XG4gICAgICAgICAgICBpZiAoYyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgLy8gc3RyIGNvbnRhaW5zIGEgVW5pY29kZSBjaGFyYWN0ZXIgdGhhdCBjYW5ub3QgYmUgZW5jb2RlZFxuICAgICAgICAgICAgICAgIC8vIGluIHRoZSByZXF1ZXN0ZWQgZW5jb2RpbmcuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXN1bHRbaV0gPSBjO1xuICAgICAgICAvLyByZXN1bHQucHVzaChjKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcmVzdWx0O1xufTtcblxuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ30gc3RyXG4gKiBAcGFyYW0ge3N0cmluZ30gZW5jb2RpbmdcbiAqIEByZXR1cm5zIHtudW1iZXJ9XG4gKi9cbnNpemVPZi5NQUNTVFJJTkcgPSBmdW5jdGlvbihzdHIsIGVuY29kaW5nKSB7XG4gICAgdmFyIGIgPSBlbmNvZGUuTUFDU1RSSU5HKHN0ciwgZW5jb2RpbmcpO1xuICAgIGlmIChiICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIGIubGVuZ3RoO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiAwO1xuICAgIH1cbn07XG5cbi8vIEhlbHBlciBmb3IgZW5jb2RlLlZBUkRFTFRBU1xuZnVuY3Rpb24gaXNCeXRlRW5jb2RhYmxlKHZhbHVlKSB7XG4gICAgcmV0dXJuIHZhbHVlID49IC0xMjggJiYgdmFsdWUgPD0gMTI3O1xufVxuXG4vLyBIZWxwZXIgZm9yIGVuY29kZS5WQVJERUxUQVNcbmZ1bmN0aW9uIGVuY29kZVZhckRlbHRhUnVuQXNaZXJvZXMoZGVsdGFzLCBwb3MsIHJlc3VsdCkge1xuICAgIHZhciBydW5MZW5ndGggPSAwO1xuICAgIHZhciBudW1EZWx0YXMgPSBkZWx0YXMubGVuZ3RoO1xuICAgIHdoaWxlIChwb3MgPCBudW1EZWx0YXMgJiYgcnVuTGVuZ3RoIDwgNjQgJiYgZGVsdGFzW3Bvc10gPT09IDApIHtcbiAgICAgICAgKytwb3M7XG4gICAgICAgICsrcnVuTGVuZ3RoO1xuICAgIH1cbiAgICByZXN1bHQucHVzaCgweDgwIHwgKHJ1bkxlbmd0aCAtIDEpKTtcbiAgICByZXR1cm4gcG9zO1xufVxuXG4vLyBIZWxwZXIgZm9yIGVuY29kZS5WQVJERUxUQVNcbmZ1bmN0aW9uIGVuY29kZVZhckRlbHRhUnVuQXNCeXRlcyhkZWx0YXMsIG9mZnNldCwgcmVzdWx0KSB7XG4gICAgdmFyIHJ1bkxlbmd0aCA9IDA7XG4gICAgdmFyIG51bURlbHRhcyA9IGRlbHRhcy5sZW5ndGg7XG4gICAgdmFyIHBvcyA9IG9mZnNldDtcbiAgICB3aGlsZSAocG9zIDwgbnVtRGVsdGFzICYmIHJ1bkxlbmd0aCA8IDY0KSB7XG4gICAgICAgIHZhciB2YWx1ZSA9IGRlbHRhc1twb3NdO1xuICAgICAgICBpZiAoIWlzQnl0ZUVuY29kYWJsZSh2YWx1ZSkpIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gV2l0aGluIGEgYnl0ZS1lbmNvZGVkIHJ1biBvZiBkZWx0YXMsIGEgc2luZ2xlIHplcm8gaXMgYmVzdFxuICAgICAgICAvLyBzdG9yZWQgbGl0ZXJhbGx5IGFzIDB4MDAgdmFsdWUuIEhvd2V2ZXIsIGlmIHdlIGhhdmUgdHdvIG9yXG4gICAgICAgIC8vIG1vcmUgemVyb2VzIGluIGEgc2VxdWVuY2UsIGl0IGlzIGJldHRlciB0byBzdGFydCBhIG5ldyBydW4uXG4gICAgICAgIC8vIEZvcmUgZXhhbXBsZSwgdGhlIHNlcXVlbmNlIG9mIGRlbHRhcyBbMTUsIDE1LCAwLCAxNSwgMTVdXG4gICAgICAgIC8vIGJlY29tZXMgNiBieXRlcyAoMDQgMEYgMEYgMDAgMEYgMEYpIHdoZW4gc3RvcmluZyB0aGUgemVyb1xuICAgICAgICAvLyB3aXRoaW4gdGhlIGN1cnJlbnQgcnVuLCBidXQgNyBieXRlcyAoMDEgMEYgMEYgODAgMDEgMEYgMEYpXG4gICAgICAgIC8vIHdoZW4gc3RhcnRpbmcgYSBuZXcgcnVuLlxuICAgICAgICBpZiAodmFsdWUgPT09IDAgJiYgcG9zICsgMSA8IG51bURlbHRhcyAmJiBkZWx0YXNbcG9zICsgMV0gPT09IDApIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgICAgKytwb3M7XG4gICAgICAgICsrcnVuTGVuZ3RoO1xuICAgIH1cbiAgICByZXN1bHQucHVzaChydW5MZW5ndGggLSAxKTtcbiAgICBmb3IgKHZhciBpID0gb2Zmc2V0OyBpIDwgcG9zOyArK2kpIHtcbiAgICAgICAgcmVzdWx0LnB1c2goKGRlbHRhc1tpXSArIDI1NikgJiAweGZmKTtcbiAgICB9XG4gICAgcmV0dXJuIHBvcztcbn1cblxuLy8gSGVscGVyIGZvciBlbmNvZGUuVkFSREVMVEFTXG5mdW5jdGlvbiBlbmNvZGVWYXJEZWx0YVJ1bkFzV29yZHMoZGVsdGFzLCBvZmZzZXQsIHJlc3VsdCkge1xuICAgIHZhciBydW5MZW5ndGggPSAwO1xuICAgIHZhciBudW1EZWx0YXMgPSBkZWx0YXMubGVuZ3RoO1xuICAgIHZhciBwb3MgPSBvZmZzZXQ7XG4gICAgd2hpbGUgKHBvcyA8IG51bURlbHRhcyAmJiBydW5MZW5ndGggPCA2NCkge1xuICAgICAgICB2YXIgdmFsdWUgPSBkZWx0YXNbcG9zXTtcblxuICAgICAgICAvLyBXaXRoaW4gYSB3b3JkLWVuY29kZWQgcnVuIG9mIGRlbHRhcywgaXQgaXMgZWFzaWVzdCB0byBzdGFydFxuICAgICAgICAvLyBhIG5ldyBydW4gKHdpdGggYSBkaWZmZXJlbnQgZW5jb2RpbmcpIHdoZW5ldmVyIHdlIGVuY291bnRlclxuICAgICAgICAvLyBhIHplcm8gdmFsdWUuIEZvciBleGFtcGxlLCB0aGUgc2VxdWVuY2UgWzB4NjY2NiwgMCwgMHg3Nzc3XVxuICAgICAgICAvLyBuZWVkcyA3IGJ5dGVzIHdoZW4gc3RvcmluZyB0aGUgemVybyBpbnNpZGUgdGhlIGN1cnJlbnQgcnVuXG4gICAgICAgIC8vICg0MiA2NiA2NiAwMCAwMCA3NyA3NyksIGFuZCBlcXVhbGx5IDcgYnl0ZXMgd2hlbiBzdGFydGluZyBhXG4gICAgICAgIC8vIG5ldyBydW4gKDQwIDY2IDY2IDgwIDQwIDc3IDc3KS5cbiAgICAgICAgaWYgKHZhbHVlID09PSAwKSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFdpdGhpbiBhIHdvcmQtZW5jb2RlZCBydW4gb2YgZGVsdGFzLCBhIHNpbmdsZSB2YWx1ZSBpbiB0aGVcbiAgICAgICAgLy8gcmFuZ2UgKC0xMjguLjEyNykgc2hvdWxkIGJlIGVuY29kZWQgd2l0aGluIHRoZSBjdXJyZW50IHJ1blxuICAgICAgICAvLyBiZWNhdXNlIGl0IGlzIG1vcmUgY29tcGFjdC4gRm9yIGV4YW1wbGUsIHRoZSBzZXF1ZW5jZVxuICAgICAgICAvLyBbMHg2NjY2LCAyLCAweDc3NzddIGJlY29tZXMgNyBieXRlcyB3aGVuIHN0b3JpbmcgdGhlIHZhbHVlXG4gICAgICAgIC8vIGxpdGVyYWxseSAoNDIgNjYgNjYgMDAgMDIgNzcgNzcpLCBidXQgOCBieXRlcyB3aGVuIHN0YXJ0aW5nXG4gICAgICAgIC8vIGEgbmV3IHJ1biAoNDAgNjYgNjYgMDAgMDIgNDAgNzcgNzcpLlxuICAgICAgICBpZiAoaXNCeXRlRW5jb2RhYmxlKHZhbHVlKSAmJiBwb3MgKyAxIDwgbnVtRGVsdGFzICYmIGlzQnl0ZUVuY29kYWJsZShkZWx0YXNbcG9zICsgMV0pKSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICAgICsrcG9zO1xuICAgICAgICArK3J1bkxlbmd0aDtcbiAgICB9XG4gICAgcmVzdWx0LnB1c2goMHg0MCB8IChydW5MZW5ndGggLSAxKSk7XG4gICAgZm9yICh2YXIgaSA9IG9mZnNldDsgaSA8IHBvczsgKytpKSB7XG4gICAgICAgIHZhciB2YWwgPSBkZWx0YXNbaV07XG4gICAgICAgIHJlc3VsdC5wdXNoKCgodmFsICsgMHgxMDAwMCkgPj4gOCkgJiAweGZmLCAodmFsICsgMHgxMDApICYgMHhmZik7XG4gICAgfVxuICAgIHJldHVybiBwb3M7XG59XG5cbi8qKlxuICogRW5jb2RlIGEgbGlzdCBvZiB2YXJpYXRpb24gYWRqdXN0bWVudCBkZWx0YXMuXG4gKlxuICogVmFyaWF0aW9uIGFkanVzdG1lbnQgZGVsdGFzIGFyZSB1c2VkIGluIOKAmGd2YXLigJkgYW5kIOKAmGN2YXLigJkgdGFibGVzLlxuICogVGhleSBpbmRpY2F0ZSBob3cgcG9pbnRzIChpbiDigJhndmFy4oCZKSBvciB2YWx1ZXMgKGluIOKAmGN2YXLigJkpIGdldCBhZGp1c3RlZFxuICogd2hlbiBnZW5lcmF0aW5nIGluc3RhbmNlcyBvZiB2YXJpYXRpb24gZm9udHMuXG4gKlxuICogQHNlZSBodHRwczovL3d3dy5taWNyb3NvZnQuY29tL3R5cG9ncmFwaHkvb3RzcGVjL2d2YXIuaHRtXG4gKiBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLmFwcGxlLmNvbS9mb250cy9UcnVlVHlwZS1SZWZlcmVuY2UtTWFudWFsL1JNMDYvQ2hhcDZndmFyLmh0bWxcbiAqIEBwYXJhbSB7QXJyYXl9XG4gKiBAcmV0dXJuIHtBcnJheX1cbiAqL1xuZW5jb2RlLlZBUkRFTFRBUyA9IGZ1bmN0aW9uKGRlbHRhcykge1xuICAgIHZhciBwb3MgPSAwO1xuICAgIHZhciByZXN1bHQgPSBbXTtcbiAgICB3aGlsZSAocG9zIDwgZGVsdGFzLmxlbmd0aCkge1xuICAgICAgICB2YXIgdmFsdWUgPSBkZWx0YXNbcG9zXTtcbiAgICAgICAgaWYgKHZhbHVlID09PSAwKSB7XG4gICAgICAgICAgICBwb3MgPSBlbmNvZGVWYXJEZWx0YVJ1bkFzWmVyb2VzKGRlbHRhcywgcG9zLCByZXN1bHQpO1xuICAgICAgICB9IGVsc2UgaWYgKHZhbHVlID49IC0xMjggJiYgdmFsdWUgPD0gMTI3KSB7XG4gICAgICAgICAgICBwb3MgPSBlbmNvZGVWYXJEZWx0YVJ1bkFzQnl0ZXMoZGVsdGFzLCBwb3MsIHJlc3VsdCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBwb3MgPSBlbmNvZGVWYXJEZWx0YVJ1bkFzV29yZHMoZGVsdGFzLCBwb3MsIHJlc3VsdCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbi8vIENvbnZlcnQgYSBsaXN0IG9mIHZhbHVlcyB0byBhIENGRiBJTkRFWCBzdHJ1Y3R1cmUuXG4vLyBUaGUgdmFsdWVzIHNob3VsZCBiZSBvYmplY3RzIGNvbnRhaW5pbmcgbmFtZSAvIHR5cGUgLyB2YWx1ZS5cbi8qKlxuICogQHBhcmFtIHtBcnJheX0gbFxuICogQHJldHVybnMge0FycmF5fVxuICovXG5lbmNvZGUuSU5ERVggPSBmdW5jdGlvbihsKSB7XG4gICAgLy92YXIgb2Zmc2V0LCBvZmZzZXRzLCBvZmZzZXRFbmNvZGVyLCBlbmNvZGVkT2Zmc2V0cywgZW5jb2RlZE9mZnNldCwgZGF0YSxcbiAgICAvLyAgICBpLCB2O1xuICAgIC8vIEJlY2F1c2Ugd2UgaGF2ZSB0byBrbm93IHdoaWNoIGRhdGEgdHlwZSB0byB1c2UgdG8gZW5jb2RlIHRoZSBvZmZzZXRzLFxuICAgIC8vIHdlIGhhdmUgdG8gZ28gdGhyb3VnaCB0aGUgdmFsdWVzIHR3aWNlOiBvbmNlIHRvIGVuY29kZSB0aGUgZGF0YSBhbmRcbiAgICAvLyBjYWxjdWxhdGUgdGhlIG9mZnNldHMsIHRoZW4gYWdhaW4gdG8gZW5jb2RlIHRoZSBvZmZzZXRzIHVzaW5nIHRoZSBmaXR0aW5nIGRhdGEgdHlwZS5cbiAgICB2YXIgb2Zmc2V0ID0gMTsgLy8gRmlyc3Qgb2Zmc2V0IGlzIGFsd2F5cyAxLlxuICAgIHZhciBvZmZzZXRzID0gW29mZnNldF07XG4gICAgdmFyIGRhdGEgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGwubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgdmFyIHYgPSBlbmNvZGUuT0JKRUNUKGxbaV0pO1xuICAgICAgICBBcnJheS5wcm90b3R5cGUucHVzaC5hcHBseShkYXRhLCB2KTtcbiAgICAgICAgb2Zmc2V0ICs9IHYubGVuZ3RoO1xuICAgICAgICBvZmZzZXRzLnB1c2gob2Zmc2V0KTtcbiAgICB9XG5cbiAgICBpZiAoZGF0YS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgcmV0dXJuIFswLCAwXTtcbiAgICB9XG5cbiAgICB2YXIgZW5jb2RlZE9mZnNldHMgPSBbXTtcbiAgICB2YXIgb2ZmU2l6ZSA9ICgxICsgTWF0aC5mbG9vcihNYXRoLmxvZyhvZmZzZXQpIC8gTWF0aC5sb2coMikpIC8gOCkgfCAwO1xuICAgIHZhciBvZmZzZXRFbmNvZGVyID0gW3VuZGVmaW5lZCwgZW5jb2RlLkJZVEUsIGVuY29kZS5VU0hPUlQsIGVuY29kZS5VSU5UMjQsIGVuY29kZS5VTE9OR11bb2ZmU2l6ZV07XG4gICAgZm9yICh2YXIgaSQxID0gMDsgaSQxIDwgb2Zmc2V0cy5sZW5ndGg7IGkkMSArPSAxKSB7XG4gICAgICAgIHZhciBlbmNvZGVkT2Zmc2V0ID0gb2Zmc2V0RW5jb2RlcihvZmZzZXRzW2kkMV0pO1xuICAgICAgICBBcnJheS5wcm90b3R5cGUucHVzaC5hcHBseShlbmNvZGVkT2Zmc2V0cywgZW5jb2RlZE9mZnNldCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIEFycmF5LnByb3RvdHlwZS5jb25jYXQoZW5jb2RlLkNhcmQxNihsLmxlbmd0aCksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICBlbmNvZGUuT2ZmU2l6ZShvZmZTaXplKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIGVuY29kZWRPZmZzZXRzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YSk7XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7QXJyYXl9XG4gKiBAcmV0dXJucyB7bnVtYmVyfVxuICovXG5zaXplT2YuSU5ERVggPSBmdW5jdGlvbih2KSB7XG4gICAgcmV0dXJuIGVuY29kZS5JTkRFWCh2KS5sZW5ndGg7XG59O1xuXG4vKipcbiAqIENvbnZlcnQgYW4gb2JqZWN0IHRvIGEgQ0ZGIERJQ1Qgc3RydWN0dXJlLlxuICogVGhlIGtleXMgc2hvdWxkIGJlIG51bWVyaWMuXG4gKiBUaGUgdmFsdWVzIHNob3VsZCBiZSBvYmplY3RzIGNvbnRhaW5pbmcgbmFtZSAvIHR5cGUgLyB2YWx1ZS5cbiAqIEBwYXJhbSB7T2JqZWN0fSBtXG4gKiBAcmV0dXJucyB7QXJyYXl9XG4gKi9cbmVuY29kZS5ESUNUID0gZnVuY3Rpb24obSkge1xuICAgIHZhciBkID0gW107XG4gICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhtKTtcbiAgICB2YXIgbGVuZ3RoID0ga2V5cy5sZW5ndGg7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgIC8vIE9iamVjdC5rZXlzKCkgcmV0dXJuIHN0cmluZyBrZXlzLCBidXQgb3VyIGtleXMgYXJlIGFsd2F5cyBudW1lcmljLlxuICAgICAgICB2YXIgayA9IHBhcnNlSW50KGtleXNbaV0sIDApO1xuICAgICAgICB2YXIgdiA9IG1ba107XG4gICAgICAgIC8vIFZhbHVlIGNvbWVzIGJlZm9yZSB0aGUga2V5LlxuICAgICAgICBkID0gZC5jb25jYXQoZW5jb2RlLk9QRVJBTkQodi52YWx1ZSwgdi50eXBlKSk7XG4gICAgICAgIGQgPSBkLmNvbmNhdChlbmNvZGUuT1BFUkFUT1IoaykpO1xuICAgIH1cblxuICAgIHJldHVybiBkO1xufTtcblxuLyoqXG4gKiBAcGFyYW0ge09iamVjdH1cbiAqIEByZXR1cm5zIHtudW1iZXJ9XG4gKi9cbnNpemVPZi5ESUNUID0gZnVuY3Rpb24obSkge1xuICAgIHJldHVybiBlbmNvZGUuRElDVChtKS5sZW5ndGg7XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7bnVtYmVyfVxuICogQHJldHVybnMge0FycmF5fVxuICovXG5lbmNvZGUuT1BFUkFUT1IgPSBmdW5jdGlvbih2KSB7XG4gICAgaWYgKHYgPCAxMjAwKSB7XG4gICAgICAgIHJldHVybiBbdl07XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIFsxMiwgdiAtIDEyMDBdO1xuICAgIH1cbn07XG5cbi8qKlxuICogQHBhcmFtIHtBcnJheX0gdlxuICogQHBhcmFtIHtzdHJpbmd9XG4gKiBAcmV0dXJucyB7QXJyYXl9XG4gKi9cbmVuY29kZS5PUEVSQU5EID0gZnVuY3Rpb24odiwgdHlwZSkge1xuICAgIHZhciBkID0gW107XG4gICAgaWYgKEFycmF5LmlzQXJyYXkodHlwZSkpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0eXBlLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgICAgICBjaGVjay5hcmd1bWVudCh2Lmxlbmd0aCA9PT0gdHlwZS5sZW5ndGgsICdOb3QgZW5vdWdoIGFyZ3VtZW50cyBnaXZlbiBmb3IgdHlwZScgKyB0eXBlKTtcbiAgICAgICAgICAgIGQgPSBkLmNvbmNhdChlbmNvZGUuT1BFUkFORCh2W2ldLCB0eXBlW2ldKSk7XG4gICAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgICBpZiAodHlwZSA9PT0gJ1NJRCcpIHtcbiAgICAgICAgICAgIGQgPSBkLmNvbmNhdChlbmNvZGUuTlVNQkVSKHYpKTtcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlID09PSAnb2Zmc2V0Jykge1xuICAgICAgICAgICAgLy8gV2UgbWFrZSBpdCBlYXN5IGZvciBvdXJzZWx2ZXMgYW5kIGFsd2F5cyBlbmNvZGUgb2Zmc2V0cyBhc1xuICAgICAgICAgICAgLy8gNCBieXRlcy4gVGhpcyBtYWtlcyBvZmZzZXQgY2FsY3VsYXRpb24gZm9yIHRoZSB0b3AgZGljdCBlYXNpZXIuXG4gICAgICAgICAgICBkID0gZC5jb25jYXQoZW5jb2RlLk5VTUJFUjMyKHYpKTtcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgZCA9IGQuY29uY2F0KGVuY29kZS5OVU1CRVIodikpO1xuICAgICAgICB9IGVsc2UgaWYgKHR5cGUgPT09ICdyZWFsJykge1xuICAgICAgICAgICAgZCA9IGQuY29uY2F0KGVuY29kZS5SRUFMKHYpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVW5rbm93biBvcGVyYW5kIHR5cGUgJyArIHR5cGUpO1xuICAgICAgICAgICAgLy8gRklYTUUgQWRkIHN1cHBvcnQgZm9yIGJvb2xlYW5zXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gZDtcbn07XG5cbmVuY29kZS5PUCA9IGVuY29kZS5CWVRFO1xuc2l6ZU9mLk9QID0gc2l6ZU9mLkJZVEU7XG5cbi8vIG1lbW9pemUgY2hhcnN0cmluZyBlbmNvZGluZyB1c2luZyBXZWFrTWFwIGlmIGF2YWlsYWJsZVxudmFyIHdtbSA9IHR5cGVvZiBXZWFrTWFwID09PSAnZnVuY3Rpb24nICYmIG5ldyBXZWFrTWFwKCk7XG5cbi8qKlxuICogQ29udmVydCBhIGxpc3Qgb2YgQ2hhclN0cmluZyBvcGVyYXRpb25zIHRvIGJ5dGVzLlxuICogQHBhcmFtIHtBcnJheX1cbiAqIEByZXR1cm5zIHtBcnJheX1cbiAqL1xuZW5jb2RlLkNIQVJTVFJJTkcgPSBmdW5jdGlvbihvcHMpIHtcbiAgICAvLyBTZWUgZW5jb2RlLk1BQ1NUUklORyBmb3Igd2h5IHdlIGRvbid0IGRvIFwiaWYgKHdtbSAmJiB3bW0uaGFzKG9wcykpXCIuXG4gICAgaWYgKHdtbSkge1xuICAgICAgICB2YXIgY2FjaGVkVmFsdWUgPSB3bW0uZ2V0KG9wcyk7XG4gICAgICAgIGlmIChjYWNoZWRWYWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkVmFsdWU7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgZCA9IFtdO1xuICAgIHZhciBsZW5ndGggPSBvcHMubGVuZ3RoO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICB2YXIgb3AgPSBvcHNbaV07XG4gICAgICAgIGQgPSBkLmNvbmNhdChlbmNvZGVbb3AudHlwZV0ob3AudmFsdWUpKTtcbiAgICB9XG5cbiAgICBpZiAod21tKSB7XG4gICAgICAgIHdtbS5zZXQob3BzLCBkKTtcbiAgICB9XG5cbiAgICByZXR1cm4gZDtcbn07XG5cbi8qKlxuICogQHBhcmFtIHtBcnJheX1cbiAqIEByZXR1cm5zIHtudW1iZXJ9XG4gKi9cbnNpemVPZi5DSEFSU1RSSU5HID0gZnVuY3Rpb24ob3BzKSB7XG4gICAgcmV0dXJuIGVuY29kZS5DSEFSU1RSSU5HKG9wcykubGVuZ3RoO1xufTtcblxuLy8gVXRpbGl0eSBmdW5jdGlvbnMgLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cblxuLyoqXG4gKiBDb252ZXJ0IGFuIG9iamVjdCBjb250YWluaW5nIG5hbWUgLyB0eXBlIC8gdmFsdWUgdG8gYnl0ZXMuXG4gKiBAcGFyYW0ge09iamVjdH1cbiAqIEByZXR1cm5zIHtBcnJheX1cbiAqL1xuZW5jb2RlLk9CSkVDVCA9IGZ1bmN0aW9uKHYpIHtcbiAgICB2YXIgZW5jb2RpbmdGdW5jdGlvbiA9IGVuY29kZVt2LnR5cGVdO1xuICAgIGNoZWNrLmFyZ3VtZW50KGVuY29kaW5nRnVuY3Rpb24gIT09IHVuZGVmaW5lZCwgJ05vIGVuY29kaW5nIGZ1bmN0aW9uIGZvciB0eXBlICcgKyB2LnR5cGUpO1xuICAgIHJldHVybiBlbmNvZGluZ0Z1bmN0aW9uKHYudmFsdWUpO1xufTtcblxuLyoqXG4gKiBAcGFyYW0ge09iamVjdH1cbiAqIEByZXR1cm5zIHtudW1iZXJ9XG4gKi9cbnNpemVPZi5PQkpFQ1QgPSBmdW5jdGlvbih2KSB7XG4gICAgdmFyIHNpemVPZkZ1bmN0aW9uID0gc2l6ZU9mW3YudHlwZV07XG4gICAgY2hlY2suYXJndW1lbnQoc2l6ZU9mRnVuY3Rpb24gIT09IHVuZGVmaW5lZCwgJ05vIHNpemVPZiBmdW5jdGlvbiBmb3IgdHlwZSAnICsgdi50eXBlKTtcbiAgICByZXR1cm4gc2l6ZU9mRnVuY3Rpb24odi52YWx1ZSk7XG59O1xuXG4vKipcbiAqIENvbnZlcnQgYSB0YWJsZSBvYmplY3QgdG8gYnl0ZXMuXG4gKiBBIHRhYmxlIGNvbnRhaW5zIGEgbGlzdCBvZiBmaWVsZHMgY29udGFpbmluZyB0aGUgbWV0YWRhdGEgKG5hbWUsIHR5cGUgYW5kIGRlZmF1bHQgdmFsdWUpLlxuICogVGhlIHRhYmxlIGl0c2VsZiBoYXMgdGhlIGZpZWxkIHZhbHVlcyBzZXQgYXMgYXR0cmlidXRlcy5cbiAqIEBwYXJhbSB7b3BlbnR5cGUuVGFibGV9XG4gKiBAcmV0dXJucyB7QXJyYXl9XG4gKi9cbmVuY29kZS5UQUJMRSA9IGZ1bmN0aW9uKHRhYmxlKSB7XG4gICAgdmFyIGQgPSBbXTtcbiAgICB2YXIgbGVuZ3RoID0gdGFibGUuZmllbGRzLmxlbmd0aDtcbiAgICB2YXIgc3VidGFibGVzID0gW107XG4gICAgdmFyIHN1YnRhYmxlT2Zmc2V0cyA9IFtdO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICB2YXIgZmllbGQgPSB0YWJsZS5maWVsZHNbaV07XG4gICAgICAgIHZhciBlbmNvZGluZ0Z1bmN0aW9uID0gZW5jb2RlW2ZpZWxkLnR5cGVdO1xuICAgICAgICBjaGVjay5hcmd1bWVudChlbmNvZGluZ0Z1bmN0aW9uICE9PSB1bmRlZmluZWQsICdObyBlbmNvZGluZyBmdW5jdGlvbiBmb3IgZmllbGQgdHlwZSAnICsgZmllbGQudHlwZSArICcgKCcgKyBmaWVsZC5uYW1lICsgJyknKTtcbiAgICAgICAgdmFyIHZhbHVlID0gdGFibGVbZmllbGQubmFtZV07XG4gICAgICAgIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB2YWx1ZSA9IGZpZWxkLnZhbHVlO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGJ5dGVzID0gZW5jb2RpbmdGdW5jdGlvbih2YWx1ZSk7XG5cbiAgICAgICAgaWYgKGZpZWxkLnR5cGUgPT09ICdUQUJMRScpIHtcbiAgICAgICAgICAgIHN1YnRhYmxlT2Zmc2V0cy5wdXNoKGQubGVuZ3RoKTtcbiAgICAgICAgICAgIGQgPSBkLmNvbmNhdChbMCwgMF0pO1xuICAgICAgICAgICAgc3VidGFibGVzLnB1c2goYnl0ZXMpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZCA9IGQuY29uY2F0KGJ5dGVzKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZvciAodmFyIGkkMSA9IDA7IGkkMSA8IHN1YnRhYmxlcy5sZW5ndGg7IGkkMSArPSAxKSB7XG4gICAgICAgIHZhciBvID0gc3VidGFibGVPZmZzZXRzW2kkMV07XG4gICAgICAgIHZhciBvZmZzZXQgPSBkLmxlbmd0aDtcbiAgICAgICAgY2hlY2suYXJndW1lbnQob2Zmc2V0IDwgNjU1MzYsICdUYWJsZSAnICsgdGFibGUudGFibGVOYW1lICsgJyB0b28gYmlnLicpO1xuICAgICAgICBkW29dID0gb2Zmc2V0ID4+IDg7XG4gICAgICAgIGRbbyArIDFdID0gb2Zmc2V0ICYgMHhmZjtcbiAgICAgICAgZCA9IGQuY29uY2F0KHN1YnRhYmxlc1tpJDFdKTtcbiAgICB9XG5cbiAgICByZXR1cm4gZDtcbn07XG5cbi8qKlxuICogQHBhcmFtIHtvcGVudHlwZS5UYWJsZX1cbiAqIEByZXR1cm5zIHtudW1iZXJ9XG4gKi9cbnNpemVPZi5UQUJMRSA9IGZ1bmN0aW9uKHRhYmxlKSB7XG4gICAgdmFyIG51bUJ5dGVzID0gMDtcbiAgICB2YXIgbGVuZ3RoID0gdGFibGUuZmllbGRzLmxlbmd0aDtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgdmFyIGZpZWxkID0gdGFibGUuZmllbGRzW2ldO1xuICAgICAgICB2YXIgc2l6ZU9mRnVuY3Rpb24gPSBzaXplT2ZbZmllbGQudHlwZV07XG4gICAgICAgIGNoZWNrLmFyZ3VtZW50KHNpemVPZkZ1bmN0aW9uICE9PSB1bmRlZmluZWQsICdObyBzaXplT2YgZnVuY3Rpb24gZm9yIGZpZWxkIHR5cGUgJyArIGZpZWxkLnR5cGUgKyAnICgnICsgZmllbGQubmFtZSArICcpJyk7XG4gICAgICAgIHZhciB2YWx1ZSA9IHRhYmxlW2ZpZWxkLm5hbWVdO1xuICAgICAgICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdmFsdWUgPSBmaWVsZC52YWx1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIG51bUJ5dGVzICs9IHNpemVPZkZ1bmN0aW9uKHZhbHVlKTtcblxuICAgICAgICAvLyBTdWJ0YWJsZXMgdGFrZSAyIG1vcmUgYnl0ZXMgZm9yIG9mZnNldHMuXG4gICAgICAgIGlmIChmaWVsZC50eXBlID09PSAnVEFCTEUnKSB7XG4gICAgICAgICAgICBudW1CeXRlcyArPSAyO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIG51bUJ5dGVzO1xufTtcblxuZW5jb2RlLlJFQ09SRCA9IGVuY29kZS5UQUJMRTtcbnNpemVPZi5SRUNPUkQgPSBzaXplT2YuVEFCTEU7XG5cbi8vIE1lcmdlIGluIGEgbGlzdCBvZiBieXRlcy5cbmVuY29kZS5MSVRFUkFMID0gZnVuY3Rpb24odikge1xuICAgIHJldHVybiB2O1xufTtcblxuc2l6ZU9mLkxJVEVSQUwgPSBmdW5jdGlvbih2KSB7XG4gICAgcmV0dXJuIHYubGVuZ3RoO1xufTtcblxuLy8gVGFibGUgbWV0YWRhdGFcblxuLyoqXG4gKiBAZXhwb3J0cyBvcGVudHlwZS5UYWJsZVxuICogQGNsYXNzXG4gKiBAcGFyYW0ge3N0cmluZ30gdGFibGVOYW1lXG4gKiBAcGFyYW0ge0FycmF5fSBmaWVsZHNcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gKiBAY29uc3RydWN0b3JcbiAqL1xuZnVuY3Rpb24gVGFibGUodGFibGVOYW1lLCBmaWVsZHMsIG9wdGlvbnMpIHtcbiAgICAvLyBGb3IgY292ZXJhZ2UgdGFibGVzIHdpdGggY292ZXJhZ2UgZm9ybWF0IDIsIHdlIGRvIG5vdCB3YW50IHRvIGFkZCB0aGUgY292ZXJhZ2UgZGF0YSBkaXJlY3RseSB0byB0aGUgdGFibGUgb2JqZWN0LFxuICAgIC8vIGFzIHRoaXMgd2lsbCByZXN1bHQgaW4gd3JvbmcgZW5jb2Rpbmcgb3JkZXIgb2YgdGhlIGNvdmVyYWdlIGRhdGEgb24gc2VyaWFsaXphdGlvbiB0byBieXRlcy5cbiAgICAvLyBUaGUgZmFsbGJhY2sgb2YgdXNpbmcgdGhlIGZpZWxkIHZhbHVlcyBkaXJlY3RseSB3aGVuIG5vdCBwcmVzZW50IG9uIHRoZSB0YWJsZSBpcyBoYW5kbGVkIGluIHR5cGVzLmVuY29kZS5UQUJMRSgpIGFscmVhZHkuXG4gICAgaWYgKGZpZWxkcy5sZW5ndGggJiYgKGZpZWxkc1swXS5uYW1lICE9PSAnY292ZXJhZ2VGb3JtYXQnIHx8IGZpZWxkc1swXS52YWx1ZSA9PT0gMSkpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBmaWVsZHMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgICAgIHZhciBmaWVsZCA9IGZpZWxkc1tpXTtcbiAgICAgICAgICAgIHRoaXNbZmllbGQubmFtZV0gPSBmaWVsZC52YWx1ZTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMudGFibGVOYW1lID0gdGFibGVOYW1lO1xuICAgIHRoaXMuZmllbGRzID0gZmllbGRzO1xuICAgIGlmIChvcHRpb25zKSB7XG4gICAgICAgIHZhciBvcHRpb25LZXlzID0gT2JqZWN0LmtleXMob3B0aW9ucyk7XG4gICAgICAgIGZvciAodmFyIGkkMSA9IDA7IGkkMSA8IG9wdGlvbktleXMubGVuZ3RoOyBpJDEgKz0gMSkge1xuICAgICAgICAgICAgdmFyIGsgPSBvcHRpb25LZXlzW2kkMV07XG4gICAgICAgICAgICB2YXIgdiA9IG9wdGlvbnNba107XG4gICAgICAgICAgICBpZiAodGhpc1trXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdGhpc1trXSA9IHY7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59XG5cbi8qKlxuICogRW5jb2RlcyB0aGUgdGFibGUgYW5kIHJldHVybnMgYW4gYXJyYXkgb2YgYnl0ZXNcbiAqIEByZXR1cm4ge0FycmF5fVxuICovXG5UYWJsZS5wcm90b3R5cGUuZW5jb2RlID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIGVuY29kZS5UQUJMRSh0aGlzKTtcbn07XG5cbi8qKlxuICogR2V0IHRoZSBzaXplIG9mIHRoZSB0YWJsZS5cbiAqIEByZXR1cm4ge251bWJlcn1cbiAqL1xuVGFibGUucHJvdG90eXBlLnNpemVPZiA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBzaXplT2YuVEFCTEUodGhpcyk7XG59O1xuXG4vKipcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIHVzaG9ydExpc3QoaXRlbU5hbWUsIGxpc3QsIGNvdW50KSB7XG4gICAgaWYgKGNvdW50ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgY291bnQgPSBsaXN0Lmxlbmd0aDtcbiAgICB9XG4gICAgdmFyIGZpZWxkcyA9IG5ldyBBcnJheShsaXN0Lmxlbmd0aCArIDEpO1xuICAgIGZpZWxkc1swXSA9IHtuYW1lOiBpdGVtTmFtZSArICdDb3VudCcsIHR5cGU6ICdVU0hPUlQnLCB2YWx1ZTogY291bnR9O1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7IGkrKykge1xuICAgICAgICBmaWVsZHNbaSArIDFdID0ge25hbWU6IGl0ZW1OYW1lICsgaSwgdHlwZTogJ1VTSE9SVCcsIHZhbHVlOiBsaXN0W2ldfTtcbiAgICB9XG4gICAgcmV0dXJuIGZpZWxkcztcbn1cblxuLyoqXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiB0YWJsZUxpc3QoaXRlbU5hbWUsIHJlY29yZHMsIGl0ZW1DYWxsYmFjaykge1xuICAgIHZhciBjb3VudCA9IHJlY29yZHMubGVuZ3RoO1xuICAgIHZhciBmaWVsZHMgPSBuZXcgQXJyYXkoY291bnQgKyAxKTtcbiAgICBmaWVsZHNbMF0gPSB7bmFtZTogaXRlbU5hbWUgKyAnQ291bnQnLCB0eXBlOiAnVVNIT1JUJywgdmFsdWU6IGNvdW50fTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNvdW50OyBpKyspIHtcbiAgICAgICAgZmllbGRzW2kgKyAxXSA9IHtuYW1lOiBpdGVtTmFtZSArIGksIHR5cGU6ICdUQUJMRScsIHZhbHVlOiBpdGVtQ2FsbGJhY2socmVjb3Jkc1tpXSwgaSl9O1xuICAgIH1cbiAgICByZXR1cm4gZmllbGRzO1xufVxuXG4vKipcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIHJlY29yZExpc3QoaXRlbU5hbWUsIHJlY29yZHMsIGl0ZW1DYWxsYmFjaykge1xuICAgIHZhciBjb3VudCA9IHJlY29yZHMubGVuZ3RoO1xuICAgIHZhciBmaWVsZHMgPSBbXTtcbiAgICBmaWVsZHNbMF0gPSB7bmFtZTogaXRlbU5hbWUgKyAnQ291bnQnLCB0eXBlOiAnVVNIT1JUJywgdmFsdWU6IGNvdW50fTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNvdW50OyBpKyspIHtcbiAgICAgICAgZmllbGRzID0gZmllbGRzLmNvbmNhdChpdGVtQ2FsbGJhY2socmVjb3Jkc1tpXSwgaSkpO1xuICAgIH1cbiAgICByZXR1cm4gZmllbGRzO1xufVxuXG4vLyBDb21tb24gTGF5b3V0IFRhYmxlc1xuXG4vKipcbiAqIEBleHBvcnRzIG9wZW50eXBlLkNvdmVyYWdlXG4gKiBAY2xhc3NcbiAqIEBwYXJhbSB7b3BlbnR5cGUuVGFibGV9XG4gKiBAY29uc3RydWN0b3JcbiAqIEBleHRlbmRzIG9wZW50eXBlLlRhYmxlXG4gKi9cbmZ1bmN0aW9uIENvdmVyYWdlKGNvdmVyYWdlVGFibGUpIHtcbiAgICBpZiAoY292ZXJhZ2VUYWJsZS5mb3JtYXQgPT09IDEpIHtcbiAgICAgICAgVGFibGUuY2FsbCh0aGlzLCAnY292ZXJhZ2VUYWJsZScsXG4gICAgICAgICAgICBbe25hbWU6ICdjb3ZlcmFnZUZvcm1hdCcsIHR5cGU6ICdVU0hPUlQnLCB2YWx1ZTogMX1dXG4gICAgICAgICAgICAuY29uY2F0KHVzaG9ydExpc3QoJ2dseXBoJywgY292ZXJhZ2VUYWJsZS5nbHlwaHMpKVxuICAgICAgICApO1xuICAgIH0gZWxzZSBpZiAoY292ZXJhZ2VUYWJsZS5mb3JtYXQgPT09IDIpIHtcbiAgICAgICAgVGFibGUuY2FsbCh0aGlzLCAnY292ZXJhZ2VUYWJsZScsXG4gICAgICAgICAgICBbe25hbWU6ICdjb3ZlcmFnZUZvcm1hdCcsIHR5cGU6ICdVU0hPUlQnLCB2YWx1ZTogMn1dXG4gICAgICAgICAgICAuY29uY2F0KHJlY29yZExpc3QoJ3JhbmdlUmVjb3JkJywgY292ZXJhZ2VUYWJsZS5yYW5nZXMsIGZ1bmN0aW9uKFJhbmdlUmVjb3JkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgICAgICAgICAge25hbWU6ICdzdGFydEdseXBoSUQnLCB0eXBlOiAnVVNIT1JUJywgdmFsdWU6IFJhbmdlUmVjb3JkLnN0YXJ0fSxcbiAgICAgICAgICAgICAgICAgICAge25hbWU6ICdlbmRHbHlwaElEJywgdHlwZTogJ1VTSE9SVCcsIHZhbHVlOiBSYW5nZVJlY29yZC5lbmR9LFxuICAgICAgICAgICAgICAgICAgICB7bmFtZTogJ3N0YXJ0Q292ZXJhZ2VJbmRleCcsIHR5cGU6ICdVU0hPUlQnLCB2YWx1ZTogUmFuZ2VSZWNvcmQuaW5kZXh9IF07XG4gICAgICAgICAgICB9KSlcbiAgICAgICAgKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBjaGVjay5hc3NlcnQoZmFsc2UsICdDb3ZlcmFnZSBmb3JtYXQgbXVzdCBiZSAxIG9yIDIuJyk7XG4gICAgfVxufVxuQ292ZXJhZ2UucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShUYWJsZS5wcm90b3R5cGUpO1xuQ292ZXJhZ2UucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gQ292ZXJhZ2U7XG5cbmZ1bmN0aW9uIFNjcmlwdExpc3Qoc2NyaXB0TGlzdFRhYmxlKSB7XG4gICAgVGFibGUuY2FsbCh0aGlzLCAnc2NyaXB0TGlzdFRhYmxlJyxcbiAgICAgICAgcmVjb3JkTGlzdCgnc2NyaXB0UmVjb3JkJywgc2NyaXB0TGlzdFRhYmxlLCBmdW5jdGlvbihzY3JpcHRSZWNvcmQsIGkpIHtcbiAgICAgICAgICAgIHZhciBzY3JpcHQgPSBzY3JpcHRSZWNvcmQuc2NyaXB0O1xuICAgICAgICAgICAgdmFyIGRlZmF1bHRMYW5nU3lzID0gc2NyaXB0LmRlZmF1bHRMYW5nU3lzO1xuICAgICAgICAgICAgY2hlY2suYXNzZXJ0KCEhZGVmYXVsdExhbmdTeXMsICdVbmFibGUgdG8gd3JpdGUgR1NVQjogc2NyaXB0ICcgKyBzY3JpcHRSZWNvcmQudGFnICsgJyBoYXMgbm8gZGVmYXVsdCBsYW5ndWFnZSBzeXN0ZW0uJyk7XG4gICAgICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgICAgIHtuYW1lOiAnc2NyaXB0VGFnJyArIGksIHR5cGU6ICdUQUcnLCB2YWx1ZTogc2NyaXB0UmVjb3JkLnRhZ30sXG4gICAgICAgICAgICAgICAge25hbWU6ICdzY3JpcHQnICsgaSwgdHlwZTogJ1RBQkxFJywgdmFsdWU6IG5ldyBUYWJsZSgnc2NyaXB0VGFibGUnLCBbXG4gICAgICAgICAgICAgICAgICAgIHtuYW1lOiAnZGVmYXVsdExhbmdTeXMnLCB0eXBlOiAnVEFCTEUnLCB2YWx1ZTogbmV3IFRhYmxlKCdkZWZhdWx0TGFuZ1N5cycsIFtcbiAgICAgICAgICAgICAgICAgICAgICAgIHtuYW1lOiAnbG9va3VwT3JkZXInLCB0eXBlOiAnVVNIT1JUJywgdmFsdWU6IDB9LFxuICAgICAgICAgICAgICAgICAgICAgICAge25hbWU6ICdyZXFGZWF0dXJlSW5kZXgnLCB0eXBlOiAnVVNIT1JUJywgdmFsdWU6IGRlZmF1bHRMYW5nU3lzLnJlcUZlYXR1cmVJbmRleH1dXG4gICAgICAgICAgICAgICAgICAgICAgICAuY29uY2F0KHVzaG9ydExpc3QoJ2ZlYXR1cmVJbmRleCcsIGRlZmF1bHRMYW5nU3lzLmZlYXR1cmVJbmRleGVzKSkpfVxuICAgICAgICAgICAgICAgICAgICBdLmNvbmNhdChyZWNvcmRMaXN0KCdsYW5nU3lzJywgc2NyaXB0LmxhbmdTeXNSZWNvcmRzLCBmdW5jdGlvbihsYW5nU3lzUmVjb3JkLCBpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgbGFuZ1N5cyA9IGxhbmdTeXNSZWNvcmQubGFuZ1N5cztcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAge25hbWU6ICdsYW5nU3lzVGFnJyArIGksIHR5cGU6ICdUQUcnLCB2YWx1ZTogbGFuZ1N5c1JlY29yZC50YWd9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtuYW1lOiAnbGFuZ1N5cycgKyBpLCB0eXBlOiAnVEFCTEUnLCB2YWx1ZTogbmV3IFRhYmxlKCdsYW5nU3lzJywgW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7bmFtZTogJ2xvb2t1cE9yZGVyJywgdHlwZTogJ1VTSE9SVCcsIHZhbHVlOiAwfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAge25hbWU6ICdyZXFGZWF0dXJlSW5kZXgnLCB0eXBlOiAnVVNIT1JUJywgdmFsdWU6IGxhbmdTeXMucmVxRmVhdHVyZUluZGV4fVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBdLmNvbmNhdCh1c2hvcnRMaXN0KCdmZWF0dXJlSW5kZXgnLCBsYW5nU3lzLmZlYXR1cmVJbmRleGVzKSkpfVxuICAgICAgICAgICAgICAgICAgICAgICAgXTtcbiAgICAgICAgICAgICAgICAgICAgfSkpKX1cbiAgICAgICAgICAgIF07XG4gICAgICAgIH0pXG4gICAgKTtcbn1cblNjcmlwdExpc3QucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShUYWJsZS5wcm90b3R5cGUpO1xuU2NyaXB0TGlzdC5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBTY3JpcHRMaXN0O1xuXG4vKipcbiAqIEBleHBvcnRzIG9wZW50eXBlLkZlYXR1cmVMaXN0XG4gKiBAY2xhc3NcbiAqIEBwYXJhbSB7b3BlbnR5cGUuVGFibGV9XG4gKiBAY29uc3RydWN0b3JcbiAqIEBleHRlbmRzIG9wZW50eXBlLlRhYmxlXG4gKi9cbmZ1bmN0aW9uIEZlYXR1cmVMaXN0KGZlYXR1cmVMaXN0VGFibGUpIHtcbiAgICBUYWJsZS5jYWxsKHRoaXMsICdmZWF0dXJlTGlzdFRhYmxlJyxcbiAgICAgICAgcmVjb3JkTGlzdCgnZmVhdHVyZVJlY29yZCcsIGZlYXR1cmVMaXN0VGFibGUsIGZ1bmN0aW9uKGZlYXR1cmVSZWNvcmQsIGkpIHtcbiAgICAgICAgICAgIHZhciBmZWF0dXJlID0gZmVhdHVyZVJlY29yZC5mZWF0dXJlO1xuICAgICAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgICAgICB7bmFtZTogJ2ZlYXR1cmVUYWcnICsgaSwgdHlwZTogJ1RBRycsIHZhbHVlOiBmZWF0dXJlUmVjb3JkLnRhZ30sXG4gICAgICAgICAgICAgICAge25hbWU6ICdmZWF0dXJlJyArIGksIHR5cGU6ICdUQUJMRScsIHZhbHVlOiBuZXcgVGFibGUoJ2ZlYXR1cmVUYWJsZScsIFtcbiAgICAgICAgICAgICAgICAgICAge25hbWU6ICdmZWF0dXJlUGFyYW1zJywgdHlwZTogJ1VTSE9SVCcsIHZhbHVlOiBmZWF0dXJlLmZlYXR1cmVQYXJhbXN9IF0uY29uY2F0KHVzaG9ydExpc3QoJ2xvb2t1cExpc3RJbmRleCcsIGZlYXR1cmUubG9va3VwTGlzdEluZGV4ZXMpKSl9XG4gICAgICAgICAgICBdO1xuICAgICAgICB9KVxuICAgICk7XG59XG5GZWF0dXJlTGlzdC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKFRhYmxlLnByb3RvdHlwZSk7XG5GZWF0dXJlTGlzdC5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBGZWF0dXJlTGlzdDtcblxuLyoqXG4gKiBAZXhwb3J0cyBvcGVudHlwZS5Mb29rdXBMaXN0XG4gKiBAY2xhc3NcbiAqIEBwYXJhbSB7b3BlbnR5cGUuVGFibGV9XG4gKiBAcGFyYW0ge09iamVjdH1cbiAqIEBjb25zdHJ1Y3RvclxuICogQGV4dGVuZHMgb3BlbnR5cGUuVGFibGVcbiAqL1xuZnVuY3Rpb24gTG9va3VwTGlzdChsb29rdXBMaXN0VGFibGUsIHN1YnRhYmxlTWFrZXJzKSB7XG4gICAgVGFibGUuY2FsbCh0aGlzLCAnbG9va3VwTGlzdFRhYmxlJywgdGFibGVMaXN0KCdsb29rdXAnLCBsb29rdXBMaXN0VGFibGUsIGZ1bmN0aW9uKGxvb2t1cFRhYmxlKSB7XG4gICAgICAgIHZhciBzdWJ0YWJsZUNhbGxiYWNrID0gc3VidGFibGVNYWtlcnNbbG9va3VwVGFibGUubG9va3VwVHlwZV07XG4gICAgICAgIGNoZWNrLmFzc2VydCghIXN1YnRhYmxlQ2FsbGJhY2ssICdVbmFibGUgdG8gd3JpdGUgR1NVQiBsb29rdXAgdHlwZSAnICsgbG9va3VwVGFibGUubG9va3VwVHlwZSArICcgdGFibGVzLicpO1xuICAgICAgICByZXR1cm4gbmV3IFRhYmxlKCdsb29rdXBUYWJsZScsIFtcbiAgICAgICAgICAgIHtuYW1lOiAnbG9va3VwVHlwZScsIHR5cGU6ICdVU0hPUlQnLCB2YWx1ZTogbG9va3VwVGFibGUubG9va3VwVHlwZX0sXG4gICAgICAgICAgICB7bmFtZTogJ2xvb2t1cEZsYWcnLCB0eXBlOiAnVVNIT1JUJywgdmFsdWU6IGxvb2t1cFRhYmxlLmxvb2t1cEZsYWd9XG4gICAgICAgIF0uY29uY2F0KHRhYmxlTGlzdCgnc3VidGFibGUnLCBsb29rdXBUYWJsZS5zdWJ0YWJsZXMsIHN1YnRhYmxlQ2FsbGJhY2spKSk7XG4gICAgfSkpO1xufVxuTG9va3VwTGlzdC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKFRhYmxlLnByb3RvdHlwZSk7XG5Mb29rdXBMaXN0LnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IExvb2t1cExpc3Q7XG5cbi8vIFJlY29yZCA9IHNhbWUgYXMgVGFibGUsIGJ1dCBpbmxpbmVkIChhIFRhYmxlIGhhcyBhbiBvZmZzZXQgYW5kIGl0cyBkYXRhIGlzIGZ1cnRoZXIgaW4gdGhlIHN0cmVhbSlcbi8vIERvbid0IHVzZSBvZmZzZXRzIGluc2lkZSBSZWNvcmRzIChwcm9iYWJsZSBidWcpLCBvbmx5IGluIFRhYmxlcy5cbnZhciB0YWJsZSA9IHtcbiAgICBUYWJsZTogVGFibGUsXG4gICAgUmVjb3JkOiBUYWJsZSxcbiAgICBDb3ZlcmFnZTogQ292ZXJhZ2UsXG4gICAgU2NyaXB0TGlzdDogU2NyaXB0TGlzdCxcbiAgICBGZWF0dXJlTGlzdDogRmVhdHVyZUxpc3QsXG4gICAgTG9va3VwTGlzdDogTG9va3VwTGlzdCxcbiAgICB1c2hvcnRMaXN0OiB1c2hvcnRMaXN0LFxuICAgIHRhYmxlTGlzdDogdGFibGVMaXN0LFxuICAgIHJlY29yZExpc3Q6IHJlY29yZExpc3QsXG59O1xuXG4vLyBQYXJzaW5nIHV0aWxpdHkgZnVuY3Rpb25zXG5cbi8vIFJldHJpZXZlIGFuIHVuc2lnbmVkIGJ5dGUgZnJvbSB0aGUgRGF0YVZpZXcuXG5mdW5jdGlvbiBnZXRCeXRlKGRhdGFWaWV3LCBvZmZzZXQpIHtcbiAgICByZXR1cm4gZGF0YVZpZXcuZ2V0VWludDgob2Zmc2V0KTtcbn1cblxuLy8gUmV0cmlldmUgYW4gdW5zaWduZWQgMTYtYml0IHNob3J0IGZyb20gdGhlIERhdGFWaWV3LlxuLy8gVGhlIHZhbHVlIGlzIHN0b3JlZCBpbiBiaWcgZW5kaWFuLlxuZnVuY3Rpb24gZ2V0VVNob3J0KGRhdGFWaWV3LCBvZmZzZXQpIHtcbiAgICByZXR1cm4gZGF0YVZpZXcuZ2V0VWludDE2KG9mZnNldCwgZmFsc2UpO1xufVxuXG4vLyBSZXRyaWV2ZSBhIHNpZ25lZCAxNi1iaXQgc2hvcnQgZnJvbSB0aGUgRGF0YVZpZXcuXG4vLyBUaGUgdmFsdWUgaXMgc3RvcmVkIGluIGJpZyBlbmRpYW4uXG5mdW5jdGlvbiBnZXRTaG9ydChkYXRhVmlldywgb2Zmc2V0KSB7XG4gICAgcmV0dXJuIGRhdGFWaWV3LmdldEludDE2KG9mZnNldCwgZmFsc2UpO1xufVxuXG4vLyBSZXRyaWV2ZSBhbiB1bnNpZ25lZCAzMi1iaXQgbG9uZyBmcm9tIHRoZSBEYXRhVmlldy5cbi8vIFRoZSB2YWx1ZSBpcyBzdG9yZWQgaW4gYmlnIGVuZGlhbi5cbmZ1bmN0aW9uIGdldFVMb25nKGRhdGFWaWV3LCBvZmZzZXQpIHtcbiAgICByZXR1cm4gZGF0YVZpZXcuZ2V0VWludDMyKG9mZnNldCwgZmFsc2UpO1xufVxuXG4vLyBSZXRyaWV2ZSBhIDMyLWJpdCBzaWduZWQgZml4ZWQtcG9pbnQgbnVtYmVyICgxNi4xNikgZnJvbSB0aGUgRGF0YVZpZXcuXG4vLyBUaGUgdmFsdWUgaXMgc3RvcmVkIGluIGJpZyBlbmRpYW4uXG5mdW5jdGlvbiBnZXRGaXhlZChkYXRhVmlldywgb2Zmc2V0KSB7XG4gICAgdmFyIGRlY2ltYWwgPSBkYXRhVmlldy5nZXRJbnQxNihvZmZzZXQsIGZhbHNlKTtcbiAgICB2YXIgZnJhY3Rpb24gPSBkYXRhVmlldy5nZXRVaW50MTYob2Zmc2V0ICsgMiwgZmFsc2UpO1xuICAgIHJldHVybiBkZWNpbWFsICsgZnJhY3Rpb24gLyA2NTUzNTtcbn1cblxuLy8gUmV0cmlldmUgYSA0LWNoYXJhY3RlciB0YWcgZnJvbSB0aGUgRGF0YVZpZXcuXG4vLyBUYWdzIGFyZSB1c2VkIHRvIGlkZW50aWZ5IHRhYmxlcy5cbmZ1bmN0aW9uIGdldFRhZyhkYXRhVmlldywgb2Zmc2V0KSB7XG4gICAgdmFyIHRhZyA9ICcnO1xuICAgIGZvciAodmFyIGkgPSBvZmZzZXQ7IGkgPCBvZmZzZXQgKyA0OyBpICs9IDEpIHtcbiAgICAgICAgdGFnICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoZGF0YVZpZXcuZ2V0SW50OChpKSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRhZztcbn1cblxuLy8gUmV0cmlldmUgYW4gb2Zmc2V0IGZyb20gdGhlIERhdGFWaWV3LlxuLy8gT2Zmc2V0cyBhcmUgMSB0byA0IGJ5dGVzIGluIGxlbmd0aCwgZGVwZW5kaW5nIG9uIHRoZSBvZmZTaXplIGFyZ3VtZW50LlxuZnVuY3Rpb24gZ2V0T2Zmc2V0KGRhdGFWaWV3LCBvZmZzZXQsIG9mZlNpemUpIHtcbiAgICB2YXIgdiA9IDA7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBvZmZTaXplOyBpICs9IDEpIHtcbiAgICAgICAgdiA8PD0gODtcbiAgICAgICAgdiArPSBkYXRhVmlldy5nZXRVaW50OChvZmZzZXQgKyBpKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdjtcbn1cblxuLy8gUmV0cmlldmUgYSBudW1iZXIgb2YgYnl0ZXMgZnJvbSBzdGFydCBvZmZzZXQgdG8gdGhlIGVuZCBvZmZzZXQgZnJvbSB0aGUgRGF0YVZpZXcuXG5mdW5jdGlvbiBnZXRCeXRlcyhkYXRhVmlldywgc3RhcnRPZmZzZXQsIGVuZE9mZnNldCkge1xuICAgIHZhciBieXRlcyA9IFtdO1xuICAgIGZvciAodmFyIGkgPSBzdGFydE9mZnNldDsgaSA8IGVuZE9mZnNldDsgaSArPSAxKSB7XG4gICAgICAgIGJ5dGVzLnB1c2goZGF0YVZpZXcuZ2V0VWludDgoaSkpO1xuICAgIH1cblxuICAgIHJldHVybiBieXRlcztcbn1cblxuLy8gQ29udmVydCB0aGUgbGlzdCBvZiBieXRlcyB0byBhIHN0cmluZy5cbmZ1bmN0aW9uIGJ5dGVzVG9TdHJpbmcoYnl0ZXMpIHtcbiAgICB2YXIgcyA9ICcnO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYnl0ZXMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgcyArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGJ5dGVzW2ldKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcztcbn1cblxudmFyIHR5cGVPZmZzZXRzID0ge1xuICAgIGJ5dGU6IDEsXG4gICAgdVNob3J0OiAyLFxuICAgIHNob3J0OiAyLFxuICAgIHVMb25nOiA0LFxuICAgIGZpeGVkOiA0LFxuICAgIGxvbmdEYXRlVGltZTogOCxcbiAgICB0YWc6IDRcbn07XG5cbi8vIEEgc3RhdGVmdWwgcGFyc2VyIHRoYXQgY2hhbmdlcyB0aGUgb2Zmc2V0IHdoZW5ldmVyIGEgdmFsdWUgaXMgcmV0cmlldmVkLlxuLy8gVGhlIGRhdGEgaXMgYSBEYXRhVmlldy5cbmZ1bmN0aW9uIFBhcnNlcihkYXRhLCBvZmZzZXQpIHtcbiAgICB0aGlzLmRhdGEgPSBkYXRhO1xuICAgIHRoaXMub2Zmc2V0ID0gb2Zmc2V0O1xuICAgIHRoaXMucmVsYXRpdmVPZmZzZXQgPSAwO1xufVxuXG5QYXJzZXIucHJvdG90eXBlLnBhcnNlQnl0ZSA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciB2ID0gdGhpcy5kYXRhLmdldFVpbnQ4KHRoaXMub2Zmc2V0ICsgdGhpcy5yZWxhdGl2ZU9mZnNldCk7XG4gICAgdGhpcy5yZWxhdGl2ZU9mZnNldCArPSAxO1xuICAgIHJldHVybiB2O1xufTtcblxuUGFyc2VyLnByb3RvdHlwZS5wYXJzZUNoYXIgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgdiA9IHRoaXMuZGF0YS5nZXRJbnQ4KHRoaXMub2Zmc2V0ICsgdGhpcy5yZWxhdGl2ZU9mZnNldCk7XG4gICAgdGhpcy5yZWxhdGl2ZU9mZnNldCArPSAxO1xuICAgIHJldHVybiB2O1xufTtcblxuUGFyc2VyLnByb3RvdHlwZS5wYXJzZUNhcmQ4ID0gUGFyc2VyLnByb3RvdHlwZS5wYXJzZUJ5dGU7XG5cblBhcnNlci5wcm90b3R5cGUucGFyc2VVU2hvcnQgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgdiA9IHRoaXMuZGF0YS5nZXRVaW50MTYodGhpcy5vZmZzZXQgKyB0aGlzLnJlbGF0aXZlT2Zmc2V0KTtcbiAgICB0aGlzLnJlbGF0aXZlT2Zmc2V0ICs9IDI7XG4gICAgcmV0dXJuIHY7XG59O1xuXG5QYXJzZXIucHJvdG90eXBlLnBhcnNlQ2FyZDE2ID0gUGFyc2VyLnByb3RvdHlwZS5wYXJzZVVTaG9ydDtcblBhcnNlci5wcm90b3R5cGUucGFyc2VTSUQgPSBQYXJzZXIucHJvdG90eXBlLnBhcnNlVVNob3J0O1xuUGFyc2VyLnByb3RvdHlwZS5wYXJzZU9mZnNldDE2ID0gUGFyc2VyLnByb3RvdHlwZS5wYXJzZVVTaG9ydDtcblxuUGFyc2VyLnByb3RvdHlwZS5wYXJzZVNob3J0ID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIHYgPSB0aGlzLmRhdGEuZ2V0SW50MTYodGhpcy5vZmZzZXQgKyB0aGlzLnJlbGF0aXZlT2Zmc2V0KTtcbiAgICB0aGlzLnJlbGF0aXZlT2Zmc2V0ICs9IDI7XG4gICAgcmV0dXJuIHY7XG59O1xuXG5QYXJzZXIucHJvdG90eXBlLnBhcnNlRjJEb3QxNCA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciB2ID0gdGhpcy5kYXRhLmdldEludDE2KHRoaXMub2Zmc2V0ICsgdGhpcy5yZWxhdGl2ZU9mZnNldCkgLyAxNjM4NDtcbiAgICB0aGlzLnJlbGF0aXZlT2Zmc2V0ICs9IDI7XG4gICAgcmV0dXJuIHY7XG59O1xuXG5QYXJzZXIucHJvdG90eXBlLnBhcnNlVUxvbmcgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgdiA9IGdldFVMb25nKHRoaXMuZGF0YSwgdGhpcy5vZmZzZXQgKyB0aGlzLnJlbGF0aXZlT2Zmc2V0KTtcbiAgICB0aGlzLnJlbGF0aXZlT2Zmc2V0ICs9IDQ7XG4gICAgcmV0dXJuIHY7XG59O1xuXG5QYXJzZXIucHJvdG90eXBlLnBhcnNlT2Zmc2V0MzIgPSBQYXJzZXIucHJvdG90eXBlLnBhcnNlVUxvbmc7XG5cblBhcnNlci5wcm90b3R5cGUucGFyc2VGaXhlZCA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciB2ID0gZ2V0Rml4ZWQodGhpcy5kYXRhLCB0aGlzLm9mZnNldCArIHRoaXMucmVsYXRpdmVPZmZzZXQpO1xuICAgIHRoaXMucmVsYXRpdmVPZmZzZXQgKz0gNDtcbiAgICByZXR1cm4gdjtcbn07XG5cblBhcnNlci5wcm90b3R5cGUucGFyc2VTdHJpbmcgPSBmdW5jdGlvbihsZW5ndGgpIHtcbiAgICB2YXIgZGF0YVZpZXcgPSB0aGlzLmRhdGE7XG4gICAgdmFyIG9mZnNldCA9IHRoaXMub2Zmc2V0ICsgdGhpcy5yZWxhdGl2ZU9mZnNldDtcbiAgICB2YXIgc3RyaW5nID0gJyc7XG4gICAgdGhpcy5yZWxhdGl2ZU9mZnNldCArPSBsZW5ndGg7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICBzdHJpbmcgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShkYXRhVmlldy5nZXRVaW50OChvZmZzZXQgKyBpKSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHN0cmluZztcbn07XG5cblBhcnNlci5wcm90b3R5cGUucGFyc2VUYWcgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5wYXJzZVN0cmluZyg0KTtcbn07XG5cbi8vIExPTkdEQVRFVElNRSBpcyBhIDY0LWJpdCBpbnRlZ2VyLlxuLy8gSmF2YVNjcmlwdCBhbmQgdW5peCB0aW1lc3RhbXBzIHRyYWRpdGlvbmFsbHkgdXNlIDMyIGJpdHMsIHNvIHdlXG4vLyBvbmx5IHRha2UgdGhlIGxhc3QgMzIgYml0cy5cbi8vICsgU2luY2UgdW50aWwgMjAzOCB0aG9zZSBiaXRzIHdpbGwgYmUgZmlsbGVkIGJ5IHplcm9zIHdlIGNhbiBpZ25vcmUgdGhlbS5cblBhcnNlci5wcm90b3R5cGUucGFyc2VMb25nRGF0ZVRpbWUgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgdiA9IGdldFVMb25nKHRoaXMuZGF0YSwgdGhpcy5vZmZzZXQgKyB0aGlzLnJlbGF0aXZlT2Zmc2V0ICsgNCk7XG4gICAgLy8gU3VidHJhY3Qgc2Vjb25kcyBiZXR3ZWVuIDAxLzAxLzE5MDQgYW5kIDAxLzAxLzE5NzBcbiAgICAvLyB0byBjb252ZXJ0IEFwcGxlIE1hYyB0aW1lc3RhbXAgdG8gU3RhbmRhcmQgVW5peCB0aW1lc3RhbXBcbiAgICB2IC09IDIwODI4NDQ4MDA7XG4gICAgdGhpcy5yZWxhdGl2ZU9mZnNldCArPSA4O1xuICAgIHJldHVybiB2O1xufTtcblxuUGFyc2VyLnByb3RvdHlwZS5wYXJzZVZlcnNpb24gPSBmdW5jdGlvbihtaW5vckJhc2UpIHtcbiAgICB2YXIgbWFqb3IgPSBnZXRVU2hvcnQodGhpcy5kYXRhLCB0aGlzLm9mZnNldCArIHRoaXMucmVsYXRpdmVPZmZzZXQpO1xuXG4gICAgLy8gSG93IHRvIGludGVycHJldCB0aGUgbWlub3IgdmVyc2lvbiBpcyB2ZXJ5IHZhZ3VlIGluIHRoZSBzcGVjLiAweDUwMDAgaXMgNSwgMHgxMDAwIGlzIDFcbiAgICAvLyBEZWZhdWx0IHJldHVybnMgdGhlIGNvcnJlY3QgbnVtYmVyIGlmIG1pbm9yID0gMHhOMDAwIHdoZXJlIE4gaXMgMC05XG4gICAgLy8gU2V0IG1pbm9yQmFzZSB0byAxIGZvciB0YWJsZXMgdGhhdCB1c2UgbWlub3IgPSBOIHdoZXJlIE4gaXMgMC05XG4gICAgdmFyIG1pbm9yID0gZ2V0VVNob3J0KHRoaXMuZGF0YSwgdGhpcy5vZmZzZXQgKyB0aGlzLnJlbGF0aXZlT2Zmc2V0ICsgMik7XG4gICAgdGhpcy5yZWxhdGl2ZU9mZnNldCArPSA0O1xuICAgIGlmIChtaW5vckJhc2UgPT09IHVuZGVmaW5lZCkgeyBtaW5vckJhc2UgPSAweDEwMDA7IH1cbiAgICByZXR1cm4gbWFqb3IgKyBtaW5vciAvIG1pbm9yQmFzZSAvIDEwO1xufTtcblxuUGFyc2VyLnByb3RvdHlwZS5za2lwID0gZnVuY3Rpb24odHlwZSwgYW1vdW50KSB7XG4gICAgaWYgKGFtb3VudCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGFtb3VudCA9IDE7XG4gICAgfVxuXG4gICAgdGhpcy5yZWxhdGl2ZU9mZnNldCArPSB0eXBlT2Zmc2V0c1t0eXBlXSAqIGFtb3VudDtcbn07XG5cbi8vLy8vIFBhcnNpbmcgbGlzdHMgYW5kIHJlY29yZHMgLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXG4vLyBQYXJzZSBhIGxpc3Qgb2YgMzIgYml0IHVuc2lnbmVkIGludGVnZXJzLlxuUGFyc2VyLnByb3RvdHlwZS5wYXJzZVVMb25nTGlzdCA9IGZ1bmN0aW9uKGNvdW50KSB7XG4gICAgaWYgKGNvdW50ID09PSB1bmRlZmluZWQpIHsgY291bnQgPSB0aGlzLnBhcnNlVUxvbmcoKTsgfVxuICAgIHZhciBvZmZzZXRzID0gbmV3IEFycmF5KGNvdW50KTtcbiAgICB2YXIgZGF0YVZpZXcgPSB0aGlzLmRhdGE7XG4gICAgdmFyIG9mZnNldCA9IHRoaXMub2Zmc2V0ICsgdGhpcy5yZWxhdGl2ZU9mZnNldDtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNvdW50OyBpKyspIHtcbiAgICAgICAgb2Zmc2V0c1tpXSA9IGRhdGFWaWV3LmdldFVpbnQzMihvZmZzZXQpO1xuICAgICAgICBvZmZzZXQgKz0gNDtcbiAgICB9XG5cbiAgICB0aGlzLnJlbGF0aXZlT2Zmc2V0ICs9IGNvdW50ICogNDtcbiAgICByZXR1cm4gb2Zmc2V0cztcbn07XG5cbi8vIFBhcnNlIGEgbGlzdCBvZiAxNiBiaXQgdW5zaWduZWQgaW50ZWdlcnMuIFRoZSBsZW5ndGggb2YgdGhlIGxpc3QgY2FuIGJlIHJlYWQgb24gdGhlIHN0cmVhbVxuLy8gb3IgcHJvdmlkZWQgYXMgYW4gYXJndW1lbnQuXG5QYXJzZXIucHJvdG90eXBlLnBhcnNlT2Zmc2V0MTZMaXN0ID1cblBhcnNlci5wcm90b3R5cGUucGFyc2VVU2hvcnRMaXN0ID0gZnVuY3Rpb24oY291bnQpIHtcbiAgICBpZiAoY291bnQgPT09IHVuZGVmaW5lZCkgeyBjb3VudCA9IHRoaXMucGFyc2VVU2hvcnQoKTsgfVxuICAgIHZhciBvZmZzZXRzID0gbmV3IEFycmF5KGNvdW50KTtcbiAgICB2YXIgZGF0YVZpZXcgPSB0aGlzLmRhdGE7XG4gICAgdmFyIG9mZnNldCA9IHRoaXMub2Zmc2V0ICsgdGhpcy5yZWxhdGl2ZU9mZnNldDtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNvdW50OyBpKyspIHtcbiAgICAgICAgb2Zmc2V0c1tpXSA9IGRhdGFWaWV3LmdldFVpbnQxNihvZmZzZXQpO1xuICAgICAgICBvZmZzZXQgKz0gMjtcbiAgICB9XG5cbiAgICB0aGlzLnJlbGF0aXZlT2Zmc2V0ICs9IGNvdW50ICogMjtcbiAgICByZXR1cm4gb2Zmc2V0cztcbn07XG5cbi8vIFBhcnNlcyBhIGxpc3Qgb2YgMTYgYml0IHNpZ25lZCBpbnRlZ2Vycy5cblBhcnNlci5wcm90b3R5cGUucGFyc2VTaG9ydExpc3QgPSBmdW5jdGlvbihjb3VudCkge1xuICAgIHZhciBsaXN0ID0gbmV3IEFycmF5KGNvdW50KTtcbiAgICB2YXIgZGF0YVZpZXcgPSB0aGlzLmRhdGE7XG4gICAgdmFyIG9mZnNldCA9IHRoaXMub2Zmc2V0ICsgdGhpcy5yZWxhdGl2ZU9mZnNldDtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNvdW50OyBpKyspIHtcbiAgICAgICAgbGlzdFtpXSA9IGRhdGFWaWV3LmdldEludDE2KG9mZnNldCk7XG4gICAgICAgIG9mZnNldCArPSAyO1xuICAgIH1cblxuICAgIHRoaXMucmVsYXRpdmVPZmZzZXQgKz0gY291bnQgKiAyO1xuICAgIHJldHVybiBsaXN0O1xufTtcblxuLy8gUGFyc2VzIGEgbGlzdCBvZiBieXRlcy5cblBhcnNlci5wcm90b3R5cGUucGFyc2VCeXRlTGlzdCA9IGZ1bmN0aW9uKGNvdW50KSB7XG4gICAgdmFyIGxpc3QgPSBuZXcgQXJyYXkoY291bnQpO1xuICAgIHZhciBkYXRhVmlldyA9IHRoaXMuZGF0YTtcbiAgICB2YXIgb2Zmc2V0ID0gdGhpcy5vZmZzZXQgKyB0aGlzLnJlbGF0aXZlT2Zmc2V0O1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY291bnQ7IGkrKykge1xuICAgICAgICBsaXN0W2ldID0gZGF0YVZpZXcuZ2V0VWludDgob2Zmc2V0KyspO1xuICAgIH1cblxuICAgIHRoaXMucmVsYXRpdmVPZmZzZXQgKz0gY291bnQ7XG4gICAgcmV0dXJuIGxpc3Q7XG59O1xuXG4vKipcbiAqIFBhcnNlIGEgbGlzdCBvZiBpdGVtcy5cbiAqIFJlY29yZCBjb3VudCBpcyBvcHRpb25hbCwgaWYgb21pdHRlZCBpdCBpcyByZWFkIGZyb20gdGhlIHN0cmVhbS5cbiAqIGl0ZW1DYWxsYmFjayBpcyBvbmUgb2YgdGhlIFBhcnNlciBtZXRob2RzLlxuICovXG5QYXJzZXIucHJvdG90eXBlLnBhcnNlTGlzdCA9IGZ1bmN0aW9uKGNvdW50LCBpdGVtQ2FsbGJhY2spIHtcbiAgICBpZiAoIWl0ZW1DYWxsYmFjaykge1xuICAgICAgICBpdGVtQ2FsbGJhY2sgPSBjb3VudDtcbiAgICAgICAgY291bnQgPSB0aGlzLnBhcnNlVVNob3J0KCk7XG4gICAgfVxuICAgIHZhciBsaXN0ID0gbmV3IEFycmF5KGNvdW50KTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNvdW50OyBpKyspIHtcbiAgICAgICAgbGlzdFtpXSA9IGl0ZW1DYWxsYmFjay5jYWxsKHRoaXMpO1xuICAgIH1cbiAgICByZXR1cm4gbGlzdDtcbn07XG5cblBhcnNlci5wcm90b3R5cGUucGFyc2VMaXN0MzIgPSBmdW5jdGlvbihjb3VudCwgaXRlbUNhbGxiYWNrKSB7XG4gICAgaWYgKCFpdGVtQ2FsbGJhY2spIHtcbiAgICAgICAgaXRlbUNhbGxiYWNrID0gY291bnQ7XG4gICAgICAgIGNvdW50ID0gdGhpcy5wYXJzZVVMb25nKCk7XG4gICAgfVxuICAgIHZhciBsaXN0ID0gbmV3IEFycmF5KGNvdW50KTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNvdW50OyBpKyspIHtcbiAgICAgICAgbGlzdFtpXSA9IGl0ZW1DYWxsYmFjay5jYWxsKHRoaXMpO1xuICAgIH1cbiAgICByZXR1cm4gbGlzdDtcbn07XG5cbi8qKlxuICogUGFyc2UgYSBsaXN0IG9mIHJlY29yZHMuXG4gKiBSZWNvcmQgY291bnQgaXMgb3B0aW9uYWwsIGlmIG9taXR0ZWQgaXQgaXMgcmVhZCBmcm9tIHRoZSBzdHJlYW0uXG4gKiBFeGFtcGxlIG9mIHJlY29yZERlc2NyaXB0aW9uOiB7IHNlcXVlbmNlSW5kZXg6IFBhcnNlci51U2hvcnQsIGxvb2t1cExpc3RJbmRleDogUGFyc2VyLnVTaG9ydCB9XG4gKi9cblBhcnNlci5wcm90b3R5cGUucGFyc2VSZWNvcmRMaXN0ID0gZnVuY3Rpb24oY291bnQsIHJlY29yZERlc2NyaXB0aW9uKSB7XG4gICAgLy8gSWYgdGhlIGNvdW50IGFyZ3VtZW50IGlzIGFic2VudCwgcmVhZCBpdCBpbiB0aGUgc3RyZWFtLlxuICAgIGlmICghcmVjb3JkRGVzY3JpcHRpb24pIHtcbiAgICAgICAgcmVjb3JkRGVzY3JpcHRpb24gPSBjb3VudDtcbiAgICAgICAgY291bnQgPSB0aGlzLnBhcnNlVVNob3J0KCk7XG4gICAgfVxuICAgIHZhciByZWNvcmRzID0gbmV3IEFycmF5KGNvdW50KTtcbiAgICB2YXIgZmllbGRzID0gT2JqZWN0LmtleXMocmVjb3JkRGVzY3JpcHRpb24pO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY291bnQ7IGkrKykge1xuICAgICAgICB2YXIgcmVjID0ge307XG4gICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgZmllbGRzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICB2YXIgZmllbGROYW1lID0gZmllbGRzW2pdO1xuICAgICAgICAgICAgdmFyIGZpZWxkVHlwZSA9IHJlY29yZERlc2NyaXB0aW9uW2ZpZWxkTmFtZV07XG4gICAgICAgICAgICByZWNbZmllbGROYW1lXSA9IGZpZWxkVHlwZS5jYWxsKHRoaXMpO1xuICAgICAgICB9XG4gICAgICAgIHJlY29yZHNbaV0gPSByZWM7XG4gICAgfVxuICAgIHJldHVybiByZWNvcmRzO1xufTtcblxuUGFyc2VyLnByb3RvdHlwZS5wYXJzZVJlY29yZExpc3QzMiA9IGZ1bmN0aW9uKGNvdW50LCByZWNvcmREZXNjcmlwdGlvbikge1xuICAgIC8vIElmIHRoZSBjb3VudCBhcmd1bWVudCBpcyBhYnNlbnQsIHJlYWQgaXQgaW4gdGhlIHN0cmVhbS5cbiAgICBpZiAoIXJlY29yZERlc2NyaXB0aW9uKSB7XG4gICAgICAgIHJlY29yZERlc2NyaXB0aW9uID0gY291bnQ7XG4gICAgICAgIGNvdW50ID0gdGhpcy5wYXJzZVVMb25nKCk7XG4gICAgfVxuICAgIHZhciByZWNvcmRzID0gbmV3IEFycmF5KGNvdW50KTtcbiAgICB2YXIgZmllbGRzID0gT2JqZWN0LmtleXMocmVjb3JkRGVzY3JpcHRpb24pO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY291bnQ7IGkrKykge1xuICAgICAgICB2YXIgcmVjID0ge307XG4gICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgZmllbGRzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICB2YXIgZmllbGROYW1lID0gZmllbGRzW2pdO1xuICAgICAgICAgICAgdmFyIGZpZWxkVHlwZSA9IHJlY29yZERlc2NyaXB0aW9uW2ZpZWxkTmFtZV07XG4gICAgICAgICAgICByZWNbZmllbGROYW1lXSA9IGZpZWxkVHlwZS5jYWxsKHRoaXMpO1xuICAgICAgICB9XG4gICAgICAgIHJlY29yZHNbaV0gPSByZWM7XG4gICAgfVxuICAgIHJldHVybiByZWNvcmRzO1xufTtcblxuLy8gUGFyc2UgYSBkYXRhIHN0cnVjdHVyZSBpbnRvIGFuIG9iamVjdFxuLy8gRXhhbXBsZSBvZiBkZXNjcmlwdGlvbjogeyBzZXF1ZW5jZUluZGV4OiBQYXJzZXIudVNob3J0LCBsb29rdXBMaXN0SW5kZXg6IFBhcnNlci51U2hvcnQgfVxuUGFyc2VyLnByb3RvdHlwZS5wYXJzZVN0cnVjdCA9IGZ1bmN0aW9uKGRlc2NyaXB0aW9uKSB7XG4gICAgaWYgKHR5cGVvZiBkZXNjcmlwdGlvbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICByZXR1cm4gZGVzY3JpcHRpb24uY2FsbCh0aGlzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgZmllbGRzID0gT2JqZWN0LmtleXMoZGVzY3JpcHRpb24pO1xuICAgICAgICB2YXIgc3RydWN0ID0ge307XG4gICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgZmllbGRzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICB2YXIgZmllbGROYW1lID0gZmllbGRzW2pdO1xuICAgICAgICAgICAgdmFyIGZpZWxkVHlwZSA9IGRlc2NyaXB0aW9uW2ZpZWxkTmFtZV07XG4gICAgICAgICAgICBzdHJ1Y3RbZmllbGROYW1lXSA9IGZpZWxkVHlwZS5jYWxsKHRoaXMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzdHJ1Y3Q7XG4gICAgfVxufTtcblxuLyoqXG4gKiBQYXJzZSBhIEdQT1MgdmFsdWVSZWNvcmRcbiAqIGh0dHBzOi8vZG9jcy5taWNyb3NvZnQuY29tL2VuLXVzL3R5cG9ncmFwaHkvb3BlbnR5cGUvc3BlYy9ncG9zI3ZhbHVlLXJlY29yZFxuICogdmFsdWVGb3JtYXQgaXMgb3B0aW9uYWwsIGlmIG9taXR0ZWQgaXQgaXMgcmVhZCBmcm9tIHRoZSBzdHJlYW0uXG4gKi9cblBhcnNlci5wcm90b3R5cGUucGFyc2VWYWx1ZVJlY29yZCA9IGZ1bmN0aW9uKHZhbHVlRm9ybWF0KSB7XG4gICAgaWYgKHZhbHVlRm9ybWF0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdmFsdWVGb3JtYXQgPSB0aGlzLnBhcnNlVVNob3J0KCk7XG4gICAgfVxuICAgIGlmICh2YWx1ZUZvcm1hdCA9PT0gMCkge1xuICAgICAgICAvLyB2YWx1ZUZvcm1hdDIgaW4ga2VybmluZyBwYWlycyBpcyBtb3N0IG9mdGVuIDBcbiAgICAgICAgLy8gaW4gdGhpcyBjYXNlIHJldHVybiB1bmRlZmluZWQgaW5zdGVhZCBvZiBhbiBlbXB0eSBvYmplY3QsIHRvIHNhdmUgc3BhY2VcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgdmFsdWVSZWNvcmQgPSB7fTtcblxuICAgIGlmICh2YWx1ZUZvcm1hdCAmIDB4MDAwMSkgeyB2YWx1ZVJlY29yZC54UGxhY2VtZW50ID0gdGhpcy5wYXJzZVNob3J0KCk7IH1cbiAgICBpZiAodmFsdWVGb3JtYXQgJiAweDAwMDIpIHsgdmFsdWVSZWNvcmQueVBsYWNlbWVudCA9IHRoaXMucGFyc2VTaG9ydCgpOyB9XG4gICAgaWYgKHZhbHVlRm9ybWF0ICYgMHgwMDA0KSB7IHZhbHVlUmVjb3JkLnhBZHZhbmNlID0gdGhpcy5wYXJzZVNob3J0KCk7IH1cbiAgICBpZiAodmFsdWVGb3JtYXQgJiAweDAwMDgpIHsgdmFsdWVSZWNvcmQueUFkdmFuY2UgPSB0aGlzLnBhcnNlU2hvcnQoKTsgfVxuXG4gICAgLy8gRGV2aWNlIHRhYmxlIChub24tdmFyaWFibGUgZm9udCkgLyBWYXJpYXRpb25JbmRleCB0YWJsZSAodmFyaWFibGUgZm9udCkgbm90IHN1cHBvcnRlZFxuICAgIC8vIGh0dHBzOi8vZG9jcy5taWNyb3NvZnQuY29tL2ZyLWZyL3R5cG9ncmFwaHkvb3BlbnR5cGUvc3BlYy9jaGFwdGVyMiNkZXZWYXJJZHhUYmxzXG4gICAgaWYgKHZhbHVlRm9ybWF0ICYgMHgwMDEwKSB7IHZhbHVlUmVjb3JkLnhQbGFEZXZpY2UgPSB1bmRlZmluZWQ7IHRoaXMucGFyc2VTaG9ydCgpOyB9XG4gICAgaWYgKHZhbHVlRm9ybWF0ICYgMHgwMDIwKSB7IHZhbHVlUmVjb3JkLnlQbGFEZXZpY2UgPSB1bmRlZmluZWQ7IHRoaXMucGFyc2VTaG9ydCgpOyB9XG4gICAgaWYgKHZhbHVlRm9ybWF0ICYgMHgwMDQwKSB7IHZhbHVlUmVjb3JkLnhBZHZEZXZpY2UgPSB1bmRlZmluZWQ7IHRoaXMucGFyc2VTaG9ydCgpOyB9XG4gICAgaWYgKHZhbHVlRm9ybWF0ICYgMHgwMDgwKSB7IHZhbHVlUmVjb3JkLnlBZHZEZXZpY2UgPSB1bmRlZmluZWQ7IHRoaXMucGFyc2VTaG9ydCgpOyB9XG5cbiAgICByZXR1cm4gdmFsdWVSZWNvcmQ7XG59O1xuXG4vKipcbiAqIFBhcnNlIGEgbGlzdCBvZiBHUE9TIHZhbHVlUmVjb3Jkc1xuICogaHR0cHM6Ly9kb2NzLm1pY3Jvc29mdC5jb20vZW4tdXMvdHlwb2dyYXBoeS9vcGVudHlwZS9zcGVjL2dwb3MjdmFsdWUtcmVjb3JkXG4gKiB2YWx1ZUZvcm1hdCBhbmQgdmFsdWVDb3VudCBhcmUgcmVhZCBmcm9tIHRoZSBzdHJlYW0uXG4gKi9cblBhcnNlci5wcm90b3R5cGUucGFyc2VWYWx1ZVJlY29yZExpc3QgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgdmFsdWVGb3JtYXQgPSB0aGlzLnBhcnNlVVNob3J0KCk7XG4gICAgdmFyIHZhbHVlQ291bnQgPSB0aGlzLnBhcnNlVVNob3J0KCk7XG4gICAgdmFyIHZhbHVlcyA9IG5ldyBBcnJheSh2YWx1ZUNvdW50KTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHZhbHVlQ291bnQ7IGkrKykge1xuICAgICAgICB2YWx1ZXNbaV0gPSB0aGlzLnBhcnNlVmFsdWVSZWNvcmQodmFsdWVGb3JtYXQpO1xuICAgIH1cbiAgICByZXR1cm4gdmFsdWVzO1xufTtcblxuUGFyc2VyLnByb3RvdHlwZS5wYXJzZVBvaW50ZXIgPSBmdW5jdGlvbihkZXNjcmlwdGlvbikge1xuICAgIHZhciBzdHJ1Y3RPZmZzZXQgPSB0aGlzLnBhcnNlT2Zmc2V0MTYoKTtcbiAgICBpZiAoc3RydWN0T2Zmc2V0ID4gMCkge1xuICAgICAgICAvLyBOVUxMIG9mZnNldCA9PiByZXR1cm4gdW5kZWZpbmVkXG4gICAgICAgIHJldHVybiBuZXcgUGFyc2VyKHRoaXMuZGF0YSwgdGhpcy5vZmZzZXQgKyBzdHJ1Y3RPZmZzZXQpLnBhcnNlU3RydWN0KGRlc2NyaXB0aW9uKTtcbiAgICB9XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbn07XG5cblBhcnNlci5wcm90b3R5cGUucGFyc2VQb2ludGVyMzIgPSBmdW5jdGlvbihkZXNjcmlwdGlvbikge1xuICAgIHZhciBzdHJ1Y3RPZmZzZXQgPSB0aGlzLnBhcnNlT2Zmc2V0MzIoKTtcbiAgICBpZiAoc3RydWN0T2Zmc2V0ID4gMCkge1xuICAgICAgICAvLyBOVUxMIG9mZnNldCA9PiByZXR1cm4gdW5kZWZpbmVkXG4gICAgICAgIHJldHVybiBuZXcgUGFyc2VyKHRoaXMuZGF0YSwgdGhpcy5vZmZzZXQgKyBzdHJ1Y3RPZmZzZXQpLnBhcnNlU3RydWN0KGRlc2NyaXB0aW9uKTtcbiAgICB9XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbn07XG5cbi8qKlxuICogUGFyc2UgYSBsaXN0IG9mIG9mZnNldHMgdG8gbGlzdHMgb2YgMTYtYml0IGludGVnZXJzLFxuICogb3IgYSBsaXN0IG9mIG9mZnNldHMgdG8gbGlzdHMgb2Ygb2Zmc2V0cyB0byBhbnkga2luZCBvZiBpdGVtcy5cbiAqIElmIGl0ZW1DYWxsYmFjayBpcyBub3QgcHJvdmlkZWQsIGEgbGlzdCBvZiBsaXN0IG9mIFVTaG9ydCBpcyBhc3N1bWVkLlxuICogSWYgcHJvdmlkZWQsIGl0ZW1DYWxsYmFjayBpcyBjYWxsZWQgb24gZWFjaCBpdGVtIGFuZCBtdXN0IHBhcnNlIHRoZSBpdGVtLlxuICogU2VlIGV4YW1wbGVzIGluIHRhYmxlcy9nc3ViLmpzXG4gKi9cblBhcnNlci5wcm90b3R5cGUucGFyc2VMaXN0T2ZMaXN0cyA9IGZ1bmN0aW9uKGl0ZW1DYWxsYmFjaykge1xuICAgIHZhciBvZmZzZXRzID0gdGhpcy5wYXJzZU9mZnNldDE2TGlzdCgpO1xuICAgIHZhciBjb3VudCA9IG9mZnNldHMubGVuZ3RoO1xuICAgIHZhciByZWxhdGl2ZU9mZnNldCA9IHRoaXMucmVsYXRpdmVPZmZzZXQ7XG4gICAgdmFyIGxpc3QgPSBuZXcgQXJyYXkoY291bnQpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY291bnQ7IGkrKykge1xuICAgICAgICB2YXIgc3RhcnQgPSBvZmZzZXRzW2ldO1xuICAgICAgICBpZiAoc3RhcnQgPT09IDApIHtcbiAgICAgICAgICAgIC8vIE5VTEwgb2Zmc2V0XG4gICAgICAgICAgICAvLyBBZGQgaSBhcyBvd25lZCBwcm9wZXJ0eSB0byBsaXN0LiBDb252ZW5pZW50IHdpdGggYXNzZXJ0LlxuICAgICAgICAgICAgbGlzdFtpXSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucmVsYXRpdmVPZmZzZXQgPSBzdGFydDtcbiAgICAgICAgaWYgKGl0ZW1DYWxsYmFjaykge1xuICAgICAgICAgICAgdmFyIHN1Yk9mZnNldHMgPSB0aGlzLnBhcnNlT2Zmc2V0MTZMaXN0KCk7XG4gICAgICAgICAgICB2YXIgc3ViTGlzdCA9IG5ldyBBcnJheShzdWJPZmZzZXRzLmxlbmd0aCk7XG4gICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHN1Yk9mZnNldHMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgICAgICB0aGlzLnJlbGF0aXZlT2Zmc2V0ID0gc3RhcnQgKyBzdWJPZmZzZXRzW2pdO1xuICAgICAgICAgICAgICAgIHN1Ykxpc3Rbal0gPSBpdGVtQ2FsbGJhY2suY2FsbCh0aGlzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxpc3RbaV0gPSBzdWJMaXN0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbGlzdFtpXSA9IHRoaXMucGFyc2VVU2hvcnRMaXN0KCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5yZWxhdGl2ZU9mZnNldCA9IHJlbGF0aXZlT2Zmc2V0O1xuICAgIHJldHVybiBsaXN0O1xufTtcblxuLy8vLy8gQ29tcGxleCB0YWJsZXMgcGFyc2luZyAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5cbi8vIFBhcnNlIGEgY292ZXJhZ2UgdGFibGUgaW4gYSBHU1VCLCBHUE9TIG9yIEdERUYgdGFibGUuXG4vLyBodHRwczovL3d3dy5taWNyb3NvZnQuY29tL3R5cG9ncmFwaHkvT1RTUEVDL2NoYXB0ZXIyLmh0bVxuLy8gcGFyc2VyLm9mZnNldCBtdXN0IHBvaW50IHRvIHRoZSBzdGFydCBvZiB0aGUgdGFibGUgY29udGFpbmluZyB0aGUgY292ZXJhZ2UuXG5QYXJzZXIucHJvdG90eXBlLnBhcnNlQ292ZXJhZ2UgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgc3RhcnRPZmZzZXQgPSB0aGlzLm9mZnNldCArIHRoaXMucmVsYXRpdmVPZmZzZXQ7XG4gICAgdmFyIGZvcm1hdCA9IHRoaXMucGFyc2VVU2hvcnQoKTtcbiAgICB2YXIgY291bnQgPSB0aGlzLnBhcnNlVVNob3J0KCk7XG4gICAgaWYgKGZvcm1hdCA9PT0gMSkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgZm9ybWF0OiAxLFxuICAgICAgICAgICAgZ2x5cGhzOiB0aGlzLnBhcnNlVVNob3J0TGlzdChjb3VudClcbiAgICAgICAgfTtcbiAgICB9IGVsc2UgaWYgKGZvcm1hdCA9PT0gMikge1xuICAgICAgICB2YXIgcmFuZ2VzID0gbmV3IEFycmF5KGNvdW50KTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb3VudDsgaSsrKSB7XG4gICAgICAgICAgICByYW5nZXNbaV0gPSB7XG4gICAgICAgICAgICAgICAgc3RhcnQ6IHRoaXMucGFyc2VVU2hvcnQoKSxcbiAgICAgICAgICAgICAgICBlbmQ6IHRoaXMucGFyc2VVU2hvcnQoKSxcbiAgICAgICAgICAgICAgICBpbmRleDogdGhpcy5wYXJzZVVTaG9ydCgpXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBmb3JtYXQ6IDIsXG4gICAgICAgICAgICByYW5nZXM6IHJhbmdlc1xuICAgICAgICB9O1xuICAgIH1cbiAgICB0aHJvdyBuZXcgRXJyb3IoJzB4JyArIHN0YXJ0T2Zmc2V0LnRvU3RyaW5nKDE2KSArICc6IENvdmVyYWdlIGZvcm1hdCBtdXN0IGJlIDEgb3IgMi4nKTtcbn07XG5cbi8vIFBhcnNlIGEgQ2xhc3MgRGVmaW5pdGlvbiBUYWJsZSBpbiBhIEdTVUIsIEdQT1Mgb3IgR0RFRiB0YWJsZS5cbi8vIGh0dHBzOi8vd3d3Lm1pY3Jvc29mdC5jb20vdHlwb2dyYXBoeS9PVFNQRUMvY2hhcHRlcjIuaHRtXG5QYXJzZXIucHJvdG90eXBlLnBhcnNlQ2xhc3NEZWYgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgc3RhcnRPZmZzZXQgPSB0aGlzLm9mZnNldCArIHRoaXMucmVsYXRpdmVPZmZzZXQ7XG4gICAgdmFyIGZvcm1hdCA9IHRoaXMucGFyc2VVU2hvcnQoKTtcbiAgICBpZiAoZm9ybWF0ID09PSAxKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBmb3JtYXQ6IDEsXG4gICAgICAgICAgICBzdGFydEdseXBoOiB0aGlzLnBhcnNlVVNob3J0KCksXG4gICAgICAgICAgICBjbGFzc2VzOiB0aGlzLnBhcnNlVVNob3J0TGlzdCgpXG4gICAgICAgIH07XG4gICAgfSBlbHNlIGlmIChmb3JtYXQgPT09IDIpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGZvcm1hdDogMixcbiAgICAgICAgICAgIHJhbmdlczogdGhpcy5wYXJzZVJlY29yZExpc3Qoe1xuICAgICAgICAgICAgICAgIHN0YXJ0OiBQYXJzZXIudVNob3J0LFxuICAgICAgICAgICAgICAgIGVuZDogUGFyc2VyLnVTaG9ydCxcbiAgICAgICAgICAgICAgICBjbGFzc0lkOiBQYXJzZXIudVNob3J0XG4gICAgICAgICAgICB9KVxuICAgICAgICB9O1xuICAgIH1cbiAgICB0aHJvdyBuZXcgRXJyb3IoJzB4JyArIHN0YXJ0T2Zmc2V0LnRvU3RyaW5nKDE2KSArICc6IENsYXNzRGVmIGZvcm1hdCBtdXN0IGJlIDEgb3IgMi4nKTtcbn07XG5cbi8vLy8vIFN0YXRpYyBtZXRob2RzIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBUaGVzZSBjb252ZW5pZW5jZSBtZXRob2RzIGNhbiBiZSB1c2VkIGFzIGNhbGxiYWNrcyBhbmQgc2hvdWxkIGJlIGNhbGxlZCB3aXRoIFwidGhpc1wiIGNvbnRleHQgc2V0IHRvIGEgUGFyc2VyIGluc3RhbmNlLlxuXG5QYXJzZXIubGlzdCA9IGZ1bmN0aW9uKGNvdW50LCBpdGVtQ2FsbGJhY2spIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnBhcnNlTGlzdChjb3VudCwgaXRlbUNhbGxiYWNrKTtcbiAgICB9O1xufTtcblxuUGFyc2VyLmxpc3QzMiA9IGZ1bmN0aW9uKGNvdW50LCBpdGVtQ2FsbGJhY2spIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnBhcnNlTGlzdDMyKGNvdW50LCBpdGVtQ2FsbGJhY2spO1xuICAgIH07XG59O1xuXG5QYXJzZXIucmVjb3JkTGlzdCA9IGZ1bmN0aW9uKGNvdW50LCByZWNvcmREZXNjcmlwdGlvbikge1xuICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VSZWNvcmRMaXN0KGNvdW50LCByZWNvcmREZXNjcmlwdGlvbik7XG4gICAgfTtcbn07XG5cblBhcnNlci5yZWNvcmRMaXN0MzIgPSBmdW5jdGlvbihjb3VudCwgcmVjb3JkRGVzY3JpcHRpb24pIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnBhcnNlUmVjb3JkTGlzdDMyKGNvdW50LCByZWNvcmREZXNjcmlwdGlvbik7XG4gICAgfTtcbn07XG5cblBhcnNlci5wb2ludGVyID0gZnVuY3Rpb24oZGVzY3JpcHRpb24pIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnBhcnNlUG9pbnRlcihkZXNjcmlwdGlvbik7XG4gICAgfTtcbn07XG5cblBhcnNlci5wb2ludGVyMzIgPSBmdW5jdGlvbihkZXNjcmlwdGlvbikge1xuICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VQb2ludGVyMzIoZGVzY3JpcHRpb24pO1xuICAgIH07XG59O1xuXG5QYXJzZXIudGFnID0gUGFyc2VyLnByb3RvdHlwZS5wYXJzZVRhZztcblBhcnNlci5ieXRlID0gUGFyc2VyLnByb3RvdHlwZS5wYXJzZUJ5dGU7XG5QYXJzZXIudVNob3J0ID0gUGFyc2VyLm9mZnNldDE2ID0gUGFyc2VyLnByb3RvdHlwZS5wYXJzZVVTaG9ydDtcblBhcnNlci51U2hvcnRMaXN0ID0gUGFyc2VyLnByb3RvdHlwZS5wYXJzZVVTaG9ydExpc3Q7XG5QYXJzZXIudUxvbmcgPSBQYXJzZXIub2Zmc2V0MzIgPSBQYXJzZXIucHJvdG90eXBlLnBhcnNlVUxvbmc7XG5QYXJzZXIudUxvbmdMaXN0ID0gUGFyc2VyLnByb3RvdHlwZS5wYXJzZVVMb25nTGlzdDtcblBhcnNlci5zdHJ1Y3QgPSBQYXJzZXIucHJvdG90eXBlLnBhcnNlU3RydWN0O1xuUGFyc2VyLmNvdmVyYWdlID0gUGFyc2VyLnByb3RvdHlwZS5wYXJzZUNvdmVyYWdlO1xuUGFyc2VyLmNsYXNzRGVmID0gUGFyc2VyLnByb3RvdHlwZS5wYXJzZUNsYXNzRGVmO1xuXG4vLy8vLyBTY3JpcHQsIEZlYXR1cmUsIExvb2t1cCBsaXN0cyAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gaHR0cHM6Ly93d3cubWljcm9zb2Z0LmNvbS90eXBvZ3JhcGh5L09UU1BFQy9jaGFwdGVyMi5odG1cblxudmFyIGxhbmdTeXNUYWJsZSA9IHtcbiAgICByZXNlcnZlZDogUGFyc2VyLnVTaG9ydCxcbiAgICByZXFGZWF0dXJlSW5kZXg6IFBhcnNlci51U2hvcnQsXG4gICAgZmVhdHVyZUluZGV4ZXM6IFBhcnNlci51U2hvcnRMaXN0XG59O1xuXG5QYXJzZXIucHJvdG90eXBlLnBhcnNlU2NyaXB0TGlzdCA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLnBhcnNlUG9pbnRlcihQYXJzZXIucmVjb3JkTGlzdCh7XG4gICAgICAgIHRhZzogUGFyc2VyLnRhZyxcbiAgICAgICAgc2NyaXB0OiBQYXJzZXIucG9pbnRlcih7XG4gICAgICAgICAgICBkZWZhdWx0TGFuZ1N5czogUGFyc2VyLnBvaW50ZXIobGFuZ1N5c1RhYmxlKSxcbiAgICAgICAgICAgIGxhbmdTeXNSZWNvcmRzOiBQYXJzZXIucmVjb3JkTGlzdCh7XG4gICAgICAgICAgICAgICAgdGFnOiBQYXJzZXIudGFnLFxuICAgICAgICAgICAgICAgIGxhbmdTeXM6IFBhcnNlci5wb2ludGVyKGxhbmdTeXNUYWJsZSlcbiAgICAgICAgICAgIH0pXG4gICAgICAgIH0pXG4gICAgfSkpIHx8IFtdO1xufTtcblxuUGFyc2VyLnByb3RvdHlwZS5wYXJzZUZlYXR1cmVMaXN0ID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMucGFyc2VQb2ludGVyKFBhcnNlci5yZWNvcmRMaXN0KHtcbiAgICAgICAgdGFnOiBQYXJzZXIudGFnLFxuICAgICAgICBmZWF0dXJlOiBQYXJzZXIucG9pbnRlcih7XG4gICAgICAgICAgICBmZWF0dXJlUGFyYW1zOiBQYXJzZXIub2Zmc2V0MTYsXG4gICAgICAgICAgICBsb29rdXBMaXN0SW5kZXhlczogUGFyc2VyLnVTaG9ydExpc3RcbiAgICAgICAgfSlcbiAgICB9KSkgfHwgW107XG59O1xuXG5QYXJzZXIucHJvdG90eXBlLnBhcnNlTG9va3VwTGlzdCA9IGZ1bmN0aW9uKGxvb2t1cFRhYmxlUGFyc2Vycykge1xuICAgIHJldHVybiB0aGlzLnBhcnNlUG9pbnRlcihQYXJzZXIubGlzdChQYXJzZXIucG9pbnRlcihmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGxvb2t1cFR5cGUgPSB0aGlzLnBhcnNlVVNob3J0KCk7XG4gICAgICAgIGNoZWNrLmFyZ3VtZW50KDEgPD0gbG9va3VwVHlwZSAmJiBsb29rdXBUeXBlIDw9IDksICdHUE9TL0dTVUIgbG9va3VwIHR5cGUgJyArIGxvb2t1cFR5cGUgKyAnIHVua25vd24uJyk7XG4gICAgICAgIHZhciBsb29rdXBGbGFnID0gdGhpcy5wYXJzZVVTaG9ydCgpO1xuICAgICAgICB2YXIgdXNlTWFya0ZpbHRlcmluZ1NldCA9IGxvb2t1cEZsYWcgJiAweDEwO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgbG9va3VwVHlwZTogbG9va3VwVHlwZSxcbiAgICAgICAgICAgIGxvb2t1cEZsYWc6IGxvb2t1cEZsYWcsXG4gICAgICAgICAgICBzdWJ0YWJsZXM6IHRoaXMucGFyc2VMaXN0KFBhcnNlci5wb2ludGVyKGxvb2t1cFRhYmxlUGFyc2Vyc1tsb29rdXBUeXBlXSkpLFxuICAgICAgICAgICAgbWFya0ZpbHRlcmluZ1NldDogdXNlTWFya0ZpbHRlcmluZ1NldCA/IHRoaXMucGFyc2VVU2hvcnQoKSA6IHVuZGVmaW5lZFxuICAgICAgICB9O1xuICAgIH0pKSkgfHwgW107XG59O1xuXG5QYXJzZXIucHJvdG90eXBlLnBhcnNlRmVhdHVyZVZhcmlhdGlvbnNMaXN0ID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMucGFyc2VQb2ludGVyMzIoZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBtYWpvclZlcnNpb24gPSB0aGlzLnBhcnNlVVNob3J0KCk7XG4gICAgICAgIHZhciBtaW5vclZlcnNpb24gPSB0aGlzLnBhcnNlVVNob3J0KCk7XG4gICAgICAgIGNoZWNrLmFyZ3VtZW50KG1ham9yVmVyc2lvbiA9PT0gMSAmJiBtaW5vclZlcnNpb24gPCAxLCAnR1BPUy9HU1VCIGZlYXR1cmUgdmFyaWF0aW9ucyB0YWJsZSB1bmtub3duLicpO1xuICAgICAgICB2YXIgZmVhdHVyZVZhcmlhdGlvbnMgPSB0aGlzLnBhcnNlUmVjb3JkTGlzdDMyKHtcbiAgICAgICAgICAgIGNvbmRpdGlvblNldE9mZnNldDogUGFyc2VyLm9mZnNldDMyLFxuICAgICAgICAgICAgZmVhdHVyZVRhYmxlU3Vic3RpdHV0aW9uT2Zmc2V0OiBQYXJzZXIub2Zmc2V0MzJcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBmZWF0dXJlVmFyaWF0aW9ucztcbiAgICB9KSB8fCBbXTtcbn07XG5cbnZhciBwYXJzZSA9IHtcbiAgICBnZXRCeXRlOiBnZXRCeXRlLFxuICAgIGdldENhcmQ4OiBnZXRCeXRlLFxuICAgIGdldFVTaG9ydDogZ2V0VVNob3J0LFxuICAgIGdldENhcmQxNjogZ2V0VVNob3J0LFxuICAgIGdldFNob3J0OiBnZXRTaG9ydCxcbiAgICBnZXRVTG9uZzogZ2V0VUxvbmcsXG4gICAgZ2V0Rml4ZWQ6IGdldEZpeGVkLFxuICAgIGdldFRhZzogZ2V0VGFnLFxuICAgIGdldE9mZnNldDogZ2V0T2Zmc2V0LFxuICAgIGdldEJ5dGVzOiBnZXRCeXRlcyxcbiAgICBieXRlc1RvU3RyaW5nOiBieXRlc1RvU3RyaW5nLFxuICAgIFBhcnNlcjogUGFyc2VyLFxufTtcblxuLy8gVGhlIGBjbWFwYCB0YWJsZSBzdG9yZXMgdGhlIG1hcHBpbmdzIGZyb20gY2hhcmFjdGVycyB0byBnbHlwaHMuXG5cbmZ1bmN0aW9uIHBhcnNlQ21hcFRhYmxlRm9ybWF0MTIoY21hcCwgcCkge1xuICAgIC8vU2tpcCByZXNlcnZlZC5cbiAgICBwLnBhcnNlVVNob3J0KCk7XG5cbiAgICAvLyBMZW5ndGggaW4gYnl0ZXMgb2YgdGhlIHN1Yi10YWJsZXMuXG4gICAgY21hcC5sZW5ndGggPSBwLnBhcnNlVUxvbmcoKTtcbiAgICBjbWFwLmxhbmd1YWdlID0gcC5wYXJzZVVMb25nKCk7XG5cbiAgICB2YXIgZ3JvdXBDb3VudDtcbiAgICBjbWFwLmdyb3VwQ291bnQgPSBncm91cENvdW50ID0gcC5wYXJzZVVMb25nKCk7XG4gICAgY21hcC5nbHlwaEluZGV4TWFwID0ge307XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGdyb3VwQ291bnQ7IGkgKz0gMSkge1xuICAgICAgICB2YXIgc3RhcnRDaGFyQ29kZSA9IHAucGFyc2VVTG9uZygpO1xuICAgICAgICB2YXIgZW5kQ2hhckNvZGUgPSBwLnBhcnNlVUxvbmcoKTtcbiAgICAgICAgdmFyIHN0YXJ0R2x5cGhJZCA9IHAucGFyc2VVTG9uZygpO1xuXG4gICAgICAgIGZvciAodmFyIGMgPSBzdGFydENoYXJDb2RlOyBjIDw9IGVuZENoYXJDb2RlOyBjICs9IDEpIHtcbiAgICAgICAgICAgIGNtYXAuZ2x5cGhJbmRleE1hcFtjXSA9IHN0YXJ0R2x5cGhJZDtcbiAgICAgICAgICAgIHN0YXJ0R2x5cGhJZCsrO1xuICAgICAgICB9XG4gICAgfVxufVxuXG5mdW5jdGlvbiBwYXJzZUNtYXBUYWJsZUZvcm1hdDQoY21hcCwgcCwgZGF0YSwgc3RhcnQsIG9mZnNldCkge1xuICAgIC8vIExlbmd0aCBpbiBieXRlcyBvZiB0aGUgc3ViLXRhYmxlcy5cbiAgICBjbWFwLmxlbmd0aCA9IHAucGFyc2VVU2hvcnQoKTtcbiAgICBjbWFwLmxhbmd1YWdlID0gcC5wYXJzZVVTaG9ydCgpO1xuXG4gICAgLy8gc2VnQ291bnQgaXMgc3RvcmVkIHggMi5cbiAgICB2YXIgc2VnQ291bnQ7XG4gICAgY21hcC5zZWdDb3VudCA9IHNlZ0NvdW50ID0gcC5wYXJzZVVTaG9ydCgpID4+IDE7XG5cbiAgICAvLyBTa2lwIHNlYXJjaFJhbmdlLCBlbnRyeVNlbGVjdG9yLCByYW5nZVNoaWZ0LlxuICAgIHAuc2tpcCgndVNob3J0JywgMyk7XG5cbiAgICAvLyBUaGUgXCJ1bnJvbGxlZFwiIG1hcHBpbmcgZnJvbSBjaGFyYWN0ZXIgY29kZXMgdG8gZ2x5cGggaW5kaWNlcy5cbiAgICBjbWFwLmdseXBoSW5kZXhNYXAgPSB7fTtcbiAgICB2YXIgZW5kQ291bnRQYXJzZXIgPSBuZXcgcGFyc2UuUGFyc2VyKGRhdGEsIHN0YXJ0ICsgb2Zmc2V0ICsgMTQpO1xuICAgIHZhciBzdGFydENvdW50UGFyc2VyID0gbmV3IHBhcnNlLlBhcnNlcihkYXRhLCBzdGFydCArIG9mZnNldCArIDE2ICsgc2VnQ291bnQgKiAyKTtcbiAgICB2YXIgaWREZWx0YVBhcnNlciA9IG5ldyBwYXJzZS5QYXJzZXIoZGF0YSwgc3RhcnQgKyBvZmZzZXQgKyAxNiArIHNlZ0NvdW50ICogNCk7XG4gICAgdmFyIGlkUmFuZ2VPZmZzZXRQYXJzZXIgPSBuZXcgcGFyc2UuUGFyc2VyKGRhdGEsIHN0YXJ0ICsgb2Zmc2V0ICsgMTYgKyBzZWdDb3VudCAqIDYpO1xuICAgIHZhciBnbHlwaEluZGV4T2Zmc2V0ID0gc3RhcnQgKyBvZmZzZXQgKyAxNiArIHNlZ0NvdW50ICogODtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNlZ0NvdW50IC0gMTsgaSArPSAxKSB7XG4gICAgICAgIHZhciBnbHlwaEluZGV4ID0gKHZvaWQgMCk7XG4gICAgICAgIHZhciBlbmRDb3VudCA9IGVuZENvdW50UGFyc2VyLnBhcnNlVVNob3J0KCk7XG4gICAgICAgIHZhciBzdGFydENvdW50ID0gc3RhcnRDb3VudFBhcnNlci5wYXJzZVVTaG9ydCgpO1xuICAgICAgICB2YXIgaWREZWx0YSA9IGlkRGVsdGFQYXJzZXIucGFyc2VTaG9ydCgpO1xuICAgICAgICB2YXIgaWRSYW5nZU9mZnNldCA9IGlkUmFuZ2VPZmZzZXRQYXJzZXIucGFyc2VVU2hvcnQoKTtcbiAgICAgICAgZm9yICh2YXIgYyA9IHN0YXJ0Q291bnQ7IGMgPD0gZW5kQ291bnQ7IGMgKz0gMSkge1xuICAgICAgICAgICAgaWYgKGlkUmFuZ2VPZmZzZXQgIT09IDApIHtcbiAgICAgICAgICAgICAgICAvLyBUaGUgaWRSYW5nZU9mZnNldCBpcyByZWxhdGl2ZSB0byB0aGUgY3VycmVudCBwb3NpdGlvbiBpbiB0aGUgaWRSYW5nZU9mZnNldCBhcnJheS5cbiAgICAgICAgICAgICAgICAvLyBUYWtlIHRoZSBjdXJyZW50IG9mZnNldCBpbiB0aGUgaWRSYW5nZU9mZnNldCBhcnJheS5cbiAgICAgICAgICAgICAgICBnbHlwaEluZGV4T2Zmc2V0ID0gKGlkUmFuZ2VPZmZzZXRQYXJzZXIub2Zmc2V0ICsgaWRSYW5nZU9mZnNldFBhcnNlci5yZWxhdGl2ZU9mZnNldCAtIDIpO1xuXG4gICAgICAgICAgICAgICAgLy8gQWRkIHRoZSB2YWx1ZSBvZiB0aGUgaWRSYW5nZU9mZnNldCwgd2hpY2ggd2lsbCBtb3ZlIHVzIGludG8gdGhlIGdseXBoSW5kZXggYXJyYXkuXG4gICAgICAgICAgICAgICAgZ2x5cGhJbmRleE9mZnNldCArPSBpZFJhbmdlT2Zmc2V0O1xuXG4gICAgICAgICAgICAgICAgLy8gVGhlbiBhZGQgdGhlIGNoYXJhY3RlciBpbmRleCBvZiB0aGUgY3VycmVudCBzZWdtZW50LCBtdWx0aXBsaWVkIGJ5IDIgZm9yIFVTSE9SVHMuXG4gICAgICAgICAgICAgICAgZ2x5cGhJbmRleE9mZnNldCArPSAoYyAtIHN0YXJ0Q291bnQpICogMjtcbiAgICAgICAgICAgICAgICBnbHlwaEluZGV4ID0gcGFyc2UuZ2V0VVNob3J0KGRhdGEsIGdseXBoSW5kZXhPZmZzZXQpO1xuICAgICAgICAgICAgICAgIGlmIChnbHlwaEluZGV4ICE9PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGdseXBoSW5kZXggPSAoZ2x5cGhJbmRleCArIGlkRGVsdGEpICYgMHhGRkZGO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZ2x5cGhJbmRleCA9IChjICsgaWREZWx0YSkgJiAweEZGRkY7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNtYXAuZ2x5cGhJbmRleE1hcFtjXSA9IGdseXBoSW5kZXg7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbi8vIFBhcnNlIHRoZSBgY21hcGAgdGFibGUuIFRoaXMgdGFibGUgc3RvcmVzIHRoZSBtYXBwaW5ncyBmcm9tIGNoYXJhY3RlcnMgdG8gZ2x5cGhzLlxuLy8gVGhlcmUgYXJlIG1hbnkgYXZhaWxhYmxlIGZvcm1hdHMsIGJ1dCB3ZSBvbmx5IHN1cHBvcnQgdGhlIFdpbmRvd3MgZm9ybWF0IDQgYW5kIDEyLlxuLy8gVGhpcyBmdW5jdGlvbiByZXR1cm5zIGEgYENtYXBFbmNvZGluZ2Agb2JqZWN0IG9yIG51bGwgaWYgbm8gc3VwcG9ydGVkIGZvcm1hdCBjb3VsZCBiZSBmb3VuZC5cbmZ1bmN0aW9uIHBhcnNlQ21hcFRhYmxlKGRhdGEsIHN0YXJ0KSB7XG4gICAgdmFyIGNtYXAgPSB7fTtcbiAgICBjbWFwLnZlcnNpb24gPSBwYXJzZS5nZXRVU2hvcnQoZGF0YSwgc3RhcnQpO1xuICAgIGNoZWNrLmFyZ3VtZW50KGNtYXAudmVyc2lvbiA9PT0gMCwgJ2NtYXAgdGFibGUgdmVyc2lvbiBzaG91bGQgYmUgMC4nKTtcblxuICAgIC8vIFRoZSBjbWFwIHRhYmxlIGNhbiBjb250YWluIG1hbnkgc3ViLXRhYmxlcywgZWFjaCB3aXRoIHRoZWlyIG93biBmb3JtYXQuXG4gICAgLy8gV2UncmUgb25seSBpbnRlcmVzdGVkIGluIGEgXCJwbGF0Zm9ybSAwXCIgKFVuaWNvZGUgZm9ybWF0KSBhbmQgXCJwbGF0Zm9ybSAzXCIgKFdpbmRvd3MgZm9ybWF0KSB0YWJsZS5cbiAgICBjbWFwLm51bVRhYmxlcyA9IHBhcnNlLmdldFVTaG9ydChkYXRhLCBzdGFydCArIDIpO1xuICAgIHZhciBvZmZzZXQgPSAtMTtcbiAgICBmb3IgKHZhciBpID0gY21hcC5udW1UYWJsZXMgLSAxOyBpID49IDA7IGkgLT0gMSkge1xuICAgICAgICB2YXIgcGxhdGZvcm1JZCA9IHBhcnNlLmdldFVTaG9ydChkYXRhLCBzdGFydCArIDQgKyAoaSAqIDgpKTtcbiAgICAgICAgdmFyIGVuY29kaW5nSWQgPSBwYXJzZS5nZXRVU2hvcnQoZGF0YSwgc3RhcnQgKyA0ICsgKGkgKiA4KSArIDIpO1xuICAgICAgICBpZiAoKHBsYXRmb3JtSWQgPT09IDMgJiYgKGVuY29kaW5nSWQgPT09IDAgfHwgZW5jb2RpbmdJZCA9PT0gMSB8fCBlbmNvZGluZ0lkID09PSAxMCkpIHx8XG4gICAgICAgICAgICAocGxhdGZvcm1JZCA9PT0gMCAmJiAoZW5jb2RpbmdJZCA9PT0gMCB8fCBlbmNvZGluZ0lkID09PSAxIHx8IGVuY29kaW5nSWQgPT09IDIgfHwgZW5jb2RpbmdJZCA9PT0gMyB8fCBlbmNvZGluZ0lkID09PSA0KSkpIHtcbiAgICAgICAgICAgIG9mZnNldCA9IHBhcnNlLmdldFVMb25nKGRhdGEsIHN0YXJ0ICsgNCArIChpICogOCkgKyA0KTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgaWYgKG9mZnNldCA9PT0gLTEpIHtcbiAgICAgICAgLy8gVGhlcmUgaXMgbm8gY21hcCB0YWJsZSBpbiB0aGUgZm9udCB0aGF0IHdlIHN1cHBvcnQuXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignTm8gdmFsaWQgY21hcCBzdWItdGFibGVzIGZvdW5kLicpO1xuICAgIH1cblxuICAgIHZhciBwID0gbmV3IHBhcnNlLlBhcnNlcihkYXRhLCBzdGFydCArIG9mZnNldCk7XG4gICAgY21hcC5mb3JtYXQgPSBwLnBhcnNlVVNob3J0KCk7XG5cbiAgICBpZiAoY21hcC5mb3JtYXQgPT09IDEyKSB7XG4gICAgICAgIHBhcnNlQ21hcFRhYmxlRm9ybWF0MTIoY21hcCwgcCk7XG4gICAgfSBlbHNlIGlmIChjbWFwLmZvcm1hdCA9PT0gNCkge1xuICAgICAgICBwYXJzZUNtYXBUYWJsZUZvcm1hdDQoY21hcCwgcCwgZGF0YSwgc3RhcnQsIG9mZnNldCk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdPbmx5IGZvcm1hdCA0IGFuZCAxMiBjbWFwIHRhYmxlcyBhcmUgc3VwcG9ydGVkIChmb3VuZCBmb3JtYXQgJyArIGNtYXAuZm9ybWF0ICsgJykuJyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGNtYXA7XG59XG5cbmZ1bmN0aW9uIGFkZFNlZ21lbnQodCwgY29kZSwgZ2x5cGhJbmRleCkge1xuICAgIHQuc2VnbWVudHMucHVzaCh7XG4gICAgICAgIGVuZDogY29kZSxcbiAgICAgICAgc3RhcnQ6IGNvZGUsXG4gICAgICAgIGRlbHRhOiAtKGNvZGUgLSBnbHlwaEluZGV4KSxcbiAgICAgICAgb2Zmc2V0OiAwLFxuICAgICAgICBnbHlwaEluZGV4OiBnbHlwaEluZGV4XG4gICAgfSk7XG59XG5cbmZ1bmN0aW9uIGFkZFRlcm1pbmF0b3JTZWdtZW50KHQpIHtcbiAgICB0LnNlZ21lbnRzLnB1c2goe1xuICAgICAgICBlbmQ6IDB4RkZGRixcbiAgICAgICAgc3RhcnQ6IDB4RkZGRixcbiAgICAgICAgZGVsdGE6IDEsXG4gICAgICAgIG9mZnNldDogMFxuICAgIH0pO1xufVxuXG4vLyBNYWtlIGNtYXAgdGFibGUsIGZvcm1hdCA0IGJ5IGRlZmF1bHQsIDEyIGlmIG5lZWRlZCBvbmx5XG5mdW5jdGlvbiBtYWtlQ21hcFRhYmxlKGdseXBocykge1xuICAgIC8vIFBsYW4gMCBpcyB0aGUgYmFzZSBVbmljb2RlIFBsYW4gYnV0IGVtb2ppcywgZm9yIGV4YW1wbGUgYXJlIG9uIGFub3RoZXIgcGxhbiwgYW5kIG5lZWRzIGNtYXAgMTIgZm9ybWF0ICh3aXRoIDMyYml0KVxuICAgIHZhciBpc1BsYW4wT25seSA9IHRydWU7XG4gICAgdmFyIGk7XG5cbiAgICAvLyBDaGVjayBpZiB3ZSBuZWVkIHRvIGFkZCBjbWFwIGZvcm1hdCAxMiBvciBpZiBmb3JtYXQgNCBvbmx5IGlzIGZpbmVcbiAgICBmb3IgKGkgPSBnbHlwaHMubGVuZ3RoIC0gMTsgaSA+IDA7IGkgLT0gMSkge1xuICAgICAgICB2YXIgZyA9IGdseXBocy5nZXQoaSk7XG4gICAgICAgIGlmIChnLnVuaWNvZGUgPiA2NTUzNSkge1xuICAgICAgICAgICAgY29uc29sZS5sb2coJ0FkZGluZyBDTUFQIGZvcm1hdCAxMiAobmVlZGVkISknKTtcbiAgICAgICAgICAgIGlzUGxhbjBPbmx5ID0gZmFsc2U7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHZhciBjbWFwVGFibGUgPSBbXG4gICAgICAgIHtuYW1lOiAndmVyc2lvbicsIHR5cGU6ICdVU0hPUlQnLCB2YWx1ZTogMH0sXG4gICAgICAgIHtuYW1lOiAnbnVtVGFibGVzJywgdHlwZTogJ1VTSE9SVCcsIHZhbHVlOiBpc1BsYW4wT25seSA/IDEgOiAyfSxcblxuICAgICAgICAvLyBDTUFQIDQgaGVhZGVyXG4gICAgICAgIHtuYW1lOiAncGxhdGZvcm1JRCcsIHR5cGU6ICdVU0hPUlQnLCB2YWx1ZTogM30sXG4gICAgICAgIHtuYW1lOiAnZW5jb2RpbmdJRCcsIHR5cGU6ICdVU0hPUlQnLCB2YWx1ZTogMX0sXG4gICAgICAgIHtuYW1lOiAnb2Zmc2V0JywgdHlwZTogJ1VMT05HJywgdmFsdWU6IGlzUGxhbjBPbmx5ID8gMTIgOiAoMTIgKyA4KX1cbiAgICBdO1xuXG4gICAgaWYgKCFpc1BsYW4wT25seSlcbiAgICAgICAgeyBjbWFwVGFibGUgPSBjbWFwVGFibGUuY29uY2F0KFtcbiAgICAgICAgICAgIC8vIENNQVAgMTIgaGVhZGVyXG4gICAgICAgICAgICB7bmFtZTogJ2NtYXAxMlBsYXRmb3JtSUQnLCB0eXBlOiAnVVNIT1JUJywgdmFsdWU6IDN9LCAvLyBXZSBlbmNvZGUgb25seSBmb3IgUGxhdGZvcm1JRCA9IDMgKFdpbmRvd3MpIGJlY2F1c2UgaXQgaXMgc3VwcG9ydGVkIGV2ZXJ5d2hlcmVcbiAgICAgICAgICAgIHtuYW1lOiAnY21hcDEyRW5jb2RpbmdJRCcsIHR5cGU6ICdVU0hPUlQnLCB2YWx1ZTogMTB9LFxuICAgICAgICAgICAge25hbWU6ICdjbWFwMTJPZmZzZXQnLCB0eXBlOiAnVUxPTkcnLCB2YWx1ZTogMH1cbiAgICAgICAgXSk7IH1cblxuICAgIGNtYXBUYWJsZSA9IGNtYXBUYWJsZS5jb25jYXQoW1xuICAgICAgICAvLyBDTUFQIDQgU3VidGFibGVcbiAgICAgICAge25hbWU6ICdmb3JtYXQnLCB0eXBlOiAnVVNIT1JUJywgdmFsdWU6IDR9LFxuICAgICAgICB7bmFtZTogJ2NtYXA0TGVuZ3RoJywgdHlwZTogJ1VTSE9SVCcsIHZhbHVlOiAwfSxcbiAgICAgICAge25hbWU6ICdsYW5ndWFnZScsIHR5cGU6ICdVU0hPUlQnLCB2YWx1ZTogMH0sXG4gICAgICAgIHtuYW1lOiAnc2VnQ291bnRYMicsIHR5cGU6ICdVU0hPUlQnLCB2YWx1ZTogMH0sXG4gICAgICAgIHtuYW1lOiAnc2VhcmNoUmFuZ2UnLCB0eXBlOiAnVVNIT1JUJywgdmFsdWU6IDB9LFxuICAgICAgICB7bmFtZTogJ2VudHJ5U2VsZWN0b3InLCB0eXBlOiAnVVNIT1JUJywgdmFsdWU6IDB9LFxuICAgICAgICB7bmFtZTogJ3JhbmdlU2hpZnQnLCB0eXBlOiAnVVNIT1JUJywgdmFsdWU6IDB9XG4gICAgXSk7XG5cbiAgICB2YXIgdCA9IG5ldyB0YWJsZS5UYWJsZSgnY21hcCcsIGNtYXBUYWJsZSk7XG5cbiAgICB0LnNlZ21lbnRzID0gW107XG4gICAgZm9yIChpID0gMDsgaSA8IGdseXBocy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICB2YXIgZ2x5cGggPSBnbHlwaHMuZ2V0KGkpO1xuICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGdseXBoLnVuaWNvZGVzLmxlbmd0aDsgaiArPSAxKSB7XG4gICAgICAgICAgICBhZGRTZWdtZW50KHQsIGdseXBoLnVuaWNvZGVzW2pdLCBpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHQuc2VnbWVudHMgPSB0LnNlZ21lbnRzLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgICAgICAgIHJldHVybiBhLnN0YXJ0IC0gYi5zdGFydDtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgYWRkVGVybWluYXRvclNlZ21lbnQodCk7XG5cbiAgICB2YXIgc2VnQ291bnQgPSB0LnNlZ21lbnRzLmxlbmd0aDtcbiAgICB2YXIgc2VnQ291bnRUb1JlbW92ZSA9IDA7XG5cbiAgICAvLyBDTUFQIDRcbiAgICAvLyBTZXQgdXAgcGFyYWxsZWwgc2VnbWVudCBhcnJheXMuXG4gICAgdmFyIGVuZENvdW50cyA9IFtdO1xuICAgIHZhciBzdGFydENvdW50cyA9IFtdO1xuICAgIHZhciBpZERlbHRhcyA9IFtdO1xuICAgIHZhciBpZFJhbmdlT2Zmc2V0cyA9IFtdO1xuICAgIHZhciBnbHlwaElkcyA9IFtdO1xuXG4gICAgLy8gQ01BUCAxMlxuICAgIHZhciBjbWFwMTJHcm91cHMgPSBbXTtcblxuICAgIC8vIFJlbWluZGVyIHRoaXMgbG9vcCBpcyBub3QgZm9sbG93aW5nIHRoZSBzcGVjaWZpY2F0aW9uIGF0IDEwMCVcbiAgICAvLyBUaGUgc3BlY2lmaWNhdGlvbiAtPiBmaW5kIHN1aXRlcyBvZiBjaGFyYWN0ZXJzIGFuZCBtYWtlIGEgZ3JvdXBcbiAgICAvLyBIZXJlIHdlJ3JlIGRvaW5nIG9uZSBncm91cCBmb3IgZWFjaCBsZXR0ZXJcbiAgICAvLyBEb2luZyBhcyB0aGUgc3BlYyBjYW4gc2F2ZSA4IHRpbWVzIChvciBtb3JlKSBzcGFjZVxuICAgIGZvciAoaSA9IDA7IGkgPCBzZWdDb3VudDsgaSArPSAxKSB7XG4gICAgICAgIHZhciBzZWdtZW50ID0gdC5zZWdtZW50c1tpXTtcblxuICAgICAgICAvLyBDTUFQIDRcbiAgICAgICAgaWYgKHNlZ21lbnQuZW5kIDw9IDY1NTM1ICYmIHNlZ21lbnQuc3RhcnQgPD0gNjU1MzUpIHtcbiAgICAgICAgICAgIGVuZENvdW50cyA9IGVuZENvdW50cy5jb25jYXQoe25hbWU6ICdlbmRfJyArIGksIHR5cGU6ICdVU0hPUlQnLCB2YWx1ZTogc2VnbWVudC5lbmR9KTtcbiAgICAgICAgICAgIHN0YXJ0Q291bnRzID0gc3RhcnRDb3VudHMuY29uY2F0KHtuYW1lOiAnc3RhcnRfJyArIGksIHR5cGU6ICdVU0hPUlQnLCB2YWx1ZTogc2VnbWVudC5zdGFydH0pO1xuICAgICAgICAgICAgaWREZWx0YXMgPSBpZERlbHRhcy5jb25jYXQoe25hbWU6ICdpZERlbHRhXycgKyBpLCB0eXBlOiAnU0hPUlQnLCB2YWx1ZTogc2VnbWVudC5kZWx0YX0pO1xuICAgICAgICAgICAgaWRSYW5nZU9mZnNldHMgPSBpZFJhbmdlT2Zmc2V0cy5jb25jYXQoe25hbWU6ICdpZFJhbmdlT2Zmc2V0XycgKyBpLCB0eXBlOiAnVVNIT1JUJywgdmFsdWU6IHNlZ21lbnQub2Zmc2V0fSk7XG4gICAgICAgICAgICBpZiAoc2VnbWVudC5nbHlwaElkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBnbHlwaElkcyA9IGdseXBoSWRzLmNvbmNhdCh7bmFtZTogJ2dseXBoXycgKyBpLCB0eXBlOiAnVVNIT1JUJywgdmFsdWU6IHNlZ21lbnQuZ2x5cGhJZH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gU2tpcCBVbmljb2RlID4gNjU1MzUgKDE2Yml0IHVuc2lnbmVkIG1heCkgZm9yIENNQVAgNCwgd2lsbCBiZSBhZGRlZCBpbiBDTUFQIDEyXG4gICAgICAgICAgICBzZWdDb3VudFRvUmVtb3ZlICs9IDE7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBDTUFQIDEyXG4gICAgICAgIC8vIFNraXAgVGVybWluYXRvciBTZWdtZW50XG4gICAgICAgIGlmICghaXNQbGFuME9ubHkgJiYgc2VnbWVudC5nbHlwaEluZGV4ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGNtYXAxMkdyb3VwcyA9IGNtYXAxMkdyb3Vwcy5jb25jYXQoe25hbWU6ICdjbWFwMTJTdGFydF8nICsgaSwgdHlwZTogJ1VMT05HJywgdmFsdWU6IHNlZ21lbnQuc3RhcnR9KTtcbiAgICAgICAgICAgIGNtYXAxMkdyb3VwcyA9IGNtYXAxMkdyb3Vwcy5jb25jYXQoe25hbWU6ICdjbWFwMTJFbmRfJyArIGksIHR5cGU6ICdVTE9ORycsIHZhbHVlOiBzZWdtZW50LmVuZH0pO1xuICAgICAgICAgICAgY21hcDEyR3JvdXBzID0gY21hcDEyR3JvdXBzLmNvbmNhdCh7bmFtZTogJ2NtYXAxMkdseXBoXycgKyBpLCB0eXBlOiAnVUxPTkcnLCB2YWx1ZTogc2VnbWVudC5nbHlwaEluZGV4fSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBDTUFQIDQgU3VidGFibGVcbiAgICB0LnNlZ0NvdW50WDIgPSAoc2VnQ291bnQgLSBzZWdDb3VudFRvUmVtb3ZlKSAqIDI7XG4gICAgdC5zZWFyY2hSYW5nZSA9IE1hdGgucG93KDIsIE1hdGguZmxvb3IoTWF0aC5sb2coKHNlZ0NvdW50IC0gc2VnQ291bnRUb1JlbW92ZSkpIC8gTWF0aC5sb2coMikpKSAqIDI7XG4gICAgdC5lbnRyeVNlbGVjdG9yID0gTWF0aC5sb2codC5zZWFyY2hSYW5nZSAvIDIpIC8gTWF0aC5sb2coMik7XG4gICAgdC5yYW5nZVNoaWZ0ID0gdC5zZWdDb3VudFgyIC0gdC5zZWFyY2hSYW5nZTtcblxuICAgIHQuZmllbGRzID0gdC5maWVsZHMuY29uY2F0KGVuZENvdW50cyk7XG4gICAgdC5maWVsZHMucHVzaCh7bmFtZTogJ3Jlc2VydmVkUGFkJywgdHlwZTogJ1VTSE9SVCcsIHZhbHVlOiAwfSk7XG4gICAgdC5maWVsZHMgPSB0LmZpZWxkcy5jb25jYXQoc3RhcnRDb3VudHMpO1xuICAgIHQuZmllbGRzID0gdC5maWVsZHMuY29uY2F0KGlkRGVsdGFzKTtcbiAgICB0LmZpZWxkcyA9IHQuZmllbGRzLmNvbmNhdChpZFJhbmdlT2Zmc2V0cyk7XG4gICAgdC5maWVsZHMgPSB0LmZpZWxkcy5jb25jYXQoZ2x5cGhJZHMpO1xuXG4gICAgdC5jbWFwNExlbmd0aCA9IDE0ICsgLy8gU3VidGFibGUgaGVhZGVyXG4gICAgICAgIGVuZENvdW50cy5sZW5ndGggKiAyICtcbiAgICAgICAgMiArIC8vIHJlc2VydmVkUGFkXG4gICAgICAgIHN0YXJ0Q291bnRzLmxlbmd0aCAqIDIgK1xuICAgICAgICBpZERlbHRhcy5sZW5ndGggKiAyICtcbiAgICAgICAgaWRSYW5nZU9mZnNldHMubGVuZ3RoICogMiArXG4gICAgICAgIGdseXBoSWRzLmxlbmd0aCAqIDI7XG5cbiAgICBpZiAoIWlzUGxhbjBPbmx5KSB7XG4gICAgICAgIC8vIENNQVAgMTIgU3VidGFibGVcbiAgICAgICAgdmFyIGNtYXAxMkxlbmd0aCA9IDE2ICsgLy8gU3VidGFibGUgaGVhZGVyXG4gICAgICAgICAgICBjbWFwMTJHcm91cHMubGVuZ3RoICogNDtcblxuICAgICAgICB0LmNtYXAxMk9mZnNldCA9IDEyICsgKDIgKiAyKSArIDQgKyB0LmNtYXA0TGVuZ3RoO1xuICAgICAgICB0LmZpZWxkcyA9IHQuZmllbGRzLmNvbmNhdChbXG4gICAgICAgICAgICB7bmFtZTogJ2NtYXAxMkZvcm1hdCcsIHR5cGU6ICdVU0hPUlQnLCB2YWx1ZTogMTJ9LFxuICAgICAgICAgICAge25hbWU6ICdjbWFwMTJSZXNlcnZlZCcsIHR5cGU6ICdVU0hPUlQnLCB2YWx1ZTogMH0sXG4gICAgICAgICAgICB7bmFtZTogJ2NtYXAxMkxlbmd0aCcsIHR5cGU6ICdVTE9ORycsIHZhbHVlOiBjbWFwMTJMZW5ndGh9LFxuICAgICAgICAgICAge25hbWU6ICdjbWFwMTJMYW5ndWFnZScsIHR5cGU6ICdVTE9ORycsIHZhbHVlOiAwfSxcbiAgICAgICAgICAgIHtuYW1lOiAnY21hcDEybkdyb3VwcycsIHR5cGU6ICdVTE9ORycsIHZhbHVlOiBjbWFwMTJHcm91cHMubGVuZ3RoIC8gM31cbiAgICAgICAgXSk7XG5cbiAgICAgICAgdC5maWVsZHMgPSB0LmZpZWxkcy5jb25jYXQoY21hcDEyR3JvdXBzKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdDtcbn1cblxudmFyIGNtYXAgPSB7IHBhcnNlOiBwYXJzZUNtYXBUYWJsZSwgbWFrZTogbWFrZUNtYXBUYWJsZSB9O1xuXG4vLyBHbHlwaCBlbmNvZGluZ1xuXG52YXIgY2ZmU3RhbmRhcmRTdHJpbmdzID0gW1xuICAgICcubm90ZGVmJywgJ3NwYWNlJywgJ2V4Y2xhbScsICdxdW90ZWRibCcsICdudW1iZXJzaWduJywgJ2RvbGxhcicsICdwZXJjZW50JywgJ2FtcGVyc2FuZCcsICdxdW90ZXJpZ2h0JyxcbiAgICAncGFyZW5sZWZ0JywgJ3BhcmVucmlnaHQnLCAnYXN0ZXJpc2snLCAncGx1cycsICdjb21tYScsICdoeXBoZW4nLCAncGVyaW9kJywgJ3NsYXNoJywgJ3plcm8nLCAnb25lJywgJ3R3bycsXG4gICAgJ3RocmVlJywgJ2ZvdXInLCAnZml2ZScsICdzaXgnLCAnc2V2ZW4nLCAnZWlnaHQnLCAnbmluZScsICdjb2xvbicsICdzZW1pY29sb24nLCAnbGVzcycsICdlcXVhbCcsICdncmVhdGVyJyxcbiAgICAncXVlc3Rpb24nLCAnYXQnLCAnQScsICdCJywgJ0MnLCAnRCcsICdFJywgJ0YnLCAnRycsICdIJywgJ0knLCAnSicsICdLJywgJ0wnLCAnTScsICdOJywgJ08nLCAnUCcsICdRJywgJ1InLCAnUycsXG4gICAgJ1QnLCAnVScsICdWJywgJ1cnLCAnWCcsICdZJywgJ1onLCAnYnJhY2tldGxlZnQnLCAnYmFja3NsYXNoJywgJ2JyYWNrZXRyaWdodCcsICdhc2NpaWNpcmN1bScsICd1bmRlcnNjb3JlJyxcbiAgICAncXVvdGVsZWZ0JywgJ2EnLCAnYicsICdjJywgJ2QnLCAnZScsICdmJywgJ2cnLCAnaCcsICdpJywgJ2onLCAnaycsICdsJywgJ20nLCAnbicsICdvJywgJ3AnLCAncScsICdyJywgJ3MnLCAndCcsXG4gICAgJ3UnLCAndicsICd3JywgJ3gnLCAneScsICd6JywgJ2JyYWNlbGVmdCcsICdiYXInLCAnYnJhY2VyaWdodCcsICdhc2NpaXRpbGRlJywgJ2V4Y2xhbWRvd24nLCAnY2VudCcsICdzdGVybGluZycsXG4gICAgJ2ZyYWN0aW9uJywgJ3llbicsICdmbG9yaW4nLCAnc2VjdGlvbicsICdjdXJyZW5jeScsICdxdW90ZXNpbmdsZScsICdxdW90ZWRibGxlZnQnLCAnZ3VpbGxlbW90bGVmdCcsXG4gICAgJ2d1aWxzaW5nbGxlZnQnLCAnZ3VpbHNpbmdscmlnaHQnLCAnZmknLCAnZmwnLCAnZW5kYXNoJywgJ2RhZ2dlcicsICdkYWdnZXJkYmwnLCAncGVyaW9kY2VudGVyZWQnLCAncGFyYWdyYXBoJyxcbiAgICAnYnVsbGV0JywgJ3F1b3Rlc2luZ2xiYXNlJywgJ3F1b3RlZGJsYmFzZScsICdxdW90ZWRibHJpZ2h0JywgJ2d1aWxsZW1vdHJpZ2h0JywgJ2VsbGlwc2lzJywgJ3BlcnRob3VzYW5kJyxcbiAgICAncXVlc3Rpb25kb3duJywgJ2dyYXZlJywgJ2FjdXRlJywgJ2NpcmN1bWZsZXgnLCAndGlsZGUnLCAnbWFjcm9uJywgJ2JyZXZlJywgJ2RvdGFjY2VudCcsICdkaWVyZXNpcycsICdyaW5nJyxcbiAgICAnY2VkaWxsYScsICdodW5nYXJ1bWxhdXQnLCAnb2dvbmVrJywgJ2Nhcm9uJywgJ2VtZGFzaCcsICdBRScsICdvcmRmZW1pbmluZScsICdMc2xhc2gnLCAnT3NsYXNoJywgJ09FJyxcbiAgICAnb3JkbWFzY3VsaW5lJywgJ2FlJywgJ2RvdGxlc3NpJywgJ2xzbGFzaCcsICdvc2xhc2gnLCAnb2UnLCAnZ2VybWFuZGJscycsICdvbmVzdXBlcmlvcicsICdsb2dpY2Fsbm90JywgJ211JyxcbiAgICAndHJhZGVtYXJrJywgJ0V0aCcsICdvbmVoYWxmJywgJ3BsdXNtaW51cycsICdUaG9ybicsICdvbmVxdWFydGVyJywgJ2RpdmlkZScsICdicm9rZW5iYXInLCAnZGVncmVlJywgJ3Rob3JuJyxcbiAgICAndGhyZWVxdWFydGVycycsICd0d29zdXBlcmlvcicsICdyZWdpc3RlcmVkJywgJ21pbnVzJywgJ2V0aCcsICdtdWx0aXBseScsICd0aHJlZXN1cGVyaW9yJywgJ2NvcHlyaWdodCcsXG4gICAgJ0FhY3V0ZScsICdBY2lyY3VtZmxleCcsICdBZGllcmVzaXMnLCAnQWdyYXZlJywgJ0FyaW5nJywgJ0F0aWxkZScsICdDY2VkaWxsYScsICdFYWN1dGUnLCAnRWNpcmN1bWZsZXgnLFxuICAgICdFZGllcmVzaXMnLCAnRWdyYXZlJywgJ0lhY3V0ZScsICdJY2lyY3VtZmxleCcsICdJZGllcmVzaXMnLCAnSWdyYXZlJywgJ050aWxkZScsICdPYWN1dGUnLCAnT2NpcmN1bWZsZXgnLFxuICAgICdPZGllcmVzaXMnLCAnT2dyYXZlJywgJ090aWxkZScsICdTY2Fyb24nLCAnVWFjdXRlJywgJ1VjaXJjdW1mbGV4JywgJ1VkaWVyZXNpcycsICdVZ3JhdmUnLCAnWWFjdXRlJyxcbiAgICAnWWRpZXJlc2lzJywgJ1pjYXJvbicsICdhYWN1dGUnLCAnYWNpcmN1bWZsZXgnLCAnYWRpZXJlc2lzJywgJ2FncmF2ZScsICdhcmluZycsICdhdGlsZGUnLCAnY2NlZGlsbGEnLCAnZWFjdXRlJyxcbiAgICAnZWNpcmN1bWZsZXgnLCAnZWRpZXJlc2lzJywgJ2VncmF2ZScsICdpYWN1dGUnLCAnaWNpcmN1bWZsZXgnLCAnaWRpZXJlc2lzJywgJ2lncmF2ZScsICdudGlsZGUnLCAnb2FjdXRlJyxcbiAgICAnb2NpcmN1bWZsZXgnLCAnb2RpZXJlc2lzJywgJ29ncmF2ZScsICdvdGlsZGUnLCAnc2Nhcm9uJywgJ3VhY3V0ZScsICd1Y2lyY3VtZmxleCcsICd1ZGllcmVzaXMnLCAndWdyYXZlJyxcbiAgICAneWFjdXRlJywgJ3lkaWVyZXNpcycsICd6Y2Fyb24nLCAnZXhjbGFtc21hbGwnLCAnSHVuZ2FydW1sYXV0c21hbGwnLCAnZG9sbGFyb2xkc3R5bGUnLCAnZG9sbGFyc3VwZXJpb3InLFxuICAgICdhbXBlcnNhbmRzbWFsbCcsICdBY3V0ZXNtYWxsJywgJ3BhcmVubGVmdHN1cGVyaW9yJywgJ3BhcmVucmlnaHRzdXBlcmlvcicsICcyNjYgZmYnLCAnb25lZG90ZW5sZWFkZXInLFxuICAgICd6ZXJvb2xkc3R5bGUnLCAnb25lb2xkc3R5bGUnLCAndHdvb2xkc3R5bGUnLCAndGhyZWVvbGRzdHlsZScsICdmb3Vyb2xkc3R5bGUnLCAnZml2ZW9sZHN0eWxlJywgJ3NpeG9sZHN0eWxlJyxcbiAgICAnc2V2ZW5vbGRzdHlsZScsICdlaWdodG9sZHN0eWxlJywgJ25pbmVvbGRzdHlsZScsICdjb21tYXN1cGVyaW9yJywgJ3RocmVlcXVhcnRlcnNlbWRhc2gnLCAncGVyaW9kc3VwZXJpb3InLFxuICAgICdxdWVzdGlvbnNtYWxsJywgJ2FzdXBlcmlvcicsICdic3VwZXJpb3InLCAnY2VudHN1cGVyaW9yJywgJ2RzdXBlcmlvcicsICdlc3VwZXJpb3InLCAnaXN1cGVyaW9yJywgJ2xzdXBlcmlvcicsXG4gICAgJ21zdXBlcmlvcicsICduc3VwZXJpb3InLCAnb3N1cGVyaW9yJywgJ3JzdXBlcmlvcicsICdzc3VwZXJpb3InLCAndHN1cGVyaW9yJywgJ2ZmJywgJ2ZmaScsICdmZmwnLFxuICAgICdwYXJlbmxlZnRpbmZlcmlvcicsICdwYXJlbnJpZ2h0aW5mZXJpb3InLCAnQ2lyY3VtZmxleHNtYWxsJywgJ2h5cGhlbnN1cGVyaW9yJywgJ0dyYXZlc21hbGwnLCAnQXNtYWxsJyxcbiAgICAnQnNtYWxsJywgJ0NzbWFsbCcsICdEc21hbGwnLCAnRXNtYWxsJywgJ0ZzbWFsbCcsICdHc21hbGwnLCAnSHNtYWxsJywgJ0lzbWFsbCcsICdKc21hbGwnLCAnS3NtYWxsJywgJ0xzbWFsbCcsXG4gICAgJ01zbWFsbCcsICdOc21hbGwnLCAnT3NtYWxsJywgJ1BzbWFsbCcsICdRc21hbGwnLCAnUnNtYWxsJywgJ1NzbWFsbCcsICdUc21hbGwnLCAnVXNtYWxsJywgJ1ZzbWFsbCcsICdXc21hbGwnLFxuICAgICdYc21hbGwnLCAnWXNtYWxsJywgJ1pzbWFsbCcsICdjb2xvbm1vbmV0YXJ5JywgJ29uZWZpdHRlZCcsICdydXBpYWgnLCAnVGlsZGVzbWFsbCcsICdleGNsYW1kb3duc21hbGwnLFxuICAgICdjZW50b2xkc3R5bGUnLCAnTHNsYXNoc21hbGwnLCAnU2Nhcm9uc21hbGwnLCAnWmNhcm9uc21hbGwnLCAnRGllcmVzaXNzbWFsbCcsICdCcmV2ZXNtYWxsJywgJ0Nhcm9uc21hbGwnLFxuICAgICdEb3RhY2NlbnRzbWFsbCcsICdNYWNyb25zbWFsbCcsICdmaWd1cmVkYXNoJywgJ2h5cGhlbmluZmVyaW9yJywgJ09nb25la3NtYWxsJywgJ1JpbmdzbWFsbCcsICdDZWRpbGxhc21hbGwnLFxuICAgICdxdWVzdGlvbmRvd25zbWFsbCcsICdvbmVlaWdodGgnLCAndGhyZWVlaWdodGhzJywgJ2ZpdmVlaWdodGhzJywgJ3NldmVuZWlnaHRocycsICdvbmV0aGlyZCcsICd0d290aGlyZHMnLFxuICAgICd6ZXJvc3VwZXJpb3InLCAnZm91cnN1cGVyaW9yJywgJ2ZpdmVzdXBlcmlvcicsICdzaXhzdXBlcmlvcicsICdzZXZlbnN1cGVyaW9yJywgJ2VpZ2h0c3VwZXJpb3InLCAnbmluZXN1cGVyaW9yJyxcbiAgICAnemVyb2luZmVyaW9yJywgJ29uZWluZmVyaW9yJywgJ3R3b2luZmVyaW9yJywgJ3RocmVlaW5mZXJpb3InLCAnZm91cmluZmVyaW9yJywgJ2ZpdmVpbmZlcmlvcicsICdzaXhpbmZlcmlvcicsXG4gICAgJ3NldmVuaW5mZXJpb3InLCAnZWlnaHRpbmZlcmlvcicsICduaW5laW5mZXJpb3InLCAnY2VudGluZmVyaW9yJywgJ2RvbGxhcmluZmVyaW9yJywgJ3BlcmlvZGluZmVyaW9yJyxcbiAgICAnY29tbWFpbmZlcmlvcicsICdBZ3JhdmVzbWFsbCcsICdBYWN1dGVzbWFsbCcsICdBY2lyY3VtZmxleHNtYWxsJywgJ0F0aWxkZXNtYWxsJywgJ0FkaWVyZXNpc3NtYWxsJyxcbiAgICAnQXJpbmdzbWFsbCcsICdBRXNtYWxsJywgJ0NjZWRpbGxhc21hbGwnLCAnRWdyYXZlc21hbGwnLCAnRWFjdXRlc21hbGwnLCAnRWNpcmN1bWZsZXhzbWFsbCcsICdFZGllcmVzaXNzbWFsbCcsXG4gICAgJ0lncmF2ZXNtYWxsJywgJ0lhY3V0ZXNtYWxsJywgJ0ljaXJjdW1mbGV4c21hbGwnLCAnSWRpZXJlc2lzc21hbGwnLCAnRXRoc21hbGwnLCAnTnRpbGRlc21hbGwnLCAnT2dyYXZlc21hbGwnLFxuICAgICdPYWN1dGVzbWFsbCcsICdPY2lyY3VtZmxleHNtYWxsJywgJ090aWxkZXNtYWxsJywgJ09kaWVyZXNpc3NtYWxsJywgJ09Fc21hbGwnLCAnT3NsYXNoc21hbGwnLCAnVWdyYXZlc21hbGwnLFxuICAgICdVYWN1dGVzbWFsbCcsICdVY2lyY3VtZmxleHNtYWxsJywgJ1VkaWVyZXNpc3NtYWxsJywgJ1lhY3V0ZXNtYWxsJywgJ1Rob3Juc21hbGwnLCAnWWRpZXJlc2lzc21hbGwnLCAnMDAxLjAwMCcsXG4gICAgJzAwMS4wMDEnLCAnMDAxLjAwMicsICcwMDEuMDAzJywgJ0JsYWNrJywgJ0JvbGQnLCAnQm9vaycsICdMaWdodCcsICdNZWRpdW0nLCAnUmVndWxhcicsICdSb21hbicsICdTZW1pYm9sZCddO1xuXG52YXIgY2ZmU3RhbmRhcmRFbmNvZGluZyA9IFtcbiAgICAnJywgJycsICcnLCAnJywgJycsICcnLCAnJywgJycsICcnLCAnJywgJycsICcnLCAnJywgJycsICcnLCAnJywgJycsICcnLCAnJywgJycsICcnLCAnJywgJycsICcnLCAnJywgJycsICcnLCAnJyxcbiAgICAnJywgJycsICcnLCAnJywgJ3NwYWNlJywgJ2V4Y2xhbScsICdxdW90ZWRibCcsICdudW1iZXJzaWduJywgJ2RvbGxhcicsICdwZXJjZW50JywgJ2FtcGVyc2FuZCcsICdxdW90ZXJpZ2h0JyxcbiAgICAncGFyZW5sZWZ0JywgJ3BhcmVucmlnaHQnLCAnYXN0ZXJpc2snLCAncGx1cycsICdjb21tYScsICdoeXBoZW4nLCAncGVyaW9kJywgJ3NsYXNoJywgJ3plcm8nLCAnb25lJywgJ3R3bycsXG4gICAgJ3RocmVlJywgJ2ZvdXInLCAnZml2ZScsICdzaXgnLCAnc2V2ZW4nLCAnZWlnaHQnLCAnbmluZScsICdjb2xvbicsICdzZW1pY29sb24nLCAnbGVzcycsICdlcXVhbCcsICdncmVhdGVyJyxcbiAgICAncXVlc3Rpb24nLCAnYXQnLCAnQScsICdCJywgJ0MnLCAnRCcsICdFJywgJ0YnLCAnRycsICdIJywgJ0knLCAnSicsICdLJywgJ0wnLCAnTScsICdOJywgJ08nLCAnUCcsICdRJywgJ1InLCAnUycsXG4gICAgJ1QnLCAnVScsICdWJywgJ1cnLCAnWCcsICdZJywgJ1onLCAnYnJhY2tldGxlZnQnLCAnYmFja3NsYXNoJywgJ2JyYWNrZXRyaWdodCcsICdhc2NpaWNpcmN1bScsICd1bmRlcnNjb3JlJyxcbiAgICAncXVvdGVsZWZ0JywgJ2EnLCAnYicsICdjJywgJ2QnLCAnZScsICdmJywgJ2cnLCAnaCcsICdpJywgJ2onLCAnaycsICdsJywgJ20nLCAnbicsICdvJywgJ3AnLCAncScsICdyJywgJ3MnLCAndCcsXG4gICAgJ3UnLCAndicsICd3JywgJ3gnLCAneScsICd6JywgJ2JyYWNlbGVmdCcsICdiYXInLCAnYnJhY2VyaWdodCcsICdhc2NpaXRpbGRlJywgJycsICcnLCAnJywgJycsICcnLCAnJywgJycsICcnLFxuICAgICcnLCAnJywgJycsICcnLCAnJywgJycsICcnLCAnJywgJycsICcnLCAnJywgJycsICcnLCAnJywgJycsICcnLCAnJywgJycsICcnLCAnJywgJycsICcnLCAnJywgJycsICcnLCAnJyxcbiAgICAnZXhjbGFtZG93bicsICdjZW50JywgJ3N0ZXJsaW5nJywgJ2ZyYWN0aW9uJywgJ3llbicsICdmbG9yaW4nLCAnc2VjdGlvbicsICdjdXJyZW5jeScsICdxdW90ZXNpbmdsZScsXG4gICAgJ3F1b3RlZGJsbGVmdCcsICdndWlsbGVtb3RsZWZ0JywgJ2d1aWxzaW5nbGxlZnQnLCAnZ3VpbHNpbmdscmlnaHQnLCAnZmknLCAnZmwnLCAnJywgJ2VuZGFzaCcsICdkYWdnZXInLFxuICAgICdkYWdnZXJkYmwnLCAncGVyaW9kY2VudGVyZWQnLCAnJywgJ3BhcmFncmFwaCcsICdidWxsZXQnLCAncXVvdGVzaW5nbGJhc2UnLCAncXVvdGVkYmxiYXNlJywgJ3F1b3RlZGJscmlnaHQnLFxuICAgICdndWlsbGVtb3RyaWdodCcsICdlbGxpcHNpcycsICdwZXJ0aG91c2FuZCcsICcnLCAncXVlc3Rpb25kb3duJywgJycsICdncmF2ZScsICdhY3V0ZScsICdjaXJjdW1mbGV4JywgJ3RpbGRlJyxcbiAgICAnbWFjcm9uJywgJ2JyZXZlJywgJ2RvdGFjY2VudCcsICdkaWVyZXNpcycsICcnLCAncmluZycsICdjZWRpbGxhJywgJycsICdodW5nYXJ1bWxhdXQnLCAnb2dvbmVrJywgJ2Nhcm9uJyxcbiAgICAnZW1kYXNoJywgJycsICcnLCAnJywgJycsICcnLCAnJywgJycsICcnLCAnJywgJycsICcnLCAnJywgJycsICcnLCAnJywgJycsICdBRScsICcnLCAnb3JkZmVtaW5pbmUnLCAnJywgJycsICcnLFxuICAgICcnLCAnTHNsYXNoJywgJ09zbGFzaCcsICdPRScsICdvcmRtYXNjdWxpbmUnLCAnJywgJycsICcnLCAnJywgJycsICdhZScsICcnLCAnJywgJycsICdkb3RsZXNzaScsICcnLCAnJyxcbiAgICAnbHNsYXNoJywgJ29zbGFzaCcsICdvZScsICdnZXJtYW5kYmxzJ107XG5cbnZhciBjZmZFeHBlcnRFbmNvZGluZyA9IFtcbiAgICAnJywgJycsICcnLCAnJywgJycsICcnLCAnJywgJycsICcnLCAnJywgJycsICcnLCAnJywgJycsICcnLCAnJywgJycsICcnLCAnJywgJycsICcnLCAnJywgJycsICcnLCAnJywgJycsICcnLCAnJyxcbiAgICAnJywgJycsICcnLCAnJywgJ3NwYWNlJywgJ2V4Y2xhbXNtYWxsJywgJ0h1bmdhcnVtbGF1dHNtYWxsJywgJycsICdkb2xsYXJvbGRzdHlsZScsICdkb2xsYXJzdXBlcmlvcicsXG4gICAgJ2FtcGVyc2FuZHNtYWxsJywgJ0FjdXRlc21hbGwnLCAncGFyZW5sZWZ0c3VwZXJpb3InLCAncGFyZW5yaWdodHN1cGVyaW9yJywgJ3R3b2RvdGVubGVhZGVyJywgJ29uZWRvdGVubGVhZGVyJyxcbiAgICAnY29tbWEnLCAnaHlwaGVuJywgJ3BlcmlvZCcsICdmcmFjdGlvbicsICd6ZXJvb2xkc3R5bGUnLCAnb25lb2xkc3R5bGUnLCAndHdvb2xkc3R5bGUnLCAndGhyZWVvbGRzdHlsZScsXG4gICAgJ2ZvdXJvbGRzdHlsZScsICdmaXZlb2xkc3R5bGUnLCAnc2l4b2xkc3R5bGUnLCAnc2V2ZW5vbGRzdHlsZScsICdlaWdodG9sZHN0eWxlJywgJ25pbmVvbGRzdHlsZScsICdjb2xvbicsXG4gICAgJ3NlbWljb2xvbicsICdjb21tYXN1cGVyaW9yJywgJ3RocmVlcXVhcnRlcnNlbWRhc2gnLCAncGVyaW9kc3VwZXJpb3InLCAncXVlc3Rpb25zbWFsbCcsICcnLCAnYXN1cGVyaW9yJyxcbiAgICAnYnN1cGVyaW9yJywgJ2NlbnRzdXBlcmlvcicsICdkc3VwZXJpb3InLCAnZXN1cGVyaW9yJywgJycsICcnLCAnaXN1cGVyaW9yJywgJycsICcnLCAnbHN1cGVyaW9yJywgJ21zdXBlcmlvcicsXG4gICAgJ25zdXBlcmlvcicsICdvc3VwZXJpb3InLCAnJywgJycsICdyc3VwZXJpb3InLCAnc3N1cGVyaW9yJywgJ3RzdXBlcmlvcicsICcnLCAnZmYnLCAnZmknLCAnZmwnLCAnZmZpJywgJ2ZmbCcsXG4gICAgJ3BhcmVubGVmdGluZmVyaW9yJywgJycsICdwYXJlbnJpZ2h0aW5mZXJpb3InLCAnQ2lyY3VtZmxleHNtYWxsJywgJ2h5cGhlbnN1cGVyaW9yJywgJ0dyYXZlc21hbGwnLCAnQXNtYWxsJyxcbiAgICAnQnNtYWxsJywgJ0NzbWFsbCcsICdEc21hbGwnLCAnRXNtYWxsJywgJ0ZzbWFsbCcsICdHc21hbGwnLCAnSHNtYWxsJywgJ0lzbWFsbCcsICdKc21hbGwnLCAnS3NtYWxsJywgJ0xzbWFsbCcsXG4gICAgJ01zbWFsbCcsICdOc21hbGwnLCAnT3NtYWxsJywgJ1BzbWFsbCcsICdRc21hbGwnLCAnUnNtYWxsJywgJ1NzbWFsbCcsICdUc21hbGwnLCAnVXNtYWxsJywgJ1ZzbWFsbCcsICdXc21hbGwnLFxuICAgICdYc21hbGwnLCAnWXNtYWxsJywgJ1pzbWFsbCcsICdjb2xvbm1vbmV0YXJ5JywgJ29uZWZpdHRlZCcsICdydXBpYWgnLCAnVGlsZGVzbWFsbCcsICcnLCAnJywgJycsICcnLCAnJywgJycsICcnLFxuICAgICcnLCAnJywgJycsICcnLCAnJywgJycsICcnLCAnJywgJycsICcnLCAnJywgJycsICcnLCAnJywgJycsICcnLCAnJywgJycsICcnLCAnJywgJycsICcnLCAnJywgJycsICcnLCAnJywgJycsXG4gICAgJ2V4Y2xhbWRvd25zbWFsbCcsICdjZW50b2xkc3R5bGUnLCAnTHNsYXNoc21hbGwnLCAnJywgJycsICdTY2Fyb25zbWFsbCcsICdaY2Fyb25zbWFsbCcsICdEaWVyZXNpc3NtYWxsJyxcbiAgICAnQnJldmVzbWFsbCcsICdDYXJvbnNtYWxsJywgJycsICdEb3RhY2NlbnRzbWFsbCcsICcnLCAnJywgJ01hY3JvbnNtYWxsJywgJycsICcnLCAnZmlndXJlZGFzaCcsICdoeXBoZW5pbmZlcmlvcicsXG4gICAgJycsICcnLCAnT2dvbmVrc21hbGwnLCAnUmluZ3NtYWxsJywgJ0NlZGlsbGFzbWFsbCcsICcnLCAnJywgJycsICdvbmVxdWFydGVyJywgJ29uZWhhbGYnLCAndGhyZWVxdWFydGVycycsXG4gICAgJ3F1ZXN0aW9uZG93bnNtYWxsJywgJ29uZWVpZ2h0aCcsICd0aHJlZWVpZ2h0aHMnLCAnZml2ZWVpZ2h0aHMnLCAnc2V2ZW5laWdodGhzJywgJ29uZXRoaXJkJywgJ3R3b3RoaXJkcycsICcnLFxuICAgICcnLCAnemVyb3N1cGVyaW9yJywgJ29uZXN1cGVyaW9yJywgJ3R3b3N1cGVyaW9yJywgJ3RocmVlc3VwZXJpb3InLCAnZm91cnN1cGVyaW9yJywgJ2ZpdmVzdXBlcmlvcicsXG4gICAgJ3NpeHN1cGVyaW9yJywgJ3NldmVuc3VwZXJpb3InLCAnZWlnaHRzdXBlcmlvcicsICduaW5lc3VwZXJpb3InLCAnemVyb2luZmVyaW9yJywgJ29uZWluZmVyaW9yJywgJ3R3b2luZmVyaW9yJyxcbiAgICAndGhyZWVpbmZlcmlvcicsICdmb3VyaW5mZXJpb3InLCAnZml2ZWluZmVyaW9yJywgJ3NpeGluZmVyaW9yJywgJ3NldmVuaW5mZXJpb3InLCAnZWlnaHRpbmZlcmlvcicsXG4gICAgJ25pbmVpbmZlcmlvcicsICdjZW50aW5mZXJpb3InLCAnZG9sbGFyaW5mZXJpb3InLCAncGVyaW9kaW5mZXJpb3InLCAnY29tbWFpbmZlcmlvcicsICdBZ3JhdmVzbWFsbCcsXG4gICAgJ0FhY3V0ZXNtYWxsJywgJ0FjaXJjdW1mbGV4c21hbGwnLCAnQXRpbGRlc21hbGwnLCAnQWRpZXJlc2lzc21hbGwnLCAnQXJpbmdzbWFsbCcsICdBRXNtYWxsJywgJ0NjZWRpbGxhc21hbGwnLFxuICAgICdFZ3JhdmVzbWFsbCcsICdFYWN1dGVzbWFsbCcsICdFY2lyY3VtZmxleHNtYWxsJywgJ0VkaWVyZXNpc3NtYWxsJywgJ0lncmF2ZXNtYWxsJywgJ0lhY3V0ZXNtYWxsJyxcbiAgICAnSWNpcmN1bWZsZXhzbWFsbCcsICdJZGllcmVzaXNzbWFsbCcsICdFdGhzbWFsbCcsICdOdGlsZGVzbWFsbCcsICdPZ3JhdmVzbWFsbCcsICdPYWN1dGVzbWFsbCcsXG4gICAgJ09jaXJjdW1mbGV4c21hbGwnLCAnT3RpbGRlc21hbGwnLCAnT2RpZXJlc2lzc21hbGwnLCAnT0VzbWFsbCcsICdPc2xhc2hzbWFsbCcsICdVZ3JhdmVzbWFsbCcsICdVYWN1dGVzbWFsbCcsXG4gICAgJ1VjaXJjdW1mbGV4c21hbGwnLCAnVWRpZXJlc2lzc21hbGwnLCAnWWFjdXRlc21hbGwnLCAnVGhvcm5zbWFsbCcsICdZZGllcmVzaXNzbWFsbCddO1xuXG52YXIgc3RhbmRhcmROYW1lcyA9IFtcbiAgICAnLm5vdGRlZicsICcubnVsbCcsICdub25tYXJraW5ncmV0dXJuJywgJ3NwYWNlJywgJ2V4Y2xhbScsICdxdW90ZWRibCcsICdudW1iZXJzaWduJywgJ2RvbGxhcicsICdwZXJjZW50JyxcbiAgICAnYW1wZXJzYW5kJywgJ3F1b3Rlc2luZ2xlJywgJ3BhcmVubGVmdCcsICdwYXJlbnJpZ2h0JywgJ2FzdGVyaXNrJywgJ3BsdXMnLCAnY29tbWEnLCAnaHlwaGVuJywgJ3BlcmlvZCcsICdzbGFzaCcsXG4gICAgJ3plcm8nLCAnb25lJywgJ3R3bycsICd0aHJlZScsICdmb3VyJywgJ2ZpdmUnLCAnc2l4JywgJ3NldmVuJywgJ2VpZ2h0JywgJ25pbmUnLCAnY29sb24nLCAnc2VtaWNvbG9uJywgJ2xlc3MnLFxuICAgICdlcXVhbCcsICdncmVhdGVyJywgJ3F1ZXN0aW9uJywgJ2F0JywgJ0EnLCAnQicsICdDJywgJ0QnLCAnRScsICdGJywgJ0cnLCAnSCcsICdJJywgJ0onLCAnSycsICdMJywgJ00nLCAnTicsICdPJyxcbiAgICAnUCcsICdRJywgJ1InLCAnUycsICdUJywgJ1UnLCAnVicsICdXJywgJ1gnLCAnWScsICdaJywgJ2JyYWNrZXRsZWZ0JywgJ2JhY2tzbGFzaCcsICdicmFja2V0cmlnaHQnLFxuICAgICdhc2NpaWNpcmN1bScsICd1bmRlcnNjb3JlJywgJ2dyYXZlJywgJ2EnLCAnYicsICdjJywgJ2QnLCAnZScsICdmJywgJ2cnLCAnaCcsICdpJywgJ2onLCAnaycsICdsJywgJ20nLCAnbicsICdvJyxcbiAgICAncCcsICdxJywgJ3InLCAncycsICd0JywgJ3UnLCAndicsICd3JywgJ3gnLCAneScsICd6JywgJ2JyYWNlbGVmdCcsICdiYXInLCAnYnJhY2VyaWdodCcsICdhc2NpaXRpbGRlJyxcbiAgICAnQWRpZXJlc2lzJywgJ0FyaW5nJywgJ0NjZWRpbGxhJywgJ0VhY3V0ZScsICdOdGlsZGUnLCAnT2RpZXJlc2lzJywgJ1VkaWVyZXNpcycsICdhYWN1dGUnLCAnYWdyYXZlJyxcbiAgICAnYWNpcmN1bWZsZXgnLCAnYWRpZXJlc2lzJywgJ2F0aWxkZScsICdhcmluZycsICdjY2VkaWxsYScsICdlYWN1dGUnLCAnZWdyYXZlJywgJ2VjaXJjdW1mbGV4JywgJ2VkaWVyZXNpcycsXG4gICAgJ2lhY3V0ZScsICdpZ3JhdmUnLCAnaWNpcmN1bWZsZXgnLCAnaWRpZXJlc2lzJywgJ250aWxkZScsICdvYWN1dGUnLCAnb2dyYXZlJywgJ29jaXJjdW1mbGV4JywgJ29kaWVyZXNpcycsXG4gICAgJ290aWxkZScsICd1YWN1dGUnLCAndWdyYXZlJywgJ3VjaXJjdW1mbGV4JywgJ3VkaWVyZXNpcycsICdkYWdnZXInLCAnZGVncmVlJywgJ2NlbnQnLCAnc3RlcmxpbmcnLCAnc2VjdGlvbicsXG4gICAgJ2J1bGxldCcsICdwYXJhZ3JhcGgnLCAnZ2VybWFuZGJscycsICdyZWdpc3RlcmVkJywgJ2NvcHlyaWdodCcsICd0cmFkZW1hcmsnLCAnYWN1dGUnLCAnZGllcmVzaXMnLCAnbm90ZXF1YWwnLFxuICAgICdBRScsICdPc2xhc2gnLCAnaW5maW5pdHknLCAncGx1c21pbnVzJywgJ2xlc3NlcXVhbCcsICdncmVhdGVyZXF1YWwnLCAneWVuJywgJ211JywgJ3BhcnRpYWxkaWZmJywgJ3N1bW1hdGlvbicsXG4gICAgJ3Byb2R1Y3QnLCAncGknLCAnaW50ZWdyYWwnLCAnb3JkZmVtaW5pbmUnLCAnb3JkbWFzY3VsaW5lJywgJ09tZWdhJywgJ2FlJywgJ29zbGFzaCcsICdxdWVzdGlvbmRvd24nLFxuICAgICdleGNsYW1kb3duJywgJ2xvZ2ljYWxub3QnLCAncmFkaWNhbCcsICdmbG9yaW4nLCAnYXBwcm94ZXF1YWwnLCAnRGVsdGEnLCAnZ3VpbGxlbW90bGVmdCcsICdndWlsbGVtb3RyaWdodCcsXG4gICAgJ2VsbGlwc2lzJywgJ25vbmJyZWFraW5nc3BhY2UnLCAnQWdyYXZlJywgJ0F0aWxkZScsICdPdGlsZGUnLCAnT0UnLCAnb2UnLCAnZW5kYXNoJywgJ2VtZGFzaCcsICdxdW90ZWRibGxlZnQnLFxuICAgICdxdW90ZWRibHJpZ2h0JywgJ3F1b3RlbGVmdCcsICdxdW90ZXJpZ2h0JywgJ2RpdmlkZScsICdsb3plbmdlJywgJ3lkaWVyZXNpcycsICdZZGllcmVzaXMnLCAnZnJhY3Rpb24nLFxuICAgICdjdXJyZW5jeScsICdndWlsc2luZ2xsZWZ0JywgJ2d1aWxzaW5nbHJpZ2h0JywgJ2ZpJywgJ2ZsJywgJ2RhZ2dlcmRibCcsICdwZXJpb2RjZW50ZXJlZCcsICdxdW90ZXNpbmdsYmFzZScsXG4gICAgJ3F1b3RlZGJsYmFzZScsICdwZXJ0aG91c2FuZCcsICdBY2lyY3VtZmxleCcsICdFY2lyY3VtZmxleCcsICdBYWN1dGUnLCAnRWRpZXJlc2lzJywgJ0VncmF2ZScsICdJYWN1dGUnLFxuICAgICdJY2lyY3VtZmxleCcsICdJZGllcmVzaXMnLCAnSWdyYXZlJywgJ09hY3V0ZScsICdPY2lyY3VtZmxleCcsICdhcHBsZScsICdPZ3JhdmUnLCAnVWFjdXRlJywgJ1VjaXJjdW1mbGV4JyxcbiAgICAnVWdyYXZlJywgJ2RvdGxlc3NpJywgJ2NpcmN1bWZsZXgnLCAndGlsZGUnLCAnbWFjcm9uJywgJ2JyZXZlJywgJ2RvdGFjY2VudCcsICdyaW5nJywgJ2NlZGlsbGEnLCAnaHVuZ2FydW1sYXV0JyxcbiAgICAnb2dvbmVrJywgJ2Nhcm9uJywgJ0xzbGFzaCcsICdsc2xhc2gnLCAnU2Nhcm9uJywgJ3NjYXJvbicsICdaY2Fyb24nLCAnemNhcm9uJywgJ2Jyb2tlbmJhcicsICdFdGgnLCAnZXRoJyxcbiAgICAnWWFjdXRlJywgJ3lhY3V0ZScsICdUaG9ybicsICd0aG9ybicsICdtaW51cycsICdtdWx0aXBseScsICdvbmVzdXBlcmlvcicsICd0d29zdXBlcmlvcicsICd0aHJlZXN1cGVyaW9yJyxcbiAgICAnb25laGFsZicsICdvbmVxdWFydGVyJywgJ3RocmVlcXVhcnRlcnMnLCAnZnJhbmMnLCAnR2JyZXZlJywgJ2dicmV2ZScsICdJZG90YWNjZW50JywgJ1NjZWRpbGxhJywgJ3NjZWRpbGxhJyxcbiAgICAnQ2FjdXRlJywgJ2NhY3V0ZScsICdDY2Fyb24nLCAnY2Nhcm9uJywgJ2Rjcm9hdCddO1xuXG4vKipcbiAqIFRoaXMgaXMgdGhlIGVuY29kaW5nIHVzZWQgZm9yIGZvbnRzIGNyZWF0ZWQgZnJvbSBzY3JhdGNoLlxuICogSXQgbG9vcHMgdGhyb3VnaCBhbGwgZ2x5cGhzIGFuZCBmaW5kcyB0aGUgYXBwcm9wcmlhdGUgdW5pY29kZSB2YWx1ZS5cbiAqIFNpbmNlIGl0J3MgbGluZWFyIHRpbWUsIG90aGVyIGVuY29kaW5ncyB3aWxsIGJlIGZhc3Rlci5cbiAqIEBleHBvcnRzIG9wZW50eXBlLkRlZmF1bHRFbmNvZGluZ1xuICogQGNsYXNzXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7b3BlbnR5cGUuRm9udH1cbiAqL1xuZnVuY3Rpb24gRGVmYXVsdEVuY29kaW5nKGZvbnQpIHtcbiAgICB0aGlzLmZvbnQgPSBmb250O1xufVxuXG5EZWZhdWx0RW5jb2RpbmcucHJvdG90eXBlLmNoYXJUb0dseXBoSW5kZXggPSBmdW5jdGlvbihjKSB7XG4gICAgdmFyIGNvZGUgPSBjLmNvZGVQb2ludEF0KDApO1xuICAgIHZhciBnbHlwaHMgPSB0aGlzLmZvbnQuZ2x5cGhzO1xuICAgIGlmIChnbHlwaHMpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBnbHlwaHMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgICAgIHZhciBnbHlwaCA9IGdseXBocy5nZXQoaSk7XG4gICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGdseXBoLnVuaWNvZGVzLmxlbmd0aDsgaiArPSAxKSB7XG4gICAgICAgICAgICAgICAgaWYgKGdseXBoLnVuaWNvZGVzW2pdID09PSBjb2RlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbn07XG5cbi8qKlxuICogQGV4cG9ydHMgb3BlbnR5cGUuQ21hcEVuY29kaW5nXG4gKiBAY2xhc3NcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtPYmplY3R9IGNtYXAgLSBhIG9iamVjdCB3aXRoIHRoZSBjbWFwIGVuY29kZWQgZGF0YVxuICovXG5mdW5jdGlvbiBDbWFwRW5jb2RpbmcoY21hcCkge1xuICAgIHRoaXMuY21hcCA9IGNtYXA7XG59XG5cbi8qKlxuICogQHBhcmFtICB7c3RyaW5nfSBjIC0gdGhlIGNoYXJhY3RlclxuICogQHJldHVybiB7bnVtYmVyfSBUaGUgZ2x5cGggaW5kZXguXG4gKi9cbkNtYXBFbmNvZGluZy5wcm90b3R5cGUuY2hhclRvR2x5cGhJbmRleCA9IGZ1bmN0aW9uKGMpIHtcbiAgICByZXR1cm4gdGhpcy5jbWFwLmdseXBoSW5kZXhNYXBbYy5jb2RlUG9pbnRBdCgwKV0gfHwgMDtcbn07XG5cbi8qKlxuICogQGV4cG9ydHMgb3BlbnR5cGUuQ2ZmRW5jb2RpbmdcbiAqIEBjbGFzc1xuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge3N0cmluZ30gZW5jb2RpbmcgLSBUaGUgZW5jb2RpbmdcbiAqIEBwYXJhbSB7QXJyYXl9IGNoYXJzZXQgLSBUaGUgY2hhcmFjdGVyIHNldC5cbiAqL1xuZnVuY3Rpb24gQ2ZmRW5jb2RpbmcoZW5jb2RpbmcsIGNoYXJzZXQpIHtcbiAgICB0aGlzLmVuY29kaW5nID0gZW5jb2Rpbmc7XG4gICAgdGhpcy5jaGFyc2V0ID0gY2hhcnNldDtcbn1cblxuLyoqXG4gKiBAcGFyYW0gIHtzdHJpbmd9IHMgLSBUaGUgY2hhcmFjdGVyXG4gKiBAcmV0dXJuIHtudW1iZXJ9IFRoZSBpbmRleC5cbiAqL1xuQ2ZmRW5jb2RpbmcucHJvdG90eXBlLmNoYXJUb0dseXBoSW5kZXggPSBmdW5jdGlvbihzKSB7XG4gICAgdmFyIGNvZGUgPSBzLmNvZGVQb2ludEF0KDApO1xuICAgIHZhciBjaGFyTmFtZSA9IHRoaXMuZW5jb2RpbmdbY29kZV07XG4gICAgcmV0dXJuIHRoaXMuY2hhcnNldC5pbmRleE9mKGNoYXJOYW1lKTtcbn07XG5cbi8qKlxuICogQGV4cG9ydHMgb3BlbnR5cGUuR2x5cGhOYW1lc1xuICogQGNsYXNzXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7T2JqZWN0fSBwb3N0XG4gKi9cbmZ1bmN0aW9uIEdseXBoTmFtZXMocG9zdCkge1xuICAgIHN3aXRjaCAocG9zdC52ZXJzaW9uKSB7XG4gICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgIHRoaXMubmFtZXMgPSBzdGFuZGFyZE5hbWVzLnNsaWNlKCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgdGhpcy5uYW1lcyA9IG5ldyBBcnJheShwb3N0Lm51bWJlck9mR2x5cGhzKTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcG9zdC5udW1iZXJPZkdseXBoczsgaSsrKSB7XG4gICAgICAgICAgICAgICAgaWYgKHBvc3QuZ2x5cGhOYW1lSW5kZXhbaV0gPCBzdGFuZGFyZE5hbWVzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLm5hbWVzW2ldID0gc3RhbmRhcmROYW1lc1twb3N0LmdseXBoTmFtZUluZGV4W2ldXTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLm5hbWVzW2ldID0gcG9zdC5uYW1lc1twb3N0LmdseXBoTmFtZUluZGV4W2ldIC0gc3RhbmRhcmROYW1lcy5sZW5ndGhdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMi41OlxuICAgICAgICAgICAgdGhpcy5uYW1lcyA9IG5ldyBBcnJheShwb3N0Lm51bWJlck9mR2x5cGhzKTtcbiAgICAgICAgICAgIGZvciAodmFyIGkkMSA9IDA7IGkkMSA8IHBvc3QubnVtYmVyT2ZHbHlwaHM7IGkkMSsrKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5uYW1lc1tpJDFdID0gc3RhbmRhcmROYW1lc1tpJDEgKyBwb3N0LmdseXBoTmFtZUluZGV4W2kkMV1dO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgdGhpcy5uYW1lcyA9IFtdO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICB0aGlzLm5hbWVzID0gW107XG4gICAgICAgICAgICBicmVhaztcbiAgICB9XG59XG5cbi8qKlxuICogR2V0cyB0aGUgaW5kZXggb2YgYSBnbHlwaCBieSBuYW1lLlxuICogQHBhcmFtICB7c3RyaW5nfSBuYW1lIC0gVGhlIGdseXBoIG5hbWVcbiAqIEByZXR1cm4ge251bWJlcn0gVGhlIGluZGV4XG4gKi9cbkdseXBoTmFtZXMucHJvdG90eXBlLm5hbWVUb0dseXBoSW5kZXggPSBmdW5jdGlvbihuYW1lKSB7XG4gICAgcmV0dXJuIHRoaXMubmFtZXMuaW5kZXhPZihuYW1lKTtcbn07XG5cbi8qKlxuICogQHBhcmFtICB7bnVtYmVyfSBnaWRcbiAqIEByZXR1cm4ge3N0cmluZ31cbiAqL1xuR2x5cGhOYW1lcy5wcm90b3R5cGUuZ2x5cGhJbmRleFRvTmFtZSA9IGZ1bmN0aW9uKGdpZCkge1xuICAgIHJldHVybiB0aGlzLm5hbWVzW2dpZF07XG59O1xuXG5mdW5jdGlvbiBhZGRHbHlwaE5hbWVzQWxsKGZvbnQpIHtcbiAgICB2YXIgZ2x5cGg7XG4gICAgdmFyIGdseXBoSW5kZXhNYXAgPSBmb250LnRhYmxlcy5jbWFwLmdseXBoSW5kZXhNYXA7XG4gICAgdmFyIGNoYXJDb2RlcyA9IE9iamVjdC5rZXlzKGdseXBoSW5kZXhNYXApO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaGFyQ29kZXMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgdmFyIGMgPSBjaGFyQ29kZXNbaV07XG4gICAgICAgIHZhciBnbHlwaEluZGV4ID0gZ2x5cGhJbmRleE1hcFtjXTtcbiAgICAgICAgZ2x5cGggPSBmb250LmdseXBocy5nZXQoZ2x5cGhJbmRleCk7XG4gICAgICAgIGdseXBoLmFkZFVuaWNvZGUocGFyc2VJbnQoYykpO1xuICAgIH1cblxuICAgIGZvciAodmFyIGkkMSA9IDA7IGkkMSA8IGZvbnQuZ2x5cGhzLmxlbmd0aDsgaSQxICs9IDEpIHtcbiAgICAgICAgZ2x5cGggPSBmb250LmdseXBocy5nZXQoaSQxKTtcbiAgICAgICAgaWYgKGZvbnQuY2ZmRW5jb2RpbmcpIHtcbiAgICAgICAgICAgIGlmIChmb250LmlzQ0lERm9udCkge1xuICAgICAgICAgICAgICAgIGdseXBoLm5hbWUgPSAnZ2lkJyArIGkkMTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZ2x5cGgubmFtZSA9IGZvbnQuY2ZmRW5jb2RpbmcuY2hhcnNldFtpJDFdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKGZvbnQuZ2x5cGhOYW1lcy5uYW1lcykge1xuICAgICAgICAgICAgZ2x5cGgubmFtZSA9IGZvbnQuZ2x5cGhOYW1lcy5nbHlwaEluZGV4VG9OYW1lKGkkMSk7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbmZ1bmN0aW9uIGFkZEdseXBoTmFtZXNUb1VuaWNvZGVNYXAoZm9udCkge1xuICAgIGZvbnQuX0luZGV4VG9Vbmljb2RlTWFwID0ge307XG5cbiAgICB2YXIgZ2x5cGhJbmRleE1hcCA9IGZvbnQudGFibGVzLmNtYXAuZ2x5cGhJbmRleE1hcDtcbiAgICB2YXIgY2hhckNvZGVzID0gT2JqZWN0LmtleXMoZ2x5cGhJbmRleE1hcCk7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNoYXJDb2Rlcy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICB2YXIgYyA9IGNoYXJDb2Rlc1tpXTtcbiAgICAgICAgdmFyIGdseXBoSW5kZXggPSBnbHlwaEluZGV4TWFwW2NdO1xuICAgICAgICBpZiAoZm9udC5fSW5kZXhUb1VuaWNvZGVNYXBbZ2x5cGhJbmRleF0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgZm9udC5fSW5kZXhUb1VuaWNvZGVNYXBbZ2x5cGhJbmRleF0gPSB7XG4gICAgICAgICAgICAgICAgdW5pY29kZXM6IFtwYXJzZUludChjKV1cbiAgICAgICAgICAgIH07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBmb250Ll9JbmRleFRvVW5pY29kZU1hcFtnbHlwaEluZGV4XS51bmljb2Rlcy5wdXNoKHBhcnNlSW50KGMpKTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuLyoqXG4gKiBAYWxpYXMgb3BlbnR5cGUuYWRkR2x5cGhOYW1lc1xuICogQHBhcmFtIHtvcGVudHlwZS5Gb250fVxuICogQHBhcmFtIHtPYmplY3R9XG4gKi9cbmZ1bmN0aW9uIGFkZEdseXBoTmFtZXMoZm9udCwgb3B0KSB7XG4gICAgaWYgKG9wdC5sb3dNZW1vcnkpIHtcbiAgICAgICAgYWRkR2x5cGhOYW1lc1RvVW5pY29kZU1hcChmb250KTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBhZGRHbHlwaE5hbWVzQWxsKGZvbnQpO1xuICAgIH1cbn1cblxuLy8gRHJhd2luZyB1dGlsaXR5IGZ1bmN0aW9ucy5cblxuLy8gRHJhdyBhIGxpbmUgb24gdGhlIGdpdmVuIGNvbnRleHQgZnJvbSBwb2ludCBgeDEseTFgIHRvIHBvaW50IGB4Mix5MmAuXG5mdW5jdGlvbiBsaW5lKGN0eCwgeDEsIHkxLCB4MiwgeTIpIHtcbiAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgY3R4Lm1vdmVUbyh4MSwgeTEpO1xuICAgIGN0eC5saW5lVG8oeDIsIHkyKTtcbiAgICBjdHguc3Ryb2tlKCk7XG59XG5cbnZhciBkcmF3ID0geyBsaW5lOiBsaW5lIH07XG5cbi8vIFRoZSBHbHlwaCBvYmplY3Rcbi8vIGltcG9ydCBnbHlmIGZyb20gJy4vdGFibGVzL2dseWYnIENhbid0IGJlIGltcG9ydGVkIGhlcmUsIGJlY2F1c2UgaXQncyBhIGNpcmN1bGFyIGRlcGVuZGVuY3lcblxuZnVuY3Rpb24gZ2V0UGF0aERlZmluaXRpb24oZ2x5cGgsIHBhdGgpIHtcbiAgICB2YXIgX3BhdGggPSBwYXRoIHx8IG5ldyBQYXRoKCk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuXG4gICAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIF9wYXRoID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgX3BhdGggPSBfcGF0aCgpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gX3BhdGg7XG4gICAgICAgIH0sXG5cbiAgICAgICAgc2V0OiBmdW5jdGlvbihwKSB7XG4gICAgICAgICAgICBfcGF0aCA9IHA7XG4gICAgICAgIH1cbiAgICB9O1xufVxuLyoqXG4gKiBAdHlwZWRlZiBHbHlwaE9wdGlvbnNcbiAqIEB0eXBlIE9iamVjdFxuICogQHByb3BlcnR5IHtzdHJpbmd9IFtuYW1lXSAtIFRoZSBnbHlwaCBuYW1lXG4gKiBAcHJvcGVydHkge251bWJlcn0gW3VuaWNvZGVdXG4gKiBAcHJvcGVydHkge0FycmF5fSBbdW5pY29kZXNdXG4gKiBAcHJvcGVydHkge251bWJlcn0gW3hNaW5dXG4gKiBAcHJvcGVydHkge251bWJlcn0gW3lNaW5dXG4gKiBAcHJvcGVydHkge251bWJlcn0gW3hNYXhdXG4gKiBAcHJvcGVydHkge251bWJlcn0gW3lNYXhdXG4gKiBAcHJvcGVydHkge251bWJlcn0gW2FkdmFuY2VXaWR0aF1cbiAqL1xuXG4vLyBBIEdseXBoIGlzIGFuIGluZGl2aWR1YWwgbWFyayB0aGF0IG9mdGVuIGNvcnJlc3BvbmRzIHRvIGEgY2hhcmFjdGVyLlxuLy8gU29tZSBnbHlwaHMsIHN1Y2ggYXMgbGlnYXR1cmVzLCBhcmUgYSBjb21iaW5hdGlvbiBvZiBtYW55IGNoYXJhY3RlcnMuXG4vLyBHbHlwaHMgYXJlIHRoZSBiYXNpYyBidWlsZGluZyBibG9ja3Mgb2YgYSBmb250LlxuLy9cbi8vIFRoZSBgR2x5cGhgIGNsYXNzIGNvbnRhaW5zIHV0aWxpdHkgbWV0aG9kcyBmb3IgZHJhd2luZyB0aGUgcGF0aCBhbmQgaXRzIHBvaW50cy5cbi8qKlxuICogQGV4cG9ydHMgb3BlbnR5cGUuR2x5cGhcbiAqIEBjbGFzc1xuICogQHBhcmFtIHtHbHlwaE9wdGlvbnN9XG4gKiBAY29uc3RydWN0b3JcbiAqL1xuZnVuY3Rpb24gR2x5cGgob3B0aW9ucykge1xuICAgIC8vIEJ5IHB1dHRpbmcgYWxsIHRoZSBjb2RlIG9uIGEgcHJvdG90eXBlIGZ1bmN0aW9uICh3aGljaCBpcyBvbmx5IGRlY2xhcmVkIG9uY2UpXG4gICAgLy8gd2UgcmVkdWNlIHRoZSBtZW1vcnkgcmVxdWlyZW1lbnRzIGZvciBsYXJnZXIgZm9udHMgYnkgc29tZSAyJVxuICAgIHRoaXMuYmluZENvbnN0cnVjdG9yVmFsdWVzKG9wdGlvbnMpO1xufVxuXG4vKipcbiAqIEBwYXJhbSAge0dseXBoT3B0aW9uc31cbiAqL1xuR2x5cGgucHJvdG90eXBlLmJpbmRDb25zdHJ1Y3RvclZhbHVlcyA9IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICB0aGlzLmluZGV4ID0gb3B0aW9ucy5pbmRleCB8fCAwO1xuXG4gICAgLy8gVGhlc2UgdGhyZWUgdmFsdWVzIGNhbm5vdCBiZSBkZWZlcnJlZCBmb3IgbWVtb3J5IG9wdGltaXphdGlvbjpcbiAgICB0aGlzLm5hbWUgPSBvcHRpb25zLm5hbWUgfHwgbnVsbDtcbiAgICB0aGlzLnVuaWNvZGUgPSBvcHRpb25zLnVuaWNvZGUgfHwgdW5kZWZpbmVkO1xuICAgIHRoaXMudW5pY29kZXMgPSBvcHRpb25zLnVuaWNvZGVzIHx8IG9wdGlvbnMudW5pY29kZSAhPT0gdW5kZWZpbmVkID8gW29wdGlvbnMudW5pY29kZV0gOiBbXTtcblxuICAgIC8vIEJ1dCBieSBiaW5kaW5nIHRoZXNlIHZhbHVlcyBvbmx5IHdoZW4gbmVjZXNzYXJ5LCB3ZSByZWR1Y2UgY2FuXG4gICAgLy8gdGhlIG1lbW9yeSByZXF1aXJlbWVudHMgYnkgYWxtb3N0IDMlIGZvciBsYXJnZXIgZm9udHMuXG4gICAgaWYgKCd4TWluJyBpbiBvcHRpb25zKSB7XG4gICAgICAgIHRoaXMueE1pbiA9IG9wdGlvbnMueE1pbjtcbiAgICB9XG5cbiAgICBpZiAoJ3lNaW4nIGluIG9wdGlvbnMpIHtcbiAgICAgICAgdGhpcy55TWluID0gb3B0aW9ucy55TWluO1xuICAgIH1cblxuICAgIGlmICgneE1heCcgaW4gb3B0aW9ucykge1xuICAgICAgICB0aGlzLnhNYXggPSBvcHRpb25zLnhNYXg7XG4gICAgfVxuXG4gICAgaWYgKCd5TWF4JyBpbiBvcHRpb25zKSB7XG4gICAgICAgIHRoaXMueU1heCA9IG9wdGlvbnMueU1heDtcbiAgICB9XG5cbiAgICBpZiAoJ2FkdmFuY2VXaWR0aCcgaW4gb3B0aW9ucykge1xuICAgICAgICB0aGlzLmFkdmFuY2VXaWR0aCA9IG9wdGlvbnMuYWR2YW5jZVdpZHRoO1xuICAgIH1cblxuICAgIC8vIFRoZSBwYXRoIGZvciBhIGdseXBoIGlzIHRoZSBtb3N0IG1lbW9yeSBpbnRlbnNpdmUsIGFuZCBpcyBib3VuZCBhcyBhIHZhbHVlXG4gICAgLy8gd2l0aCBhIGdldHRlci9zZXR0ZXIgdG8gZW5zdXJlIHdlIGFjdHVhbGx5IGRvIHBhdGggcGFyc2luZyBvbmx5IG9uY2UgdGhlXG4gICAgLy8gcGF0aCBpcyBhY3R1YWxseSBuZWVkZWQgYnkgYW55dGhpbmcuXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsICdwYXRoJywgZ2V0UGF0aERlZmluaXRpb24odGhpcywgb3B0aW9ucy5wYXRoKSk7XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7bnVtYmVyfVxuICovXG5HbHlwaC5wcm90b3R5cGUuYWRkVW5pY29kZSA9IGZ1bmN0aW9uKHVuaWNvZGUpIHtcbiAgICBpZiAodGhpcy51bmljb2Rlcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgdGhpcy51bmljb2RlID0gdW5pY29kZTtcbiAgICB9XG5cbiAgICB0aGlzLnVuaWNvZGVzLnB1c2godW5pY29kZSk7XG59O1xuXG4vKipcbiAqIENhbGN1bGF0ZSB0aGUgbWluaW11bSBib3VuZGluZyBib3ggZm9yIHRoaXMgZ2x5cGguXG4gKiBAcmV0dXJuIHtvcGVudHlwZS5Cb3VuZGluZ0JveH1cbiAqL1xuR2x5cGgucHJvdG90eXBlLmdldEJvdW5kaW5nQm94ID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMucGF0aC5nZXRCb3VuZGluZ0JveCgpO1xufTtcblxuLyoqXG4gKiBDb252ZXJ0IHRoZSBnbHlwaCB0byBhIFBhdGggd2UgY2FuIGRyYXcgb24gYSBkcmF3aW5nIGNvbnRleHQuXG4gKiBAcGFyYW0gIHtudW1iZXJ9IFt4PTBdIC0gSG9yaXpvbnRhbCBwb3NpdGlvbiBvZiB0aGUgYmVnaW5uaW5nIG9mIHRoZSB0ZXh0LlxuICogQHBhcmFtICB7bnVtYmVyfSBbeT0wXSAtIFZlcnRpY2FsIHBvc2l0aW9uIG9mIHRoZSAqYmFzZWxpbmUqIG9mIHRoZSB0ZXh0LlxuICogQHBhcmFtICB7bnVtYmVyfSBbZm9udFNpemU9NzJdIC0gRm9udCBzaXplIGluIHBpeGVscy4gV2Ugc2NhbGUgdGhlIGdseXBoIHVuaXRzIGJ5IGAxIC8gdW5pdHNQZXJFbSAqIGZvbnRTaXplYC5cbiAqIEBwYXJhbSAge09iamVjdD19IG9wdGlvbnMgLSB4U2NhbGUsIHlTY2FsZSB0byBzdHJldGNoIHRoZSBnbHlwaC5cbiAqIEBwYXJhbSAge29wZW50eXBlLkZvbnR9IGlmIGhpbnRpbmcgaXMgdG8gYmUgdXNlZCwgdGhlIGZvbnRcbiAqIEByZXR1cm4ge29wZW50eXBlLlBhdGh9XG4gKi9cbkdseXBoLnByb3RvdHlwZS5nZXRQYXRoID0gZnVuY3Rpb24oeCwgeSwgZm9udFNpemUsIG9wdGlvbnMsIGZvbnQpIHtcbiAgICB4ID0geCAhPT0gdW5kZWZpbmVkID8geCA6IDA7XG4gICAgeSA9IHkgIT09IHVuZGVmaW5lZCA/IHkgOiAwO1xuICAgIGZvbnRTaXplID0gZm9udFNpemUgIT09IHVuZGVmaW5lZCA/IGZvbnRTaXplIDogNzI7XG4gICAgdmFyIGNvbW1hbmRzO1xuICAgIHZhciBoUG9pbnRzO1xuICAgIGlmICghb3B0aW9ucykgeyBvcHRpb25zID0geyB9OyB9XG4gICAgdmFyIHhTY2FsZSA9IG9wdGlvbnMueFNjYWxlO1xuICAgIHZhciB5U2NhbGUgPSBvcHRpb25zLnlTY2FsZTtcblxuICAgIGlmIChvcHRpb25zLmhpbnRpbmcgJiYgZm9udCAmJiBmb250LmhpbnRpbmcpIHtcbiAgICAgICAgLy8gaW4gY2FzZSBvZiBoaW50aW5nLCB0aGUgaGludGluZyBlbmdpbmUgdGFrZXMgY2FyZVxuICAgICAgICAvLyBvZiBzY2FsaW5nIHRoZSBwb2ludHMgKG5vdCB0aGUgcGF0aCkgYmVmb3JlIGhpbnRpbmcuXG4gICAgICAgIGhQb2ludHMgPSB0aGlzLnBhdGggJiYgZm9udC5oaW50aW5nLmV4ZWModGhpcywgZm9udFNpemUpO1xuICAgICAgICAvLyBpbiBjYXNlIHRoZSBoaW50aW5nIGVuZ2luZSBmYWlsZWQgaFBvaW50cyBpcyB1bmRlZmluZWRcbiAgICAgICAgLy8gYW5kIHRodXMgcmV2ZXJ0cyB0byBwbGFpbiByZW5kaW5nXG4gICAgfVxuXG4gICAgaWYgKGhQb2ludHMpIHtcbiAgICAgICAgLy8gQ2FsbCBmb250LmhpbnRpbmcuZ2V0Q29tbWFuZHMgaW5zdGVhZCBvZiBgZ2x5Zi5nZXRQYXRoKGhQb2ludHMpLmNvbW1hbmRzYCB0byBhdm9pZCBhIGNpcmN1bGFyIGRlcGVuZGVuY3lcbiAgICAgICAgY29tbWFuZHMgPSBmb250LmhpbnRpbmcuZ2V0Q29tbWFuZHMoaFBvaW50cyk7XG4gICAgICAgIHggPSBNYXRoLnJvdW5kKHgpO1xuICAgICAgICB5ID0gTWF0aC5yb3VuZCh5KTtcbiAgICAgICAgLy8gVE9ETyBpbiBjYXNlIG9mIGhpbnRpbmcgeHlTY2FsaW5nIGlzIG5vdCB5ZXQgc3VwcG9ydGVkXG4gICAgICAgIHhTY2FsZSA9IHlTY2FsZSA9IDE7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgY29tbWFuZHMgPSB0aGlzLnBhdGguY29tbWFuZHM7XG4gICAgICAgIHZhciBzY2FsZSA9IDEgLyAodGhpcy5wYXRoLnVuaXRzUGVyRW0gfHwgMTAwMCkgKiBmb250U2l6ZTtcbiAgICAgICAgaWYgKHhTY2FsZSA9PT0gdW5kZWZpbmVkKSB7IHhTY2FsZSA9IHNjYWxlOyB9XG4gICAgICAgIGlmICh5U2NhbGUgPT09IHVuZGVmaW5lZCkgeyB5U2NhbGUgPSBzY2FsZTsgfVxuICAgIH1cblxuICAgIHZhciBwID0gbmV3IFBhdGgoKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNvbW1hbmRzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgIHZhciBjbWQgPSBjb21tYW5kc1tpXTtcbiAgICAgICAgaWYgKGNtZC50eXBlID09PSAnTScpIHtcbiAgICAgICAgICAgIHAubW92ZVRvKHggKyAoY21kLnggKiB4U2NhbGUpLCB5ICsgKC1jbWQueSAqIHlTY2FsZSkpO1xuICAgICAgICB9IGVsc2UgaWYgKGNtZC50eXBlID09PSAnTCcpIHtcbiAgICAgICAgICAgIHAubGluZVRvKHggKyAoY21kLnggKiB4U2NhbGUpLCB5ICsgKC1jbWQueSAqIHlTY2FsZSkpO1xuICAgICAgICB9IGVsc2UgaWYgKGNtZC50eXBlID09PSAnUScpIHtcbiAgICAgICAgICAgIHAucXVhZHJhdGljQ3VydmVUbyh4ICsgKGNtZC54MSAqIHhTY2FsZSksIHkgKyAoLWNtZC55MSAqIHlTY2FsZSksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeCArIChjbWQueCAqIHhTY2FsZSksIHkgKyAoLWNtZC55ICogeVNjYWxlKSk7XG4gICAgICAgIH0gZWxzZSBpZiAoY21kLnR5cGUgPT09ICdDJykge1xuICAgICAgICAgICAgcC5jdXJ2ZVRvKHggKyAoY21kLngxICogeFNjYWxlKSwgeSArICgtY21kLnkxICogeVNjYWxlKSxcbiAgICAgICAgICAgICAgICAgICAgICB4ICsgKGNtZC54MiAqIHhTY2FsZSksIHkgKyAoLWNtZC55MiAqIHlTY2FsZSksXG4gICAgICAgICAgICAgICAgICAgICAgeCArIChjbWQueCAqIHhTY2FsZSksIHkgKyAoLWNtZC55ICogeVNjYWxlKSk7XG4gICAgICAgIH0gZWxzZSBpZiAoY21kLnR5cGUgPT09ICdaJykge1xuICAgICAgICAgICAgcC5jbG9zZVBhdGgoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBwO1xufTtcblxuLyoqXG4gKiBTcGxpdCB0aGUgZ2x5cGggaW50byBjb250b3Vycy5cbiAqIFRoaXMgZnVuY3Rpb24gaXMgaGVyZSBmb3IgYmFja3dhcmRzIGNvbXBhdGliaWxpdHksIGFuZCB0b1xuICogcHJvdmlkZSByYXcgYWNjZXNzIHRvIHRoZSBUcnVlVHlwZSBnbHlwaCBvdXRsaW5lcy5cbiAqIEByZXR1cm4ge0FycmF5fVxuICovXG5HbHlwaC5wcm90b3R5cGUuZ2V0Q29udG91cnMgPSBmdW5jdGlvbigpIHtcbiAgICBpZiAodGhpcy5wb2ludHMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gW107XG4gICAgfVxuXG4gICAgdmFyIGNvbnRvdXJzID0gW107XG4gICAgdmFyIGN1cnJlbnRDb250b3VyID0gW107XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLnBvaW50cy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICB2YXIgcHQgPSB0aGlzLnBvaW50c1tpXTtcbiAgICAgICAgY3VycmVudENvbnRvdXIucHVzaChwdCk7XG4gICAgICAgIGlmIChwdC5sYXN0UG9pbnRPZkNvbnRvdXIpIHtcbiAgICAgICAgICAgIGNvbnRvdXJzLnB1c2goY3VycmVudENvbnRvdXIpO1xuICAgICAgICAgICAgY3VycmVudENvbnRvdXIgPSBbXTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGNoZWNrLmFyZ3VtZW50KGN1cnJlbnRDb250b3VyLmxlbmd0aCA9PT0gMCwgJ1RoZXJlIGFyZSBzdGlsbCBwb2ludHMgbGVmdCBpbiB0aGUgY3VycmVudCBjb250b3VyLicpO1xuICAgIHJldHVybiBjb250b3Vycztcbn07XG5cbi8qKlxuICogQ2FsY3VsYXRlIHRoZSB4TWluL3lNaW4veE1heC95TWF4L2xzYi9yc2IgZm9yIGEgR2x5cGguXG4gKiBAcmV0dXJuIHtPYmplY3R9XG4gKi9cbkdseXBoLnByb3RvdHlwZS5nZXRNZXRyaWNzID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGNvbW1hbmRzID0gdGhpcy5wYXRoLmNvbW1hbmRzO1xuICAgIHZhciB4Q29vcmRzID0gW107XG4gICAgdmFyIHlDb29yZHMgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNvbW1hbmRzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgIHZhciBjbWQgPSBjb21tYW5kc1tpXTtcbiAgICAgICAgaWYgKGNtZC50eXBlICE9PSAnWicpIHtcbiAgICAgICAgICAgIHhDb29yZHMucHVzaChjbWQueCk7XG4gICAgICAgICAgICB5Q29vcmRzLnB1c2goY21kLnkpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGNtZC50eXBlID09PSAnUScgfHwgY21kLnR5cGUgPT09ICdDJykge1xuICAgICAgICAgICAgeENvb3Jkcy5wdXNoKGNtZC54MSk7XG4gICAgICAgICAgICB5Q29vcmRzLnB1c2goY21kLnkxKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChjbWQudHlwZSA9PT0gJ0MnKSB7XG4gICAgICAgICAgICB4Q29vcmRzLnB1c2goY21kLngyKTtcbiAgICAgICAgICAgIHlDb29yZHMucHVzaChjbWQueTIpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgdmFyIG1ldHJpY3MgPSB7XG4gICAgICAgIHhNaW46IE1hdGgubWluLmFwcGx5KG51bGwsIHhDb29yZHMpLFxuICAgICAgICB5TWluOiBNYXRoLm1pbi5hcHBseShudWxsLCB5Q29vcmRzKSxcbiAgICAgICAgeE1heDogTWF0aC5tYXguYXBwbHkobnVsbCwgeENvb3JkcyksXG4gICAgICAgIHlNYXg6IE1hdGgubWF4LmFwcGx5KG51bGwsIHlDb29yZHMpLFxuICAgICAgICBsZWZ0U2lkZUJlYXJpbmc6IHRoaXMubGVmdFNpZGVCZWFyaW5nXG4gICAgfTtcblxuICAgIGlmICghaXNGaW5pdGUobWV0cmljcy54TWluKSkge1xuICAgICAgICBtZXRyaWNzLnhNaW4gPSAwO1xuICAgIH1cblxuICAgIGlmICghaXNGaW5pdGUobWV0cmljcy54TWF4KSkge1xuICAgICAgICBtZXRyaWNzLnhNYXggPSB0aGlzLmFkdmFuY2VXaWR0aDtcbiAgICB9XG5cbiAgICBpZiAoIWlzRmluaXRlKG1ldHJpY3MueU1pbikpIHtcbiAgICAgICAgbWV0cmljcy55TWluID0gMDtcbiAgICB9XG5cbiAgICBpZiAoIWlzRmluaXRlKG1ldHJpY3MueU1heCkpIHtcbiAgICAgICAgbWV0cmljcy55TWF4ID0gMDtcbiAgICB9XG5cbiAgICBtZXRyaWNzLnJpZ2h0U2lkZUJlYXJpbmcgPSB0aGlzLmFkdmFuY2VXaWR0aCAtIG1ldHJpY3MubGVmdFNpZGVCZWFyaW5nIC0gKG1ldHJpY3MueE1heCAtIG1ldHJpY3MueE1pbik7XG4gICAgcmV0dXJuIG1ldHJpY3M7XG59O1xuXG4vKipcbiAqIERyYXcgdGhlIGdseXBoIG9uIHRoZSBnaXZlbiBjb250ZXh0LlxuICogQHBhcmFtICB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHggLSBBIDJEIGRyYXdpbmcgY29udGV4dCwgbGlrZSBDYW52YXMuXG4gKiBAcGFyYW0gIHtudW1iZXJ9IFt4PTBdIC0gSG9yaXpvbnRhbCBwb3NpdGlvbiBvZiB0aGUgYmVnaW5uaW5nIG9mIHRoZSB0ZXh0LlxuICogQHBhcmFtICB7bnVtYmVyfSBbeT0wXSAtIFZlcnRpY2FsIHBvc2l0aW9uIG9mIHRoZSAqYmFzZWxpbmUqIG9mIHRoZSB0ZXh0LlxuICogQHBhcmFtICB7bnVtYmVyfSBbZm9udFNpemU9NzJdIC0gRm9udCBzaXplIGluIHBpeGVscy4gV2Ugc2NhbGUgdGhlIGdseXBoIHVuaXRzIGJ5IGAxIC8gdW5pdHNQZXJFbSAqIGZvbnRTaXplYC5cbiAqIEBwYXJhbSAge09iamVjdD19IG9wdGlvbnMgLSB4U2NhbGUsIHlTY2FsZSB0byBzdHJldGNoIHRoZSBnbHlwaC5cbiAqL1xuR2x5cGgucHJvdG90eXBlLmRyYXcgPSBmdW5jdGlvbihjdHgsIHgsIHksIGZvbnRTaXplLCBvcHRpb25zKSB7XG4gICAgdGhpcy5nZXRQYXRoKHgsIHksIGZvbnRTaXplLCBvcHRpb25zKS5kcmF3KGN0eCk7XG59O1xuXG4vKipcbiAqIERyYXcgdGhlIHBvaW50cyBvZiB0aGUgZ2x5cGguXG4gKiBPbi1jdXJ2ZSBwb2ludHMgd2lsbCBiZSBkcmF3biBpbiBibHVlLCBvZmYtY3VydmUgcG9pbnRzIHdpbGwgYmUgZHJhd24gaW4gcmVkLlxuICogQHBhcmFtICB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHggLSBBIDJEIGRyYXdpbmcgY29udGV4dCwgbGlrZSBDYW52YXMuXG4gKiBAcGFyYW0gIHtudW1iZXJ9IFt4PTBdIC0gSG9yaXpvbnRhbCBwb3NpdGlvbiBvZiB0aGUgYmVnaW5uaW5nIG9mIHRoZSB0ZXh0LlxuICogQHBhcmFtICB7bnVtYmVyfSBbeT0wXSAtIFZlcnRpY2FsIHBvc2l0aW9uIG9mIHRoZSAqYmFzZWxpbmUqIG9mIHRoZSB0ZXh0LlxuICogQHBhcmFtICB7bnVtYmVyfSBbZm9udFNpemU9NzJdIC0gRm9udCBzaXplIGluIHBpeGVscy4gV2Ugc2NhbGUgdGhlIGdseXBoIHVuaXRzIGJ5IGAxIC8gdW5pdHNQZXJFbSAqIGZvbnRTaXplYC5cbiAqL1xuR2x5cGgucHJvdG90eXBlLmRyYXdQb2ludHMgPSBmdW5jdGlvbihjdHgsIHgsIHksIGZvbnRTaXplKSB7XG4gICAgZnVuY3Rpb24gZHJhd0NpcmNsZXMobCwgeCwgeSwgc2NhbGUpIHtcbiAgICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGwubGVuZ3RoOyBqICs9IDEpIHtcbiAgICAgICAgICAgIGN0eC5tb3ZlVG8oeCArIChsW2pdLnggKiBzY2FsZSksIHkgKyAobFtqXS55ICogc2NhbGUpKTtcbiAgICAgICAgICAgIGN0eC5hcmMoeCArIChsW2pdLnggKiBzY2FsZSksIHkgKyAobFtqXS55ICogc2NhbGUpLCAyLCAwLCBNYXRoLlBJICogMiwgZmFsc2UpO1xuICAgICAgICB9XG5cbiAgICAgICAgY3R4LmNsb3NlUGF0aCgpO1xuICAgICAgICBjdHguZmlsbCgpO1xuICAgIH1cblxuICAgIHggPSB4ICE9PSB1bmRlZmluZWQgPyB4IDogMDtcbiAgICB5ID0geSAhPT0gdW5kZWZpbmVkID8geSA6IDA7XG4gICAgZm9udFNpemUgPSBmb250U2l6ZSAhPT0gdW5kZWZpbmVkID8gZm9udFNpemUgOiAyNDtcbiAgICB2YXIgc2NhbGUgPSAxIC8gdGhpcy5wYXRoLnVuaXRzUGVyRW0gKiBmb250U2l6ZTtcblxuICAgIHZhciBibHVlQ2lyY2xlcyA9IFtdO1xuICAgIHZhciByZWRDaXJjbGVzID0gW107XG4gICAgdmFyIHBhdGggPSB0aGlzLnBhdGg7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwYXRoLmNvbW1hbmRzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgIHZhciBjbWQgPSBwYXRoLmNvbW1hbmRzW2ldO1xuICAgICAgICBpZiAoY21kLnggIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgYmx1ZUNpcmNsZXMucHVzaCh7eDogY21kLngsIHk6IC1jbWQueX0pO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGNtZC54MSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZWRDaXJjbGVzLnB1c2goe3g6IGNtZC54MSwgeTogLWNtZC55MX0pO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGNtZC54MiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZWRDaXJjbGVzLnB1c2goe3g6IGNtZC54MiwgeTogLWNtZC55Mn0pO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgY3R4LmZpbGxTdHlsZSA9ICdibHVlJztcbiAgICBkcmF3Q2lyY2xlcyhibHVlQ2lyY2xlcywgeCwgeSwgc2NhbGUpO1xuICAgIGN0eC5maWxsU3R5bGUgPSAncmVkJztcbiAgICBkcmF3Q2lyY2xlcyhyZWRDaXJjbGVzLCB4LCB5LCBzY2FsZSk7XG59O1xuXG4vKipcbiAqIERyYXcgbGluZXMgaW5kaWNhdGluZyBpbXBvcnRhbnQgZm9udCBtZWFzdXJlbWVudHMuXG4gKiBCbGFjayBsaW5lcyBpbmRpY2F0ZSB0aGUgb3JpZ2luIG9mIHRoZSBjb29yZGluYXRlIHN5c3RlbSAocG9pbnQgMCwwKS5cbiAqIEJsdWUgbGluZXMgaW5kaWNhdGUgdGhlIGdseXBoIGJvdW5kaW5nIGJveC5cbiAqIEdyZWVuIGxpbmUgaW5kaWNhdGVzIHRoZSBhZHZhbmNlIHdpZHRoIG9mIHRoZSBnbHlwaC5cbiAqIEBwYXJhbSAge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4IC0gQSAyRCBkcmF3aW5nIGNvbnRleHQsIGxpa2UgQ2FudmFzLlxuICogQHBhcmFtICB7bnVtYmVyfSBbeD0wXSAtIEhvcml6b250YWwgcG9zaXRpb24gb2YgdGhlIGJlZ2lubmluZyBvZiB0aGUgdGV4dC5cbiAqIEBwYXJhbSAge251bWJlcn0gW3k9MF0gLSBWZXJ0aWNhbCBwb3NpdGlvbiBvZiB0aGUgKmJhc2VsaW5lKiBvZiB0aGUgdGV4dC5cbiAqIEBwYXJhbSAge251bWJlcn0gW2ZvbnRTaXplPTcyXSAtIEZvbnQgc2l6ZSBpbiBwaXhlbHMuIFdlIHNjYWxlIHRoZSBnbHlwaCB1bml0cyBieSBgMSAvIHVuaXRzUGVyRW0gKiBmb250U2l6ZWAuXG4gKi9cbkdseXBoLnByb3RvdHlwZS5kcmF3TWV0cmljcyA9IGZ1bmN0aW9uKGN0eCwgeCwgeSwgZm9udFNpemUpIHtcbiAgICB2YXIgc2NhbGU7XG4gICAgeCA9IHggIT09IHVuZGVmaW5lZCA/IHggOiAwO1xuICAgIHkgPSB5ICE9PSB1bmRlZmluZWQgPyB5IDogMDtcbiAgICBmb250U2l6ZSA9IGZvbnRTaXplICE9PSB1bmRlZmluZWQgPyBmb250U2l6ZSA6IDI0O1xuICAgIHNjYWxlID0gMSAvIHRoaXMucGF0aC51bml0c1BlckVtICogZm9udFNpemU7XG4gICAgY3R4LmxpbmVXaWR0aCA9IDE7XG5cbiAgICAvLyBEcmF3IHRoZSBvcmlnaW5cbiAgICBjdHguc3Ryb2tlU3R5bGUgPSAnYmxhY2snO1xuICAgIGRyYXcubGluZShjdHgsIHgsIC0xMDAwMCwgeCwgMTAwMDApO1xuICAgIGRyYXcubGluZShjdHgsIC0xMDAwMCwgeSwgMTAwMDAsIHkpO1xuXG4gICAgLy8gVGhpcyBjb2RlIGlzIGhlcmUgZHVlIHRvIG1lbW9yeSBvcHRpbWl6YXRpb246IGJ5IG5vdCB1c2luZ1xuICAgIC8vIGRlZmF1bHRzIGluIHRoZSBjb25zdHJ1Y3Rvciwgd2Ugc2F2ZSBhIG5vdGFibGUgYW1vdW50IG9mIG1lbW9yeS5cbiAgICB2YXIgeE1pbiA9IHRoaXMueE1pbiB8fCAwO1xuICAgIHZhciB5TWluID0gdGhpcy55TWluIHx8IDA7XG4gICAgdmFyIHhNYXggPSB0aGlzLnhNYXggfHwgMDtcbiAgICB2YXIgeU1heCA9IHRoaXMueU1heCB8fCAwO1xuICAgIHZhciBhZHZhbmNlV2lkdGggPSB0aGlzLmFkdmFuY2VXaWR0aCB8fCAwO1xuXG4gICAgLy8gRHJhdyB0aGUgZ2x5cGggYm94XG4gICAgY3R4LnN0cm9rZVN0eWxlID0gJ2JsdWUnO1xuICAgIGRyYXcubGluZShjdHgsIHggKyAoeE1pbiAqIHNjYWxlKSwgLTEwMDAwLCB4ICsgKHhNaW4gKiBzY2FsZSksIDEwMDAwKTtcbiAgICBkcmF3LmxpbmUoY3R4LCB4ICsgKHhNYXggKiBzY2FsZSksIC0xMDAwMCwgeCArICh4TWF4ICogc2NhbGUpLCAxMDAwMCk7XG4gICAgZHJhdy5saW5lKGN0eCwgLTEwMDAwLCB5ICsgKC15TWluICogc2NhbGUpLCAxMDAwMCwgeSArICgteU1pbiAqIHNjYWxlKSk7XG4gICAgZHJhdy5saW5lKGN0eCwgLTEwMDAwLCB5ICsgKC15TWF4ICogc2NhbGUpLCAxMDAwMCwgeSArICgteU1heCAqIHNjYWxlKSk7XG5cbiAgICAvLyBEcmF3IHRoZSBhZHZhbmNlIHdpZHRoXG4gICAgY3R4LnN0cm9rZVN0eWxlID0gJ2dyZWVuJztcbiAgICBkcmF3LmxpbmUoY3R4LCB4ICsgKGFkdmFuY2VXaWR0aCAqIHNjYWxlKSwgLTEwMDAwLCB4ICsgKGFkdmFuY2VXaWR0aCAqIHNjYWxlKSwgMTAwMDApO1xufTtcblxuLy8gVGhlIEdseXBoU2V0IG9iamVjdFxuXG4vLyBEZWZpbmUgYSBwcm9wZXJ0eSBvbiB0aGUgZ2x5cGggdGhhdCBkZXBlbmRzIG9uIHRoZSBwYXRoIGJlaW5nIGxvYWRlZC5cbmZ1bmN0aW9uIGRlZmluZURlcGVuZGVudFByb3BlcnR5KGdseXBoLCBleHRlcm5hbE5hbWUsIGludGVybmFsTmFtZSkge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShnbHlwaCwgZXh0ZXJuYWxOYW1lLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAvLyBSZXF1ZXN0IHRoZSBwYXRoIHByb3BlcnR5IHRvIG1ha2Ugc3VyZSB0aGUgcGF0aCBpcyBsb2FkZWQuXG4gICAgICAgICAgICBnbHlwaC5wYXRoOyAvLyBqc2hpbnQgaWdub3JlOmxpbmVcbiAgICAgICAgICAgIHJldHVybiBnbHlwaFtpbnRlcm5hbE5hbWVdO1xuICAgICAgICB9LFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uKG5ld1ZhbHVlKSB7XG4gICAgICAgICAgICBnbHlwaFtpbnRlcm5hbE5hbWVdID0gbmV3VmFsdWU7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xufVxuXG4vKipcbiAqIEEgR2x5cGhTZXQgcmVwcmVzZW50cyBhbGwgZ2x5cGhzIGF2YWlsYWJsZSBpbiB0aGUgZm9udCwgYnV0IG1vZGVsbGVkIHVzaW5nXG4gKiBhIGRlZmVycmVkIGdseXBoIGxvYWRlciwgZm9yIHJldHJpZXZpbmcgZ2x5cGhzIG9ubHkgb25jZSB0aGV5IGFyZSBhYnNvbHV0ZWx5XG4gKiBuZWNlc3NhcnksIHRvIGtlZXAgdGhlIG1lbW9yeSBmb290cHJpbnQgZG93bi5cbiAqIEBleHBvcnRzIG9wZW50eXBlLkdseXBoU2V0XG4gKiBAY2xhc3NcbiAqIEBwYXJhbSB7b3BlbnR5cGUuRm9udH1cbiAqIEBwYXJhbSB7QXJyYXl9XG4gKi9cbmZ1bmN0aW9uIEdseXBoU2V0KGZvbnQsIGdseXBocykge1xuICAgIHRoaXMuZm9udCA9IGZvbnQ7XG4gICAgdGhpcy5nbHlwaHMgPSB7fTtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShnbHlwaHMpKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZ2x5cGhzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgZ2x5cGggPSBnbHlwaHNbaV07XG4gICAgICAgICAgICBnbHlwaC5wYXRoLnVuaXRzUGVyRW0gPSBmb250LnVuaXRzUGVyRW07XG4gICAgICAgICAgICB0aGlzLmdseXBoc1tpXSA9IGdseXBoO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy5sZW5ndGggPSAoZ2x5cGhzICYmIGdseXBocy5sZW5ndGgpIHx8IDA7XG59XG5cbi8qKlxuICogQHBhcmFtICB7bnVtYmVyfSBpbmRleFxuICogQHJldHVybiB7b3BlbnR5cGUuR2x5cGh9XG4gKi9cbkdseXBoU2V0LnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbihpbmRleCkge1xuICAgIC8vIHRoaXMuZ2x5cGhzW2luZGV4XSBpcyAndW5kZWZpbmVkJyB3aGVuIGxvdyBtZW1vcnkgbW9kZSBpcyBvbi4gZ2x5cGggaXMgcHVzaGVkIG9uIHJlcXVlc3Qgb25seS5cbiAgICBpZiAodGhpcy5nbHlwaHNbaW5kZXhdID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhpcy5mb250Ll9wdXNoKGluZGV4KTtcbiAgICAgICAgaWYgKHR5cGVvZiB0aGlzLmdseXBoc1tpbmRleF0gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHRoaXMuZ2x5cGhzW2luZGV4XSA9IHRoaXMuZ2x5cGhzW2luZGV4XSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGdseXBoID0gdGhpcy5nbHlwaHNbaW5kZXhdO1xuICAgICAgICB2YXIgdW5pY29kZU9iaiA9IHRoaXMuZm9udC5fSW5kZXhUb1VuaWNvZGVNYXBbaW5kZXhdO1xuXG4gICAgICAgIGlmICh1bmljb2RlT2JqKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHVuaWNvZGVPYmoudW5pY29kZXMubGVuZ3RoOyBqKyspXG4gICAgICAgICAgICAgICAgeyBnbHlwaC5hZGRVbmljb2RlKHVuaWNvZGVPYmoudW5pY29kZXNbal0pOyB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5mb250LmNmZkVuY29kaW5nKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5mb250LmlzQ0lERm9udCkge1xuICAgICAgICAgICAgICAgIGdseXBoLm5hbWUgPSAnZ2lkJyArIGluZGV4O1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBnbHlwaC5uYW1lID0gdGhpcy5mb250LmNmZkVuY29kaW5nLmNoYXJzZXRbaW5kZXhdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKHRoaXMuZm9udC5nbHlwaE5hbWVzLm5hbWVzKSB7XG4gICAgICAgICAgICBnbHlwaC5uYW1lID0gdGhpcy5mb250LmdseXBoTmFtZXMuZ2x5cGhJbmRleFRvTmFtZShpbmRleCk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmdseXBoc1tpbmRleF0uYWR2YW5jZVdpZHRoID0gdGhpcy5mb250Ll9obXR4VGFibGVEYXRhW2luZGV4XS5hZHZhbmNlV2lkdGg7XG4gICAgICAgIHRoaXMuZ2x5cGhzW2luZGV4XS5sZWZ0U2lkZUJlYXJpbmcgPSB0aGlzLmZvbnQuX2htdHhUYWJsZURhdGFbaW5kZXhdLmxlZnRTaWRlQmVhcmluZztcbiAgICB9IGVsc2Uge1xuICAgICAgICBpZiAodHlwZW9mIHRoaXMuZ2x5cGhzW2luZGV4XSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgdGhpcy5nbHlwaHNbaW5kZXhdID0gdGhpcy5nbHlwaHNbaW5kZXhdKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5nbHlwaHNbaW5kZXhdO1xufTtcblxuLyoqXG4gKiBAcGFyYW0gIHtudW1iZXJ9IGluZGV4XG4gKiBAcGFyYW0gIHtPYmplY3R9XG4gKi9cbkdseXBoU2V0LnByb3RvdHlwZS5wdXNoID0gZnVuY3Rpb24oaW5kZXgsIGxvYWRlcikge1xuICAgIHRoaXMuZ2x5cGhzW2luZGV4XSA9IGxvYWRlcjtcbiAgICB0aGlzLmxlbmd0aCsrO1xufTtcblxuLyoqXG4gKiBAYWxpYXMgb3BlbnR5cGUuZ2x5cGhMb2FkZXJcbiAqIEBwYXJhbSAge29wZW50eXBlLkZvbnR9IGZvbnRcbiAqIEBwYXJhbSAge251bWJlcn0gaW5kZXhcbiAqIEByZXR1cm4ge29wZW50eXBlLkdseXBofVxuICovXG5mdW5jdGlvbiBnbHlwaExvYWRlcihmb250LCBpbmRleCkge1xuICAgIHJldHVybiBuZXcgR2x5cGgoe2luZGV4OiBpbmRleCwgZm9udDogZm9udH0pO1xufVxuXG4vKipcbiAqIEdlbmVyYXRlIGEgc3R1YiBnbHlwaCB0aGF0IGNhbiBiZSBmaWxsZWQgd2l0aCBhbGwgbWV0YWRhdGEgKmV4Y2VwdCpcbiAqIHRoZSBcInBvaW50c1wiIGFuZCBcInBhdGhcIiBwcm9wZXJ0aWVzLCB3aGljaCBtdXN0IGJlIGxvYWRlZCBvbmx5IG9uY2VcbiAqIHRoZSBnbHlwaCdzIHBhdGggaXMgYWN0dWFsbHkgcmVxdWVzdGVkIGZvciB0ZXh0IHNoYXBpbmcuXG4gKiBAYWxpYXMgb3BlbnR5cGUudHRmR2x5cGhMb2FkZXJcbiAqIEBwYXJhbSAge29wZW50eXBlLkZvbnR9IGZvbnRcbiAqIEBwYXJhbSAge251bWJlcn0gaW5kZXhcbiAqIEBwYXJhbSAge0Z1bmN0aW9ufSBwYXJzZUdseXBoXG4gKiBAcGFyYW0gIHtPYmplY3R9IGRhdGFcbiAqIEBwYXJhbSAge251bWJlcn0gcG9zaXRpb25cbiAqIEBwYXJhbSAge0Z1bmN0aW9ufSBidWlsZFBhdGhcbiAqIEByZXR1cm4ge29wZW50eXBlLkdseXBofVxuICovXG5mdW5jdGlvbiB0dGZHbHlwaExvYWRlcihmb250LCBpbmRleCwgcGFyc2VHbHlwaCwgZGF0YSwgcG9zaXRpb24sIGJ1aWxkUGF0aCkge1xuICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGdseXBoID0gbmV3IEdseXBoKHtpbmRleDogaW5kZXgsIGZvbnQ6IGZvbnR9KTtcblxuICAgICAgICBnbHlwaC5wYXRoID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBwYXJzZUdseXBoKGdseXBoLCBkYXRhLCBwb3NpdGlvbik7XG4gICAgICAgICAgICB2YXIgcGF0aCA9IGJ1aWxkUGF0aChmb250LmdseXBocywgZ2x5cGgpO1xuICAgICAgICAgICAgcGF0aC51bml0c1BlckVtID0gZm9udC51bml0c1BlckVtO1xuICAgICAgICAgICAgcmV0dXJuIHBhdGg7XG4gICAgICAgIH07XG5cbiAgICAgICAgZGVmaW5lRGVwZW5kZW50UHJvcGVydHkoZ2x5cGgsICd4TWluJywgJ194TWluJyk7XG4gICAgICAgIGRlZmluZURlcGVuZGVudFByb3BlcnR5KGdseXBoLCAneE1heCcsICdfeE1heCcpO1xuICAgICAgICBkZWZpbmVEZXBlbmRlbnRQcm9wZXJ0eShnbHlwaCwgJ3lNaW4nLCAnX3lNaW4nKTtcbiAgICAgICAgZGVmaW5lRGVwZW5kZW50UHJvcGVydHkoZ2x5cGgsICd5TWF4JywgJ195TWF4Jyk7XG5cbiAgICAgICAgcmV0dXJuIGdseXBoO1xuICAgIH07XG59XG4vKipcbiAqIEBhbGlhcyBvcGVudHlwZS5jZmZHbHlwaExvYWRlclxuICogQHBhcmFtICB7b3BlbnR5cGUuRm9udH0gZm9udFxuICogQHBhcmFtICB7bnVtYmVyfSBpbmRleFxuICogQHBhcmFtICB7RnVuY3Rpb259IHBhcnNlQ0ZGQ2hhcnN0cmluZ1xuICogQHBhcmFtICB7c3RyaW5nfSBjaGFyc3RyaW5nXG4gKiBAcmV0dXJuIHtvcGVudHlwZS5HbHlwaH1cbiAqL1xuZnVuY3Rpb24gY2ZmR2x5cGhMb2FkZXIoZm9udCwgaW5kZXgsIHBhcnNlQ0ZGQ2hhcnN0cmluZywgY2hhcnN0cmluZykge1xuICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGdseXBoID0gbmV3IEdseXBoKHtpbmRleDogaW5kZXgsIGZvbnQ6IGZvbnR9KTtcblxuICAgICAgICBnbHlwaC5wYXRoID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgcGF0aCA9IHBhcnNlQ0ZGQ2hhcnN0cmluZyhmb250LCBnbHlwaCwgY2hhcnN0cmluZyk7XG4gICAgICAgICAgICBwYXRoLnVuaXRzUGVyRW0gPSBmb250LnVuaXRzUGVyRW07XG4gICAgICAgICAgICByZXR1cm4gcGF0aDtcbiAgICAgICAgfTtcblxuICAgICAgICByZXR1cm4gZ2x5cGg7XG4gICAgfTtcbn1cblxudmFyIGdseXBoc2V0ID0geyBHbHlwaFNldDogR2x5cGhTZXQsIGdseXBoTG9hZGVyOiBnbHlwaExvYWRlciwgdHRmR2x5cGhMb2FkZXI6IHR0ZkdseXBoTG9hZGVyLCBjZmZHbHlwaExvYWRlcjogY2ZmR2x5cGhMb2FkZXIgfTtcblxuLy8gVGhlIGBDRkZgIHRhYmxlIGNvbnRhaW5zIHRoZSBnbHlwaCBvdXRsaW5lcyBpbiBQb3N0U2NyaXB0IGZvcm1hdC5cblxuLy8gQ3VzdG9tIGVxdWFscyBmdW5jdGlvbiB0aGF0IGNhbiBhbHNvIGNoZWNrIGxpc3RzLlxuZnVuY3Rpb24gZXF1YWxzKGEsIGIpIHtcbiAgICBpZiAoYSA9PT0gYikge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkoYSkgJiYgQXJyYXkuaXNBcnJheShiKSkge1xuICAgICAgICBpZiAoYS5sZW5ndGggIT09IGIubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGEubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgICAgIGlmICghZXF1YWxzKGFbaV0sIGJbaV0pKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbn1cblxuLy8gU3Vicm91dGluZXMgYXJlIGVuY29kZWQgdXNpbmcgdGhlIG5lZ2F0aXZlIGhhbGYgb2YgdGhlIG51bWJlciBzcGFjZS5cbi8vIFNlZSB0eXBlIDIgY2hhcHRlciA0LjcgXCJTdWJyb3V0aW5lIG9wZXJhdG9yc1wiLlxuZnVuY3Rpb24gY2FsY0NGRlN1YnJvdXRpbmVCaWFzKHN1YnJzKSB7XG4gICAgdmFyIGJpYXM7XG4gICAgaWYgKHN1YnJzLmxlbmd0aCA8IDEyNDApIHtcbiAgICAgICAgYmlhcyA9IDEwNztcbiAgICB9IGVsc2UgaWYgKHN1YnJzLmxlbmd0aCA8IDMzOTAwKSB7XG4gICAgICAgIGJpYXMgPSAxMTMxO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGJpYXMgPSAzMjc2ODtcbiAgICB9XG5cbiAgICByZXR1cm4gYmlhcztcbn1cblxuLy8gUGFyc2UgYSBgQ0ZGYCBJTkRFWCBhcnJheS5cbi8vIEFuIGluZGV4IGFycmF5IGNvbnNpc3RzIG9mIGEgbGlzdCBvZiBvZmZzZXRzLCB0aGVuIGEgbGlzdCBvZiBvYmplY3RzIGF0IHRob3NlIG9mZnNldHMuXG5mdW5jdGlvbiBwYXJzZUNGRkluZGV4KGRhdGEsIHN0YXJ0LCBjb252ZXJzaW9uRm4pIHtcbiAgICB2YXIgb2Zmc2V0cyA9IFtdO1xuICAgIHZhciBvYmplY3RzID0gW107XG4gICAgdmFyIGNvdW50ID0gcGFyc2UuZ2V0Q2FyZDE2KGRhdGEsIHN0YXJ0KTtcbiAgICB2YXIgb2JqZWN0T2Zmc2V0O1xuICAgIHZhciBlbmRPZmZzZXQ7XG4gICAgaWYgKGNvdW50ICE9PSAwKSB7XG4gICAgICAgIHZhciBvZmZzZXRTaXplID0gcGFyc2UuZ2V0Qnl0ZShkYXRhLCBzdGFydCArIDIpO1xuICAgICAgICBvYmplY3RPZmZzZXQgPSBzdGFydCArICgoY291bnQgKyAxKSAqIG9mZnNldFNpemUpICsgMjtcbiAgICAgICAgdmFyIHBvcyA9IHN0YXJ0ICsgMztcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb3VudCArIDE7IGkgKz0gMSkge1xuICAgICAgICAgICAgb2Zmc2V0cy5wdXNoKHBhcnNlLmdldE9mZnNldChkYXRhLCBwb3MsIG9mZnNldFNpemUpKTtcbiAgICAgICAgICAgIHBvcyArPSBvZmZzZXRTaXplO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gVGhlIHRvdGFsIHNpemUgb2YgdGhlIGluZGV4IGFycmF5IGlzIDQgaGVhZGVyIGJ5dGVzICsgdGhlIHZhbHVlIG9mIHRoZSBsYXN0IG9mZnNldC5cbiAgICAgICAgZW5kT2Zmc2V0ID0gb2JqZWN0T2Zmc2V0ICsgb2Zmc2V0c1tjb3VudF07XG4gICAgfSBlbHNlIHtcbiAgICAgICAgZW5kT2Zmc2V0ID0gc3RhcnQgKyAyO1xuICAgIH1cblxuICAgIGZvciAodmFyIGkkMSA9IDA7IGkkMSA8IG9mZnNldHMubGVuZ3RoIC0gMTsgaSQxICs9IDEpIHtcbiAgICAgICAgdmFyIHZhbHVlID0gcGFyc2UuZ2V0Qnl0ZXMoZGF0YSwgb2JqZWN0T2Zmc2V0ICsgb2Zmc2V0c1tpJDFdLCBvYmplY3RPZmZzZXQgKyBvZmZzZXRzW2kkMSArIDFdKTtcbiAgICAgICAgaWYgKGNvbnZlcnNpb25Gbikge1xuICAgICAgICAgICAgdmFsdWUgPSBjb252ZXJzaW9uRm4odmFsdWUpO1xuICAgICAgICB9XG5cbiAgICAgICAgb2JqZWN0cy5wdXNoKHZhbHVlKTtcbiAgICB9XG5cbiAgICByZXR1cm4ge29iamVjdHM6IG9iamVjdHMsIHN0YXJ0T2Zmc2V0OiBzdGFydCwgZW5kT2Zmc2V0OiBlbmRPZmZzZXR9O1xufVxuXG5mdW5jdGlvbiBwYXJzZUNGRkluZGV4TG93TWVtb3J5KGRhdGEsIHN0YXJ0KSB7XG4gICAgdmFyIG9mZnNldHMgPSBbXTtcbiAgICB2YXIgY291bnQgPSBwYXJzZS5nZXRDYXJkMTYoZGF0YSwgc3RhcnQpO1xuICAgIHZhciBvYmplY3RPZmZzZXQ7XG4gICAgdmFyIGVuZE9mZnNldDtcbiAgICBpZiAoY291bnQgIT09IDApIHtcbiAgICAgICAgdmFyIG9mZnNldFNpemUgPSBwYXJzZS5nZXRCeXRlKGRhdGEsIHN0YXJ0ICsgMik7XG4gICAgICAgIG9iamVjdE9mZnNldCA9IHN0YXJ0ICsgKChjb3VudCArIDEpICogb2Zmc2V0U2l6ZSkgKyAyO1xuICAgICAgICB2YXIgcG9zID0gc3RhcnQgKyAzO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNvdW50ICsgMTsgaSArPSAxKSB7XG4gICAgICAgICAgICBvZmZzZXRzLnB1c2gocGFyc2UuZ2V0T2Zmc2V0KGRhdGEsIHBvcywgb2Zmc2V0U2l6ZSkpO1xuICAgICAgICAgICAgcG9zICs9IG9mZnNldFNpemU7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBUaGUgdG90YWwgc2l6ZSBvZiB0aGUgaW5kZXggYXJyYXkgaXMgNCBoZWFkZXIgYnl0ZXMgKyB0aGUgdmFsdWUgb2YgdGhlIGxhc3Qgb2Zmc2V0LlxuICAgICAgICBlbmRPZmZzZXQgPSBvYmplY3RPZmZzZXQgKyBvZmZzZXRzW2NvdW50XTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBlbmRPZmZzZXQgPSBzdGFydCArIDI7XG4gICAgfVxuXG4gICAgcmV0dXJuIHtvZmZzZXRzOiBvZmZzZXRzLCBzdGFydE9mZnNldDogc3RhcnQsIGVuZE9mZnNldDogZW5kT2Zmc2V0fTtcbn1cbmZ1bmN0aW9uIGdldENmZkluZGV4T2JqZWN0KGksIG9mZnNldHMsIGRhdGEsIHN0YXJ0LCBjb252ZXJzaW9uRm4pIHtcbiAgICB2YXIgY291bnQgPSBwYXJzZS5nZXRDYXJkMTYoZGF0YSwgc3RhcnQpO1xuICAgIHZhciBvYmplY3RPZmZzZXQgPSAwO1xuICAgIGlmIChjb3VudCAhPT0gMCkge1xuICAgICAgICB2YXIgb2Zmc2V0U2l6ZSA9IHBhcnNlLmdldEJ5dGUoZGF0YSwgc3RhcnQgKyAyKTtcbiAgICAgICAgb2JqZWN0T2Zmc2V0ID0gc3RhcnQgKyAoKGNvdW50ICsgMSkgKiBvZmZzZXRTaXplKSArIDI7XG4gICAgfVxuXG4gICAgdmFyIHZhbHVlID0gcGFyc2UuZ2V0Qnl0ZXMoZGF0YSwgb2JqZWN0T2Zmc2V0ICsgb2Zmc2V0c1tpXSwgb2JqZWN0T2Zmc2V0ICsgb2Zmc2V0c1tpICsgMV0pO1xuICAgIGlmIChjb252ZXJzaW9uRm4pIHtcbiAgICAgICAgdmFsdWUgPSBjb252ZXJzaW9uRm4odmFsdWUpO1xuICAgIH1cbiAgICByZXR1cm4gdmFsdWU7XG59XG5cbi8vIFBhcnNlIGEgYENGRmAgRElDVCByZWFsIHZhbHVlLlxuZnVuY3Rpb24gcGFyc2VGbG9hdE9wZXJhbmQocGFyc2VyKSB7XG4gICAgdmFyIHMgPSAnJztcbiAgICB2YXIgZW9mID0gMTU7XG4gICAgdmFyIGxvb2t1cCA9IFsnMCcsICcxJywgJzInLCAnMycsICc0JywgJzUnLCAnNicsICc3JywgJzgnLCAnOScsICcuJywgJ0UnLCAnRS0nLCBudWxsLCAnLSddO1xuICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgIHZhciBiID0gcGFyc2VyLnBhcnNlQnl0ZSgpO1xuICAgICAgICB2YXIgbjEgPSBiID4+IDQ7XG4gICAgICAgIHZhciBuMiA9IGIgJiAxNTtcblxuICAgICAgICBpZiAobjEgPT09IGVvZikge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgICBzICs9IGxvb2t1cFtuMV07XG5cbiAgICAgICAgaWYgKG4yID09PSBlb2YpIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgICAgcyArPSBsb29rdXBbbjJdO1xuICAgIH1cblxuICAgIHJldHVybiBwYXJzZUZsb2F0KHMpO1xufVxuXG4vLyBQYXJzZSBhIGBDRkZgIERJQ1Qgb3BlcmFuZC5cbmZ1bmN0aW9uIHBhcnNlT3BlcmFuZChwYXJzZXIsIGIwKSB7XG4gICAgdmFyIGIxO1xuICAgIHZhciBiMjtcbiAgICB2YXIgYjM7XG4gICAgdmFyIGI0O1xuICAgIGlmIChiMCA9PT0gMjgpIHtcbiAgICAgICAgYjEgPSBwYXJzZXIucGFyc2VCeXRlKCk7XG4gICAgICAgIGIyID0gcGFyc2VyLnBhcnNlQnl0ZSgpO1xuICAgICAgICByZXR1cm4gYjEgPDwgOCB8IGIyO1xuICAgIH1cblxuICAgIGlmIChiMCA9PT0gMjkpIHtcbiAgICAgICAgYjEgPSBwYXJzZXIucGFyc2VCeXRlKCk7XG4gICAgICAgIGIyID0gcGFyc2VyLnBhcnNlQnl0ZSgpO1xuICAgICAgICBiMyA9IHBhcnNlci5wYXJzZUJ5dGUoKTtcbiAgICAgICAgYjQgPSBwYXJzZXIucGFyc2VCeXRlKCk7XG4gICAgICAgIHJldHVybiBiMSA8PCAyNCB8IGIyIDw8IDE2IHwgYjMgPDwgOCB8IGI0O1xuICAgIH1cblxuICAgIGlmIChiMCA9PT0gMzApIHtcbiAgICAgICAgcmV0dXJuIHBhcnNlRmxvYXRPcGVyYW5kKHBhcnNlcik7XG4gICAgfVxuXG4gICAgaWYgKGIwID49IDMyICYmIGIwIDw9IDI0Nikge1xuICAgICAgICByZXR1cm4gYjAgLSAxMzk7XG4gICAgfVxuXG4gICAgaWYgKGIwID49IDI0NyAmJiBiMCA8PSAyNTApIHtcbiAgICAgICAgYjEgPSBwYXJzZXIucGFyc2VCeXRlKCk7XG4gICAgICAgIHJldHVybiAoYjAgLSAyNDcpICogMjU2ICsgYjEgKyAxMDg7XG4gICAgfVxuXG4gICAgaWYgKGIwID49IDI1MSAmJiBiMCA8PSAyNTQpIHtcbiAgICAgICAgYjEgPSBwYXJzZXIucGFyc2VCeXRlKCk7XG4gICAgICAgIHJldHVybiAtKGIwIC0gMjUxKSAqIDI1NiAtIGIxIC0gMTA4O1xuICAgIH1cblxuICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBiMCAnICsgYjApO1xufVxuXG4vLyBDb252ZXJ0IHRoZSBlbnRyaWVzIHJldHVybmVkIGJ5IGBwYXJzZURpY3RgIHRvIGEgcHJvcGVyIGRpY3Rpb25hcnkuXG4vLyBJZiBhIHZhbHVlIGlzIGEgbGlzdCBvZiBvbmUsIGl0IGlzIHVucGFja2VkLlxuZnVuY3Rpb24gZW50cmllc1RvT2JqZWN0KGVudHJpZXMpIHtcbiAgICB2YXIgbyA9IHt9O1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZW50cmllcy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICB2YXIga2V5ID0gZW50cmllc1tpXVswXTtcbiAgICAgICAgdmFyIHZhbHVlcyA9IGVudHJpZXNbaV1bMV07XG4gICAgICAgIHZhciB2YWx1ZSA9ICh2b2lkIDApO1xuICAgICAgICBpZiAodmFsdWVzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZXNbMF07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YWx1ZSA9IHZhbHVlcztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChvLmhhc093blByb3BlcnR5KGtleSkgJiYgIWlzTmFOKG9ba2V5XSkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignT2JqZWN0ICcgKyBvICsgJyBhbHJlYWR5IGhhcyBrZXkgJyArIGtleSk7XG4gICAgICAgIH1cblxuICAgICAgICBvW2tleV0gPSB2YWx1ZTtcbiAgICB9XG5cbiAgICByZXR1cm4gbztcbn1cblxuLy8gUGFyc2UgYSBgQ0ZGYCBESUNUIG9iamVjdC5cbi8vIEEgZGljdGlvbmFyeSBjb250YWlucyBrZXktdmFsdWUgcGFpcnMgaW4gYSBjb21wYWN0IHRva2VuaXplZCBmb3JtYXQuXG5mdW5jdGlvbiBwYXJzZUNGRkRpY3QoZGF0YSwgc3RhcnQsIHNpemUpIHtcbiAgICBzdGFydCA9IHN0YXJ0ICE9PSB1bmRlZmluZWQgPyBzdGFydCA6IDA7XG4gICAgdmFyIHBhcnNlciA9IG5ldyBwYXJzZS5QYXJzZXIoZGF0YSwgc3RhcnQpO1xuICAgIHZhciBlbnRyaWVzID0gW107XG4gICAgdmFyIG9wZXJhbmRzID0gW107XG4gICAgc2l6ZSA9IHNpemUgIT09IHVuZGVmaW5lZCA/IHNpemUgOiBkYXRhLmxlbmd0aDtcblxuICAgIHdoaWxlIChwYXJzZXIucmVsYXRpdmVPZmZzZXQgPCBzaXplKSB7XG4gICAgICAgIHZhciBvcCA9IHBhcnNlci5wYXJzZUJ5dGUoKTtcblxuICAgICAgICAvLyBUaGUgZmlyc3QgYnl0ZSBmb3IgZWFjaCBkaWN0IGl0ZW0gZGlzdGluZ3Vpc2hlcyBiZXR3ZWVuIG9wZXJhdG9yIChrZXkpIGFuZCBvcGVyYW5kICh2YWx1ZSkuXG4gICAgICAgIC8vIFZhbHVlcyA8PSAyMSBhcmUgb3BlcmF0b3JzLlxuICAgICAgICBpZiAob3AgPD0gMjEpIHtcbiAgICAgICAgICAgIC8vIFR3by1ieXRlIG9wZXJhdG9ycyBoYXZlIGFuIGluaXRpYWwgZXNjYXBlIGJ5dGUgb2YgMTIuXG4gICAgICAgICAgICBpZiAob3AgPT09IDEyKSB7XG4gICAgICAgICAgICAgICAgb3AgPSAxMjAwICsgcGFyc2VyLnBhcnNlQnl0ZSgpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBlbnRyaWVzLnB1c2goW29wLCBvcGVyYW5kc10pO1xuICAgICAgICAgICAgb3BlcmFuZHMgPSBbXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIFNpbmNlIHRoZSBvcGVyYW5kcyAodmFsdWVzKSBjb21lIGJlZm9yZSB0aGUgb3BlcmF0b3JzIChrZXlzKSwgd2Ugc3RvcmUgYWxsIG9wZXJhbmRzIGluIGEgbGlzdFxuICAgICAgICAgICAgLy8gdW50aWwgd2UgZW5jb3VudGVyIGFuIG9wZXJhdG9yLlxuICAgICAgICAgICAgb3BlcmFuZHMucHVzaChwYXJzZU9wZXJhbmQocGFyc2VyLCBvcCkpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGVudHJpZXNUb09iamVjdChlbnRyaWVzKTtcbn1cblxuLy8gR2l2ZW4gYSBTdHJpbmcgSW5kZXggKFNJRCksIHJldHVybiB0aGUgdmFsdWUgb2YgdGhlIHN0cmluZy5cbi8vIFN0cmluZ3MgYmVsb3cgaW5kZXggMzkyIGFyZSBzdGFuZGFyZCBDRkYgc3RyaW5ncyBhbmQgYXJlIG5vdCBlbmNvZGVkIGluIHRoZSBmb250LlxuZnVuY3Rpb24gZ2V0Q0ZGU3RyaW5nKHN0cmluZ3MsIGluZGV4KSB7XG4gICAgaWYgKGluZGV4IDw9IDM5MCkge1xuICAgICAgICBpbmRleCA9IGNmZlN0YW5kYXJkU3RyaW5nc1tpbmRleF07XG4gICAgfSBlbHNlIHtcbiAgICAgICAgaW5kZXggPSBzdHJpbmdzW2luZGV4IC0gMzkxXTtcbiAgICB9XG5cbiAgICByZXR1cm4gaW5kZXg7XG59XG5cbi8vIEludGVycHJldCBhIGRpY3Rpb25hcnkgYW5kIHJldHVybiBhIG5ldyBkaWN0aW9uYXJ5IHdpdGggcmVhZGFibGUga2V5cyBhbmQgdmFsdWVzIGZvciBtaXNzaW5nIGVudHJpZXMuXG4vLyBUaGlzIGZ1bmN0aW9uIHRha2VzIGBtZXRhYCB3aGljaCBpcyBhIGxpc3Qgb2Ygb2JqZWN0cyBjb250YWluaW5nIGBvcGVyYW5kYCwgYG5hbWVgIGFuZCBgZGVmYXVsdGAuXG5mdW5jdGlvbiBpbnRlcnByZXREaWN0KGRpY3QsIG1ldGEsIHN0cmluZ3MpIHtcbiAgICB2YXIgbmV3RGljdCA9IHt9O1xuICAgIHZhciB2YWx1ZTtcblxuICAgIC8vIEJlY2F1c2Ugd2UgYWxzbyB3YW50IHRvIGluY2x1ZGUgbWlzc2luZyB2YWx1ZXMsIHdlIHN0YXJ0IG91dCBmcm9tIHRoZSBtZXRhIGxpc3RcbiAgICAvLyBhbmQgbG9va3VwIHZhbHVlcyBpbiB0aGUgZGljdC5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG1ldGEubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgdmFyIG0gPSBtZXRhW2ldO1xuXG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KG0udHlwZSkpIHtcbiAgICAgICAgICAgIHZhciB2YWx1ZXMgPSBbXTtcbiAgICAgICAgICAgIHZhbHVlcy5sZW5ndGggPSBtLnR5cGUubGVuZ3RoO1xuICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBtLnR5cGUubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IGRpY3RbbS5vcF0gIT09IHVuZGVmaW5lZCA/IGRpY3RbbS5vcF1bal0gOiB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBtLnZhbHVlICE9PSB1bmRlZmluZWQgJiYgbS52YWx1ZVtqXSAhPT0gdW5kZWZpbmVkID8gbS52YWx1ZVtqXSA6IG51bGw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChtLnR5cGVbal0gPT09ICdTSUQnKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gZ2V0Q0ZGU3RyaW5nKHN0cmluZ3MsIHZhbHVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFsdWVzW2pdID0gdmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBuZXdEaWN0W20ubmFtZV0gPSB2YWx1ZXM7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YWx1ZSA9IGRpY3RbbS5vcF07XG4gICAgICAgICAgICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHZhbHVlID0gbS52YWx1ZSAhPT0gdW5kZWZpbmVkID8gbS52YWx1ZSA6IG51bGw7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChtLnR5cGUgPT09ICdTSUQnKSB7XG4gICAgICAgICAgICAgICAgdmFsdWUgPSBnZXRDRkZTdHJpbmcoc3RyaW5ncywgdmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbmV3RGljdFttLm5hbWVdID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gbmV3RGljdDtcbn1cblxuLy8gUGFyc2UgdGhlIENGRiBoZWFkZXIuXG5mdW5jdGlvbiBwYXJzZUNGRkhlYWRlcihkYXRhLCBzdGFydCkge1xuICAgIHZhciBoZWFkZXIgPSB7fTtcbiAgICBoZWFkZXIuZm9ybWF0TWFqb3IgPSBwYXJzZS5nZXRDYXJkOChkYXRhLCBzdGFydCk7XG4gICAgaGVhZGVyLmZvcm1hdE1pbm9yID0gcGFyc2UuZ2V0Q2FyZDgoZGF0YSwgc3RhcnQgKyAxKTtcbiAgICBoZWFkZXIuc2l6ZSA9IHBhcnNlLmdldENhcmQ4KGRhdGEsIHN0YXJ0ICsgMik7XG4gICAgaGVhZGVyLm9mZnNldFNpemUgPSBwYXJzZS5nZXRDYXJkOChkYXRhLCBzdGFydCArIDMpO1xuICAgIGhlYWRlci5zdGFydE9mZnNldCA9IHN0YXJ0O1xuICAgIGhlYWRlci5lbmRPZmZzZXQgPSBzdGFydCArIDQ7XG4gICAgcmV0dXJuIGhlYWRlcjtcbn1cblxudmFyIFRPUF9ESUNUX01FVEEgPSBbXG4gICAge25hbWU6ICd2ZXJzaW9uJywgb3A6IDAsIHR5cGU6ICdTSUQnfSxcbiAgICB7bmFtZTogJ25vdGljZScsIG9wOiAxLCB0eXBlOiAnU0lEJ30sXG4gICAge25hbWU6ICdjb3B5cmlnaHQnLCBvcDogMTIwMCwgdHlwZTogJ1NJRCd9LFxuICAgIHtuYW1lOiAnZnVsbE5hbWUnLCBvcDogMiwgdHlwZTogJ1NJRCd9LFxuICAgIHtuYW1lOiAnZmFtaWx5TmFtZScsIG9wOiAzLCB0eXBlOiAnU0lEJ30sXG4gICAge25hbWU6ICd3ZWlnaHQnLCBvcDogNCwgdHlwZTogJ1NJRCd9LFxuICAgIHtuYW1lOiAnaXNGaXhlZFBpdGNoJywgb3A6IDEyMDEsIHR5cGU6ICdudW1iZXInLCB2YWx1ZTogMH0sXG4gICAge25hbWU6ICdpdGFsaWNBbmdsZScsIG9wOiAxMjAyLCB0eXBlOiAnbnVtYmVyJywgdmFsdWU6IDB9LFxuICAgIHtuYW1lOiAndW5kZXJsaW5lUG9zaXRpb24nLCBvcDogMTIwMywgdHlwZTogJ251bWJlcicsIHZhbHVlOiAtMTAwfSxcbiAgICB7bmFtZTogJ3VuZGVybGluZVRoaWNrbmVzcycsIG9wOiAxMjA0LCB0eXBlOiAnbnVtYmVyJywgdmFsdWU6IDUwfSxcbiAgICB7bmFtZTogJ3BhaW50VHlwZScsIG9wOiAxMjA1LCB0eXBlOiAnbnVtYmVyJywgdmFsdWU6IDB9LFxuICAgIHtuYW1lOiAnY2hhcnN0cmluZ1R5cGUnLCBvcDogMTIwNiwgdHlwZTogJ251bWJlcicsIHZhbHVlOiAyfSxcbiAgICB7XG4gICAgICAgIG5hbWU6ICdmb250TWF0cml4JyxcbiAgICAgICAgb3A6IDEyMDcsXG4gICAgICAgIHR5cGU6IFsncmVhbCcsICdyZWFsJywgJ3JlYWwnLCAncmVhbCcsICdyZWFsJywgJ3JlYWwnXSxcbiAgICAgICAgdmFsdWU6IFswLjAwMSwgMCwgMCwgMC4wMDEsIDAsIDBdXG4gICAgfSxcbiAgICB7bmFtZTogJ3VuaXF1ZUlkJywgb3A6IDEzLCB0eXBlOiAnbnVtYmVyJ30sXG4gICAge25hbWU6ICdmb250QkJveCcsIG9wOiA1LCB0eXBlOiBbJ251bWJlcicsICdudW1iZXInLCAnbnVtYmVyJywgJ251bWJlciddLCB2YWx1ZTogWzAsIDAsIDAsIDBdfSxcbiAgICB7bmFtZTogJ3N0cm9rZVdpZHRoJywgb3A6IDEyMDgsIHR5cGU6ICdudW1iZXInLCB2YWx1ZTogMH0sXG4gICAge25hbWU6ICd4dWlkJywgb3A6IDE0LCB0eXBlOiBbXSwgdmFsdWU6IG51bGx9LFxuICAgIHtuYW1lOiAnY2hhcnNldCcsIG9wOiAxNSwgdHlwZTogJ29mZnNldCcsIHZhbHVlOiAwfSxcbiAgICB7bmFtZTogJ2VuY29kaW5nJywgb3A6IDE2LCB0eXBlOiAnb2Zmc2V0JywgdmFsdWU6IDB9LFxuICAgIHtuYW1lOiAnY2hhclN0cmluZ3MnLCBvcDogMTcsIHR5cGU6ICdvZmZzZXQnLCB2YWx1ZTogMH0sXG4gICAge25hbWU6ICdwcml2YXRlJywgb3A6IDE4LCB0eXBlOiBbJ251bWJlcicsICdvZmZzZXQnXSwgdmFsdWU6IFswLCAwXX0sXG4gICAge25hbWU6ICdyb3MnLCBvcDogMTIzMCwgdHlwZTogWydTSUQnLCAnU0lEJywgJ251bWJlciddfSxcbiAgICB7bmFtZTogJ2NpZEZvbnRWZXJzaW9uJywgb3A6IDEyMzEsIHR5cGU6ICdudW1iZXInLCB2YWx1ZTogMH0sXG4gICAge25hbWU6ICdjaWRGb250UmV2aXNpb24nLCBvcDogMTIzMiwgdHlwZTogJ251bWJlcicsIHZhbHVlOiAwfSxcbiAgICB7bmFtZTogJ2NpZEZvbnRUeXBlJywgb3A6IDEyMzMsIHR5cGU6ICdudW1iZXInLCB2YWx1ZTogMH0sXG4gICAge25hbWU6ICdjaWRDb3VudCcsIG9wOiAxMjM0LCB0eXBlOiAnbnVtYmVyJywgdmFsdWU6IDg3MjB9LFxuICAgIHtuYW1lOiAndWlkQmFzZScsIG9wOiAxMjM1LCB0eXBlOiAnbnVtYmVyJ30sXG4gICAge25hbWU6ICdmZEFycmF5Jywgb3A6IDEyMzYsIHR5cGU6ICdvZmZzZXQnfSxcbiAgICB7bmFtZTogJ2ZkU2VsZWN0Jywgb3A6IDEyMzcsIHR5cGU6ICdvZmZzZXQnfSxcbiAgICB7bmFtZTogJ2ZvbnROYW1lJywgb3A6IDEyMzgsIHR5cGU6ICdTSUQnfVxuXTtcblxudmFyIFBSSVZBVEVfRElDVF9NRVRBID0gW1xuICAgIHtuYW1lOiAnc3VicnMnLCBvcDogMTksIHR5cGU6ICdvZmZzZXQnLCB2YWx1ZTogMH0sXG4gICAge25hbWU6ICdkZWZhdWx0V2lkdGhYJywgb3A6IDIwLCB0eXBlOiAnbnVtYmVyJywgdmFsdWU6IDB9LFxuICAgIHtuYW1lOiAnbm9taW5hbFdpZHRoWCcsIG9wOiAyMSwgdHlwZTogJ251bWJlcicsIHZhbHVlOiAwfVxuXTtcblxuLy8gUGFyc2UgdGhlIENGRiB0b3AgZGljdGlvbmFyeS4gQSBDRkYgdGFibGUgY2FuIGNvbnRhaW4gbXVsdGlwbGUgZm9udHMsIGVhY2ggd2l0aCB0aGVpciBvd24gdG9wIGRpY3Rpb25hcnkuXG4vLyBUaGUgdG9wIGRpY3Rpb25hcnkgY29udGFpbnMgdGhlIGVzc2VudGlhbCBtZXRhZGF0YSBmb3IgdGhlIGZvbnQsIHRvZ2V0aGVyIHdpdGggdGhlIHByaXZhdGUgZGljdGlvbmFyeS5cbmZ1bmN0aW9uIHBhcnNlQ0ZGVG9wRGljdChkYXRhLCBzdHJpbmdzKSB7XG4gICAgdmFyIGRpY3QgPSBwYXJzZUNGRkRpY3QoZGF0YSwgMCwgZGF0YS5ieXRlTGVuZ3RoKTtcbiAgICByZXR1cm4gaW50ZXJwcmV0RGljdChkaWN0LCBUT1BfRElDVF9NRVRBLCBzdHJpbmdzKTtcbn1cblxuLy8gUGFyc2UgdGhlIENGRiBwcml2YXRlIGRpY3Rpb25hcnkuIFdlIGRvbid0IGZ1bGx5IHBhcnNlIG91dCBhbGwgdGhlIHZhbHVlcywgb25seSB0aGUgb25lcyB3ZSBuZWVkLlxuZnVuY3Rpb24gcGFyc2VDRkZQcml2YXRlRGljdChkYXRhLCBzdGFydCwgc2l6ZSwgc3RyaW5ncykge1xuICAgIHZhciBkaWN0ID0gcGFyc2VDRkZEaWN0KGRhdGEsIHN0YXJ0LCBzaXplKTtcbiAgICByZXR1cm4gaW50ZXJwcmV0RGljdChkaWN0LCBQUklWQVRFX0RJQ1RfTUVUQSwgc3RyaW5ncyk7XG59XG5cbi8vIFJldHVybnMgYSBsaXN0IG9mIFwiVG9wIERJQ1RcInMgZm91bmQgdXNpbmcgYW4gSU5ERVggbGlzdC5cbi8vIFVzZWQgdG8gcmVhZCBib3RoIHRoZSB1c3VhbCBoaWdoLWxldmVsIFRvcCBESUNUcyBhbmQgYWxzbyB0aGUgRkRBcnJheVxuLy8gZGlzY292ZXJlZCBpbnNpZGUgQ0lELWtleWVkIGZvbnRzLiAgV2hlbiBhIFRvcCBESUNUIGhhcyBhIHJlZmVyZW5jZSB0b1xuLy8gYSBQcml2YXRlIERJQ1QgdGhhdCBpcyByZWFkIGFuZCBzYXZlZCBpbnRvIHRoZSBUb3AgRElDVC5cbi8vXG4vLyBJbiBhZGRpdGlvbiB0byB0aGUgZXhwZWN0ZWQvb3B0aW9uYWwgdmFsdWVzIGFzIG91dGxpbmVkIGluIFRPUF9ESUNUX01FVEFcbi8vIHRoZSBmb2xsb3dpbmcgdmFsdWVzIG1pZ2h0IGJlIHNhdmVkIGludG8gdGhlIFRvcCBESUNULlxuLy9cbi8vICAgIF9zdWJycyBbXSAgICAgICAgYXJyYXkgb2YgbG9jYWwgQ0ZGIHN1YnJvdXRpbmVzIGZyb20gUHJpdmF0ZSBESUNUXG4vLyAgICBfc3VicnNCaWFzICAgICAgIGJpYXMgdmFsdWUgY29tcHV0ZWQgZnJvbSBudW1iZXIgb2Ygc3Vicm91dGluZXNcbi8vICAgICAgICAgICAgICAgICAgICAgIChzZWUgY2FsY0NGRlN1YnJvdXRpbmVCaWFzKCkgYW5kIHBhcnNlQ0ZGQ2hhcnN0cmluZygpKVxuLy8gICAgX2RlZmF1bHRXaWR0aFggICBkZWZhdWx0IHdpZHRocyBmb3IgQ0ZGIGNoYXJhY3RlcnNcbi8vICAgIF9ub21pbmFsV2lkdGhYICAgYmlhcyBhZGRlZCB0byB3aWR0aCBlbWJlZGRlZCB3aXRoaW4gZ2x5cGggZGVzY3JpcHRpb25cbi8vXG4vLyAgICBfcHJpdmF0ZURpY3QgICAgIHNhdmVkIGNvcHkgb2YgcGFyc2VkIFByaXZhdGUgRElDVCBmcm9tIFRvcCBESUNUXG5mdW5jdGlvbiBnYXRoZXJDRkZUb3BEaWN0cyhkYXRhLCBzdGFydCwgY2ZmSW5kZXgsIHN0cmluZ3MpIHtcbiAgICB2YXIgdG9wRGljdEFycmF5ID0gW107XG4gICAgZm9yICh2YXIgaVRvcERpY3QgPSAwOyBpVG9wRGljdCA8IGNmZkluZGV4Lmxlbmd0aDsgaVRvcERpY3QgKz0gMSkge1xuICAgICAgICB2YXIgdG9wRGljdERhdGEgPSBuZXcgRGF0YVZpZXcobmV3IFVpbnQ4QXJyYXkoY2ZmSW5kZXhbaVRvcERpY3RdKS5idWZmZXIpO1xuICAgICAgICB2YXIgdG9wRGljdCA9IHBhcnNlQ0ZGVG9wRGljdCh0b3BEaWN0RGF0YSwgc3RyaW5ncyk7XG4gICAgICAgIHRvcERpY3QuX3N1YnJzID0gW107XG4gICAgICAgIHRvcERpY3QuX3N1YnJzQmlhcyA9IDA7XG4gICAgICAgIHRvcERpY3QuX2RlZmF1bHRXaWR0aFggPSAwO1xuICAgICAgICB0b3BEaWN0Ll9ub21pbmFsV2lkdGhYID0gMDtcbiAgICAgICAgdmFyIHByaXZhdGVTaXplID0gdG9wRGljdC5wcml2YXRlWzBdO1xuICAgICAgICB2YXIgcHJpdmF0ZU9mZnNldCA9IHRvcERpY3QucHJpdmF0ZVsxXTtcbiAgICAgICAgaWYgKHByaXZhdGVTaXplICE9PSAwICYmIHByaXZhdGVPZmZzZXQgIT09IDApIHtcbiAgICAgICAgICAgIHZhciBwcml2YXRlRGljdCA9IHBhcnNlQ0ZGUHJpdmF0ZURpY3QoZGF0YSwgcHJpdmF0ZU9mZnNldCArIHN0YXJ0LCBwcml2YXRlU2l6ZSwgc3RyaW5ncyk7XG4gICAgICAgICAgICB0b3BEaWN0Ll9kZWZhdWx0V2lkdGhYID0gcHJpdmF0ZURpY3QuZGVmYXVsdFdpZHRoWDtcbiAgICAgICAgICAgIHRvcERpY3QuX25vbWluYWxXaWR0aFggPSBwcml2YXRlRGljdC5ub21pbmFsV2lkdGhYO1xuICAgICAgICAgICAgaWYgKHByaXZhdGVEaWN0LnN1YnJzICE9PSAwKSB7XG4gICAgICAgICAgICAgICAgdmFyIHN1YnJPZmZzZXQgPSBwcml2YXRlT2Zmc2V0ICsgcHJpdmF0ZURpY3Quc3VicnM7XG4gICAgICAgICAgICAgICAgdmFyIHN1YnJJbmRleCA9IHBhcnNlQ0ZGSW5kZXgoZGF0YSwgc3Vick9mZnNldCArIHN0YXJ0KTtcbiAgICAgICAgICAgICAgICB0b3BEaWN0Ll9zdWJycyA9IHN1YnJJbmRleC5vYmplY3RzO1xuICAgICAgICAgICAgICAgIHRvcERpY3QuX3N1YnJzQmlhcyA9IGNhbGNDRkZTdWJyb3V0aW5lQmlhcyh0b3BEaWN0Ll9zdWJycyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0b3BEaWN0Ll9wcml2YXRlRGljdCA9IHByaXZhdGVEaWN0O1xuICAgICAgICB9XG4gICAgICAgIHRvcERpY3RBcnJheS5wdXNoKHRvcERpY3QpO1xuICAgIH1cbiAgICByZXR1cm4gdG9wRGljdEFycmF5O1xufVxuXG4vLyBQYXJzZSB0aGUgQ0ZGIGNoYXJzZXQgdGFibGUsIHdoaWNoIGNvbnRhaW5zIGludGVybmFsIG5hbWVzIGZvciBhbGwgdGhlIGdseXBocy5cbi8vIFRoaXMgZnVuY3Rpb24gd2lsbCByZXR1cm4gYSBsaXN0IG9mIGdseXBoIG5hbWVzLlxuLy8gU2VlIEFkb2JlIFROICM1MTc2IGNoYXB0ZXIgMTMsIFwiQ2hhcnNldHNcIi5cbmZ1bmN0aW9uIHBhcnNlQ0ZGQ2hhcnNldChkYXRhLCBzdGFydCwgbkdseXBocywgc3RyaW5ncykge1xuICAgIHZhciBzaWQ7XG4gICAgdmFyIGNvdW50O1xuICAgIHZhciBwYXJzZXIgPSBuZXcgcGFyc2UuUGFyc2VyKGRhdGEsIHN0YXJ0KTtcblxuICAgIC8vIFRoZSAubm90ZGVmIGdseXBoIGlzIG5vdCBpbmNsdWRlZCwgc28gc3VidHJhY3QgMS5cbiAgICBuR2x5cGhzIC09IDE7XG4gICAgdmFyIGNoYXJzZXQgPSBbJy5ub3RkZWYnXTtcblxuICAgIHZhciBmb3JtYXQgPSBwYXJzZXIucGFyc2VDYXJkOCgpO1xuICAgIGlmIChmb3JtYXQgPT09IDApIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBuR2x5cGhzOyBpICs9IDEpIHtcbiAgICAgICAgICAgIHNpZCA9IHBhcnNlci5wYXJzZVNJRCgpO1xuICAgICAgICAgICAgY2hhcnNldC5wdXNoKGdldENGRlN0cmluZyhzdHJpbmdzLCBzaWQpKTtcbiAgICAgICAgfVxuICAgIH0gZWxzZSBpZiAoZm9ybWF0ID09PSAxKSB7XG4gICAgICAgIHdoaWxlIChjaGFyc2V0Lmxlbmd0aCA8PSBuR2x5cGhzKSB7XG4gICAgICAgICAgICBzaWQgPSBwYXJzZXIucGFyc2VTSUQoKTtcbiAgICAgICAgICAgIGNvdW50ID0gcGFyc2VyLnBhcnNlQ2FyZDgoKTtcbiAgICAgICAgICAgIGZvciAodmFyIGkkMSA9IDA7IGkkMSA8PSBjb3VudDsgaSQxICs9IDEpIHtcbiAgICAgICAgICAgICAgICBjaGFyc2V0LnB1c2goZ2V0Q0ZGU3RyaW5nKHN0cmluZ3MsIHNpZCkpO1xuICAgICAgICAgICAgICAgIHNpZCArPSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSBlbHNlIGlmIChmb3JtYXQgPT09IDIpIHtcbiAgICAgICAgd2hpbGUgKGNoYXJzZXQubGVuZ3RoIDw9IG5HbHlwaHMpIHtcbiAgICAgICAgICAgIHNpZCA9IHBhcnNlci5wYXJzZVNJRCgpO1xuICAgICAgICAgICAgY291bnQgPSBwYXJzZXIucGFyc2VDYXJkMTYoKTtcbiAgICAgICAgICAgIGZvciAodmFyIGkkMiA9IDA7IGkkMiA8PSBjb3VudDsgaSQyICs9IDEpIHtcbiAgICAgICAgICAgICAgICBjaGFyc2V0LnB1c2goZ2V0Q0ZGU3RyaW5nKHN0cmluZ3MsIHNpZCkpO1xuICAgICAgICAgICAgICAgIHNpZCArPSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbmtub3duIGNoYXJzZXQgZm9ybWF0ICcgKyBmb3JtYXQpO1xuICAgIH1cblxuICAgIHJldHVybiBjaGFyc2V0O1xufVxuXG4vLyBQYXJzZSB0aGUgQ0ZGIGVuY29kaW5nIGRhdGEuIE9ubHkgb25lIGVuY29kaW5nIGNhbiBiZSBzcGVjaWZpZWQgcGVyIGZvbnQuXG4vLyBTZWUgQWRvYmUgVE4gIzUxNzYgY2hhcHRlciAxMiwgXCJFbmNvZGluZ3NcIi5cbmZ1bmN0aW9uIHBhcnNlQ0ZGRW5jb2RpbmcoZGF0YSwgc3RhcnQsIGNoYXJzZXQpIHtcbiAgICB2YXIgY29kZTtcbiAgICB2YXIgZW5jID0ge307XG4gICAgdmFyIHBhcnNlciA9IG5ldyBwYXJzZS5QYXJzZXIoZGF0YSwgc3RhcnQpO1xuICAgIHZhciBmb3JtYXQgPSBwYXJzZXIucGFyc2VDYXJkOCgpO1xuICAgIGlmIChmb3JtYXQgPT09IDApIHtcbiAgICAgICAgdmFyIG5Db2RlcyA9IHBhcnNlci5wYXJzZUNhcmQ4KCk7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbkNvZGVzOyBpICs9IDEpIHtcbiAgICAgICAgICAgIGNvZGUgPSBwYXJzZXIucGFyc2VDYXJkOCgpO1xuICAgICAgICAgICAgZW5jW2NvZGVdID0gaTtcbiAgICAgICAgfVxuICAgIH0gZWxzZSBpZiAoZm9ybWF0ID09PSAxKSB7XG4gICAgICAgIHZhciBuUmFuZ2VzID0gcGFyc2VyLnBhcnNlQ2FyZDgoKTtcbiAgICAgICAgY29kZSA9IDE7XG4gICAgICAgIGZvciAodmFyIGkkMSA9IDA7IGkkMSA8IG5SYW5nZXM7IGkkMSArPSAxKSB7XG4gICAgICAgICAgICB2YXIgZmlyc3QgPSBwYXJzZXIucGFyc2VDYXJkOCgpO1xuICAgICAgICAgICAgdmFyIG5MZWZ0ID0gcGFyc2VyLnBhcnNlQ2FyZDgoKTtcbiAgICAgICAgICAgIGZvciAodmFyIGogPSBmaXJzdDsgaiA8PSBmaXJzdCArIG5MZWZ0OyBqICs9IDEpIHtcbiAgICAgICAgICAgICAgICBlbmNbal0gPSBjb2RlO1xuICAgICAgICAgICAgICAgIGNvZGUgKz0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignVW5rbm93biBlbmNvZGluZyBmb3JtYXQgJyArIGZvcm1hdCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG5ldyBDZmZFbmNvZGluZyhlbmMsIGNoYXJzZXQpO1xufVxuXG4vLyBUYWtlIGluIGNoYXJzdHJpbmcgY29kZSBhbmQgcmV0dXJuIGEgR2x5cGggb2JqZWN0LlxuLy8gVGhlIGVuY29kaW5nIGlzIGRlc2NyaWJlZCBpbiB0aGUgVHlwZSAyIENoYXJzdHJpbmcgRm9ybWF0XG4vLyBodHRwczovL3d3dy5taWNyb3NvZnQuY29tL3R5cG9ncmFwaHkvT1RTUEVDL2NoYXJzdHIyLmh0bVxuZnVuY3Rpb24gcGFyc2VDRkZDaGFyc3RyaW5nKGZvbnQsIGdseXBoLCBjb2RlKSB7XG4gICAgdmFyIGMxeDtcbiAgICB2YXIgYzF5O1xuICAgIHZhciBjMng7XG4gICAgdmFyIGMyeTtcbiAgICB2YXIgcCA9IG5ldyBQYXRoKCk7XG4gICAgdmFyIHN0YWNrID0gW107XG4gICAgdmFyIG5TdGVtcyA9IDA7XG4gICAgdmFyIGhhdmVXaWR0aCA9IGZhbHNlO1xuICAgIHZhciBvcGVuID0gZmFsc2U7XG4gICAgdmFyIHggPSAwO1xuICAgIHZhciB5ID0gMDtcbiAgICB2YXIgc3VicnM7XG4gICAgdmFyIHN1YnJzQmlhcztcbiAgICB2YXIgZGVmYXVsdFdpZHRoWDtcbiAgICB2YXIgbm9taW5hbFdpZHRoWDtcbiAgICBpZiAoZm9udC5pc0NJREZvbnQpIHtcbiAgICAgICAgdmFyIGZkSW5kZXggPSBmb250LnRhYmxlcy5jZmYudG9wRGljdC5fZmRTZWxlY3RbZ2x5cGguaW5kZXhdO1xuICAgICAgICB2YXIgZmREaWN0ID0gZm9udC50YWJsZXMuY2ZmLnRvcERpY3QuX2ZkQXJyYXlbZmRJbmRleF07XG4gICAgICAgIHN1YnJzID0gZmREaWN0Ll9zdWJycztcbiAgICAgICAgc3VicnNCaWFzID0gZmREaWN0Ll9zdWJyc0JpYXM7XG4gICAgICAgIGRlZmF1bHRXaWR0aFggPSBmZERpY3QuX2RlZmF1bHRXaWR0aFg7XG4gICAgICAgIG5vbWluYWxXaWR0aFggPSBmZERpY3QuX25vbWluYWxXaWR0aFg7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgc3VicnMgPSBmb250LnRhYmxlcy5jZmYudG9wRGljdC5fc3VicnM7XG4gICAgICAgIHN1YnJzQmlhcyA9IGZvbnQudGFibGVzLmNmZi50b3BEaWN0Ll9zdWJyc0JpYXM7XG4gICAgICAgIGRlZmF1bHRXaWR0aFggPSBmb250LnRhYmxlcy5jZmYudG9wRGljdC5fZGVmYXVsdFdpZHRoWDtcbiAgICAgICAgbm9taW5hbFdpZHRoWCA9IGZvbnQudGFibGVzLmNmZi50b3BEaWN0Ll9ub21pbmFsV2lkdGhYO1xuICAgIH1cbiAgICB2YXIgd2lkdGggPSBkZWZhdWx0V2lkdGhYO1xuXG4gICAgZnVuY3Rpb24gbmV3Q29udG91cih4LCB5KSB7XG4gICAgICAgIGlmIChvcGVuKSB7XG4gICAgICAgICAgICBwLmNsb3NlUGF0aCgpO1xuICAgICAgICB9XG5cbiAgICAgICAgcC5tb3ZlVG8oeCwgeSk7XG4gICAgICAgIG9wZW4gPSB0cnVlO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHBhcnNlU3RlbXMoKSB7XG4gICAgICAgIHZhciBoYXNXaWR0aEFyZztcblxuICAgICAgICAvLyBUaGUgbnVtYmVyIG9mIHN0ZW0gb3BlcmF0b3JzIG9uIHRoZSBzdGFjayBpcyBhbHdheXMgZXZlbi5cbiAgICAgICAgLy8gSWYgdGhlIHZhbHVlIGlzIHVuZXZlbiwgdGhhdCBtZWFucyBhIHdpZHRoIGlzIHNwZWNpZmllZC5cbiAgICAgICAgaGFzV2lkdGhBcmcgPSBzdGFjay5sZW5ndGggJSAyICE9PSAwO1xuICAgICAgICBpZiAoaGFzV2lkdGhBcmcgJiYgIWhhdmVXaWR0aCkge1xuICAgICAgICAgICAgd2lkdGggPSBzdGFjay5zaGlmdCgpICsgbm9taW5hbFdpZHRoWDtcbiAgICAgICAgfVxuXG4gICAgICAgIG5TdGVtcyArPSBzdGFjay5sZW5ndGggPj4gMTtcbiAgICAgICAgc3RhY2subGVuZ3RoID0gMDtcbiAgICAgICAgaGF2ZVdpZHRoID0gdHJ1ZTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwYXJzZShjb2RlKSB7XG4gICAgICAgIHZhciBiMTtcbiAgICAgICAgdmFyIGIyO1xuICAgICAgICB2YXIgYjM7XG4gICAgICAgIHZhciBiNDtcbiAgICAgICAgdmFyIGNvZGVJbmRleDtcbiAgICAgICAgdmFyIHN1YnJDb2RlO1xuICAgICAgICB2YXIganB4O1xuICAgICAgICB2YXIganB5O1xuICAgICAgICB2YXIgYzN4O1xuICAgICAgICB2YXIgYzN5O1xuICAgICAgICB2YXIgYzR4O1xuICAgICAgICB2YXIgYzR5O1xuXG4gICAgICAgIHZhciBpID0gMDtcbiAgICAgICAgd2hpbGUgKGkgPCBjb2RlLmxlbmd0aCkge1xuICAgICAgICAgICAgdmFyIHYgPSBjb2RlW2ldO1xuICAgICAgICAgICAgaSArPSAxO1xuICAgICAgICAgICAgc3dpdGNoICh2KSB7XG4gICAgICAgICAgICAgICAgY2FzZSAxOiAvLyBoc3RlbVxuICAgICAgICAgICAgICAgICAgICBwYXJzZVN0ZW1zKCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgMzogLy8gdnN0ZW1cbiAgICAgICAgICAgICAgICAgICAgcGFyc2VTdGVtcygpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDQ6IC8vIHZtb3ZldG9cbiAgICAgICAgICAgICAgICAgICAgaWYgKHN0YWNrLmxlbmd0aCA+IDEgJiYgIWhhdmVXaWR0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgd2lkdGggPSBzdGFjay5zaGlmdCgpICsgbm9taW5hbFdpZHRoWDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGhhdmVXaWR0aCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICB5ICs9IHN0YWNrLnBvcCgpO1xuICAgICAgICAgICAgICAgICAgICBuZXdDb250b3VyKHgsIHkpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDU6IC8vIHJsaW5ldG9cbiAgICAgICAgICAgICAgICAgICAgd2hpbGUgKHN0YWNrLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHggKz0gc3RhY2suc2hpZnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHkgKz0gc3RhY2suc2hpZnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHAubGluZVRvKHgsIHkpO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSA2OiAvLyBobGluZXRvXG4gICAgICAgICAgICAgICAgICAgIHdoaWxlIChzdGFjay5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB4ICs9IHN0YWNrLnNoaWZ0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBwLmxpbmVUbyh4LCB5KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzdGFjay5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgeSArPSBzdGFjay5zaGlmdCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcC5saW5lVG8oeCwgeSk7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDc6IC8vIHZsaW5ldG9cbiAgICAgICAgICAgICAgICAgICAgd2hpbGUgKHN0YWNrLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHkgKz0gc3RhY2suc2hpZnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHAubGluZVRvKHgsIHkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHN0YWNrLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICB4ICs9IHN0YWNrLnNoaWZ0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBwLmxpbmVUbyh4LCB5KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgODogLy8gcnJjdXJ2ZXRvXG4gICAgICAgICAgICAgICAgICAgIHdoaWxlIChzdGFjay5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjMXggPSB4ICsgc3RhY2suc2hpZnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGMxeSA9IHkgKyBzdGFjay5zaGlmdCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYzJ4ID0gYzF4ICsgc3RhY2suc2hpZnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGMyeSA9IGMxeSArIHN0YWNrLnNoaWZ0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB4ID0gYzJ4ICsgc3RhY2suc2hpZnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHkgPSBjMnkgKyBzdGFjay5zaGlmdCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcC5jdXJ2ZVRvKGMxeCwgYzF5LCBjMngsIGMyeSwgeCwgeSk7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDEwOiAvLyBjYWxsc3ViclxuICAgICAgICAgICAgICAgICAgICBjb2RlSW5kZXggPSBzdGFjay5wb3AoKSArIHN1YnJzQmlhcztcbiAgICAgICAgICAgICAgICAgICAgc3VickNvZGUgPSBzdWJyc1tjb2RlSW5kZXhdO1xuICAgICAgICAgICAgICAgICAgICBpZiAoc3VickNvZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcnNlKHN1YnJDb2RlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgMTE6IC8vIHJldHVyblxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgY2FzZSAxMjogLy8gZmxleCBvcGVyYXRvcnNcbiAgICAgICAgICAgICAgICAgICAgdiA9IGNvZGVbaV07XG4gICAgICAgICAgICAgICAgICAgIGkgKz0gMTtcbiAgICAgICAgICAgICAgICAgICAgc3dpdGNoICh2KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDM1OiAvLyBmbGV4XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gfC0gZHgxIGR5MSBkeDIgZHkyIGR4MyBkeTMgZHg0IGR5NCBkeDUgZHk1IGR4NiBkeTYgZmQgZmxleCAoMTIgMzUpIHwtXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYzF4ID0geCAgICsgc3RhY2suc2hpZnQoKTsgICAgLy8gZHgxXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYzF5ID0geSAgICsgc3RhY2suc2hpZnQoKTsgICAgLy8gZHkxXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYzJ4ID0gYzF4ICsgc3RhY2suc2hpZnQoKTsgICAgLy8gZHgyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYzJ5ID0gYzF5ICsgc3RhY2suc2hpZnQoKTsgICAgLy8gZHkyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAganB4ID0gYzJ4ICsgc3RhY2suc2hpZnQoKTsgICAgLy8gZHgzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAganB5ID0gYzJ5ICsgc3RhY2suc2hpZnQoKTsgICAgLy8gZHkzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYzN4ID0ganB4ICsgc3RhY2suc2hpZnQoKTsgICAgLy8gZHg0XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYzN5ID0ganB5ICsgc3RhY2suc2hpZnQoKTsgICAgLy8gZHk0XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYzR4ID0gYzN4ICsgc3RhY2suc2hpZnQoKTsgICAgLy8gZHg1XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYzR5ID0gYzN5ICsgc3RhY2suc2hpZnQoKTsgICAgLy8gZHk1XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgeCA9IGM0eCAgICsgc3RhY2suc2hpZnQoKTsgICAgLy8gZHg2XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgeSA9IGM0eSAgICsgc3RhY2suc2hpZnQoKTsgICAgLy8gZHk2XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhY2suc2hpZnQoKTsgICAgICAgICAgICAgICAgLy8gZmxleCBkZXB0aFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHAuY3VydmVUbyhjMXgsIGMxeSwgYzJ4LCBjMnksIGpweCwganB5KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwLmN1cnZlVG8oYzN4LCBjM3ksIGM0eCwgYzR5LCB4LCB5KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMzQ6IC8vIGhmbGV4XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gfC0gZHgxIGR4MiBkeTIgZHgzIGR4NCBkeDUgZHg2IGhmbGV4ICgxMiAzNCkgfC1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjMXggPSB4ICAgKyBzdGFjay5zaGlmdCgpOyAgICAvLyBkeDFcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjMXkgPSB5OyAgICAgICAgICAgICAgICAgICAgICAvLyBkeTFcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjMnggPSBjMXggKyBzdGFjay5zaGlmdCgpOyAgICAvLyBkeDJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjMnkgPSBjMXkgKyBzdGFjay5zaGlmdCgpOyAgICAvLyBkeTJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBqcHggPSBjMnggKyBzdGFjay5zaGlmdCgpOyAgICAvLyBkeDNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBqcHkgPSBjMnk7ICAgICAgICAgICAgICAgICAgICAvLyBkeTNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjM3ggPSBqcHggKyBzdGFjay5zaGlmdCgpOyAgICAvLyBkeDRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjM3kgPSBjMnk7ICAgICAgICAgICAgICAgICAgICAvLyBkeTRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjNHggPSBjM3ggKyBzdGFjay5zaGlmdCgpOyAgICAvLyBkeDVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjNHkgPSB5OyAgICAgICAgICAgICAgICAgICAgICAvLyBkeTVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB4ID0gYzR4ICsgc3RhY2suc2hpZnQoKTsgICAgICAvLyBkeDZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwLmN1cnZlVG8oYzF4LCBjMXksIGMyeCwgYzJ5LCBqcHgsIGpweSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcC5jdXJ2ZVRvKGMzeCwgYzN5LCBjNHgsIGM0eSwgeCwgeSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDM2OiAvLyBoZmxleDFcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB8LSBkeDEgZHkxIGR4MiBkeTIgZHgzIGR4NCBkeDUgZHk1IGR4NiBoZmxleDEgKDEyIDM2KSB8LVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGMxeCA9IHggICArIHN0YWNrLnNoaWZ0KCk7ICAgIC8vIGR4MVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGMxeSA9IHkgICArIHN0YWNrLnNoaWZ0KCk7ICAgIC8vIGR5MVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGMyeCA9IGMxeCArIHN0YWNrLnNoaWZ0KCk7ICAgIC8vIGR4MlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGMyeSA9IGMxeSArIHN0YWNrLnNoaWZ0KCk7ICAgIC8vIGR5MlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGpweCA9IGMyeCArIHN0YWNrLnNoaWZ0KCk7ICAgIC8vIGR4M1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGpweSA9IGMyeTsgICAgICAgICAgICAgICAgICAgIC8vIGR5M1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGMzeCA9IGpweCArIHN0YWNrLnNoaWZ0KCk7ICAgIC8vIGR4NFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGMzeSA9IGMyeTsgICAgICAgICAgICAgICAgICAgIC8vIGR5NFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGM0eCA9IGMzeCArIHN0YWNrLnNoaWZ0KCk7ICAgIC8vIGR4NVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGM0eSA9IGMzeSArIHN0YWNrLnNoaWZ0KCk7ICAgIC8vIGR5NVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHggPSBjNHggKyBzdGFjay5zaGlmdCgpOyAgICAgIC8vIGR4NlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHAuY3VydmVUbyhjMXgsIGMxeSwgYzJ4LCBjMnksIGpweCwganB5KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwLmN1cnZlVG8oYzN4LCBjM3ksIGM0eCwgYzR5LCB4LCB5KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMzc6IC8vIGZsZXgxXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gfC0gZHgxIGR5MSBkeDIgZHkyIGR4MyBkeTMgZHg0IGR5NCBkeDUgZHk1IGQ2IGZsZXgxICgxMiAzNykgfC1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjMXggPSB4ICAgKyBzdGFjay5zaGlmdCgpOyAgICAvLyBkeDFcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjMXkgPSB5ICAgKyBzdGFjay5zaGlmdCgpOyAgICAvLyBkeTFcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjMnggPSBjMXggKyBzdGFjay5zaGlmdCgpOyAgICAvLyBkeDJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjMnkgPSBjMXkgKyBzdGFjay5zaGlmdCgpOyAgICAvLyBkeTJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBqcHggPSBjMnggKyBzdGFjay5zaGlmdCgpOyAgICAvLyBkeDNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBqcHkgPSBjMnkgKyBzdGFjay5zaGlmdCgpOyAgICAvLyBkeTNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjM3ggPSBqcHggKyBzdGFjay5zaGlmdCgpOyAgICAvLyBkeDRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjM3kgPSBqcHkgKyBzdGFjay5zaGlmdCgpOyAgICAvLyBkeTRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjNHggPSBjM3ggKyBzdGFjay5zaGlmdCgpOyAgICAvLyBkeDVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjNHkgPSBjM3kgKyBzdGFjay5zaGlmdCgpOyAgICAvLyBkeTVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoTWF0aC5hYnMoYzR4IC0geCkgPiBNYXRoLmFicyhjNHkgLSB5KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB4ID0gYzR4ICsgc3RhY2suc2hpZnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB5ID0gYzR5ICsgc3RhY2suc2hpZnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwLmN1cnZlVG8oYzF4LCBjMXksIGMyeCwgYzJ5LCBqcHgsIGpweSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcC5jdXJ2ZVRvKGMzeCwgYzN5LCBjNHgsIGM0eSwgeCwgeSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCdHbHlwaCAnICsgZ2x5cGguaW5kZXggKyAnOiB1bmtub3duIG9wZXJhdG9yICcgKyAxMjAwICsgdik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhY2subGVuZ3RoID0gMDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDE0OiAvLyBlbmRjaGFyXG4gICAgICAgICAgICAgICAgICAgIGlmIChzdGFjay5sZW5ndGggPiAwICYmICFoYXZlV2lkdGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHdpZHRoID0gc3RhY2suc2hpZnQoKSArIG5vbWluYWxXaWR0aFg7XG4gICAgICAgICAgICAgICAgICAgICAgICBoYXZlV2lkdGggPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wZW4pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHAuY2xvc2VQYXRoKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBvcGVuID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDE4OiAvLyBoc3RlbWhtXG4gICAgICAgICAgICAgICAgICAgIHBhcnNlU3RlbXMoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAxOTogLy8gaGludG1hc2tcbiAgICAgICAgICAgICAgICBjYXNlIDIwOiAvLyBjbnRybWFza1xuICAgICAgICAgICAgICAgICAgICBwYXJzZVN0ZW1zKCk7XG4gICAgICAgICAgICAgICAgICAgIGkgKz0gKG5TdGVtcyArIDcpID4+IDM7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgMjE6IC8vIHJtb3ZldG9cbiAgICAgICAgICAgICAgICAgICAgaWYgKHN0YWNrLmxlbmd0aCA+IDIgJiYgIWhhdmVXaWR0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgd2lkdGggPSBzdGFjay5zaGlmdCgpICsgbm9taW5hbFdpZHRoWDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGhhdmVXaWR0aCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICB5ICs9IHN0YWNrLnBvcCgpO1xuICAgICAgICAgICAgICAgICAgICB4ICs9IHN0YWNrLnBvcCgpO1xuICAgICAgICAgICAgICAgICAgICBuZXdDb250b3VyKHgsIHkpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDIyOiAvLyBobW92ZXRvXG4gICAgICAgICAgICAgICAgICAgIGlmIChzdGFjay5sZW5ndGggPiAxICYmICFoYXZlV2lkdGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHdpZHRoID0gc3RhY2suc2hpZnQoKSArIG5vbWluYWxXaWR0aFg7XG4gICAgICAgICAgICAgICAgICAgICAgICBoYXZlV2lkdGggPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgeCArPSBzdGFjay5wb3AoKTtcbiAgICAgICAgICAgICAgICAgICAgbmV3Q29udG91cih4LCB5KTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAyMzogLy8gdnN0ZW1obVxuICAgICAgICAgICAgICAgICAgICBwYXJzZVN0ZW1zKCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgMjQ6IC8vIHJjdXJ2ZWxpbmVcbiAgICAgICAgICAgICAgICAgICAgd2hpbGUgKHN0YWNrLmxlbmd0aCA+IDIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGMxeCA9IHggKyBzdGFjay5zaGlmdCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYzF5ID0geSArIHN0YWNrLnNoaWZ0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjMnggPSBjMXggKyBzdGFjay5zaGlmdCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYzJ5ID0gYzF5ICsgc3RhY2suc2hpZnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHggPSBjMnggKyBzdGFjay5zaGlmdCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgeSA9IGMyeSArIHN0YWNrLnNoaWZ0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBwLmN1cnZlVG8oYzF4LCBjMXksIGMyeCwgYzJ5LCB4LCB5KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIHggKz0gc3RhY2suc2hpZnQoKTtcbiAgICAgICAgICAgICAgICAgICAgeSArPSBzdGFjay5zaGlmdCgpO1xuICAgICAgICAgICAgICAgICAgICBwLmxpbmVUbyh4LCB5KTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAyNTogLy8gcmxpbmVjdXJ2ZVxuICAgICAgICAgICAgICAgICAgICB3aGlsZSAoc3RhY2subGVuZ3RoID4gNikge1xuICAgICAgICAgICAgICAgICAgICAgICAgeCArPSBzdGFjay5zaGlmdCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgeSArPSBzdGFjay5zaGlmdCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcC5saW5lVG8oeCwgeSk7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBjMXggPSB4ICsgc3RhY2suc2hpZnQoKTtcbiAgICAgICAgICAgICAgICAgICAgYzF5ID0geSArIHN0YWNrLnNoaWZ0KCk7XG4gICAgICAgICAgICAgICAgICAgIGMyeCA9IGMxeCArIHN0YWNrLnNoaWZ0KCk7XG4gICAgICAgICAgICAgICAgICAgIGMyeSA9IGMxeSArIHN0YWNrLnNoaWZ0KCk7XG4gICAgICAgICAgICAgICAgICAgIHggPSBjMnggKyBzdGFjay5zaGlmdCgpO1xuICAgICAgICAgICAgICAgICAgICB5ID0gYzJ5ICsgc3RhY2suc2hpZnQoKTtcbiAgICAgICAgICAgICAgICAgICAgcC5jdXJ2ZVRvKGMxeCwgYzF5LCBjMngsIGMyeSwgeCwgeSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgMjY6IC8vIHZ2Y3VydmV0b1xuICAgICAgICAgICAgICAgICAgICBpZiAoc3RhY2subGVuZ3RoICUgMikge1xuICAgICAgICAgICAgICAgICAgICAgICAgeCArPSBzdGFjay5zaGlmdCgpO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgd2hpbGUgKHN0YWNrLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGMxeCA9IHg7XG4gICAgICAgICAgICAgICAgICAgICAgICBjMXkgPSB5ICsgc3RhY2suc2hpZnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGMyeCA9IGMxeCArIHN0YWNrLnNoaWZ0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjMnkgPSBjMXkgKyBzdGFjay5zaGlmdCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgeCA9IGMyeDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHkgPSBjMnkgKyBzdGFjay5zaGlmdCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcC5jdXJ2ZVRvKGMxeCwgYzF5LCBjMngsIGMyeSwgeCwgeSk7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDI3OiAvLyBoaGN1cnZldG9cbiAgICAgICAgICAgICAgICAgICAgaWYgKHN0YWNrLmxlbmd0aCAlIDIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHkgKz0gc3RhY2suc2hpZnQoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIHdoaWxlIChzdGFjay5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjMXggPSB4ICsgc3RhY2suc2hpZnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGMxeSA9IHk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjMnggPSBjMXggKyBzdGFjay5zaGlmdCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYzJ5ID0gYzF5ICsgc3RhY2suc2hpZnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHggPSBjMnggKyBzdGFjay5zaGlmdCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgeSA9IGMyeTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHAuY3VydmVUbyhjMXgsIGMxeSwgYzJ4LCBjMnksIHgsIHkpO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAyODogLy8gc2hvcnRpbnRcbiAgICAgICAgICAgICAgICAgICAgYjEgPSBjb2RlW2ldO1xuICAgICAgICAgICAgICAgICAgICBiMiA9IGNvZGVbaSArIDFdO1xuICAgICAgICAgICAgICAgICAgICBzdGFjay5wdXNoKCgoYjEgPDwgMjQpIHwgKGIyIDw8IDE2KSkgPj4gMTYpO1xuICAgICAgICAgICAgICAgICAgICBpICs9IDI7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgMjk6IC8vIGNhbGxnc3ViclxuICAgICAgICAgICAgICAgICAgICBjb2RlSW5kZXggPSBzdGFjay5wb3AoKSArIGZvbnQuZ3N1YnJzQmlhcztcbiAgICAgICAgICAgICAgICAgICAgc3VickNvZGUgPSBmb250LmdzdWJyc1tjb2RlSW5kZXhdO1xuICAgICAgICAgICAgICAgICAgICBpZiAoc3VickNvZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcnNlKHN1YnJDb2RlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgMzA6IC8vIHZoY3VydmV0b1xuICAgICAgICAgICAgICAgICAgICB3aGlsZSAoc3RhY2subGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYzF4ID0geDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGMxeSA9IHkgKyBzdGFjay5zaGlmdCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYzJ4ID0gYzF4ICsgc3RhY2suc2hpZnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGMyeSA9IGMxeSArIHN0YWNrLnNoaWZ0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB4ID0gYzJ4ICsgc3RhY2suc2hpZnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHkgPSBjMnkgKyAoc3RhY2subGVuZ3RoID09PSAxID8gc3RhY2suc2hpZnQoKSA6IDApO1xuICAgICAgICAgICAgICAgICAgICAgICAgcC5jdXJ2ZVRvKGMxeCwgYzF5LCBjMngsIGMyeSwgeCwgeSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoc3RhY2subGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGMxeCA9IHggKyBzdGFjay5zaGlmdCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYzF5ID0geTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGMyeCA9IGMxeCArIHN0YWNrLnNoaWZ0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjMnkgPSBjMXkgKyBzdGFjay5zaGlmdCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgeSA9IGMyeSArIHN0YWNrLnNoaWZ0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB4ID0gYzJ4ICsgKHN0YWNrLmxlbmd0aCA9PT0gMSA/IHN0YWNrLnNoaWZ0KCkgOiAwKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHAuY3VydmVUbyhjMXgsIGMxeSwgYzJ4LCBjMnksIHgsIHkpO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAzMTogLy8gaHZjdXJ2ZXRvXG4gICAgICAgICAgICAgICAgICAgIHdoaWxlIChzdGFjay5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjMXggPSB4ICsgc3RhY2suc2hpZnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGMxeSA9IHk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjMnggPSBjMXggKyBzdGFjay5zaGlmdCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYzJ5ID0gYzF5ICsgc3RhY2suc2hpZnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHkgPSBjMnkgKyBzdGFjay5zaGlmdCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgeCA9IGMyeCArIChzdGFjay5sZW5ndGggPT09IDEgPyBzdGFjay5zaGlmdCgpIDogMCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBwLmN1cnZlVG8oYzF4LCBjMXksIGMyeCwgYzJ5LCB4LCB5KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzdGFjay5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgYzF4ID0geDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGMxeSA9IHkgKyBzdGFjay5zaGlmdCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYzJ4ID0gYzF4ICsgc3RhY2suc2hpZnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGMyeSA9IGMxeSArIHN0YWNrLnNoaWZ0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB4ID0gYzJ4ICsgc3RhY2suc2hpZnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHkgPSBjMnkgKyAoc3RhY2subGVuZ3RoID09PSAxID8gc3RhY2suc2hpZnQoKSA6IDApO1xuICAgICAgICAgICAgICAgICAgICAgICAgcC5jdXJ2ZVRvKGMxeCwgYzF5LCBjMngsIGMyeSwgeCwgeSk7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICBpZiAodiA8IDMyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZygnR2x5cGggJyArIGdseXBoLmluZGV4ICsgJzogdW5rbm93biBvcGVyYXRvciAnICsgdik7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAodiA8IDI0Nykge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RhY2sucHVzaCh2IC0gMTM5KTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmICh2IDwgMjUxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBiMSA9IGNvZGVbaV07XG4gICAgICAgICAgICAgICAgICAgICAgICBpICs9IDE7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdGFjay5wdXNoKCh2IC0gMjQ3KSAqIDI1NiArIGIxICsgMTA4KTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmICh2IDwgMjU1KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBiMSA9IGNvZGVbaV07XG4gICAgICAgICAgICAgICAgICAgICAgICBpICs9IDE7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdGFjay5wdXNoKC0odiAtIDI1MSkgKiAyNTYgLSBiMSAtIDEwOCk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBiMSA9IGNvZGVbaV07XG4gICAgICAgICAgICAgICAgICAgICAgICBiMiA9IGNvZGVbaSArIDFdO1xuICAgICAgICAgICAgICAgICAgICAgICAgYjMgPSBjb2RlW2kgKyAyXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGI0ID0gY29kZVtpICsgM107XG4gICAgICAgICAgICAgICAgICAgICAgICBpICs9IDQ7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdGFjay5wdXNoKCgoYjEgPDwgMjQpIHwgKGIyIDw8IDE2KSB8IChiMyA8PCA4KSB8IGI0KSAvIDY1NTM2KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgcGFyc2UoY29kZSk7XG5cbiAgICBnbHlwaC5hZHZhbmNlV2lkdGggPSB3aWR0aDtcbiAgICByZXR1cm4gcDtcbn1cblxuZnVuY3Rpb24gcGFyc2VDRkZGRFNlbGVjdChkYXRhLCBzdGFydCwgbkdseXBocywgZmRBcnJheUNvdW50KSB7XG4gICAgdmFyIGZkU2VsZWN0ID0gW107XG4gICAgdmFyIGZkSW5kZXg7XG4gICAgdmFyIHBhcnNlciA9IG5ldyBwYXJzZS5QYXJzZXIoZGF0YSwgc3RhcnQpO1xuICAgIHZhciBmb3JtYXQgPSBwYXJzZXIucGFyc2VDYXJkOCgpO1xuICAgIGlmIChmb3JtYXQgPT09IDApIHtcbiAgICAgICAgLy8gU2ltcGxlIGxpc3Qgb2YgbkdseXBocyBlbGVtZW50c1xuICAgICAgICBmb3IgKHZhciBpR2lkID0gMDsgaUdpZCA8IG5HbHlwaHM7IGlHaWQrKykge1xuICAgICAgICAgICAgZmRJbmRleCA9IHBhcnNlci5wYXJzZUNhcmQ4KCk7XG4gICAgICAgICAgICBpZiAoZmRJbmRleCA+PSBmZEFycmF5Q291bnQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NGRiB0YWJsZSBDSUQgRm9udCBGRFNlbGVjdCBoYXMgYmFkIEZEIGluZGV4IHZhbHVlICcgKyBmZEluZGV4ICsgJyAoRkQgY291bnQgJyArIGZkQXJyYXlDb3VudCArICcpJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmZFNlbGVjdC5wdXNoKGZkSW5kZXgpO1xuICAgICAgICB9XG4gICAgfSBlbHNlIGlmIChmb3JtYXQgPT09IDMpIHtcbiAgICAgICAgLy8gUmFuZ2VzXG4gICAgICAgIHZhciBuUmFuZ2VzID0gcGFyc2VyLnBhcnNlQ2FyZDE2KCk7XG4gICAgICAgIHZhciBmaXJzdCA9IHBhcnNlci5wYXJzZUNhcmQxNigpO1xuICAgICAgICBpZiAoZmlyc3QgIT09IDApIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ0ZGIFRhYmxlIENJRCBGb250IEZEU2VsZWN0IGZvcm1hdCAzIHJhbmdlIGhhcyBiYWQgaW5pdGlhbCBHSUQgJyArIGZpcnN0KTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgbmV4dDtcbiAgICAgICAgZm9yICh2YXIgaVJhbmdlID0gMDsgaVJhbmdlIDwgblJhbmdlczsgaVJhbmdlKyspIHtcbiAgICAgICAgICAgIGZkSW5kZXggPSBwYXJzZXIucGFyc2VDYXJkOCgpO1xuICAgICAgICAgICAgbmV4dCA9IHBhcnNlci5wYXJzZUNhcmQxNigpO1xuICAgICAgICAgICAgaWYgKGZkSW5kZXggPj0gZmRBcnJheUNvdW50KSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDRkYgdGFibGUgQ0lEIEZvbnQgRkRTZWxlY3QgaGFzIGJhZCBGRCBpbmRleCB2YWx1ZSAnICsgZmRJbmRleCArICcgKEZEIGNvdW50ICcgKyBmZEFycmF5Q291bnQgKyAnKScpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG5leHQgPiBuR2x5cGhzKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDRkYgVGFibGUgQ0lEIEZvbnQgRkRTZWxlY3QgZm9ybWF0IDMgcmFuZ2UgaGFzIGJhZCBHSUQgJyArIG5leHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yICg7IGZpcnN0IDwgbmV4dDsgZmlyc3QrKykge1xuICAgICAgICAgICAgICAgIGZkU2VsZWN0LnB1c2goZmRJbmRleCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmaXJzdCA9IG5leHQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG5leHQgIT09IG5HbHlwaHMpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ0ZGIFRhYmxlIENJRCBGb250IEZEU2VsZWN0IGZvcm1hdCAzIHJhbmdlIGhhcyBiYWQgZmluYWwgR0lEICcgKyBuZXh0KTtcbiAgICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignQ0ZGIFRhYmxlIENJRCBGb250IEZEU2VsZWN0IHRhYmxlIGhhcyB1bnN1cHBvcnRlZCBmb3JtYXQgJyArIGZvcm1hdCk7XG4gICAgfVxuICAgIHJldHVybiBmZFNlbGVjdDtcbn1cblxuLy8gUGFyc2UgdGhlIGBDRkZgIHRhYmxlLCB3aGljaCBjb250YWlucyB0aGUgZ2x5cGggb3V0bGluZXMgaW4gUG9zdFNjcmlwdCBmb3JtYXQuXG5mdW5jdGlvbiBwYXJzZUNGRlRhYmxlKGRhdGEsIHN0YXJ0LCBmb250LCBvcHQpIHtcbiAgICBmb250LnRhYmxlcy5jZmYgPSB7fTtcbiAgICB2YXIgaGVhZGVyID0gcGFyc2VDRkZIZWFkZXIoZGF0YSwgc3RhcnQpO1xuICAgIHZhciBuYW1lSW5kZXggPSBwYXJzZUNGRkluZGV4KGRhdGEsIGhlYWRlci5lbmRPZmZzZXQsIHBhcnNlLmJ5dGVzVG9TdHJpbmcpO1xuICAgIHZhciB0b3BEaWN0SW5kZXggPSBwYXJzZUNGRkluZGV4KGRhdGEsIG5hbWVJbmRleC5lbmRPZmZzZXQpO1xuICAgIHZhciBzdHJpbmdJbmRleCA9IHBhcnNlQ0ZGSW5kZXgoZGF0YSwgdG9wRGljdEluZGV4LmVuZE9mZnNldCwgcGFyc2UuYnl0ZXNUb1N0cmluZyk7XG4gICAgdmFyIGdsb2JhbFN1YnJJbmRleCA9IHBhcnNlQ0ZGSW5kZXgoZGF0YSwgc3RyaW5nSW5kZXguZW5kT2Zmc2V0KTtcbiAgICBmb250LmdzdWJycyA9IGdsb2JhbFN1YnJJbmRleC5vYmplY3RzO1xuICAgIGZvbnQuZ3N1YnJzQmlhcyA9IGNhbGNDRkZTdWJyb3V0aW5lQmlhcyhmb250LmdzdWJycyk7XG5cbiAgICB2YXIgdG9wRGljdEFycmF5ID0gZ2F0aGVyQ0ZGVG9wRGljdHMoZGF0YSwgc3RhcnQsIHRvcERpY3RJbmRleC5vYmplY3RzLCBzdHJpbmdJbmRleC5vYmplY3RzKTtcbiAgICBpZiAodG9wRGljdEFycmF5Lmxlbmd0aCAhPT0gMSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NGRiB0YWJsZSBoYXMgdG9vIG1hbnkgZm9udHMgaW4gXFwnRm9udFNldFxcJyAtIGNvdW50IG9mIGZvbnRzIE5hbWVJbmRleC5sZW5ndGggPSAnICsgdG9wRGljdEFycmF5Lmxlbmd0aCk7XG4gICAgfVxuXG4gICAgdmFyIHRvcERpY3QgPSB0b3BEaWN0QXJyYXlbMF07XG4gICAgZm9udC50YWJsZXMuY2ZmLnRvcERpY3QgPSB0b3BEaWN0O1xuXG4gICAgaWYgKHRvcERpY3QuX3ByaXZhdGVEaWN0KSB7XG4gICAgICAgIGZvbnQuZGVmYXVsdFdpZHRoWCA9IHRvcERpY3QuX3ByaXZhdGVEaWN0LmRlZmF1bHRXaWR0aFg7XG4gICAgICAgIGZvbnQubm9taW5hbFdpZHRoWCA9IHRvcERpY3QuX3ByaXZhdGVEaWN0Lm5vbWluYWxXaWR0aFg7XG4gICAgfVxuXG4gICAgaWYgKHRvcERpY3Qucm9zWzBdICE9PSB1bmRlZmluZWQgJiYgdG9wRGljdC5yb3NbMV0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBmb250LmlzQ0lERm9udCA9IHRydWU7XG4gICAgfVxuXG4gICAgaWYgKGZvbnQuaXNDSURGb250KSB7XG4gICAgICAgIHZhciBmZEFycmF5T2Zmc2V0ID0gdG9wRGljdC5mZEFycmF5O1xuICAgICAgICB2YXIgZmRTZWxlY3RPZmZzZXQgPSB0b3BEaWN0LmZkU2VsZWN0O1xuICAgICAgICBpZiAoZmRBcnJheU9mZnNldCA9PT0gMCB8fCBmZFNlbGVjdE9mZnNldCA9PT0gMCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdGb250IGlzIG1hcmtlZCBhcyBhIENJRCBmb250LCBidXQgRkRBcnJheSBhbmQvb3IgRkRTZWxlY3QgaW5mb3JtYXRpb24gaXMgbWlzc2luZycpO1xuICAgICAgICB9XG4gICAgICAgIGZkQXJyYXlPZmZzZXQgKz0gc3RhcnQ7XG4gICAgICAgIHZhciBmZEFycmF5SW5kZXggPSBwYXJzZUNGRkluZGV4KGRhdGEsIGZkQXJyYXlPZmZzZXQpO1xuICAgICAgICB2YXIgZmRBcnJheSA9IGdhdGhlckNGRlRvcERpY3RzKGRhdGEsIHN0YXJ0LCBmZEFycmF5SW5kZXgub2JqZWN0cywgc3RyaW5nSW5kZXgub2JqZWN0cyk7XG4gICAgICAgIHRvcERpY3QuX2ZkQXJyYXkgPSBmZEFycmF5O1xuICAgICAgICBmZFNlbGVjdE9mZnNldCArPSBzdGFydDtcbiAgICAgICAgdG9wRGljdC5fZmRTZWxlY3QgPSBwYXJzZUNGRkZEU2VsZWN0KGRhdGEsIGZkU2VsZWN0T2Zmc2V0LCBmb250Lm51bUdseXBocywgZmRBcnJheS5sZW5ndGgpO1xuICAgIH1cblxuICAgIHZhciBwcml2YXRlRGljdE9mZnNldCA9IHN0YXJ0ICsgdG9wRGljdC5wcml2YXRlWzFdO1xuICAgIHZhciBwcml2YXRlRGljdCA9IHBhcnNlQ0ZGUHJpdmF0ZURpY3QoZGF0YSwgcHJpdmF0ZURpY3RPZmZzZXQsIHRvcERpY3QucHJpdmF0ZVswXSwgc3RyaW5nSW5kZXgub2JqZWN0cyk7XG4gICAgZm9udC5kZWZhdWx0V2lkdGhYID0gcHJpdmF0ZURpY3QuZGVmYXVsdFdpZHRoWDtcbiAgICBmb250Lm5vbWluYWxXaWR0aFggPSBwcml2YXRlRGljdC5ub21pbmFsV2lkdGhYO1xuXG4gICAgaWYgKHByaXZhdGVEaWN0LnN1YnJzICE9PSAwKSB7XG4gICAgICAgIHZhciBzdWJyT2Zmc2V0ID0gcHJpdmF0ZURpY3RPZmZzZXQgKyBwcml2YXRlRGljdC5zdWJycztcbiAgICAgICAgdmFyIHN1YnJJbmRleCA9IHBhcnNlQ0ZGSW5kZXgoZGF0YSwgc3Vick9mZnNldCk7XG4gICAgICAgIGZvbnQuc3VicnMgPSBzdWJySW5kZXgub2JqZWN0cztcbiAgICAgICAgZm9udC5zdWJyc0JpYXMgPSBjYWxjQ0ZGU3Vicm91dGluZUJpYXMoZm9udC5zdWJycyk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgZm9udC5zdWJycyA9IFtdO1xuICAgICAgICBmb250LnN1YnJzQmlhcyA9IDA7XG4gICAgfVxuXG4gICAgLy8gT2Zmc2V0cyBpbiB0aGUgdG9wIGRpY3QgYXJlIHJlbGF0aXZlIHRvIHRoZSBiZWdpbm5pbmcgb2YgdGhlIENGRiBkYXRhLCBzbyBhZGQgdGhlIENGRiBzdGFydCBvZmZzZXQuXG4gICAgdmFyIGNoYXJTdHJpbmdzSW5kZXg7XG4gICAgaWYgKG9wdC5sb3dNZW1vcnkpIHtcbiAgICAgICAgY2hhclN0cmluZ3NJbmRleCA9IHBhcnNlQ0ZGSW5kZXhMb3dNZW1vcnkoZGF0YSwgc3RhcnQgKyB0b3BEaWN0LmNoYXJTdHJpbmdzKTtcbiAgICAgICAgZm9udC5uR2x5cGhzID0gY2hhclN0cmluZ3NJbmRleC5vZmZzZXRzLmxlbmd0aDtcbiAgICB9IGVsc2Uge1xuICAgICAgICBjaGFyU3RyaW5nc0luZGV4ID0gcGFyc2VDRkZJbmRleChkYXRhLCBzdGFydCArIHRvcERpY3QuY2hhclN0cmluZ3MpO1xuICAgICAgICBmb250Lm5HbHlwaHMgPSBjaGFyU3RyaW5nc0luZGV4Lm9iamVjdHMubGVuZ3RoO1xuICAgIH1cblxuICAgIHZhciBjaGFyc2V0ID0gcGFyc2VDRkZDaGFyc2V0KGRhdGEsIHN0YXJ0ICsgdG9wRGljdC5jaGFyc2V0LCBmb250Lm5HbHlwaHMsIHN0cmluZ0luZGV4Lm9iamVjdHMpO1xuICAgIGlmICh0b3BEaWN0LmVuY29kaW5nID09PSAwKSB7XG4gICAgICAgIC8vIFN0YW5kYXJkIGVuY29kaW5nXG4gICAgICAgIGZvbnQuY2ZmRW5jb2RpbmcgPSBuZXcgQ2ZmRW5jb2RpbmcoY2ZmU3RhbmRhcmRFbmNvZGluZywgY2hhcnNldCk7XG4gICAgfSBlbHNlIGlmICh0b3BEaWN0LmVuY29kaW5nID09PSAxKSB7XG4gICAgICAgIC8vIEV4cGVydCBlbmNvZGluZ1xuICAgICAgICBmb250LmNmZkVuY29kaW5nID0gbmV3IENmZkVuY29kaW5nKGNmZkV4cGVydEVuY29kaW5nLCBjaGFyc2V0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBmb250LmNmZkVuY29kaW5nID0gcGFyc2VDRkZFbmNvZGluZyhkYXRhLCBzdGFydCArIHRvcERpY3QuZW5jb2RpbmcsIGNoYXJzZXQpO1xuICAgIH1cblxuICAgIC8vIFByZWZlciB0aGUgQ01BUCBlbmNvZGluZyB0byB0aGUgQ0ZGIGVuY29kaW5nLlxuICAgIGZvbnQuZW5jb2RpbmcgPSBmb250LmVuY29kaW5nIHx8IGZvbnQuY2ZmRW5jb2Rpbmc7XG5cbiAgICBmb250LmdseXBocyA9IG5ldyBnbHlwaHNldC5HbHlwaFNldChmb250KTtcbiAgICBpZiAob3B0Lmxvd01lbW9yeSkge1xuICAgICAgICBmb250Ll9wdXNoID0gZnVuY3Rpb24oaSkge1xuICAgICAgICAgICAgdmFyIGNoYXJTdHJpbmcgPSBnZXRDZmZJbmRleE9iamVjdChpLCBjaGFyU3RyaW5nc0luZGV4Lm9mZnNldHMsIGRhdGEsIHN0YXJ0ICsgdG9wRGljdC5jaGFyU3RyaW5ncyk7XG4gICAgICAgICAgICBmb250LmdseXBocy5wdXNoKGksIGdseXBoc2V0LmNmZkdseXBoTG9hZGVyKGZvbnQsIGksIHBhcnNlQ0ZGQ2hhcnN0cmluZywgY2hhclN0cmluZykpO1xuICAgICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZm9udC5uR2x5cGhzOyBpICs9IDEpIHtcbiAgICAgICAgICAgIHZhciBjaGFyU3RyaW5nID0gY2hhclN0cmluZ3NJbmRleC5vYmplY3RzW2ldO1xuICAgICAgICAgICAgZm9udC5nbHlwaHMucHVzaChpLCBnbHlwaHNldC5jZmZHbHlwaExvYWRlcihmb250LCBpLCBwYXJzZUNGRkNoYXJzdHJpbmcsIGNoYXJTdHJpbmcpKTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuLy8gQ29udmVydCBhIHN0cmluZyB0byBhIFN0cmluZyBJRCAoU0lEKS5cbi8vIFRoZSBsaXN0IG9mIHN0cmluZ3MgaXMgbW9kaWZpZWQgaW4gcGxhY2UuXG5mdW5jdGlvbiBlbmNvZGVTdHJpbmcocywgc3RyaW5ncykge1xuICAgIHZhciBzaWQ7XG5cbiAgICAvLyBJcyB0aGUgc3RyaW5nIGluIHRoZSBDRkYgc3RhbmRhcmQgc3RyaW5ncz9cbiAgICB2YXIgaSA9IGNmZlN0YW5kYXJkU3RyaW5ncy5pbmRleE9mKHMpO1xuICAgIGlmIChpID49IDApIHtcbiAgICAgICAgc2lkID0gaTtcbiAgICB9XG5cbiAgICAvLyBJcyB0aGUgc3RyaW5nIGFscmVhZHkgaW4gdGhlIHN0cmluZyBpbmRleD9cbiAgICBpID0gc3RyaW5ncy5pbmRleE9mKHMpO1xuICAgIGlmIChpID49IDApIHtcbiAgICAgICAgc2lkID0gaSArIGNmZlN0YW5kYXJkU3RyaW5ncy5sZW5ndGg7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgc2lkID0gY2ZmU3RhbmRhcmRTdHJpbmdzLmxlbmd0aCArIHN0cmluZ3MubGVuZ3RoO1xuICAgICAgICBzdHJpbmdzLnB1c2gocyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHNpZDtcbn1cblxuZnVuY3Rpb24gbWFrZUhlYWRlcigpIHtcbiAgICByZXR1cm4gbmV3IHRhYmxlLlJlY29yZCgnSGVhZGVyJywgW1xuICAgICAgICB7bmFtZTogJ21ham9yJywgdHlwZTogJ0NhcmQ4JywgdmFsdWU6IDF9LFxuICAgICAgICB7bmFtZTogJ21pbm9yJywgdHlwZTogJ0NhcmQ4JywgdmFsdWU6IDB9LFxuICAgICAgICB7bmFtZTogJ2hkclNpemUnLCB0eXBlOiAnQ2FyZDgnLCB2YWx1ZTogNH0sXG4gICAgICAgIHtuYW1lOiAnbWFqb3InLCB0eXBlOiAnQ2FyZDgnLCB2YWx1ZTogMX1cbiAgICBdKTtcbn1cblxuZnVuY3Rpb24gbWFrZU5hbWVJbmRleChmb250TmFtZXMpIHtcbiAgICB2YXIgdCA9IG5ldyB0YWJsZS5SZWNvcmQoJ05hbWUgSU5ERVgnLCBbXG4gICAgICAgIHtuYW1lOiAnbmFtZXMnLCB0eXBlOiAnSU5ERVgnLCB2YWx1ZTogW119XG4gICAgXSk7XG4gICAgdC5uYW1lcyA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZm9udE5hbWVzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgIHQubmFtZXMucHVzaCh7bmFtZTogJ25hbWVfJyArIGksIHR5cGU6ICdOQU1FJywgdmFsdWU6IGZvbnROYW1lc1tpXX0pO1xuICAgIH1cblxuICAgIHJldHVybiB0O1xufVxuXG4vLyBHaXZlbiBhIGRpY3Rpb25hcnkncyBtZXRhZGF0YSwgY3JlYXRlIGEgRElDVCBzdHJ1Y3R1cmUuXG5mdW5jdGlvbiBtYWtlRGljdChtZXRhLCBhdHRycywgc3RyaW5ncykge1xuICAgIHZhciBtID0ge307XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtZXRhLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgIHZhciBlbnRyeSA9IG1ldGFbaV07XG4gICAgICAgIHZhciB2YWx1ZSA9IGF0dHJzW2VudHJ5Lm5hbWVdO1xuICAgICAgICBpZiAodmFsdWUgIT09IHVuZGVmaW5lZCAmJiAhZXF1YWxzKHZhbHVlLCBlbnRyeS52YWx1ZSkpIHtcbiAgICAgICAgICAgIGlmIChlbnRyeS50eXBlID09PSAnU0lEJykge1xuICAgICAgICAgICAgICAgIHZhbHVlID0gZW5jb2RlU3RyaW5nKHZhbHVlLCBzdHJpbmdzKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgbVtlbnRyeS5vcF0gPSB7bmFtZTogZW50cnkubmFtZSwgdHlwZTogZW50cnkudHlwZSwgdmFsdWU6IHZhbHVlfTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBtO1xufVxuXG4vLyBUaGUgVG9wIERJQ1QgaG91c2VzIHRoZSBnbG9iYWwgZm9udCBhdHRyaWJ1dGVzLlxuZnVuY3Rpb24gbWFrZVRvcERpY3QoYXR0cnMsIHN0cmluZ3MpIHtcbiAgICB2YXIgdCA9IG5ldyB0YWJsZS5SZWNvcmQoJ1RvcCBESUNUJywgW1xuICAgICAgICB7bmFtZTogJ2RpY3QnLCB0eXBlOiAnRElDVCcsIHZhbHVlOiB7fX1cbiAgICBdKTtcbiAgICB0LmRpY3QgPSBtYWtlRGljdChUT1BfRElDVF9NRVRBLCBhdHRycywgc3RyaW5ncyk7XG4gICAgcmV0dXJuIHQ7XG59XG5cbmZ1bmN0aW9uIG1ha2VUb3BEaWN0SW5kZXgodG9wRGljdCkge1xuICAgIHZhciB0ID0gbmV3IHRhYmxlLlJlY29yZCgnVG9wIERJQ1QgSU5ERVgnLCBbXG4gICAgICAgIHtuYW1lOiAndG9wRGljdHMnLCB0eXBlOiAnSU5ERVgnLCB2YWx1ZTogW119XG4gICAgXSk7XG4gICAgdC50b3BEaWN0cyA9IFt7bmFtZTogJ3RvcERpY3RfMCcsIHR5cGU6ICdUQUJMRScsIHZhbHVlOiB0b3BEaWN0fV07XG4gICAgcmV0dXJuIHQ7XG59XG5cbmZ1bmN0aW9uIG1ha2VTdHJpbmdJbmRleChzdHJpbmdzKSB7XG4gICAgdmFyIHQgPSBuZXcgdGFibGUuUmVjb3JkKCdTdHJpbmcgSU5ERVgnLCBbXG4gICAgICAgIHtuYW1lOiAnc3RyaW5ncycsIHR5cGU6ICdJTkRFWCcsIHZhbHVlOiBbXX1cbiAgICBdKTtcbiAgICB0LnN0cmluZ3MgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHN0cmluZ3MubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgdC5zdHJpbmdzLnB1c2goe25hbWU6ICdzdHJpbmdfJyArIGksIHR5cGU6ICdTVFJJTkcnLCB2YWx1ZTogc3RyaW5nc1tpXX0pO1xuICAgIH1cblxuICAgIHJldHVybiB0O1xufVxuXG5mdW5jdGlvbiBtYWtlR2xvYmFsU3VickluZGV4KCkge1xuICAgIC8vIEN1cnJlbnRseSB3ZSBkb24ndCB1c2Ugc3Vicm91dGluZXMuXG4gICAgcmV0dXJuIG5ldyB0YWJsZS5SZWNvcmQoJ0dsb2JhbCBTdWJyIElOREVYJywgW1xuICAgICAgICB7bmFtZTogJ3N1YnJzJywgdHlwZTogJ0lOREVYJywgdmFsdWU6IFtdfVxuICAgIF0pO1xufVxuXG5mdW5jdGlvbiBtYWtlQ2hhcnNldHMoZ2x5cGhOYW1lcywgc3RyaW5ncykge1xuICAgIHZhciB0ID0gbmV3IHRhYmxlLlJlY29yZCgnQ2hhcnNldHMnLCBbXG4gICAgICAgIHtuYW1lOiAnZm9ybWF0JywgdHlwZTogJ0NhcmQ4JywgdmFsdWU6IDB9XG4gICAgXSk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBnbHlwaE5hbWVzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgIHZhciBnbHlwaE5hbWUgPSBnbHlwaE5hbWVzW2ldO1xuICAgICAgICB2YXIgZ2x5cGhTSUQgPSBlbmNvZGVTdHJpbmcoZ2x5cGhOYW1lLCBzdHJpbmdzKTtcbiAgICAgICAgdC5maWVsZHMucHVzaCh7bmFtZTogJ2dseXBoXycgKyBpLCB0eXBlOiAnU0lEJywgdmFsdWU6IGdseXBoU0lEfSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHQ7XG59XG5cbmZ1bmN0aW9uIGdseXBoVG9PcHMoZ2x5cGgpIHtcbiAgICB2YXIgb3BzID0gW107XG4gICAgdmFyIHBhdGggPSBnbHlwaC5wYXRoO1xuICAgIG9wcy5wdXNoKHtuYW1lOiAnd2lkdGgnLCB0eXBlOiAnTlVNQkVSJywgdmFsdWU6IGdseXBoLmFkdmFuY2VXaWR0aH0pO1xuICAgIHZhciB4ID0gMDtcbiAgICB2YXIgeSA9IDA7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwYXRoLmNvbW1hbmRzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgIHZhciBkeCA9ICh2b2lkIDApO1xuICAgICAgICB2YXIgZHkgPSAodm9pZCAwKTtcbiAgICAgICAgdmFyIGNtZCA9IHBhdGguY29tbWFuZHNbaV07XG4gICAgICAgIGlmIChjbWQudHlwZSA9PT0gJ1EnKSB7XG4gICAgICAgICAgICAvLyBDRkYgb25seSBzdXBwb3J0cyBiw6l6aWVyIGN1cnZlcywgc28gY29udmVydCB0aGUgcXVhZCB0byBhIGLDqXppZXIuXG4gICAgICAgICAgICB2YXIgXzEzID0gMSAvIDM7XG4gICAgICAgICAgICB2YXIgXzIzID0gMiAvIDM7XG5cbiAgICAgICAgICAgIC8vIFdlJ3JlIGdvaW5nIHRvIGNyZWF0ZSBhIG5ldyBjb21tYW5kIHNvIHdlIGRvbid0IGNoYW5nZSB0aGUgb3JpZ2luYWwgcGF0aC5cbiAgICAgICAgICAgIC8vIFNpbmNlIGFsbCBjb29yZGluYXRlcyBhcmUgcmVsYXRpdmUsIHdlIHJvdW5kKCkgdGhlbSBBU0FQIHRvIGF2b2lkIHByb3BhZ2F0aW5nIGVycm9ycy5cbiAgICAgICAgICAgIGNtZCA9IHtcbiAgICAgICAgICAgICAgICB0eXBlOiAnQycsXG4gICAgICAgICAgICAgICAgeDogY21kLngsXG4gICAgICAgICAgICAgICAgeTogY21kLnksXG4gICAgICAgICAgICAgICAgeDE6IE1hdGgucm91bmQoXzEzICogeCArIF8yMyAqIGNtZC54MSksXG4gICAgICAgICAgICAgICAgeTE6IE1hdGgucm91bmQoXzEzICogeSArIF8yMyAqIGNtZC55MSksXG4gICAgICAgICAgICAgICAgeDI6IE1hdGgucm91bmQoXzEzICogY21kLnggKyBfMjMgKiBjbWQueDEpLFxuICAgICAgICAgICAgICAgIHkyOiBNYXRoLnJvdW5kKF8xMyAqIGNtZC55ICsgXzIzICogY21kLnkxKVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChjbWQudHlwZSA9PT0gJ00nKSB7XG4gICAgICAgICAgICBkeCA9IE1hdGgucm91bmQoY21kLnggLSB4KTtcbiAgICAgICAgICAgIGR5ID0gTWF0aC5yb3VuZChjbWQueSAtIHkpO1xuICAgICAgICAgICAgb3BzLnB1c2goe25hbWU6ICdkeCcsIHR5cGU6ICdOVU1CRVInLCB2YWx1ZTogZHh9KTtcbiAgICAgICAgICAgIG9wcy5wdXNoKHtuYW1lOiAnZHknLCB0eXBlOiAnTlVNQkVSJywgdmFsdWU6IGR5fSk7XG4gICAgICAgICAgICBvcHMucHVzaCh7bmFtZTogJ3Jtb3ZldG8nLCB0eXBlOiAnT1AnLCB2YWx1ZTogMjF9KTtcbiAgICAgICAgICAgIHggPSBNYXRoLnJvdW5kKGNtZC54KTtcbiAgICAgICAgICAgIHkgPSBNYXRoLnJvdW5kKGNtZC55KTtcbiAgICAgICAgfSBlbHNlIGlmIChjbWQudHlwZSA9PT0gJ0wnKSB7XG4gICAgICAgICAgICBkeCA9IE1hdGgucm91bmQoY21kLnggLSB4KTtcbiAgICAgICAgICAgIGR5ID0gTWF0aC5yb3VuZChjbWQueSAtIHkpO1xuICAgICAgICAgICAgb3BzLnB1c2goe25hbWU6ICdkeCcsIHR5cGU6ICdOVU1CRVInLCB2YWx1ZTogZHh9KTtcbiAgICAgICAgICAgIG9wcy5wdXNoKHtuYW1lOiAnZHknLCB0eXBlOiAnTlVNQkVSJywgdmFsdWU6IGR5fSk7XG4gICAgICAgICAgICBvcHMucHVzaCh7bmFtZTogJ3JsaW5ldG8nLCB0eXBlOiAnT1AnLCB2YWx1ZTogNX0pO1xuICAgICAgICAgICAgeCA9IE1hdGgucm91bmQoY21kLngpO1xuICAgICAgICAgICAgeSA9IE1hdGgucm91bmQoY21kLnkpO1xuICAgICAgICB9IGVsc2UgaWYgKGNtZC50eXBlID09PSAnQycpIHtcbiAgICAgICAgICAgIHZhciBkeDEgPSBNYXRoLnJvdW5kKGNtZC54MSAtIHgpO1xuICAgICAgICAgICAgdmFyIGR5MSA9IE1hdGgucm91bmQoY21kLnkxIC0geSk7XG4gICAgICAgICAgICB2YXIgZHgyID0gTWF0aC5yb3VuZChjbWQueDIgLSBjbWQueDEpO1xuICAgICAgICAgICAgdmFyIGR5MiA9IE1hdGgucm91bmQoY21kLnkyIC0gY21kLnkxKTtcbiAgICAgICAgICAgIGR4ID0gTWF0aC5yb3VuZChjbWQueCAtIGNtZC54Mik7XG4gICAgICAgICAgICBkeSA9IE1hdGgucm91bmQoY21kLnkgLSBjbWQueTIpO1xuICAgICAgICAgICAgb3BzLnB1c2goe25hbWU6ICdkeDEnLCB0eXBlOiAnTlVNQkVSJywgdmFsdWU6IGR4MX0pO1xuICAgICAgICAgICAgb3BzLnB1c2goe25hbWU6ICdkeTEnLCB0eXBlOiAnTlVNQkVSJywgdmFsdWU6IGR5MX0pO1xuICAgICAgICAgICAgb3BzLnB1c2goe25hbWU6ICdkeDInLCB0eXBlOiAnTlVNQkVSJywgdmFsdWU6IGR4Mn0pO1xuICAgICAgICAgICAgb3BzLnB1c2goe25hbWU6ICdkeTInLCB0eXBlOiAnTlVNQkVSJywgdmFsdWU6IGR5Mn0pO1xuICAgICAgICAgICAgb3BzLnB1c2goe25hbWU6ICdkeCcsIHR5cGU6ICdOVU1CRVInLCB2YWx1ZTogZHh9KTtcbiAgICAgICAgICAgIG9wcy5wdXNoKHtuYW1lOiAnZHknLCB0eXBlOiAnTlVNQkVSJywgdmFsdWU6IGR5fSk7XG4gICAgICAgICAgICBvcHMucHVzaCh7bmFtZTogJ3JyY3VydmV0bycsIHR5cGU6ICdPUCcsIHZhbHVlOiA4fSk7XG4gICAgICAgICAgICB4ID0gTWF0aC5yb3VuZChjbWQueCk7XG4gICAgICAgICAgICB5ID0gTWF0aC5yb3VuZChjbWQueSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBDb250b3VycyBhcmUgY2xvc2VkIGF1dG9tYXRpY2FsbHkuXG4gICAgfVxuXG4gICAgb3BzLnB1c2goe25hbWU6ICdlbmRjaGFyJywgdHlwZTogJ09QJywgdmFsdWU6IDE0fSk7XG4gICAgcmV0dXJuIG9wcztcbn1cblxuZnVuY3Rpb24gbWFrZUNoYXJTdHJpbmdzSW5kZXgoZ2x5cGhzKSB7XG4gICAgdmFyIHQgPSBuZXcgdGFibGUuUmVjb3JkKCdDaGFyU3RyaW5ncyBJTkRFWCcsIFtcbiAgICAgICAge25hbWU6ICdjaGFyU3RyaW5ncycsIHR5cGU6ICdJTkRFWCcsIHZhbHVlOiBbXX1cbiAgICBdKTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZ2x5cGhzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgIHZhciBnbHlwaCA9IGdseXBocy5nZXQoaSk7XG4gICAgICAgIHZhciBvcHMgPSBnbHlwaFRvT3BzKGdseXBoKTtcbiAgICAgICAgdC5jaGFyU3RyaW5ncy5wdXNoKHtuYW1lOiBnbHlwaC5uYW1lLCB0eXBlOiAnQ0hBUlNUUklORycsIHZhbHVlOiBvcHN9KTtcbiAgICB9XG5cbiAgICByZXR1cm4gdDtcbn1cblxuZnVuY3Rpb24gbWFrZVByaXZhdGVEaWN0KGF0dHJzLCBzdHJpbmdzKSB7XG4gICAgdmFyIHQgPSBuZXcgdGFibGUuUmVjb3JkKCdQcml2YXRlIERJQ1QnLCBbXG4gICAgICAgIHtuYW1lOiAnZGljdCcsIHR5cGU6ICdESUNUJywgdmFsdWU6IHt9fVxuICAgIF0pO1xuICAgIHQuZGljdCA9IG1ha2VEaWN0KFBSSVZBVEVfRElDVF9NRVRBLCBhdHRycywgc3RyaW5ncyk7XG4gICAgcmV0dXJuIHQ7XG59XG5cbmZ1bmN0aW9uIG1ha2VDRkZUYWJsZShnbHlwaHMsIG9wdGlvbnMpIHtcbiAgICB2YXIgdCA9IG5ldyB0YWJsZS5UYWJsZSgnQ0ZGICcsIFtcbiAgICAgICAge25hbWU6ICdoZWFkZXInLCB0eXBlOiAnUkVDT1JEJ30sXG4gICAgICAgIHtuYW1lOiAnbmFtZUluZGV4JywgdHlwZTogJ1JFQ09SRCd9LFxuICAgICAgICB7bmFtZTogJ3RvcERpY3RJbmRleCcsIHR5cGU6ICdSRUNPUkQnfSxcbiAgICAgICAge25hbWU6ICdzdHJpbmdJbmRleCcsIHR5cGU6ICdSRUNPUkQnfSxcbiAgICAgICAge25hbWU6ICdnbG9iYWxTdWJySW5kZXgnLCB0eXBlOiAnUkVDT1JEJ30sXG4gICAgICAgIHtuYW1lOiAnY2hhcnNldHMnLCB0eXBlOiAnUkVDT1JEJ30sXG4gICAgICAgIHtuYW1lOiAnY2hhclN0cmluZ3NJbmRleCcsIHR5cGU6ICdSRUNPUkQnfSxcbiAgICAgICAge25hbWU6ICdwcml2YXRlRGljdCcsIHR5cGU6ICdSRUNPUkQnfVxuICAgIF0pO1xuXG4gICAgdmFyIGZvbnRTY2FsZSA9IDEgLyBvcHRpb25zLnVuaXRzUGVyRW07XG4gICAgLy8gV2UgdXNlIG5vbi16ZXJvIHZhbHVlcyBmb3IgdGhlIG9mZnNldHMgc28gdGhhdCB0aGUgRElDVCBlbmNvZGVzIHRoZW0uXG4gICAgLy8gVGhpcyBpcyBpbXBvcnRhbnQgYmVjYXVzZSB0aGUgc2l6ZSBvZiB0aGUgVG9wIERJQ1QgcGxheXMgYSByb2xlIGluIG9mZnNldCBjYWxjdWxhdGlvbixcbiAgICAvLyBhbmQgdGhlIHNpemUgc2hvdWxkbid0IGNoYW5nZSBhZnRlciB3ZSd2ZSB3cml0dGVuIGNvcnJlY3Qgb2Zmc2V0cy5cbiAgICB2YXIgYXR0cnMgPSB7XG4gICAgICAgIHZlcnNpb246IG9wdGlvbnMudmVyc2lvbixcbiAgICAgICAgZnVsbE5hbWU6IG9wdGlvbnMuZnVsbE5hbWUsXG4gICAgICAgIGZhbWlseU5hbWU6IG9wdGlvbnMuZmFtaWx5TmFtZSxcbiAgICAgICAgd2VpZ2h0OiBvcHRpb25zLndlaWdodE5hbWUsXG4gICAgICAgIGZvbnRCQm94OiBvcHRpb25zLmZvbnRCQm94IHx8IFswLCAwLCAwLCAwXSxcbiAgICAgICAgZm9udE1hdHJpeDogW2ZvbnRTY2FsZSwgMCwgMCwgZm9udFNjYWxlLCAwLCAwXSxcbiAgICAgICAgY2hhcnNldDogOTk5LFxuICAgICAgICBlbmNvZGluZzogMCxcbiAgICAgICAgY2hhclN0cmluZ3M6IDk5OSxcbiAgICAgICAgcHJpdmF0ZTogWzAsIDk5OV1cbiAgICB9O1xuXG4gICAgdmFyIHByaXZhdGVBdHRycyA9IHt9O1xuXG4gICAgdmFyIGdseXBoTmFtZXMgPSBbXTtcbiAgICB2YXIgZ2x5cGg7XG5cbiAgICAvLyBTa2lwIGZpcnN0IGdseXBoICgubm90ZGVmKVxuICAgIGZvciAodmFyIGkgPSAxOyBpIDwgZ2x5cGhzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgIGdseXBoID0gZ2x5cGhzLmdldChpKTtcbiAgICAgICAgZ2x5cGhOYW1lcy5wdXNoKGdseXBoLm5hbWUpO1xuICAgIH1cblxuICAgIHZhciBzdHJpbmdzID0gW107XG5cbiAgICB0LmhlYWRlciA9IG1ha2VIZWFkZXIoKTtcbiAgICB0Lm5hbWVJbmRleCA9IG1ha2VOYW1lSW5kZXgoW29wdGlvbnMucG9zdFNjcmlwdE5hbWVdKTtcbiAgICB2YXIgdG9wRGljdCA9IG1ha2VUb3BEaWN0KGF0dHJzLCBzdHJpbmdzKTtcbiAgICB0LnRvcERpY3RJbmRleCA9IG1ha2VUb3BEaWN0SW5kZXgodG9wRGljdCk7XG4gICAgdC5nbG9iYWxTdWJySW5kZXggPSBtYWtlR2xvYmFsU3VickluZGV4KCk7XG4gICAgdC5jaGFyc2V0cyA9IG1ha2VDaGFyc2V0cyhnbHlwaE5hbWVzLCBzdHJpbmdzKTtcbiAgICB0LmNoYXJTdHJpbmdzSW5kZXggPSBtYWtlQ2hhclN0cmluZ3NJbmRleChnbHlwaHMpO1xuICAgIHQucHJpdmF0ZURpY3QgPSBtYWtlUHJpdmF0ZURpY3QocHJpdmF0ZUF0dHJzLCBzdHJpbmdzKTtcblxuICAgIC8vIE5lZWRzIHRvIGNvbWUgYXQgdGhlIGVuZCwgdG8gZW5jb2RlIGFsbCBjdXN0b20gc3RyaW5ncyB1c2VkIGluIHRoZSBmb250LlxuICAgIHQuc3RyaW5nSW5kZXggPSBtYWtlU3RyaW5nSW5kZXgoc3RyaW5ncyk7XG5cbiAgICB2YXIgc3RhcnRPZmZzZXQgPSB0LmhlYWRlci5zaXplT2YoKSArXG4gICAgICAgIHQubmFtZUluZGV4LnNpemVPZigpICtcbiAgICAgICAgdC50b3BEaWN0SW5kZXguc2l6ZU9mKCkgK1xuICAgICAgICB0LnN0cmluZ0luZGV4LnNpemVPZigpICtcbiAgICAgICAgdC5nbG9iYWxTdWJySW5kZXguc2l6ZU9mKCk7XG4gICAgYXR0cnMuY2hhcnNldCA9IHN0YXJ0T2Zmc2V0O1xuXG4gICAgLy8gV2UgdXNlIHRoZSBDRkYgc3RhbmRhcmQgZW5jb2Rpbmc7IHByb3BlciBlbmNvZGluZyB3aWxsIGJlIGhhbmRsZWQgaW4gY21hcC5cbiAgICBhdHRycy5lbmNvZGluZyA9IDA7XG4gICAgYXR0cnMuY2hhclN0cmluZ3MgPSBhdHRycy5jaGFyc2V0ICsgdC5jaGFyc2V0cy5zaXplT2YoKTtcbiAgICBhdHRycy5wcml2YXRlWzFdID0gYXR0cnMuY2hhclN0cmluZ3MgKyB0LmNoYXJTdHJpbmdzSW5kZXguc2l6ZU9mKCk7XG5cbiAgICAvLyBSZWNyZWF0ZSB0aGUgVG9wIERJQ1QgSU5ERVggd2l0aCB0aGUgY29ycmVjdCBvZmZzZXRzLlxuICAgIHRvcERpY3QgPSBtYWtlVG9wRGljdChhdHRycywgc3RyaW5ncyk7XG4gICAgdC50b3BEaWN0SW5kZXggPSBtYWtlVG9wRGljdEluZGV4KHRvcERpY3QpO1xuXG4gICAgcmV0dXJuIHQ7XG59XG5cbnZhciBjZmYgPSB7IHBhcnNlOiBwYXJzZUNGRlRhYmxlLCBtYWtlOiBtYWtlQ0ZGVGFibGUgfTtcblxuLy8gVGhlIGBoZWFkYCB0YWJsZSBjb250YWlucyBnbG9iYWwgaW5mb3JtYXRpb24gYWJvdXQgdGhlIGZvbnQuXG5cbi8vIFBhcnNlIHRoZSBoZWFkZXIgYGhlYWRgIHRhYmxlXG5mdW5jdGlvbiBwYXJzZUhlYWRUYWJsZShkYXRhLCBzdGFydCkge1xuICAgIHZhciBoZWFkID0ge307XG4gICAgdmFyIHAgPSBuZXcgcGFyc2UuUGFyc2VyKGRhdGEsIHN0YXJ0KTtcbiAgICBoZWFkLnZlcnNpb24gPSBwLnBhcnNlVmVyc2lvbigpO1xuICAgIGhlYWQuZm9udFJldmlzaW9uID0gTWF0aC5yb3VuZChwLnBhcnNlRml4ZWQoKSAqIDEwMDApIC8gMTAwMDtcbiAgICBoZWFkLmNoZWNrU3VtQWRqdXN0bWVudCA9IHAucGFyc2VVTG9uZygpO1xuICAgIGhlYWQubWFnaWNOdW1iZXIgPSBwLnBhcnNlVUxvbmcoKTtcbiAgICBjaGVjay5hcmd1bWVudChoZWFkLm1hZ2ljTnVtYmVyID09PSAweDVGMEYzQ0Y1LCAnRm9udCBoZWFkZXIgaGFzIHdyb25nIG1hZ2ljIG51bWJlci4nKTtcbiAgICBoZWFkLmZsYWdzID0gcC5wYXJzZVVTaG9ydCgpO1xuICAgIGhlYWQudW5pdHNQZXJFbSA9IHAucGFyc2VVU2hvcnQoKTtcbiAgICBoZWFkLmNyZWF0ZWQgPSBwLnBhcnNlTG9uZ0RhdGVUaW1lKCk7XG4gICAgaGVhZC5tb2RpZmllZCA9IHAucGFyc2VMb25nRGF0ZVRpbWUoKTtcbiAgICBoZWFkLnhNaW4gPSBwLnBhcnNlU2hvcnQoKTtcbiAgICBoZWFkLnlNaW4gPSBwLnBhcnNlU2hvcnQoKTtcbiAgICBoZWFkLnhNYXggPSBwLnBhcnNlU2hvcnQoKTtcbiAgICBoZWFkLnlNYXggPSBwLnBhcnNlU2hvcnQoKTtcbiAgICBoZWFkLm1hY1N0eWxlID0gcC5wYXJzZVVTaG9ydCgpO1xuICAgIGhlYWQubG93ZXN0UmVjUFBFTSA9IHAucGFyc2VVU2hvcnQoKTtcbiAgICBoZWFkLmZvbnREaXJlY3Rpb25IaW50ID0gcC5wYXJzZVNob3J0KCk7XG4gICAgaGVhZC5pbmRleFRvTG9jRm9ybWF0ID0gcC5wYXJzZVNob3J0KCk7XG4gICAgaGVhZC5nbHlwaERhdGFGb3JtYXQgPSBwLnBhcnNlU2hvcnQoKTtcbiAgICByZXR1cm4gaGVhZDtcbn1cblxuZnVuY3Rpb24gbWFrZUhlYWRUYWJsZShvcHRpb25zKSB7XG4gICAgLy8gQXBwbGUgTWFjIHRpbWVzdGFtcCBlcG9jaCBpcyAwMS8wMS8xOTA0IG5vdCAwMS8wMS8xOTcwXG4gICAgdmFyIHRpbWVzdGFtcCA9IE1hdGgucm91bmQobmV3IERhdGUoKS5nZXRUaW1lKCkgLyAxMDAwKSArIDIwODI4NDQ4MDA7XG4gICAgdmFyIGNyZWF0ZWRUaW1lc3RhbXAgPSB0aW1lc3RhbXA7XG5cbiAgICBpZiAob3B0aW9ucy5jcmVhdGVkVGltZXN0YW1wKSB7XG4gICAgICAgIGNyZWF0ZWRUaW1lc3RhbXAgPSBvcHRpb25zLmNyZWF0ZWRUaW1lc3RhbXAgKyAyMDgyODQ0ODAwO1xuICAgIH1cblxuICAgIHJldHVybiBuZXcgdGFibGUuVGFibGUoJ2hlYWQnLCBbXG4gICAgICAgIHtuYW1lOiAndmVyc2lvbicsIHR5cGU6ICdGSVhFRCcsIHZhbHVlOiAweDAwMDEwMDAwfSxcbiAgICAgICAge25hbWU6ICdmb250UmV2aXNpb24nLCB0eXBlOiAnRklYRUQnLCB2YWx1ZTogMHgwMDAxMDAwMH0sXG4gICAgICAgIHtuYW1lOiAnY2hlY2tTdW1BZGp1c3RtZW50JywgdHlwZTogJ1VMT05HJywgdmFsdWU6IDB9LFxuICAgICAgICB7bmFtZTogJ21hZ2ljTnVtYmVyJywgdHlwZTogJ1VMT05HJywgdmFsdWU6IDB4NUYwRjNDRjV9LFxuICAgICAgICB7bmFtZTogJ2ZsYWdzJywgdHlwZTogJ1VTSE9SVCcsIHZhbHVlOiAwfSxcbiAgICAgICAge25hbWU6ICd1bml0c1BlckVtJywgdHlwZTogJ1VTSE9SVCcsIHZhbHVlOiAxMDAwfSxcbiAgICAgICAge25hbWU6ICdjcmVhdGVkJywgdHlwZTogJ0xPTkdEQVRFVElNRScsIHZhbHVlOiBjcmVhdGVkVGltZXN0YW1wfSxcbiAgICAgICAge25hbWU6ICdtb2RpZmllZCcsIHR5cGU6ICdMT05HREFURVRJTUUnLCB2YWx1ZTogdGltZXN0YW1wfSxcbiAgICAgICAge25hbWU6ICd4TWluJywgdHlwZTogJ1NIT1JUJywgdmFsdWU6IDB9LFxuICAgICAgICB7bmFtZTogJ3lNaW4nLCB0eXBlOiAnU0hPUlQnLCB2YWx1ZTogMH0sXG4gICAgICAgIHtuYW1lOiAneE1heCcsIHR5cGU6ICdTSE9SVCcsIHZhbHVlOiAwfSxcbiAgICAgICAge25hbWU6ICd5TWF4JywgdHlwZTogJ1NIT1JUJywgdmFsdWU6IDB9LFxuICAgICAgICB7bmFtZTogJ21hY1N0eWxlJywgdHlwZTogJ1VTSE9SVCcsIHZhbHVlOiAwfSxcbiAgICAgICAge25hbWU6ICdsb3dlc3RSZWNQUEVNJywgdHlwZTogJ1VTSE9SVCcsIHZhbHVlOiAwfSxcbiAgICAgICAge25hbWU6ICdmb250RGlyZWN0aW9uSGludCcsIHR5cGU6ICdTSE9SVCcsIHZhbHVlOiAyfSxcbiAgICAgICAge25hbWU6ICdpbmRleFRvTG9jRm9ybWF0JywgdHlwZTogJ1NIT1JUJywgdmFsdWU6IDB9LFxuICAgICAgICB7bmFtZTogJ2dseXBoRGF0YUZvcm1hdCcsIHR5cGU6ICdTSE9SVCcsIHZhbHVlOiAwfVxuICAgIF0sIG9wdGlvbnMpO1xufVxuXG52YXIgaGVhZCA9IHsgcGFyc2U6IHBhcnNlSGVhZFRhYmxlLCBtYWtlOiBtYWtlSGVhZFRhYmxlIH07XG5cbi8vIFRoZSBgaGhlYWAgdGFibGUgY29udGFpbnMgaW5mb3JtYXRpb24gZm9yIGhvcml6b250YWwgbGF5b3V0LlxuXG4vLyBQYXJzZSB0aGUgaG9yaXpvbnRhbCBoZWFkZXIgYGhoZWFgIHRhYmxlXG5mdW5jdGlvbiBwYXJzZUhoZWFUYWJsZShkYXRhLCBzdGFydCkge1xuICAgIHZhciBoaGVhID0ge307XG4gICAgdmFyIHAgPSBuZXcgcGFyc2UuUGFyc2VyKGRhdGEsIHN0YXJ0KTtcbiAgICBoaGVhLnZlcnNpb24gPSBwLnBhcnNlVmVyc2lvbigpO1xuICAgIGhoZWEuYXNjZW5kZXIgPSBwLnBhcnNlU2hvcnQoKTtcbiAgICBoaGVhLmRlc2NlbmRlciA9IHAucGFyc2VTaG9ydCgpO1xuICAgIGhoZWEubGluZUdhcCA9IHAucGFyc2VTaG9ydCgpO1xuICAgIGhoZWEuYWR2YW5jZVdpZHRoTWF4ID0gcC5wYXJzZVVTaG9ydCgpO1xuICAgIGhoZWEubWluTGVmdFNpZGVCZWFyaW5nID0gcC5wYXJzZVNob3J0KCk7XG4gICAgaGhlYS5taW5SaWdodFNpZGVCZWFyaW5nID0gcC5wYXJzZVNob3J0KCk7XG4gICAgaGhlYS54TWF4RXh0ZW50ID0gcC5wYXJzZVNob3J0KCk7XG4gICAgaGhlYS5jYXJldFNsb3BlUmlzZSA9IHAucGFyc2VTaG9ydCgpO1xuICAgIGhoZWEuY2FyZXRTbG9wZVJ1biA9IHAucGFyc2VTaG9ydCgpO1xuICAgIGhoZWEuY2FyZXRPZmZzZXQgPSBwLnBhcnNlU2hvcnQoKTtcbiAgICBwLnJlbGF0aXZlT2Zmc2V0ICs9IDg7XG4gICAgaGhlYS5tZXRyaWNEYXRhRm9ybWF0ID0gcC5wYXJzZVNob3J0KCk7XG4gICAgaGhlYS5udW1iZXJPZkhNZXRyaWNzID0gcC5wYXJzZVVTaG9ydCgpO1xuICAgIHJldHVybiBoaGVhO1xufVxuXG5mdW5jdGlvbiBtYWtlSGhlYVRhYmxlKG9wdGlvbnMpIHtcbiAgICByZXR1cm4gbmV3IHRhYmxlLlRhYmxlKCdoaGVhJywgW1xuICAgICAgICB7bmFtZTogJ3ZlcnNpb24nLCB0eXBlOiAnRklYRUQnLCB2YWx1ZTogMHgwMDAxMDAwMH0sXG4gICAgICAgIHtuYW1lOiAnYXNjZW5kZXInLCB0eXBlOiAnRldPUkQnLCB2YWx1ZTogMH0sXG4gICAgICAgIHtuYW1lOiAnZGVzY2VuZGVyJywgdHlwZTogJ0ZXT1JEJywgdmFsdWU6IDB9LFxuICAgICAgICB7bmFtZTogJ2xpbmVHYXAnLCB0eXBlOiAnRldPUkQnLCB2YWx1ZTogMH0sXG4gICAgICAgIHtuYW1lOiAnYWR2YW5jZVdpZHRoTWF4JywgdHlwZTogJ1VGV09SRCcsIHZhbHVlOiAwfSxcbiAgICAgICAge25hbWU6ICdtaW5MZWZ0U2lkZUJlYXJpbmcnLCB0eXBlOiAnRldPUkQnLCB2YWx1ZTogMH0sXG4gICAgICAgIHtuYW1lOiAnbWluUmlnaHRTaWRlQmVhcmluZycsIHR5cGU6ICdGV09SRCcsIHZhbHVlOiAwfSxcbiAgICAgICAge25hbWU6ICd4TWF4RXh0ZW50JywgdHlwZTogJ0ZXT1JEJywgdmFsdWU6IDB9LFxuICAgICAgICB7bmFtZTogJ2NhcmV0U2xvcGVSaXNlJywgdHlwZTogJ1NIT1JUJywgdmFsdWU6IDF9LFxuICAgICAgICB7bmFtZTogJ2NhcmV0U2xvcGVSdW4nLCB0eXBlOiAnU0hPUlQnLCB2YWx1ZTogMH0sXG4gICAgICAgIHtuYW1lOiAnY2FyZXRPZmZzZXQnLCB0eXBlOiAnU0hPUlQnLCB2YWx1ZTogMH0sXG4gICAgICAgIHtuYW1lOiAncmVzZXJ2ZWQxJywgdHlwZTogJ1NIT1JUJywgdmFsdWU6IDB9LFxuICAgICAgICB7bmFtZTogJ3Jlc2VydmVkMicsIHR5cGU6ICdTSE9SVCcsIHZhbHVlOiAwfSxcbiAgICAgICAge25hbWU6ICdyZXNlcnZlZDMnLCB0eXBlOiAnU0hPUlQnLCB2YWx1ZTogMH0sXG4gICAgICAgIHtuYW1lOiAncmVzZXJ2ZWQ0JywgdHlwZTogJ1NIT1JUJywgdmFsdWU6IDB9LFxuICAgICAgICB7bmFtZTogJ21ldHJpY0RhdGFGb3JtYXQnLCB0eXBlOiAnU0hPUlQnLCB2YWx1ZTogMH0sXG4gICAgICAgIHtuYW1lOiAnbnVtYmVyT2ZITWV0cmljcycsIHR5cGU6ICdVU0hPUlQnLCB2YWx1ZTogMH1cbiAgICBdLCBvcHRpb25zKTtcbn1cblxudmFyIGhoZWEgPSB7IHBhcnNlOiBwYXJzZUhoZWFUYWJsZSwgbWFrZTogbWFrZUhoZWFUYWJsZSB9O1xuXG4vLyBUaGUgYGhtdHhgIHRhYmxlIGNvbnRhaW5zIHRoZSBob3Jpem9udGFsIG1ldHJpY3MgZm9yIGFsbCBnbHlwaHMuXG5cbmZ1bmN0aW9uIHBhcnNlSG10eFRhYmxlQWxsKGRhdGEsIHN0YXJ0LCBudW1NZXRyaWNzLCBudW1HbHlwaHMsIGdseXBocykge1xuICAgIHZhciBhZHZhbmNlV2lkdGg7XG4gICAgdmFyIGxlZnRTaWRlQmVhcmluZztcbiAgICB2YXIgcCA9IG5ldyBwYXJzZS5QYXJzZXIoZGF0YSwgc3RhcnQpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbnVtR2x5cGhzOyBpICs9IDEpIHtcbiAgICAgICAgLy8gSWYgdGhlIGZvbnQgaXMgbW9ub3NwYWNlZCwgb25seSBvbmUgZW50cnkgaXMgbmVlZGVkLiBUaGlzIGxhc3QgZW50cnkgYXBwbGllcyB0byBhbGwgc3Vic2VxdWVudCBnbHlwaHMuXG4gICAgICAgIGlmIChpIDwgbnVtTWV0cmljcykge1xuICAgICAgICAgICAgYWR2YW5jZVdpZHRoID0gcC5wYXJzZVVTaG9ydCgpO1xuICAgICAgICAgICAgbGVmdFNpZGVCZWFyaW5nID0gcC5wYXJzZVNob3J0KCk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgZ2x5cGggPSBnbHlwaHMuZ2V0KGkpO1xuICAgICAgICBnbHlwaC5hZHZhbmNlV2lkdGggPSBhZHZhbmNlV2lkdGg7XG4gICAgICAgIGdseXBoLmxlZnRTaWRlQmVhcmluZyA9IGxlZnRTaWRlQmVhcmluZztcbiAgICB9XG59XG5cbmZ1bmN0aW9uIHBhcnNlSG10eFRhYmxlT25Mb3dNZW1vcnkoZm9udCwgZGF0YSwgc3RhcnQsIG51bU1ldHJpY3MsIG51bUdseXBocykge1xuICAgIGZvbnQuX2htdHhUYWJsZURhdGEgPSB7fTtcblxuICAgIHZhciBhZHZhbmNlV2lkdGg7XG4gICAgdmFyIGxlZnRTaWRlQmVhcmluZztcbiAgICB2YXIgcCA9IG5ldyBwYXJzZS5QYXJzZXIoZGF0YSwgc3RhcnQpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbnVtR2x5cGhzOyBpICs9IDEpIHtcbiAgICAgICAgLy8gSWYgdGhlIGZvbnQgaXMgbW9ub3NwYWNlZCwgb25seSBvbmUgZW50cnkgaXMgbmVlZGVkLiBUaGlzIGxhc3QgZW50cnkgYXBwbGllcyB0byBhbGwgc3Vic2VxdWVudCBnbHlwaHMuXG4gICAgICAgIGlmIChpIDwgbnVtTWV0cmljcykge1xuICAgICAgICAgICAgYWR2YW5jZVdpZHRoID0gcC5wYXJzZVVTaG9ydCgpO1xuICAgICAgICAgICAgbGVmdFNpZGVCZWFyaW5nID0gcC5wYXJzZVNob3J0KCk7XG4gICAgICAgIH1cblxuICAgICAgICBmb250Ll9obXR4VGFibGVEYXRhW2ldID0ge1xuICAgICAgICAgICAgYWR2YW5jZVdpZHRoOiBhZHZhbmNlV2lkdGgsXG4gICAgICAgICAgICBsZWZ0U2lkZUJlYXJpbmc6IGxlZnRTaWRlQmVhcmluZ1xuICAgICAgICB9O1xuICAgIH1cbn1cblxuLy8gUGFyc2UgdGhlIGBobXR4YCB0YWJsZSwgd2hpY2ggY29udGFpbnMgdGhlIGhvcml6b250YWwgbWV0cmljcyBmb3IgYWxsIGdseXBocy5cbi8vIFRoaXMgZnVuY3Rpb24gYXVnbWVudHMgdGhlIGdseXBoIGFycmF5LCBhZGRpbmcgdGhlIGFkdmFuY2VXaWR0aCBhbmQgbGVmdFNpZGVCZWFyaW5nIHRvIGVhY2ggZ2x5cGguXG5mdW5jdGlvbiBwYXJzZUhtdHhUYWJsZShmb250LCBkYXRhLCBzdGFydCwgbnVtTWV0cmljcywgbnVtR2x5cGhzLCBnbHlwaHMsIG9wdCkge1xuICAgIGlmIChvcHQubG93TWVtb3J5KVxuICAgICAgICB7IHBhcnNlSG10eFRhYmxlT25Mb3dNZW1vcnkoZm9udCwgZGF0YSwgc3RhcnQsIG51bU1ldHJpY3MsIG51bUdseXBocyk7IH1cbiAgICBlbHNlXG4gICAgICAgIHsgcGFyc2VIbXR4VGFibGVBbGwoZGF0YSwgc3RhcnQsIG51bU1ldHJpY3MsIG51bUdseXBocywgZ2x5cGhzKTsgfVxufVxuXG5mdW5jdGlvbiBtYWtlSG10eFRhYmxlKGdseXBocykge1xuICAgIHZhciB0ID0gbmV3IHRhYmxlLlRhYmxlKCdobXR4JywgW10pO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZ2x5cGhzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgIHZhciBnbHlwaCA9IGdseXBocy5nZXQoaSk7XG4gICAgICAgIHZhciBhZHZhbmNlV2lkdGggPSBnbHlwaC5hZHZhbmNlV2lkdGggfHwgMDtcbiAgICAgICAgdmFyIGxlZnRTaWRlQmVhcmluZyA9IGdseXBoLmxlZnRTaWRlQmVhcmluZyB8fCAwO1xuICAgICAgICB0LmZpZWxkcy5wdXNoKHtuYW1lOiAnYWR2YW5jZVdpZHRoXycgKyBpLCB0eXBlOiAnVVNIT1JUJywgdmFsdWU6IGFkdmFuY2VXaWR0aH0pO1xuICAgICAgICB0LmZpZWxkcy5wdXNoKHtuYW1lOiAnbGVmdFNpZGVCZWFyaW5nXycgKyBpLCB0eXBlOiAnU0hPUlQnLCB2YWx1ZTogbGVmdFNpZGVCZWFyaW5nfSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHQ7XG59XG5cbnZhciBobXR4ID0geyBwYXJzZTogcGFyc2VIbXR4VGFibGUsIG1ha2U6IG1ha2VIbXR4VGFibGUgfTtcblxuLy8gVGhlIGBsdGFnYCB0YWJsZSBzdG9yZXMgSUVURiBCQ1AtNDcgbGFuZ3VhZ2UgdGFncy4gSXQgYWxsb3dzIHN1cHBvcnRpbmdcblxuZnVuY3Rpb24gbWFrZUx0YWdUYWJsZSh0YWdzKSB7XG4gICAgdmFyIHJlc3VsdCA9IG5ldyB0YWJsZS5UYWJsZSgnbHRhZycsIFtcbiAgICAgICAge25hbWU6ICd2ZXJzaW9uJywgdHlwZTogJ1VMT05HJywgdmFsdWU6IDF9LFxuICAgICAgICB7bmFtZTogJ2ZsYWdzJywgdHlwZTogJ1VMT05HJywgdmFsdWU6IDB9LFxuICAgICAgICB7bmFtZTogJ251bVRhZ3MnLCB0eXBlOiAnVUxPTkcnLCB2YWx1ZTogdGFncy5sZW5ndGh9XG4gICAgXSk7XG5cbiAgICB2YXIgc3RyaW5nUG9vbCA9ICcnO1xuICAgIHZhciBzdHJpbmdQb29sT2Zmc2V0ID0gMTIgKyB0YWdzLmxlbmd0aCAqIDQ7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0YWdzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIHZhciBwb3MgPSBzdHJpbmdQb29sLmluZGV4T2YodGFnc1tpXSk7XG4gICAgICAgIGlmIChwb3MgPCAwKSB7XG4gICAgICAgICAgICBwb3MgPSBzdHJpbmdQb29sLmxlbmd0aDtcbiAgICAgICAgICAgIHN0cmluZ1Bvb2wgKz0gdGFnc1tpXTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJlc3VsdC5maWVsZHMucHVzaCh7bmFtZTogJ29mZnNldCAnICsgaSwgdHlwZTogJ1VTSE9SVCcsIHZhbHVlOiBzdHJpbmdQb29sT2Zmc2V0ICsgcG9zfSk7XG4gICAgICAgIHJlc3VsdC5maWVsZHMucHVzaCh7bmFtZTogJ2xlbmd0aCAnICsgaSwgdHlwZTogJ1VTSE9SVCcsIHZhbHVlOiB0YWdzW2ldLmxlbmd0aH0pO1xuICAgIH1cblxuICAgIHJlc3VsdC5maWVsZHMucHVzaCh7bmFtZTogJ3N0cmluZ1Bvb2wnLCB0eXBlOiAnQ0hBUkFSUkFZJywgdmFsdWU6IHN0cmluZ1Bvb2x9KTtcbiAgICByZXR1cm4gcmVzdWx0O1xufVxuXG5mdW5jdGlvbiBwYXJzZUx0YWdUYWJsZShkYXRhLCBzdGFydCkge1xuICAgIHZhciBwID0gbmV3IHBhcnNlLlBhcnNlcihkYXRhLCBzdGFydCk7XG4gICAgdmFyIHRhYmxlVmVyc2lvbiA9IHAucGFyc2VVTG9uZygpO1xuICAgIGNoZWNrLmFyZ3VtZW50KHRhYmxlVmVyc2lvbiA9PT0gMSwgJ1Vuc3VwcG9ydGVkIGx0YWcgdGFibGUgdmVyc2lvbi4nKTtcbiAgICAvLyBUaGUgJ2x0YWcnIHNwZWNpZmljYXRpb24gZG9lcyBub3QgZGVmaW5lIGFueSBmbGFnczsgc2tpcCB0aGUgZmllbGQuXG4gICAgcC5za2lwKCd1TG9uZycsIDEpO1xuICAgIHZhciBudW1UYWdzID0gcC5wYXJzZVVMb25nKCk7XG5cbiAgICB2YXIgdGFncyA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbnVtVGFnczsgaSsrKSB7XG4gICAgICAgIHZhciB0YWcgPSAnJztcbiAgICAgICAgdmFyIG9mZnNldCA9IHN0YXJ0ICsgcC5wYXJzZVVTaG9ydCgpO1xuICAgICAgICB2YXIgbGVuZ3RoID0gcC5wYXJzZVVTaG9ydCgpO1xuICAgICAgICBmb3IgKHZhciBqID0gb2Zmc2V0OyBqIDwgb2Zmc2V0ICsgbGVuZ3RoOyArK2opIHtcbiAgICAgICAgICAgIHRhZyArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGRhdGEuZ2V0SW50OChqKSk7XG4gICAgICAgIH1cblxuICAgICAgICB0YWdzLnB1c2godGFnKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGFncztcbn1cblxudmFyIGx0YWcgPSB7IG1ha2U6IG1ha2VMdGFnVGFibGUsIHBhcnNlOiBwYXJzZUx0YWdUYWJsZSB9O1xuXG4vLyBUaGUgYG1heHBgIHRhYmxlIGVzdGFibGlzaGVzIHRoZSBtZW1vcnkgcmVxdWlyZW1lbnRzIGZvciB0aGUgZm9udC5cblxuLy8gUGFyc2UgdGhlIG1heGltdW0gcHJvZmlsZSBgbWF4cGAgdGFibGUuXG5mdW5jdGlvbiBwYXJzZU1heHBUYWJsZShkYXRhLCBzdGFydCkge1xuICAgIHZhciBtYXhwID0ge307XG4gICAgdmFyIHAgPSBuZXcgcGFyc2UuUGFyc2VyKGRhdGEsIHN0YXJ0KTtcbiAgICBtYXhwLnZlcnNpb24gPSBwLnBhcnNlVmVyc2lvbigpO1xuICAgIG1heHAubnVtR2x5cGhzID0gcC5wYXJzZVVTaG9ydCgpO1xuICAgIGlmIChtYXhwLnZlcnNpb24gPT09IDEuMCkge1xuICAgICAgICBtYXhwLm1heFBvaW50cyA9IHAucGFyc2VVU2hvcnQoKTtcbiAgICAgICAgbWF4cC5tYXhDb250b3VycyA9IHAucGFyc2VVU2hvcnQoKTtcbiAgICAgICAgbWF4cC5tYXhDb21wb3NpdGVQb2ludHMgPSBwLnBhcnNlVVNob3J0KCk7XG4gICAgICAgIG1heHAubWF4Q29tcG9zaXRlQ29udG91cnMgPSBwLnBhcnNlVVNob3J0KCk7XG4gICAgICAgIG1heHAubWF4Wm9uZXMgPSBwLnBhcnNlVVNob3J0KCk7XG4gICAgICAgIG1heHAubWF4VHdpbGlnaHRQb2ludHMgPSBwLnBhcnNlVVNob3J0KCk7XG4gICAgICAgIG1heHAubWF4U3RvcmFnZSA9IHAucGFyc2VVU2hvcnQoKTtcbiAgICAgICAgbWF4cC5tYXhGdW5jdGlvbkRlZnMgPSBwLnBhcnNlVVNob3J0KCk7XG4gICAgICAgIG1heHAubWF4SW5zdHJ1Y3Rpb25EZWZzID0gcC5wYXJzZVVTaG9ydCgpO1xuICAgICAgICBtYXhwLm1heFN0YWNrRWxlbWVudHMgPSBwLnBhcnNlVVNob3J0KCk7XG4gICAgICAgIG1heHAubWF4U2l6ZU9mSW5zdHJ1Y3Rpb25zID0gcC5wYXJzZVVTaG9ydCgpO1xuICAgICAgICBtYXhwLm1heENvbXBvbmVudEVsZW1lbnRzID0gcC5wYXJzZVVTaG9ydCgpO1xuICAgICAgICBtYXhwLm1heENvbXBvbmVudERlcHRoID0gcC5wYXJzZVVTaG9ydCgpO1xuICAgIH1cblxuICAgIHJldHVybiBtYXhwO1xufVxuXG5mdW5jdGlvbiBtYWtlTWF4cFRhYmxlKG51bUdseXBocykge1xuICAgIHJldHVybiBuZXcgdGFibGUuVGFibGUoJ21heHAnLCBbXG4gICAgICAgIHtuYW1lOiAndmVyc2lvbicsIHR5cGU6ICdGSVhFRCcsIHZhbHVlOiAweDAwMDA1MDAwfSxcbiAgICAgICAge25hbWU6ICdudW1HbHlwaHMnLCB0eXBlOiAnVVNIT1JUJywgdmFsdWU6IG51bUdseXBoc31cbiAgICBdKTtcbn1cblxudmFyIG1heHAgPSB7IHBhcnNlOiBwYXJzZU1heHBUYWJsZSwgbWFrZTogbWFrZU1heHBUYWJsZSB9O1xuXG4vLyBUaGUgYG5hbWVgIG5hbWluZyB0YWJsZS5cblxuLy8gTmFtZUlEcyBmb3IgdGhlIG5hbWUgdGFibGUuXG52YXIgbmFtZVRhYmxlTmFtZXMgPSBbXG4gICAgJ2NvcHlyaWdodCcsICAgICAgICAgICAgICAvLyAwXG4gICAgJ2ZvbnRGYW1pbHknLCAgICAgICAgICAgICAvLyAxXG4gICAgJ2ZvbnRTdWJmYW1pbHknLCAgICAgICAgICAvLyAyXG4gICAgJ3VuaXF1ZUlEJywgICAgICAgICAgICAgICAvLyAzXG4gICAgJ2Z1bGxOYW1lJywgICAgICAgICAgICAgICAvLyA0XG4gICAgJ3ZlcnNpb24nLCAgICAgICAgICAgICAgICAvLyA1XG4gICAgJ3Bvc3RTY3JpcHROYW1lJywgICAgICAgICAvLyA2XG4gICAgJ3RyYWRlbWFyaycsICAgICAgICAgICAgICAvLyA3XG4gICAgJ21hbnVmYWN0dXJlcicsICAgICAgICAgICAvLyA4XG4gICAgJ2Rlc2lnbmVyJywgICAgICAgICAgICAgICAvLyA5XG4gICAgJ2Rlc2NyaXB0aW9uJywgICAgICAgICAgICAvLyAxMFxuICAgICdtYW51ZmFjdHVyZXJVUkwnLCAgICAgICAgLy8gMTFcbiAgICAnZGVzaWduZXJVUkwnLCAgICAgICAgICAgIC8vIDEyXG4gICAgJ2xpY2Vuc2UnLCAgICAgICAgICAgICAgICAvLyAxM1xuICAgICdsaWNlbnNlVVJMJywgICAgICAgICAgICAgLy8gMTRcbiAgICAncmVzZXJ2ZWQnLCAgICAgICAgICAgICAgIC8vIDE1XG4gICAgJ3ByZWZlcnJlZEZhbWlseScsICAgICAgICAvLyAxNlxuICAgICdwcmVmZXJyZWRTdWJmYW1pbHknLCAgICAgLy8gMTdcbiAgICAnY29tcGF0aWJsZUZ1bGxOYW1lJywgICAgIC8vIDE4XG4gICAgJ3NhbXBsZVRleHQnLCAgICAgICAgICAgICAvLyAxOVxuICAgICdwb3N0U2NyaXB0RmluZEZvbnROYW1lJywgLy8gMjBcbiAgICAnd3dzRmFtaWx5JywgICAgICAgICAgICAgIC8vIDIxXG4gICAgJ3d3c1N1YmZhbWlseScgICAgICAgICAgICAvLyAyMlxuXTtcblxudmFyIG1hY0xhbmd1YWdlcyA9IHtcbiAgICAwOiAnZW4nLFxuICAgIDE6ICdmcicsXG4gICAgMjogJ2RlJyxcbiAgICAzOiAnaXQnLFxuICAgIDQ6ICdubCcsXG4gICAgNTogJ3N2JyxcbiAgICA2OiAnZXMnLFxuICAgIDc6ICdkYScsXG4gICAgODogJ3B0JyxcbiAgICA5OiAnbm8nLFxuICAgIDEwOiAnaGUnLFxuICAgIDExOiAnamEnLFxuICAgIDEyOiAnYXInLFxuICAgIDEzOiAnZmknLFxuICAgIDE0OiAnZWwnLFxuICAgIDE1OiAnaXMnLFxuICAgIDE2OiAnbXQnLFxuICAgIDE3OiAndHInLFxuICAgIDE4OiAnaHInLFxuICAgIDE5OiAnemgtSGFudCcsXG4gICAgMjA6ICd1cicsXG4gICAgMjE6ICdoaScsXG4gICAgMjI6ICd0aCcsXG4gICAgMjM6ICdrbycsXG4gICAgMjQ6ICdsdCcsXG4gICAgMjU6ICdwbCcsXG4gICAgMjY6ICdodScsXG4gICAgMjc6ICdlcycsXG4gICAgMjg6ICdsdicsXG4gICAgMjk6ICdzZScsXG4gICAgMzA6ICdmbycsXG4gICAgMzE6ICdmYScsXG4gICAgMzI6ICdydScsXG4gICAgMzM6ICd6aCcsXG4gICAgMzQ6ICdubC1CRScsXG4gICAgMzU6ICdnYScsXG4gICAgMzY6ICdzcScsXG4gICAgMzc6ICdybycsXG4gICAgMzg6ICdjeicsXG4gICAgMzk6ICdzaycsXG4gICAgNDA6ICdzaScsXG4gICAgNDE6ICd5aScsXG4gICAgNDI6ICdzcicsXG4gICAgNDM6ICdtaycsXG4gICAgNDQ6ICdiZycsXG4gICAgNDU6ICd1aycsXG4gICAgNDY6ICdiZScsXG4gICAgNDc6ICd1eicsXG4gICAgNDg6ICdraycsXG4gICAgNDk6ICdhei1DeXJsJyxcbiAgICA1MDogJ2F6LUFyYWInLFxuICAgIDUxOiAnaHknLFxuICAgIDUyOiAna2EnLFxuICAgIDUzOiAnbW8nLFxuICAgIDU0OiAna3knLFxuICAgIDU1OiAndGcnLFxuICAgIDU2OiAndGsnLFxuICAgIDU3OiAnbW4tQ04nLFxuICAgIDU4OiAnbW4nLFxuICAgIDU5OiAncHMnLFxuICAgIDYwOiAna3MnLFxuICAgIDYxOiAna3UnLFxuICAgIDYyOiAnc2QnLFxuICAgIDYzOiAnYm8nLFxuICAgIDY0OiAnbmUnLFxuICAgIDY1OiAnc2EnLFxuICAgIDY2OiAnbXInLFxuICAgIDY3OiAnYm4nLFxuICAgIDY4OiAnYXMnLFxuICAgIDY5OiAnZ3UnLFxuICAgIDcwOiAncGEnLFxuICAgIDcxOiAnb3InLFxuICAgIDcyOiAnbWwnLFxuICAgIDczOiAna24nLFxuICAgIDc0OiAndGEnLFxuICAgIDc1OiAndGUnLFxuICAgIDc2OiAnc2knLFxuICAgIDc3OiAnbXknLFxuICAgIDc4OiAna20nLFxuICAgIDc5OiAnbG8nLFxuICAgIDgwOiAndmknLFxuICAgIDgxOiAnaWQnLFxuICAgIDgyOiAndGwnLFxuICAgIDgzOiAnbXMnLFxuICAgIDg0OiAnbXMtQXJhYicsXG4gICAgODU6ICdhbScsXG4gICAgODY6ICd0aScsXG4gICAgODc6ICdvbScsXG4gICAgODg6ICdzbycsXG4gICAgODk6ICdzdycsXG4gICAgOTA6ICdydycsXG4gICAgOTE6ICdybicsXG4gICAgOTI6ICdueScsXG4gICAgOTM6ICdtZycsXG4gICAgOTQ6ICdlbycsXG4gICAgMTI4OiAnY3knLFxuICAgIDEyOTogJ2V1JyxcbiAgICAxMzA6ICdjYScsXG4gICAgMTMxOiAnbGEnLFxuICAgIDEzMjogJ3F1JyxcbiAgICAxMzM6ICdnbicsXG4gICAgMTM0OiAnYXknLFxuICAgIDEzNTogJ3R0JyxcbiAgICAxMzY6ICd1ZycsXG4gICAgMTM3OiAnZHonLFxuICAgIDEzODogJ2p2JyxcbiAgICAxMzk6ICdzdScsXG4gICAgMTQwOiAnZ2wnLFxuICAgIDE0MTogJ2FmJyxcbiAgICAxNDI6ICdicicsXG4gICAgMTQzOiAnaXUnLFxuICAgIDE0NDogJ2dkJyxcbiAgICAxNDU6ICdndicsXG4gICAgMTQ2OiAnZ2EnLFxuICAgIDE0NzogJ3RvJyxcbiAgICAxNDg6ICdlbC1wb2x5dG9uJyxcbiAgICAxNDk6ICdrbCcsXG4gICAgMTUwOiAnYXonLFxuICAgIDE1MTogJ25uJ1xufTtcblxuLy8gTWFjT1MgbGFuZ3VhZ2UgSUQg4oaSIE1hY09TIHNjcmlwdCBJRFxuLy9cbi8vIE5vdGUgdGhhdCB0aGUgc2NyaXB0IElEIGlzIG5vdCBzdWZmaWNpZW50IHRvIGRldGVybWluZSB3aGF0IGVuY29kaW5nXG4vLyB0byB1c2UgaW4gVHJ1ZVR5cGUgZmlsZXMuIEZvciBzb21lIGxhbmd1YWdlcywgTWFjT1MgdXNlZCBhIG1vZGlmaWNhdGlvblxuLy8gb2YgYSBtYWluc3RyZWFtIHNjcmlwdC4gRm9yIGV4YW1wbGUsIGFuIEljZWxhbmRpYyBuYW1lIHdvdWxkIGJlIHN0b3JlZFxuLy8gd2l0aCBzbVJvbWFuIGluIHRoZSBUcnVlVHlwZSBuYW1pbmcgdGFibGUsIGJ1dCB0aGUgYWN0dWFsIGVuY29kaW5nXG4vLyBpcyBhIHNwZWNpYWwgSWNlbGFuZGljIHZlcnNpb24gb2YgdGhlIG5vcm1hbCBNYWNpbnRvc2ggUm9tYW4gZW5jb2RpbmcuXG4vLyBBcyBhbm90aGVyIGV4YW1wbGUsIEludWt0aXR1dCB1c2VzIGFuIDgtYml0IGVuY29kaW5nIGZvciBDYW5hZGlhbiBBYm9yaWdpbmFsXG4vLyBTeWxsYWJsZXMgYnV0IE1hY09TIGhhZCBydW4gb3V0IG9mIGF2YWlsYWJsZSBzY3JpcHQgY29kZXMsIHNvIHRoaXMgd2FzXG4vLyBkb25lIGFzIGEgKHByZXR0eSByYWRpY2FsKSBcIm1vZGlmaWNhdGlvblwiIG9mIEV0aGlvcGljLlxuLy9cbi8vIGh0dHA6Ly91bmljb2RlLm9yZy9QdWJsaWMvTUFQUElOR1MvVkVORE9SUy9BUFBMRS9SZWFkbWUudHh0XG52YXIgbWFjTGFuZ3VhZ2VUb1NjcmlwdCA9IHtcbiAgICAwOiAwLCAgLy8gbGFuZ0VuZ2xpc2gg4oaSIHNtUm9tYW5cbiAgICAxOiAwLCAgLy8gbGFuZ0ZyZW5jaCDihpIgc21Sb21hblxuICAgIDI6IDAsICAvLyBsYW5nR2VybWFuIOKGkiBzbVJvbWFuXG4gICAgMzogMCwgIC8vIGxhbmdJdGFsaWFuIOKGkiBzbVJvbWFuXG4gICAgNDogMCwgIC8vIGxhbmdEdXRjaCDihpIgc21Sb21hblxuICAgIDU6IDAsICAvLyBsYW5nU3dlZGlzaCDihpIgc21Sb21hblxuICAgIDY6IDAsICAvLyBsYW5nU3BhbmlzaCDihpIgc21Sb21hblxuICAgIDc6IDAsICAvLyBsYW5nRGFuaXNoIOKGkiBzbVJvbWFuXG4gICAgODogMCwgIC8vIGxhbmdQb3J0dWd1ZXNlIOKGkiBzbVJvbWFuXG4gICAgOTogMCwgIC8vIGxhbmdOb3J3ZWdpYW4g4oaSIHNtUm9tYW5cbiAgICAxMDogNSwgIC8vIGxhbmdIZWJyZXcg4oaSIHNtSGVicmV3XG4gICAgMTE6IDEsICAvLyBsYW5nSmFwYW5lc2Ug4oaSIHNtSmFwYW5lc2VcbiAgICAxMjogNCwgIC8vIGxhbmdBcmFiaWMg4oaSIHNtQXJhYmljXG4gICAgMTM6IDAsICAvLyBsYW5nRmlubmlzaCDihpIgc21Sb21hblxuICAgIDE0OiA2LCAgLy8gbGFuZ0dyZWVrIOKGkiBzbUdyZWVrXG4gICAgMTU6IDAsICAvLyBsYW5nSWNlbGFuZGljIOKGkiBzbVJvbWFuIChtb2RpZmllZClcbiAgICAxNjogMCwgIC8vIGxhbmdNYWx0ZXNlIOKGkiBzbVJvbWFuXG4gICAgMTc6IDAsICAvLyBsYW5nVHVya2lzaCDihpIgc21Sb21hbiAobW9kaWZpZWQpXG4gICAgMTg6IDAsICAvLyBsYW5nQ3JvYXRpYW4g4oaSIHNtUm9tYW4gKG1vZGlmaWVkKVxuICAgIDE5OiAyLCAgLy8gbGFuZ1RyYWRDaGluZXNlIOKGkiBzbVRyYWRDaGluZXNlXG4gICAgMjA6IDQsICAvLyBsYW5nVXJkdSDihpIgc21BcmFiaWNcbiAgICAyMTogOSwgIC8vIGxhbmdIaW5kaSDihpIgc21EZXZhbmFnYXJpXG4gICAgMjI6IDIxLCAgLy8gbGFuZ1RoYWkg4oaSIHNtVGhhaVxuICAgIDIzOiAzLCAgLy8gbGFuZ0tvcmVhbiDihpIgc21Lb3JlYW5cbiAgICAyNDogMjksICAvLyBsYW5nTGl0aHVhbmlhbiDihpIgc21DZW50cmFsRXVyb1JvbWFuXG4gICAgMjU6IDI5LCAgLy8gbGFuZ1BvbGlzaCDihpIgc21DZW50cmFsRXVyb1JvbWFuXG4gICAgMjY6IDI5LCAgLy8gbGFuZ0h1bmdhcmlhbiDihpIgc21DZW50cmFsRXVyb1JvbWFuXG4gICAgMjc6IDI5LCAgLy8gbGFuZ0VzdG9uaWFuIOKGkiBzbUNlbnRyYWxFdXJvUm9tYW5cbiAgICAyODogMjksICAvLyBsYW5nTGF0dmlhbiDihpIgc21DZW50cmFsRXVyb1JvbWFuXG4gICAgMjk6IDAsICAvLyBsYW5nU2FtaSDihpIgc21Sb21hblxuICAgIDMwOiAwLCAgLy8gbGFuZ0Zhcm9lc2Ug4oaSIHNtUm9tYW4gKG1vZGlmaWVkKVxuICAgIDMxOiA0LCAgLy8gbGFuZ0ZhcnNpIOKGkiBzbUFyYWJpYyAobW9kaWZpZWQpXG4gICAgMzI6IDcsICAvLyBsYW5nUnVzc2lhbiDihpIgc21DeXJpbGxpY1xuICAgIDMzOiAyNSwgIC8vIGxhbmdTaW1wQ2hpbmVzZSDihpIgc21TaW1wQ2hpbmVzZVxuICAgIDM0OiAwLCAgLy8gbGFuZ0ZsZW1pc2gg4oaSIHNtUm9tYW5cbiAgICAzNTogMCwgIC8vIGxhbmdJcmlzaEdhZWxpYyDihpIgc21Sb21hbiAobW9kaWZpZWQpXG4gICAgMzY6IDAsICAvLyBsYW5nQWxiYW5pYW4g4oaSIHNtUm9tYW5cbiAgICAzNzogMCwgIC8vIGxhbmdSb21hbmlhbiDihpIgc21Sb21hbiAobW9kaWZpZWQpXG4gICAgMzg6IDI5LCAgLy8gbGFuZ0N6ZWNoIOKGkiBzbUNlbnRyYWxFdXJvUm9tYW5cbiAgICAzOTogMjksICAvLyBsYW5nU2xvdmFrIOKGkiBzbUNlbnRyYWxFdXJvUm9tYW5cbiAgICA0MDogMCwgIC8vIGxhbmdTbG92ZW5pYW4g4oaSIHNtUm9tYW4gKG1vZGlmaWVkKVxuICAgIDQxOiA1LCAgLy8gbGFuZ1lpZGRpc2gg4oaSIHNtSGVicmV3XG4gICAgNDI6IDcsICAvLyBsYW5nU2VyYmlhbiDihpIgc21DeXJpbGxpY1xuICAgIDQzOiA3LCAgLy8gbGFuZ01hY2Vkb25pYW4g4oaSIHNtQ3lyaWxsaWNcbiAgICA0NDogNywgIC8vIGxhbmdCdWxnYXJpYW4g4oaSIHNtQ3lyaWxsaWNcbiAgICA0NTogNywgIC8vIGxhbmdVa3JhaW5pYW4g4oaSIHNtQ3lyaWxsaWMgKG1vZGlmaWVkKVxuICAgIDQ2OiA3LCAgLy8gbGFuZ0J5ZWxvcnVzc2lhbiDihpIgc21DeXJpbGxpY1xuICAgIDQ3OiA3LCAgLy8gbGFuZ1V6YmVrIOKGkiBzbUN5cmlsbGljXG4gICAgNDg6IDcsICAvLyBsYW5nS2F6YWtoIOKGkiBzbUN5cmlsbGljXG4gICAgNDk6IDcsICAvLyBsYW5nQXplcmJhaWphbmkg4oaSIHNtQ3lyaWxsaWNcbiAgICA1MDogNCwgIC8vIGxhbmdBemVyYmFpamFuQXIg4oaSIHNtQXJhYmljXG4gICAgNTE6IDI0LCAgLy8gbGFuZ0FybWVuaWFuIOKGkiBzbUFybWVuaWFuXG4gICAgNTI6IDIzLCAgLy8gbGFuZ0dlb3JnaWFuIOKGkiBzbUdlb3JnaWFuXG4gICAgNTM6IDcsICAvLyBsYW5nTW9sZGF2aWFuIOKGkiBzbUN5cmlsbGljXG4gICAgNTQ6IDcsICAvLyBsYW5nS2lyZ2hpeiDihpIgc21DeXJpbGxpY1xuICAgIDU1OiA3LCAgLy8gbGFuZ1RhamlraSDihpIgc21DeXJpbGxpY1xuICAgIDU2OiA3LCAgLy8gbGFuZ1R1cmttZW4g4oaSIHNtQ3lyaWxsaWNcbiAgICA1NzogMjcsICAvLyBsYW5nTW9uZ29saWFuIOKGkiBzbU1vbmdvbGlhblxuICAgIDU4OiA3LCAgLy8gbGFuZ01vbmdvbGlhbkN5ciDihpIgc21DeXJpbGxpY1xuICAgIDU5OiA0LCAgLy8gbGFuZ1Bhc2h0byDihpIgc21BcmFiaWNcbiAgICA2MDogNCwgIC8vIGxhbmdLdXJkaXNoIOKGkiBzbUFyYWJpY1xuICAgIDYxOiA0LCAgLy8gbGFuZ0thc2htaXJpIOKGkiBzbUFyYWJpY1xuICAgIDYyOiA0LCAgLy8gbGFuZ1NpbmRoaSDihpIgc21BcmFiaWNcbiAgICA2MzogMjYsICAvLyBsYW5nVGliZXRhbiDihpIgc21UaWJldGFuXG4gICAgNjQ6IDksICAvLyBsYW5nTmVwYWxpIOKGkiBzbURldmFuYWdhcmlcbiAgICA2NTogOSwgIC8vIGxhbmdTYW5za3JpdCDihpIgc21EZXZhbmFnYXJpXG4gICAgNjY6IDksICAvLyBsYW5nTWFyYXRoaSDihpIgc21EZXZhbmFnYXJpXG4gICAgNjc6IDEzLCAgLy8gbGFuZ0JlbmdhbGkg4oaSIHNtQmVuZ2FsaVxuICAgIDY4OiAxMywgIC8vIGxhbmdBc3NhbWVzZSDihpIgc21CZW5nYWxpXG4gICAgNjk6IDExLCAgLy8gbGFuZ0d1amFyYXRpIOKGkiBzbUd1amFyYXRpXG4gICAgNzA6IDEwLCAgLy8gbGFuZ1B1bmphYmkg4oaSIHNtR3VybXVraGlcbiAgICA3MTogMTIsICAvLyBsYW5nT3JpeWEg4oaSIHNtT3JpeWFcbiAgICA3MjogMTcsICAvLyBsYW5nTWFsYXlhbGFtIOKGkiBzbU1hbGF5YWxhbVxuICAgIDczOiAxNiwgIC8vIGxhbmdLYW5uYWRhIOKGkiBzbUthbm5hZGFcbiAgICA3NDogMTQsICAvLyBsYW5nVGFtaWwg4oaSIHNtVGFtaWxcbiAgICA3NTogMTUsICAvLyBsYW5nVGVsdWd1IOKGkiBzbVRlbHVndVxuICAgIDc2OiAxOCwgIC8vIGxhbmdTaW5oYWxlc2Ug4oaSIHNtU2luaGFsZXNlXG4gICAgNzc6IDE5LCAgLy8gbGFuZ0J1cm1lc2Ug4oaSIHNtQnVybWVzZVxuICAgIDc4OiAyMCwgIC8vIGxhbmdLaG1lciDihpIgc21LaG1lclxuICAgIDc5OiAyMiwgIC8vIGxhbmdMYW8g4oaSIHNtTGFvXG4gICAgODA6IDMwLCAgLy8gbGFuZ1ZpZXRuYW1lc2Ug4oaSIHNtVmlldG5hbWVzZVxuICAgIDgxOiAwLCAgLy8gbGFuZ0luZG9uZXNpYW4g4oaSIHNtUm9tYW5cbiAgICA4MjogMCwgIC8vIGxhbmdUYWdhbG9nIOKGkiBzbVJvbWFuXG4gICAgODM6IDAsICAvLyBsYW5nTWFsYXlSb21hbiDihpIgc21Sb21hblxuICAgIDg0OiA0LCAgLy8gbGFuZ01hbGF5QXJhYmljIOKGkiBzbUFyYWJpY1xuICAgIDg1OiAyOCwgIC8vIGxhbmdBbWhhcmljIOKGkiBzbUV0aGlvcGljXG4gICAgODY6IDI4LCAgLy8gbGFuZ1RpZ3JpbnlhIOKGkiBzbUV0aGlvcGljXG4gICAgODc6IDI4LCAgLy8gbGFuZ09yb21vIOKGkiBzbUV0aGlvcGljXG4gICAgODg6IDAsICAvLyBsYW5nU29tYWxpIOKGkiBzbVJvbWFuXG4gICAgODk6IDAsICAvLyBsYW5nU3dhaGlsaSDihpIgc21Sb21hblxuICAgIDkwOiAwLCAgLy8gbGFuZ0tpbnlhcndhbmRhIOKGkiBzbVJvbWFuXG4gICAgOTE6IDAsICAvLyBsYW5nUnVuZGkg4oaSIHNtUm9tYW5cbiAgICA5MjogMCwgIC8vIGxhbmdOeWFuamEg4oaSIHNtUm9tYW5cbiAgICA5MzogMCwgIC8vIGxhbmdNYWxhZ2FzeSDihpIgc21Sb21hblxuICAgIDk0OiAwLCAgLy8gbGFuZ0VzcGVyYW50byDihpIgc21Sb21hblxuICAgIDEyODogMCwgIC8vIGxhbmdXZWxzaCDihpIgc21Sb21hbiAobW9kaWZpZWQpXG4gICAgMTI5OiAwLCAgLy8gbGFuZ0Jhc3F1ZSDihpIgc21Sb21hblxuICAgIDEzMDogMCwgIC8vIGxhbmdDYXRhbGFuIOKGkiBzbVJvbWFuXG4gICAgMTMxOiAwLCAgLy8gbGFuZ0xhdGluIOKGkiBzbVJvbWFuXG4gICAgMTMyOiAwLCAgLy8gbGFuZ1F1ZWNodWEg4oaSIHNtUm9tYW5cbiAgICAxMzM6IDAsICAvLyBsYW5nR3VhcmFuaSDihpIgc21Sb21hblxuICAgIDEzNDogMCwgIC8vIGxhbmdBeW1hcmEg4oaSIHNtUm9tYW5cbiAgICAxMzU6IDcsICAvLyBsYW5nVGF0YXIg4oaSIHNtQ3lyaWxsaWNcbiAgICAxMzY6IDQsICAvLyBsYW5nVWlnaHVyIOKGkiBzbUFyYWJpY1xuICAgIDEzNzogMjYsICAvLyBsYW5nRHpvbmdraGEg4oaSIHNtVGliZXRhblxuICAgIDEzODogMCwgIC8vIGxhbmdKYXZhbmVzZVJvbSDihpIgc21Sb21hblxuICAgIDEzOTogMCwgIC8vIGxhbmdTdW5kYW5lc2VSb20g4oaSIHNtUm9tYW5cbiAgICAxNDA6IDAsICAvLyBsYW5nR2FsaWNpYW4g4oaSIHNtUm9tYW5cbiAgICAxNDE6IDAsICAvLyBsYW5nQWZyaWthYW5zIOKGkiBzbVJvbWFuXG4gICAgMTQyOiAwLCAgLy8gbGFuZ0JyZXRvbiDihpIgc21Sb21hbiAobW9kaWZpZWQpXG4gICAgMTQzOiAyOCwgIC8vIGxhbmdJbnVrdGl0dXQg4oaSIHNtRXRoaW9waWMgKG1vZGlmaWVkKVxuICAgIDE0NDogMCwgIC8vIGxhbmdTY290dGlzaEdhZWxpYyDihpIgc21Sb21hbiAobW9kaWZpZWQpXG4gICAgMTQ1OiAwLCAgLy8gbGFuZ01hbnhHYWVsaWMg4oaSIHNtUm9tYW4gKG1vZGlmaWVkKVxuICAgIDE0NjogMCwgIC8vIGxhbmdJcmlzaEdhZWxpY1NjcmlwdCDihpIgc21Sb21hbiAobW9kaWZpZWQpXG4gICAgMTQ3OiAwLCAgLy8gbGFuZ1RvbmdhbiDihpIgc21Sb21hblxuICAgIDE0ODogNiwgIC8vIGxhbmdHcmVla0FuY2llbnQg4oaSIHNtUm9tYW5cbiAgICAxNDk6IDAsICAvLyBsYW5nR3JlZW5sYW5kaWMg4oaSIHNtUm9tYW5cbiAgICAxNTA6IDAsICAvLyBsYW5nQXplcmJhaWphblJvbWFuIOKGkiBzbVJvbWFuXG4gICAgMTUxOiAwICAgLy8gbGFuZ055bm9yc2sg4oaSIHNtUm9tYW5cbn07XG5cbi8vIFdoaWxlIE1pY3Jvc29mdCBpbmRpY2F0ZXMgYSByZWdpb24vY291bnRyeSBmb3IgYWxsIGl0cyBsYW5ndWFnZVxuLy8gSURzLCB3ZSBvbWl0IHRoZSByZWdpb24gY29kZSBpZiBpdCdzIGVxdWFsIHRvIHRoZSBcIm1vc3QgbGlrZWx5XG4vLyByZWdpb24gc3VidGFnXCIgYWNjb3JkaW5nIHRvIFVuaWNvZGUgQ0xEUi4gRm9yIHNjcmlwdHMsIHdlIG9taXRcbi8vIHRoZSBzdWJ0YWcgaWYgaXQgaXMgZXF1YWwgdG8gdGhlIFN1cHByZXNzLVNjcmlwdCBlbnRyeSBpbiB0aGVcbi8vIElBTkEgbGFuZ3VhZ2Ugc3VidGFnIHJlZ2lzdHJ5IGZvciBJRVRGIEJDUCA0Ny5cbi8vXG4vLyBGb3IgZXhhbXBsZSwgTWljcm9zb2Z0IHN0YXRlcyB0aGF0IGl0cyBsYW5ndWFnZSBjb2RlIDB4MDQxQSBpc1xuLy8gQ3JvYXRpYW4gaW4gQ3JvYXRpYS4gV2UgdHJhbnNmb3JtIHRoaXMgdG8gdGhlIEJDUCA0NyBsYW5ndWFnZSBjb2RlICdocidcbi8vIGFuZCBub3QgJ2hyLUhSJyBiZWNhdXNlIENyb2F0aWEgaXMgdGhlIGRlZmF1bHQgY291bnRyeSBmb3IgQ3JvYXRpYW4sXG4vLyBhY2NvcmRpbmcgdG8gVW5pY29kZSBDTERSLiBBcyBhbm90aGVyIGV4YW1wbGUsIE1pY3Jvc29mdCBzdGF0ZXNcbi8vIHRoYXQgMHgxMDFBIGlzIENyb2F0aWFuIChMYXRpbikgaW4gQm9zbmlhLUhlcnplZ292aW5hLiBXZSB0cmFuc2Zvcm1cbi8vIHRoaXMgdG8gJ2hyLUJBJyBhbmQgbm90ICdoci1MYXRuLUJBJyBiZWNhdXNlIExhdGluIGlzIHRoZSBkZWZhdWx0IHNjcmlwdFxuLy8gZm9yIHRoZSBDcm9hdGlhbiBsYW5ndWFnZSwgYWNjb3JkaW5nIHRvIElBTkEuXG4vL1xuLy8gaHR0cDovL3d3dy51bmljb2RlLm9yZy9jbGRyL2NoYXJ0cy9sYXRlc3Qvc3VwcGxlbWVudGFsL2xpa2VseV9zdWJ0YWdzLmh0bWxcbi8vIGh0dHA6Ly93d3cuaWFuYS5vcmcvYXNzaWdubWVudHMvbGFuZ3VhZ2Utc3VidGFnLXJlZ2lzdHJ5L2xhbmd1YWdlLXN1YnRhZy1yZWdpc3RyeVxudmFyIHdpbmRvd3NMYW5ndWFnZXMgPSB7XG4gICAgMHgwNDM2OiAnYWYnLFxuICAgIDB4MDQxQzogJ3NxJyxcbiAgICAweDA0ODQ6ICdnc3cnLFxuICAgIDB4MDQ1RTogJ2FtJyxcbiAgICAweDE0MDE6ICdhci1EWicsXG4gICAgMHgzQzAxOiAnYXItQkgnLFxuICAgIDB4MEMwMTogJ2FyJyxcbiAgICAweDA4MDE6ICdhci1JUScsXG4gICAgMHgyQzAxOiAnYXItSk8nLFxuICAgIDB4MzQwMTogJ2FyLUtXJyxcbiAgICAweDMwMDE6ICdhci1MQicsXG4gICAgMHgxMDAxOiAnYXItTFknLFxuICAgIDB4MTgwMTogJ2FyeScsXG4gICAgMHgyMDAxOiAnYXItT00nLFxuICAgIDB4NDAwMTogJ2FyLVFBJyxcbiAgICAweDA0MDE6ICdhci1TQScsXG4gICAgMHgyODAxOiAnYXItU1knLFxuICAgIDB4MUMwMTogJ2FlYicsXG4gICAgMHgzODAxOiAnYXItQUUnLFxuICAgIDB4MjQwMTogJ2FyLVlFJyxcbiAgICAweDA0MkI6ICdoeScsXG4gICAgMHgwNDREOiAnYXMnLFxuICAgIDB4MDgyQzogJ2F6LUN5cmwnLFxuICAgIDB4MDQyQzogJ2F6JyxcbiAgICAweDA0NkQ6ICdiYScsXG4gICAgMHgwNDJEOiAnZXUnLFxuICAgIDB4MDQyMzogJ2JlJyxcbiAgICAweDA4NDU6ICdibicsXG4gICAgMHgwNDQ1OiAnYm4tSU4nLFxuICAgIDB4MjAxQTogJ2JzLUN5cmwnLFxuICAgIDB4MTQxQTogJ2JzJyxcbiAgICAweDA0N0U6ICdicicsXG4gICAgMHgwNDAyOiAnYmcnLFxuICAgIDB4MDQwMzogJ2NhJyxcbiAgICAweDBDMDQ6ICd6aC1ISycsXG4gICAgMHgxNDA0OiAnemgtTU8nLFxuICAgIDB4MDgwNDogJ3poJyxcbiAgICAweDEwMDQ6ICd6aC1TRycsXG4gICAgMHgwNDA0OiAnemgtVFcnLFxuICAgIDB4MDQ4MzogJ2NvJyxcbiAgICAweDA0MUE6ICdocicsXG4gICAgMHgxMDFBOiAnaHItQkEnLFxuICAgIDB4MDQwNTogJ2NzJyxcbiAgICAweDA0MDY6ICdkYScsXG4gICAgMHgwNDhDOiAncHJzJyxcbiAgICAweDA0NjU6ICdkdicsXG4gICAgMHgwODEzOiAnbmwtQkUnLFxuICAgIDB4MDQxMzogJ25sJyxcbiAgICAweDBDMDk6ICdlbi1BVScsXG4gICAgMHgyODA5OiAnZW4tQlonLFxuICAgIDB4MTAwOTogJ2VuLUNBJyxcbiAgICAweDI0MDk6ICdlbi0wMjknLFxuICAgIDB4NDAwOTogJ2VuLUlOJyxcbiAgICAweDE4MDk6ICdlbi1JRScsXG4gICAgMHgyMDA5OiAnZW4tSk0nLFxuICAgIDB4NDQwOTogJ2VuLU1ZJyxcbiAgICAweDE0MDk6ICdlbi1OWicsXG4gICAgMHgzNDA5OiAnZW4tUEgnLFxuICAgIDB4NDgwOTogJ2VuLVNHJyxcbiAgICAweDFDMDk6ICdlbi1aQScsXG4gICAgMHgyQzA5OiAnZW4tVFQnLFxuICAgIDB4MDgwOTogJ2VuLUdCJyxcbiAgICAweDA0MDk6ICdlbicsXG4gICAgMHgzMDA5OiAnZW4tWlcnLFxuICAgIDB4MDQyNTogJ2V0JyxcbiAgICAweDA0Mzg6ICdmbycsXG4gICAgMHgwNDY0OiAnZmlsJyxcbiAgICAweDA0MEI6ICdmaScsXG4gICAgMHgwODBDOiAnZnItQkUnLFxuICAgIDB4MEMwQzogJ2ZyLUNBJyxcbiAgICAweDA0MEM6ICdmcicsXG4gICAgMHgxNDBDOiAnZnItTFUnLFxuICAgIDB4MTgwQzogJ2ZyLU1DJyxcbiAgICAweDEwMEM6ICdmci1DSCcsXG4gICAgMHgwNDYyOiAnZnknLFxuICAgIDB4MDQ1NjogJ2dsJyxcbiAgICAweDA0Mzc6ICdrYScsXG4gICAgMHgwQzA3OiAnZGUtQVQnLFxuICAgIDB4MDQwNzogJ2RlJyxcbiAgICAweDE0MDc6ICdkZS1MSScsXG4gICAgMHgxMDA3OiAnZGUtTFUnLFxuICAgIDB4MDgwNzogJ2RlLUNIJyxcbiAgICAweDA0MDg6ICdlbCcsXG4gICAgMHgwNDZGOiAna2wnLFxuICAgIDB4MDQ0NzogJ2d1JyxcbiAgICAweDA0Njg6ICdoYScsXG4gICAgMHgwNDBEOiAnaGUnLFxuICAgIDB4MDQzOTogJ2hpJyxcbiAgICAweDA0MEU6ICdodScsXG4gICAgMHgwNDBGOiAnaXMnLFxuICAgIDB4MDQ3MDogJ2lnJyxcbiAgICAweDA0MjE6ICdpZCcsXG4gICAgMHgwNDVEOiAnaXUnLFxuICAgIDB4MDg1RDogJ2l1LUxhdG4nLFxuICAgIDB4MDgzQzogJ2dhJyxcbiAgICAweDA0MzQ6ICd4aCcsXG4gICAgMHgwNDM1OiAnenUnLFxuICAgIDB4MDQxMDogJ2l0JyxcbiAgICAweDA4MTA6ICdpdC1DSCcsXG4gICAgMHgwNDExOiAnamEnLFxuICAgIDB4MDQ0QjogJ2tuJyxcbiAgICAweDA0M0Y6ICdraycsXG4gICAgMHgwNDUzOiAna20nLFxuICAgIDB4MDQ4NjogJ3F1YycsXG4gICAgMHgwNDg3OiAncncnLFxuICAgIDB4MDQ0MTogJ3N3JyxcbiAgICAweDA0NTc6ICdrb2snLFxuICAgIDB4MDQxMjogJ2tvJyxcbiAgICAweDA0NDA6ICdreScsXG4gICAgMHgwNDU0OiAnbG8nLFxuICAgIDB4MDQyNjogJ2x2JyxcbiAgICAweDA0Mjc6ICdsdCcsXG4gICAgMHgwODJFOiAnZHNiJyxcbiAgICAweDA0NkU6ICdsYicsXG4gICAgMHgwNDJGOiAnbWsnLFxuICAgIDB4MDgzRTogJ21zLUJOJyxcbiAgICAweDA0M0U6ICdtcycsXG4gICAgMHgwNDRDOiAnbWwnLFxuICAgIDB4MDQzQTogJ210JyxcbiAgICAweDA0ODE6ICdtaScsXG4gICAgMHgwNDdBOiAnYXJuJyxcbiAgICAweDA0NEU6ICdtcicsXG4gICAgMHgwNDdDOiAnbW9oJyxcbiAgICAweDA0NTA6ICdtbicsXG4gICAgMHgwODUwOiAnbW4tQ04nLFxuICAgIDB4MDQ2MTogJ25lJyxcbiAgICAweDA0MTQ6ICduYicsXG4gICAgMHgwODE0OiAnbm4nLFxuICAgIDB4MDQ4MjogJ29jJyxcbiAgICAweDA0NDg6ICdvcicsXG4gICAgMHgwNDYzOiAncHMnLFxuICAgIDB4MDQxNTogJ3BsJyxcbiAgICAweDA0MTY6ICdwdCcsXG4gICAgMHgwODE2OiAncHQtUFQnLFxuICAgIDB4MDQ0NjogJ3BhJyxcbiAgICAweDA0NkI6ICdxdS1CTycsXG4gICAgMHgwODZCOiAncXUtRUMnLFxuICAgIDB4MEM2QjogJ3F1JyxcbiAgICAweDA0MTg6ICdybycsXG4gICAgMHgwNDE3OiAncm0nLFxuICAgIDB4MDQxOTogJ3J1JyxcbiAgICAweDI0M0I6ICdzbW4nLFxuICAgIDB4MTAzQjogJ3Ntai1OTycsXG4gICAgMHgxNDNCOiAnc21qJyxcbiAgICAweDBDM0I6ICdzZS1GSScsXG4gICAgMHgwNDNCOiAnc2UnLFxuICAgIDB4MDgzQjogJ3NlLVNFJyxcbiAgICAweDIwM0I6ICdzbXMnLFxuICAgIDB4MTgzQjogJ3NtYS1OTycsXG4gICAgMHgxQzNCOiAnc21zJyxcbiAgICAweDA0NEY6ICdzYScsXG4gICAgMHgxQzFBOiAnc3ItQ3lybC1CQScsXG4gICAgMHgwQzFBOiAnc3InLFxuICAgIDB4MTgxQTogJ3NyLUxhdG4tQkEnLFxuICAgIDB4MDgxQTogJ3NyLUxhdG4nLFxuICAgIDB4MDQ2QzogJ25zbycsXG4gICAgMHgwNDMyOiAndG4nLFxuICAgIDB4MDQ1QjogJ3NpJyxcbiAgICAweDA0MUI6ICdzaycsXG4gICAgMHgwNDI0OiAnc2wnLFxuICAgIDB4MkMwQTogJ2VzLUFSJyxcbiAgICAweDQwMEE6ICdlcy1CTycsXG4gICAgMHgzNDBBOiAnZXMtQ0wnLFxuICAgIDB4MjQwQTogJ2VzLUNPJyxcbiAgICAweDE0MEE6ICdlcy1DUicsXG4gICAgMHgxQzBBOiAnZXMtRE8nLFxuICAgIDB4MzAwQTogJ2VzLUVDJyxcbiAgICAweDQ0MEE6ICdlcy1TVicsXG4gICAgMHgxMDBBOiAnZXMtR1QnLFxuICAgIDB4NDgwQTogJ2VzLUhOJyxcbiAgICAweDA4MEE6ICdlcy1NWCcsXG4gICAgMHg0QzBBOiAnZXMtTkknLFxuICAgIDB4MTgwQTogJ2VzLVBBJyxcbiAgICAweDNDMEE6ICdlcy1QWScsXG4gICAgMHgyODBBOiAnZXMtUEUnLFxuICAgIDB4NTAwQTogJ2VzLVBSJyxcblxuICAgIC8vIE1pY3Jvc29mdCBoYXMgZGVmaW5lZCB0d28gZGlmZmVyZW50IGxhbmd1YWdlIGNvZGVzIGZvclxuICAgIC8vIOKAnFNwYW5pc2ggd2l0aCBtb2Rlcm4gc29ydGluZ+KAnSBhbmQg4oCcU3BhbmlzaCB3aXRoIHRyYWRpdGlvbmFsXG4gICAgLy8gc29ydGluZ+KAnS4gVGhpcyBtYWtlcyBzZW5zZSBmb3IgY29sbGF0aW9uIEFQSXMsIGFuZCBpdCB3b3VsZCBiZVxuICAgIC8vIHBvc3NpYmxlIHRvIGV4cHJlc3MgdGhpcyBpbiBCQ1AgNDcgbGFuZ3VhZ2UgdGFncyB2aWEgVW5pY29kZVxuICAgIC8vIGV4dGVuc2lvbnMgKGVnLiwgZXMtdS1jby10cmFkIGlzIFNwYW5pc2ggd2l0aCB0cmFkaXRpb25hbFxuICAgIC8vIHNvcnRpbmcpLiBIb3dldmVyLCBmb3Igc3RvcmluZyBuYW1lcyBpbiBmb250cywgdGhlIGRpc3RpbmN0aW9uXG4gICAgLy8gZG9lcyBub3QgbWFrZSBzZW5zZSwgc28gd2UgZ2l2ZSDigJxlc+KAnSBpbiBib3RoIGNhc2VzLlxuICAgIDB4MEMwQTogJ2VzJyxcbiAgICAweDA0MEE6ICdlcycsXG5cbiAgICAweDU0MEE6ICdlcy1VUycsXG4gICAgMHgzODBBOiAnZXMtVVknLFxuICAgIDB4MjAwQTogJ2VzLVZFJyxcbiAgICAweDA4MUQ6ICdzdi1GSScsXG4gICAgMHgwNDFEOiAnc3YnLFxuICAgIDB4MDQ1QTogJ3N5cicsXG4gICAgMHgwNDI4OiAndGcnLFxuICAgIDB4MDg1RjogJ3R6bScsXG4gICAgMHgwNDQ5OiAndGEnLFxuICAgIDB4MDQ0NDogJ3R0JyxcbiAgICAweDA0NEE6ICd0ZScsXG4gICAgMHgwNDFFOiAndGgnLFxuICAgIDB4MDQ1MTogJ2JvJyxcbiAgICAweDA0MUY6ICd0cicsXG4gICAgMHgwNDQyOiAndGsnLFxuICAgIDB4MDQ4MDogJ3VnJyxcbiAgICAweDA0MjI6ICd1aycsXG4gICAgMHgwNDJFOiAnaHNiJyxcbiAgICAweDA0MjA6ICd1cicsXG4gICAgMHgwODQzOiAndXotQ3lybCcsXG4gICAgMHgwNDQzOiAndXonLFxuICAgIDB4MDQyQTogJ3ZpJyxcbiAgICAweDA0NTI6ICdjeScsXG4gICAgMHgwNDg4OiAnd28nLFxuICAgIDB4MDQ4NTogJ3NhaCcsXG4gICAgMHgwNDc4OiAnaWknLFxuICAgIDB4MDQ2QTogJ3lvJ1xufTtcblxuLy8gUmV0dXJucyBhIElFVEYgQkNQIDQ3IGxhbmd1YWdlIGNvZGUsIGZvciBleGFtcGxlICd6aC1IYW50J1xuLy8gZm9yICdDaGluZXNlIGluIHRoZSB0cmFkaXRpb25hbCBzY3JpcHQnLlxuZnVuY3Rpb24gZ2V0TGFuZ3VhZ2VDb2RlKHBsYXRmb3JtSUQsIGxhbmd1YWdlSUQsIGx0YWcpIHtcbiAgICBzd2l0Y2ggKHBsYXRmb3JtSUQpIHtcbiAgICAgICAgY2FzZSAwOiAgLy8gVW5pY29kZVxuICAgICAgICAgICAgaWYgKGxhbmd1YWdlSUQgPT09IDB4RkZGRikge1xuICAgICAgICAgICAgICAgIHJldHVybiAndW5kJztcbiAgICAgICAgICAgIH0gZWxzZSBpZiAobHRhZykge1xuICAgICAgICAgICAgICAgIHJldHVybiBsdGFnW2xhbmd1YWdlSURdO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlIDE6ICAvLyBNYWNpbnRvc2hcbiAgICAgICAgICAgIHJldHVybiBtYWNMYW5ndWFnZXNbbGFuZ3VhZ2VJRF07XG5cbiAgICAgICAgY2FzZSAzOiAgLy8gV2luZG93c1xuICAgICAgICAgICAgcmV0dXJuIHdpbmRvd3NMYW5ndWFnZXNbbGFuZ3VhZ2VJRF07XG4gICAgfVxuXG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbn1cblxudmFyIHV0ZjE2ID0gJ3V0Zi0xNic7XG5cbi8vIE1hY09TIHNjcmlwdCBJRCDihpIgZW5jb2RpbmcuIFRoaXMgdGFibGUgc3RvcmVzIHRoZSBkZWZhdWx0IGNhc2UsXG4vLyB3aGljaCBjYW4gYmUgb3ZlcnJpZGRlbiBieSBtYWNMYW5ndWFnZUVuY29kaW5ncy5cbnZhciBtYWNTY3JpcHRFbmNvZGluZ3MgPSB7XG4gICAgMDogJ21hY2ludG9zaCcsICAgICAgICAgICAvLyBzbVJvbWFuXG4gICAgMTogJ3gtbWFjLWphcGFuZXNlJywgICAgICAvLyBzbUphcGFuZXNlXG4gICAgMjogJ3gtbWFjLWNoaW5lc2V0cmFkJywgICAvLyBzbVRyYWRDaGluZXNlXG4gICAgMzogJ3gtbWFjLWtvcmVhbicsICAgICAgICAvLyBzbUtvcmVhblxuICAgIDY6ICd4LW1hYy1ncmVlaycsICAgICAgICAgLy8gc21HcmVla1xuICAgIDc6ICd4LW1hYy1jeXJpbGxpYycsICAgICAgLy8gc21DeXJpbGxpY1xuICAgIDk6ICd4LW1hYy1kZXZhbmFnYWknLCAgICAgLy8gc21EZXZhbmFnYXJpXG4gICAgMTA6ICd4LW1hYy1ndXJtdWtoaScsICAgICAvLyBzbUd1cm11a2hpXG4gICAgMTE6ICd4LW1hYy1ndWphcmF0aScsICAgICAvLyBzbUd1amFyYXRpXG4gICAgMTI6ICd4LW1hYy1vcml5YScsICAgICAgICAvLyBzbU9yaXlhXG4gICAgMTM6ICd4LW1hYy1iZW5nYWxpJywgICAgICAvLyBzbUJlbmdhbGlcbiAgICAxNDogJ3gtbWFjLXRhbWlsJywgICAgICAgIC8vIHNtVGFtaWxcbiAgICAxNTogJ3gtbWFjLXRlbHVndScsICAgICAgIC8vIHNtVGVsdWd1XG4gICAgMTY6ICd4LW1hYy1rYW5uYWRhJywgICAgICAvLyBzbUthbm5hZGFcbiAgICAxNzogJ3gtbWFjLW1hbGF5YWxhbScsICAgIC8vIHNtTWFsYXlhbGFtXG4gICAgMTg6ICd4LW1hYy1zaW5oYWxlc2UnLCAgICAvLyBzbVNpbmhhbGVzZVxuICAgIDE5OiAneC1tYWMtYnVybWVzZScsICAgICAgLy8gc21CdXJtZXNlXG4gICAgMjA6ICd4LW1hYy1raG1lcicsICAgICAgICAvLyBzbUtobWVyXG4gICAgMjE6ICd4LW1hYy10aGFpJywgICAgICAgICAvLyBzbVRoYWlcbiAgICAyMjogJ3gtbWFjLWxhbycsICAgICAgICAgIC8vIHNtTGFvXG4gICAgMjM6ICd4LW1hYy1nZW9yZ2lhbicsICAgICAvLyBzbUdlb3JnaWFuXG4gICAgMjQ6ICd4LW1hYy1hcm1lbmlhbicsICAgICAvLyBzbUFybWVuaWFuXG4gICAgMjU6ICd4LW1hYy1jaGluZXNlc2ltcCcsICAvLyBzbVNpbXBDaGluZXNlXG4gICAgMjY6ICd4LW1hYy10aWJldGFuJywgICAgICAvLyBzbVRpYmV0YW5cbiAgICAyNzogJ3gtbWFjLW1vbmdvbGlhbicsICAgIC8vIHNtTW9uZ29saWFuXG4gICAgMjg6ICd4LW1hYy1ldGhpb3BpYycsICAgICAvLyBzbUV0aGlvcGljXG4gICAgMjk6ICd4LW1hYy1jZScsICAgICAgICAgICAvLyBzbUNlbnRyYWxFdXJvUm9tYW5cbiAgICAzMDogJ3gtbWFjLXZpZXRuYW1lc2UnLCAgIC8vIHNtVmlldG5hbWVzZVxuICAgIDMxOiAneC1tYWMtZXh0YXJhYmljJyAgICAgLy8gc21FeHRBcmFiaWNcbn07XG5cbi8vIE1hY09TIGxhbmd1YWdlIElEIOKGkiBlbmNvZGluZy4gVGhpcyB0YWJsZSBzdG9yZXMgdGhlIGV4Y2VwdGlvbmFsXG4vLyBjYXNlcywgd2hpY2ggb3ZlcnJpZGUgbWFjU2NyaXB0RW5jb2RpbmdzLiBGb3Igd3JpdGluZyBNYWNPUyBuYW1pbmdcbi8vIHRhYmxlcywgd2UgbmVlZCB0byBlbWl0IGEgTWFjT1Mgc2NyaXB0IElELiBUaGVyZWZvcmUsIHdlIGNhbm5vdFxuLy8gbWVyZ2UgbWFjU2NyaXB0RW5jb2RpbmdzIGludG8gbWFjTGFuZ3VhZ2VFbmNvZGluZ3MuXG4vL1xuLy8gaHR0cDovL3VuaWNvZGUub3JnL1B1YmxpYy9NQVBQSU5HUy9WRU5ET1JTL0FQUExFL1JlYWRtZS50eHRcbnZhciBtYWNMYW5ndWFnZUVuY29kaW5ncyA9IHtcbiAgICAxNTogJ3gtbWFjLWljZWxhbmRpYycsICAgIC8vIGxhbmdJY2VsYW5kaWNcbiAgICAxNzogJ3gtbWFjLXR1cmtpc2gnLCAgICAgIC8vIGxhbmdUdXJraXNoXG4gICAgMTg6ICd4LW1hYy1jcm9hdGlhbicsICAgICAvLyBsYW5nQ3JvYXRpYW5cbiAgICAyNDogJ3gtbWFjLWNlJywgICAgICAgICAgIC8vIGxhbmdMaXRodWFuaWFuXG4gICAgMjU6ICd4LW1hYy1jZScsICAgICAgICAgICAvLyBsYW5nUG9saXNoXG4gICAgMjY6ICd4LW1hYy1jZScsICAgICAgICAgICAvLyBsYW5nSHVuZ2FyaWFuXG4gICAgMjc6ICd4LW1hYy1jZScsICAgICAgICAgICAvLyBsYW5nRXN0b25pYW5cbiAgICAyODogJ3gtbWFjLWNlJywgICAgICAgICAgIC8vIGxhbmdMYXR2aWFuXG4gICAgMzA6ICd4LW1hYy1pY2VsYW5kaWMnLCAgICAvLyBsYW5nRmFyb2VzZVxuICAgIDM3OiAneC1tYWMtcm9tYW5pYW4nLCAgICAgLy8gbGFuZ1JvbWFuaWFuXG4gICAgMzg6ICd4LW1hYy1jZScsICAgICAgICAgICAvLyBsYW5nQ3plY2hcbiAgICAzOTogJ3gtbWFjLWNlJywgICAgICAgICAgIC8vIGxhbmdTbG92YWtcbiAgICA0MDogJ3gtbWFjLWNlJywgICAgICAgICAgIC8vIGxhbmdTbG92ZW5pYW5cbiAgICAxNDM6ICd4LW1hYy1pbnVpdCcsICAgICAgIC8vIGxhbmdJbnVrdGl0dXRcbiAgICAxNDY6ICd4LW1hYy1nYWVsaWMnICAgICAgIC8vIGxhbmdJcmlzaEdhZWxpY1NjcmlwdFxufTtcblxuZnVuY3Rpb24gZ2V0RW5jb2RpbmcocGxhdGZvcm1JRCwgZW5jb2RpbmdJRCwgbGFuZ3VhZ2VJRCkge1xuICAgIHN3aXRjaCAocGxhdGZvcm1JRCkge1xuICAgICAgICBjYXNlIDA6ICAvLyBVbmljb2RlXG4gICAgICAgICAgICByZXR1cm4gdXRmMTY7XG5cbiAgICAgICAgY2FzZSAxOiAgLy8gQXBwbGUgTWFjaW50b3NoXG4gICAgICAgICAgICByZXR1cm4gbWFjTGFuZ3VhZ2VFbmNvZGluZ3NbbGFuZ3VhZ2VJRF0gfHwgbWFjU2NyaXB0RW5jb2RpbmdzW2VuY29kaW5nSURdO1xuXG4gICAgICAgIGNhc2UgMzogIC8vIE1pY3Jvc29mdCBXaW5kb3dzXG4gICAgICAgICAgICBpZiAoZW5jb2RpbmdJRCA9PT0gMSB8fCBlbmNvZGluZ0lEID09PSAxMCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB1dGYxNjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbn1cblxuLy8gUGFyc2UgdGhlIG5hbWluZyBgbmFtZWAgdGFibGUuXG4vLyBGSVhNRTogRm9ybWF0IDEgYWRkaXRpb25hbCBmaWVsZHMgYXJlIG5vdCBzdXBwb3J0ZWQgeWV0LlxuLy8gbHRhZyBpcyB0aGUgY29udGVudCBvZiB0aGUgYGx0YWcnIHRhYmxlLCBzdWNoIGFzIFsnZW4nLCAnemgtSGFucycsICdkZS1DSC0xOTA0J10uXG5mdW5jdGlvbiBwYXJzZU5hbWVUYWJsZShkYXRhLCBzdGFydCwgbHRhZykge1xuICAgIHZhciBuYW1lID0ge307XG4gICAgdmFyIHAgPSBuZXcgcGFyc2UuUGFyc2VyKGRhdGEsIHN0YXJ0KTtcbiAgICB2YXIgZm9ybWF0ID0gcC5wYXJzZVVTaG9ydCgpO1xuICAgIHZhciBjb3VudCA9IHAucGFyc2VVU2hvcnQoKTtcbiAgICB2YXIgc3RyaW5nT2Zmc2V0ID0gcC5vZmZzZXQgKyBwLnBhcnNlVVNob3J0KCk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb3VudDsgaSsrKSB7XG4gICAgICAgIHZhciBwbGF0Zm9ybUlEID0gcC5wYXJzZVVTaG9ydCgpO1xuICAgICAgICB2YXIgZW5jb2RpbmdJRCA9IHAucGFyc2VVU2hvcnQoKTtcbiAgICAgICAgdmFyIGxhbmd1YWdlSUQgPSBwLnBhcnNlVVNob3J0KCk7XG4gICAgICAgIHZhciBuYW1lSUQgPSBwLnBhcnNlVVNob3J0KCk7XG4gICAgICAgIHZhciBwcm9wZXJ0eSA9IG5hbWVUYWJsZU5hbWVzW25hbWVJRF0gfHwgbmFtZUlEO1xuICAgICAgICB2YXIgYnl0ZUxlbmd0aCA9IHAucGFyc2VVU2hvcnQoKTtcbiAgICAgICAgdmFyIG9mZnNldCA9IHAucGFyc2VVU2hvcnQoKTtcbiAgICAgICAgdmFyIGxhbmd1YWdlID0gZ2V0TGFuZ3VhZ2VDb2RlKHBsYXRmb3JtSUQsIGxhbmd1YWdlSUQsIGx0YWcpO1xuICAgICAgICB2YXIgZW5jb2RpbmcgPSBnZXRFbmNvZGluZyhwbGF0Zm9ybUlELCBlbmNvZGluZ0lELCBsYW5ndWFnZUlEKTtcbiAgICAgICAgaWYgKGVuY29kaW5nICE9PSB1bmRlZmluZWQgJiYgbGFuZ3VhZ2UgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdmFyIHRleHQgPSAodm9pZCAwKTtcbiAgICAgICAgICAgIGlmIChlbmNvZGluZyA9PT0gdXRmMTYpIHtcbiAgICAgICAgICAgICAgICB0ZXh0ID0gZGVjb2RlLlVURjE2KGRhdGEsIHN0cmluZ09mZnNldCArIG9mZnNldCwgYnl0ZUxlbmd0aCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRleHQgPSBkZWNvZGUuTUFDU1RSSU5HKGRhdGEsIHN0cmluZ09mZnNldCArIG9mZnNldCwgYnl0ZUxlbmd0aCwgZW5jb2RpbmcpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAodGV4dCkge1xuICAgICAgICAgICAgICAgIHZhciB0cmFuc2xhdGlvbnMgPSBuYW1lW3Byb3BlcnR5XTtcbiAgICAgICAgICAgICAgICBpZiAodHJhbnNsYXRpb25zID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgdHJhbnNsYXRpb25zID0gbmFtZVtwcm9wZXJ0eV0gPSB7fTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB0cmFuc2xhdGlvbnNbbGFuZ3VhZ2VdID0gdGV4dDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIHZhciBsYW5nVGFnQ291bnQgPSAwO1xuICAgIGlmIChmb3JtYXQgPT09IDEpIHtcbiAgICAgICAgLy8gRklYTUU6IEFsc28gaGFuZGxlIE1pY3Jvc29mdCdzICduYW1lJyB0YWJsZSAxLlxuICAgICAgICBsYW5nVGFnQ291bnQgPSBwLnBhcnNlVVNob3J0KCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG5hbWU7XG59XG5cbi8vIHsyMzogJ2Zvbyd9IOKGkiB7J2Zvbyc6IDIzfVxuLy8gWydiYXInLCAnYmF6J10g4oaSIHsnYmFyJzogMCwgJ2Jheic6IDF9XG5mdW5jdGlvbiByZXZlcnNlRGljdChkaWN0KSB7XG4gICAgdmFyIHJlc3VsdCA9IHt9O1xuICAgIGZvciAodmFyIGtleSBpbiBkaWN0KSB7XG4gICAgICAgIHJlc3VsdFtkaWN0W2tleV1dID0gcGFyc2VJbnQoa2V5KTtcbiAgICB9XG5cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuXG5mdW5jdGlvbiBtYWtlTmFtZVJlY29yZChwbGF0Zm9ybUlELCBlbmNvZGluZ0lELCBsYW5ndWFnZUlELCBuYW1lSUQsIGxlbmd0aCwgb2Zmc2V0KSB7XG4gICAgcmV0dXJuIG5ldyB0YWJsZS5SZWNvcmQoJ05hbWVSZWNvcmQnLCBbXG4gICAgICAgIHtuYW1lOiAncGxhdGZvcm1JRCcsIHR5cGU6ICdVU0hPUlQnLCB2YWx1ZTogcGxhdGZvcm1JRH0sXG4gICAgICAgIHtuYW1lOiAnZW5jb2RpbmdJRCcsIHR5cGU6ICdVU0hPUlQnLCB2YWx1ZTogZW5jb2RpbmdJRH0sXG4gICAgICAgIHtuYW1lOiAnbGFuZ3VhZ2VJRCcsIHR5cGU6ICdVU0hPUlQnLCB2YWx1ZTogbGFuZ3VhZ2VJRH0sXG4gICAgICAgIHtuYW1lOiAnbmFtZUlEJywgdHlwZTogJ1VTSE9SVCcsIHZhbHVlOiBuYW1lSUR9LFxuICAgICAgICB7bmFtZTogJ2xlbmd0aCcsIHR5cGU6ICdVU0hPUlQnLCB2YWx1ZTogbGVuZ3RofSxcbiAgICAgICAge25hbWU6ICdvZmZzZXQnLCB0eXBlOiAnVVNIT1JUJywgdmFsdWU6IG9mZnNldH1cbiAgICBdKTtcbn1cblxuLy8gRmluZHMgdGhlIHBvc2l0aW9uIG9mIG5lZWRsZSBpbiBoYXlzdGFjaywgb3IgLTEgaWYgbm90IHRoZXJlLlxuLy8gTGlrZSBTdHJpbmcuaW5kZXhPZigpLCBidXQgZm9yIGFycmF5cy5cbmZ1bmN0aW9uIGZpbmRTdWJBcnJheShuZWVkbGUsIGhheXN0YWNrKSB7XG4gICAgdmFyIG5lZWRsZUxlbmd0aCA9IG5lZWRsZS5sZW5ndGg7XG4gICAgdmFyIGxpbWl0ID0gaGF5c3RhY2subGVuZ3RoIC0gbmVlZGxlTGVuZ3RoICsgMTtcblxuICAgIGxvb3A6XG4gICAgZm9yICh2YXIgcG9zID0gMDsgcG9zIDwgbGltaXQ7IHBvcysrKSB7XG4gICAgICAgIGZvciAoOyBwb3MgPCBsaW1pdDsgcG9zKyspIHtcbiAgICAgICAgICAgIGZvciAodmFyIGsgPSAwOyBrIDwgbmVlZGxlTGVuZ3RoOyBrKyspIHtcbiAgICAgICAgICAgICAgICBpZiAoaGF5c3RhY2tbcG9zICsga10gIT09IG5lZWRsZVtrXSkge1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZSBsb29wO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHBvcztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiAtMTtcbn1cblxuZnVuY3Rpb24gYWRkU3RyaW5nVG9Qb29sKHMsIHBvb2wpIHtcbiAgICB2YXIgb2Zmc2V0ID0gZmluZFN1YkFycmF5KHMsIHBvb2wpO1xuICAgIGlmIChvZmZzZXQgPCAwKSB7XG4gICAgICAgIG9mZnNldCA9IHBvb2wubGVuZ3RoO1xuICAgICAgICB2YXIgaSA9IDA7XG4gICAgICAgIHZhciBsZW4gPSBzLmxlbmd0aDtcbiAgICAgICAgZm9yICg7IGkgPCBsZW47ICsraSkge1xuICAgICAgICAgICAgcG9vbC5wdXNoKHNbaV0pO1xuICAgICAgICB9XG5cbiAgICB9XG5cbiAgICByZXR1cm4gb2Zmc2V0O1xufVxuXG5mdW5jdGlvbiBtYWtlTmFtZVRhYmxlKG5hbWVzLCBsdGFnKSB7XG4gICAgdmFyIG5hbWVJRDtcbiAgICB2YXIgbmFtZUlEcyA9IFtdO1xuXG4gICAgdmFyIG5hbWVzV2l0aE51bWVyaWNLZXlzID0ge307XG4gICAgdmFyIG5hbWVUYWJsZUlkcyA9IHJldmVyc2VEaWN0KG5hbWVUYWJsZU5hbWVzKTtcbiAgICBmb3IgKHZhciBrZXkgaW4gbmFtZXMpIHtcbiAgICAgICAgdmFyIGlkID0gbmFtZVRhYmxlSWRzW2tleV07XG4gICAgICAgIGlmIChpZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBpZCA9IGtleTtcbiAgICAgICAgfVxuXG4gICAgICAgIG5hbWVJRCA9IHBhcnNlSW50KGlkKTtcblxuICAgICAgICBpZiAoaXNOYU4obmFtZUlEKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdOYW1lIHRhYmxlIGVudHJ5IFwiJyArIGtleSArICdcIiBkb2VzIG5vdCBleGlzdCwgc2VlIG5hbWVUYWJsZU5hbWVzIGZvciBjb21wbGV0ZSBsaXN0LicpO1xuICAgICAgICB9XG5cbiAgICAgICAgbmFtZXNXaXRoTnVtZXJpY0tleXNbbmFtZUlEXSA9IG5hbWVzW2tleV07XG4gICAgICAgIG5hbWVJRHMucHVzaChuYW1lSUQpO1xuICAgIH1cblxuICAgIHZhciBtYWNMYW5ndWFnZUlkcyA9IHJldmVyc2VEaWN0KG1hY0xhbmd1YWdlcyk7XG4gICAgdmFyIHdpbmRvd3NMYW5ndWFnZUlkcyA9IHJldmVyc2VEaWN0KHdpbmRvd3NMYW5ndWFnZXMpO1xuXG4gICAgdmFyIG5hbWVSZWNvcmRzID0gW107XG4gICAgdmFyIHN0cmluZ1Bvb2wgPSBbXTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbmFtZUlEcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBuYW1lSUQgPSBuYW1lSURzW2ldO1xuICAgICAgICB2YXIgdHJhbnNsYXRpb25zID0gbmFtZXNXaXRoTnVtZXJpY0tleXNbbmFtZUlEXTtcbiAgICAgICAgZm9yICh2YXIgbGFuZyBpbiB0cmFuc2xhdGlvbnMpIHtcbiAgICAgICAgICAgIHZhciB0ZXh0ID0gdHJhbnNsYXRpb25zW2xhbmddO1xuXG4gICAgICAgICAgICAvLyBGb3IgTWFjT1MsIHdlIHRyeSB0byBlbWl0IHRoZSBuYW1lIGluIHRoZSBmb3JtIHRoYXQgd2FzIGludHJvZHVjZWRcbiAgICAgICAgICAgIC8vIGluIHRoZSBpbml0aWFsIHZlcnNpb24gb2YgdGhlIFRydWVUeXBlIHNwZWMgKGluIHRoZSBsYXRlIDE5ODBzKS5cbiAgICAgICAgICAgIC8vIEhvd2V2ZXIsIHRoaXMgY2FuIGZhaWwgZm9yIHZhcmlvdXMgcmVhc29uczogdGhlIHJlcXVlc3RlZCBCQ1AgNDdcbiAgICAgICAgICAgIC8vIGxhbmd1YWdlIGNvZGUgbWlnaHQgbm90IGhhdmUgYW4gb2xkLXN0eWxlIE1hYyBlcXVpdmFsZW50O1xuICAgICAgICAgICAgLy8gd2UgbWlnaHQgbm90IGhhdmUgYSBjb2RlYyBmb3IgdGhlIG5lZWRlZCBjaGFyYWN0ZXIgZW5jb2Rpbmc7XG4gICAgICAgICAgICAvLyBvciB0aGUgbmFtZSBtaWdodCBjb250YWluIGNoYXJhY3RlcnMgdGhhdCBjYW5ub3QgYmUgZXhwcmVzc2VkXG4gICAgICAgICAgICAvLyBpbiB0aGUgb2xkLXN0eWxlIE1hY2ludG9zaCBlbmNvZGluZy4gSW4gY2FzZSBvZiBmYWlsdXJlLCB3ZSBlbWl0XG4gICAgICAgICAgICAvLyB0aGUgbmFtZSBpbiBhIG1vcmUgbW9kZXJuIGZhc2hpb24gKFVuaWNvZGUgZW5jb2Rpbmcgd2l0aCBCQ1AgNDdcbiAgICAgICAgICAgIC8vIGxhbmd1YWdlIHRhZ3MpIHRoYXQgaXMgcmVjb2duaXplZCBieSBNYWNPUyAxMC41LCByZWxlYXNlZCBpbiAyMDA5LlxuICAgICAgICAgICAgLy8gSWYgZm9udHMgd2VyZSBvbmx5IHJlYWQgYnkgb3BlcmF0aW5nIHN5c3RlbXMsIHdlIGNvdWxkIHNpbXBseVxuICAgICAgICAgICAgLy8gZW1pdCBhbGwgbmFtZXMgaW4gdGhlIG1vZGVybiBmb3JtOyB0aGlzIHdvdWxkIGJlIG11Y2ggZWFzaWVyLlxuICAgICAgICAgICAgLy8gSG93ZXZlciwgdGhlcmUgYXJlIG1hbnkgYXBwbGljYXRpb25zIGFuZCBsaWJyYXJpZXMgdGhhdCByZWFkXG4gICAgICAgICAgICAvLyAnbmFtZScgdGFibGVzIGRpcmVjdGx5LCBhbmQgdGhlc2Ugd2lsbCB1c3VhbGx5IG9ubHkgcmVjb2duaXplXG4gICAgICAgICAgICAvLyB0aGUgYW5jaWVudCBmb3JtIChzaWxlbnRseSBza2lwcGluZyB0aGUgdW5yZWNvZ25pemVkIG5hbWVzKS5cbiAgICAgICAgICAgIHZhciBtYWNQbGF0Zm9ybSA9IDE7ICAvLyBNYWNpbnRvc2hcbiAgICAgICAgICAgIHZhciBtYWNMYW5ndWFnZSA9IG1hY0xhbmd1YWdlSWRzW2xhbmddO1xuICAgICAgICAgICAgdmFyIG1hY1NjcmlwdCA9IG1hY0xhbmd1YWdlVG9TY3JpcHRbbWFjTGFuZ3VhZ2VdO1xuICAgICAgICAgICAgdmFyIG1hY0VuY29kaW5nID0gZ2V0RW5jb2RpbmcobWFjUGxhdGZvcm0sIG1hY1NjcmlwdCwgbWFjTGFuZ3VhZ2UpO1xuICAgICAgICAgICAgdmFyIG1hY05hbWUgPSBlbmNvZGUuTUFDU1RSSU5HKHRleHQsIG1hY0VuY29kaW5nKTtcbiAgICAgICAgICAgIGlmIChtYWNOYW1lID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBtYWNQbGF0Zm9ybSA9IDA7ICAvLyBVbmljb2RlXG4gICAgICAgICAgICAgICAgbWFjTGFuZ3VhZ2UgPSBsdGFnLmluZGV4T2YobGFuZyk7XG4gICAgICAgICAgICAgICAgaWYgKG1hY0xhbmd1YWdlIDwgMCkge1xuICAgICAgICAgICAgICAgICAgICBtYWNMYW5ndWFnZSA9IGx0YWcubGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICBsdGFnLnB1c2gobGFuZyk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgbWFjU2NyaXB0ID0gNDsgIC8vIFVuaWNvZGUgMi4wIGFuZCBsYXRlclxuICAgICAgICAgICAgICAgIG1hY05hbWUgPSBlbmNvZGUuVVRGMTYodGV4dCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBtYWNOYW1lT2Zmc2V0ID0gYWRkU3RyaW5nVG9Qb29sKG1hY05hbWUsIHN0cmluZ1Bvb2wpO1xuICAgICAgICAgICAgbmFtZVJlY29yZHMucHVzaChtYWtlTmFtZVJlY29yZChtYWNQbGF0Zm9ybSwgbWFjU2NyaXB0LCBtYWNMYW5ndWFnZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmFtZUlELCBtYWNOYW1lLmxlbmd0aCwgbWFjTmFtZU9mZnNldCkpO1xuXG4gICAgICAgICAgICB2YXIgd2luTGFuZ3VhZ2UgPSB3aW5kb3dzTGFuZ3VhZ2VJZHNbbGFuZ107XG4gICAgICAgICAgICBpZiAod2luTGFuZ3VhZ2UgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHZhciB3aW5OYW1lID0gZW5jb2RlLlVURjE2KHRleHQpO1xuICAgICAgICAgICAgICAgIHZhciB3aW5OYW1lT2Zmc2V0ID0gYWRkU3RyaW5nVG9Qb29sKHdpbk5hbWUsIHN0cmluZ1Bvb2wpO1xuICAgICAgICAgICAgICAgIG5hbWVSZWNvcmRzLnB1c2gobWFrZU5hbWVSZWNvcmQoMywgMSwgd2luTGFuZ3VhZ2UsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lSUQsIHdpbk5hbWUubGVuZ3RoLCB3aW5OYW1lT2Zmc2V0KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBuYW1lUmVjb3Jkcy5zb3J0KGZ1bmN0aW9uKGEsIGIpIHtcbiAgICAgICAgcmV0dXJuICgoYS5wbGF0Zm9ybUlEIC0gYi5wbGF0Zm9ybUlEKSB8fFxuICAgICAgICAgICAgICAgIChhLmVuY29kaW5nSUQgLSBiLmVuY29kaW5nSUQpIHx8XG4gICAgICAgICAgICAgICAgKGEubGFuZ3VhZ2VJRCAtIGIubGFuZ3VhZ2VJRCkgfHxcbiAgICAgICAgICAgICAgICAoYS5uYW1lSUQgLSBiLm5hbWVJRCkpO1xuICAgIH0pO1xuXG4gICAgdmFyIHQgPSBuZXcgdGFibGUuVGFibGUoJ25hbWUnLCBbXG4gICAgICAgIHtuYW1lOiAnZm9ybWF0JywgdHlwZTogJ1VTSE9SVCcsIHZhbHVlOiAwfSxcbiAgICAgICAge25hbWU6ICdjb3VudCcsIHR5cGU6ICdVU0hPUlQnLCB2YWx1ZTogbmFtZVJlY29yZHMubGVuZ3RofSxcbiAgICAgICAge25hbWU6ICdzdHJpbmdPZmZzZXQnLCB0eXBlOiAnVVNIT1JUJywgdmFsdWU6IDYgKyBuYW1lUmVjb3Jkcy5sZW5ndGggKiAxMn1cbiAgICBdKTtcblxuICAgIGZvciAodmFyIHIgPSAwOyByIDwgbmFtZVJlY29yZHMubGVuZ3RoOyByKyspIHtcbiAgICAgICAgdC5maWVsZHMucHVzaCh7bmFtZTogJ3JlY29yZF8nICsgciwgdHlwZTogJ1JFQ09SRCcsIHZhbHVlOiBuYW1lUmVjb3Jkc1tyXX0pO1xuICAgIH1cblxuICAgIHQuZmllbGRzLnB1c2goe25hbWU6ICdzdHJpbmdzJywgdHlwZTogJ0xJVEVSQUwnLCB2YWx1ZTogc3RyaW5nUG9vbH0pO1xuICAgIHJldHVybiB0O1xufVxuXG52YXIgX25hbWUgPSB7IHBhcnNlOiBwYXJzZU5hbWVUYWJsZSwgbWFrZTogbWFrZU5hbWVUYWJsZSB9O1xuXG4vLyBUaGUgYE9TLzJgIHRhYmxlIGNvbnRhaW5zIG1ldHJpY3MgcmVxdWlyZWQgaW4gT3BlblR5cGUgZm9udHMuXG5cbnZhciB1bmljb2RlUmFuZ2VzID0gW1xuICAgIHtiZWdpbjogMHgwMDAwLCBlbmQ6IDB4MDA3Rn0sIC8vIEJhc2ljIExhdGluXG4gICAge2JlZ2luOiAweDAwODAsIGVuZDogMHgwMEZGfSwgLy8gTGF0aW4tMSBTdXBwbGVtZW50XG4gICAge2JlZ2luOiAweDAxMDAsIGVuZDogMHgwMTdGfSwgLy8gTGF0aW4gRXh0ZW5kZWQtQVxuICAgIHtiZWdpbjogMHgwMTgwLCBlbmQ6IDB4MDI0Rn0sIC8vIExhdGluIEV4dGVuZGVkLUJcbiAgICB7YmVnaW46IDB4MDI1MCwgZW5kOiAweDAyQUZ9LCAvLyBJUEEgRXh0ZW5zaW9uc1xuICAgIHtiZWdpbjogMHgwMkIwLCBlbmQ6IDB4MDJGRn0sIC8vIFNwYWNpbmcgTW9kaWZpZXIgTGV0dGVyc1xuICAgIHtiZWdpbjogMHgwMzAwLCBlbmQ6IDB4MDM2Rn0sIC8vIENvbWJpbmluZyBEaWFjcml0aWNhbCBNYXJrc1xuICAgIHtiZWdpbjogMHgwMzcwLCBlbmQ6IDB4MDNGRn0sIC8vIEdyZWVrIGFuZCBDb3B0aWNcbiAgICB7YmVnaW46IDB4MkM4MCwgZW5kOiAweDJDRkZ9LCAvLyBDb3B0aWNcbiAgICB7YmVnaW46IDB4MDQwMCwgZW5kOiAweDA0RkZ9LCAvLyBDeXJpbGxpY1xuICAgIHtiZWdpbjogMHgwNTMwLCBlbmQ6IDB4MDU4Rn0sIC8vIEFybWVuaWFuXG4gICAge2JlZ2luOiAweDA1OTAsIGVuZDogMHgwNUZGfSwgLy8gSGVicmV3XG4gICAge2JlZ2luOiAweEE1MDAsIGVuZDogMHhBNjNGfSwgLy8gVmFpXG4gICAge2JlZ2luOiAweDA2MDAsIGVuZDogMHgwNkZGfSwgLy8gQXJhYmljXG4gICAge2JlZ2luOiAweDA3QzAsIGVuZDogMHgwN0ZGfSwgLy8gTktvXG4gICAge2JlZ2luOiAweDA5MDAsIGVuZDogMHgwOTdGfSwgLy8gRGV2YW5hZ2FyaVxuICAgIHtiZWdpbjogMHgwOTgwLCBlbmQ6IDB4MDlGRn0sIC8vIEJlbmdhbGlcbiAgICB7YmVnaW46IDB4MEEwMCwgZW5kOiAweDBBN0Z9LCAvLyBHdXJtdWtoaVxuICAgIHtiZWdpbjogMHgwQTgwLCBlbmQ6IDB4MEFGRn0sIC8vIEd1amFyYXRpXG4gICAge2JlZ2luOiAweDBCMDAsIGVuZDogMHgwQjdGfSwgLy8gT3JpeWFcbiAgICB7YmVnaW46IDB4MEI4MCwgZW5kOiAweDBCRkZ9LCAvLyBUYW1pbFxuICAgIHtiZWdpbjogMHgwQzAwLCBlbmQ6IDB4MEM3Rn0sIC8vIFRlbHVndVxuICAgIHtiZWdpbjogMHgwQzgwLCBlbmQ6IDB4MENGRn0sIC8vIEthbm5hZGFcbiAgICB7YmVnaW46IDB4MEQwMCwgZW5kOiAweDBEN0Z9LCAvLyBNYWxheWFsYW1cbiAgICB7YmVnaW46IDB4MEUwMCwgZW5kOiAweDBFN0Z9LCAvLyBUaGFpXG4gICAge2JlZ2luOiAweDBFODAsIGVuZDogMHgwRUZGfSwgLy8gTGFvXG4gICAge2JlZ2luOiAweDEwQTAsIGVuZDogMHgxMEZGfSwgLy8gR2VvcmdpYW5cbiAgICB7YmVnaW46IDB4MUIwMCwgZW5kOiAweDFCN0Z9LCAvLyBCYWxpbmVzZVxuICAgIHtiZWdpbjogMHgxMTAwLCBlbmQ6IDB4MTFGRn0sIC8vIEhhbmd1bCBKYW1vXG4gICAge2JlZ2luOiAweDFFMDAsIGVuZDogMHgxRUZGfSwgLy8gTGF0aW4gRXh0ZW5kZWQgQWRkaXRpb25hbFxuICAgIHtiZWdpbjogMHgxRjAwLCBlbmQ6IDB4MUZGRn0sIC8vIEdyZWVrIEV4dGVuZGVkXG4gICAge2JlZ2luOiAweDIwMDAsIGVuZDogMHgyMDZGfSwgLy8gR2VuZXJhbCBQdW5jdHVhdGlvblxuICAgIHtiZWdpbjogMHgyMDcwLCBlbmQ6IDB4MjA5Rn0sIC8vIFN1cGVyc2NyaXB0cyBBbmQgU3Vic2NyaXB0c1xuICAgIHtiZWdpbjogMHgyMEEwLCBlbmQ6IDB4MjBDRn0sIC8vIEN1cnJlbmN5IFN5bWJvbFxuICAgIHtiZWdpbjogMHgyMEQwLCBlbmQ6IDB4MjBGRn0sIC8vIENvbWJpbmluZyBEaWFjcml0aWNhbCBNYXJrcyBGb3IgU3ltYm9sc1xuICAgIHtiZWdpbjogMHgyMTAwLCBlbmQ6IDB4MjE0Rn0sIC8vIExldHRlcmxpa2UgU3ltYm9sc1xuICAgIHtiZWdpbjogMHgyMTUwLCBlbmQ6IDB4MjE4Rn0sIC8vIE51bWJlciBGb3Jtc1xuICAgIHtiZWdpbjogMHgyMTkwLCBlbmQ6IDB4MjFGRn0sIC8vIEFycm93c1xuICAgIHtiZWdpbjogMHgyMjAwLCBlbmQ6IDB4MjJGRn0sIC8vIE1hdGhlbWF0aWNhbCBPcGVyYXRvcnNcbiAgICB7YmVnaW46IDB4MjMwMCwgZW5kOiAweDIzRkZ9LCAvLyBNaXNjZWxsYW5lb3VzIFRlY2huaWNhbFxuICAgIHtiZWdpbjogMHgyNDAwLCBlbmQ6IDB4MjQzRn0sIC8vIENvbnRyb2wgUGljdHVyZXNcbiAgICB7YmVnaW46IDB4MjQ0MCwgZW5kOiAweDI0NUZ9LCAvLyBPcHRpY2FsIENoYXJhY3RlciBSZWNvZ25pdGlvblxuICAgIHtiZWdpbjogMHgyNDYwLCBlbmQ6IDB4MjRGRn0sIC8vIEVuY2xvc2VkIEFscGhhbnVtZXJpY3NcbiAgICB7YmVnaW46IDB4MjUwMCwgZW5kOiAweDI1N0Z9LCAvLyBCb3ggRHJhd2luZ1xuICAgIHtiZWdpbjogMHgyNTgwLCBlbmQ6IDB4MjU5Rn0sIC8vIEJsb2NrIEVsZW1lbnRzXG4gICAge2JlZ2luOiAweDI1QTAsIGVuZDogMHgyNUZGfSwgLy8gR2VvbWV0cmljIFNoYXBlc1xuICAgIHtiZWdpbjogMHgyNjAwLCBlbmQ6IDB4MjZGRn0sIC8vIE1pc2NlbGxhbmVvdXMgU3ltYm9sc1xuICAgIHtiZWdpbjogMHgyNzAwLCBlbmQ6IDB4MjdCRn0sIC8vIERpbmdiYXRzXG4gICAge2JlZ2luOiAweDMwMDAsIGVuZDogMHgzMDNGfSwgLy8gQ0pLIFN5bWJvbHMgQW5kIFB1bmN0dWF0aW9uXG4gICAge2JlZ2luOiAweDMwNDAsIGVuZDogMHgzMDlGfSwgLy8gSGlyYWdhbmFcbiAgICB7YmVnaW46IDB4MzBBMCwgZW5kOiAweDMwRkZ9LCAvLyBLYXRha2FuYVxuICAgIHtiZWdpbjogMHgzMTAwLCBlbmQ6IDB4MzEyRn0sIC8vIEJvcG9tb2ZvXG4gICAge2JlZ2luOiAweDMxMzAsIGVuZDogMHgzMThGfSwgLy8gSGFuZ3VsIENvbXBhdGliaWxpdHkgSmFtb1xuICAgIHtiZWdpbjogMHhBODQwLCBlbmQ6IDB4QTg3Rn0sIC8vIFBoYWdzLXBhXG4gICAge2JlZ2luOiAweDMyMDAsIGVuZDogMHgzMkZGfSwgLy8gRW5jbG9zZWQgQ0pLIExldHRlcnMgQW5kIE1vbnRoc1xuICAgIHtiZWdpbjogMHgzMzAwLCBlbmQ6IDB4MzNGRn0sIC8vIENKSyBDb21wYXRpYmlsaXR5XG4gICAge2JlZ2luOiAweEFDMDAsIGVuZDogMHhEN0FGfSwgLy8gSGFuZ3VsIFN5bGxhYmxlc1xuICAgIHtiZWdpbjogMHhEODAwLCBlbmQ6IDB4REZGRn0sIC8vIE5vbi1QbGFuZSAwICpcbiAgICB7YmVnaW46IDB4MTA5MDAsIGVuZDogMHgxMDkxRn0sIC8vIFBob2VuaWNpYVxuICAgIHtiZWdpbjogMHg0RTAwLCBlbmQ6IDB4OUZGRn0sIC8vIENKSyBVbmlmaWVkIElkZW9ncmFwaHNcbiAgICB7YmVnaW46IDB4RTAwMCwgZW5kOiAweEY4RkZ9LCAvLyBQcml2YXRlIFVzZSBBcmVhIChwbGFuZSAwKVxuICAgIHtiZWdpbjogMHgzMUMwLCBlbmQ6IDB4MzFFRn0sIC8vIENKSyBTdHJva2VzXG4gICAge2JlZ2luOiAweEZCMDAsIGVuZDogMHhGQjRGfSwgLy8gQWxwaGFiZXRpYyBQcmVzZW50YXRpb24gRm9ybXNcbiAgICB7YmVnaW46IDB4RkI1MCwgZW5kOiAweEZERkZ9LCAvLyBBcmFiaWMgUHJlc2VudGF0aW9uIEZvcm1zLUFcbiAgICB7YmVnaW46IDB4RkUyMCwgZW5kOiAweEZFMkZ9LCAvLyBDb21iaW5pbmcgSGFsZiBNYXJrc1xuICAgIHtiZWdpbjogMHhGRTEwLCBlbmQ6IDB4RkUxRn0sIC8vIFZlcnRpY2FsIEZvcm1zXG4gICAge2JlZ2luOiAweEZFNTAsIGVuZDogMHhGRTZGfSwgLy8gU21hbGwgRm9ybSBWYXJpYW50c1xuICAgIHtiZWdpbjogMHhGRTcwLCBlbmQ6IDB4RkVGRn0sIC8vIEFyYWJpYyBQcmVzZW50YXRpb24gRm9ybXMtQlxuICAgIHtiZWdpbjogMHhGRjAwLCBlbmQ6IDB4RkZFRn0sIC8vIEhhbGZ3aWR0aCBBbmQgRnVsbHdpZHRoIEZvcm1zXG4gICAge2JlZ2luOiAweEZGRjAsIGVuZDogMHhGRkZGfSwgLy8gU3BlY2lhbHNcbiAgICB7YmVnaW46IDB4MEYwMCwgZW5kOiAweDBGRkZ9LCAvLyBUaWJldGFuXG4gICAge2JlZ2luOiAweDA3MDAsIGVuZDogMHgwNzRGfSwgLy8gU3lyaWFjXG4gICAge2JlZ2luOiAweDA3ODAsIGVuZDogMHgwN0JGfSwgLy8gVGhhYW5hXG4gICAge2JlZ2luOiAweDBEODAsIGVuZDogMHgwREZGfSwgLy8gU2luaGFsYVxuICAgIHtiZWdpbjogMHgxMDAwLCBlbmQ6IDB4MTA5Rn0sIC8vIE15YW5tYXJcbiAgICB7YmVnaW46IDB4MTIwMCwgZW5kOiAweDEzN0Z9LCAvLyBFdGhpb3BpY1xuICAgIHtiZWdpbjogMHgxM0EwLCBlbmQ6IDB4MTNGRn0sIC8vIENoZXJva2VlXG4gICAge2JlZ2luOiAweDE0MDAsIGVuZDogMHgxNjdGfSwgLy8gVW5pZmllZCBDYW5hZGlhbiBBYm9yaWdpbmFsIFN5bGxhYmljc1xuICAgIHtiZWdpbjogMHgxNjgwLCBlbmQ6IDB4MTY5Rn0sIC8vIE9naGFtXG4gICAge2JlZ2luOiAweDE2QTAsIGVuZDogMHgxNkZGfSwgLy8gUnVuaWNcbiAgICB7YmVnaW46IDB4MTc4MCwgZW5kOiAweDE3RkZ9LCAvLyBLaG1lclxuICAgIHtiZWdpbjogMHgxODAwLCBlbmQ6IDB4MThBRn0sIC8vIE1vbmdvbGlhblxuICAgIHtiZWdpbjogMHgyODAwLCBlbmQ6IDB4MjhGRn0sIC8vIEJyYWlsbGUgUGF0dGVybnNcbiAgICB7YmVnaW46IDB4QTAwMCwgZW5kOiAweEE0OEZ9LCAvLyBZaSBTeWxsYWJsZXNcbiAgICB7YmVnaW46IDB4MTcwMCwgZW5kOiAweDE3MUZ9LCAvLyBUYWdhbG9nXG4gICAge2JlZ2luOiAweDEwMzAwLCBlbmQ6IDB4MTAzMkZ9LCAvLyBPbGQgSXRhbGljXG4gICAge2JlZ2luOiAweDEwMzMwLCBlbmQ6IDB4MTAzNEZ9LCAvLyBHb3RoaWNcbiAgICB7YmVnaW46IDB4MTA0MDAsIGVuZDogMHgxMDQ0Rn0sIC8vIERlc2VyZXRcbiAgICB7YmVnaW46IDB4MUQwMDAsIGVuZDogMHgxRDBGRn0sIC8vIEJ5emFudGluZSBNdXNpY2FsIFN5bWJvbHNcbiAgICB7YmVnaW46IDB4MUQ0MDAsIGVuZDogMHgxRDdGRn0sIC8vIE1hdGhlbWF0aWNhbCBBbHBoYW51bWVyaWMgU3ltYm9sc1xuICAgIHtiZWdpbjogMHhGRjAwMCwgZW5kOiAweEZGRkZEfSwgLy8gUHJpdmF0ZSBVc2UgKHBsYW5lIDE1KVxuICAgIHtiZWdpbjogMHhGRTAwLCBlbmQ6IDB4RkUwRn0sIC8vIFZhcmlhdGlvbiBTZWxlY3RvcnNcbiAgICB7YmVnaW46IDB4RTAwMDAsIGVuZDogMHhFMDA3Rn0sIC8vIFRhZ3NcbiAgICB7YmVnaW46IDB4MTkwMCwgZW5kOiAweDE5NEZ9LCAvLyBMaW1idVxuICAgIHtiZWdpbjogMHgxOTUwLCBlbmQ6IDB4MTk3Rn0sIC8vIFRhaSBMZVxuICAgIHtiZWdpbjogMHgxOTgwLCBlbmQ6IDB4MTlERn0sIC8vIE5ldyBUYWkgTHVlXG4gICAge2JlZ2luOiAweDFBMDAsIGVuZDogMHgxQTFGfSwgLy8gQnVnaW5lc2VcbiAgICB7YmVnaW46IDB4MkMwMCwgZW5kOiAweDJDNUZ9LCAvLyBHbGFnb2xpdGljXG4gICAge2JlZ2luOiAweDJEMzAsIGVuZDogMHgyRDdGfSwgLy8gVGlmaW5hZ2hcbiAgICB7YmVnaW46IDB4NERDMCwgZW5kOiAweDRERkZ9LCAvLyBZaWppbmcgSGV4YWdyYW0gU3ltYm9sc1xuICAgIHtiZWdpbjogMHhBODAwLCBlbmQ6IDB4QTgyRn0sIC8vIFN5bG90aSBOYWdyaVxuICAgIHtiZWdpbjogMHgxMDAwMCwgZW5kOiAweDEwMDdGfSwgLy8gTGluZWFyIEIgU3lsbGFiYXJ5XG4gICAge2JlZ2luOiAweDEwMTQwLCBlbmQ6IDB4MTAxOEZ9LCAvLyBBbmNpZW50IEdyZWVrIE51bWJlcnNcbiAgICB7YmVnaW46IDB4MTAzODAsIGVuZDogMHgxMDM5Rn0sIC8vIFVnYXJpdGljXG4gICAge2JlZ2luOiAweDEwM0EwLCBlbmQ6IDB4MTAzREZ9LCAvLyBPbGQgUGVyc2lhblxuICAgIHtiZWdpbjogMHgxMDQ1MCwgZW5kOiAweDEwNDdGfSwgLy8gU2hhdmlhblxuICAgIHtiZWdpbjogMHgxMDQ4MCwgZW5kOiAweDEwNEFGfSwgLy8gT3NtYW55YVxuICAgIHtiZWdpbjogMHgxMDgwMCwgZW5kOiAweDEwODNGfSwgLy8gQ3lwcmlvdCBTeWxsYWJhcnlcbiAgICB7YmVnaW46IDB4MTBBMDAsIGVuZDogMHgxMEE1Rn0sIC8vIEtoYXJvc2h0aGlcbiAgICB7YmVnaW46IDB4MUQzMDAsIGVuZDogMHgxRDM1Rn0sIC8vIFRhaSBYdWFuIEppbmcgU3ltYm9sc1xuICAgIHtiZWdpbjogMHgxMjAwMCwgZW5kOiAweDEyM0ZGfSwgLy8gQ3VuZWlmb3JtXG4gICAge2JlZ2luOiAweDFEMzYwLCBlbmQ6IDB4MUQzN0Z9LCAvLyBDb3VudGluZyBSb2QgTnVtZXJhbHNcbiAgICB7YmVnaW46IDB4MUI4MCwgZW5kOiAweDFCQkZ9LCAvLyBTdW5kYW5lc2VcbiAgICB7YmVnaW46IDB4MUMwMCwgZW5kOiAweDFDNEZ9LCAvLyBMZXBjaGFcbiAgICB7YmVnaW46IDB4MUM1MCwgZW5kOiAweDFDN0Z9LCAvLyBPbCBDaGlraVxuICAgIHtiZWdpbjogMHhBODgwLCBlbmQ6IDB4QThERn0sIC8vIFNhdXJhc2h0cmFcbiAgICB7YmVnaW46IDB4QTkwMCwgZW5kOiAweEE5MkZ9LCAvLyBLYXlhaCBMaVxuICAgIHtiZWdpbjogMHhBOTMwLCBlbmQ6IDB4QTk1Rn0sIC8vIFJlamFuZ1xuICAgIHtiZWdpbjogMHhBQTAwLCBlbmQ6IDB4QUE1Rn0sIC8vIENoYW1cbiAgICB7YmVnaW46IDB4MTAxOTAsIGVuZDogMHgxMDFDRn0sIC8vIEFuY2llbnQgU3ltYm9sc1xuICAgIHtiZWdpbjogMHgxMDFEMCwgZW5kOiAweDEwMUZGfSwgLy8gUGhhaXN0b3MgRGlzY1xuICAgIHtiZWdpbjogMHgxMDJBMCwgZW5kOiAweDEwMkRGfSwgLy8gQ2FyaWFuXG4gICAge2JlZ2luOiAweDFGMDMwLCBlbmQ6IDB4MUYwOUZ9ICAvLyBEb21pbm8gVGlsZXNcbl07XG5cbmZ1bmN0aW9uIGdldFVuaWNvZGVSYW5nZSh1bmljb2RlKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB1bmljb2RlUmFuZ2VzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgIHZhciByYW5nZSA9IHVuaWNvZGVSYW5nZXNbaV07XG4gICAgICAgIGlmICh1bmljb2RlID49IHJhbmdlLmJlZ2luICYmIHVuaWNvZGUgPCByYW5nZS5lbmQpIHtcbiAgICAgICAgICAgIHJldHVybiBpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIC0xO1xufVxuXG4vLyBQYXJzZSB0aGUgT1MvMiBhbmQgV2luZG93cyBtZXRyaWNzIGBPUy8yYCB0YWJsZVxuZnVuY3Rpb24gcGFyc2VPUzJUYWJsZShkYXRhLCBzdGFydCkge1xuICAgIHZhciBvczIgPSB7fTtcbiAgICB2YXIgcCA9IG5ldyBwYXJzZS5QYXJzZXIoZGF0YSwgc3RhcnQpO1xuICAgIG9zMi52ZXJzaW9uID0gcC5wYXJzZVVTaG9ydCgpO1xuICAgIG9zMi54QXZnQ2hhcldpZHRoID0gcC5wYXJzZVNob3J0KCk7XG4gICAgb3MyLnVzV2VpZ2h0Q2xhc3MgPSBwLnBhcnNlVVNob3J0KCk7XG4gICAgb3MyLnVzV2lkdGhDbGFzcyA9IHAucGFyc2VVU2hvcnQoKTtcbiAgICBvczIuZnNUeXBlID0gcC5wYXJzZVVTaG9ydCgpO1xuICAgIG9zMi55U3Vic2NyaXB0WFNpemUgPSBwLnBhcnNlU2hvcnQoKTtcbiAgICBvczIueVN1YnNjcmlwdFlTaXplID0gcC5wYXJzZVNob3J0KCk7XG4gICAgb3MyLnlTdWJzY3JpcHRYT2Zmc2V0ID0gcC5wYXJzZVNob3J0KCk7XG4gICAgb3MyLnlTdWJzY3JpcHRZT2Zmc2V0ID0gcC5wYXJzZVNob3J0KCk7XG4gICAgb3MyLnlTdXBlcnNjcmlwdFhTaXplID0gcC5wYXJzZVNob3J0KCk7XG4gICAgb3MyLnlTdXBlcnNjcmlwdFlTaXplID0gcC5wYXJzZVNob3J0KCk7XG4gICAgb3MyLnlTdXBlcnNjcmlwdFhPZmZzZXQgPSBwLnBhcnNlU2hvcnQoKTtcbiAgICBvczIueVN1cGVyc2NyaXB0WU9mZnNldCA9IHAucGFyc2VTaG9ydCgpO1xuICAgIG9zMi55U3RyaWtlb3V0U2l6ZSA9IHAucGFyc2VTaG9ydCgpO1xuICAgIG9zMi55U3RyaWtlb3V0UG9zaXRpb24gPSBwLnBhcnNlU2hvcnQoKTtcbiAgICBvczIuc0ZhbWlseUNsYXNzID0gcC5wYXJzZVNob3J0KCk7XG4gICAgb3MyLnBhbm9zZSA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgMTA7IGkrKykge1xuICAgICAgICBvczIucGFub3NlW2ldID0gcC5wYXJzZUJ5dGUoKTtcbiAgICB9XG5cbiAgICBvczIudWxVbmljb2RlUmFuZ2UxID0gcC5wYXJzZVVMb25nKCk7XG4gICAgb3MyLnVsVW5pY29kZVJhbmdlMiA9IHAucGFyc2VVTG9uZygpO1xuICAgIG9zMi51bFVuaWNvZGVSYW5nZTMgPSBwLnBhcnNlVUxvbmcoKTtcbiAgICBvczIudWxVbmljb2RlUmFuZ2U0ID0gcC5wYXJzZVVMb25nKCk7XG4gICAgb3MyLmFjaFZlbmRJRCA9IFN0cmluZy5mcm9tQ2hhckNvZGUocC5wYXJzZUJ5dGUoKSwgcC5wYXJzZUJ5dGUoKSwgcC5wYXJzZUJ5dGUoKSwgcC5wYXJzZUJ5dGUoKSk7XG4gICAgb3MyLmZzU2VsZWN0aW9uID0gcC5wYXJzZVVTaG9ydCgpO1xuICAgIG9zMi51c0ZpcnN0Q2hhckluZGV4ID0gcC5wYXJzZVVTaG9ydCgpO1xuICAgIG9zMi51c0xhc3RDaGFySW5kZXggPSBwLnBhcnNlVVNob3J0KCk7XG4gICAgb3MyLnNUeXBvQXNjZW5kZXIgPSBwLnBhcnNlU2hvcnQoKTtcbiAgICBvczIuc1R5cG9EZXNjZW5kZXIgPSBwLnBhcnNlU2hvcnQoKTtcbiAgICBvczIuc1R5cG9MaW5lR2FwID0gcC5wYXJzZVNob3J0KCk7XG4gICAgb3MyLnVzV2luQXNjZW50ID0gcC5wYXJzZVVTaG9ydCgpO1xuICAgIG9zMi51c1dpbkRlc2NlbnQgPSBwLnBhcnNlVVNob3J0KCk7XG4gICAgaWYgKG9zMi52ZXJzaW9uID49IDEpIHtcbiAgICAgICAgb3MyLnVsQ29kZVBhZ2VSYW5nZTEgPSBwLnBhcnNlVUxvbmcoKTtcbiAgICAgICAgb3MyLnVsQ29kZVBhZ2VSYW5nZTIgPSBwLnBhcnNlVUxvbmcoKTtcbiAgICB9XG5cbiAgICBpZiAob3MyLnZlcnNpb24gPj0gMikge1xuICAgICAgICBvczIuc3hIZWlnaHQgPSBwLnBhcnNlU2hvcnQoKTtcbiAgICAgICAgb3MyLnNDYXBIZWlnaHQgPSBwLnBhcnNlU2hvcnQoKTtcbiAgICAgICAgb3MyLnVzRGVmYXVsdENoYXIgPSBwLnBhcnNlVVNob3J0KCk7XG4gICAgICAgIG9zMi51c0JyZWFrQ2hhciA9IHAucGFyc2VVU2hvcnQoKTtcbiAgICAgICAgb3MyLnVzTWF4Q29udGVudCA9IHAucGFyc2VVU2hvcnQoKTtcbiAgICB9XG5cbiAgICByZXR1cm4gb3MyO1xufVxuXG5mdW5jdGlvbiBtYWtlT1MyVGFibGUob3B0aW9ucykge1xuICAgIHJldHVybiBuZXcgdGFibGUuVGFibGUoJ09TLzInLCBbXG4gICAgICAgIHtuYW1lOiAndmVyc2lvbicsIHR5cGU6ICdVU0hPUlQnLCB2YWx1ZTogMHgwMDAzfSxcbiAgICAgICAge25hbWU6ICd4QXZnQ2hhcldpZHRoJywgdHlwZTogJ1NIT1JUJywgdmFsdWU6IDB9LFxuICAgICAgICB7bmFtZTogJ3VzV2VpZ2h0Q2xhc3MnLCB0eXBlOiAnVVNIT1JUJywgdmFsdWU6IDB9LFxuICAgICAgICB7bmFtZTogJ3VzV2lkdGhDbGFzcycsIHR5cGU6ICdVU0hPUlQnLCB2YWx1ZTogMH0sXG4gICAgICAgIHtuYW1lOiAnZnNUeXBlJywgdHlwZTogJ1VTSE9SVCcsIHZhbHVlOiAwfSxcbiAgICAgICAge25hbWU6ICd5U3Vic2NyaXB0WFNpemUnLCB0eXBlOiAnU0hPUlQnLCB2YWx1ZTogNjUwfSxcbiAgICAgICAge25hbWU6ICd5U3Vic2NyaXB0WVNpemUnLCB0eXBlOiAnU0hPUlQnLCB2YWx1ZTogNjk5fSxcbiAgICAgICAge25hbWU6ICd5U3Vic2NyaXB0WE9mZnNldCcsIHR5cGU6ICdTSE9SVCcsIHZhbHVlOiAwfSxcbiAgICAgICAge25hbWU6ICd5U3Vic2NyaXB0WU9mZnNldCcsIHR5cGU6ICdTSE9SVCcsIHZhbHVlOiAxNDB9LFxuICAgICAgICB7bmFtZTogJ3lTdXBlcnNjcmlwdFhTaXplJywgdHlwZTogJ1NIT1JUJywgdmFsdWU6IDY1MH0sXG4gICAgICAgIHtuYW1lOiAneVN1cGVyc2NyaXB0WVNpemUnLCB0eXBlOiAnU0hPUlQnLCB2YWx1ZTogNjk5fSxcbiAgICAgICAge25hbWU6ICd5U3VwZXJzY3JpcHRYT2Zmc2V0JywgdHlwZTogJ1NIT1JUJywgdmFsdWU6IDB9LFxuICAgICAgICB7bmFtZTogJ3lTdXBlcnNjcmlwdFlPZmZzZXQnLCB0eXBlOiAnU0hPUlQnLCB2YWx1ZTogNDc5fSxcbiAgICAgICAge25hbWU6ICd5U3RyaWtlb3V0U2l6ZScsIHR5cGU6ICdTSE9SVCcsIHZhbHVlOiA0OX0sXG4gICAgICAgIHtuYW1lOiAneVN0cmlrZW91dFBvc2l0aW9uJywgdHlwZTogJ1NIT1JUJywgdmFsdWU6IDI1OH0sXG4gICAgICAgIHtuYW1lOiAnc0ZhbWlseUNsYXNzJywgdHlwZTogJ1NIT1JUJywgdmFsdWU6IDB9LFxuICAgICAgICB7bmFtZTogJ2JGYW1pbHlUeXBlJywgdHlwZTogJ0JZVEUnLCB2YWx1ZTogMH0sXG4gICAgICAgIHtuYW1lOiAnYlNlcmlmU3R5bGUnLCB0eXBlOiAnQllURScsIHZhbHVlOiAwfSxcbiAgICAgICAge25hbWU6ICdiV2VpZ2h0JywgdHlwZTogJ0JZVEUnLCB2YWx1ZTogMH0sXG4gICAgICAgIHtuYW1lOiAnYlByb3BvcnRpb24nLCB0eXBlOiAnQllURScsIHZhbHVlOiAwfSxcbiAgICAgICAge25hbWU6ICdiQ29udHJhc3QnLCB0eXBlOiAnQllURScsIHZhbHVlOiAwfSxcbiAgICAgICAge25hbWU6ICdiU3Ryb2tlVmFyaWF0aW9uJywgdHlwZTogJ0JZVEUnLCB2YWx1ZTogMH0sXG4gICAgICAgIHtuYW1lOiAnYkFybVN0eWxlJywgdHlwZTogJ0JZVEUnLCB2YWx1ZTogMH0sXG4gICAgICAgIHtuYW1lOiAnYkxldHRlcmZvcm0nLCB0eXBlOiAnQllURScsIHZhbHVlOiAwfSxcbiAgICAgICAge25hbWU6ICdiTWlkbGluZScsIHR5cGU6ICdCWVRFJywgdmFsdWU6IDB9LFxuICAgICAgICB7bmFtZTogJ2JYSGVpZ2h0JywgdHlwZTogJ0JZVEUnLCB2YWx1ZTogMH0sXG4gICAgICAgIHtuYW1lOiAndWxVbmljb2RlUmFuZ2UxJywgdHlwZTogJ1VMT05HJywgdmFsdWU6IDB9LFxuICAgICAgICB7bmFtZTogJ3VsVW5pY29kZVJhbmdlMicsIHR5cGU6ICdVTE9ORycsIHZhbHVlOiAwfSxcbiAgICAgICAge25hbWU6ICd1bFVuaWNvZGVSYW5nZTMnLCB0eXBlOiAnVUxPTkcnLCB2YWx1ZTogMH0sXG4gICAgICAgIHtuYW1lOiAndWxVbmljb2RlUmFuZ2U0JywgdHlwZTogJ1VMT05HJywgdmFsdWU6IDB9LFxuICAgICAgICB7bmFtZTogJ2FjaFZlbmRJRCcsIHR5cGU6ICdDSEFSQVJSQVknLCB2YWx1ZTogJ1hYWFgnfSxcbiAgICAgICAge25hbWU6ICdmc1NlbGVjdGlvbicsIHR5cGU6ICdVU0hPUlQnLCB2YWx1ZTogMH0sXG4gICAgICAgIHtuYW1lOiAndXNGaXJzdENoYXJJbmRleCcsIHR5cGU6ICdVU0hPUlQnLCB2YWx1ZTogMH0sXG4gICAgICAgIHtuYW1lOiAndXNMYXN0Q2hhckluZGV4JywgdHlwZTogJ1VTSE9SVCcsIHZhbHVlOiAwfSxcbiAgICAgICAge25hbWU6ICdzVHlwb0FzY2VuZGVyJywgdHlwZTogJ1NIT1JUJywgdmFsdWU6IDB9LFxuICAgICAgICB7bmFtZTogJ3NUeXBvRGVzY2VuZGVyJywgdHlwZTogJ1NIT1JUJywgdmFsdWU6IDB9LFxuICAgICAgICB7bmFtZTogJ3NUeXBvTGluZUdhcCcsIHR5cGU6ICdTSE9SVCcsIHZhbHVlOiAwfSxcbiAgICAgICAge25hbWU6ICd1c1dpbkFzY2VudCcsIHR5cGU6ICdVU0hPUlQnLCB2YWx1ZTogMH0sXG4gICAgICAgIHtuYW1lOiAndXNXaW5EZXNjZW50JywgdHlwZTogJ1VTSE9SVCcsIHZhbHVlOiAwfSxcbiAgICAgICAge25hbWU6ICd1bENvZGVQYWdlUmFuZ2UxJywgdHlwZTogJ1VMT05HJywgdmFsdWU6IDB9LFxuICAgICAgICB7bmFtZTogJ3VsQ29kZVBhZ2VSYW5nZTInLCB0eXBlOiAnVUxPTkcnLCB2YWx1ZTogMH0sXG4gICAgICAgIHtuYW1lOiAnc3hIZWlnaHQnLCB0eXBlOiAnU0hPUlQnLCB2YWx1ZTogMH0sXG4gICAgICAgIHtuYW1lOiAnc0NhcEhlaWdodCcsIHR5cGU6ICdTSE9SVCcsIHZhbHVlOiAwfSxcbiAgICAgICAge25hbWU6ICd1c0RlZmF1bHRDaGFyJywgdHlwZTogJ1VTSE9SVCcsIHZhbHVlOiAwfSxcbiAgICAgICAge25hbWU6ICd1c0JyZWFrQ2hhcicsIHR5cGU6ICdVU0hPUlQnLCB2YWx1ZTogMH0sXG4gICAgICAgIHtuYW1lOiAndXNNYXhDb250ZXh0JywgdHlwZTogJ1VTSE9SVCcsIHZhbHVlOiAwfVxuICAgIF0sIG9wdGlvbnMpO1xufVxuXG52YXIgb3MyID0geyBwYXJzZTogcGFyc2VPUzJUYWJsZSwgbWFrZTogbWFrZU9TMlRhYmxlLCB1bmljb2RlUmFuZ2VzOiB1bmljb2RlUmFuZ2VzLCBnZXRVbmljb2RlUmFuZ2U6IGdldFVuaWNvZGVSYW5nZSB9O1xuXG4vLyBUaGUgYHBvc3RgIHRhYmxlIHN0b3JlcyBhZGRpdGlvbmFsIFBvc3RTY3JpcHQgaW5mb3JtYXRpb24sIHN1Y2ggYXMgZ2x5cGggbmFtZXMuXG5cbi8vIFBhcnNlIHRoZSBQb3N0U2NyaXB0IGBwb3N0YCB0YWJsZVxuZnVuY3Rpb24gcGFyc2VQb3N0VGFibGUoZGF0YSwgc3RhcnQpIHtcbiAgICB2YXIgcG9zdCA9IHt9O1xuICAgIHZhciBwID0gbmV3IHBhcnNlLlBhcnNlcihkYXRhLCBzdGFydCk7XG4gICAgcG9zdC52ZXJzaW9uID0gcC5wYXJzZVZlcnNpb24oKTtcbiAgICBwb3N0Lml0YWxpY0FuZ2xlID0gcC5wYXJzZUZpeGVkKCk7XG4gICAgcG9zdC51bmRlcmxpbmVQb3NpdGlvbiA9IHAucGFyc2VTaG9ydCgpO1xuICAgIHBvc3QudW5kZXJsaW5lVGhpY2tuZXNzID0gcC5wYXJzZVNob3J0KCk7XG4gICAgcG9zdC5pc0ZpeGVkUGl0Y2ggPSBwLnBhcnNlVUxvbmcoKTtcbiAgICBwb3N0Lm1pbk1lbVR5cGU0MiA9IHAucGFyc2VVTG9uZygpO1xuICAgIHBvc3QubWF4TWVtVHlwZTQyID0gcC5wYXJzZVVMb25nKCk7XG4gICAgcG9zdC5taW5NZW1UeXBlMSA9IHAucGFyc2VVTG9uZygpO1xuICAgIHBvc3QubWF4TWVtVHlwZTEgPSBwLnBhcnNlVUxvbmcoKTtcbiAgICBzd2l0Y2ggKHBvc3QudmVyc2lvbikge1xuICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICBwb3N0Lm5hbWVzID0gc3RhbmRhcmROYW1lcy5zbGljZSgpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgIHBvc3QubnVtYmVyT2ZHbHlwaHMgPSBwLnBhcnNlVVNob3J0KCk7XG4gICAgICAgICAgICBwb3N0LmdseXBoTmFtZUluZGV4ID0gbmV3IEFycmF5KHBvc3QubnVtYmVyT2ZHbHlwaHMpO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwb3N0Lm51bWJlck9mR2x5cGhzOyBpKyspIHtcbiAgICAgICAgICAgICAgICBwb3N0LmdseXBoTmFtZUluZGV4W2ldID0gcC5wYXJzZVVTaG9ydCgpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBwb3N0Lm5hbWVzID0gW107XG4gICAgICAgICAgICBmb3IgKHZhciBpJDEgPSAwOyBpJDEgPCBwb3N0Lm51bWJlck9mR2x5cGhzOyBpJDErKykge1xuICAgICAgICAgICAgICAgIGlmIChwb3N0LmdseXBoTmFtZUluZGV4W2kkMV0gPj0gc3RhbmRhcmROYW1lcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG5hbWVMZW5ndGggPSBwLnBhcnNlQ2hhcigpO1xuICAgICAgICAgICAgICAgICAgICBwb3N0Lm5hbWVzLnB1c2gocC5wYXJzZVN0cmluZyhuYW1lTGVuZ3RoKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAyLjU6XG4gICAgICAgICAgICBwb3N0Lm51bWJlck9mR2x5cGhzID0gcC5wYXJzZVVTaG9ydCgpO1xuICAgICAgICAgICAgcG9zdC5vZmZzZXQgPSBuZXcgQXJyYXkocG9zdC5udW1iZXJPZkdseXBocyk7XG4gICAgICAgICAgICBmb3IgKHZhciBpJDIgPSAwOyBpJDIgPCBwb3N0Lm51bWJlck9mR2x5cGhzOyBpJDIrKykge1xuICAgICAgICAgICAgICAgIHBvc3Qub2Zmc2V0W2kkMl0gPSBwLnBhcnNlQ2hhcigpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBicmVhaztcbiAgICB9XG4gICAgcmV0dXJuIHBvc3Q7XG59XG5cbmZ1bmN0aW9uIG1ha2VQb3N0VGFibGUoKSB7XG4gICAgcmV0dXJuIG5ldyB0YWJsZS5UYWJsZSgncG9zdCcsIFtcbiAgICAgICAge25hbWU6ICd2ZXJzaW9uJywgdHlwZTogJ0ZJWEVEJywgdmFsdWU6IDB4MDAwMzAwMDB9LFxuICAgICAgICB7bmFtZTogJ2l0YWxpY0FuZ2xlJywgdHlwZTogJ0ZJWEVEJywgdmFsdWU6IDB9LFxuICAgICAgICB7bmFtZTogJ3VuZGVybGluZVBvc2l0aW9uJywgdHlwZTogJ0ZXT1JEJywgdmFsdWU6IDB9LFxuICAgICAgICB7bmFtZTogJ3VuZGVybGluZVRoaWNrbmVzcycsIHR5cGU6ICdGV09SRCcsIHZhbHVlOiAwfSxcbiAgICAgICAge25hbWU6ICdpc0ZpeGVkUGl0Y2gnLCB0eXBlOiAnVUxPTkcnLCB2YWx1ZTogMH0sXG4gICAgICAgIHtuYW1lOiAnbWluTWVtVHlwZTQyJywgdHlwZTogJ1VMT05HJywgdmFsdWU6IDB9LFxuICAgICAgICB7bmFtZTogJ21heE1lbVR5cGU0MicsIHR5cGU6ICdVTE9ORycsIHZhbHVlOiAwfSxcbiAgICAgICAge25hbWU6ICdtaW5NZW1UeXBlMScsIHR5cGU6ICdVTE9ORycsIHZhbHVlOiAwfSxcbiAgICAgICAge25hbWU6ICdtYXhNZW1UeXBlMScsIHR5cGU6ICdVTE9ORycsIHZhbHVlOiAwfVxuICAgIF0pO1xufVxuXG52YXIgcG9zdCA9IHsgcGFyc2U6IHBhcnNlUG9zdFRhYmxlLCBtYWtlOiBtYWtlUG9zdFRhYmxlIH07XG5cbi8vIFRoZSBgR1NVQmAgdGFibGUgY29udGFpbnMgbGlnYXR1cmVzLCBhbW9uZyBvdGhlciB0aGluZ3MuXG5cbnZhciBzdWJ0YWJsZVBhcnNlcnMgPSBuZXcgQXJyYXkoOSk7ICAgICAgICAgLy8gc3VidGFibGVQYXJzZXJzWzBdIGlzIHVudXNlZFxuXG4vLyBodHRwczovL3d3dy5taWNyb3NvZnQuY29tL3R5cG9ncmFwaHkvT1RTUEVDL0dTVUIuaHRtI1NTXG5zdWJ0YWJsZVBhcnNlcnNbMV0gPSBmdW5jdGlvbiBwYXJzZUxvb2t1cDEoKSB7XG4gICAgdmFyIHN0YXJ0ID0gdGhpcy5vZmZzZXQgKyB0aGlzLnJlbGF0aXZlT2Zmc2V0O1xuICAgIHZhciBzdWJzdEZvcm1hdCA9IHRoaXMucGFyc2VVU2hvcnQoKTtcbiAgICBpZiAoc3Vic3RGb3JtYXQgPT09IDEpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHN1YnN0Rm9ybWF0OiAxLFxuICAgICAgICAgICAgY292ZXJhZ2U6IHRoaXMucGFyc2VQb2ludGVyKFBhcnNlci5jb3ZlcmFnZSksXG4gICAgICAgICAgICBkZWx0YUdseXBoSWQ6IHRoaXMucGFyc2VVU2hvcnQoKVxuICAgICAgICB9O1xuICAgIH0gZWxzZSBpZiAoc3Vic3RGb3JtYXQgPT09IDIpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHN1YnN0Rm9ybWF0OiAyLFxuICAgICAgICAgICAgY292ZXJhZ2U6IHRoaXMucGFyc2VQb2ludGVyKFBhcnNlci5jb3ZlcmFnZSksXG4gICAgICAgICAgICBzdWJzdGl0dXRlOiB0aGlzLnBhcnNlT2Zmc2V0MTZMaXN0KClcbiAgICAgICAgfTtcbiAgICB9XG4gICAgY2hlY2suYXNzZXJ0KGZhbHNlLCAnMHgnICsgc3RhcnQudG9TdHJpbmcoMTYpICsgJzogbG9va3VwIHR5cGUgMSBmb3JtYXQgbXVzdCBiZSAxIG9yIDIuJyk7XG59O1xuXG4vLyBodHRwczovL3d3dy5taWNyb3NvZnQuY29tL3R5cG9ncmFwaHkvT1RTUEVDL0dTVUIuaHRtI01TXG5zdWJ0YWJsZVBhcnNlcnNbMl0gPSBmdW5jdGlvbiBwYXJzZUxvb2t1cDIoKSB7XG4gICAgdmFyIHN1YnN0Rm9ybWF0ID0gdGhpcy5wYXJzZVVTaG9ydCgpO1xuICAgIGNoZWNrLmFyZ3VtZW50KHN1YnN0Rm9ybWF0ID09PSAxLCAnR1NVQiBNdWx0aXBsZSBTdWJzdGl0dXRpb24gU3VidGFibGUgaWRlbnRpZmllci1mb3JtYXQgbXVzdCBiZSAxJyk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgc3Vic3RGb3JtYXQ6IHN1YnN0Rm9ybWF0LFxuICAgICAgICBjb3ZlcmFnZTogdGhpcy5wYXJzZVBvaW50ZXIoUGFyc2VyLmNvdmVyYWdlKSxcbiAgICAgICAgc2VxdWVuY2VzOiB0aGlzLnBhcnNlTGlzdE9mTGlzdHMoKVxuICAgIH07XG59O1xuXG4vLyBodHRwczovL3d3dy5taWNyb3NvZnQuY29tL3R5cG9ncmFwaHkvT1RTUEVDL0dTVUIuaHRtI0FTXG5zdWJ0YWJsZVBhcnNlcnNbM10gPSBmdW5jdGlvbiBwYXJzZUxvb2t1cDMoKSB7XG4gICAgdmFyIHN1YnN0Rm9ybWF0ID0gdGhpcy5wYXJzZVVTaG9ydCgpO1xuICAgIGNoZWNrLmFyZ3VtZW50KHN1YnN0Rm9ybWF0ID09PSAxLCAnR1NVQiBBbHRlcm5hdGUgU3Vic3RpdHV0aW9uIFN1YnRhYmxlIGlkZW50aWZpZXItZm9ybWF0IG11c3QgYmUgMScpO1xuICAgIHJldHVybiB7XG4gICAgICAgIHN1YnN0Rm9ybWF0OiBzdWJzdEZvcm1hdCxcbiAgICAgICAgY292ZXJhZ2U6IHRoaXMucGFyc2VQb2ludGVyKFBhcnNlci5jb3ZlcmFnZSksXG4gICAgICAgIGFsdGVybmF0ZVNldHM6IHRoaXMucGFyc2VMaXN0T2ZMaXN0cygpXG4gICAgfTtcbn07XG5cbi8vIGh0dHBzOi8vd3d3Lm1pY3Jvc29mdC5jb20vdHlwb2dyYXBoeS9PVFNQRUMvR1NVQi5odG0jTFNcbnN1YnRhYmxlUGFyc2Vyc1s0XSA9IGZ1bmN0aW9uIHBhcnNlTG9va3VwNCgpIHtcbiAgICB2YXIgc3Vic3RGb3JtYXQgPSB0aGlzLnBhcnNlVVNob3J0KCk7XG4gICAgY2hlY2suYXJndW1lbnQoc3Vic3RGb3JtYXQgPT09IDEsICdHU1VCIGxpZ2F0dXJlIHRhYmxlIGlkZW50aWZpZXItZm9ybWF0IG11c3QgYmUgMScpO1xuICAgIHJldHVybiB7XG4gICAgICAgIHN1YnN0Rm9ybWF0OiBzdWJzdEZvcm1hdCxcbiAgICAgICAgY292ZXJhZ2U6IHRoaXMucGFyc2VQb2ludGVyKFBhcnNlci5jb3ZlcmFnZSksXG4gICAgICAgIGxpZ2F0dXJlU2V0czogdGhpcy5wYXJzZUxpc3RPZkxpc3RzKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBsaWdHbHlwaDogdGhpcy5wYXJzZVVTaG9ydCgpLFxuICAgICAgICAgICAgICAgIGNvbXBvbmVudHM6IHRoaXMucGFyc2VVU2hvcnRMaXN0KHRoaXMucGFyc2VVU2hvcnQoKSAtIDEpXG4gICAgICAgICAgICB9O1xuICAgICAgICB9KVxuICAgIH07XG59O1xuXG52YXIgbG9va3VwUmVjb3JkRGVzYyA9IHtcbiAgICBzZXF1ZW5jZUluZGV4OiBQYXJzZXIudVNob3J0LFxuICAgIGxvb2t1cExpc3RJbmRleDogUGFyc2VyLnVTaG9ydFxufTtcblxuLy8gaHR0cHM6Ly93d3cubWljcm9zb2Z0LmNvbS90eXBvZ3JhcGh5L09UU1BFQy9HU1VCLmh0bSNDU0ZcbnN1YnRhYmxlUGFyc2Vyc1s1XSA9IGZ1bmN0aW9uIHBhcnNlTG9va3VwNSgpIHtcbiAgICB2YXIgc3RhcnQgPSB0aGlzLm9mZnNldCArIHRoaXMucmVsYXRpdmVPZmZzZXQ7XG4gICAgdmFyIHN1YnN0Rm9ybWF0ID0gdGhpcy5wYXJzZVVTaG9ydCgpO1xuXG4gICAgaWYgKHN1YnN0Rm9ybWF0ID09PSAxKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBzdWJzdEZvcm1hdDogc3Vic3RGb3JtYXQsXG4gICAgICAgICAgICBjb3ZlcmFnZTogdGhpcy5wYXJzZVBvaW50ZXIoUGFyc2VyLmNvdmVyYWdlKSxcbiAgICAgICAgICAgIHJ1bGVTZXRzOiB0aGlzLnBhcnNlTGlzdE9mTGlzdHMoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgdmFyIGdseXBoQ291bnQgPSB0aGlzLnBhcnNlVVNob3J0KCk7XG4gICAgICAgICAgICAgICAgdmFyIHN1YnN0Q291bnQgPSB0aGlzLnBhcnNlVVNob3J0KCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgaW5wdXQ6IHRoaXMucGFyc2VVU2hvcnRMaXN0KGdseXBoQ291bnQgLSAxKSxcbiAgICAgICAgICAgICAgICAgICAgbG9va3VwUmVjb3JkczogdGhpcy5wYXJzZVJlY29yZExpc3Qoc3Vic3RDb3VudCwgbG9va3VwUmVjb3JkRGVzYylcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSlcbiAgICAgICAgfTtcbiAgICB9IGVsc2UgaWYgKHN1YnN0Rm9ybWF0ID09PSAyKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBzdWJzdEZvcm1hdDogc3Vic3RGb3JtYXQsXG4gICAgICAgICAgICBjb3ZlcmFnZTogdGhpcy5wYXJzZVBvaW50ZXIoUGFyc2VyLmNvdmVyYWdlKSxcbiAgICAgICAgICAgIGNsYXNzRGVmOiB0aGlzLnBhcnNlUG9pbnRlcihQYXJzZXIuY2xhc3NEZWYpLFxuICAgICAgICAgICAgY2xhc3NTZXRzOiB0aGlzLnBhcnNlTGlzdE9mTGlzdHMoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgdmFyIGdseXBoQ291bnQgPSB0aGlzLnBhcnNlVVNob3J0KCk7XG4gICAgICAgICAgICAgICAgdmFyIHN1YnN0Q291bnQgPSB0aGlzLnBhcnNlVVNob3J0KCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgY2xhc3NlczogdGhpcy5wYXJzZVVTaG9ydExpc3QoZ2x5cGhDb3VudCAtIDEpLFxuICAgICAgICAgICAgICAgICAgICBsb29rdXBSZWNvcmRzOiB0aGlzLnBhcnNlUmVjb3JkTGlzdChzdWJzdENvdW50LCBsb29rdXBSZWNvcmREZXNjKVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9KVxuICAgICAgICB9O1xuICAgIH0gZWxzZSBpZiAoc3Vic3RGb3JtYXQgPT09IDMpIHtcbiAgICAgICAgdmFyIGdseXBoQ291bnQgPSB0aGlzLnBhcnNlVVNob3J0KCk7XG4gICAgICAgIHZhciBzdWJzdENvdW50ID0gdGhpcy5wYXJzZVVTaG9ydCgpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgc3Vic3RGb3JtYXQ6IHN1YnN0Rm9ybWF0LFxuICAgICAgICAgICAgY292ZXJhZ2VzOiB0aGlzLnBhcnNlTGlzdChnbHlwaENvdW50LCBQYXJzZXIucG9pbnRlcihQYXJzZXIuY292ZXJhZ2UpKSxcbiAgICAgICAgICAgIGxvb2t1cFJlY29yZHM6IHRoaXMucGFyc2VSZWNvcmRMaXN0KHN1YnN0Q291bnQsIGxvb2t1cFJlY29yZERlc2MpXG4gICAgICAgIH07XG4gICAgfVxuICAgIGNoZWNrLmFzc2VydChmYWxzZSwgJzB4JyArIHN0YXJ0LnRvU3RyaW5nKDE2KSArICc6IGxvb2t1cCB0eXBlIDUgZm9ybWF0IG11c3QgYmUgMSwgMiBvciAzLicpO1xufTtcblxuLy8gaHR0cHM6Ly93d3cubWljcm9zb2Z0LmNvbS90eXBvZ3JhcGh5L09UU1BFQy9HU1VCLmh0bSNDQ1xuc3VidGFibGVQYXJzZXJzWzZdID0gZnVuY3Rpb24gcGFyc2VMb29rdXA2KCkge1xuICAgIHZhciBzdGFydCA9IHRoaXMub2Zmc2V0ICsgdGhpcy5yZWxhdGl2ZU9mZnNldDtcbiAgICB2YXIgc3Vic3RGb3JtYXQgPSB0aGlzLnBhcnNlVVNob3J0KCk7XG4gICAgaWYgKHN1YnN0Rm9ybWF0ID09PSAxKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBzdWJzdEZvcm1hdDogMSxcbiAgICAgICAgICAgIGNvdmVyYWdlOiB0aGlzLnBhcnNlUG9pbnRlcihQYXJzZXIuY292ZXJhZ2UpLFxuICAgICAgICAgICAgY2hhaW5SdWxlU2V0czogdGhpcy5wYXJzZUxpc3RPZkxpc3RzKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIGJhY2t0cmFjazogdGhpcy5wYXJzZVVTaG9ydExpc3QoKSxcbiAgICAgICAgICAgICAgICAgICAgaW5wdXQ6IHRoaXMucGFyc2VVU2hvcnRMaXN0KHRoaXMucGFyc2VTaG9ydCgpIC0gMSksXG4gICAgICAgICAgICAgICAgICAgIGxvb2thaGVhZDogdGhpcy5wYXJzZVVTaG9ydExpc3QoKSxcbiAgICAgICAgICAgICAgICAgICAgbG9va3VwUmVjb3JkczogdGhpcy5wYXJzZVJlY29yZExpc3QobG9va3VwUmVjb3JkRGVzYylcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSlcbiAgICAgICAgfTtcbiAgICB9IGVsc2UgaWYgKHN1YnN0Rm9ybWF0ID09PSAyKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBzdWJzdEZvcm1hdDogMixcbiAgICAgICAgICAgIGNvdmVyYWdlOiB0aGlzLnBhcnNlUG9pbnRlcihQYXJzZXIuY292ZXJhZ2UpLFxuICAgICAgICAgICAgYmFja3RyYWNrQ2xhc3NEZWY6IHRoaXMucGFyc2VQb2ludGVyKFBhcnNlci5jbGFzc0RlZiksXG4gICAgICAgICAgICBpbnB1dENsYXNzRGVmOiB0aGlzLnBhcnNlUG9pbnRlcihQYXJzZXIuY2xhc3NEZWYpLFxuICAgICAgICAgICAgbG9va2FoZWFkQ2xhc3NEZWY6IHRoaXMucGFyc2VQb2ludGVyKFBhcnNlci5jbGFzc0RlZiksXG4gICAgICAgICAgICBjaGFpbkNsYXNzU2V0OiB0aGlzLnBhcnNlTGlzdE9mTGlzdHMoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgYmFja3RyYWNrOiB0aGlzLnBhcnNlVVNob3J0TGlzdCgpLFxuICAgICAgICAgICAgICAgICAgICBpbnB1dDogdGhpcy5wYXJzZVVTaG9ydExpc3QodGhpcy5wYXJzZVNob3J0KCkgLSAxKSxcbiAgICAgICAgICAgICAgICAgICAgbG9va2FoZWFkOiB0aGlzLnBhcnNlVVNob3J0TGlzdCgpLFxuICAgICAgICAgICAgICAgICAgICBsb29rdXBSZWNvcmRzOiB0aGlzLnBhcnNlUmVjb3JkTGlzdChsb29rdXBSZWNvcmREZXNjKVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9KVxuICAgICAgICB9O1xuICAgIH0gZWxzZSBpZiAoc3Vic3RGb3JtYXQgPT09IDMpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHN1YnN0Rm9ybWF0OiAzLFxuICAgICAgICAgICAgYmFja3RyYWNrQ292ZXJhZ2U6IHRoaXMucGFyc2VMaXN0KFBhcnNlci5wb2ludGVyKFBhcnNlci5jb3ZlcmFnZSkpLFxuICAgICAgICAgICAgaW5wdXRDb3ZlcmFnZTogdGhpcy5wYXJzZUxpc3QoUGFyc2VyLnBvaW50ZXIoUGFyc2VyLmNvdmVyYWdlKSksXG4gICAgICAgICAgICBsb29rYWhlYWRDb3ZlcmFnZTogdGhpcy5wYXJzZUxpc3QoUGFyc2VyLnBvaW50ZXIoUGFyc2VyLmNvdmVyYWdlKSksXG4gICAgICAgICAgICBsb29rdXBSZWNvcmRzOiB0aGlzLnBhcnNlUmVjb3JkTGlzdChsb29rdXBSZWNvcmREZXNjKVxuICAgICAgICB9O1xuICAgIH1cbiAgICBjaGVjay5hc3NlcnQoZmFsc2UsICcweCcgKyBzdGFydC50b1N0cmluZygxNikgKyAnOiBsb29rdXAgdHlwZSA2IGZvcm1hdCBtdXN0IGJlIDEsIDIgb3IgMy4nKTtcbn07XG5cbi8vIGh0dHBzOi8vd3d3Lm1pY3Jvc29mdC5jb20vdHlwb2dyYXBoeS9PVFNQRUMvR1NVQi5odG0jRVNcbnN1YnRhYmxlUGFyc2Vyc1s3XSA9IGZ1bmN0aW9uIHBhcnNlTG9va3VwNygpIHtcbiAgICAvLyBFeHRlbnNpb24gU3Vic3RpdHV0aW9uIHN1YnRhYmxlXG4gICAgdmFyIHN1YnN0Rm9ybWF0ID0gdGhpcy5wYXJzZVVTaG9ydCgpO1xuICAgIGNoZWNrLmFyZ3VtZW50KHN1YnN0Rm9ybWF0ID09PSAxLCAnR1NVQiBFeHRlbnNpb24gU3Vic3RpdHV0aW9uIHN1YnRhYmxlIGlkZW50aWZpZXItZm9ybWF0IG11c3QgYmUgMScpO1xuICAgIHZhciBleHRlbnNpb25Mb29rdXBUeXBlID0gdGhpcy5wYXJzZVVTaG9ydCgpO1xuICAgIHZhciBleHRlbnNpb25QYXJzZXIgPSBuZXcgUGFyc2VyKHRoaXMuZGF0YSwgdGhpcy5vZmZzZXQgKyB0aGlzLnBhcnNlVUxvbmcoKSk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgc3Vic3RGb3JtYXQ6IDEsXG4gICAgICAgIGxvb2t1cFR5cGU6IGV4dGVuc2lvbkxvb2t1cFR5cGUsXG4gICAgICAgIGV4dGVuc2lvbjogc3VidGFibGVQYXJzZXJzW2V4dGVuc2lvbkxvb2t1cFR5cGVdLmNhbGwoZXh0ZW5zaW9uUGFyc2VyKVxuICAgIH07XG59O1xuXG4vLyBodHRwczovL3d3dy5taWNyb3NvZnQuY29tL3R5cG9ncmFwaHkvT1RTUEVDL0dTVUIuaHRtI1JDQ1NcbnN1YnRhYmxlUGFyc2Vyc1s4XSA9IGZ1bmN0aW9uIHBhcnNlTG9va3VwOCgpIHtcbiAgICB2YXIgc3Vic3RGb3JtYXQgPSB0aGlzLnBhcnNlVVNob3J0KCk7XG4gICAgY2hlY2suYXJndW1lbnQoc3Vic3RGb3JtYXQgPT09IDEsICdHU1VCIFJldmVyc2UgQ2hhaW5pbmcgQ29udGV4dHVhbCBTaW5nbGUgU3Vic3RpdHV0aW9uIFN1YnRhYmxlIGlkZW50aWZpZXItZm9ybWF0IG11c3QgYmUgMScpO1xuICAgIHJldHVybiB7XG4gICAgICAgIHN1YnN0Rm9ybWF0OiBzdWJzdEZvcm1hdCxcbiAgICAgICAgY292ZXJhZ2U6IHRoaXMucGFyc2VQb2ludGVyKFBhcnNlci5jb3ZlcmFnZSksXG4gICAgICAgIGJhY2t0cmFja0NvdmVyYWdlOiB0aGlzLnBhcnNlTGlzdChQYXJzZXIucG9pbnRlcihQYXJzZXIuY292ZXJhZ2UpKSxcbiAgICAgICAgbG9va2FoZWFkQ292ZXJhZ2U6IHRoaXMucGFyc2VMaXN0KFBhcnNlci5wb2ludGVyKFBhcnNlci5jb3ZlcmFnZSkpLFxuICAgICAgICBzdWJzdGl0dXRlczogdGhpcy5wYXJzZVVTaG9ydExpc3QoKVxuICAgIH07XG59O1xuXG4vLyBodHRwczovL3d3dy5taWNyb3NvZnQuY29tL3R5cG9ncmFwaHkvT1RTUEVDL2dzdWIuaHRtXG5mdW5jdGlvbiBwYXJzZUdzdWJUYWJsZShkYXRhLCBzdGFydCkge1xuICAgIHN0YXJ0ID0gc3RhcnQgfHwgMDtcbiAgICB2YXIgcCA9IG5ldyBQYXJzZXIoZGF0YSwgc3RhcnQpO1xuICAgIHZhciB0YWJsZVZlcnNpb24gPSBwLnBhcnNlVmVyc2lvbigxKTtcbiAgICBjaGVjay5hcmd1bWVudCh0YWJsZVZlcnNpb24gPT09IDEgfHwgdGFibGVWZXJzaW9uID09PSAxLjEsICdVbnN1cHBvcnRlZCBHU1VCIHRhYmxlIHZlcnNpb24uJyk7XG4gICAgaWYgKHRhYmxlVmVyc2lvbiA9PT0gMSkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdmVyc2lvbjogdGFibGVWZXJzaW9uLFxuICAgICAgICAgICAgc2NyaXB0czogcC5wYXJzZVNjcmlwdExpc3QoKSxcbiAgICAgICAgICAgIGZlYXR1cmVzOiBwLnBhcnNlRmVhdHVyZUxpc3QoKSxcbiAgICAgICAgICAgIGxvb2t1cHM6IHAucGFyc2VMb29rdXBMaXN0KHN1YnRhYmxlUGFyc2VycylcbiAgICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdmVyc2lvbjogdGFibGVWZXJzaW9uLFxuICAgICAgICAgICAgc2NyaXB0czogcC5wYXJzZVNjcmlwdExpc3QoKSxcbiAgICAgICAgICAgIGZlYXR1cmVzOiBwLnBhcnNlRmVhdHVyZUxpc3QoKSxcbiAgICAgICAgICAgIGxvb2t1cHM6IHAucGFyc2VMb29rdXBMaXN0KHN1YnRhYmxlUGFyc2VycyksXG4gICAgICAgICAgICB2YXJpYXRpb25zOiBwLnBhcnNlRmVhdHVyZVZhcmlhdGlvbnNMaXN0KClcbiAgICAgICAgfTtcbiAgICB9XG5cbn1cblxuLy8gR1NVQiBXcml0aW5nIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbnZhciBzdWJ0YWJsZU1ha2VycyA9IG5ldyBBcnJheSg5KTtcblxuc3VidGFibGVNYWtlcnNbMV0gPSBmdW5jdGlvbiBtYWtlTG9va3VwMShzdWJ0YWJsZSkge1xuICAgIGlmIChzdWJ0YWJsZS5zdWJzdEZvcm1hdCA9PT0gMSkge1xuICAgICAgICByZXR1cm4gbmV3IHRhYmxlLlRhYmxlKCdzdWJzdGl0dXRpb25UYWJsZScsIFtcbiAgICAgICAgICAgIHtuYW1lOiAnc3Vic3RGb3JtYXQnLCB0eXBlOiAnVVNIT1JUJywgdmFsdWU6IDF9LFxuICAgICAgICAgICAge25hbWU6ICdjb3ZlcmFnZScsIHR5cGU6ICdUQUJMRScsIHZhbHVlOiBuZXcgdGFibGUuQ292ZXJhZ2Uoc3VidGFibGUuY292ZXJhZ2UpfSxcbiAgICAgICAgICAgIHtuYW1lOiAnZGVsdGFHbHlwaElEJywgdHlwZTogJ1VTSE9SVCcsIHZhbHVlOiBzdWJ0YWJsZS5kZWx0YUdseXBoSWR9XG4gICAgICAgIF0pO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBuZXcgdGFibGUuVGFibGUoJ3N1YnN0aXR1dGlvblRhYmxlJywgW1xuICAgICAgICAgICAge25hbWU6ICdzdWJzdEZvcm1hdCcsIHR5cGU6ICdVU0hPUlQnLCB2YWx1ZTogMn0sXG4gICAgICAgICAgICB7bmFtZTogJ2NvdmVyYWdlJywgdHlwZTogJ1RBQkxFJywgdmFsdWU6IG5ldyB0YWJsZS5Db3ZlcmFnZShzdWJ0YWJsZS5jb3ZlcmFnZSl9XG4gICAgICAgIF0uY29uY2F0KHRhYmxlLnVzaG9ydExpc3QoJ3N1YnN0aXR1dGUnLCBzdWJ0YWJsZS5zdWJzdGl0dXRlKSkpO1xuICAgIH1cbn07XG5cbnN1YnRhYmxlTWFrZXJzWzJdID0gZnVuY3Rpb24gbWFrZUxvb2t1cDIoc3VidGFibGUpIHtcbiAgICBjaGVjay5hc3NlcnQoc3VidGFibGUuc3Vic3RGb3JtYXQgPT09IDEsICdMb29rdXAgdHlwZSAyIHN1YnN0Rm9ybWF0IG11c3QgYmUgMS4nKTtcbiAgICByZXR1cm4gbmV3IHRhYmxlLlRhYmxlKCdzdWJzdGl0dXRpb25UYWJsZScsIFtcbiAgICAgICAge25hbWU6ICdzdWJzdEZvcm1hdCcsIHR5cGU6ICdVU0hPUlQnLCB2YWx1ZTogMX0sXG4gICAgICAgIHtuYW1lOiAnY292ZXJhZ2UnLCB0eXBlOiAnVEFCTEUnLCB2YWx1ZTogbmV3IHRhYmxlLkNvdmVyYWdlKHN1YnRhYmxlLmNvdmVyYWdlKX1cbiAgICBdLmNvbmNhdCh0YWJsZS50YWJsZUxpc3QoJ3NlcVNldCcsIHN1YnRhYmxlLnNlcXVlbmNlcywgZnVuY3Rpb24oc2VxdWVuY2VTZXQpIHtcbiAgICAgICAgcmV0dXJuIG5ldyB0YWJsZS5UYWJsZSgnc2VxdWVuY2VTZXRUYWJsZScsIHRhYmxlLnVzaG9ydExpc3QoJ3NlcXVlbmNlJywgc2VxdWVuY2VTZXQpKTtcbiAgICB9KSkpO1xufTtcblxuc3VidGFibGVNYWtlcnNbM10gPSBmdW5jdGlvbiBtYWtlTG9va3VwMyhzdWJ0YWJsZSkge1xuICAgIGNoZWNrLmFzc2VydChzdWJ0YWJsZS5zdWJzdEZvcm1hdCA9PT0gMSwgJ0xvb2t1cCB0eXBlIDMgc3Vic3RGb3JtYXQgbXVzdCBiZSAxLicpO1xuICAgIHJldHVybiBuZXcgdGFibGUuVGFibGUoJ3N1YnN0aXR1dGlvblRhYmxlJywgW1xuICAgICAgICB7bmFtZTogJ3N1YnN0Rm9ybWF0JywgdHlwZTogJ1VTSE9SVCcsIHZhbHVlOiAxfSxcbiAgICAgICAge25hbWU6ICdjb3ZlcmFnZScsIHR5cGU6ICdUQUJMRScsIHZhbHVlOiBuZXcgdGFibGUuQ292ZXJhZ2Uoc3VidGFibGUuY292ZXJhZ2UpfVxuICAgIF0uY29uY2F0KHRhYmxlLnRhYmxlTGlzdCgnYWx0U2V0Jywgc3VidGFibGUuYWx0ZXJuYXRlU2V0cywgZnVuY3Rpb24oYWx0ZXJuYXRlU2V0KSB7XG4gICAgICAgIHJldHVybiBuZXcgdGFibGUuVGFibGUoJ2FsdGVybmF0ZVNldFRhYmxlJywgdGFibGUudXNob3J0TGlzdCgnYWx0ZXJuYXRlJywgYWx0ZXJuYXRlU2V0KSk7XG4gICAgfSkpKTtcbn07XG5cbnN1YnRhYmxlTWFrZXJzWzRdID0gZnVuY3Rpb24gbWFrZUxvb2t1cDQoc3VidGFibGUpIHtcbiAgICBjaGVjay5hc3NlcnQoc3VidGFibGUuc3Vic3RGb3JtYXQgPT09IDEsICdMb29rdXAgdHlwZSA0IHN1YnN0Rm9ybWF0IG11c3QgYmUgMS4nKTtcbiAgICByZXR1cm4gbmV3IHRhYmxlLlRhYmxlKCdzdWJzdGl0dXRpb25UYWJsZScsIFtcbiAgICAgICAge25hbWU6ICdzdWJzdEZvcm1hdCcsIHR5cGU6ICdVU0hPUlQnLCB2YWx1ZTogMX0sXG4gICAgICAgIHtuYW1lOiAnY292ZXJhZ2UnLCB0eXBlOiAnVEFCTEUnLCB2YWx1ZTogbmV3IHRhYmxlLkNvdmVyYWdlKHN1YnRhYmxlLmNvdmVyYWdlKX1cbiAgICBdLmNvbmNhdCh0YWJsZS50YWJsZUxpc3QoJ2xpZ1NldCcsIHN1YnRhYmxlLmxpZ2F0dXJlU2V0cywgZnVuY3Rpb24obGlnYXR1cmVTZXQpIHtcbiAgICAgICAgcmV0dXJuIG5ldyB0YWJsZS5UYWJsZSgnbGlnYXR1cmVTZXRUYWJsZScsIHRhYmxlLnRhYmxlTGlzdCgnbGlnYXR1cmUnLCBsaWdhdHVyZVNldCwgZnVuY3Rpb24obGlnYXR1cmUpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgdGFibGUuVGFibGUoJ2xpZ2F0dXJlVGFibGUnLFxuICAgICAgICAgICAgICAgIFt7bmFtZTogJ2xpZ0dseXBoJywgdHlwZTogJ1VTSE9SVCcsIHZhbHVlOiBsaWdhdHVyZS5saWdHbHlwaH1dXG4gICAgICAgICAgICAgICAgLmNvbmNhdCh0YWJsZS51c2hvcnRMaXN0KCdjb21wb25lbnQnLCBsaWdhdHVyZS5jb21wb25lbnRzLCBsaWdhdHVyZS5jb21wb25lbnRzLmxlbmd0aCArIDEpKVxuICAgICAgICAgICAgKTtcbiAgICAgICAgfSkpO1xuICAgIH0pKSk7XG59O1xuXG5zdWJ0YWJsZU1ha2Vyc1s2XSA9IGZ1bmN0aW9uIG1ha2VMb29rdXA2KHN1YnRhYmxlKSB7XG4gICAgaWYgKHN1YnRhYmxlLnN1YnN0Rm9ybWF0ID09PSAxKSB7XG4gICAgICAgIHZhciByZXR1cm5UYWJsZSA9IG5ldyB0YWJsZS5UYWJsZSgnY2hhaW5Db250ZXh0VGFibGUnLCBbXG4gICAgICAgICAgICB7bmFtZTogJ3N1YnN0Rm9ybWF0JywgdHlwZTogJ1VTSE9SVCcsIHZhbHVlOiBzdWJ0YWJsZS5zdWJzdEZvcm1hdH0sXG4gICAgICAgICAgICB7bmFtZTogJ2NvdmVyYWdlJywgdHlwZTogJ1RBQkxFJywgdmFsdWU6IG5ldyB0YWJsZS5Db3ZlcmFnZShzdWJ0YWJsZS5jb3ZlcmFnZSl9XG4gICAgICAgIF0uY29uY2F0KHRhYmxlLnRhYmxlTGlzdCgnY2hhaW5SdWxlU2V0Jywgc3VidGFibGUuY2hhaW5SdWxlU2V0cywgZnVuY3Rpb24oY2hhaW5SdWxlU2V0KSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IHRhYmxlLlRhYmxlKCdjaGFpblJ1bGVTZXRUYWJsZScsIHRhYmxlLnRhYmxlTGlzdCgnY2hhaW5SdWxlJywgY2hhaW5SdWxlU2V0LCBmdW5jdGlvbihjaGFpblJ1bGUpIHtcbiAgICAgICAgICAgICAgICB2YXIgdGFibGVEYXRhID0gdGFibGUudXNob3J0TGlzdCgnYmFja3RyYWNrR2x5cGgnLCBjaGFpblJ1bGUuYmFja3RyYWNrLCBjaGFpblJ1bGUuYmFja3RyYWNrLmxlbmd0aClcbiAgICAgICAgICAgICAgICAgICAgLmNvbmNhdCh0YWJsZS51c2hvcnRMaXN0KCdpbnB1dEdseXBoJywgY2hhaW5SdWxlLmlucHV0LCBjaGFpblJ1bGUuaW5wdXQubGVuZ3RoICsgMSkpXG4gICAgICAgICAgICAgICAgICAgIC5jb25jYXQodGFibGUudXNob3J0TGlzdCgnbG9va2FoZWFkR2x5cGgnLCBjaGFpblJ1bGUubG9va2FoZWFkLCBjaGFpblJ1bGUubG9va2FoZWFkLmxlbmd0aCkpXG4gICAgICAgICAgICAgICAgICAgIC5jb25jYXQodGFibGUudXNob3J0TGlzdCgnc3Vic3RpdHV0aW9uJywgW10sIGNoYWluUnVsZS5sb29rdXBSZWNvcmRzLmxlbmd0aCkpO1xuXG4gICAgICAgICAgICAgICAgY2hhaW5SdWxlLmxvb2t1cFJlY29yZHMuZm9yRWFjaChmdW5jdGlvbiAocmVjb3JkLCBpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRhYmxlRGF0YSA9IHRhYmxlRGF0YVxuICAgICAgICAgICAgICAgICAgICAgICAgLmNvbmNhdCh7bmFtZTogJ3NlcXVlbmNlSW5kZXgnICsgaSwgdHlwZTogJ1VTSE9SVCcsIHZhbHVlOiByZWNvcmQuc2VxdWVuY2VJbmRleH0pXG4gICAgICAgICAgICAgICAgICAgICAgICAuY29uY2F0KHtuYW1lOiAnbG9va3VwTGlzdEluZGV4JyArIGksIHR5cGU6ICdVU0hPUlQnLCB2YWx1ZTogcmVjb3JkLmxvb2t1cExpc3RJbmRleH0pO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgdGFibGUuVGFibGUoJ2NoYWluUnVsZVRhYmxlJywgdGFibGVEYXRhKTtcbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgfSkpKTtcbiAgICAgICAgcmV0dXJuIHJldHVyblRhYmxlO1xuICAgIH0gZWxzZSBpZiAoc3VidGFibGUuc3Vic3RGb3JtYXQgPT09IDIpIHtcbiAgICAgICAgY2hlY2suYXNzZXJ0KGZhbHNlLCAnbG9va3VwIHR5cGUgNiBmb3JtYXQgMiBpcyBub3QgeWV0IHN1cHBvcnRlZC4nKTtcbiAgICB9IGVsc2UgaWYgKHN1YnRhYmxlLnN1YnN0Rm9ybWF0ID09PSAzKSB7XG4gICAgICAgIHZhciB0YWJsZURhdGEgPSBbXG4gICAgICAgICAgICB7bmFtZTogJ3N1YnN0Rm9ybWF0JywgdHlwZTogJ1VTSE9SVCcsIHZhbHVlOiBzdWJ0YWJsZS5zdWJzdEZvcm1hdH0gXTtcblxuICAgICAgICB0YWJsZURhdGEucHVzaCh7bmFtZTogJ2JhY2t0cmFja0dseXBoQ291bnQnLCB0eXBlOiAnVVNIT1JUJywgdmFsdWU6IHN1YnRhYmxlLmJhY2t0cmFja0NvdmVyYWdlLmxlbmd0aH0pO1xuICAgICAgICBzdWJ0YWJsZS5iYWNrdHJhY2tDb3ZlcmFnZS5mb3JFYWNoKGZ1bmN0aW9uIChjb3ZlcmFnZSwgaSkge1xuICAgICAgICAgICAgdGFibGVEYXRhLnB1c2goe25hbWU6ICdiYWNrdHJhY2tDb3ZlcmFnZScgKyBpLCB0eXBlOiAnVEFCTEUnLCB2YWx1ZTogbmV3IHRhYmxlLkNvdmVyYWdlKGNvdmVyYWdlKX0pO1xuICAgICAgICB9KTtcbiAgICAgICAgdGFibGVEYXRhLnB1c2goe25hbWU6ICdpbnB1dEdseXBoQ291bnQnLCB0eXBlOiAnVVNIT1JUJywgdmFsdWU6IHN1YnRhYmxlLmlucHV0Q292ZXJhZ2UubGVuZ3RofSk7XG4gICAgICAgIHN1YnRhYmxlLmlucHV0Q292ZXJhZ2UuZm9yRWFjaChmdW5jdGlvbiAoY292ZXJhZ2UsIGkpIHtcbiAgICAgICAgICAgIHRhYmxlRGF0YS5wdXNoKHtuYW1lOiAnaW5wdXRDb3ZlcmFnZScgKyBpLCB0eXBlOiAnVEFCTEUnLCB2YWx1ZTogbmV3IHRhYmxlLkNvdmVyYWdlKGNvdmVyYWdlKX0pO1xuICAgICAgICB9KTtcbiAgICAgICAgdGFibGVEYXRhLnB1c2goe25hbWU6ICdsb29rYWhlYWRHbHlwaENvdW50JywgdHlwZTogJ1VTSE9SVCcsIHZhbHVlOiBzdWJ0YWJsZS5sb29rYWhlYWRDb3ZlcmFnZS5sZW5ndGh9KTtcbiAgICAgICAgc3VidGFibGUubG9va2FoZWFkQ292ZXJhZ2UuZm9yRWFjaChmdW5jdGlvbiAoY292ZXJhZ2UsIGkpIHtcbiAgICAgICAgICAgIHRhYmxlRGF0YS5wdXNoKHtuYW1lOiAnbG9va2FoZWFkQ292ZXJhZ2UnICsgaSwgdHlwZTogJ1RBQkxFJywgdmFsdWU6IG5ldyB0YWJsZS5Db3ZlcmFnZShjb3ZlcmFnZSl9KTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgdGFibGVEYXRhLnB1c2goe25hbWU6ICdzdWJzdGl0dXRpb25Db3VudCcsIHR5cGU6ICdVU0hPUlQnLCB2YWx1ZTogc3VidGFibGUubG9va3VwUmVjb3Jkcy5sZW5ndGh9KTtcbiAgICAgICAgc3VidGFibGUubG9va3VwUmVjb3Jkcy5mb3JFYWNoKGZ1bmN0aW9uIChyZWNvcmQsIGkpIHtcbiAgICAgICAgICAgIHRhYmxlRGF0YSA9IHRhYmxlRGF0YVxuICAgICAgICAgICAgICAgIC5jb25jYXQoe25hbWU6ICdzZXF1ZW5jZUluZGV4JyArIGksIHR5cGU6ICdVU0hPUlQnLCB2YWx1ZTogcmVjb3JkLnNlcXVlbmNlSW5kZXh9KVxuICAgICAgICAgICAgICAgIC5jb25jYXQoe25hbWU6ICdsb29rdXBMaXN0SW5kZXgnICsgaSwgdHlwZTogJ1VTSE9SVCcsIHZhbHVlOiByZWNvcmQubG9va3VwTGlzdEluZGV4fSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHZhciByZXR1cm5UYWJsZSQxID0gbmV3IHRhYmxlLlRhYmxlKCdjaGFpbkNvbnRleHRUYWJsZScsIHRhYmxlRGF0YSk7XG5cbiAgICAgICAgcmV0dXJuIHJldHVyblRhYmxlJDE7XG4gICAgfVxuXG4gICAgY2hlY2suYXNzZXJ0KGZhbHNlLCAnbG9va3VwIHR5cGUgNiBmb3JtYXQgbXVzdCBiZSAxLCAyIG9yIDMuJyk7XG59O1xuXG5mdW5jdGlvbiBtYWtlR3N1YlRhYmxlKGdzdWIpIHtcbiAgICByZXR1cm4gbmV3IHRhYmxlLlRhYmxlKCdHU1VCJywgW1xuICAgICAgICB7bmFtZTogJ3ZlcnNpb24nLCB0eXBlOiAnVUxPTkcnLCB2YWx1ZTogMHgxMDAwMH0sXG4gICAgICAgIHtuYW1lOiAnc2NyaXB0cycsIHR5cGU6ICdUQUJMRScsIHZhbHVlOiBuZXcgdGFibGUuU2NyaXB0TGlzdChnc3ViLnNjcmlwdHMpfSxcbiAgICAgICAge25hbWU6ICdmZWF0dXJlcycsIHR5cGU6ICdUQUJMRScsIHZhbHVlOiBuZXcgdGFibGUuRmVhdHVyZUxpc3QoZ3N1Yi5mZWF0dXJlcyl9LFxuICAgICAgICB7bmFtZTogJ2xvb2t1cHMnLCB0eXBlOiAnVEFCTEUnLCB2YWx1ZTogbmV3IHRhYmxlLkxvb2t1cExpc3QoZ3N1Yi5sb29rdXBzLCBzdWJ0YWJsZU1ha2Vycyl9XG4gICAgXSk7XG59XG5cbnZhciBnc3ViID0geyBwYXJzZTogcGFyc2VHc3ViVGFibGUsIG1ha2U6IG1ha2VHc3ViVGFibGUgfTtcblxuLy8gVGhlIGBHUE9TYCB0YWJsZSBjb250YWlucyBrZXJuaW5nIHBhaXJzLCBhbW9uZyBvdGhlciB0aGluZ3MuXG5cbi8vIFBhcnNlIHRoZSBtZXRhZGF0YSBgbWV0YWAgdGFibGUuXG4vLyBodHRwczovL2RldmVsb3Blci5hcHBsZS5jb20vZm9udHMvVHJ1ZVR5cGUtUmVmZXJlbmNlLU1hbnVhbC9STTA2L0NoYXA2bWV0YS5odG1sXG5mdW5jdGlvbiBwYXJzZU1ldGFUYWJsZShkYXRhLCBzdGFydCkge1xuICAgIHZhciBwID0gbmV3IHBhcnNlLlBhcnNlcihkYXRhLCBzdGFydCk7XG4gICAgdmFyIHRhYmxlVmVyc2lvbiA9IHAucGFyc2VVTG9uZygpO1xuICAgIGNoZWNrLmFyZ3VtZW50KHRhYmxlVmVyc2lvbiA9PT0gMSwgJ1Vuc3VwcG9ydGVkIE1FVEEgdGFibGUgdmVyc2lvbi4nKTtcbiAgICBwLnBhcnNlVUxvbmcoKTsgLy8gZmxhZ3MgLSBjdXJyZW50bHkgdW51c2VkIGFuZCBzZXQgdG8gMFxuICAgIHAucGFyc2VVTG9uZygpOyAvLyB0YWJsZU9mZnNldFxuICAgIHZhciBudW1EYXRhTWFwcyA9IHAucGFyc2VVTG9uZygpO1xuXG4gICAgdmFyIHRhZ3MgPSB7fTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG51bURhdGFNYXBzOyBpKyspIHtcbiAgICAgICAgdmFyIHRhZyA9IHAucGFyc2VUYWcoKTtcbiAgICAgICAgdmFyIGRhdGFPZmZzZXQgPSBwLnBhcnNlVUxvbmcoKTtcbiAgICAgICAgdmFyIGRhdGFMZW5ndGggPSBwLnBhcnNlVUxvbmcoKTtcbiAgICAgICAgdmFyIHRleHQgPSBkZWNvZGUuVVRGOChkYXRhLCBzdGFydCArIGRhdGFPZmZzZXQsIGRhdGFMZW5ndGgpO1xuXG4gICAgICAgIHRhZ3NbdGFnXSA9IHRleHQ7XG4gICAgfVxuICAgIHJldHVybiB0YWdzO1xufVxuXG5mdW5jdGlvbiBtYWtlTWV0YVRhYmxlKHRhZ3MpIHtcbiAgICB2YXIgbnVtVGFncyA9IE9iamVjdC5rZXlzKHRhZ3MpLmxlbmd0aDtcbiAgICB2YXIgc3RyaW5nUG9vbCA9ICcnO1xuICAgIHZhciBzdHJpbmdQb29sT2Zmc2V0ID0gMTYgKyBudW1UYWdzICogMTI7XG5cbiAgICB2YXIgcmVzdWx0ID0gbmV3IHRhYmxlLlRhYmxlKCdtZXRhJywgW1xuICAgICAgICB7bmFtZTogJ3ZlcnNpb24nLCB0eXBlOiAnVUxPTkcnLCB2YWx1ZTogMX0sXG4gICAgICAgIHtuYW1lOiAnZmxhZ3MnLCB0eXBlOiAnVUxPTkcnLCB2YWx1ZTogMH0sXG4gICAgICAgIHtuYW1lOiAnb2Zmc2V0JywgdHlwZTogJ1VMT05HJywgdmFsdWU6IHN0cmluZ1Bvb2xPZmZzZXR9LFxuICAgICAgICB7bmFtZTogJ251bVRhZ3MnLCB0eXBlOiAnVUxPTkcnLCB2YWx1ZTogbnVtVGFnc31cbiAgICBdKTtcblxuICAgIGZvciAodmFyIHRhZyBpbiB0YWdzKSB7XG4gICAgICAgIHZhciBwb3MgPSBzdHJpbmdQb29sLmxlbmd0aDtcbiAgICAgICAgc3RyaW5nUG9vbCArPSB0YWdzW3RhZ107XG5cbiAgICAgICAgcmVzdWx0LmZpZWxkcy5wdXNoKHtuYW1lOiAndGFnICcgKyB0YWcsIHR5cGU6ICdUQUcnLCB2YWx1ZTogdGFnfSk7XG4gICAgICAgIHJlc3VsdC5maWVsZHMucHVzaCh7bmFtZTogJ29mZnNldCAnICsgdGFnLCB0eXBlOiAnVUxPTkcnLCB2YWx1ZTogc3RyaW5nUG9vbE9mZnNldCArIHBvc30pO1xuICAgICAgICByZXN1bHQuZmllbGRzLnB1c2goe25hbWU6ICdsZW5ndGggJyArIHRhZywgdHlwZTogJ1VMT05HJywgdmFsdWU6IHRhZ3NbdGFnXS5sZW5ndGh9KTtcbiAgICB9XG5cbiAgICByZXN1bHQuZmllbGRzLnB1c2goe25hbWU6ICdzdHJpbmdQb29sJywgdHlwZTogJ0NIQVJBUlJBWScsIHZhbHVlOiBzdHJpbmdQb29sfSk7XG5cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuXG52YXIgbWV0YSA9IHsgcGFyc2U6IHBhcnNlTWV0YVRhYmxlLCBtYWtlOiBtYWtlTWV0YVRhYmxlIH07XG5cbi8vIFRoZSBgc2ZudGAgd3JhcHBlciBwcm92aWRlcyBvcmdhbml6YXRpb24gZm9yIHRoZSB0YWJsZXMgaW4gdGhlIGZvbnQuXG5cbmZ1bmN0aW9uIGxvZzIodikge1xuICAgIHJldHVybiBNYXRoLmxvZyh2KSAvIE1hdGgubG9nKDIpIHwgMDtcbn1cblxuZnVuY3Rpb24gY29tcHV0ZUNoZWNrU3VtKGJ5dGVzKSB7XG4gICAgd2hpbGUgKGJ5dGVzLmxlbmd0aCAlIDQgIT09IDApIHtcbiAgICAgICAgYnl0ZXMucHVzaCgwKTtcbiAgICB9XG5cbiAgICB2YXIgc3VtID0gMDtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGJ5dGVzLmxlbmd0aDsgaSArPSA0KSB7XG4gICAgICAgIHN1bSArPSAoYnl0ZXNbaV0gPDwgMjQpICtcbiAgICAgICAgICAgIChieXRlc1tpICsgMV0gPDwgMTYpICtcbiAgICAgICAgICAgIChieXRlc1tpICsgMl0gPDwgOCkgK1xuICAgICAgICAgICAgKGJ5dGVzW2kgKyAzXSk7XG4gICAgfVxuXG4gICAgc3VtICU9IE1hdGgucG93KDIsIDMyKTtcbiAgICByZXR1cm4gc3VtO1xufVxuXG5mdW5jdGlvbiBtYWtlVGFibGVSZWNvcmQodGFnLCBjaGVja1N1bSwgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgICByZXR1cm4gbmV3IHRhYmxlLlJlY29yZCgnVGFibGUgUmVjb3JkJywgW1xuICAgICAgICB7bmFtZTogJ3RhZycsIHR5cGU6ICdUQUcnLCB2YWx1ZTogdGFnICE9PSB1bmRlZmluZWQgPyB0YWcgOiAnJ30sXG4gICAgICAgIHtuYW1lOiAnY2hlY2tTdW0nLCB0eXBlOiAnVUxPTkcnLCB2YWx1ZTogY2hlY2tTdW0gIT09IHVuZGVmaW5lZCA/IGNoZWNrU3VtIDogMH0sXG4gICAgICAgIHtuYW1lOiAnb2Zmc2V0JywgdHlwZTogJ1VMT05HJywgdmFsdWU6IG9mZnNldCAhPT0gdW5kZWZpbmVkID8gb2Zmc2V0IDogMH0sXG4gICAgICAgIHtuYW1lOiAnbGVuZ3RoJywgdHlwZTogJ1VMT05HJywgdmFsdWU6IGxlbmd0aCAhPT0gdW5kZWZpbmVkID8gbGVuZ3RoIDogMH1cbiAgICBdKTtcbn1cblxuZnVuY3Rpb24gbWFrZVNmbnRUYWJsZSh0YWJsZXMpIHtcbiAgICB2YXIgc2ZudCA9IG5ldyB0YWJsZS5UYWJsZSgnc2ZudCcsIFtcbiAgICAgICAge25hbWU6ICd2ZXJzaW9uJywgdHlwZTogJ1RBRycsIHZhbHVlOiAnT1RUTyd9LFxuICAgICAgICB7bmFtZTogJ251bVRhYmxlcycsIHR5cGU6ICdVU0hPUlQnLCB2YWx1ZTogMH0sXG4gICAgICAgIHtuYW1lOiAnc2VhcmNoUmFuZ2UnLCB0eXBlOiAnVVNIT1JUJywgdmFsdWU6IDB9LFxuICAgICAgICB7bmFtZTogJ2VudHJ5U2VsZWN0b3InLCB0eXBlOiAnVVNIT1JUJywgdmFsdWU6IDB9LFxuICAgICAgICB7bmFtZTogJ3JhbmdlU2hpZnQnLCB0eXBlOiAnVVNIT1JUJywgdmFsdWU6IDB9XG4gICAgXSk7XG4gICAgc2ZudC50YWJsZXMgPSB0YWJsZXM7XG4gICAgc2ZudC5udW1UYWJsZXMgPSB0YWJsZXMubGVuZ3RoO1xuICAgIHZhciBoaWdoZXN0UG93ZXJPZjIgPSBNYXRoLnBvdygyLCBsb2cyKHNmbnQubnVtVGFibGVzKSk7XG4gICAgc2ZudC5zZWFyY2hSYW5nZSA9IDE2ICogaGlnaGVzdFBvd2VyT2YyO1xuICAgIHNmbnQuZW50cnlTZWxlY3RvciA9IGxvZzIoaGlnaGVzdFBvd2VyT2YyKTtcbiAgICBzZm50LnJhbmdlU2hpZnQgPSBzZm50Lm51bVRhYmxlcyAqIDE2IC0gc2ZudC5zZWFyY2hSYW5nZTtcblxuICAgIHZhciByZWNvcmRGaWVsZHMgPSBbXTtcbiAgICB2YXIgdGFibGVGaWVsZHMgPSBbXTtcblxuICAgIHZhciBvZmZzZXQgPSBzZm50LnNpemVPZigpICsgKG1ha2VUYWJsZVJlY29yZCgpLnNpemVPZigpICogc2ZudC5udW1UYWJsZXMpO1xuICAgIHdoaWxlIChvZmZzZXQgJSA0ICE9PSAwKSB7XG4gICAgICAgIG9mZnNldCArPSAxO1xuICAgICAgICB0YWJsZUZpZWxkcy5wdXNoKHtuYW1lOiAncGFkZGluZycsIHR5cGU6ICdCWVRFJywgdmFsdWU6IDB9KTtcbiAgICB9XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRhYmxlcy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICB2YXIgdCA9IHRhYmxlc1tpXTtcbiAgICAgICAgY2hlY2suYXJndW1lbnQodC50YWJsZU5hbWUubGVuZ3RoID09PSA0LCAnVGFibGUgbmFtZScgKyB0LnRhYmxlTmFtZSArICcgaXMgaW52YWxpZC4nKTtcbiAgICAgICAgdmFyIHRhYmxlTGVuZ3RoID0gdC5zaXplT2YoKTtcbiAgICAgICAgdmFyIHRhYmxlUmVjb3JkID0gbWFrZVRhYmxlUmVjb3JkKHQudGFibGVOYW1lLCBjb21wdXRlQ2hlY2tTdW0odC5lbmNvZGUoKSksIG9mZnNldCwgdGFibGVMZW5ndGgpO1xuICAgICAgICByZWNvcmRGaWVsZHMucHVzaCh7bmFtZTogdGFibGVSZWNvcmQudGFnICsgJyBUYWJsZSBSZWNvcmQnLCB0eXBlOiAnUkVDT1JEJywgdmFsdWU6IHRhYmxlUmVjb3JkfSk7XG4gICAgICAgIHRhYmxlRmllbGRzLnB1c2goe25hbWU6IHQudGFibGVOYW1lICsgJyB0YWJsZScsIHR5cGU6ICdSRUNPUkQnLCB2YWx1ZTogdH0pO1xuICAgICAgICBvZmZzZXQgKz0gdGFibGVMZW5ndGg7XG4gICAgICAgIGNoZWNrLmFyZ3VtZW50KCFpc05hTihvZmZzZXQpLCAnU29tZXRoaW5nIHdlbnQgd3JvbmcgY2FsY3VsYXRpbmcgdGhlIG9mZnNldC4nKTtcbiAgICAgICAgd2hpbGUgKG9mZnNldCAlIDQgIT09IDApIHtcbiAgICAgICAgICAgIG9mZnNldCArPSAxO1xuICAgICAgICAgICAgdGFibGVGaWVsZHMucHVzaCh7bmFtZTogJ3BhZGRpbmcnLCB0eXBlOiAnQllURScsIHZhbHVlOiAwfSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBUYWJsZSByZWNvcmRzIG5lZWQgdG8gYmUgc29ydGVkIGFscGhhYmV0aWNhbGx5LlxuICAgIHJlY29yZEZpZWxkcy5zb3J0KGZ1bmN0aW9uKHIxLCByMikge1xuICAgICAgICBpZiAocjEudmFsdWUudGFnID4gcjIudmFsdWUudGFnKSB7XG4gICAgICAgICAgICByZXR1cm4gMTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgc2ZudC5maWVsZHMgPSBzZm50LmZpZWxkcy5jb25jYXQocmVjb3JkRmllbGRzKTtcbiAgICBzZm50LmZpZWxkcyA9IHNmbnQuZmllbGRzLmNvbmNhdCh0YWJsZUZpZWxkcyk7XG4gICAgcmV0dXJuIHNmbnQ7XG59XG5cbi8vIEdldCB0aGUgbWV0cmljcyBmb3IgYSBjaGFyYWN0ZXIuIElmIHRoZSBzdHJpbmcgaGFzIG1vcmUgdGhhbiBvbmUgY2hhcmFjdGVyXG4vLyB0aGlzIGZ1bmN0aW9uIHJldHVybnMgbWV0cmljcyBmb3IgdGhlIGZpcnN0IGF2YWlsYWJsZSBjaGFyYWN0ZXIuXG4vLyBZb3UgY2FuIHByb3ZpZGUgb3B0aW9uYWwgZmFsbGJhY2sgbWV0cmljcyBpZiBubyBjaGFyYWN0ZXJzIGFyZSBhdmFpbGFibGUuXG5mdW5jdGlvbiBtZXRyaWNzRm9yQ2hhcihmb250LCBjaGFycywgbm90Rm91bmRNZXRyaWNzKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaGFycy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICB2YXIgZ2x5cGhJbmRleCA9IGZvbnQuY2hhclRvR2x5cGhJbmRleChjaGFyc1tpXSk7XG4gICAgICAgIGlmIChnbHlwaEluZGV4ID4gMCkge1xuICAgICAgICAgICAgdmFyIGdseXBoID0gZm9udC5nbHlwaHMuZ2V0KGdseXBoSW5kZXgpO1xuICAgICAgICAgICAgcmV0dXJuIGdseXBoLmdldE1ldHJpY3MoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBub3RGb3VuZE1ldHJpY3M7XG59XG5cbmZ1bmN0aW9uIGF2ZXJhZ2UodnMpIHtcbiAgICB2YXIgc3VtID0gMDtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHZzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgIHN1bSArPSB2c1tpXTtcbiAgICB9XG5cbiAgICByZXR1cm4gc3VtIC8gdnMubGVuZ3RoO1xufVxuXG4vLyBDb252ZXJ0IHRoZSBmb250IG9iamVjdCB0byBhIFNGTlQgZGF0YSBzdHJ1Y3R1cmUuXG4vLyBUaGlzIHN0cnVjdHVyZSBjb250YWlucyBhbGwgdGhlIG5lY2Vzc2FyeSB0YWJsZXMgYW5kIG1ldGFkYXRhIHRvIGNyZWF0ZSBhIGJpbmFyeSBPVEYgZmlsZS5cbmZ1bmN0aW9uIGZvbnRUb1NmbnRUYWJsZShmb250KSB7XG4gICAgdmFyIHhNaW5zID0gW107XG4gICAgdmFyIHlNaW5zID0gW107XG4gICAgdmFyIHhNYXhzID0gW107XG4gICAgdmFyIHlNYXhzID0gW107XG4gICAgdmFyIGFkdmFuY2VXaWR0aHMgPSBbXTtcbiAgICB2YXIgbGVmdFNpZGVCZWFyaW5ncyA9IFtdO1xuICAgIHZhciByaWdodFNpZGVCZWFyaW5ncyA9IFtdO1xuICAgIHZhciBmaXJzdENoYXJJbmRleDtcbiAgICB2YXIgbGFzdENoYXJJbmRleCA9IDA7XG4gICAgdmFyIHVsVW5pY29kZVJhbmdlMSA9IDA7XG4gICAgdmFyIHVsVW5pY29kZVJhbmdlMiA9IDA7XG4gICAgdmFyIHVsVW5pY29kZVJhbmdlMyA9IDA7XG4gICAgdmFyIHVsVW5pY29kZVJhbmdlNCA9IDA7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGZvbnQuZ2x5cGhzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgIHZhciBnbHlwaCA9IGZvbnQuZ2x5cGhzLmdldChpKTtcbiAgICAgICAgdmFyIHVuaWNvZGUgPSBnbHlwaC51bmljb2RlIHwgMDtcblxuICAgICAgICBpZiAoaXNOYU4oZ2x5cGguYWR2YW5jZVdpZHRoKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdHbHlwaCAnICsgZ2x5cGgubmFtZSArICcgKCcgKyBpICsgJyk6IGFkdmFuY2VXaWR0aCBpcyBub3QgYSBudW1iZXIuJyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZmlyc3RDaGFySW5kZXggPiB1bmljb2RlIHx8IGZpcnN0Q2hhckluZGV4ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIC8vIGlnbm9yZSAubm90ZGVmIGNoYXJcbiAgICAgICAgICAgIGlmICh1bmljb2RlID4gMCkge1xuICAgICAgICAgICAgICAgIGZpcnN0Q2hhckluZGV4ID0gdW5pY29kZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChsYXN0Q2hhckluZGV4IDwgdW5pY29kZSkge1xuICAgICAgICAgICAgbGFzdENoYXJJbmRleCA9IHVuaWNvZGU7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgcG9zaXRpb24gPSBvczIuZ2V0VW5pY29kZVJhbmdlKHVuaWNvZGUpO1xuICAgICAgICBpZiAocG9zaXRpb24gPCAzMikge1xuICAgICAgICAgICAgdWxVbmljb2RlUmFuZ2UxIHw9IDEgPDwgcG9zaXRpb247XG4gICAgICAgIH0gZWxzZSBpZiAocG9zaXRpb24gPCA2NCkge1xuICAgICAgICAgICAgdWxVbmljb2RlUmFuZ2UyIHw9IDEgPDwgcG9zaXRpb24gLSAzMjtcbiAgICAgICAgfSBlbHNlIGlmIChwb3NpdGlvbiA8IDk2KSB7XG4gICAgICAgICAgICB1bFVuaWNvZGVSYW5nZTMgfD0gMSA8PCBwb3NpdGlvbiAtIDY0O1xuICAgICAgICB9IGVsc2UgaWYgKHBvc2l0aW9uIDwgMTIzKSB7XG4gICAgICAgICAgICB1bFVuaWNvZGVSYW5nZTQgfD0gMSA8PCBwb3NpdGlvbiAtIDk2O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbmljb2RlIHJhbmdlcyBiaXRzID4gMTIzIGFyZSByZXNlcnZlZCBmb3IgaW50ZXJuYWwgdXNhZ2UnKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBTa2lwIG5vbi1pbXBvcnRhbnQgY2hhcmFjdGVycy5cbiAgICAgICAgaWYgKGdseXBoLm5hbWUgPT09ICcubm90ZGVmJykgeyBjb250aW51ZTsgfVxuICAgICAgICB2YXIgbWV0cmljcyA9IGdseXBoLmdldE1ldHJpY3MoKTtcbiAgICAgICAgeE1pbnMucHVzaChtZXRyaWNzLnhNaW4pO1xuICAgICAgICB5TWlucy5wdXNoKG1ldHJpY3MueU1pbik7XG4gICAgICAgIHhNYXhzLnB1c2gobWV0cmljcy54TWF4KTtcbiAgICAgICAgeU1heHMucHVzaChtZXRyaWNzLnlNYXgpO1xuICAgICAgICBsZWZ0U2lkZUJlYXJpbmdzLnB1c2gobWV0cmljcy5sZWZ0U2lkZUJlYXJpbmcpO1xuICAgICAgICByaWdodFNpZGVCZWFyaW5ncy5wdXNoKG1ldHJpY3MucmlnaHRTaWRlQmVhcmluZyk7XG4gICAgICAgIGFkdmFuY2VXaWR0aHMucHVzaChnbHlwaC5hZHZhbmNlV2lkdGgpO1xuICAgIH1cblxuICAgIHZhciBnbG9iYWxzID0ge1xuICAgICAgICB4TWluOiBNYXRoLm1pbi5hcHBseShudWxsLCB4TWlucyksXG4gICAgICAgIHlNaW46IE1hdGgubWluLmFwcGx5KG51bGwsIHlNaW5zKSxcbiAgICAgICAgeE1heDogTWF0aC5tYXguYXBwbHkobnVsbCwgeE1heHMpLFxuICAgICAgICB5TWF4OiBNYXRoLm1heC5hcHBseShudWxsLCB5TWF4cyksXG4gICAgICAgIGFkdmFuY2VXaWR0aE1heDogTWF0aC5tYXguYXBwbHkobnVsbCwgYWR2YW5jZVdpZHRocyksXG4gICAgICAgIGFkdmFuY2VXaWR0aEF2ZzogYXZlcmFnZShhZHZhbmNlV2lkdGhzKSxcbiAgICAgICAgbWluTGVmdFNpZGVCZWFyaW5nOiBNYXRoLm1pbi5hcHBseShudWxsLCBsZWZ0U2lkZUJlYXJpbmdzKSxcbiAgICAgICAgbWF4TGVmdFNpZGVCZWFyaW5nOiBNYXRoLm1heC5hcHBseShudWxsLCBsZWZ0U2lkZUJlYXJpbmdzKSxcbiAgICAgICAgbWluUmlnaHRTaWRlQmVhcmluZzogTWF0aC5taW4uYXBwbHkobnVsbCwgcmlnaHRTaWRlQmVhcmluZ3MpXG4gICAgfTtcbiAgICBnbG9iYWxzLmFzY2VuZGVyID0gZm9udC5hc2NlbmRlcjtcbiAgICBnbG9iYWxzLmRlc2NlbmRlciA9IGZvbnQuZGVzY2VuZGVyO1xuXG4gICAgdmFyIGhlYWRUYWJsZSA9IGhlYWQubWFrZSh7XG4gICAgICAgIGZsYWdzOiAzLCAvLyAwMDAwMDAxMSAoYmFzZWxpbmUgZm9yIGZvbnQgYXQgeT0wOyBsZWZ0IHNpZGViZWFyaW5nIHBvaW50IGF0IHg9MClcbiAgICAgICAgdW5pdHNQZXJFbTogZm9udC51bml0c1BlckVtLFxuICAgICAgICB4TWluOiBnbG9iYWxzLnhNaW4sXG4gICAgICAgIHlNaW46IGdsb2JhbHMueU1pbixcbiAgICAgICAgeE1heDogZ2xvYmFscy54TWF4LFxuICAgICAgICB5TWF4OiBnbG9iYWxzLnlNYXgsXG4gICAgICAgIGxvd2VzdFJlY1BQRU06IDMsXG4gICAgICAgIGNyZWF0ZWRUaW1lc3RhbXA6IGZvbnQuY3JlYXRlZFRpbWVzdGFtcFxuICAgIH0pO1xuXG4gICAgdmFyIGhoZWFUYWJsZSA9IGhoZWEubWFrZSh7XG4gICAgICAgIGFzY2VuZGVyOiBnbG9iYWxzLmFzY2VuZGVyLFxuICAgICAgICBkZXNjZW5kZXI6IGdsb2JhbHMuZGVzY2VuZGVyLFxuICAgICAgICBhZHZhbmNlV2lkdGhNYXg6IGdsb2JhbHMuYWR2YW5jZVdpZHRoTWF4LFxuICAgICAgICBtaW5MZWZ0U2lkZUJlYXJpbmc6IGdsb2JhbHMubWluTGVmdFNpZGVCZWFyaW5nLFxuICAgICAgICBtaW5SaWdodFNpZGVCZWFyaW5nOiBnbG9iYWxzLm1pblJpZ2h0U2lkZUJlYXJpbmcsXG4gICAgICAgIHhNYXhFeHRlbnQ6IGdsb2JhbHMubWF4TGVmdFNpZGVCZWFyaW5nICsgKGdsb2JhbHMueE1heCAtIGdsb2JhbHMueE1pbiksXG4gICAgICAgIG51bWJlck9mSE1ldHJpY3M6IGZvbnQuZ2x5cGhzLmxlbmd0aFxuICAgIH0pO1xuXG4gICAgdmFyIG1heHBUYWJsZSA9IG1heHAubWFrZShmb250LmdseXBocy5sZW5ndGgpO1xuXG4gICAgdmFyIG9zMlRhYmxlID0gb3MyLm1ha2UoT2JqZWN0LmFzc2lnbih7XG4gICAgICAgIHhBdmdDaGFyV2lkdGg6IE1hdGgucm91bmQoZ2xvYmFscy5hZHZhbmNlV2lkdGhBdmcpLFxuICAgICAgICB1c0ZpcnN0Q2hhckluZGV4OiBmaXJzdENoYXJJbmRleCxcbiAgICAgICAgdXNMYXN0Q2hhckluZGV4OiBsYXN0Q2hhckluZGV4LFxuICAgICAgICB1bFVuaWNvZGVSYW5nZTE6IHVsVW5pY29kZVJhbmdlMSxcbiAgICAgICAgdWxVbmljb2RlUmFuZ2UyOiB1bFVuaWNvZGVSYW5nZTIsXG4gICAgICAgIHVsVW5pY29kZVJhbmdlMzogdWxVbmljb2RlUmFuZ2UzLFxuICAgICAgICB1bFVuaWNvZGVSYW5nZTQ6IHVsVW5pY29kZVJhbmdlNCxcbiAgICAgICAgLy8gU2VlIGh0dHA6Ly90eXBvcGhpbGUuY29tL25vZGUvMTMwODEgZm9yIG1vcmUgaW5mbyBvbiB2ZXJ0aWNhbCBtZXRyaWNzLlxuICAgICAgICAvLyBXZSBnZXQgbWV0cmljcyBmb3IgdHlwaWNhbCBjaGFyYWN0ZXJzIChzdWNoIGFzIFwieFwiIGZvciB4SGVpZ2h0KS5cbiAgICAgICAgLy8gV2UgcHJvdmlkZSBzb21lIGZhbGxiYWNrIGNoYXJhY3RlcnMgaWYgY2hhcmFjdGVycyBhcmUgdW5hdmFpbGFibGU6IHRoZWlyXG4gICAgICAgIC8vIG9yZGVyaW5nIHdhcyBjaG9zZW4gZXhwZXJpbWVudGFsbHkuXG4gICAgICAgIHNUeXBvQXNjZW5kZXI6IGdsb2JhbHMuYXNjZW5kZXIsXG4gICAgICAgIHNUeXBvRGVzY2VuZGVyOiBnbG9iYWxzLmRlc2NlbmRlcixcbiAgICAgICAgc1R5cG9MaW5lR2FwOiAwLFxuICAgICAgICB1c1dpbkFzY2VudDogZ2xvYmFscy55TWF4LFxuICAgICAgICB1c1dpbkRlc2NlbnQ6IE1hdGguYWJzKGdsb2JhbHMueU1pbiksXG4gICAgICAgIHVsQ29kZVBhZ2VSYW5nZTE6IDEsIC8vIEZJWE1FOiBoYXJkLWNvZGUgTGF0aW4gMSBzdXBwb3J0IGZvciBub3dcbiAgICAgICAgc3hIZWlnaHQ6IG1ldHJpY3NGb3JDaGFyKGZvbnQsICd4eXZ3Jywge3lNYXg6IE1hdGgucm91bmQoZ2xvYmFscy5hc2NlbmRlciAvIDIpfSkueU1heCxcbiAgICAgICAgc0NhcEhlaWdodDogbWV0cmljc0ZvckNoYXIoZm9udCwgJ0hJS0xFRkpNTlRaQkRQUkFHT1FTVVZXWFknLCBnbG9iYWxzKS55TWF4LFxuICAgICAgICB1c0RlZmF1bHRDaGFyOiBmb250Lmhhc0NoYXIoJyAnKSA/IDMyIDogMCwgLy8gVXNlIHNwYWNlIGFzIHRoZSBkZWZhdWx0IGNoYXJhY3RlciwgaWYgYXZhaWxhYmxlLlxuICAgICAgICB1c0JyZWFrQ2hhcjogZm9udC5oYXNDaGFyKCcgJykgPyAzMiA6IDAsIC8vIFVzZSBzcGFjZSBhcyB0aGUgYnJlYWsgY2hhcmFjdGVyLCBpZiBhdmFpbGFibGUuXG4gICAgfSwgZm9udC50YWJsZXMub3MyKSk7XG5cbiAgICB2YXIgaG10eFRhYmxlID0gaG10eC5tYWtlKGZvbnQuZ2x5cGhzKTtcbiAgICB2YXIgY21hcFRhYmxlID0gY21hcC5tYWtlKGZvbnQuZ2x5cGhzKTtcblxuICAgIHZhciBlbmdsaXNoRmFtaWx5TmFtZSA9IGZvbnQuZ2V0RW5nbGlzaE5hbWUoJ2ZvbnRGYW1pbHknKTtcbiAgICB2YXIgZW5nbGlzaFN0eWxlTmFtZSA9IGZvbnQuZ2V0RW5nbGlzaE5hbWUoJ2ZvbnRTdWJmYW1pbHknKTtcbiAgICB2YXIgZW5nbGlzaEZ1bGxOYW1lID0gZW5nbGlzaEZhbWlseU5hbWUgKyAnICcgKyBlbmdsaXNoU3R5bGVOYW1lO1xuICAgIHZhciBwb3N0U2NyaXB0TmFtZSA9IGZvbnQuZ2V0RW5nbGlzaE5hbWUoJ3Bvc3RTY3JpcHROYW1lJyk7XG4gICAgaWYgKCFwb3N0U2NyaXB0TmFtZSkge1xuICAgICAgICBwb3N0U2NyaXB0TmFtZSA9IGVuZ2xpc2hGYW1pbHlOYW1lLnJlcGxhY2UoL1xccy9nLCAnJykgKyAnLScgKyBlbmdsaXNoU3R5bGVOYW1lO1xuICAgIH1cblxuICAgIHZhciBuYW1lcyA9IHt9O1xuICAgIGZvciAodmFyIG4gaW4gZm9udC5uYW1lcykge1xuICAgICAgICBuYW1lc1tuXSA9IGZvbnQubmFtZXNbbl07XG4gICAgfVxuXG4gICAgaWYgKCFuYW1lcy51bmlxdWVJRCkge1xuICAgICAgICBuYW1lcy51bmlxdWVJRCA9IHtlbjogZm9udC5nZXRFbmdsaXNoTmFtZSgnbWFudWZhY3R1cmVyJykgKyAnOicgKyBlbmdsaXNoRnVsbE5hbWV9O1xuICAgIH1cblxuICAgIGlmICghbmFtZXMucG9zdFNjcmlwdE5hbWUpIHtcbiAgICAgICAgbmFtZXMucG9zdFNjcmlwdE5hbWUgPSB7ZW46IHBvc3RTY3JpcHROYW1lfTtcbiAgICB9XG5cbiAgICBpZiAoIW5hbWVzLnByZWZlcnJlZEZhbWlseSkge1xuICAgICAgICBuYW1lcy5wcmVmZXJyZWRGYW1pbHkgPSBmb250Lm5hbWVzLmZvbnRGYW1pbHk7XG4gICAgfVxuXG4gICAgaWYgKCFuYW1lcy5wcmVmZXJyZWRTdWJmYW1pbHkpIHtcbiAgICAgICAgbmFtZXMucHJlZmVycmVkU3ViZmFtaWx5ID0gZm9udC5uYW1lcy5mb250U3ViZmFtaWx5O1xuICAgIH1cblxuICAgIHZhciBsYW5ndWFnZVRhZ3MgPSBbXTtcbiAgICB2YXIgbmFtZVRhYmxlID0gX25hbWUubWFrZShuYW1lcywgbGFuZ3VhZ2VUYWdzKTtcbiAgICB2YXIgbHRhZ1RhYmxlID0gKGxhbmd1YWdlVGFncy5sZW5ndGggPiAwID8gbHRhZy5tYWtlKGxhbmd1YWdlVGFncykgOiB1bmRlZmluZWQpO1xuXG4gICAgdmFyIHBvc3RUYWJsZSA9IHBvc3QubWFrZSgpO1xuICAgIHZhciBjZmZUYWJsZSA9IGNmZi5tYWtlKGZvbnQuZ2x5cGhzLCB7XG4gICAgICAgIHZlcnNpb246IGZvbnQuZ2V0RW5nbGlzaE5hbWUoJ3ZlcnNpb24nKSxcbiAgICAgICAgZnVsbE5hbWU6IGVuZ2xpc2hGdWxsTmFtZSxcbiAgICAgICAgZmFtaWx5TmFtZTogZW5nbGlzaEZhbWlseU5hbWUsXG4gICAgICAgIHdlaWdodE5hbWU6IGVuZ2xpc2hTdHlsZU5hbWUsXG4gICAgICAgIHBvc3RTY3JpcHROYW1lOiBwb3N0U2NyaXB0TmFtZSxcbiAgICAgICAgdW5pdHNQZXJFbTogZm9udC51bml0c1BlckVtLFxuICAgICAgICBmb250QkJveDogWzAsIGdsb2JhbHMueU1pbiwgZ2xvYmFscy5hc2NlbmRlciwgZ2xvYmFscy5hZHZhbmNlV2lkdGhNYXhdXG4gICAgfSk7XG5cbiAgICB2YXIgbWV0YVRhYmxlID0gKGZvbnQubWV0YXMgJiYgT2JqZWN0LmtleXMoZm9udC5tZXRhcykubGVuZ3RoID4gMCkgPyBtZXRhLm1ha2UoZm9udC5tZXRhcykgOiB1bmRlZmluZWQ7XG5cbiAgICAvLyBUaGUgb3JkZXIgZG9lcyBub3QgbWF0dGVyIGJlY2F1c2UgbWFrZVNmbnRUYWJsZSgpIHdpbGwgc29ydCB0aGVtLlxuICAgIHZhciB0YWJsZXMgPSBbaGVhZFRhYmxlLCBoaGVhVGFibGUsIG1heHBUYWJsZSwgb3MyVGFibGUsIG5hbWVUYWJsZSwgY21hcFRhYmxlLCBwb3N0VGFibGUsIGNmZlRhYmxlLCBobXR4VGFibGVdO1xuICAgIGlmIChsdGFnVGFibGUpIHtcbiAgICAgICAgdGFibGVzLnB1c2gobHRhZ1RhYmxlKTtcbiAgICB9XG4gICAgLy8gT3B0aW9uYWwgdGFibGVzXG4gICAgaWYgKGZvbnQudGFibGVzLmdzdWIpIHtcbiAgICAgICAgdGFibGVzLnB1c2goZ3N1Yi5tYWtlKGZvbnQudGFibGVzLmdzdWIpKTtcbiAgICB9XG4gICAgaWYgKG1ldGFUYWJsZSkge1xuICAgICAgICB0YWJsZXMucHVzaChtZXRhVGFibGUpO1xuICAgIH1cblxuICAgIHZhciBzZm50VGFibGUgPSBtYWtlU2ZudFRhYmxlKHRhYmxlcyk7XG5cbiAgICAvLyBDb21wdXRlIHRoZSBmb250J3MgY2hlY2tTdW0gYW5kIHN0b3JlIGl0IGluIGhlYWQuY2hlY2tTdW1BZGp1c3RtZW50LlxuICAgIHZhciBieXRlcyA9IHNmbnRUYWJsZS5lbmNvZGUoKTtcbiAgICB2YXIgY2hlY2tTdW0gPSBjb21wdXRlQ2hlY2tTdW0oYnl0ZXMpO1xuICAgIHZhciB0YWJsZUZpZWxkcyA9IHNmbnRUYWJsZS5maWVsZHM7XG4gICAgdmFyIGNoZWNrU3VtQWRqdXN0ZWQgPSBmYWxzZTtcbiAgICBmb3IgKHZhciBpJDEgPSAwOyBpJDEgPCB0YWJsZUZpZWxkcy5sZW5ndGg7IGkkMSArPSAxKSB7XG4gICAgICAgIGlmICh0YWJsZUZpZWxkc1tpJDFdLm5hbWUgPT09ICdoZWFkIHRhYmxlJykge1xuICAgICAgICAgICAgdGFibGVGaWVsZHNbaSQxXS52YWx1ZS5jaGVja1N1bUFkanVzdG1lbnQgPSAweEIxQjBBRkJBIC0gY2hlY2tTdW07XG4gICAgICAgICAgICBjaGVja1N1bUFkanVzdGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgaWYgKCFjaGVja1N1bUFkanVzdGVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignQ291bGQgbm90IGZpbmQgaGVhZCB0YWJsZSB3aXRoIGNoZWNrU3VtIHRvIGFkanVzdC4nKTtcbiAgICB9XG5cbiAgICByZXR1cm4gc2ZudFRhYmxlO1xufVxuXG52YXIgc2ZudCA9IHsgbWFrZTogbWFrZVNmbnRUYWJsZSwgZm9udFRvVGFibGU6IGZvbnRUb1NmbnRUYWJsZSwgY29tcHV0ZUNoZWNrU3VtOiBjb21wdXRlQ2hlY2tTdW0gfTtcblxuLy8gVGhlIExheW91dCBvYmplY3QgaXMgdGhlIHByb3RvdHlwZSBvZiBTdWJzdGl0dXRpb24gb2JqZWN0cywgYW5kIHByb3ZpZGVzXG5cbmZ1bmN0aW9uIHNlYXJjaFRhZyhhcnIsIHRhZykge1xuICAgIC8qIGpzaGludCBiaXR3aXNlOiBmYWxzZSAqL1xuICAgIHZhciBpbWluID0gMDtcbiAgICB2YXIgaW1heCA9IGFyci5sZW5ndGggLSAxO1xuICAgIHdoaWxlIChpbWluIDw9IGltYXgpIHtcbiAgICAgICAgdmFyIGltaWQgPSAoaW1pbiArIGltYXgpID4+PiAxO1xuICAgICAgICB2YXIgdmFsID0gYXJyW2ltaWRdLnRhZztcbiAgICAgICAgaWYgKHZhbCA9PT0gdGFnKSB7XG4gICAgICAgICAgICByZXR1cm4gaW1pZDtcbiAgICAgICAgfSBlbHNlIGlmICh2YWwgPCB0YWcpIHtcbiAgICAgICAgICAgIGltaW4gPSBpbWlkICsgMTtcbiAgICAgICAgfSBlbHNlIHsgaW1heCA9IGltaWQgLSAxOyB9XG4gICAgfVxuICAgIC8vIE5vdCBmb3VuZDogcmV0dXJuIC0xLWluc2VydGlvbiBwb2ludFxuICAgIHJldHVybiAtaW1pbiAtIDE7XG59XG5cbmZ1bmN0aW9uIGJpblNlYXJjaChhcnIsIHZhbHVlKSB7XG4gICAgLyoganNoaW50IGJpdHdpc2U6IGZhbHNlICovXG4gICAgdmFyIGltaW4gPSAwO1xuICAgIHZhciBpbWF4ID0gYXJyLmxlbmd0aCAtIDE7XG4gICAgd2hpbGUgKGltaW4gPD0gaW1heCkge1xuICAgICAgICB2YXIgaW1pZCA9IChpbWluICsgaW1heCkgPj4+IDE7XG4gICAgICAgIHZhciB2YWwgPSBhcnJbaW1pZF07XG4gICAgICAgIGlmICh2YWwgPT09IHZhbHVlKSB7XG4gICAgICAgICAgICByZXR1cm4gaW1pZDtcbiAgICAgICAgfSBlbHNlIGlmICh2YWwgPCB2YWx1ZSkge1xuICAgICAgICAgICAgaW1pbiA9IGltaWQgKyAxO1xuICAgICAgICB9IGVsc2UgeyBpbWF4ID0gaW1pZCAtIDE7IH1cbiAgICB9XG4gICAgLy8gTm90IGZvdW5kOiByZXR1cm4gLTEtaW5zZXJ0aW9uIHBvaW50XG4gICAgcmV0dXJuIC1pbWluIC0gMTtcbn1cblxuLy8gYmluYXJ5IHNlYXJjaCBpbiBhIGxpc3Qgb2YgcmFuZ2VzIChjb3ZlcmFnZSwgY2xhc3MgZGVmaW5pdGlvbilcbmZ1bmN0aW9uIHNlYXJjaFJhbmdlKHJhbmdlcywgdmFsdWUpIHtcbiAgICAvLyBqc2hpbnQgYml0d2lzZTogZmFsc2VcbiAgICB2YXIgcmFuZ2U7XG4gICAgdmFyIGltaW4gPSAwO1xuICAgIHZhciBpbWF4ID0gcmFuZ2VzLmxlbmd0aCAtIDE7XG4gICAgd2hpbGUgKGltaW4gPD0gaW1heCkge1xuICAgICAgICB2YXIgaW1pZCA9IChpbWluICsgaW1heCkgPj4+IDE7XG4gICAgICAgIHJhbmdlID0gcmFuZ2VzW2ltaWRdO1xuICAgICAgICB2YXIgc3RhcnQgPSByYW5nZS5zdGFydDtcbiAgICAgICAgaWYgKHN0YXJ0ID09PSB2YWx1ZSkge1xuICAgICAgICAgICAgcmV0dXJuIHJhbmdlO1xuICAgICAgICB9IGVsc2UgaWYgKHN0YXJ0IDwgdmFsdWUpIHtcbiAgICAgICAgICAgIGltaW4gPSBpbWlkICsgMTtcbiAgICAgICAgfSBlbHNlIHsgaW1heCA9IGltaWQgLSAxOyB9XG4gICAgfVxuICAgIGlmIChpbWluID4gMCkge1xuICAgICAgICByYW5nZSA9IHJhbmdlc1tpbWluIC0gMV07XG4gICAgICAgIGlmICh2YWx1ZSA+IHJhbmdlLmVuZCkgeyByZXR1cm4gMDsgfVxuICAgICAgICByZXR1cm4gcmFuZ2U7XG4gICAgfVxufVxuXG4vKipcbiAqIEBleHBvcnRzIG9wZW50eXBlLkxheW91dFxuICogQGNsYXNzXG4gKi9cbmZ1bmN0aW9uIExheW91dChmb250LCB0YWJsZU5hbWUpIHtcbiAgICB0aGlzLmZvbnQgPSBmb250O1xuICAgIHRoaXMudGFibGVOYW1lID0gdGFibGVOYW1lO1xufVxuXG5MYXlvdXQucHJvdG90eXBlID0ge1xuXG4gICAgLyoqXG4gICAgICogQmluYXJ5IHNlYXJjaCBhbiBvYmplY3QgYnkgXCJ0YWdcIiBwcm9wZXJ0eVxuICAgICAqIEBpbnN0YW5jZVxuICAgICAqIEBmdW5jdGlvbiBzZWFyY2hUYWdcbiAgICAgKiBAbWVtYmVyb2Ygb3BlbnR5cGUuTGF5b3V0XG4gICAgICogQHBhcmFtICB7QXJyYXl9IGFyclxuICAgICAqIEBwYXJhbSAge3N0cmluZ30gdGFnXG4gICAgICogQHJldHVybiB7bnVtYmVyfVxuICAgICAqL1xuICAgIHNlYXJjaFRhZzogc2VhcmNoVGFnLFxuXG4gICAgLyoqXG4gICAgICogQmluYXJ5IHNlYXJjaCBpbiBhIGxpc3Qgb2YgbnVtYmVyc1xuICAgICAqIEBpbnN0YW5jZVxuICAgICAqIEBmdW5jdGlvbiBiaW5TZWFyY2hcbiAgICAgKiBAbWVtYmVyb2Ygb3BlbnR5cGUuTGF5b3V0XG4gICAgICogQHBhcmFtICB7QXJyYXl9IGFyclxuICAgICAqIEBwYXJhbSAge251bWJlcn0gdmFsdWVcbiAgICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAgICovXG4gICAgYmluU2VhcmNoOiBiaW5TZWFyY2gsXG5cbiAgICAvKipcbiAgICAgKiBHZXQgb3IgY3JlYXRlIHRoZSBMYXlvdXQgdGFibGUgKEdTVUIsIEdQT1MgZXRjKS5cbiAgICAgKiBAcGFyYW0gIHtib29sZWFufSBjcmVhdGUgLSBXaGV0aGVyIHRvIGNyZWF0ZSBhIG5ldyBvbmUuXG4gICAgICogQHJldHVybiB7T2JqZWN0fSBUaGUgR1NVQiBvciBHUE9TIHRhYmxlLlxuICAgICAqL1xuICAgIGdldFRhYmxlOiBmdW5jdGlvbihjcmVhdGUpIHtcbiAgICAgICAgdmFyIGxheW91dCA9IHRoaXMuZm9udC50YWJsZXNbdGhpcy50YWJsZU5hbWVdO1xuICAgICAgICBpZiAoIWxheW91dCAmJiBjcmVhdGUpIHtcbiAgICAgICAgICAgIGxheW91dCA9IHRoaXMuZm9udC50YWJsZXNbdGhpcy50YWJsZU5hbWVdID0gdGhpcy5jcmVhdGVEZWZhdWx0VGFibGUoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbGF5b3V0O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGFsbCBzY3JpcHRzIGluIHRoZSBzdWJzdGl0dXRpb24gdGFibGUuXG4gICAgICogQGluc3RhbmNlXG4gICAgICogQHJldHVybiB7QXJyYXl9XG4gICAgICovXG4gICAgZ2V0U2NyaXB0TmFtZXM6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgbGF5b3V0ID0gdGhpcy5nZXRUYWJsZSgpO1xuICAgICAgICBpZiAoIWxheW91dCkgeyByZXR1cm4gW107IH1cbiAgICAgICAgcmV0dXJuIGxheW91dC5zY3JpcHRzLm1hcChmdW5jdGlvbihzY3JpcHQpIHtcbiAgICAgICAgICAgIHJldHVybiBzY3JpcHQudGFnO1xuICAgICAgICB9KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgYmVzdCBiZXQgZm9yIGEgc2NyaXB0IG5hbWUuXG4gICAgICogUmV0dXJucyAnREZMVCcgaWYgaXQgZXhpc3RzLlxuICAgICAqIElmIG5vdCwgcmV0dXJucyAnbGF0bicgaWYgaXQgZXhpc3RzLlxuICAgICAqIElmIG5laXRoZXIgZXhpc3QsIHJldHVybnMgdW5kZWZpbmVkLlxuICAgICAqL1xuICAgIGdldERlZmF1bHRTY3JpcHROYW1lOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGxheW91dCA9IHRoaXMuZ2V0VGFibGUoKTtcbiAgICAgICAgaWYgKCFsYXlvdXQpIHsgcmV0dXJuOyB9XG4gICAgICAgIHZhciBoYXNMYXRuID0gZmFsc2U7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGF5b3V0LnNjcmlwdHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBuYW1lID0gbGF5b3V0LnNjcmlwdHNbaV0udGFnO1xuICAgICAgICAgICAgaWYgKG5hbWUgPT09ICdERkxUJykgeyByZXR1cm4gbmFtZTsgfVxuICAgICAgICAgICAgaWYgKG5hbWUgPT09ICdsYXRuJykgeyBoYXNMYXRuID0gdHJ1ZTsgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChoYXNMYXRuKSB7IHJldHVybiAnbGF0bic7IH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhbGwgTGFuZ1N5c1JlY29yZHMgaW4gdGhlIGdpdmVuIHNjcmlwdC5cbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3NjcmlwdD0nREZMVCddXG4gICAgICogQHBhcmFtIHtib29sZWFufSBjcmVhdGUgLSBmb3JjZXMgdGhlIGNyZWF0aW9uIG9mIHRoaXMgc2NyaXB0IHRhYmxlIGlmIGl0IGRvZXNuJ3QgZXhpc3QuXG4gICAgICogQHJldHVybiB7T2JqZWN0fSBBbiBvYmplY3Qgd2l0aCB0YWcgYW5kIHNjcmlwdCBwcm9wZXJ0aWVzLlxuICAgICAqL1xuICAgIGdldFNjcmlwdFRhYmxlOiBmdW5jdGlvbihzY3JpcHQsIGNyZWF0ZSkge1xuICAgICAgICB2YXIgbGF5b3V0ID0gdGhpcy5nZXRUYWJsZShjcmVhdGUpO1xuICAgICAgICBpZiAobGF5b3V0KSB7XG4gICAgICAgICAgICBzY3JpcHQgPSBzY3JpcHQgfHwgJ0RGTFQnO1xuICAgICAgICAgICAgdmFyIHNjcmlwdHMgPSBsYXlvdXQuc2NyaXB0cztcbiAgICAgICAgICAgIHZhciBwb3MgPSBzZWFyY2hUYWcobGF5b3V0LnNjcmlwdHMsIHNjcmlwdCk7XG4gICAgICAgICAgICBpZiAocG9zID49IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gc2NyaXB0c1twb3NdLnNjcmlwdDtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoY3JlYXRlKSB7XG4gICAgICAgICAgICAgICAgdmFyIHNjciA9IHtcbiAgICAgICAgICAgICAgICAgICAgdGFnOiBzY3JpcHQsXG4gICAgICAgICAgICAgICAgICAgIHNjcmlwdDoge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGVmYXVsdExhbmdTeXM6IHtyZXNlcnZlZDogMCwgcmVxRmVhdHVyZUluZGV4OiAweGZmZmYsIGZlYXR1cmVJbmRleGVzOiBbXX0sXG4gICAgICAgICAgICAgICAgICAgICAgICBsYW5nU3lzUmVjb3JkczogW11cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgc2NyaXB0cy5zcGxpY2UoLTEgLSBwb3MsIDAsIHNjcik7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHNjci5zY3JpcHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIGxhbmd1YWdlIHN5c3RlbSB0YWJsZVxuICAgICAqIEBpbnN0YW5jZVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbc2NyaXB0PSdERkxUJ11cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW2xhbmd1YWdlPSdkbGZ0J11cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IGNyZWF0ZSAtIGZvcmNlcyB0aGUgY3JlYXRpb24gb2YgdGhpcyBsYW5nU3lzVGFibGUgaWYgaXQgZG9lc24ndCBleGlzdC5cbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9XG4gICAgICovXG4gICAgZ2V0TGFuZ1N5c1RhYmxlOiBmdW5jdGlvbihzY3JpcHQsIGxhbmd1YWdlLCBjcmVhdGUpIHtcbiAgICAgICAgdmFyIHNjcmlwdFRhYmxlID0gdGhpcy5nZXRTY3JpcHRUYWJsZShzY3JpcHQsIGNyZWF0ZSk7XG4gICAgICAgIGlmIChzY3JpcHRUYWJsZSkge1xuICAgICAgICAgICAgaWYgKCFsYW5ndWFnZSB8fCBsYW5ndWFnZSA9PT0gJ2RmbHQnIHx8IGxhbmd1YWdlID09PSAnREZMVCcpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gc2NyaXB0VGFibGUuZGVmYXVsdExhbmdTeXM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgcG9zID0gc2VhcmNoVGFnKHNjcmlwdFRhYmxlLmxhbmdTeXNSZWNvcmRzLCBsYW5ndWFnZSk7XG4gICAgICAgICAgICBpZiAocG9zID49IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gc2NyaXB0VGFibGUubGFuZ1N5c1JlY29yZHNbcG9zXS5sYW5nU3lzO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChjcmVhdGUpIHtcbiAgICAgICAgICAgICAgICB2YXIgbGFuZ1N5c1JlY29yZCA9IHtcbiAgICAgICAgICAgICAgICAgICAgdGFnOiBsYW5ndWFnZSxcbiAgICAgICAgICAgICAgICAgICAgbGFuZ1N5czoge3Jlc2VydmVkOiAwLCByZXFGZWF0dXJlSW5kZXg6IDB4ZmZmZiwgZmVhdHVyZUluZGV4ZXM6IFtdfVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgc2NyaXB0VGFibGUubGFuZ1N5c1JlY29yZHMuc3BsaWNlKC0xIC0gcG9zLCAwLCBsYW5nU3lzUmVjb3JkKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gbGFuZ1N5c1JlY29yZC5sYW5nU3lzO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEdldCBhIHNwZWNpZmljIGZlYXR1cmUgdGFibGUuXG4gICAgICogQGluc3RhbmNlXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtzY3JpcHQ9J0RGTFQnXVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbbGFuZ3VhZ2U9J2RsZnQnXVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBmZWF0dXJlIC0gT25lIG9mIHRoZSBjb2RlcyBsaXN0ZWQgYXQgaHR0cHM6Ly93d3cubWljcm9zb2Z0LmNvbS90eXBvZ3JhcGh5L09UU1BFQy9mZWF0dXJlbGlzdC5odG1cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IGNyZWF0ZSAtIGZvcmNlcyB0aGUgY3JlYXRpb24gb2YgdGhlIGZlYXR1cmUgdGFibGUgaWYgaXQgZG9lc24ndCBleGlzdC5cbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9XG4gICAgICovXG4gICAgZ2V0RmVhdHVyZVRhYmxlOiBmdW5jdGlvbihzY3JpcHQsIGxhbmd1YWdlLCBmZWF0dXJlLCBjcmVhdGUpIHtcbiAgICAgICAgdmFyIGxhbmdTeXNUYWJsZSA9IHRoaXMuZ2V0TGFuZ1N5c1RhYmxlKHNjcmlwdCwgbGFuZ3VhZ2UsIGNyZWF0ZSk7XG4gICAgICAgIGlmIChsYW5nU3lzVGFibGUpIHtcbiAgICAgICAgICAgIHZhciBmZWF0dXJlUmVjb3JkO1xuICAgICAgICAgICAgdmFyIGZlYXRJbmRleGVzID0gbGFuZ1N5c1RhYmxlLmZlYXR1cmVJbmRleGVzO1xuICAgICAgICAgICAgdmFyIGFsbEZlYXR1cmVzID0gdGhpcy5mb250LnRhYmxlc1t0aGlzLnRhYmxlTmFtZV0uZmVhdHVyZXM7XG4gICAgICAgICAgICAvLyBUaGUgRmVhdHVyZUluZGV4IGFycmF5IG9mIGluZGljZXMgaXMgaW4gYXJiaXRyYXJ5IG9yZGVyLFxuICAgICAgICAgICAgLy8gZXZlbiBpZiBhbGxGZWF0dXJlcyBpcyBzb3J0ZWQgYWxwaGFiZXRpY2FsbHkgYnkgZmVhdHVyZSB0YWcuXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGZlYXRJbmRleGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgZmVhdHVyZVJlY29yZCA9IGFsbEZlYXR1cmVzW2ZlYXRJbmRleGVzW2ldXTtcbiAgICAgICAgICAgICAgICBpZiAoZmVhdHVyZVJlY29yZC50YWcgPT09IGZlYXR1cmUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZlYXR1cmVSZWNvcmQuZmVhdHVyZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoY3JlYXRlKSB7XG4gICAgICAgICAgICAgICAgdmFyIGluZGV4ID0gYWxsRmVhdHVyZXMubGVuZ3RoO1xuICAgICAgICAgICAgICAgIC8vIEF1dG9tYXRpYyBvcmRlcmluZyBvZiBmZWF0dXJlcyB3b3VsZCByZXF1aXJlIHRvIHNoaWZ0IGZlYXR1cmUgaW5kZXhlcyBpbiB0aGUgc2NyaXB0IGxpc3QuXG4gICAgICAgICAgICAgICAgY2hlY2suYXNzZXJ0KGluZGV4ID09PSAwIHx8IGZlYXR1cmUgPj0gYWxsRmVhdHVyZXNbaW5kZXggLSAxXS50YWcsICdGZWF0dXJlcyBtdXN0IGJlIGFkZGVkIGluIGFscGhhYmV0aWNhbCBvcmRlci4nKTtcbiAgICAgICAgICAgICAgICBmZWF0dXJlUmVjb3JkID0ge1xuICAgICAgICAgICAgICAgICAgICB0YWc6IGZlYXR1cmUsXG4gICAgICAgICAgICAgICAgICAgIGZlYXR1cmU6IHsgcGFyYW1zOiAwLCBsb29rdXBMaXN0SW5kZXhlczogW10gfVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgYWxsRmVhdHVyZXMucHVzaChmZWF0dXJlUmVjb3JkKTtcbiAgICAgICAgICAgICAgICBmZWF0SW5kZXhlcy5wdXNoKGluZGV4KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmVhdHVyZVJlY29yZC5mZWF0dXJlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgbG9va3VwIHRhYmxlcyBvZiBhIGdpdmVuIHR5cGUgZm9yIGEgc2NyaXB0L2xhbmd1YWdlL2ZlYXR1cmUuXG4gICAgICogQGluc3RhbmNlXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtzY3JpcHQ9J0RGTFQnXVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbbGFuZ3VhZ2U9J2RsZnQnXVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBmZWF0dXJlIC0gNC1sZXR0ZXIgZmVhdHVyZSBjb2RlXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGxvb2t1cFR5cGUgLSAxIHRvIDlcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IGNyZWF0ZSAtIGZvcmNlcyB0aGUgY3JlYXRpb24gb2YgdGhlIGxvb2t1cCB0YWJsZSBpZiBpdCBkb2Vzbid0IGV4aXN0LCB3aXRoIG5vIHN1YnRhYmxlcy5cbiAgICAgKiBAcmV0dXJuIHtPYmplY3RbXX1cbiAgICAgKi9cbiAgICBnZXRMb29rdXBUYWJsZXM6IGZ1bmN0aW9uKHNjcmlwdCwgbGFuZ3VhZ2UsIGZlYXR1cmUsIGxvb2t1cFR5cGUsIGNyZWF0ZSkge1xuICAgICAgICB2YXIgZmVhdHVyZVRhYmxlID0gdGhpcy5nZXRGZWF0dXJlVGFibGUoc2NyaXB0LCBsYW5ndWFnZSwgZmVhdHVyZSwgY3JlYXRlKTtcbiAgICAgICAgdmFyIHRhYmxlcyA9IFtdO1xuICAgICAgICBpZiAoZmVhdHVyZVRhYmxlKSB7XG4gICAgICAgICAgICB2YXIgbG9va3VwVGFibGU7XG4gICAgICAgICAgICB2YXIgbG9va3VwTGlzdEluZGV4ZXMgPSBmZWF0dXJlVGFibGUubG9va3VwTGlzdEluZGV4ZXM7XG4gICAgICAgICAgICB2YXIgYWxsTG9va3VwcyA9IHRoaXMuZm9udC50YWJsZXNbdGhpcy50YWJsZU5hbWVdLmxvb2t1cHM7XG4gICAgICAgICAgICAvLyBsb29rdXBMaXN0SW5kZXhlcyBhcmUgaW4gbm8gcGFydGljdWxhciBvcmRlciwgc28gdXNlIG5haXZlIHNlYXJjaC5cbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbG9va3VwTGlzdEluZGV4ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBsb29rdXBUYWJsZSA9IGFsbExvb2t1cHNbbG9va3VwTGlzdEluZGV4ZXNbaV1dO1xuICAgICAgICAgICAgICAgIGlmIChsb29rdXBUYWJsZS5sb29rdXBUeXBlID09PSBsb29rdXBUeXBlKSB7XG4gICAgICAgICAgICAgICAgICAgIHRhYmxlcy5wdXNoKGxvb2t1cFRhYmxlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGFibGVzLmxlbmd0aCA9PT0gMCAmJiBjcmVhdGUpIHtcbiAgICAgICAgICAgICAgICBsb29rdXBUYWJsZSA9IHtcbiAgICAgICAgICAgICAgICAgICAgbG9va3VwVHlwZTogbG9va3VwVHlwZSxcbiAgICAgICAgICAgICAgICAgICAgbG9va3VwRmxhZzogMCxcbiAgICAgICAgICAgICAgICAgICAgc3VidGFibGVzOiBbXSxcbiAgICAgICAgICAgICAgICAgICAgbWFya0ZpbHRlcmluZ1NldDogdW5kZWZpbmVkXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB2YXIgaW5kZXggPSBhbGxMb29rdXBzLmxlbmd0aDtcbiAgICAgICAgICAgICAgICBhbGxMb29rdXBzLnB1c2gobG9va3VwVGFibGUpO1xuICAgICAgICAgICAgICAgIGxvb2t1cExpc3RJbmRleGVzLnB1c2goaW5kZXgpO1xuICAgICAgICAgICAgICAgIHJldHVybiBbbG9va3VwVGFibGVdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0YWJsZXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEZpbmQgYSBnbHlwaCBpbiBhIGNsYXNzIGRlZmluaXRpb24gdGFibGVcbiAgICAgKiBodHRwczovL2RvY3MubWljcm9zb2Z0LmNvbS9lbi11cy90eXBvZ3JhcGh5L29wZW50eXBlL3NwZWMvY2hhcHRlcjIjY2xhc3MtZGVmaW5pdGlvbi10YWJsZVxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBjbGFzc0RlZlRhYmxlIC0gYW4gT3BlblR5cGUgTGF5b3V0IGNsYXNzIGRlZmluaXRpb24gdGFibGVcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gZ2x5cGhJbmRleCAtIHRoZSBpbmRleCBvZiB0aGUgZ2x5cGggdG8gZmluZFxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IC0xIGlmIG5vdCBmb3VuZFxuICAgICAqL1xuICAgIGdldEdseXBoQ2xhc3M6IGZ1bmN0aW9uKGNsYXNzRGVmVGFibGUsIGdseXBoSW5kZXgpIHtcbiAgICAgICAgc3dpdGNoIChjbGFzc0RlZlRhYmxlLmZvcm1hdCkge1xuICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgIGlmIChjbGFzc0RlZlRhYmxlLnN0YXJ0R2x5cGggPD0gZ2x5cGhJbmRleCAmJiBnbHlwaEluZGV4IDwgY2xhc3NEZWZUYWJsZS5zdGFydEdseXBoICsgY2xhc3NEZWZUYWJsZS5jbGFzc2VzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY2xhc3NEZWZUYWJsZS5jbGFzc2VzW2dseXBoSW5kZXggLSBjbGFzc0RlZlRhYmxlLnN0YXJ0R2x5cGhdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICB2YXIgcmFuZ2UgPSBzZWFyY2hSYW5nZShjbGFzc0RlZlRhYmxlLnJhbmdlcywgZ2x5cGhJbmRleCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJhbmdlID8gcmFuZ2UuY2xhc3NJZCA6IDA7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogRmluZCBhIGdseXBoIGluIGEgY292ZXJhZ2UgdGFibGVcbiAgICAgKiBodHRwczovL2RvY3MubWljcm9zb2Z0LmNvbS9lbi11cy90eXBvZ3JhcGh5L29wZW50eXBlL3NwZWMvY2hhcHRlcjIjY292ZXJhZ2UtdGFibGVcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gY292ZXJhZ2VUYWJsZSAtIGFuIE9wZW5UeXBlIExheW91dCBjb3ZlcmFnZSB0YWJsZVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBnbHlwaEluZGV4IC0gdGhlIGluZGV4IG9mIHRoZSBnbHlwaCB0byBmaW5kXG4gICAgICogQHJldHVybnMge251bWJlcn0gLTEgaWYgbm90IGZvdW5kXG4gICAgICovXG4gICAgZ2V0Q292ZXJhZ2VJbmRleDogZnVuY3Rpb24oY292ZXJhZ2VUYWJsZSwgZ2x5cGhJbmRleCkge1xuICAgICAgICBzd2l0Y2ggKGNvdmVyYWdlVGFibGUuZm9ybWF0KSB7XG4gICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgdmFyIGluZGV4ID0gYmluU2VhcmNoKGNvdmVyYWdlVGFibGUuZ2x5cGhzLCBnbHlwaEluZGV4KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gaW5kZXggPj0gMCA/IGluZGV4IDogLTE7XG4gICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgdmFyIHJhbmdlID0gc2VhcmNoUmFuZ2UoY292ZXJhZ2VUYWJsZS5yYW5nZXMsIGdseXBoSW5kZXgpO1xuICAgICAgICAgICAgICAgIHJldHVybiByYW5nZSA/IHJhbmdlLmluZGV4ICsgZ2x5cGhJbmRleCAtIHJhbmdlLnN0YXJ0IDogLTE7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgbGlzdCBvZiBnbHlwaCBpbmRleGVzIG9mIGEgY292ZXJhZ2UgdGFibGUuXG4gICAgICogRm9ybWF0IDE6IHRoZSBsaXN0IGlzIHN0b3JlZCByYXdcbiAgICAgKiBGb3JtYXQgMjogY29tcGFjdCBsaXN0IGFzIHJhbmdlIHJlY29yZHMuXG4gICAgICogQGluc3RhbmNlXG4gICAgICogQHBhcmFtICB7T2JqZWN0fSBjb3ZlcmFnZVRhYmxlXG4gICAgICogQHJldHVybiB7QXJyYXl9XG4gICAgICovXG4gICAgZXhwYW5kQ292ZXJhZ2U6IGZ1bmN0aW9uKGNvdmVyYWdlVGFibGUpIHtcbiAgICAgICAgaWYgKGNvdmVyYWdlVGFibGUuZm9ybWF0ID09PSAxKSB7XG4gICAgICAgICAgICByZXR1cm4gY292ZXJhZ2VUYWJsZS5nbHlwaHM7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YXIgZ2x5cGhzID0gW107XG4gICAgICAgICAgICB2YXIgcmFuZ2VzID0gY292ZXJhZ2VUYWJsZS5yYW5nZXM7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHJhbmdlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIHZhciByYW5nZSA9IHJhbmdlc1tpXTtcbiAgICAgICAgICAgICAgICB2YXIgc3RhcnQgPSByYW5nZS5zdGFydDtcbiAgICAgICAgICAgICAgICB2YXIgZW5kID0gcmFuZ2UuZW5kO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGogPSBzdGFydDsgaiA8PSBlbmQ7IGorKykge1xuICAgICAgICAgICAgICAgICAgICBnbHlwaHMucHVzaChqKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZ2x5cGhzO1xuICAgICAgICB9XG4gICAgfVxuXG59O1xuXG4vLyBUaGUgUG9zaXRpb24gb2JqZWN0IHByb3ZpZGVzIHV0aWxpdHkgbWV0aG9kcyB0byBtYW5pcHVsYXRlXG5cbi8qKlxuICogQGV4cG9ydHMgb3BlbnR5cGUuUG9zaXRpb25cbiAqIEBjbGFzc1xuICogQGV4dGVuZHMgb3BlbnR5cGUuTGF5b3V0XG4gKiBAcGFyYW0ge29wZW50eXBlLkZvbnR9XG4gKiBAY29uc3RydWN0b3JcbiAqL1xuZnVuY3Rpb24gUG9zaXRpb24oZm9udCkge1xuICAgIExheW91dC5jYWxsKHRoaXMsIGZvbnQsICdncG9zJyk7XG59XG5cblBvc2l0aW9uLnByb3RvdHlwZSA9IExheW91dC5wcm90b3R5cGU7XG5cbi8qKlxuICogSW5pdCBzb21lIGRhdGEgZm9yIGZhc3RlciBhbmQgZWFzaWVyIGFjY2VzcyBsYXRlci5cbiAqL1xuUG9zaXRpb24ucHJvdG90eXBlLmluaXQgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgc2NyaXB0ID0gdGhpcy5nZXREZWZhdWx0U2NyaXB0TmFtZSgpO1xuICAgIHRoaXMuZGVmYXVsdEtlcm5pbmdUYWJsZXMgPSB0aGlzLmdldEtlcm5pbmdUYWJsZXMoc2NyaXB0KTtcbn07XG5cbi8qKlxuICogRmluZCBhIGdseXBoIHBhaXIgaW4gYSBsaXN0IG9mIGxvb2t1cCB0YWJsZXMgb2YgdHlwZSAyIGFuZCByZXRyaWV2ZSB0aGUgeEFkdmFuY2Uga2VybmluZyB2YWx1ZS5cbiAqXG4gKiBAcGFyYW0ge2ludGVnZXJ9IGxlZnRJbmRleCAtIGxlZnQgZ2x5cGggaW5kZXhcbiAqIEBwYXJhbSB7aW50ZWdlcn0gcmlnaHRJbmRleCAtIHJpZ2h0IGdseXBoIGluZGV4XG4gKiBAcmV0dXJucyB7aW50ZWdlcn1cbiAqL1xuUG9zaXRpb24ucHJvdG90eXBlLmdldEtlcm5pbmdWYWx1ZSA9IGZ1bmN0aW9uKGtlcm5pbmdMb29rdXBzLCBsZWZ0SW5kZXgsIHJpZ2h0SW5kZXgpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGtlcm5pbmdMb29rdXBzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBzdWJ0YWJsZXMgPSBrZXJuaW5nTG9va3Vwc1tpXS5zdWJ0YWJsZXM7XG4gICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgc3VidGFibGVzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICB2YXIgc3VidGFibGUgPSBzdWJ0YWJsZXNbal07XG4gICAgICAgICAgICB2YXIgY292SW5kZXggPSB0aGlzLmdldENvdmVyYWdlSW5kZXgoc3VidGFibGUuY292ZXJhZ2UsIGxlZnRJbmRleCk7XG4gICAgICAgICAgICBpZiAoY292SW5kZXggPCAwKSB7IGNvbnRpbnVlOyB9XG4gICAgICAgICAgICBzd2l0Y2ggKHN1YnRhYmxlLnBvc0Zvcm1hdCkge1xuICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgLy8gU2VhcmNoIFBhaXIgQWRqdXN0bWVudCBQb3NpdGlvbmluZyBGb3JtYXQgMVxuICAgICAgICAgICAgICAgICAgICB2YXIgcGFpclNldCA9IHN1YnRhYmxlLnBhaXJTZXRzW2NvdkluZGV4XTtcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgayA9IDA7IGsgPCBwYWlyU2V0Lmxlbmd0aDsgaysrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgcGFpciA9IHBhaXJTZXRba107XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocGFpci5zZWNvbmRHbHlwaCA9PT0gcmlnaHRJbmRleCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBwYWlyLnZhbHVlMSAmJiBwYWlyLnZhbHVlMS54QWR2YW5jZSB8fCAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrOyAgICAgIC8vIGxlZnQgZ2x5cGggZm91bmQsIG5vdCByaWdodCBnbHlwaCAtIHRyeSBuZXh0IHN1YnRhYmxlXG4gICAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgICAgICAvLyBTZWFyY2ggUGFpciBBZGp1c3RtZW50IFBvc2l0aW9uaW5nIEZvcm1hdCAyXG4gICAgICAgICAgICAgICAgICAgIHZhciBjbGFzczEgPSB0aGlzLmdldEdseXBoQ2xhc3Moc3VidGFibGUuY2xhc3NEZWYxLCBsZWZ0SW5kZXgpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgY2xhc3MyID0gdGhpcy5nZXRHbHlwaENsYXNzKHN1YnRhYmxlLmNsYXNzRGVmMiwgcmlnaHRJbmRleCk7XG4gICAgICAgICAgICAgICAgICAgIHZhciBwYWlyJDEgPSBzdWJ0YWJsZS5jbGFzc1JlY29yZHNbY2xhc3MxXVtjbGFzczJdO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcGFpciQxLnZhbHVlMSAmJiBwYWlyJDEudmFsdWUxLnhBZHZhbmNlIHx8IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIDA7XG59O1xuXG4vKipcbiAqIExpc3QgYWxsIGtlcm5pbmcgbG9va3VwIHRhYmxlcy5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gW3NjcmlwdD0nREZMVCddIC0gdXNlIGZvbnQucG9zaXRpb24uZ2V0RGVmYXVsdFNjcmlwdE5hbWUoKSBmb3IgYSBiZXR0ZXIgZGVmYXVsdCB2YWx1ZVxuICogQHBhcmFtIHtzdHJpbmd9IFtsYW5ndWFnZT0nZGZsdCddXG4gKiBAcmV0dXJuIHtvYmplY3RbXX0gVGhlIGxpc3Qgb2Yga2VybmluZyBsb29rdXAgdGFibGVzIChtYXkgYmUgZW1wdHkpLCBvciB1bmRlZmluZWQgaWYgdGhlcmUgaXMgbm8gR1BPUyB0YWJsZSAoYW5kIHdlIHNob3VsZCB1c2UgdGhlIGtlcm4gdGFibGUpXG4gKi9cblBvc2l0aW9uLnByb3RvdHlwZS5nZXRLZXJuaW5nVGFibGVzID0gZnVuY3Rpb24oc2NyaXB0LCBsYW5ndWFnZSkge1xuICAgIGlmICh0aGlzLmZvbnQudGFibGVzLmdwb3MpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0TG9va3VwVGFibGVzKHNjcmlwdCwgbGFuZ3VhZ2UsICdrZXJuJywgMik7XG4gICAgfVxufTtcblxuLy8gVGhlIFN1YnN0aXR1dGlvbiBvYmplY3QgcHJvdmlkZXMgdXRpbGl0eSBtZXRob2RzIHRvIG1hbmlwdWxhdGVcblxuLyoqXG4gKiBAZXhwb3J0cyBvcGVudHlwZS5TdWJzdGl0dXRpb25cbiAqIEBjbGFzc1xuICogQGV4dGVuZHMgb3BlbnR5cGUuTGF5b3V0XG4gKiBAcGFyYW0ge29wZW50eXBlLkZvbnR9XG4gKiBAY29uc3RydWN0b3JcbiAqL1xuZnVuY3Rpb24gU3Vic3RpdHV0aW9uKGZvbnQpIHtcbiAgICBMYXlvdXQuY2FsbCh0aGlzLCBmb250LCAnZ3N1YicpO1xufVxuXG4vLyBDaGVjayBpZiAyIGFycmF5cyBvZiBwcmltaXRpdmVzIGFyZSBlcXVhbC5cbmZ1bmN0aW9uIGFycmF5c0VxdWFsKGFyMSwgYXIyKSB7XG4gICAgdmFyIG4gPSBhcjEubGVuZ3RoO1xuICAgIGlmIChuICE9PSBhcjIubGVuZ3RoKSB7IHJldHVybiBmYWxzZTsgfVxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbjsgaSsrKSB7XG4gICAgICAgIGlmIChhcjFbaV0gIT09IGFyMltpXSkgeyByZXR1cm4gZmFsc2U7IH1cbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG59XG5cbi8vIEZpbmQgdGhlIGZpcnN0IHN1YnRhYmxlIG9mIGEgbG9va3VwIHRhYmxlIGluIGEgcGFydGljdWxhciBmb3JtYXQuXG5mdW5jdGlvbiBnZXRTdWJzdEZvcm1hdChsb29rdXBUYWJsZSwgZm9ybWF0LCBkZWZhdWx0U3VidGFibGUpIHtcbiAgICB2YXIgc3VidGFibGVzID0gbG9va3VwVGFibGUuc3VidGFibGVzO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc3VidGFibGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBzdWJ0YWJsZSA9IHN1YnRhYmxlc1tpXTtcbiAgICAgICAgaWYgKHN1YnRhYmxlLnN1YnN0Rm9ybWF0ID09PSBmb3JtYXQpIHtcbiAgICAgICAgICAgIHJldHVybiBzdWJ0YWJsZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoZGVmYXVsdFN1YnRhYmxlKSB7XG4gICAgICAgIHN1YnRhYmxlcy5wdXNoKGRlZmF1bHRTdWJ0YWJsZSk7XG4gICAgICAgIHJldHVybiBkZWZhdWx0U3VidGFibGU7XG4gICAgfVxuICAgIHJldHVybiB1bmRlZmluZWQ7XG59XG5cblN1YnN0aXR1dGlvbi5wcm90b3R5cGUgPSBMYXlvdXQucHJvdG90eXBlO1xuXG4vKipcbiAqIENyZWF0ZSBhIGRlZmF1bHQgR1NVQiB0YWJsZS5cbiAqIEByZXR1cm4ge09iamVjdH0gZ3N1YiAtIFRoZSBHU1VCIHRhYmxlLlxuICovXG5TdWJzdGl0dXRpb24ucHJvdG90eXBlLmNyZWF0ZURlZmF1bHRUYWJsZSA9IGZ1bmN0aW9uKCkge1xuICAgIC8vIEdlbmVyYXRlIGEgZGVmYXVsdCBlbXB0eSBHU1VCIHRhYmxlIHdpdGgganVzdCBhIERGTFQgc2NyaXB0IGFuZCBkZmx0IGxhbmcgc3lzLlxuICAgIHJldHVybiB7XG4gICAgICAgIHZlcnNpb246IDEsXG4gICAgICAgIHNjcmlwdHM6IFt7XG4gICAgICAgICAgICB0YWc6ICdERkxUJyxcbiAgICAgICAgICAgIHNjcmlwdDoge1xuICAgICAgICAgICAgICAgIGRlZmF1bHRMYW5nU3lzOiB7IHJlc2VydmVkOiAwLCByZXFGZWF0dXJlSW5kZXg6IDB4ZmZmZiwgZmVhdHVyZUluZGV4ZXM6IFtdIH0sXG4gICAgICAgICAgICAgICAgbGFuZ1N5c1JlY29yZHM6IFtdXG4gICAgICAgICAgICB9XG4gICAgICAgIH1dLFxuICAgICAgICBmZWF0dXJlczogW10sXG4gICAgICAgIGxvb2t1cHM6IFtdXG4gICAgfTtcbn07XG5cbi8qKlxuICogTGlzdCBhbGwgc2luZ2xlIHN1YnN0aXR1dGlvbnMgKGxvb2t1cCB0eXBlIDEpIGZvciBhIGdpdmVuIHNjcmlwdCwgbGFuZ3VhZ2UsIGFuZCBmZWF0dXJlLlxuICogQHBhcmFtIHtzdHJpbmd9IFtzY3JpcHQ9J0RGTFQnXVxuICogQHBhcmFtIHtzdHJpbmd9IFtsYW5ndWFnZT0nZGZsdCddXG4gKiBAcGFyYW0ge3N0cmluZ30gZmVhdHVyZSAtIDQtY2hhcmFjdGVyIGZlYXR1cmUgbmFtZSAoJ2FhbHQnLCAnc2FsdCcsICdzczAxJy4uLilcbiAqIEByZXR1cm4ge0FycmF5fSBzdWJzdGl0dXRpb25zIC0gVGhlIGxpc3Qgb2Ygc3Vic3RpdHV0aW9ucy5cbiAqL1xuU3Vic3RpdHV0aW9uLnByb3RvdHlwZS5nZXRTaW5nbGUgPSBmdW5jdGlvbihmZWF0dXJlLCBzY3JpcHQsIGxhbmd1YWdlKSB7XG4gICAgdmFyIHN1YnN0aXR1dGlvbnMgPSBbXTtcbiAgICB2YXIgbG9va3VwVGFibGVzID0gdGhpcy5nZXRMb29rdXBUYWJsZXMoc2NyaXB0LCBsYW5ndWFnZSwgZmVhdHVyZSwgMSk7XG4gICAgZm9yICh2YXIgaWR4ID0gMDsgaWR4IDwgbG9va3VwVGFibGVzLmxlbmd0aDsgaWR4KyspIHtcbiAgICAgICAgdmFyIHN1YnRhYmxlcyA9IGxvb2t1cFRhYmxlc1tpZHhdLnN1YnRhYmxlcztcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdWJ0YWJsZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBzdWJ0YWJsZSA9IHN1YnRhYmxlc1tpXTtcbiAgICAgICAgICAgIHZhciBnbHlwaHMgPSB0aGlzLmV4cGFuZENvdmVyYWdlKHN1YnRhYmxlLmNvdmVyYWdlKTtcbiAgICAgICAgICAgIHZhciBqID0gKHZvaWQgMCk7XG4gICAgICAgICAgICBpZiAoc3VidGFibGUuc3Vic3RGb3JtYXQgPT09IDEpIHtcbiAgICAgICAgICAgICAgICB2YXIgZGVsdGEgPSBzdWJ0YWJsZS5kZWx0YUdseXBoSWQ7XG4gICAgICAgICAgICAgICAgZm9yIChqID0gMDsgaiA8IGdseXBocy5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgZ2x5cGggPSBnbHlwaHNbal07XG4gICAgICAgICAgICAgICAgICAgIHN1YnN0aXR1dGlvbnMucHVzaCh7IHN1YjogZ2x5cGgsIGJ5OiBnbHlwaCArIGRlbHRhIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdmFyIHN1YnN0aXR1dGUgPSBzdWJ0YWJsZS5zdWJzdGl0dXRlO1xuICAgICAgICAgICAgICAgIGZvciAoaiA9IDA7IGogPCBnbHlwaHMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgICAgICAgICAgc3Vic3RpdHV0aW9ucy5wdXNoKHsgc3ViOiBnbHlwaHNbal0sIGJ5OiBzdWJzdGl0dXRlW2pdIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gc3Vic3RpdHV0aW9ucztcbn07XG5cbi8qKlxuICogTGlzdCBhbGwgbXVsdGlwbGUgc3Vic3RpdHV0aW9ucyAobG9va3VwIHR5cGUgMikgZm9yIGEgZ2l2ZW4gc2NyaXB0LCBsYW5ndWFnZSwgYW5kIGZlYXR1cmUuXG4gKiBAcGFyYW0ge3N0cmluZ30gW3NjcmlwdD0nREZMVCddXG4gKiBAcGFyYW0ge3N0cmluZ30gW2xhbmd1YWdlPSdkZmx0J11cbiAqIEBwYXJhbSB7c3RyaW5nfSBmZWF0dXJlIC0gNC1jaGFyYWN0ZXIgZmVhdHVyZSBuYW1lICgnY2NtcCcsICdzdGNoJylcbiAqIEByZXR1cm4ge0FycmF5fSBzdWJzdGl0dXRpb25zIC0gVGhlIGxpc3Qgb2Ygc3Vic3RpdHV0aW9ucy5cbiAqL1xuU3Vic3RpdHV0aW9uLnByb3RvdHlwZS5nZXRNdWx0aXBsZSA9IGZ1bmN0aW9uKGZlYXR1cmUsIHNjcmlwdCwgbGFuZ3VhZ2UpIHtcbiAgICB2YXIgc3Vic3RpdHV0aW9ucyA9IFtdO1xuICAgIHZhciBsb29rdXBUYWJsZXMgPSB0aGlzLmdldExvb2t1cFRhYmxlcyhzY3JpcHQsIGxhbmd1YWdlLCBmZWF0dXJlLCAyKTtcbiAgICBmb3IgKHZhciBpZHggPSAwOyBpZHggPCBsb29rdXBUYWJsZXMubGVuZ3RoOyBpZHgrKykge1xuICAgICAgICB2YXIgc3VidGFibGVzID0gbG9va3VwVGFibGVzW2lkeF0uc3VidGFibGVzO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHN1YnRhYmxlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIHN1YnRhYmxlID0gc3VidGFibGVzW2ldO1xuICAgICAgICAgICAgdmFyIGdseXBocyA9IHRoaXMuZXhwYW5kQ292ZXJhZ2Uoc3VidGFibGUuY292ZXJhZ2UpO1xuICAgICAgICAgICAgdmFyIGogPSAodm9pZCAwKTtcblxuICAgICAgICAgICAgZm9yIChqID0gMDsgaiA8IGdseXBocy5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgICAgIHZhciBnbHlwaCA9IGdseXBoc1tqXTtcbiAgICAgICAgICAgICAgICB2YXIgcmVwbGFjZW1lbnRzID0gc3VidGFibGUuc2VxdWVuY2VzW2pdO1xuICAgICAgICAgICAgICAgIHN1YnN0aXR1dGlvbnMucHVzaCh7IHN1YjogZ2x5cGgsIGJ5OiByZXBsYWNlbWVudHMgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHN1YnN0aXR1dGlvbnM7XG59O1xuXG4vKipcbiAqIExpc3QgYWxsIGFsdGVybmF0ZXMgKGxvb2t1cCB0eXBlIDMpIGZvciBhIGdpdmVuIHNjcmlwdCwgbGFuZ3VhZ2UsIGFuZCBmZWF0dXJlLlxuICogQHBhcmFtIHtzdHJpbmd9IFtzY3JpcHQ9J0RGTFQnXVxuICogQHBhcmFtIHtzdHJpbmd9IFtsYW5ndWFnZT0nZGZsdCddXG4gKiBAcGFyYW0ge3N0cmluZ30gZmVhdHVyZSAtIDQtY2hhcmFjdGVyIGZlYXR1cmUgbmFtZSAoJ2FhbHQnLCAnc2FsdCcuLi4pXG4gKiBAcmV0dXJuIHtBcnJheX0gYWx0ZXJuYXRlcyAtIFRoZSBsaXN0IG9mIGFsdGVybmF0ZXNcbiAqL1xuU3Vic3RpdHV0aW9uLnByb3RvdHlwZS5nZXRBbHRlcm5hdGVzID0gZnVuY3Rpb24oZmVhdHVyZSwgc2NyaXB0LCBsYW5ndWFnZSkge1xuICAgIHZhciBhbHRlcm5hdGVzID0gW107XG4gICAgdmFyIGxvb2t1cFRhYmxlcyA9IHRoaXMuZ2V0TG9va3VwVGFibGVzKHNjcmlwdCwgbGFuZ3VhZ2UsIGZlYXR1cmUsIDMpO1xuICAgIGZvciAodmFyIGlkeCA9IDA7IGlkeCA8IGxvb2t1cFRhYmxlcy5sZW5ndGg7IGlkeCsrKSB7XG4gICAgICAgIHZhciBzdWJ0YWJsZXMgPSBsb29rdXBUYWJsZXNbaWR4XS5zdWJ0YWJsZXM7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc3VidGFibGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgc3VidGFibGUgPSBzdWJ0YWJsZXNbaV07XG4gICAgICAgICAgICB2YXIgZ2x5cGhzID0gdGhpcy5leHBhbmRDb3ZlcmFnZShzdWJ0YWJsZS5jb3ZlcmFnZSk7XG4gICAgICAgICAgICB2YXIgYWx0ZXJuYXRlU2V0cyA9IHN1YnRhYmxlLmFsdGVybmF0ZVNldHM7XG4gICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGdseXBocy5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgICAgIGFsdGVybmF0ZXMucHVzaCh7IHN1YjogZ2x5cGhzW2pdLCBieTogYWx0ZXJuYXRlU2V0c1tqXSB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gYWx0ZXJuYXRlcztcbn07XG5cbi8qKlxuICogTGlzdCBhbGwgbGlnYXR1cmVzIChsb29rdXAgdHlwZSA0KSBmb3IgYSBnaXZlbiBzY3JpcHQsIGxhbmd1YWdlLCBhbmQgZmVhdHVyZS5cbiAqIFRoZSByZXN1bHQgaXMgYW4gYXJyYXkgb2YgbGlnYXR1cmUgb2JqZWN0cyBsaWtlIHsgc3ViOiBbaWRzXSwgYnk6IGlkIH1cbiAqIEBwYXJhbSB7c3RyaW5nfSBmZWF0dXJlIC0gNC1sZXR0ZXIgZmVhdHVyZSBuYW1lICgnbGlnYScsICdybGlnJywgJ2RsaWcnLi4uKVxuICogQHBhcmFtIHtzdHJpbmd9IFtzY3JpcHQ9J0RGTFQnXVxuICogQHBhcmFtIHtzdHJpbmd9IFtsYW5ndWFnZT0nZGZsdCddXG4gKiBAcmV0dXJuIHtBcnJheX0gbGlnYXR1cmVzIC0gVGhlIGxpc3Qgb2YgbGlnYXR1cmVzLlxuICovXG5TdWJzdGl0dXRpb24ucHJvdG90eXBlLmdldExpZ2F0dXJlcyA9IGZ1bmN0aW9uKGZlYXR1cmUsIHNjcmlwdCwgbGFuZ3VhZ2UpIHtcbiAgICB2YXIgbGlnYXR1cmVzID0gW107XG4gICAgdmFyIGxvb2t1cFRhYmxlcyA9IHRoaXMuZ2V0TG9va3VwVGFibGVzKHNjcmlwdCwgbGFuZ3VhZ2UsIGZlYXR1cmUsIDQpO1xuICAgIGZvciAodmFyIGlkeCA9IDA7IGlkeCA8IGxvb2t1cFRhYmxlcy5sZW5ndGg7IGlkeCsrKSB7XG4gICAgICAgIHZhciBzdWJ0YWJsZXMgPSBsb29rdXBUYWJsZXNbaWR4XS5zdWJ0YWJsZXM7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc3VidGFibGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgc3VidGFibGUgPSBzdWJ0YWJsZXNbaV07XG4gICAgICAgICAgICB2YXIgZ2x5cGhzID0gdGhpcy5leHBhbmRDb3ZlcmFnZShzdWJ0YWJsZS5jb3ZlcmFnZSk7XG4gICAgICAgICAgICB2YXIgbGlnYXR1cmVTZXRzID0gc3VidGFibGUubGlnYXR1cmVTZXRzO1xuICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBnbHlwaHMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgc3RhcnRHbHlwaCA9IGdseXBoc1tqXTtcbiAgICAgICAgICAgICAgICB2YXIgbGlnU2V0ID0gbGlnYXR1cmVTZXRzW2pdO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGsgPSAwOyBrIDwgbGlnU2V0Lmxlbmd0aDsgaysrKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBsaWcgPSBsaWdTZXRba107XG4gICAgICAgICAgICAgICAgICAgIGxpZ2F0dXJlcy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN1YjogW3N0YXJ0R2x5cGhdLmNvbmNhdChsaWcuY29tcG9uZW50cyksXG4gICAgICAgICAgICAgICAgICAgICAgICBieTogbGlnLmxpZ0dseXBoXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbGlnYXR1cmVzO1xufTtcblxuLyoqXG4gKiBBZGQgb3IgbW9kaWZ5IGEgc2luZ2xlIHN1YnN0aXR1dGlvbiAobG9va3VwIHR5cGUgMSlcbiAqIEZvcm1hdCAyLCBtb3JlIGZsZXhpYmxlLCBpcyBhbHdheXMgdXNlZC5cbiAqIEBwYXJhbSB7c3RyaW5nfSBmZWF0dXJlIC0gNC1sZXR0ZXIgZmVhdHVyZSBuYW1lICgnbGlnYScsICdybGlnJywgJ2RsaWcnLi4uKVxuICogQHBhcmFtIHtPYmplY3R9IHN1YnN0aXR1dGlvbiAtIHsgc3ViOiBpZCwgYnk6IGlkIH0gKGZvcm1hdCAxIGlzIG5vdCBzdXBwb3J0ZWQpXG4gKiBAcGFyYW0ge3N0cmluZ30gW3NjcmlwdD0nREZMVCddXG4gKiBAcGFyYW0ge3N0cmluZ30gW2xhbmd1YWdlPSdkZmx0J11cbiAqL1xuU3Vic3RpdHV0aW9uLnByb3RvdHlwZS5hZGRTaW5nbGUgPSBmdW5jdGlvbihmZWF0dXJlLCBzdWJzdGl0dXRpb24sIHNjcmlwdCwgbGFuZ3VhZ2UpIHtcbiAgICB2YXIgbG9va3VwVGFibGUgPSB0aGlzLmdldExvb2t1cFRhYmxlcyhzY3JpcHQsIGxhbmd1YWdlLCBmZWF0dXJlLCAxLCB0cnVlKVswXTtcbiAgICB2YXIgc3VidGFibGUgPSBnZXRTdWJzdEZvcm1hdChsb29rdXBUYWJsZSwgMiwgeyAgICAgICAgICAgICAgICAvLyBsb29rdXAgdHlwZSAxIHN1YnRhYmxlLCBmb3JtYXQgMiwgY292ZXJhZ2UgZm9ybWF0IDFcbiAgICAgICAgc3Vic3RGb3JtYXQ6IDIsXG4gICAgICAgIGNvdmVyYWdlOiB7Zm9ybWF0OiAxLCBnbHlwaHM6IFtdfSxcbiAgICAgICAgc3Vic3RpdHV0ZTogW11cbiAgICB9KTtcbiAgICBjaGVjay5hc3NlcnQoc3VidGFibGUuY292ZXJhZ2UuZm9ybWF0ID09PSAxLCAnU2luZ2xlOiB1bmFibGUgdG8gbW9kaWZ5IGNvdmVyYWdlIHRhYmxlIGZvcm1hdCAnICsgc3VidGFibGUuY292ZXJhZ2UuZm9ybWF0KTtcbiAgICB2YXIgY292ZXJhZ2VHbHlwaCA9IHN1YnN0aXR1dGlvbi5zdWI7XG4gICAgdmFyIHBvcyA9IHRoaXMuYmluU2VhcmNoKHN1YnRhYmxlLmNvdmVyYWdlLmdseXBocywgY292ZXJhZ2VHbHlwaCk7XG4gICAgaWYgKHBvcyA8IDApIHtcbiAgICAgICAgcG9zID0gLTEgLSBwb3M7XG4gICAgICAgIHN1YnRhYmxlLmNvdmVyYWdlLmdseXBocy5zcGxpY2UocG9zLCAwLCBjb3ZlcmFnZUdseXBoKTtcbiAgICAgICAgc3VidGFibGUuc3Vic3RpdHV0ZS5zcGxpY2UocG9zLCAwLCAwKTtcbiAgICB9XG4gICAgc3VidGFibGUuc3Vic3RpdHV0ZVtwb3NdID0gc3Vic3RpdHV0aW9uLmJ5O1xufTtcblxuLyoqXG4gKiBBZGQgb3IgbW9kaWZ5IGEgbXVsdGlwbGUgc3Vic3RpdHV0aW9uIChsb29rdXAgdHlwZSAyKVxuICogQHBhcmFtIHtzdHJpbmd9IGZlYXR1cmUgLSA0LWxldHRlciBmZWF0dXJlIG5hbWUgKCdjY21wJywgJ3N0Y2gnKVxuICogQHBhcmFtIHtPYmplY3R9IHN1YnN0aXR1dGlvbiAtIHsgc3ViOiBpZCwgYnk6IFtpZF0gfSBmb3IgZm9ybWF0IDIuXG4gKiBAcGFyYW0ge3N0cmluZ30gW3NjcmlwdD0nREZMVCddXG4gKiBAcGFyYW0ge3N0cmluZ30gW2xhbmd1YWdlPSdkZmx0J11cbiAqL1xuU3Vic3RpdHV0aW9uLnByb3RvdHlwZS5hZGRNdWx0aXBsZSA9IGZ1bmN0aW9uKGZlYXR1cmUsIHN1YnN0aXR1dGlvbiwgc2NyaXB0LCBsYW5ndWFnZSkge1xuICAgIGNoZWNrLmFzc2VydChzdWJzdGl0dXRpb24uYnkgaW5zdGFuY2VvZiBBcnJheSAmJiBzdWJzdGl0dXRpb24uYnkubGVuZ3RoID4gMSwgJ011bHRpcGxlOiBcImJ5XCIgbXVzdCBiZSBhbiBhcnJheSBvZiB0d28gb3IgbW9yZSBpZHMnKTtcbiAgICB2YXIgbG9va3VwVGFibGUgPSB0aGlzLmdldExvb2t1cFRhYmxlcyhzY3JpcHQsIGxhbmd1YWdlLCBmZWF0dXJlLCAyLCB0cnVlKVswXTtcbiAgICB2YXIgc3VidGFibGUgPSBnZXRTdWJzdEZvcm1hdChsb29rdXBUYWJsZSwgMSwgeyAgICAgICAgICAgICAgICAvLyBsb29rdXAgdHlwZSAyIHN1YnRhYmxlLCBmb3JtYXQgMSwgY292ZXJhZ2UgZm9ybWF0IDFcbiAgICAgICAgc3Vic3RGb3JtYXQ6IDEsXG4gICAgICAgIGNvdmVyYWdlOiB7Zm9ybWF0OiAxLCBnbHlwaHM6IFtdfSxcbiAgICAgICAgc2VxdWVuY2VzOiBbXVxuICAgIH0pO1xuICAgIGNoZWNrLmFzc2VydChzdWJ0YWJsZS5jb3ZlcmFnZS5mb3JtYXQgPT09IDEsICdNdWx0aXBsZTogdW5hYmxlIHRvIG1vZGlmeSBjb3ZlcmFnZSB0YWJsZSBmb3JtYXQgJyArIHN1YnRhYmxlLmNvdmVyYWdlLmZvcm1hdCk7XG4gICAgdmFyIGNvdmVyYWdlR2x5cGggPSBzdWJzdGl0dXRpb24uc3ViO1xuICAgIHZhciBwb3MgPSB0aGlzLmJpblNlYXJjaChzdWJ0YWJsZS5jb3ZlcmFnZS5nbHlwaHMsIGNvdmVyYWdlR2x5cGgpO1xuICAgIGlmIChwb3MgPCAwKSB7XG4gICAgICAgIHBvcyA9IC0xIC0gcG9zO1xuICAgICAgICBzdWJ0YWJsZS5jb3ZlcmFnZS5nbHlwaHMuc3BsaWNlKHBvcywgMCwgY292ZXJhZ2VHbHlwaCk7XG4gICAgICAgIHN1YnRhYmxlLnNlcXVlbmNlcy5zcGxpY2UocG9zLCAwLCAwKTtcbiAgICB9XG4gICAgc3VidGFibGUuc2VxdWVuY2VzW3Bvc10gPSBzdWJzdGl0dXRpb24uYnk7XG59O1xuXG4vKipcbiAqIEFkZCBvciBtb2RpZnkgYW4gYWx0ZXJuYXRlIHN1YnN0aXR1dGlvbiAobG9va3VwIHR5cGUgMylcbiAqIEBwYXJhbSB7c3RyaW5nfSBmZWF0dXJlIC0gNC1sZXR0ZXIgZmVhdHVyZSBuYW1lICgnbGlnYScsICdybGlnJywgJ2RsaWcnLi4uKVxuICogQHBhcmFtIHtPYmplY3R9IHN1YnN0aXR1dGlvbiAtIHsgc3ViOiBpZCwgYnk6IFtpZHNdIH1cbiAqIEBwYXJhbSB7c3RyaW5nfSBbc2NyaXB0PSdERkxUJ11cbiAqIEBwYXJhbSB7c3RyaW5nfSBbbGFuZ3VhZ2U9J2RmbHQnXVxuICovXG5TdWJzdGl0dXRpb24ucHJvdG90eXBlLmFkZEFsdGVybmF0ZSA9IGZ1bmN0aW9uKGZlYXR1cmUsIHN1YnN0aXR1dGlvbiwgc2NyaXB0LCBsYW5ndWFnZSkge1xuICAgIHZhciBsb29rdXBUYWJsZSA9IHRoaXMuZ2V0TG9va3VwVGFibGVzKHNjcmlwdCwgbGFuZ3VhZ2UsIGZlYXR1cmUsIDMsIHRydWUpWzBdO1xuICAgIHZhciBzdWJ0YWJsZSA9IGdldFN1YnN0Rm9ybWF0KGxvb2t1cFRhYmxlLCAxLCB7ICAgICAgICAgICAgICAgIC8vIGxvb2t1cCB0eXBlIDMgc3VidGFibGUsIGZvcm1hdCAxLCBjb3ZlcmFnZSBmb3JtYXQgMVxuICAgICAgICBzdWJzdEZvcm1hdDogMSxcbiAgICAgICAgY292ZXJhZ2U6IHtmb3JtYXQ6IDEsIGdseXBoczogW119LFxuICAgICAgICBhbHRlcm5hdGVTZXRzOiBbXVxuICAgIH0pO1xuICAgIGNoZWNrLmFzc2VydChzdWJ0YWJsZS5jb3ZlcmFnZS5mb3JtYXQgPT09IDEsICdBbHRlcm5hdGU6IHVuYWJsZSB0byBtb2RpZnkgY292ZXJhZ2UgdGFibGUgZm9ybWF0ICcgKyBzdWJ0YWJsZS5jb3ZlcmFnZS5mb3JtYXQpO1xuICAgIHZhciBjb3ZlcmFnZUdseXBoID0gc3Vic3RpdHV0aW9uLnN1YjtcbiAgICB2YXIgcG9zID0gdGhpcy5iaW5TZWFyY2goc3VidGFibGUuY292ZXJhZ2UuZ2x5cGhzLCBjb3ZlcmFnZUdseXBoKTtcbiAgICBpZiAocG9zIDwgMCkge1xuICAgICAgICBwb3MgPSAtMSAtIHBvcztcbiAgICAgICAgc3VidGFibGUuY292ZXJhZ2UuZ2x5cGhzLnNwbGljZShwb3MsIDAsIGNvdmVyYWdlR2x5cGgpO1xuICAgICAgICBzdWJ0YWJsZS5hbHRlcm5hdGVTZXRzLnNwbGljZShwb3MsIDAsIDApO1xuICAgIH1cbiAgICBzdWJ0YWJsZS5hbHRlcm5hdGVTZXRzW3Bvc10gPSBzdWJzdGl0dXRpb24uYnk7XG59O1xuXG4vKipcbiAqIEFkZCBhIGxpZ2F0dXJlIChsb29rdXAgdHlwZSA0KVxuICogTGlnYXR1cmVzIHdpdGggbW9yZSBjb21wb25lbnRzIG11c3QgYmUgc3RvcmVkIGFoZWFkIG9mIHRob3NlIHdpdGggZmV3ZXIgY29tcG9uZW50cyBpbiBvcmRlciB0byBiZSBmb3VuZFxuICogQHBhcmFtIHtzdHJpbmd9IGZlYXR1cmUgLSA0LWxldHRlciBmZWF0dXJlIG5hbWUgKCdsaWdhJywgJ3JsaWcnLCAnZGxpZycuLi4pXG4gKiBAcGFyYW0ge09iamVjdH0gbGlnYXR1cmUgLSB7IHN1YjogW2lkc10sIGJ5OiBpZCB9XG4gKiBAcGFyYW0ge3N0cmluZ30gW3NjcmlwdD0nREZMVCddXG4gKiBAcGFyYW0ge3N0cmluZ30gW2xhbmd1YWdlPSdkZmx0J11cbiAqL1xuU3Vic3RpdHV0aW9uLnByb3RvdHlwZS5hZGRMaWdhdHVyZSA9IGZ1bmN0aW9uKGZlYXR1cmUsIGxpZ2F0dXJlLCBzY3JpcHQsIGxhbmd1YWdlKSB7XG4gICAgdmFyIGxvb2t1cFRhYmxlID0gdGhpcy5nZXRMb29rdXBUYWJsZXMoc2NyaXB0LCBsYW5ndWFnZSwgZmVhdHVyZSwgNCwgdHJ1ZSlbMF07XG4gICAgdmFyIHN1YnRhYmxlID0gbG9va3VwVGFibGUuc3VidGFibGVzWzBdO1xuICAgIGlmICghc3VidGFibGUpIHtcbiAgICAgICAgc3VidGFibGUgPSB7ICAgICAgICAgICAgICAgIC8vIGxvb2t1cCB0eXBlIDQgc3VidGFibGUsIGZvcm1hdCAxLCBjb3ZlcmFnZSBmb3JtYXQgMVxuICAgICAgICAgICAgc3Vic3RGb3JtYXQ6IDEsXG4gICAgICAgICAgICBjb3ZlcmFnZTogeyBmb3JtYXQ6IDEsIGdseXBoczogW10gfSxcbiAgICAgICAgICAgIGxpZ2F0dXJlU2V0czogW11cbiAgICAgICAgfTtcbiAgICAgICAgbG9va3VwVGFibGUuc3VidGFibGVzWzBdID0gc3VidGFibGU7XG4gICAgfVxuICAgIGNoZWNrLmFzc2VydChzdWJ0YWJsZS5jb3ZlcmFnZS5mb3JtYXQgPT09IDEsICdMaWdhdHVyZTogdW5hYmxlIHRvIG1vZGlmeSBjb3ZlcmFnZSB0YWJsZSBmb3JtYXQgJyArIHN1YnRhYmxlLmNvdmVyYWdlLmZvcm1hdCk7XG4gICAgdmFyIGNvdmVyYWdlR2x5cGggPSBsaWdhdHVyZS5zdWJbMF07XG4gICAgdmFyIGxpZ0NvbXBvbmVudHMgPSBsaWdhdHVyZS5zdWIuc2xpY2UoMSk7XG4gICAgdmFyIGxpZ2F0dXJlVGFibGUgPSB7XG4gICAgICAgIGxpZ0dseXBoOiBsaWdhdHVyZS5ieSxcbiAgICAgICAgY29tcG9uZW50czogbGlnQ29tcG9uZW50c1xuICAgIH07XG4gICAgdmFyIHBvcyA9IHRoaXMuYmluU2VhcmNoKHN1YnRhYmxlLmNvdmVyYWdlLmdseXBocywgY292ZXJhZ2VHbHlwaCk7XG4gICAgaWYgKHBvcyA+PSAwKSB7XG4gICAgICAgIC8vIGxpZ2F0dXJlU2V0IGFscmVhZHkgZXhpc3RzXG4gICAgICAgIHZhciBsaWdhdHVyZVNldCA9IHN1YnRhYmxlLmxpZ2F0dXJlU2V0c1twb3NdO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxpZ2F0dXJlU2V0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAvLyBJZiBsaWdhdHVyZSBhbHJlYWR5IGV4aXN0cywgcmV0dXJuLlxuICAgICAgICAgICAgaWYgKGFycmF5c0VxdWFsKGxpZ2F0dXJlU2V0W2ldLmNvbXBvbmVudHMsIGxpZ0NvbXBvbmVudHMpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIGxpZ2F0dXJlIGRvZXMgbm90IGV4aXN0OiBhZGQgaXQuXG4gICAgICAgIGxpZ2F0dXJlU2V0LnB1c2gobGlnYXR1cmVUYWJsZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgLy8gQ3JlYXRlIGEgbmV3IGxpZ2F0dXJlU2V0IGFuZCBhZGQgY292ZXJhZ2UgZm9yIHRoZSBmaXJzdCBnbHlwaC5cbiAgICAgICAgcG9zID0gLTEgLSBwb3M7XG4gICAgICAgIHN1YnRhYmxlLmNvdmVyYWdlLmdseXBocy5zcGxpY2UocG9zLCAwLCBjb3ZlcmFnZUdseXBoKTtcbiAgICAgICAgc3VidGFibGUubGlnYXR1cmVTZXRzLnNwbGljZShwb3MsIDAsIFtsaWdhdHVyZVRhYmxlXSk7XG4gICAgfVxufTtcblxuLyoqXG4gKiBMaXN0IGFsbCBmZWF0dXJlIGRhdGEgZm9yIGEgZ2l2ZW4gc2NyaXB0IGFuZCBsYW5ndWFnZS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBmZWF0dXJlIC0gNC1sZXR0ZXIgZmVhdHVyZSBuYW1lXG4gKiBAcGFyYW0ge3N0cmluZ30gW3NjcmlwdD0nREZMVCddXG4gKiBAcGFyYW0ge3N0cmluZ30gW2xhbmd1YWdlPSdkZmx0J11cbiAqIEByZXR1cm4ge0FycmF5fSBzdWJzdGl0dXRpb25zIC0gVGhlIGxpc3Qgb2Ygc3Vic3RpdHV0aW9ucy5cbiAqL1xuU3Vic3RpdHV0aW9uLnByb3RvdHlwZS5nZXRGZWF0dXJlID0gZnVuY3Rpb24oZmVhdHVyZSwgc2NyaXB0LCBsYW5ndWFnZSkge1xuICAgIGlmICgvc3NcXGRcXGQvLnRlc3QoZmVhdHVyZSkpIHtcbiAgICAgICAgLy8gc3MwMSAtIHNzMjBcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0U2luZ2xlKGZlYXR1cmUsIHNjcmlwdCwgbGFuZ3VhZ2UpO1xuICAgIH1cbiAgICBzd2l0Y2ggKGZlYXR1cmUpIHtcbiAgICAgICAgY2FzZSAnYWFsdCc6XG4gICAgICAgIGNhc2UgJ3NhbHQnOlxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0U2luZ2xlKGZlYXR1cmUsIHNjcmlwdCwgbGFuZ3VhZ2UpXG4gICAgICAgICAgICAgICAgICAgIC5jb25jYXQodGhpcy5nZXRBbHRlcm5hdGVzKGZlYXR1cmUsIHNjcmlwdCwgbGFuZ3VhZ2UpKTtcbiAgICAgICAgY2FzZSAnZGxpZyc6XG4gICAgICAgIGNhc2UgJ2xpZ2EnOlxuICAgICAgICBjYXNlICdybGlnJzpcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmdldExpZ2F0dXJlcyhmZWF0dXJlLCBzY3JpcHQsIGxhbmd1YWdlKTtcbiAgICAgICAgY2FzZSAnY2NtcCc6XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5nZXRNdWx0aXBsZShmZWF0dXJlLCBzY3JpcHQsIGxhbmd1YWdlKVxuICAgICAgICAgICAgICAgIC5jb25jYXQodGhpcy5nZXRMaWdhdHVyZXMoZmVhdHVyZSwgc2NyaXB0LCBsYW5ndWFnZSkpO1xuICAgICAgICBjYXNlICdzdGNoJzpcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmdldE11bHRpcGxlKGZlYXR1cmUsIHNjcmlwdCwgbGFuZ3VhZ2UpO1xuICAgIH1cbiAgICByZXR1cm4gdW5kZWZpbmVkO1xufTtcblxuLyoqXG4gKiBBZGQgYSBzdWJzdGl0dXRpb24gdG8gYSBmZWF0dXJlIGZvciBhIGdpdmVuIHNjcmlwdCBhbmQgbGFuZ3VhZ2UuXG4gKiBAcGFyYW0ge3N0cmluZ30gZmVhdHVyZSAtIDQtbGV0dGVyIGZlYXR1cmUgbmFtZVxuICogQHBhcmFtIHtPYmplY3R9IHN1YiAtIHRoZSBzdWJzdGl0dXRpb24gdG8gYWRkIChhbiBvYmplY3QgbGlrZSB7IHN1YjogaWQgb3IgW2lkc10sIGJ5OiBpZCBvciBbaWRzXSB9KVxuICogQHBhcmFtIHtzdHJpbmd9IFtzY3JpcHQ9J0RGTFQnXVxuICogQHBhcmFtIHtzdHJpbmd9IFtsYW5ndWFnZT0nZGZsdCddXG4gKi9cblN1YnN0aXR1dGlvbi5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24oZmVhdHVyZSwgc3ViLCBzY3JpcHQsIGxhbmd1YWdlKSB7XG4gICAgaWYgKC9zc1xcZFxcZC8udGVzdChmZWF0dXJlKSkge1xuICAgICAgICAvLyBzczAxIC0gc3MyMFxuICAgICAgICByZXR1cm4gdGhpcy5hZGRTaW5nbGUoZmVhdHVyZSwgc3ViLCBzY3JpcHQsIGxhbmd1YWdlKTtcbiAgICB9XG4gICAgc3dpdGNoIChmZWF0dXJlKSB7XG4gICAgICAgIGNhc2UgJ2FhbHQnOlxuICAgICAgICBjYXNlICdzYWx0JzpcbiAgICAgICAgICAgIGlmICh0eXBlb2Ygc3ViLmJ5ID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmFkZFNpbmdsZShmZWF0dXJlLCBzdWIsIHNjcmlwdCwgbGFuZ3VhZ2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuYWRkQWx0ZXJuYXRlKGZlYXR1cmUsIHN1Yiwgc2NyaXB0LCBsYW5ndWFnZSk7XG4gICAgICAgIGNhc2UgJ2RsaWcnOlxuICAgICAgICBjYXNlICdsaWdhJzpcbiAgICAgICAgY2FzZSAncmxpZyc6XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5hZGRMaWdhdHVyZShmZWF0dXJlLCBzdWIsIHNjcmlwdCwgbGFuZ3VhZ2UpO1xuICAgICAgICBjYXNlICdjY21wJzpcbiAgICAgICAgICAgIGlmIChzdWIuYnkgaW5zdGFuY2VvZiBBcnJheSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmFkZE11bHRpcGxlKGZlYXR1cmUsIHN1Yiwgc2NyaXB0LCBsYW5ndWFnZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5hZGRMaWdhdHVyZShmZWF0dXJlLCBzdWIsIHNjcmlwdCwgbGFuZ3VhZ2UpO1xuICAgIH1cbiAgICByZXR1cm4gdW5kZWZpbmVkO1xufTtcblxuZnVuY3Rpb24gaXNCcm93c2VyKCkge1xuICAgIHJldHVybiB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJztcbn1cblxuZnVuY3Rpb24gbm9kZUJ1ZmZlclRvQXJyYXlCdWZmZXIoYnVmZmVyKSB7XG4gICAgdmFyIGFiID0gbmV3IEFycmF5QnVmZmVyKGJ1ZmZlci5sZW5ndGgpO1xuICAgIHZhciB2aWV3ID0gbmV3IFVpbnQ4QXJyYXkoYWIpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYnVmZmVyLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIHZpZXdbaV0gPSBidWZmZXJbaV07XG4gICAgfVxuXG4gICAgcmV0dXJuIGFiO1xufVxuXG5mdW5jdGlvbiBhcnJheUJ1ZmZlclRvTm9kZUJ1ZmZlcihhYikge1xuICAgIHZhciBidWZmZXIgPSBuZXcgQnVmZmVyKGFiLmJ5dGVMZW5ndGgpO1xuICAgIHZhciB2aWV3ID0gbmV3IFVpbnQ4QXJyYXkoYWIpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYnVmZmVyLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIGJ1ZmZlcltpXSA9IHZpZXdbaV07XG4gICAgfVxuXG4gICAgcmV0dXJuIGJ1ZmZlcjtcbn1cblxuZnVuY3Rpb24gY2hlY2tBcmd1bWVudChleHByZXNzaW9uLCBtZXNzYWdlKSB7XG4gICAgaWYgKCFleHByZXNzaW9uKSB7XG4gICAgICAgIHRocm93IG1lc3NhZ2U7XG4gICAgfVxufVxuXG4vLyBUaGUgYGdseWZgIHRhYmxlIGRlc2NyaWJlcyB0aGUgZ2x5cGhzIGluIFRydWVUeXBlIG91dGxpbmUgZm9ybWF0LlxuXG4vLyBQYXJzZSB0aGUgY29vcmRpbmF0ZSBkYXRhIGZvciBhIGdseXBoLlxuZnVuY3Rpb24gcGFyc2VHbHlwaENvb3JkaW5hdGUocCwgZmxhZywgcHJldmlvdXNWYWx1ZSwgc2hvcnRWZWN0b3JCaXRNYXNrLCBzYW1lQml0TWFzaykge1xuICAgIHZhciB2O1xuICAgIGlmICgoZmxhZyAmIHNob3J0VmVjdG9yQml0TWFzaykgPiAwKSB7XG4gICAgICAgIC8vIFRoZSBjb29yZGluYXRlIGlzIDEgYnl0ZSBsb25nLlxuICAgICAgICB2ID0gcC5wYXJzZUJ5dGUoKTtcbiAgICAgICAgLy8gVGhlIGBzYW1lYCBiaXQgaXMgcmUtdXNlZCBmb3Igc2hvcnQgdmFsdWVzIHRvIHNpZ25pZnkgdGhlIHNpZ24gb2YgdGhlIHZhbHVlLlxuICAgICAgICBpZiAoKGZsYWcgJiBzYW1lQml0TWFzaykgPT09IDApIHtcbiAgICAgICAgICAgIHYgPSAtdjtcbiAgICAgICAgfVxuXG4gICAgICAgIHYgPSBwcmV2aW91c1ZhbHVlICsgdjtcbiAgICB9IGVsc2Uge1xuICAgICAgICAvLyAgVGhlIGNvb3JkaW5hdGUgaXMgMiBieXRlcyBsb25nLlxuICAgICAgICAvLyBJZiB0aGUgYHNhbWVgIGJpdCBpcyBzZXQsIHRoZSBjb29yZGluYXRlIGlzIHRoZSBzYW1lIGFzIHRoZSBwcmV2aW91cyBjb29yZGluYXRlLlxuICAgICAgICBpZiAoKGZsYWcgJiBzYW1lQml0TWFzaykgPiAwKSB7XG4gICAgICAgICAgICB2ID0gcHJldmlvdXNWYWx1ZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIFBhcnNlIHRoZSBjb29yZGluYXRlIGFzIGEgc2lnbmVkIDE2LWJpdCBkZWx0YSB2YWx1ZS5cbiAgICAgICAgICAgIHYgPSBwcmV2aW91c1ZhbHVlICsgcC5wYXJzZVNob3J0KCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdjtcbn1cblxuLy8gUGFyc2UgYSBUcnVlVHlwZSBnbHlwaC5cbmZ1bmN0aW9uIHBhcnNlR2x5cGgoZ2x5cGgsIGRhdGEsIHN0YXJ0KSB7XG4gICAgdmFyIHAgPSBuZXcgcGFyc2UuUGFyc2VyKGRhdGEsIHN0YXJ0KTtcbiAgICBnbHlwaC5udW1iZXJPZkNvbnRvdXJzID0gcC5wYXJzZVNob3J0KCk7XG4gICAgZ2x5cGguX3hNaW4gPSBwLnBhcnNlU2hvcnQoKTtcbiAgICBnbHlwaC5feU1pbiA9IHAucGFyc2VTaG9ydCgpO1xuICAgIGdseXBoLl94TWF4ID0gcC5wYXJzZVNob3J0KCk7XG4gICAgZ2x5cGguX3lNYXggPSBwLnBhcnNlU2hvcnQoKTtcbiAgICB2YXIgZmxhZ3M7XG4gICAgdmFyIGZsYWc7XG5cbiAgICBpZiAoZ2x5cGgubnVtYmVyT2ZDb250b3VycyA+IDApIHtcbiAgICAgICAgLy8gVGhpcyBnbHlwaCBpcyBub3QgYSBjb21wb3NpdGUuXG4gICAgICAgIHZhciBlbmRQb2ludEluZGljZXMgPSBnbHlwaC5lbmRQb2ludEluZGljZXMgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBnbHlwaC5udW1iZXJPZkNvbnRvdXJzOyBpICs9IDEpIHtcbiAgICAgICAgICAgIGVuZFBvaW50SW5kaWNlcy5wdXNoKHAucGFyc2VVU2hvcnQoKSk7XG4gICAgICAgIH1cblxuICAgICAgICBnbHlwaC5pbnN0cnVjdGlvbkxlbmd0aCA9IHAucGFyc2VVU2hvcnQoKTtcbiAgICAgICAgZ2x5cGguaW5zdHJ1Y3Rpb25zID0gW107XG4gICAgICAgIGZvciAodmFyIGkkMSA9IDA7IGkkMSA8IGdseXBoLmluc3RydWN0aW9uTGVuZ3RoOyBpJDEgKz0gMSkge1xuICAgICAgICAgICAgZ2x5cGguaW5zdHJ1Y3Rpb25zLnB1c2gocC5wYXJzZUJ5dGUoKSk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgbnVtYmVyT2ZDb29yZGluYXRlcyA9IGVuZFBvaW50SW5kaWNlc1tlbmRQb2ludEluZGljZXMubGVuZ3RoIC0gMV0gKyAxO1xuICAgICAgICBmbGFncyA9IFtdO1xuICAgICAgICBmb3IgKHZhciBpJDIgPSAwOyBpJDIgPCBudW1iZXJPZkNvb3JkaW5hdGVzOyBpJDIgKz0gMSkge1xuICAgICAgICAgICAgZmxhZyA9IHAucGFyc2VCeXRlKCk7XG4gICAgICAgICAgICBmbGFncy5wdXNoKGZsYWcpO1xuICAgICAgICAgICAgLy8gSWYgYml0IDMgaXMgc2V0LCB3ZSByZXBlYXQgdGhpcyBmbGFnIG4gdGltZXMsIHdoZXJlIG4gaXMgdGhlIG5leHQgYnl0ZS5cbiAgICAgICAgICAgIGlmICgoZmxhZyAmIDgpID4gMCkge1xuICAgICAgICAgICAgICAgIHZhciByZXBlYXRDb3VudCA9IHAucGFyc2VCeXRlKCk7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCByZXBlYXRDb3VudDsgaiArPSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIGZsYWdzLnB1c2goZmxhZyk7XG4gICAgICAgICAgICAgICAgICAgIGkkMiArPSAxO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGNoZWNrLmFyZ3VtZW50KGZsYWdzLmxlbmd0aCA9PT0gbnVtYmVyT2ZDb29yZGluYXRlcywgJ0JhZCBmbGFncy4nKTtcblxuICAgICAgICBpZiAoZW5kUG9pbnRJbmRpY2VzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIHZhciBwb2ludHMgPSBbXTtcbiAgICAgICAgICAgIHZhciBwb2ludDtcbiAgICAgICAgICAgIC8vIFgvWSBjb29yZGluYXRlcyBhcmUgcmVsYXRpdmUgdG8gdGhlIHByZXZpb3VzIHBvaW50LCBleGNlcHQgZm9yIHRoZSBmaXJzdCBwb2ludCB3aGljaCBpcyByZWxhdGl2ZSB0byAwLDAuXG4gICAgICAgICAgICBpZiAobnVtYmVyT2ZDb29yZGluYXRlcyA+IDApIHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpJDMgPSAwOyBpJDMgPCBudW1iZXJPZkNvb3JkaW5hdGVzOyBpJDMgKz0gMSkge1xuICAgICAgICAgICAgICAgICAgICBmbGFnID0gZmxhZ3NbaSQzXTtcbiAgICAgICAgICAgICAgICAgICAgcG9pbnQgPSB7fTtcbiAgICAgICAgICAgICAgICAgICAgcG9pbnQub25DdXJ2ZSA9ICEhKGZsYWcgJiAxKTtcbiAgICAgICAgICAgICAgICAgICAgcG9pbnQubGFzdFBvaW50T2ZDb250b3VyID0gZW5kUG9pbnRJbmRpY2VzLmluZGV4T2YoaSQzKSA+PSAwO1xuICAgICAgICAgICAgICAgICAgICBwb2ludHMucHVzaChwb2ludCk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdmFyIHB4ID0gMDtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpJDQgPSAwOyBpJDQgPCBudW1iZXJPZkNvb3JkaW5hdGVzOyBpJDQgKz0gMSkge1xuICAgICAgICAgICAgICAgICAgICBmbGFnID0gZmxhZ3NbaSQ0XTtcbiAgICAgICAgICAgICAgICAgICAgcG9pbnQgPSBwb2ludHNbaSQ0XTtcbiAgICAgICAgICAgICAgICAgICAgcG9pbnQueCA9IHBhcnNlR2x5cGhDb29yZGluYXRlKHAsIGZsYWcsIHB4LCAyLCAxNik7XG4gICAgICAgICAgICAgICAgICAgIHB4ID0gcG9pbnQueDtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB2YXIgcHkgPSAwO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkkNSA9IDA7IGkkNSA8IG51bWJlck9mQ29vcmRpbmF0ZXM7IGkkNSArPSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIGZsYWcgPSBmbGFnc1tpJDVdO1xuICAgICAgICAgICAgICAgICAgICBwb2ludCA9IHBvaW50c1tpJDVdO1xuICAgICAgICAgICAgICAgICAgICBwb2ludC55ID0gcGFyc2VHbHlwaENvb3JkaW5hdGUocCwgZmxhZywgcHksIDQsIDMyKTtcbiAgICAgICAgICAgICAgICAgICAgcHkgPSBwb2ludC55O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZ2x5cGgucG9pbnRzID0gcG9pbnRzO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZ2x5cGgucG9pbnRzID0gW107XG4gICAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGdseXBoLm51bWJlck9mQ29udG91cnMgPT09IDApIHtcbiAgICAgICAgZ2x5cGgucG9pbnRzID0gW107XG4gICAgfSBlbHNlIHtcbiAgICAgICAgZ2x5cGguaXNDb21wb3NpdGUgPSB0cnVlO1xuICAgICAgICBnbHlwaC5wb2ludHMgPSBbXTtcbiAgICAgICAgZ2x5cGguY29tcG9uZW50cyA9IFtdO1xuICAgICAgICB2YXIgbW9yZUNvbXBvbmVudHMgPSB0cnVlO1xuICAgICAgICB3aGlsZSAobW9yZUNvbXBvbmVudHMpIHtcbiAgICAgICAgICAgIGZsYWdzID0gcC5wYXJzZVVTaG9ydCgpO1xuICAgICAgICAgICAgdmFyIGNvbXBvbmVudCA9IHtcbiAgICAgICAgICAgICAgICBnbHlwaEluZGV4OiBwLnBhcnNlVVNob3J0KCksXG4gICAgICAgICAgICAgICAgeFNjYWxlOiAxLFxuICAgICAgICAgICAgICAgIHNjYWxlMDE6IDAsXG4gICAgICAgICAgICAgICAgc2NhbGUxMDogMCxcbiAgICAgICAgICAgICAgICB5U2NhbGU6IDEsXG4gICAgICAgICAgICAgICAgZHg6IDAsXG4gICAgICAgICAgICAgICAgZHk6IDBcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBpZiAoKGZsYWdzICYgMSkgPiAwKSB7XG4gICAgICAgICAgICAgICAgLy8gVGhlIGFyZ3VtZW50cyBhcmUgd29yZHNcbiAgICAgICAgICAgICAgICBpZiAoKGZsYWdzICYgMikgPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIHZhbHVlcyBhcmUgb2Zmc2V0XG4gICAgICAgICAgICAgICAgICAgIGNvbXBvbmVudC5keCA9IHAucGFyc2VTaG9ydCgpO1xuICAgICAgICAgICAgICAgICAgICBjb21wb25lbnQuZHkgPSBwLnBhcnNlU2hvcnQoKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyB2YWx1ZXMgYXJlIG1hdGNoZWQgcG9pbnRzXG4gICAgICAgICAgICAgICAgICAgIGNvbXBvbmVudC5tYXRjaGVkUG9pbnRzID0gW3AucGFyc2VVU2hvcnQoKSwgcC5wYXJzZVVTaG9ydCgpXTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gVGhlIGFyZ3VtZW50cyBhcmUgYnl0ZXNcbiAgICAgICAgICAgICAgICBpZiAoKGZsYWdzICYgMikgPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIHZhbHVlcyBhcmUgb2Zmc2V0XG4gICAgICAgICAgICAgICAgICAgIGNvbXBvbmVudC5keCA9IHAucGFyc2VDaGFyKCk7XG4gICAgICAgICAgICAgICAgICAgIGNvbXBvbmVudC5keSA9IHAucGFyc2VDaGFyKCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gdmFsdWVzIGFyZSBtYXRjaGVkIHBvaW50c1xuICAgICAgICAgICAgICAgICAgICBjb21wb25lbnQubWF0Y2hlZFBvaW50cyA9IFtwLnBhcnNlQnl0ZSgpLCBwLnBhcnNlQnl0ZSgpXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICgoZmxhZ3MgJiA4KSA+IDApIHtcbiAgICAgICAgICAgICAgICAvLyBXZSBoYXZlIGEgc2NhbGVcbiAgICAgICAgICAgICAgICBjb21wb25lbnQueFNjYWxlID0gY29tcG9uZW50LnlTY2FsZSA9IHAucGFyc2VGMkRvdDE0KCk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKChmbGFncyAmIDY0KSA+IDApIHtcbiAgICAgICAgICAgICAgICAvLyBXZSBoYXZlIGFuIFggLyBZIHNjYWxlXG4gICAgICAgICAgICAgICAgY29tcG9uZW50LnhTY2FsZSA9IHAucGFyc2VGMkRvdDE0KCk7XG4gICAgICAgICAgICAgICAgY29tcG9uZW50LnlTY2FsZSA9IHAucGFyc2VGMkRvdDE0KCk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKChmbGFncyAmIDEyOCkgPiAwKSB7XG4gICAgICAgICAgICAgICAgLy8gV2UgaGF2ZSBhIDJ4MiB0cmFuc2Zvcm1hdGlvblxuICAgICAgICAgICAgICAgIGNvbXBvbmVudC54U2NhbGUgPSBwLnBhcnNlRjJEb3QxNCgpO1xuICAgICAgICAgICAgICAgIGNvbXBvbmVudC5zY2FsZTAxID0gcC5wYXJzZUYyRG90MTQoKTtcbiAgICAgICAgICAgICAgICBjb21wb25lbnQuc2NhbGUxMCA9IHAucGFyc2VGMkRvdDE0KCk7XG4gICAgICAgICAgICAgICAgY29tcG9uZW50LnlTY2FsZSA9IHAucGFyc2VGMkRvdDE0KCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGdseXBoLmNvbXBvbmVudHMucHVzaChjb21wb25lbnQpO1xuICAgICAgICAgICAgbW9yZUNvbXBvbmVudHMgPSAhIShmbGFncyAmIDMyKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZmxhZ3MgJiAweDEwMCkge1xuICAgICAgICAgICAgLy8gV2UgaGF2ZSBpbnN0cnVjdGlvbnNcbiAgICAgICAgICAgIGdseXBoLmluc3RydWN0aW9uTGVuZ3RoID0gcC5wYXJzZVVTaG9ydCgpO1xuICAgICAgICAgICAgZ2x5cGguaW5zdHJ1Y3Rpb25zID0gW107XG4gICAgICAgICAgICBmb3IgKHZhciBpJDYgPSAwOyBpJDYgPCBnbHlwaC5pbnN0cnVjdGlvbkxlbmd0aDsgaSQ2ICs9IDEpIHtcbiAgICAgICAgICAgICAgICBnbHlwaC5pbnN0cnVjdGlvbnMucHVzaChwLnBhcnNlQnl0ZSgpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn1cblxuLy8gVHJhbnNmb3JtIGFuIGFycmF5IG9mIHBvaW50cyBhbmQgcmV0dXJuIGEgbmV3IGFycmF5LlxuZnVuY3Rpb24gdHJhbnNmb3JtUG9pbnRzKHBvaW50cywgdHJhbnNmb3JtKSB7XG4gICAgdmFyIG5ld1BvaW50cyA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcG9pbnRzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgIHZhciBwdCA9IHBvaW50c1tpXTtcbiAgICAgICAgdmFyIG5ld1B0ID0ge1xuICAgICAgICAgICAgeDogdHJhbnNmb3JtLnhTY2FsZSAqIHB0LnggKyB0cmFuc2Zvcm0uc2NhbGUwMSAqIHB0LnkgKyB0cmFuc2Zvcm0uZHgsXG4gICAgICAgICAgICB5OiB0cmFuc2Zvcm0uc2NhbGUxMCAqIHB0LnggKyB0cmFuc2Zvcm0ueVNjYWxlICogcHQueSArIHRyYW5zZm9ybS5keSxcbiAgICAgICAgICAgIG9uQ3VydmU6IHB0Lm9uQ3VydmUsXG4gICAgICAgICAgICBsYXN0UG9pbnRPZkNvbnRvdXI6IHB0Lmxhc3RQb2ludE9mQ29udG91clxuICAgICAgICB9O1xuICAgICAgICBuZXdQb2ludHMucHVzaChuZXdQdCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG5ld1BvaW50cztcbn1cblxuZnVuY3Rpb24gZ2V0Q29udG91cnMocG9pbnRzKSB7XG4gICAgdmFyIGNvbnRvdXJzID0gW107XG4gICAgdmFyIGN1cnJlbnRDb250b3VyID0gW107XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwb2ludHMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgdmFyIHB0ID0gcG9pbnRzW2ldO1xuICAgICAgICBjdXJyZW50Q29udG91ci5wdXNoKHB0KTtcbiAgICAgICAgaWYgKHB0Lmxhc3RQb2ludE9mQ29udG91cikge1xuICAgICAgICAgICAgY29udG91cnMucHVzaChjdXJyZW50Q29udG91cik7XG4gICAgICAgICAgICBjdXJyZW50Q29udG91ciA9IFtdO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgY2hlY2suYXJndW1lbnQoY3VycmVudENvbnRvdXIubGVuZ3RoID09PSAwLCAnVGhlcmUgYXJlIHN0aWxsIHBvaW50cyBsZWZ0IGluIHRoZSBjdXJyZW50IGNvbnRvdXIuJyk7XG4gICAgcmV0dXJuIGNvbnRvdXJzO1xufVxuXG4vLyBDb252ZXJ0IHRoZSBUcnVlVHlwZSBnbHlwaCBvdXRsaW5lIHRvIGEgUGF0aC5cbmZ1bmN0aW9uIGdldFBhdGgocG9pbnRzKSB7XG4gICAgdmFyIHAgPSBuZXcgUGF0aCgpO1xuICAgIGlmICghcG9pbnRzKSB7XG4gICAgICAgIHJldHVybiBwO1xuICAgIH1cblxuICAgIHZhciBjb250b3VycyA9IGdldENvbnRvdXJzKHBvaW50cyk7XG5cbiAgICBmb3IgKHZhciBjb250b3VySW5kZXggPSAwOyBjb250b3VySW5kZXggPCBjb250b3Vycy5sZW5ndGg7ICsrY29udG91ckluZGV4KSB7XG4gICAgICAgIHZhciBjb250b3VyID0gY29udG91cnNbY29udG91ckluZGV4XTtcblxuICAgICAgICB2YXIgcHJldiA9IG51bGw7XG4gICAgICAgIHZhciBjdXJyID0gY29udG91cltjb250b3VyLmxlbmd0aCAtIDFdO1xuICAgICAgICB2YXIgbmV4dCA9IGNvbnRvdXJbMF07XG5cbiAgICAgICAgaWYgKGN1cnIub25DdXJ2ZSkge1xuICAgICAgICAgICAgcC5tb3ZlVG8oY3Vyci54LCBjdXJyLnkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKG5leHQub25DdXJ2ZSkge1xuICAgICAgICAgICAgICAgIHAubW92ZVRvKG5leHQueCwgbmV4dC55KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gSWYgYm90aCBmaXJzdCBhbmQgbGFzdCBwb2ludHMgYXJlIG9mZi1jdXJ2ZSwgc3RhcnQgYXQgdGhlaXIgbWlkZGxlLlxuICAgICAgICAgICAgICAgIHZhciBzdGFydCA9IHt4OiAoY3Vyci54ICsgbmV4dC54KSAqIDAuNSwgeTogKGN1cnIueSArIG5leHQueSkgKiAwLjV9O1xuICAgICAgICAgICAgICAgIHAubW92ZVRvKHN0YXJ0LngsIHN0YXJ0LnkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb250b3VyLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICBwcmV2ID0gY3VycjtcbiAgICAgICAgICAgIGN1cnIgPSBuZXh0O1xuICAgICAgICAgICAgbmV4dCA9IGNvbnRvdXJbKGkgKyAxKSAlIGNvbnRvdXIubGVuZ3RoXTtcblxuICAgICAgICAgICAgaWYgKGN1cnIub25DdXJ2ZSkge1xuICAgICAgICAgICAgICAgIC8vIFRoaXMgaXMgYSBzdHJhaWdodCBsaW5lLlxuICAgICAgICAgICAgICAgIHAubGluZVRvKGN1cnIueCwgY3Vyci55KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdmFyIHByZXYyID0gcHJldjtcbiAgICAgICAgICAgICAgICB2YXIgbmV4dDIgPSBuZXh0O1xuXG4gICAgICAgICAgICAgICAgaWYgKCFwcmV2Lm9uQ3VydmUpIHtcbiAgICAgICAgICAgICAgICAgICAgcHJldjIgPSB7IHg6IChjdXJyLnggKyBwcmV2LngpICogMC41LCB5OiAoY3Vyci55ICsgcHJldi55KSAqIDAuNSB9O1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmICghbmV4dC5vbkN1cnZlKSB7XG4gICAgICAgICAgICAgICAgICAgIG5leHQyID0geyB4OiAoY3Vyci54ICsgbmV4dC54KSAqIDAuNSwgeTogKGN1cnIueSArIG5leHQueSkgKiAwLjUgfTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBwLnF1YWRyYXRpY0N1cnZlVG8oY3Vyci54LCBjdXJyLnksIG5leHQyLngsIG5leHQyLnkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcC5jbG9zZVBhdGgoKTtcbiAgICB9XG4gICAgcmV0dXJuIHA7XG59XG5cbmZ1bmN0aW9uIGJ1aWxkUGF0aChnbHlwaHMsIGdseXBoKSB7XG4gICAgaWYgKGdseXBoLmlzQ29tcG9zaXRlKSB7XG4gICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgZ2x5cGguY29tcG9uZW50cy5sZW5ndGg7IGogKz0gMSkge1xuICAgICAgICAgICAgdmFyIGNvbXBvbmVudCA9IGdseXBoLmNvbXBvbmVudHNbal07XG4gICAgICAgICAgICB2YXIgY29tcG9uZW50R2x5cGggPSBnbHlwaHMuZ2V0KGNvbXBvbmVudC5nbHlwaEluZGV4KTtcbiAgICAgICAgICAgIC8vIEZvcmNlIHRoZSB0dGZHbHlwaExvYWRlciB0byBwYXJzZSB0aGUgZ2x5cGguXG4gICAgICAgICAgICBjb21wb25lbnRHbHlwaC5nZXRQYXRoKCk7XG4gICAgICAgICAgICBpZiAoY29tcG9uZW50R2x5cGgucG9pbnRzKSB7XG4gICAgICAgICAgICAgICAgdmFyIHRyYW5zZm9ybWVkUG9pbnRzID0gKHZvaWQgMCk7XG4gICAgICAgICAgICAgICAgaWYgKGNvbXBvbmVudC5tYXRjaGVkUG9pbnRzID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gY29tcG9uZW50IHBvc2l0aW9uZWQgYnkgb2Zmc2V0XG4gICAgICAgICAgICAgICAgICAgIHRyYW5zZm9ybWVkUG9pbnRzID0gdHJhbnNmb3JtUG9pbnRzKGNvbXBvbmVudEdseXBoLnBvaW50cywgY29tcG9uZW50KTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyBjb21wb25lbnQgcG9zaXRpb25lZCBieSBtYXRjaGVkIHBvaW50c1xuICAgICAgICAgICAgICAgICAgICBpZiAoKGNvbXBvbmVudC5tYXRjaGVkUG9pbnRzWzBdID4gZ2x5cGgucG9pbnRzLmxlbmd0aCAtIDEpIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAoY29tcG9uZW50Lm1hdGNoZWRQb2ludHNbMV0gPiBjb21wb25lbnRHbHlwaC5wb2ludHMubGVuZ3RoIC0gMSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IEVycm9yKCdNYXRjaGVkIHBvaW50cyBvdXQgb2YgcmFuZ2UgaW4gJyArIGdseXBoLm5hbWUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHZhciBmaXJzdFB0ID0gZ2x5cGgucG9pbnRzW2NvbXBvbmVudC5tYXRjaGVkUG9pbnRzWzBdXTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHNlY29uZFB0ID0gY29tcG9uZW50R2x5cGgucG9pbnRzW2NvbXBvbmVudC5tYXRjaGVkUG9pbnRzWzFdXTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHRyYW5zZm9ybSA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHhTY2FsZTogY29tcG9uZW50LnhTY2FsZSwgc2NhbGUwMTogY29tcG9uZW50LnNjYWxlMDEsXG4gICAgICAgICAgICAgICAgICAgICAgICBzY2FsZTEwOiBjb21wb25lbnQuc2NhbGUxMCwgeVNjYWxlOiBjb21wb25lbnQueVNjYWxlLFxuICAgICAgICAgICAgICAgICAgICAgICAgZHg6IDAsIGR5OiAwXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIHNlY29uZFB0ID0gdHJhbnNmb3JtUG9pbnRzKFtzZWNvbmRQdF0sIHRyYW5zZm9ybSlbMF07XG4gICAgICAgICAgICAgICAgICAgIHRyYW5zZm9ybS5keCA9IGZpcnN0UHQueCAtIHNlY29uZFB0Lng7XG4gICAgICAgICAgICAgICAgICAgIHRyYW5zZm9ybS5keSA9IGZpcnN0UHQueSAtIHNlY29uZFB0Lnk7XG4gICAgICAgICAgICAgICAgICAgIHRyYW5zZm9ybWVkUG9pbnRzID0gdHJhbnNmb3JtUG9pbnRzKGNvbXBvbmVudEdseXBoLnBvaW50cywgdHJhbnNmb3JtKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZ2x5cGgucG9pbnRzID0gZ2x5cGgucG9pbnRzLmNvbmNhdCh0cmFuc2Zvcm1lZFBvaW50cyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gZ2V0UGF0aChnbHlwaC5wb2ludHMpO1xufVxuXG5mdW5jdGlvbiBwYXJzZUdseWZUYWJsZUFsbChkYXRhLCBzdGFydCwgbG9jYSwgZm9udCkge1xuICAgIHZhciBnbHlwaHMgPSBuZXcgZ2x5cGhzZXQuR2x5cGhTZXQoZm9udCk7XG5cbiAgICAvLyBUaGUgbGFzdCBlbGVtZW50IG9mIHRoZSBsb2NhIHRhYmxlIGlzIGludmFsaWQuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsb2NhLmxlbmd0aCAtIDE7IGkgKz0gMSkge1xuICAgICAgICB2YXIgb2Zmc2V0ID0gbG9jYVtpXTtcbiAgICAgICAgdmFyIG5leHRPZmZzZXQgPSBsb2NhW2kgKyAxXTtcbiAgICAgICAgaWYgKG9mZnNldCAhPT0gbmV4dE9mZnNldCkge1xuICAgICAgICAgICAgZ2x5cGhzLnB1c2goaSwgZ2x5cGhzZXQudHRmR2x5cGhMb2FkZXIoZm9udCwgaSwgcGFyc2VHbHlwaCwgZGF0YSwgc3RhcnQgKyBvZmZzZXQsIGJ1aWxkUGF0aCkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZ2x5cGhzLnB1c2goaSwgZ2x5cGhzZXQuZ2x5cGhMb2FkZXIoZm9udCwgaSkpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGdseXBocztcbn1cblxuZnVuY3Rpb24gcGFyc2VHbHlmVGFibGVPbkxvd01lbW9yeShkYXRhLCBzdGFydCwgbG9jYSwgZm9udCkge1xuICAgIHZhciBnbHlwaHMgPSBuZXcgZ2x5cGhzZXQuR2x5cGhTZXQoZm9udCk7XG5cbiAgICBmb250Ll9wdXNoID0gZnVuY3Rpb24oaSkge1xuICAgICAgICB2YXIgb2Zmc2V0ID0gbG9jYVtpXTtcbiAgICAgICAgdmFyIG5leHRPZmZzZXQgPSBsb2NhW2kgKyAxXTtcbiAgICAgICAgaWYgKG9mZnNldCAhPT0gbmV4dE9mZnNldCkge1xuICAgICAgICAgICAgZ2x5cGhzLnB1c2goaSwgZ2x5cGhzZXQudHRmR2x5cGhMb2FkZXIoZm9udCwgaSwgcGFyc2VHbHlwaCwgZGF0YSwgc3RhcnQgKyBvZmZzZXQsIGJ1aWxkUGF0aCkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZ2x5cGhzLnB1c2goaSwgZ2x5cGhzZXQuZ2x5cGhMb2FkZXIoZm9udCwgaSkpO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIHJldHVybiBnbHlwaHM7XG59XG5cbi8vIFBhcnNlIGFsbCB0aGUgZ2x5cGhzIGFjY29yZGluZyB0byB0aGUgb2Zmc2V0cyBmcm9tIHRoZSBgbG9jYWAgdGFibGUuXG5mdW5jdGlvbiBwYXJzZUdseWZUYWJsZShkYXRhLCBzdGFydCwgbG9jYSwgZm9udCwgb3B0KSB7XG4gICAgaWYgKG9wdC5sb3dNZW1vcnkpXG4gICAgICAgIHsgcmV0dXJuIHBhcnNlR2x5ZlRhYmxlT25Mb3dNZW1vcnkoZGF0YSwgc3RhcnQsIGxvY2EsIGZvbnQpOyB9XG4gICAgZWxzZVxuICAgICAgICB7IHJldHVybiBwYXJzZUdseWZUYWJsZUFsbChkYXRhLCBzdGFydCwgbG9jYSwgZm9udCk7IH1cbn1cblxudmFyIGdseWYgPSB7IGdldFBhdGg6IGdldFBhdGgsIHBhcnNlOiBwYXJzZUdseWZUYWJsZX07XG5cbi8qIEEgVHJ1ZVR5cGUgZm9udCBoaW50aW5nIGludGVycHJldGVyLlxuKlxuKiAoYykgMjAxNyBBeGVsIEtpdHRlbmJlcmdlclxuKlxuKiBUaGlzIGludGVycHJldGVyIGhhcyBiZWVuIGltcGxlbWVudGVkIGFjY29yZGluZyB0byB0aGlzIGRvY3VtZW50YXRpb246XG4qIGh0dHBzOi8vZGV2ZWxvcGVyLmFwcGxlLmNvbS9mb250cy9UcnVlVHlwZS1SZWZlcmVuY2UtTWFudWFsL1JNMDUvQ2hhcDUuaHRtbFxuKlxuKiBBY2NvcmRpbmcgdG8gdGhlIGRvY3VtZW50YXRpb24gRjI0RE9UNiB2YWx1ZXMgYXJlIHVzZWQgZm9yIHBpeGVscy5cbiogVGhhdCBtZWFucyBjYWxjdWxhdGlvbiBpcyAxLzY0IHBpeGVsIGFjY3VyYXRlIGFuZCB1c2VzIGludGVnZXIgb3BlcmF0aW9ucy5cbiogSG93ZXZlciwgSmF2YXNjcmlwdCBoYXMgZmxvYXRpbmcgcG9pbnQgb3BlcmF0aW9ucyBieSBkZWZhdWx0IGFuZCBvbmx5XG4qIHRob3NlIGFyZSBhdmFpbGFibGUuIE9uZSBjb3VsZCBtYWtlIGEgY2FzZSB0byBzaW11bGF0ZSB0aGUgMS82NCBhY2N1cmFjeVxuKiBleGFjdGx5IGJ5IHRydW5jYXRpbmcgYWZ0ZXIgZXZlcnkgZGl2aXNpb24gb3BlcmF0aW9uXG4qIChmb3IgZXhhbXBsZSB3aXRoIDw8IDApIHRvIGdldCBwaXhlbCBleGFjdGx5IHJlc3VsdHMgYXMgb3RoZXIgVHJ1ZVR5cGVcbiogaW1wbGVtZW50YXRpb25zLiBJdCBtYXkgbWFrZSBzZW5zZSBzaW5jZSBzb21lIGZvbnRzIGFyZSBwaXhlbCBvcHRpbWl6ZWRcbiogYnkgaGFuZCB1c2luZyBERUxUQVAgaW5zdHJ1Y3Rpb25zLiBUaGUgY3VycmVudCBpbXBsZW1lbnRhdGlvbiBkb2Vzbid0XG4qIGFuZCByYXRoZXIgdXNlcyBmdWxsIGZsb2F0aW5nIHBvaW50IHByZWNpc2lvbi5cbipcbiogeFNjYWxlLCB5U2NhbGUgYW5kIHJvdGF0aW9uIGlzIGN1cnJlbnRseSBpZ25vcmVkLlxuKlxuKiBBIGZldyBub24tdHJpdmlhbCBpbnN0cnVjdGlvbnMgYXJlIG1pc3NpbmcgYXMgSSBkaWRuJ3QgZW5jb3VudGVyIHlldFxuKiBhIGZvbnQgdGhhdCB1c2VkIHRoZW0gdG8gdGVzdCBhIHBvc3NpYmxlIGltcGxlbWVudGF0aW9uLlxuKlxuKiBTb21lIGZvbnRzIHNlZW0gdG8gdXNlIHVuZG9jdW1lbnRlZCBmZWF0dXJlcyByZWdhcmRpbmcgdGhlIHR3aWxpZ2h0IHpvbmUuXG4qIE9ubHkgc29tZSBvZiB0aGVtIGFyZSBpbXBsZW1lbnRlZCBhcyB0aGV5IHdlcmUgZW5jb3VudGVyZWQuXG4qXG4qIFRoZSBleHBvcnRzLkRFQlVHIHN0YXRlbWVudHMgYXJlIHJlbW92ZWQgb24gdGhlIG1pbmlmaWVkIGRpc3RyaWJ1dGlvbiBmaWxlLlxuKi9cblxudmFyIGluc3RydWN0aW9uVGFibGU7XG52YXIgZXhlYztcbnZhciBleGVjR2x5cGg7XG52YXIgZXhlY0NvbXBvbmVudDtcblxuLypcbiogQ3JlYXRlcyBhIGhpbnRpbmcgb2JqZWN0LlxuKlxuKiBUaGVyZSBvdWdodCB0byBiZSBleGFjdGx5IG9uZVxuKiBmb3IgZWFjaCB0cnVldHlwZSBmb250IHRoYXQgaXMgdXNlZCBmb3IgaGludGluZy5cbiovXG5mdW5jdGlvbiBIaW50aW5nKGZvbnQpIHtcbiAgICAvLyB0aGUgZm9udCB0aGlzIGhpbnRpbmcgb2JqZWN0IGlzIGZvclxuICAgIHRoaXMuZm9udCA9IGZvbnQ7XG5cbiAgICB0aGlzLmdldENvbW1hbmRzID0gZnVuY3Rpb24gKGhQb2ludHMpIHtcbiAgICAgICAgcmV0dXJuIGdseWYuZ2V0UGF0aChoUG9pbnRzKS5jb21tYW5kcztcbiAgICB9O1xuXG4gICAgLy8gY2FjaGVkIHN0YXRlc1xuICAgIHRoaXMuX2ZwZ21TdGF0ZSAgPVxuICAgIHRoaXMuX3ByZXBTdGF0ZSAgPVxuICAgICAgICB1bmRlZmluZWQ7XG5cbiAgICAvLyBlcnJvclN0YXRlXG4gICAgLy8gMCAuLi4gYWxsIG9rYXlcbiAgICAvLyAxIC4uLiBoYWQgYW4gZXJyb3IgaW4gYSBnbHlmLFxuICAgIC8vICAgICAgIGNvbnRpbnVlIHdvcmtpbmcgYnV0IHN0b3Agc3BhbW1pbmdcbiAgICAvLyAgICAgICB0aGUgY29uc29sZVxuICAgIC8vIDIgLi4uIGVycm9yIGF0IHByZXAsIHN0b3AgaGludGluZyBhdCB0aGlzIHBwZW1cbiAgICAvLyAzIC4uLiBlcnJvciBhdCBmcGVnLCBzdG9wIGhpbnRpbmcgZm9yIHRoaXMgZm9udCBhdCBhbGxcbiAgICB0aGlzLl9lcnJvclN0YXRlID0gMDtcbn1cblxuLypcbiogTm90IHJvdW5kaW5nLlxuKi9cbmZ1bmN0aW9uIHJvdW5kT2ZmKHYpIHtcbiAgICByZXR1cm4gdjtcbn1cblxuLypcbiogUm91bmRpbmcgdG8gZ3JpZC5cbiovXG5mdW5jdGlvbiByb3VuZFRvR3JpZCh2KSB7XG4gICAgLy9Sb3VuZGluZyBpbiBUVCBpcyBzdXBwb3NlZCB0byBcInN5bW1ldHJpY2FsIGFyb3VuZCB6ZXJvXCJcbiAgICByZXR1cm4gTWF0aC5zaWduKHYpICogTWF0aC5yb3VuZChNYXRoLmFicyh2KSk7XG59XG5cbi8qXG4qIFJvdW5kaW5nIHRvIGRvdWJsZSBncmlkLlxuKi9cbmZ1bmN0aW9uIHJvdW5kVG9Eb3VibGVHcmlkKHYpIHtcbiAgICByZXR1cm4gTWF0aC5zaWduKHYpICogTWF0aC5yb3VuZChNYXRoLmFicyh2ICogMikpIC8gMjtcbn1cblxuLypcbiogUm91bmRpbmcgdG8gaGFsZiBncmlkLlxuKi9cbmZ1bmN0aW9uIHJvdW5kVG9IYWxmR3JpZCh2KSB7XG4gICAgcmV0dXJuIE1hdGguc2lnbih2KSAqIChNYXRoLnJvdW5kKE1hdGguYWJzKHYpICsgMC41KSAtIDAuNSk7XG59XG5cbi8qXG4qIFJvdW5kaW5nIHRvIHVwIHRvIGdyaWQuXG4qL1xuZnVuY3Rpb24gcm91bmRVcFRvR3JpZCh2KSB7XG4gICAgcmV0dXJuIE1hdGguc2lnbih2KSAqIE1hdGguY2VpbChNYXRoLmFicyh2KSk7XG59XG5cbi8qXG4qIFJvdW5kaW5nIHRvIGRvd24gdG8gZ3JpZC5cbiovXG5mdW5jdGlvbiByb3VuZERvd25Ub0dyaWQodikge1xuICAgIHJldHVybiBNYXRoLnNpZ24odikgKiBNYXRoLmZsb29yKE1hdGguYWJzKHYpKTtcbn1cblxuLypcbiogU3VwZXIgcm91bmRpbmcuXG4qL1xudmFyIHJvdW5kU3VwZXIgPSBmdW5jdGlvbiAodikge1xuICAgIHZhciBwZXJpb2QgPSB0aGlzLnNyUGVyaW9kO1xuICAgIHZhciBwaGFzZSA9IHRoaXMuc3JQaGFzZTtcbiAgICB2YXIgdGhyZXNob2xkID0gdGhpcy5zclRocmVzaG9sZDtcbiAgICB2YXIgc2lnbiA9IDE7XG5cbiAgICBpZiAodiA8IDApIHtcbiAgICAgICAgdiA9IC12O1xuICAgICAgICBzaWduID0gLTE7XG4gICAgfVxuXG4gICAgdiArPSB0aHJlc2hvbGQgLSBwaGFzZTtcblxuICAgIHYgPSBNYXRoLnRydW5jKHYgLyBwZXJpb2QpICogcGVyaW9kO1xuXG4gICAgdiArPSBwaGFzZTtcblxuICAgIC8vIGFjY29yZGluZyB0byBodHRwOi8veGdyaWRmaXQuc291cmNlZm9yZ2UubmV0L3JvdW5kLmh0bWxcbiAgICBpZiAodiA8IDApIHsgcmV0dXJuIHBoYXNlICogc2lnbjsgfVxuXG4gICAgcmV0dXJuIHYgKiBzaWduO1xufTtcblxuLypcbiogVW5pdCB2ZWN0b3Igb2YgeC1heGlzLlxuKi9cbnZhciB4VW5pdFZlY3RvciA9IHtcbiAgICB4OiAxLFxuXG4gICAgeTogMCxcblxuICAgIGF4aXM6ICd4JyxcblxuICAgIC8vIEdldHMgdGhlIHByb2plY3RlZCBkaXN0YW5jZSBiZXR3ZWVuIHR3byBwb2ludHMuXG4gICAgLy8gbzEvbzIgLi4uIGlmIHRydWUsIHJlc3BlY3RpdmUgb3JpZ2luYWwgcG9zaXRpb24gaXMgdXNlZC5cbiAgICBkaXN0YW5jZTogZnVuY3Rpb24gKHAxLCBwMiwgbzEsIG8yKSB7XG4gICAgICAgIHJldHVybiAobzEgPyBwMS54byA6IHAxLngpIC0gKG8yID8gcDIueG8gOiBwMi54KTtcbiAgICB9LFxuXG4gICAgLy8gTW92ZXMgcG9pbnQgcCBzbyB0aGUgbW92ZWQgcG9zaXRpb24gaGFzIHRoZSBzYW1lIHJlbGF0aXZlXG4gICAgLy8gcG9zaXRpb24gdG8gdGhlIG1vdmVkIHBvc2l0aW9ucyBvZiBycDEgYW5kIHJwMiB0aGFuIHRoZVxuICAgIC8vIG9yaWdpbmFsIHBvc2l0aW9ucyBoYWQuXG4gICAgLy9cbiAgICAvLyBTZWUgQVBQRU5ESVggb24gSU5URVJQT0xBVEUgYXQgdGhlIGJvdHRvbSBvZiB0aGlzIGZpbGUuXG4gICAgaW50ZXJwb2xhdGU6IGZ1bmN0aW9uIChwLCBycDEsIHJwMiwgcHYpIHtcbiAgICAgICAgdmFyIGRvMTtcbiAgICAgICAgdmFyIGRvMjtcbiAgICAgICAgdmFyIGRvYTE7XG4gICAgICAgIHZhciBkb2EyO1xuICAgICAgICB2YXIgZG0xO1xuICAgICAgICB2YXIgZG0yO1xuICAgICAgICB2YXIgZHQ7XG5cbiAgICAgICAgaWYgKCFwdiB8fCBwdiA9PT0gdGhpcykge1xuICAgICAgICAgICAgZG8xID0gcC54byAtIHJwMS54bztcbiAgICAgICAgICAgIGRvMiA9IHAueG8gLSBycDIueG87XG4gICAgICAgICAgICBkbTEgPSBycDEueCAtIHJwMS54bztcbiAgICAgICAgICAgIGRtMiA9IHJwMi54IC0gcnAyLnhvO1xuICAgICAgICAgICAgZG9hMSA9IE1hdGguYWJzKGRvMSk7XG4gICAgICAgICAgICBkb2EyID0gTWF0aC5hYnMoZG8yKTtcbiAgICAgICAgICAgIGR0ID0gZG9hMSArIGRvYTI7XG5cbiAgICAgICAgICAgIGlmIChkdCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHAueCA9IHAueG8gKyAoZG0xICsgZG0yKSAvIDI7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBwLnggPSBwLnhvICsgKGRtMSAqIGRvYTIgKyBkbTIgKiBkb2ExKSAvIGR0O1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgZG8xID0gcHYuZGlzdGFuY2UocCwgcnAxLCB0cnVlLCB0cnVlKTtcbiAgICAgICAgZG8yID0gcHYuZGlzdGFuY2UocCwgcnAyLCB0cnVlLCB0cnVlKTtcbiAgICAgICAgZG0xID0gcHYuZGlzdGFuY2UocnAxLCBycDEsIGZhbHNlLCB0cnVlKTtcbiAgICAgICAgZG0yID0gcHYuZGlzdGFuY2UocnAyLCBycDIsIGZhbHNlLCB0cnVlKTtcbiAgICAgICAgZG9hMSA9IE1hdGguYWJzKGRvMSk7XG4gICAgICAgIGRvYTIgPSBNYXRoLmFicyhkbzIpO1xuICAgICAgICBkdCA9IGRvYTEgKyBkb2EyO1xuXG4gICAgICAgIGlmIChkdCA9PT0gMCkge1xuICAgICAgICAgICAgeFVuaXRWZWN0b3Iuc2V0UmVsYXRpdmUocCwgcCwgKGRtMSArIGRtMikgLyAyLCBwdiwgdHJ1ZSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB4VW5pdFZlY3Rvci5zZXRSZWxhdGl2ZShwLCBwLCAoZG0xICogZG9hMiArIGRtMiAqIGRvYTEpIC8gZHQsIHB2LCB0cnVlKTtcbiAgICB9LFxuXG4gICAgLy8gU2xvcGUgb2YgbGluZSBub3JtYWwgdG8gdGhpc1xuICAgIG5vcm1hbFNsb3BlOiBOdW1iZXIuTkVHQVRJVkVfSU5GSU5JVFksXG5cbiAgICAvLyBTZXRzIHRoZSBwb2ludCAncCcgcmVsYXRpdmUgdG8gcG9pbnQgJ3JwJ1xuICAgIC8vIGJ5IHRoZSBkaXN0YW5jZSAnZCcuXG4gICAgLy9cbiAgICAvLyBTZWUgQVBQRU5ESVggb24gU0VUUkVMQVRJVkUgYXQgdGhlIGJvdHRvbSBvZiB0aGlzIGZpbGUuXG4gICAgLy9cbiAgICAvLyBwICAgLi4uIHBvaW50IHRvIHNldFxuICAgIC8vIHJwICAuLi4gcmVmZXJlbmNlIHBvaW50XG4gICAgLy8gZCAgIC4uLiBkaXN0YW5jZSBvbiBwcm9qZWN0aW9uIHZlY3RvclxuICAgIC8vIHB2ICAuLi4gcHJvamVjdGlvbiB2ZWN0b3IgKHVuZGVmaW5lZCA9IHRoaXMpXG4gICAgLy8gb3JnIC4uLiBpZiB0cnVlLCB1c2VzIHRoZSBvcmlnaW5hbCBwb3NpdGlvbiBvZiBycCBhcyByZWZlcmVuY2UuXG4gICAgc2V0UmVsYXRpdmU6IGZ1bmN0aW9uIChwLCBycCwgZCwgcHYsIG9yZykge1xuICAgICAgICBpZiAoIXB2IHx8IHB2ID09PSB0aGlzKSB7XG4gICAgICAgICAgICBwLnggPSAob3JnID8gcnAueG8gOiBycC54KSArIGQ7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgcnB4ID0gb3JnID8gcnAueG8gOiBycC54O1xuICAgICAgICB2YXIgcnB5ID0gb3JnID8gcnAueW8gOiBycC55O1xuICAgICAgICB2YXIgcnBkeCA9IHJweCArIGQgKiBwdi54O1xuICAgICAgICB2YXIgcnBkeSA9IHJweSArIGQgKiBwdi55O1xuXG4gICAgICAgIHAueCA9IHJwZHggKyAocC55IC0gcnBkeSkgLyBwdi5ub3JtYWxTbG9wZTtcbiAgICB9LFxuXG4gICAgLy8gU2xvcGUgb2YgdmVjdG9yIGxpbmUuXG4gICAgc2xvcGU6IDAsXG5cbiAgICAvLyBUb3VjaGVzIHRoZSBwb2ludCBwLlxuICAgIHRvdWNoOiBmdW5jdGlvbiAocCkge1xuICAgICAgICBwLnhUb3VjaGVkID0gdHJ1ZTtcbiAgICB9LFxuXG4gICAgLy8gVGVzdHMgaWYgYSBwb2ludCBwIGlzIHRvdWNoZWQuXG4gICAgdG91Y2hlZDogZnVuY3Rpb24gKHApIHtcbiAgICAgICAgcmV0dXJuIHAueFRvdWNoZWQ7XG4gICAgfSxcblxuICAgIC8vIFVudG91Y2hlcyB0aGUgcG9pbnQgcC5cbiAgICB1bnRvdWNoOiBmdW5jdGlvbiAocCkge1xuICAgICAgICBwLnhUb3VjaGVkID0gZmFsc2U7XG4gICAgfVxufTtcblxuLypcbiogVW5pdCB2ZWN0b3Igb2YgeS1heGlzLlxuKi9cbnZhciB5VW5pdFZlY3RvciA9IHtcbiAgICB4OiAwLFxuXG4gICAgeTogMSxcblxuICAgIGF4aXM6ICd5JyxcblxuICAgIC8vIEdldHMgdGhlIHByb2plY3RlZCBkaXN0YW5jZSBiZXR3ZWVuIHR3byBwb2ludHMuXG4gICAgLy8gbzEvbzIgLi4uIGlmIHRydWUsIHJlc3BlY3RpdmUgb3JpZ2luYWwgcG9zaXRpb24gaXMgdXNlZC5cbiAgICBkaXN0YW5jZTogZnVuY3Rpb24gKHAxLCBwMiwgbzEsIG8yKSB7XG4gICAgICAgIHJldHVybiAobzEgPyBwMS55byA6IHAxLnkpIC0gKG8yID8gcDIueW8gOiBwMi55KTtcbiAgICB9LFxuXG4gICAgLy8gTW92ZXMgcG9pbnQgcCBzbyB0aGUgbW92ZWQgcG9zaXRpb24gaGFzIHRoZSBzYW1lIHJlbGF0aXZlXG4gICAgLy8gcG9zaXRpb24gdG8gdGhlIG1vdmVkIHBvc2l0aW9ucyBvZiBycDEgYW5kIHJwMiB0aGFuIHRoZVxuICAgIC8vIG9yaWdpbmFsIHBvc2l0aW9ucyBoYWQuXG4gICAgLy9cbiAgICAvLyBTZWUgQVBQRU5ESVggb24gSU5URVJQT0xBVEUgYXQgdGhlIGJvdHRvbSBvZiB0aGlzIGZpbGUuXG4gICAgaW50ZXJwb2xhdGU6IGZ1bmN0aW9uIChwLCBycDEsIHJwMiwgcHYpIHtcbiAgICAgICAgdmFyIGRvMTtcbiAgICAgICAgdmFyIGRvMjtcbiAgICAgICAgdmFyIGRvYTE7XG4gICAgICAgIHZhciBkb2EyO1xuICAgICAgICB2YXIgZG0xO1xuICAgICAgICB2YXIgZG0yO1xuICAgICAgICB2YXIgZHQ7XG5cbiAgICAgICAgaWYgKCFwdiB8fCBwdiA9PT0gdGhpcykge1xuICAgICAgICAgICAgZG8xID0gcC55byAtIHJwMS55bztcbiAgICAgICAgICAgIGRvMiA9IHAueW8gLSBycDIueW87XG4gICAgICAgICAgICBkbTEgPSBycDEueSAtIHJwMS55bztcbiAgICAgICAgICAgIGRtMiA9IHJwMi55IC0gcnAyLnlvO1xuICAgICAgICAgICAgZG9hMSA9IE1hdGguYWJzKGRvMSk7XG4gICAgICAgICAgICBkb2EyID0gTWF0aC5hYnMoZG8yKTtcbiAgICAgICAgICAgIGR0ID0gZG9hMSArIGRvYTI7XG5cbiAgICAgICAgICAgIGlmIChkdCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHAueSA9IHAueW8gKyAoZG0xICsgZG0yKSAvIDI7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBwLnkgPSBwLnlvICsgKGRtMSAqIGRvYTIgKyBkbTIgKiBkb2ExKSAvIGR0O1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgZG8xID0gcHYuZGlzdGFuY2UocCwgcnAxLCB0cnVlLCB0cnVlKTtcbiAgICAgICAgZG8yID0gcHYuZGlzdGFuY2UocCwgcnAyLCB0cnVlLCB0cnVlKTtcbiAgICAgICAgZG0xID0gcHYuZGlzdGFuY2UocnAxLCBycDEsIGZhbHNlLCB0cnVlKTtcbiAgICAgICAgZG0yID0gcHYuZGlzdGFuY2UocnAyLCBycDIsIGZhbHNlLCB0cnVlKTtcbiAgICAgICAgZG9hMSA9IE1hdGguYWJzKGRvMSk7XG4gICAgICAgIGRvYTIgPSBNYXRoLmFicyhkbzIpO1xuICAgICAgICBkdCA9IGRvYTEgKyBkb2EyO1xuXG4gICAgICAgIGlmIChkdCA9PT0gMCkge1xuICAgICAgICAgICAgeVVuaXRWZWN0b3Iuc2V0UmVsYXRpdmUocCwgcCwgKGRtMSArIGRtMikgLyAyLCBwdiwgdHJ1ZSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB5VW5pdFZlY3Rvci5zZXRSZWxhdGl2ZShwLCBwLCAoZG0xICogZG9hMiArIGRtMiAqIGRvYTEpIC8gZHQsIHB2LCB0cnVlKTtcbiAgICB9LFxuXG4gICAgLy8gU2xvcGUgb2YgbGluZSBub3JtYWwgdG8gdGhpcy5cbiAgICBub3JtYWxTbG9wZTogMCxcblxuICAgIC8vIFNldHMgdGhlIHBvaW50ICdwJyByZWxhdGl2ZSB0byBwb2ludCAncnAnXG4gICAgLy8gYnkgdGhlIGRpc3RhbmNlICdkJ1xuICAgIC8vXG4gICAgLy8gU2VlIEFQUEVORElYIG9uIFNFVFJFTEFUSVZFIGF0IHRoZSBib3R0b20gb2YgdGhpcyBmaWxlLlxuICAgIC8vXG4gICAgLy8gcCAgIC4uLiBwb2ludCB0byBzZXRcbiAgICAvLyBycCAgLi4uIHJlZmVyZW5jZSBwb2ludFxuICAgIC8vIGQgICAuLi4gZGlzdGFuY2Ugb24gcHJvamVjdGlvbiB2ZWN0b3JcbiAgICAvLyBwdiAgLi4uIHByb2plY3Rpb24gdmVjdG9yICh1bmRlZmluZWQgPSB0aGlzKVxuICAgIC8vIG9yZyAuLi4gaWYgdHJ1ZSwgdXNlcyB0aGUgb3JpZ2luYWwgcG9zaXRpb24gb2YgcnAgYXMgcmVmZXJlbmNlLlxuICAgIHNldFJlbGF0aXZlOiBmdW5jdGlvbiAocCwgcnAsIGQsIHB2LCBvcmcpIHtcbiAgICAgICAgaWYgKCFwdiB8fCBwdiA9PT0gdGhpcykge1xuICAgICAgICAgICAgcC55ID0gKG9yZyA/IHJwLnlvIDogcnAueSkgKyBkO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHJweCA9IG9yZyA/IHJwLnhvIDogcnAueDtcbiAgICAgICAgdmFyIHJweSA9IG9yZyA/IHJwLnlvIDogcnAueTtcbiAgICAgICAgdmFyIHJwZHggPSBycHggKyBkICogcHYueDtcbiAgICAgICAgdmFyIHJwZHkgPSBycHkgKyBkICogcHYueTtcblxuICAgICAgICBwLnkgPSBycGR5ICsgcHYubm9ybWFsU2xvcGUgKiAocC54IC0gcnBkeCk7XG4gICAgfSxcblxuICAgIC8vIFNsb3BlIG9mIHZlY3RvciBsaW5lLlxuICAgIHNsb3BlOiBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFksXG5cbiAgICAvLyBUb3VjaGVzIHRoZSBwb2ludCBwLlxuICAgIHRvdWNoOiBmdW5jdGlvbiAocCkge1xuICAgICAgICBwLnlUb3VjaGVkID0gdHJ1ZTtcbiAgICB9LFxuXG4gICAgLy8gVGVzdHMgaWYgYSBwb2ludCBwIGlzIHRvdWNoZWQuXG4gICAgdG91Y2hlZDogZnVuY3Rpb24gKHApIHtcbiAgICAgICAgcmV0dXJuIHAueVRvdWNoZWQ7XG4gICAgfSxcblxuICAgIC8vIFVudG91Y2hlcyB0aGUgcG9pbnQgcC5cbiAgICB1bnRvdWNoOiBmdW5jdGlvbiAocCkge1xuICAgICAgICBwLnlUb3VjaGVkID0gZmFsc2U7XG4gICAgfVxufTtcblxuT2JqZWN0LmZyZWV6ZSh4VW5pdFZlY3Rvcik7XG5PYmplY3QuZnJlZXplKHlVbml0VmVjdG9yKTtcblxuLypcbiogQ3JlYXRlcyBhIHVuaXQgdmVjdG9yIHRoYXQgaXMgbm90IHgtIG9yIHktYXhpcy5cbiovXG5mdW5jdGlvbiBVbml0VmVjdG9yKHgsIHkpIHtcbiAgICB0aGlzLnggPSB4O1xuICAgIHRoaXMueSA9IHk7XG4gICAgdGhpcy5heGlzID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuc2xvcGUgPSB5IC8geDtcbiAgICB0aGlzLm5vcm1hbFNsb3BlID0gLXggLyB5O1xuICAgIE9iamVjdC5mcmVlemUodGhpcyk7XG59XG5cbi8qXG4qIEdldHMgdGhlIHByb2plY3RlZCBkaXN0YW5jZSBiZXR3ZWVuIHR3byBwb2ludHMuXG4qIG8xL28yIC4uLiBpZiB0cnVlLCByZXNwZWN0aXZlIG9yaWdpbmFsIHBvc2l0aW9uIGlzIHVzZWQuXG4qL1xuVW5pdFZlY3Rvci5wcm90b3R5cGUuZGlzdGFuY2UgPSBmdW5jdGlvbihwMSwgcDIsIG8xLCBvMikge1xuICAgIHJldHVybiAoXG4gICAgICAgIHRoaXMueCAqIHhVbml0VmVjdG9yLmRpc3RhbmNlKHAxLCBwMiwgbzEsIG8yKSArXG4gICAgICAgIHRoaXMueSAqIHlVbml0VmVjdG9yLmRpc3RhbmNlKHAxLCBwMiwgbzEsIG8yKVxuICAgICk7XG59O1xuXG4vKlxuKiBNb3ZlcyBwb2ludCBwIHNvIHRoZSBtb3ZlZCBwb3NpdGlvbiBoYXMgdGhlIHNhbWUgcmVsYXRpdmVcbiogcG9zaXRpb24gdG8gdGhlIG1vdmVkIHBvc2l0aW9ucyBvZiBycDEgYW5kIHJwMiB0aGFuIHRoZVxuKiBvcmlnaW5hbCBwb3NpdGlvbnMgaGFkLlxuKlxuKiBTZWUgQVBQRU5ESVggb24gSU5URVJQT0xBVEUgYXQgdGhlIGJvdHRvbSBvZiB0aGlzIGZpbGUuXG4qL1xuVW5pdFZlY3Rvci5wcm90b3R5cGUuaW50ZXJwb2xhdGUgPSBmdW5jdGlvbihwLCBycDEsIHJwMiwgcHYpIHtcbiAgICB2YXIgZG0xO1xuICAgIHZhciBkbTI7XG4gICAgdmFyIGRvMTtcbiAgICB2YXIgZG8yO1xuICAgIHZhciBkb2ExO1xuICAgIHZhciBkb2EyO1xuICAgIHZhciBkdDtcblxuICAgIGRvMSA9IHB2LmRpc3RhbmNlKHAsIHJwMSwgdHJ1ZSwgdHJ1ZSk7XG4gICAgZG8yID0gcHYuZGlzdGFuY2UocCwgcnAyLCB0cnVlLCB0cnVlKTtcbiAgICBkbTEgPSBwdi5kaXN0YW5jZShycDEsIHJwMSwgZmFsc2UsIHRydWUpO1xuICAgIGRtMiA9IHB2LmRpc3RhbmNlKHJwMiwgcnAyLCBmYWxzZSwgdHJ1ZSk7XG4gICAgZG9hMSA9IE1hdGguYWJzKGRvMSk7XG4gICAgZG9hMiA9IE1hdGguYWJzKGRvMik7XG4gICAgZHQgPSBkb2ExICsgZG9hMjtcblxuICAgIGlmIChkdCA9PT0gMCkge1xuICAgICAgICB0aGlzLnNldFJlbGF0aXZlKHAsIHAsIChkbTEgKyBkbTIpIC8gMiwgcHYsIHRydWUpO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpcy5zZXRSZWxhdGl2ZShwLCBwLCAoZG0xICogZG9hMiArIGRtMiAqIGRvYTEpIC8gZHQsIHB2LCB0cnVlKTtcbn07XG5cbi8qXG4qIFNldHMgdGhlIHBvaW50ICdwJyByZWxhdGl2ZSB0byBwb2ludCAncnAnXG4qIGJ5IHRoZSBkaXN0YW5jZSAnZCdcbipcbiogU2VlIEFQUEVORElYIG9uIFNFVFJFTEFUSVZFIGF0IHRoZSBib3R0b20gb2YgdGhpcyBmaWxlLlxuKlxuKiBwICAgLi4uICBwb2ludCB0byBzZXRcbiogcnAgIC4uLiByZWZlcmVuY2UgcG9pbnRcbiogZCAgIC4uLiBkaXN0YW5jZSBvbiBwcm9qZWN0aW9uIHZlY3RvclxuKiBwdiAgLi4uIHByb2plY3Rpb24gdmVjdG9yICh1bmRlZmluZWQgPSB0aGlzKVxuKiBvcmcgLi4uIGlmIHRydWUsIHVzZXMgdGhlIG9yaWdpbmFsIHBvc2l0aW9uIG9mIHJwIGFzIHJlZmVyZW5jZS5cbiovXG5Vbml0VmVjdG9yLnByb3RvdHlwZS5zZXRSZWxhdGl2ZSA9IGZ1bmN0aW9uKHAsIHJwLCBkLCBwdiwgb3JnKSB7XG4gICAgcHYgPSBwdiB8fCB0aGlzO1xuXG4gICAgdmFyIHJweCA9IG9yZyA/IHJwLnhvIDogcnAueDtcbiAgICB2YXIgcnB5ID0gb3JnID8gcnAueW8gOiBycC55O1xuICAgIHZhciBycGR4ID0gcnB4ICsgZCAqIHB2Lng7XG4gICAgdmFyIHJwZHkgPSBycHkgKyBkICogcHYueTtcblxuICAgIHZhciBwdm5zID0gcHYubm9ybWFsU2xvcGU7XG4gICAgdmFyIGZ2cyA9IHRoaXMuc2xvcGU7XG5cbiAgICB2YXIgcHggPSBwLng7XG4gICAgdmFyIHB5ID0gcC55O1xuXG4gICAgcC54ID0gKGZ2cyAqIHB4IC0gcHZucyAqIHJwZHggKyBycGR5IC0gcHkpIC8gKGZ2cyAtIHB2bnMpO1xuICAgIHAueSA9IGZ2cyAqIChwLnggLSBweCkgKyBweTtcbn07XG5cbi8qXG4qIFRvdWNoZXMgdGhlIHBvaW50IHAuXG4qL1xuVW5pdFZlY3Rvci5wcm90b3R5cGUudG91Y2ggPSBmdW5jdGlvbihwKSB7XG4gICAgcC54VG91Y2hlZCA9IHRydWU7XG4gICAgcC55VG91Y2hlZCA9IHRydWU7XG59O1xuXG4vKlxuKiBSZXR1cm5zIGEgdW5pdCB2ZWN0b3Igd2l0aCB4L3kgY29vcmRpbmF0ZXMuXG4qL1xuZnVuY3Rpb24gZ2V0VW5pdFZlY3Rvcih4LCB5KSB7XG4gICAgdmFyIGQgPSBNYXRoLnNxcnQoeCAqIHggKyB5ICogeSk7XG5cbiAgICB4IC89IGQ7XG4gICAgeSAvPSBkO1xuXG4gICAgaWYgKHggPT09IDEgJiYgeSA9PT0gMCkgeyByZXR1cm4geFVuaXRWZWN0b3I7IH1cbiAgICBlbHNlIGlmICh4ID09PSAwICYmIHkgPT09IDEpIHsgcmV0dXJuIHlVbml0VmVjdG9yOyB9XG4gICAgZWxzZSB7IHJldHVybiBuZXcgVW5pdFZlY3Rvcih4LCB5KTsgfVxufVxuXG4vKlxuKiBDcmVhdGVzIGEgcG9pbnQgaW4gdGhlIGhpbnRpbmcgZW5naW5lLlxuKi9cbmZ1bmN0aW9uIEhQb2ludChcbiAgICB4LFxuICAgIHksXG4gICAgbGFzdFBvaW50T2ZDb250b3VyLFxuICAgIG9uQ3VydmVcbikge1xuICAgIHRoaXMueCA9IHRoaXMueG8gPSBNYXRoLnJvdW5kKHggKiA2NCkgLyA2NDsgLy8gaGludGVkIHggdmFsdWUgYW5kIG9yaWdpbmFsIHgtdmFsdWVcbiAgICB0aGlzLnkgPSB0aGlzLnlvID0gTWF0aC5yb3VuZCh5ICogNjQpIC8gNjQ7IC8vIGhpbnRlZCB5IHZhbHVlIGFuZCBvcmlnaW5hbCB5LXZhbHVlXG5cbiAgICB0aGlzLmxhc3RQb2ludE9mQ29udG91ciA9IGxhc3RQb2ludE9mQ29udG91cjtcbiAgICB0aGlzLm9uQ3VydmUgPSBvbkN1cnZlO1xuICAgIHRoaXMucHJldlBvaW50T25Db250b3VyID0gdW5kZWZpbmVkO1xuICAgIHRoaXMubmV4dFBvaW50T25Db250b3VyID0gdW5kZWZpbmVkO1xuICAgIHRoaXMueFRvdWNoZWQgPSBmYWxzZTtcbiAgICB0aGlzLnlUb3VjaGVkID0gZmFsc2U7XG5cbiAgICBPYmplY3QucHJldmVudEV4dGVuc2lvbnModGhpcyk7XG59XG5cbi8qXG4qIFJldHVybnMgdGhlIG5leHQgdG91Y2hlZCBwb2ludCBvbiB0aGUgY29udG91ci5cbipcbiogdiAgLi4uIHVuaXQgdmVjdG9yIHRvIHRlc3QgdG91Y2ggYXhpcy5cbiovXG5IUG9pbnQucHJvdG90eXBlLm5leHRUb3VjaGVkID0gZnVuY3Rpb24odikge1xuICAgIHZhciBwID0gdGhpcy5uZXh0UG9pbnRPbkNvbnRvdXI7XG5cbiAgICB3aGlsZSAoIXYudG91Y2hlZChwKSAmJiBwICE9PSB0aGlzKSB7IHAgPSBwLm5leHRQb2ludE9uQ29udG91cjsgfVxuXG4gICAgcmV0dXJuIHA7XG59O1xuXG4vKlxuKiBSZXR1cm5zIHRoZSBwcmV2aW91cyB0b3VjaGVkIHBvaW50IG9uIHRoZSBjb250b3VyXG4qXG4qIHYgIC4uLiB1bml0IHZlY3RvciB0byB0ZXN0IHRvdWNoIGF4aXMuXG4qL1xuSFBvaW50LnByb3RvdHlwZS5wcmV2VG91Y2hlZCA9IGZ1bmN0aW9uKHYpIHtcbiAgICB2YXIgcCA9IHRoaXMucHJldlBvaW50T25Db250b3VyO1xuXG4gICAgd2hpbGUgKCF2LnRvdWNoZWQocCkgJiYgcCAhPT0gdGhpcykgeyBwID0gcC5wcmV2UG9pbnRPbkNvbnRvdXI7IH1cblxuICAgIHJldHVybiBwO1xufTtcblxuLypcbiogVGhlIHplcm8gcG9pbnQuXG4qL1xudmFyIEhQWmVybyA9IE9iamVjdC5mcmVlemUobmV3IEhQb2ludCgwLCAwKSk7XG5cbi8qXG4qIFRoZSBkZWZhdWx0IHN0YXRlIG9mIHRoZSBpbnRlcnByZXRlci5cbipcbiogTm90ZTogRnJlZXppbmcgdGhlIGRlZmF1bHRTdGF0ZSBhbmQgdGhlbiBkZXJpdmluZyBmcm9tIGl0XG4qIG1ha2VzIHRoZSBWOCBKYXZhc2NyaXB0IGVuZ2luZSBnb2luZyBhd2t3YXJkLFxuKiBzbyB0aGlzIGlzIGF2b2lkZWQsIGFsYmVpdCB0aGUgZGVmYXVsdFN0YXRlIHNob3VsZG4ndFxuKiBldmVyIGNoYW5nZS5cbiovXG52YXIgZGVmYXVsdFN0YXRlID0ge1xuICAgIGN2Q3V0SW46IDE3IC8gMTYsICAgIC8vIGNvbnRyb2wgdmFsdWUgY3V0IGluXG4gICAgZGVsdGFCYXNlOiA5LFxuICAgIGRlbHRhU2hpZnQ6IDAuMTI1LFxuICAgIGxvb3A6IDEsICAgICAgICAgICAgIC8vIGxvb3BzIHNvbWUgaW5zdHJ1Y3Rpb25zXG4gICAgbWluRGlzOiAxLCAgICAgICAgICAgLy8gbWluaW11bSBkaXN0YW5jZVxuICAgIGF1dG9GbGlwOiB0cnVlXG59O1xuXG4vKlxuKiBUaGUgY3VycmVudCBzdGF0ZSBvZiB0aGUgaW50ZXJwcmV0ZXIuXG4qXG4qIGVudiAgLi4uICdmcGdtJyBvciAncHJlcCcgb3IgJ2dseWYnXG4qIHByb2cgLi4uIHRoZSBwcm9ncmFtXG4qL1xuZnVuY3Rpb24gU3RhdGUoZW52LCBwcm9nKSB7XG4gICAgdGhpcy5lbnYgPSBlbnY7XG4gICAgdGhpcy5zdGFjayA9IFtdO1xuICAgIHRoaXMucHJvZyA9IHByb2c7XG5cbiAgICBzd2l0Y2ggKGVudikge1xuICAgICAgICBjYXNlICdnbHlmJyA6XG4gICAgICAgICAgICB0aGlzLnpwMCA9IHRoaXMuenAxID0gdGhpcy56cDIgPSAxO1xuICAgICAgICAgICAgdGhpcy5ycDAgPSB0aGlzLnJwMSA9IHRoaXMucnAyID0gMDtcbiAgICAgICAgICAgIC8qIGZhbGwgdGhyb3VnaCAqL1xuICAgICAgICBjYXNlICdwcmVwJyA6XG4gICAgICAgICAgICB0aGlzLmZ2ID0gdGhpcy5wdiA9IHRoaXMuZHB2ID0geFVuaXRWZWN0b3I7XG4gICAgICAgICAgICB0aGlzLnJvdW5kID0gcm91bmRUb0dyaWQ7XG4gICAgfVxufVxuXG4vKlxuKiBFeGVjdXRlcyBhIGdseXBoIHByb2dyYW0uXG4qXG4qIFRoaXMgZG9lcyB0aGUgaGludGluZyBmb3IgZWFjaCBnbHlwaC5cbipcbiogUmV0dXJucyBhbiBhcnJheSBvZiBtb3ZlZCBwb2ludHMuXG4qXG4qIGdseXBoOiB0aGUgZ2x5cGggdG8gaGludFxuKiBwcGVtOiB0aGUgc2l6ZSB0aGUgZ2x5cGggaXMgcmVuZGVyZWQgZm9yXG4qL1xuSGludGluZy5wcm90b3R5cGUuZXhlYyA9IGZ1bmN0aW9uKGdseXBoLCBwcGVtKSB7XG4gICAgaWYgKHR5cGVvZiBwcGVtICE9PSAnbnVtYmVyJykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1BvaW50IHNpemUgaXMgbm90IGEgbnVtYmVyIScpO1xuICAgIH1cblxuICAgIC8vIFJlY2VpdmVkIGEgZmF0YWwgZXJyb3IsIGRvbid0IGRvIGFueSBoaW50aW5nIGFueW1vcmUuXG4gICAgaWYgKHRoaXMuX2Vycm9yU3RhdGUgPiAyKSB7IHJldHVybjsgfVxuXG4gICAgdmFyIGZvbnQgPSB0aGlzLmZvbnQ7XG4gICAgdmFyIHByZXBTdGF0ZSA9IHRoaXMuX3ByZXBTdGF0ZTtcblxuICAgIGlmICghcHJlcFN0YXRlIHx8IHByZXBTdGF0ZS5wcGVtICE9PSBwcGVtKSB7XG4gICAgICAgIHZhciBmcGdtU3RhdGUgPSB0aGlzLl9mcGdtU3RhdGU7XG5cbiAgICAgICAgaWYgKCFmcGdtU3RhdGUpIHtcbiAgICAgICAgICAgIC8vIEV4ZWN1dGVzIHRoZSBmcGdtIHN0YXRlLlxuICAgICAgICAgICAgLy8gVGhpcyBpcyB1c2VkIGJ5IGZvbnRzIHRvIGRlZmluZSBmdW5jdGlvbnMuXG4gICAgICAgICAgICBTdGF0ZS5wcm90b3R5cGUgPSBkZWZhdWx0U3RhdGU7XG5cbiAgICAgICAgICAgIGZwZ21TdGF0ZSA9XG4gICAgICAgICAgICB0aGlzLl9mcGdtU3RhdGUgPVxuICAgICAgICAgICAgICAgIG5ldyBTdGF0ZSgnZnBnbScsIGZvbnQudGFibGVzLmZwZ20pO1xuXG4gICAgICAgICAgICBmcGdtU3RhdGUuZnVuY3MgPSBbIF07XG4gICAgICAgICAgICBmcGdtU3RhdGUuZm9udCA9IGZvbnQ7XG5cbiAgICAgICAgICAgIGlmIChleHBvcnRzLkRFQlVHKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coJy0tLUVYRUMgRlBHTS0tLScpO1xuICAgICAgICAgICAgICAgIGZwZ21TdGF0ZS5zdGVwID0gLTE7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgZXhlYyhmcGdtU3RhdGUpO1xuICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCdIaW50aW5nIGVycm9yIGluIEZQR006JyArIGUpO1xuICAgICAgICAgICAgICAgIHRoaXMuX2Vycm9yU3RhdGUgPSAzO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEV4ZWN1dGVzIHRoZSBwcmVwIHByb2dyYW0gZm9yIHRoaXMgcHBlbSBzZXR0aW5nLlxuICAgICAgICAvLyBUaGlzIGlzIHVzZWQgYnkgZm9udHMgdG8gc2V0IGN2dCB2YWx1ZXNcbiAgICAgICAgLy8gZGVwZW5kaW5nIG9uIHRvIGJlIHJlbmRlcmVkIGZvbnQgc2l6ZS5cblxuICAgICAgICBTdGF0ZS5wcm90b3R5cGUgPSBmcGdtU3RhdGU7XG4gICAgICAgIHByZXBTdGF0ZSA9XG4gICAgICAgIHRoaXMuX3ByZXBTdGF0ZSA9XG4gICAgICAgICAgICBuZXcgU3RhdGUoJ3ByZXAnLCBmb250LnRhYmxlcy5wcmVwKTtcblxuICAgICAgICBwcmVwU3RhdGUucHBlbSA9IHBwZW07XG5cbiAgICAgICAgLy8gQ3JlYXRlcyBhIGNvcHkgb2YgdGhlIGN2dCB0YWJsZVxuICAgICAgICAvLyBhbmQgc2NhbGVzIGl0IHRvIHRoZSBjdXJyZW50IHBwZW0gc2V0dGluZy5cbiAgICAgICAgdmFyIG9DdnQgPSBmb250LnRhYmxlcy5jdnQ7XG4gICAgICAgIGlmIChvQ3Z0KSB7XG4gICAgICAgICAgICB2YXIgY3Z0ID0gcHJlcFN0YXRlLmN2dCA9IG5ldyBBcnJheShvQ3Z0Lmxlbmd0aCk7XG4gICAgICAgICAgICB2YXIgc2NhbGUgPSBwcGVtIC8gZm9udC51bml0c1BlckVtO1xuICAgICAgICAgICAgZm9yICh2YXIgYyA9IDA7IGMgPCBvQ3Z0Lmxlbmd0aDsgYysrKSB7XG4gICAgICAgICAgICAgICAgY3Z0W2NdID0gb0N2dFtjXSAqIHNjYWxlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcHJlcFN0YXRlLmN2dCA9IFtdO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGV4cG9ydHMuREVCVUcpIHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCctLS1FWEVDIFBSRVAtLS0nKTtcbiAgICAgICAgICAgIHByZXBTdGF0ZS5zdGVwID0gLTE7XG4gICAgICAgIH1cblxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgZXhlYyhwcmVwU3RhdGUpO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5fZXJyb3JTdGF0ZSA8IDIpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZygnSGludGluZyBlcnJvciBpbiBQUkVQOicgKyBlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX2Vycm9yU3RhdGUgPSAyO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuX2Vycm9yU3RhdGUgPiAxKSB7IHJldHVybjsgfVxuXG4gICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIGV4ZWNHbHlwaChnbHlwaCwgcHJlcFN0YXRlKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGlmICh0aGlzLl9lcnJvclN0YXRlIDwgMSkge1xuICAgICAgICAgICAgY29uc29sZS5sb2coJ0hpbnRpbmcgZXJyb3I6JyArIGUpO1xuICAgICAgICAgICAgY29uc29sZS5sb2coJ05vdGU6IGZ1cnRoZXIgaGludGluZyBlcnJvcnMgYXJlIHNpbGVuY2VkJyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fZXJyb3JTdGF0ZSA9IDE7XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxufTtcblxuLypcbiogRXhlY3V0ZXMgdGhlIGhpbnRpbmcgcHJvZ3JhbSBmb3IgYSBnbHlwaC5cbiovXG5leGVjR2x5cGggPSBmdW5jdGlvbihnbHlwaCwgcHJlcFN0YXRlKSB7XG4gICAgLy8gb3JpZ2luYWwgcG9pbnQgcG9zaXRpb25zXG4gICAgdmFyIHhTY2FsZSA9IHByZXBTdGF0ZS5wcGVtIC8gcHJlcFN0YXRlLmZvbnQudW5pdHNQZXJFbTtcbiAgICB2YXIgeVNjYWxlID0geFNjYWxlO1xuICAgIHZhciBjb21wb25lbnRzID0gZ2x5cGguY29tcG9uZW50cztcbiAgICB2YXIgY29udG91cnM7XG4gICAgdmFyIGdab25lO1xuICAgIHZhciBzdGF0ZTtcblxuICAgIFN0YXRlLnByb3RvdHlwZSA9IHByZXBTdGF0ZTtcbiAgICBpZiAoIWNvbXBvbmVudHMpIHtcbiAgICAgICAgc3RhdGUgPSBuZXcgU3RhdGUoJ2dseWYnLCBnbHlwaC5pbnN0cnVjdGlvbnMpO1xuICAgICAgICBpZiAoZXhwb3J0cy5ERUJVRykge1xuICAgICAgICAgICAgY29uc29sZS5sb2coJy0tLUVYRUMgR0xZUEgtLS0nKTtcbiAgICAgICAgICAgIHN0YXRlLnN0ZXAgPSAtMTtcbiAgICAgICAgfVxuICAgICAgICBleGVjQ29tcG9uZW50KGdseXBoLCBzdGF0ZSwgeFNjYWxlLCB5U2NhbGUpO1xuICAgICAgICBnWm9uZSA9IHN0YXRlLmdab25lO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBmb250ID0gcHJlcFN0YXRlLmZvbnQ7XG4gICAgICAgIGdab25lID0gW107XG4gICAgICAgIGNvbnRvdXJzID0gW107XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY29tcG9uZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIGMgPSBjb21wb25lbnRzW2ldO1xuICAgICAgICAgICAgdmFyIGNnID0gZm9udC5nbHlwaHMuZ2V0KGMuZ2x5cGhJbmRleCk7XG5cbiAgICAgICAgICAgIHN0YXRlID0gbmV3IFN0YXRlKCdnbHlmJywgY2cuaW5zdHJ1Y3Rpb25zKTtcblxuICAgICAgICAgICAgaWYgKGV4cG9ydHMuREVCVUcpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZygnLS0tRVhFQyBDT01QICcgKyBpICsgJy0tLScpO1xuICAgICAgICAgICAgICAgIHN0YXRlLnN0ZXAgPSAtMTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZXhlY0NvbXBvbmVudChjZywgc3RhdGUsIHhTY2FsZSwgeVNjYWxlKTtcbiAgICAgICAgICAgIC8vIGFwcGVuZHMgdGhlIGNvbXB1dGVkIHBvaW50cyB0byB0aGUgcmVzdWx0IGFycmF5XG4gICAgICAgICAgICAvLyBwb3N0IHByb2Nlc3NlcyB0aGUgY29tcG9uZW50IHBvaW50c1xuICAgICAgICAgICAgdmFyIGR4ID0gTWF0aC5yb3VuZChjLmR4ICogeFNjYWxlKTtcbiAgICAgICAgICAgIHZhciBkeSA9IE1hdGgucm91bmQoYy5keSAqIHlTY2FsZSk7XG4gICAgICAgICAgICB2YXIgZ3ogPSBzdGF0ZS5nWm9uZTtcbiAgICAgICAgICAgIHZhciBjYyA9IHN0YXRlLmNvbnRvdXJzO1xuICAgICAgICAgICAgZm9yICh2YXIgcGkgPSAwOyBwaSA8IGd6Lmxlbmd0aDsgcGkrKykge1xuICAgICAgICAgICAgICAgIHZhciBwID0gZ3pbcGldO1xuICAgICAgICAgICAgICAgIHAueFRvdWNoZWQgPSBwLnlUb3VjaGVkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgcC54byA9IHAueCA9IHAueCArIGR4O1xuICAgICAgICAgICAgICAgIHAueW8gPSBwLnkgPSBwLnkgKyBkeTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIGdMZW4gPSBnWm9uZS5sZW5ndGg7XG4gICAgICAgICAgICBnWm9uZS5wdXNoLmFwcGx5KGdab25lLCBneik7XG4gICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGNjLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICAgICAgY29udG91cnMucHVzaChjY1tqXSArIGdMZW4pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGdseXBoLmluc3RydWN0aW9ucyAmJiAhc3RhdGUuaW5oaWJpdEdyaWRGaXQpIHtcbiAgICAgICAgICAgIC8vIHRoZSBjb21wb3NpdGUgaGFzIGluc3RydWN0aW9ucyBvbiBpdHMgb3duXG4gICAgICAgICAgICBzdGF0ZSA9IG5ldyBTdGF0ZSgnZ2x5ZicsIGdseXBoLmluc3RydWN0aW9ucyk7XG5cbiAgICAgICAgICAgIHN0YXRlLmdab25lID0gc3RhdGUuejAgPSBzdGF0ZS56MSA9IHN0YXRlLnoyID0gZ1pvbmU7XG5cbiAgICAgICAgICAgIHN0YXRlLmNvbnRvdXJzID0gY29udG91cnM7XG5cbiAgICAgICAgICAgIC8vIG5vdGU6IEhQWmVybyBjYW5ub3QgYmUgdXNlZCBoZXJlLCBzaW5jZVxuICAgICAgICAgICAgLy8gICAgICAgdGhlIHBvaW50IG1pZ2h0IGJlIG1vZGlmaWVkXG4gICAgICAgICAgICBnWm9uZS5wdXNoKFxuICAgICAgICAgICAgICAgIG5ldyBIUG9pbnQoMCwgMCksXG4gICAgICAgICAgICAgICAgbmV3IEhQb2ludChNYXRoLnJvdW5kKGdseXBoLmFkdmFuY2VXaWR0aCAqIHhTY2FsZSksIDApXG4gICAgICAgICAgICApO1xuXG4gICAgICAgICAgICBpZiAoZXhwb3J0cy5ERUJVRykge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCctLS1FWEVDIENPTVBPU0lURS0tLScpO1xuICAgICAgICAgICAgICAgIHN0YXRlLnN0ZXAgPSAtMTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZXhlYyhzdGF0ZSk7XG5cbiAgICAgICAgICAgIGdab25lLmxlbmd0aCAtPSAyO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGdab25lO1xufTtcblxuLypcbiogRXhlY3V0ZXMgdGhlIGhpbnRpbmcgcHJvZ3JhbSBmb3IgYSBjb21wb25lbnQgb2YgYSBtdWx0aS1jb21wb25lbnQgZ2x5cGhcbiogb3Igb2YgdGhlIGdseXBoIGl0c2VsZiBmb3IgYSBub24tY29tcG9uZW50IGdseXBoLlxuKi9cbmV4ZWNDb21wb25lbnQgPSBmdW5jdGlvbihnbHlwaCwgc3RhdGUsIHhTY2FsZSwgeVNjYWxlKVxue1xuICAgIHZhciBwb2ludHMgPSBnbHlwaC5wb2ludHMgfHwgW107XG4gICAgdmFyIHBMZW4gPSBwb2ludHMubGVuZ3RoO1xuICAgIHZhciBnWm9uZSA9IHN0YXRlLmdab25lID0gc3RhdGUuejAgPSBzdGF0ZS56MSA9IHN0YXRlLnoyID0gW107XG4gICAgdmFyIGNvbnRvdXJzID0gc3RhdGUuY29udG91cnMgPSBbXTtcblxuICAgIC8vIFNjYWxlcyB0aGUgb3JpZ2luYWwgcG9pbnRzIGFuZFxuICAgIC8vIG1ha2VzIGNvcGllcyBmb3IgdGhlIGhpbnRlZCBwb2ludHMuXG4gICAgdmFyIGNwOyAvLyBjdXJyZW50IHBvaW50XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwTGVuOyBpKyspIHtcbiAgICAgICAgY3AgPSBwb2ludHNbaV07XG5cbiAgICAgICAgZ1pvbmVbaV0gPSBuZXcgSFBvaW50KFxuICAgICAgICAgICAgY3AueCAqIHhTY2FsZSxcbiAgICAgICAgICAgIGNwLnkgKiB5U2NhbGUsXG4gICAgICAgICAgICBjcC5sYXN0UG9pbnRPZkNvbnRvdXIsXG4gICAgICAgICAgICBjcC5vbkN1cnZlXG4gICAgICAgICk7XG4gICAgfVxuXG4gICAgLy8gQ2hhaW4gbGlua3MgdGhlIGNvbnRvdXJzLlxuICAgIHZhciBzcDsgLy8gc3RhcnQgcG9pbnRcbiAgICB2YXIgbnA7IC8vIG5leHQgcG9pbnRcblxuICAgIGZvciAodmFyIGkkMSA9IDA7IGkkMSA8IHBMZW47IGkkMSsrKSB7XG4gICAgICAgIGNwID0gZ1pvbmVbaSQxXTtcblxuICAgICAgICBpZiAoIXNwKSB7XG4gICAgICAgICAgICBzcCA9IGNwO1xuICAgICAgICAgICAgY29udG91cnMucHVzaChpJDEpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGNwLmxhc3RQb2ludE9mQ29udG91cikge1xuICAgICAgICAgICAgY3AubmV4dFBvaW50T25Db250b3VyID0gc3A7XG4gICAgICAgICAgICBzcC5wcmV2UG9pbnRPbkNvbnRvdXIgPSBjcDtcbiAgICAgICAgICAgIHNwID0gdW5kZWZpbmVkO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbnAgPSBnWm9uZVtpJDEgKyAxXTtcbiAgICAgICAgICAgIGNwLm5leHRQb2ludE9uQ29udG91ciA9IG5wO1xuICAgICAgICAgICAgbnAucHJldlBvaW50T25Db250b3VyID0gY3A7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoc3RhdGUuaW5oaWJpdEdyaWRGaXQpIHsgcmV0dXJuOyB9XG5cbiAgICBpZiAoZXhwb3J0cy5ERUJVRykge1xuICAgICAgICBjb25zb2xlLmxvZygnUFJPQ0VTU0lORyBHTFlQSCcsIHN0YXRlLnN0YWNrKTtcbiAgICAgICAgZm9yICh2YXIgaSQyID0gMDsgaSQyIDwgcExlbjsgaSQyKyspIHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKGkkMiwgZ1pvbmVbaSQyXS54LCBnWm9uZVtpJDJdLnkpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZ1pvbmUucHVzaChcbiAgICAgICAgbmV3IEhQb2ludCgwLCAwKSxcbiAgICAgICAgbmV3IEhQb2ludChNYXRoLnJvdW5kKGdseXBoLmFkdmFuY2VXaWR0aCAqIHhTY2FsZSksIDApXG4gICAgKTtcblxuICAgIGV4ZWMoc3RhdGUpO1xuXG4gICAgLy8gUmVtb3ZlcyB0aGUgZXh0cmEgcG9pbnRzLlxuICAgIGdab25lLmxlbmd0aCAtPSAyO1xuXG4gICAgaWYgKGV4cG9ydHMuREVCVUcpIHtcbiAgICAgICAgY29uc29sZS5sb2coJ0ZJTklTSEVEIEdMWVBIJywgc3RhdGUuc3RhY2spO1xuICAgICAgICBmb3IgKHZhciBpJDMgPSAwOyBpJDMgPCBwTGVuOyBpJDMrKykge1xuICAgICAgICAgICAgY29uc29sZS5sb2coaSQzLCBnWm9uZVtpJDNdLngsIGdab25lW2kkM10ueSk7XG4gICAgICAgIH1cbiAgICB9XG59O1xuXG4vKlxuKiBFeGVjdXRlcyB0aGUgcHJvZ3JhbSBsb2FkZWQgaW4gc3RhdGUuXG4qL1xuZXhlYyA9IGZ1bmN0aW9uKHN0YXRlKSB7XG4gICAgdmFyIHByb2cgPSBzdGF0ZS5wcm9nO1xuXG4gICAgaWYgKCFwcm9nKSB7IHJldHVybjsgfVxuXG4gICAgdmFyIHBMZW4gPSBwcm9nLmxlbmd0aDtcbiAgICB2YXIgaW5zO1xuXG4gICAgZm9yIChzdGF0ZS5pcCA9IDA7IHN0YXRlLmlwIDwgcExlbjsgc3RhdGUuaXArKykge1xuICAgICAgICBpZiAoZXhwb3J0cy5ERUJVRykgeyBzdGF0ZS5zdGVwKys7IH1cbiAgICAgICAgaW5zID0gaW5zdHJ1Y3Rpb25UYWJsZVtwcm9nW3N0YXRlLmlwXV07XG5cbiAgICAgICAgaWYgKCFpbnMpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAgICAgICAndW5rbm93biBpbnN0cnVjdGlvbjogMHgnICtcbiAgICAgICAgICAgICAgICBOdW1iZXIocHJvZ1tzdGF0ZS5pcF0pLnRvU3RyaW5nKDE2KVxuICAgICAgICAgICAgKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlucyhzdGF0ZSk7XG5cbiAgICAgICAgLy8gdmVyeSBleHRlbnNpdmUgZGVidWdnaW5nIGZvciBlYWNoIHN0ZXBcbiAgICAgICAgLypcbiAgICAgICAgaWYgKGV4cG9ydHMuREVCVUcpIHtcbiAgICAgICAgICAgIHZhciBkYTtcbiAgICAgICAgICAgIGlmIChzdGF0ZS5nWm9uZSkge1xuICAgICAgICAgICAgICAgIGRhID0gW107XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzdGF0ZS5nWm9uZS5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIGRhLnB1c2goaSArICcgJyArXG4gICAgICAgICAgICAgICAgICAgICAgICBzdGF0ZS5nWm9uZVtpXS54ICogNjQgKyAnICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGUuZ1pvbmVbaV0ueSAqIDY0ICsgJyAnICtcbiAgICAgICAgICAgICAgICAgICAgICAgIChzdGF0ZS5nWm9uZVtpXS54VG91Y2hlZCA/ICd4JyA6ICcnKSArXG4gICAgICAgICAgICAgICAgICAgICAgICAoc3RhdGUuZ1pvbmVbaV0ueVRvdWNoZWQgPyAneScgOiAnJylcbiAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coJ0daJywgZGEpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoc3RhdGUudFpvbmUpIHtcbiAgICAgICAgICAgICAgICBkYSA9IFtdO1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc3RhdGUudFpvbmUubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgZGEucHVzaChpICsgJyAnICtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRlLnRab25lW2ldLnggKiA2NCArICcgJyArXG4gICAgICAgICAgICAgICAgICAgICAgICBzdGF0ZS50Wm9uZVtpXS55ICogNjQgKyAnICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgKHN0YXRlLnRab25lW2ldLnhUb3VjaGVkID8gJ3gnIDogJycpICtcbiAgICAgICAgICAgICAgICAgICAgICAgIChzdGF0ZS50Wm9uZVtpXS55VG91Y2hlZCA/ICd5JyA6ICcnKVxuICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZygnVFonLCBkYSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChzdGF0ZS5zdGFjay5sZW5ndGggPiAxMCkge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFxuICAgICAgICAgICAgICAgICAgICBzdGF0ZS5zdGFjay5sZW5ndGgsXG4gICAgICAgICAgICAgICAgICAgICcuLi4nLCBzdGF0ZS5zdGFjay5zbGljZShzdGF0ZS5zdGFjay5sZW5ndGggLSAxMClcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhzdGF0ZS5zdGFjay5sZW5ndGgsIHN0YXRlLnN0YWNrKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAqL1xuICAgIH1cbn07XG5cbi8qXG4qIEluaXRpYWxpemVzIHRoZSB0d2lsaWdodCB6b25lLlxuKlxuKiBUaGlzIGlzIG9ubHkgZG9uZSBpZiBhIFNaUHggaW5zdHJ1Y3Rpb25cbiogcmVmZXJzIHRvIHRoZSB0d2lsaWdodCB6b25lLlxuKi9cbmZ1bmN0aW9uIGluaXRUWm9uZShzdGF0ZSlcbntcbiAgICB2YXIgdFpvbmUgPSBzdGF0ZS50Wm9uZSA9IG5ldyBBcnJheShzdGF0ZS5nWm9uZS5sZW5ndGgpO1xuXG4gICAgLy8gbm8gaWRlYSBpZiB0aGlzIGlzIGFjdHVhbGx5IGNvcnJlY3QuLi5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRab25lLmxlbmd0aDsgaSsrKVxuICAgIHtcbiAgICAgICAgdFpvbmVbaV0gPSBuZXcgSFBvaW50KDAsIDApO1xuICAgIH1cbn1cblxuLypcbiogU2tpcHMgdGhlIGluc3RydWN0aW9uIHBvaW50ZXIgYWhlYWQgb3ZlciBhbiBJRi9FTFNFIGJsb2NrLlxuKiBoYW5kbGVFbHNlIC4uIGlmIHRydWUgYnJlYWtzIG9uIG1hdGNoaW5nIEVMU0VcbiovXG5mdW5jdGlvbiBza2lwKHN0YXRlLCBoYW5kbGVFbHNlKVxue1xuICAgIHZhciBwcm9nID0gc3RhdGUucHJvZztcbiAgICB2YXIgaXAgPSBzdGF0ZS5pcDtcbiAgICB2YXIgbmVzdGluZyA9IDE7XG4gICAgdmFyIGlucztcblxuICAgIGRvIHtcbiAgICAgICAgaW5zID0gcHJvZ1srK2lwXTtcbiAgICAgICAgaWYgKGlucyA9PT0gMHg1OCkgLy8gSUZcbiAgICAgICAgICAgIHsgbmVzdGluZysrOyB9XG4gICAgICAgIGVsc2UgaWYgKGlucyA9PT0gMHg1OSkgLy8gRUlGXG4gICAgICAgICAgICB7IG5lc3RpbmctLTsgfVxuICAgICAgICBlbHNlIGlmIChpbnMgPT09IDB4NDApIC8vIE5QVVNIQlxuICAgICAgICAgICAgeyBpcCArPSBwcm9nW2lwICsgMV0gKyAxOyB9XG4gICAgICAgIGVsc2UgaWYgKGlucyA9PT0gMHg0MSkgLy8gTlBVU0hXXG4gICAgICAgICAgICB7IGlwICs9IDIgKiBwcm9nW2lwICsgMV0gKyAxOyB9XG4gICAgICAgIGVsc2UgaWYgKGlucyA+PSAweEIwICYmIGlucyA8PSAweEI3KSAvLyBQVVNIQlxuICAgICAgICAgICAgeyBpcCArPSBpbnMgLSAweEIwICsgMTsgfVxuICAgICAgICBlbHNlIGlmIChpbnMgPj0gMHhCOCAmJiBpbnMgPD0gMHhCRikgLy8gUFVTSFdcbiAgICAgICAgICAgIHsgaXAgKz0gKGlucyAtIDB4QjggKyAxKSAqIDI7IH1cbiAgICAgICAgZWxzZSBpZiAoaGFuZGxlRWxzZSAmJiBuZXN0aW5nID09PSAxICYmIGlucyA9PT0gMHgxQikgLy8gRUxTRVxuICAgICAgICAgICAgeyBicmVhazsgfVxuICAgIH0gd2hpbGUgKG5lc3RpbmcgPiAwKTtcblxuICAgIHN0YXRlLmlwID0gaXA7XG59XG5cbi8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSpcbiogICAgICAgICAgQW5kIHRoZW4gYSBsb3Qgb2YgaW5zdHJ1Y3Rpb25zLi4uICAgICAgICAgICAgICAgICpcbiotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuLy8gU1ZUQ0FbYV0gU2V0IGZyZWVkb20gYW5kIHByb2plY3Rpb24gVmVjdG9ycyBUbyBDb29yZGluYXRlIEF4aXNcbi8vIDB4MDAtMHgwMVxuZnVuY3Rpb24gU1ZUQ0Eodiwgc3RhdGUpIHtcbiAgICBpZiAoZXhwb3J0cy5ERUJVRykgeyBjb25zb2xlLmxvZyhzdGF0ZS5zdGVwLCAnU1ZUQ0FbJyArIHYuYXhpcyArICddJyk7IH1cblxuICAgIHN0YXRlLmZ2ID0gc3RhdGUucHYgPSBzdGF0ZS5kcHYgPSB2O1xufVxuXG4vLyBTUFZUQ0FbYV0gU2V0IFByb2plY3Rpb24gVmVjdG9yIHRvIENvb3JkaW5hdGUgQXhpc1xuLy8gMHgwMi0weDAzXG5mdW5jdGlvbiBTUFZUQ0Eodiwgc3RhdGUpIHtcbiAgICBpZiAoZXhwb3J0cy5ERUJVRykgeyBjb25zb2xlLmxvZyhzdGF0ZS5zdGVwLCAnU1BWVENBWycgKyB2LmF4aXMgKyAnXScpOyB9XG5cbiAgICBzdGF0ZS5wdiA9IHN0YXRlLmRwdiA9IHY7XG59XG5cbi8vIFNGVlRDQVthXSBTZXQgRnJlZWRvbSBWZWN0b3IgdG8gQ29vcmRpbmF0ZSBBeGlzXG4vLyAweDA0LTB4MDVcbmZ1bmN0aW9uIFNGVlRDQSh2LCBzdGF0ZSkge1xuICAgIGlmIChleHBvcnRzLkRFQlVHKSB7IGNvbnNvbGUubG9nKHN0YXRlLnN0ZXAsICdTRlZUQ0FbJyArIHYuYXhpcyArICddJyk7IH1cblxuICAgIHN0YXRlLmZ2ID0gdjtcbn1cblxuLy8gU1BWVExbYV0gU2V0IFByb2plY3Rpb24gVmVjdG9yIFRvIExpbmVcbi8vIDB4MDYtMHgwN1xuZnVuY3Rpb24gU1BWVEwoYSwgc3RhdGUpIHtcbiAgICB2YXIgc3RhY2sgPSBzdGF0ZS5zdGFjaztcbiAgICB2YXIgcDJpID0gc3RhY2sucG9wKCk7XG4gICAgdmFyIHAxaSA9IHN0YWNrLnBvcCgpO1xuICAgIHZhciBwMiA9IHN0YXRlLnoyW3AyaV07XG4gICAgdmFyIHAxID0gc3RhdGUuejFbcDFpXTtcblxuICAgIGlmIChleHBvcnRzLkRFQlVHKSB7IGNvbnNvbGUubG9nKCdTUFZUTFsnICsgYSArICddJywgcDJpLCBwMWkpOyB9XG5cbiAgICB2YXIgZHg7XG4gICAgdmFyIGR5O1xuXG4gICAgaWYgKCFhKSB7XG4gICAgICAgIGR4ID0gcDEueCAtIHAyLng7XG4gICAgICAgIGR5ID0gcDEueSAtIHAyLnk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgZHggPSBwMi55IC0gcDEueTtcbiAgICAgICAgZHkgPSBwMS54IC0gcDIueDtcbiAgICB9XG5cbiAgICBzdGF0ZS5wdiA9IHN0YXRlLmRwdiA9IGdldFVuaXRWZWN0b3IoZHgsIGR5KTtcbn1cblxuLy8gU0ZWVExbYV0gU2V0IEZyZWVkb20gVmVjdG9yIFRvIExpbmVcbi8vIDB4MDgtMHgwOVxuZnVuY3Rpb24gU0ZWVEwoYSwgc3RhdGUpIHtcbiAgICB2YXIgc3RhY2sgPSBzdGF0ZS5zdGFjaztcbiAgICB2YXIgcDJpID0gc3RhY2sucG9wKCk7XG4gICAgdmFyIHAxaSA9IHN0YWNrLnBvcCgpO1xuICAgIHZhciBwMiA9IHN0YXRlLnoyW3AyaV07XG4gICAgdmFyIHAxID0gc3RhdGUuejFbcDFpXTtcblxuICAgIGlmIChleHBvcnRzLkRFQlVHKSB7IGNvbnNvbGUubG9nKCdTRlZUTFsnICsgYSArICddJywgcDJpLCBwMWkpOyB9XG5cbiAgICB2YXIgZHg7XG4gICAgdmFyIGR5O1xuXG4gICAgaWYgKCFhKSB7XG4gICAgICAgIGR4ID0gcDEueCAtIHAyLng7XG4gICAgICAgIGR5ID0gcDEueSAtIHAyLnk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgZHggPSBwMi55IC0gcDEueTtcbiAgICAgICAgZHkgPSBwMS54IC0gcDIueDtcbiAgICB9XG5cbiAgICBzdGF0ZS5mdiA9IGdldFVuaXRWZWN0b3IoZHgsIGR5KTtcbn1cblxuLy8gU1BWRlNbXSBTZXQgUHJvamVjdGlvbiBWZWN0b3IgRnJvbSBTdGFja1xuLy8gMHgwQVxuZnVuY3Rpb24gU1BWRlMoc3RhdGUpIHtcbiAgICB2YXIgc3RhY2sgPSBzdGF0ZS5zdGFjaztcbiAgICB2YXIgeSA9IHN0YWNrLnBvcCgpO1xuICAgIHZhciB4ID0gc3RhY2sucG9wKCk7XG5cbiAgICBpZiAoZXhwb3J0cy5ERUJVRykgeyBjb25zb2xlLmxvZyhzdGF0ZS5zdGVwLCAnU1BWRlNbXScsIHksIHgpOyB9XG5cbiAgICBzdGF0ZS5wdiA9IHN0YXRlLmRwdiA9IGdldFVuaXRWZWN0b3IoeCwgeSk7XG59XG5cbi8vIFNGVkZTW10gU2V0IEZyZWVkb20gVmVjdG9yIEZyb20gU3RhY2tcbi8vIDB4MEJcbmZ1bmN0aW9uIFNGVkZTKHN0YXRlKSB7XG4gICAgdmFyIHN0YWNrID0gc3RhdGUuc3RhY2s7XG4gICAgdmFyIHkgPSBzdGFjay5wb3AoKTtcbiAgICB2YXIgeCA9IHN0YWNrLnBvcCgpO1xuXG4gICAgaWYgKGV4cG9ydHMuREVCVUcpIHsgY29uc29sZS5sb2coc3RhdGUuc3RlcCwgJ1NQVkZTW10nLCB5LCB4KTsgfVxuXG4gICAgc3RhdGUuZnYgPSBnZXRVbml0VmVjdG9yKHgsIHkpO1xufVxuXG4vLyBHUFZbXSBHZXQgUHJvamVjdGlvbiBWZWN0b3Jcbi8vIDB4MENcbmZ1bmN0aW9uIEdQVihzdGF0ZSkge1xuICAgIHZhciBzdGFjayA9IHN0YXRlLnN0YWNrO1xuICAgIHZhciBwdiA9IHN0YXRlLnB2O1xuXG4gICAgaWYgKGV4cG9ydHMuREVCVUcpIHsgY29uc29sZS5sb2coc3RhdGUuc3RlcCwgJ0dQVltdJyk7IH1cblxuICAgIHN0YWNrLnB1c2gocHYueCAqIDB4NDAwMCk7XG4gICAgc3RhY2sucHVzaChwdi55ICogMHg0MDAwKTtcbn1cblxuLy8gR0ZWW10gR2V0IEZyZWVkb20gVmVjdG9yXG4vLyAweDBDXG5mdW5jdGlvbiBHRlYoc3RhdGUpIHtcbiAgICB2YXIgc3RhY2sgPSBzdGF0ZS5zdGFjaztcbiAgICB2YXIgZnYgPSBzdGF0ZS5mdjtcblxuICAgIGlmIChleHBvcnRzLkRFQlVHKSB7IGNvbnNvbGUubG9nKHN0YXRlLnN0ZXAsICdHRlZbXScpOyB9XG5cbiAgICBzdGFjay5wdXNoKGZ2LnggKiAweDQwMDApO1xuICAgIHN0YWNrLnB1c2goZnYueSAqIDB4NDAwMCk7XG59XG5cbi8vIFNGVlRQVltdIFNldCBGcmVlZG9tIFZlY3RvciBUbyBQcm9qZWN0aW9uIFZlY3RvclxuLy8gMHgwRVxuZnVuY3Rpb24gU0ZWVFBWKHN0YXRlKSB7XG4gICAgc3RhdGUuZnYgPSBzdGF0ZS5wdjtcblxuICAgIGlmIChleHBvcnRzLkRFQlVHKSB7IGNvbnNvbGUubG9nKHN0YXRlLnN0ZXAsICdTRlZUUFZbXScpOyB9XG59XG5cbi8vIElTRUNUW10gbW92ZXMgcG9pbnQgcCB0byB0aGUgSW50ZXJTRUNUaW9uIG9mIHR3byBsaW5lc1xuLy8gMHgwRlxuZnVuY3Rpb24gSVNFQ1Qoc3RhdGUpXG57XG4gICAgdmFyIHN0YWNrID0gc3RhdGUuc3RhY2s7XG4gICAgdmFyIHBhMGkgPSBzdGFjay5wb3AoKTtcbiAgICB2YXIgcGExaSA9IHN0YWNrLnBvcCgpO1xuICAgIHZhciBwYjBpID0gc3RhY2sucG9wKCk7XG4gICAgdmFyIHBiMWkgPSBzdGFjay5wb3AoKTtcbiAgICB2YXIgcGkgPSBzdGFjay5wb3AoKTtcbiAgICB2YXIgejAgPSBzdGF0ZS56MDtcbiAgICB2YXIgejEgPSBzdGF0ZS56MTtcbiAgICB2YXIgcGEwID0gejBbcGEwaV07XG4gICAgdmFyIHBhMSA9IHowW3BhMWldO1xuICAgIHZhciBwYjAgPSB6MVtwYjBpXTtcbiAgICB2YXIgcGIxID0gejFbcGIxaV07XG4gICAgdmFyIHAgPSBzdGF0ZS56MltwaV07XG5cbiAgICBpZiAoZXhwb3J0cy5ERUJVRykgeyBjb25zb2xlLmxvZygnSVNFQ1RbXSwgJywgcGEwaSwgcGExaSwgcGIwaSwgcGIxaSwgcGkpOyB9XG5cbiAgICAvLyBtYXRoIGZyb21cbiAgICAvLyBlbi53aWtpcGVkaWEub3JnL3dpa2kvTGluZSVFMiU4MCU5M2xpbmVfaW50ZXJzZWN0aW9uI0dpdmVuX3R3b19wb2ludHNfb25fZWFjaF9saW5lXG5cbiAgICB2YXIgeDEgPSBwYTAueDtcbiAgICB2YXIgeTEgPSBwYTAueTtcbiAgICB2YXIgeDIgPSBwYTEueDtcbiAgICB2YXIgeTIgPSBwYTEueTtcbiAgICB2YXIgeDMgPSBwYjAueDtcbiAgICB2YXIgeTMgPSBwYjAueTtcbiAgICB2YXIgeDQgPSBwYjEueDtcbiAgICB2YXIgeTQgPSBwYjEueTtcblxuICAgIHZhciBkaXYgPSAoeDEgLSB4MikgKiAoeTMgLSB5NCkgLSAoeTEgLSB5MikgKiAoeDMgLSB4NCk7XG4gICAgdmFyIGYxID0geDEgKiB5MiAtIHkxICogeDI7XG4gICAgdmFyIGYyID0geDMgKiB5NCAtIHkzICogeDQ7XG5cbiAgICBwLnggPSAoZjEgKiAoeDMgLSB4NCkgLSBmMiAqICh4MSAtIHgyKSkgLyBkaXY7XG4gICAgcC55ID0gKGYxICogKHkzIC0geTQpIC0gZjIgKiAoeTEgLSB5MikpIC8gZGl2O1xufVxuXG4vLyBTUlAwW10gU2V0IFJlZmVyZW5jZSBQb2ludCAwXG4vLyAweDEwXG5mdW5jdGlvbiBTUlAwKHN0YXRlKSB7XG4gICAgc3RhdGUucnAwID0gc3RhdGUuc3RhY2sucG9wKCk7XG5cbiAgICBpZiAoZXhwb3J0cy5ERUJVRykgeyBjb25zb2xlLmxvZyhzdGF0ZS5zdGVwLCAnU1JQMFtdJywgc3RhdGUucnAwKTsgfVxufVxuXG4vLyBTUlAxW10gU2V0IFJlZmVyZW5jZSBQb2ludCAxXG4vLyAweDExXG5mdW5jdGlvbiBTUlAxKHN0YXRlKSB7XG4gICAgc3RhdGUucnAxID0gc3RhdGUuc3RhY2sucG9wKCk7XG5cbiAgICBpZiAoZXhwb3J0cy5ERUJVRykgeyBjb25zb2xlLmxvZyhzdGF0ZS5zdGVwLCAnU1JQMVtdJywgc3RhdGUucnAxKTsgfVxufVxuXG4vLyBTUlAxW10gU2V0IFJlZmVyZW5jZSBQb2ludCAyXG4vLyAweDEyXG5mdW5jdGlvbiBTUlAyKHN0YXRlKSB7XG4gICAgc3RhdGUucnAyID0gc3RhdGUuc3RhY2sucG9wKCk7XG5cbiAgICBpZiAoZXhwb3J0cy5ERUJVRykgeyBjb25zb2xlLmxvZyhzdGF0ZS5zdGVwLCAnU1JQMltdJywgc3RhdGUucnAyKTsgfVxufVxuXG4vLyBTWlAwW10gU2V0IFpvbmUgUG9pbnRlciAwXG4vLyAweDEzXG5mdW5jdGlvbiBTWlAwKHN0YXRlKSB7XG4gICAgdmFyIG4gPSBzdGF0ZS5zdGFjay5wb3AoKTtcblxuICAgIGlmIChleHBvcnRzLkRFQlVHKSB7IGNvbnNvbGUubG9nKHN0YXRlLnN0ZXAsICdTWlAwW10nLCBuKTsgfVxuXG4gICAgc3RhdGUuenAwID0gbjtcblxuICAgIHN3aXRjaCAobikge1xuICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICBpZiAoIXN0YXRlLnRab25lKSB7IGluaXRUWm9uZShzdGF0ZSk7IH1cbiAgICAgICAgICAgIHN0YXRlLnowID0gc3RhdGUudFpvbmU7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAxIDpcbiAgICAgICAgICAgIHN0YXRlLnowID0gc3RhdGUuZ1pvbmU7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdCA6XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgem9uZSBwb2ludGVyJyk7XG4gICAgfVxufVxuXG4vLyBTWlAxW10gU2V0IFpvbmUgUG9pbnRlciAxXG4vLyAweDE0XG5mdW5jdGlvbiBTWlAxKHN0YXRlKSB7XG4gICAgdmFyIG4gPSBzdGF0ZS5zdGFjay5wb3AoKTtcblxuICAgIGlmIChleHBvcnRzLkRFQlVHKSB7IGNvbnNvbGUubG9nKHN0YXRlLnN0ZXAsICdTWlAxW10nLCBuKTsgfVxuXG4gICAgc3RhdGUuenAxID0gbjtcblxuICAgIHN3aXRjaCAobikge1xuICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICBpZiAoIXN0YXRlLnRab25lKSB7IGluaXRUWm9uZShzdGF0ZSk7IH1cbiAgICAgICAgICAgIHN0YXRlLnoxID0gc3RhdGUudFpvbmU7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAxIDpcbiAgICAgICAgICAgIHN0YXRlLnoxID0gc3RhdGUuZ1pvbmU7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdCA6XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgem9uZSBwb2ludGVyJyk7XG4gICAgfVxufVxuXG4vLyBTWlAyW10gU2V0IFpvbmUgUG9pbnRlciAyXG4vLyAweDE1XG5mdW5jdGlvbiBTWlAyKHN0YXRlKSB7XG4gICAgdmFyIG4gPSBzdGF0ZS5zdGFjay5wb3AoKTtcblxuICAgIGlmIChleHBvcnRzLkRFQlVHKSB7IGNvbnNvbGUubG9nKHN0YXRlLnN0ZXAsICdTWlAyW10nLCBuKTsgfVxuXG4gICAgc3RhdGUuenAyID0gbjtcblxuICAgIHN3aXRjaCAobikge1xuICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICBpZiAoIXN0YXRlLnRab25lKSB7IGluaXRUWm9uZShzdGF0ZSk7IH1cbiAgICAgICAgICAgIHN0YXRlLnoyID0gc3RhdGUudFpvbmU7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAxIDpcbiAgICAgICAgICAgIHN0YXRlLnoyID0gc3RhdGUuZ1pvbmU7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdCA6XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgem9uZSBwb2ludGVyJyk7XG4gICAgfVxufVxuXG4vLyBTWlBTW10gU2V0IFpvbmUgUG9pbnRlclNcbi8vIDB4MTZcbmZ1bmN0aW9uIFNaUFMoc3RhdGUpIHtcbiAgICB2YXIgbiA9IHN0YXRlLnN0YWNrLnBvcCgpO1xuXG4gICAgaWYgKGV4cG9ydHMuREVCVUcpIHsgY29uc29sZS5sb2coc3RhdGUuc3RlcCwgJ1NaUFNbXScsIG4pOyB9XG5cbiAgICBzdGF0ZS56cDAgPSBzdGF0ZS56cDEgPSBzdGF0ZS56cDIgPSBuO1xuXG4gICAgc3dpdGNoIChuKSB7XG4gICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgIGlmICghc3RhdGUudFpvbmUpIHsgaW5pdFRab25lKHN0YXRlKTsgfVxuICAgICAgICAgICAgc3RhdGUuejAgPSBzdGF0ZS56MSA9IHN0YXRlLnoyID0gc3RhdGUudFpvbmU7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAxIDpcbiAgICAgICAgICAgIHN0YXRlLnowID0gc3RhdGUuejEgPSBzdGF0ZS56MiA9IHN0YXRlLmdab25lO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQgOlxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHpvbmUgcG9pbnRlcicpO1xuICAgIH1cbn1cblxuLy8gU0xPT1BbXSBTZXQgTE9PUCB2YXJpYWJsZVxuLy8gMHgxN1xuZnVuY3Rpb24gU0xPT1Aoc3RhdGUpIHtcbiAgICBzdGF0ZS5sb29wID0gc3RhdGUuc3RhY2sucG9wKCk7XG5cbiAgICBpZiAoZXhwb3J0cy5ERUJVRykgeyBjb25zb2xlLmxvZyhzdGF0ZS5zdGVwLCAnU0xPT1BbXScsIHN0YXRlLmxvb3ApOyB9XG59XG5cbi8vIFJUR1tdIFJvdW5kIFRvIEdyaWRcbi8vIDB4MThcbmZ1bmN0aW9uIFJURyhzdGF0ZSkge1xuICAgIGlmIChleHBvcnRzLkRFQlVHKSB7IGNvbnNvbGUubG9nKHN0YXRlLnN0ZXAsICdSVEdbXScpOyB9XG5cbiAgICBzdGF0ZS5yb3VuZCA9IHJvdW5kVG9HcmlkO1xufVxuXG4vLyBSVEhHW10gUm91bmQgVG8gSGFsZiBHcmlkXG4vLyAweDE5XG5mdW5jdGlvbiBSVEhHKHN0YXRlKSB7XG4gICAgaWYgKGV4cG9ydHMuREVCVUcpIHsgY29uc29sZS5sb2coc3RhdGUuc3RlcCwgJ1JUSEdbXScpOyB9XG5cbiAgICBzdGF0ZS5yb3VuZCA9IHJvdW5kVG9IYWxmR3JpZDtcbn1cblxuLy8gU01EW10gU2V0IE1pbmltdW0gRGlzdGFuY2Vcbi8vIDB4MUFcbmZ1bmN0aW9uIFNNRChzdGF0ZSkge1xuICAgIHZhciBkID0gc3RhdGUuc3RhY2sucG9wKCk7XG5cbiAgICBpZiAoZXhwb3J0cy5ERUJVRykgeyBjb25zb2xlLmxvZyhzdGF0ZS5zdGVwLCAnU01EW10nLCBkKTsgfVxuXG4gICAgc3RhdGUubWluRGlzID0gZCAvIDB4NDA7XG59XG5cbi8vIEVMU0VbXSBFTFNFIGNsYXVzZVxuLy8gMHgxQlxuZnVuY3Rpb24gRUxTRShzdGF0ZSkge1xuICAgIC8vIFRoaXMgaW5zdHJ1Y3Rpb24gaGFzIGJlZW4gcmVhY2hlZCBieSBleGVjdXRpbmcgYSB0aGVuIGJyYW5jaFxuICAgIC8vIHNvIGl0IGp1c3Qgc2tpcHMgYWhlYWQgdW50aWwgbWF0Y2hpbmcgRUlGLlxuICAgIC8vXG4gICAgLy8gSW4gY2FzZSB0aGUgSUYgd2FzIG5lZ2F0aXZlIHRoZSBJRltdIGluc3RydWN0aW9uIGFscmVhZHlcbiAgICAvLyBza2lwcGVkIGZvcndhcmQgb3ZlciB0aGUgRUxTRVtdXG5cbiAgICBpZiAoZXhwb3J0cy5ERUJVRykgeyBjb25zb2xlLmxvZyhzdGF0ZS5zdGVwLCAnRUxTRVtdJyk7IH1cblxuICAgIHNraXAoc3RhdGUsIGZhbHNlKTtcbn1cblxuLy8gSk1QUltdIEp1TVAgUmVsYXRpdmVcbi8vIDB4MUNcbmZ1bmN0aW9uIEpNUFIoc3RhdGUpIHtcbiAgICB2YXIgbyA9IHN0YXRlLnN0YWNrLnBvcCgpO1xuXG4gICAgaWYgKGV4cG9ydHMuREVCVUcpIHsgY29uc29sZS5sb2coc3RhdGUuc3RlcCwgJ0pNUFJbXScsIG8pOyB9XG5cbiAgICAvLyBBIGp1bXAgYnkgMSB3b3VsZCBkbyBub3RoaW5nLlxuICAgIHN0YXRlLmlwICs9IG8gLSAxO1xufVxuXG4vLyBTQ1ZUQ0lbXSBTZXQgQ29udHJvbCBWYWx1ZSBUYWJsZSBDdXQtSW5cbi8vIDB4MURcbmZ1bmN0aW9uIFNDVlRDSShzdGF0ZSkge1xuICAgIHZhciBuID0gc3RhdGUuc3RhY2sucG9wKCk7XG5cbiAgICBpZiAoZXhwb3J0cy5ERUJVRykgeyBjb25zb2xlLmxvZyhzdGF0ZS5zdGVwLCAnU0NWVENJW10nLCBuKTsgfVxuXG4gICAgc3RhdGUuY3ZDdXRJbiA9IG4gLyAweDQwO1xufVxuXG4vLyBEVVBbXSBEVVBsaWNhdGUgdG9wIHN0YWNrIGVsZW1lbnRcbi8vIDB4MjBcbmZ1bmN0aW9uIERVUChzdGF0ZSkge1xuICAgIHZhciBzdGFjayA9IHN0YXRlLnN0YWNrO1xuXG4gICAgaWYgKGV4cG9ydHMuREVCVUcpIHsgY29uc29sZS5sb2coc3RhdGUuc3RlcCwgJ0RVUFtdJyk7IH1cblxuICAgIHN0YWNrLnB1c2goc3RhY2tbc3RhY2subGVuZ3RoIC0gMV0pO1xufVxuXG4vLyBQT1BbXSBQT1AgdG9wIHN0YWNrIGVsZW1lbnRcbi8vIDB4MjFcbmZ1bmN0aW9uIFBPUChzdGF0ZSkge1xuICAgIGlmIChleHBvcnRzLkRFQlVHKSB7IGNvbnNvbGUubG9nKHN0YXRlLnN0ZXAsICdQT1BbXScpOyB9XG5cbiAgICBzdGF0ZS5zdGFjay5wb3AoKTtcbn1cblxuLy8gQ0xFQVJbXSBDTEVBUiB0aGUgc3RhY2tcbi8vIDB4MjJcbmZ1bmN0aW9uIENMRUFSKHN0YXRlKSB7XG4gICAgaWYgKGV4cG9ydHMuREVCVUcpIHsgY29uc29sZS5sb2coc3RhdGUuc3RlcCwgJ0NMRUFSW10nKTsgfVxuXG4gICAgc3RhdGUuc3RhY2subGVuZ3RoID0gMDtcbn1cblxuLy8gU1dBUFtdIFNXQVAgdGhlIHRvcCB0d28gZWxlbWVudHMgb24gdGhlIHN0YWNrXG4vLyAweDIzXG5mdW5jdGlvbiBTV0FQKHN0YXRlKSB7XG4gICAgdmFyIHN0YWNrID0gc3RhdGUuc3RhY2s7XG5cbiAgICB2YXIgYSA9IHN0YWNrLnBvcCgpO1xuICAgIHZhciBiID0gc3RhY2sucG9wKCk7XG5cbiAgICBpZiAoZXhwb3J0cy5ERUJVRykgeyBjb25zb2xlLmxvZyhzdGF0ZS5zdGVwLCAnU1dBUFtdJyk7IH1cblxuICAgIHN0YWNrLnB1c2goYSk7XG4gICAgc3RhY2sucHVzaChiKTtcbn1cblxuLy8gREVQVEhbXSBERVBUSCBvZiB0aGUgc3RhY2tcbi8vIDB4MjRcbmZ1bmN0aW9uIERFUFRIKHN0YXRlKSB7XG4gICAgdmFyIHN0YWNrID0gc3RhdGUuc3RhY2s7XG5cbiAgICBpZiAoZXhwb3J0cy5ERUJVRykgeyBjb25zb2xlLmxvZyhzdGF0ZS5zdGVwLCAnREVQVEhbXScpOyB9XG5cbiAgICBzdGFjay5wdXNoKHN0YWNrLmxlbmd0aCk7XG59XG5cbi8vIExPT1BDQUxMW10gTE9PUENBTEwgZnVuY3Rpb25cbi8vIDB4MkFcbmZ1bmN0aW9uIExPT1BDQUxMKHN0YXRlKSB7XG4gICAgdmFyIHN0YWNrID0gc3RhdGUuc3RhY2s7XG4gICAgdmFyIGZuID0gc3RhY2sucG9wKCk7XG4gICAgdmFyIGMgPSBzdGFjay5wb3AoKTtcblxuICAgIGlmIChleHBvcnRzLkRFQlVHKSB7IGNvbnNvbGUubG9nKHN0YXRlLnN0ZXAsICdMT09QQ0FMTFtdJywgZm4sIGMpOyB9XG5cbiAgICAvLyBzYXZlcyBjYWxsZXJzIHByb2dyYW1cbiAgICB2YXIgY2lwID0gc3RhdGUuaXA7XG4gICAgdmFyIGNwcm9nID0gc3RhdGUucHJvZztcblxuICAgIHN0YXRlLnByb2cgPSBzdGF0ZS5mdW5jc1tmbl07XG5cbiAgICAvLyBleGVjdXRlcyB0aGUgZnVuY3Rpb25cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGM7IGkrKykge1xuICAgICAgICBleGVjKHN0YXRlKTtcblxuICAgICAgICBpZiAoZXhwb3J0cy5ERUJVRykgeyBjb25zb2xlLmxvZyhcbiAgICAgICAgICAgICsrc3RhdGUuc3RlcCxcbiAgICAgICAgICAgIGkgKyAxIDwgYyA/ICduZXh0IGxvb3BjYWxsJyA6ICdkb25lIGxvb3BjYWxsJyxcbiAgICAgICAgICAgIGlcbiAgICAgICAgKTsgfVxuICAgIH1cblxuICAgIC8vIHJlc3RvcmVzIHRoZSBjYWxsZXJzIHByb2dyYW1cbiAgICBzdGF0ZS5pcCA9IGNpcDtcbiAgICBzdGF0ZS5wcm9nID0gY3Byb2c7XG59XG5cbi8vIENBTExbXSBDQUxMIGZ1bmN0aW9uXG4vLyAweDJCXG5mdW5jdGlvbiBDQUxMKHN0YXRlKSB7XG4gICAgdmFyIGZuID0gc3RhdGUuc3RhY2sucG9wKCk7XG5cbiAgICBpZiAoZXhwb3J0cy5ERUJVRykgeyBjb25zb2xlLmxvZyhzdGF0ZS5zdGVwLCAnQ0FMTFtdJywgZm4pOyB9XG5cbiAgICAvLyBzYXZlcyBjYWxsZXJzIHByb2dyYW1cbiAgICB2YXIgY2lwID0gc3RhdGUuaXA7XG4gICAgdmFyIGNwcm9nID0gc3RhdGUucHJvZztcblxuICAgIHN0YXRlLnByb2cgPSBzdGF0ZS5mdW5jc1tmbl07XG5cbiAgICAvLyBleGVjdXRlcyB0aGUgZnVuY3Rpb25cbiAgICBleGVjKHN0YXRlKTtcblxuICAgIC8vIHJlc3RvcmVzIHRoZSBjYWxsZXJzIHByb2dyYW1cbiAgICBzdGF0ZS5pcCA9IGNpcDtcbiAgICBzdGF0ZS5wcm9nID0gY3Byb2c7XG5cbiAgICBpZiAoZXhwb3J0cy5ERUJVRykgeyBjb25zb2xlLmxvZygrK3N0YXRlLnN0ZXAsICdyZXR1cm5pbmcgZnJvbScsIGZuKTsgfVxufVxuXG4vLyBDSU5ERVhbXSBDb3B5IHRoZSBJTkRFWGVkIGVsZW1lbnQgdG8gdGhlIHRvcCBvZiB0aGUgc3RhY2tcbi8vIDB4MjVcbmZ1bmN0aW9uIENJTkRFWChzdGF0ZSkge1xuICAgIHZhciBzdGFjayA9IHN0YXRlLnN0YWNrO1xuICAgIHZhciBrID0gc3RhY2sucG9wKCk7XG5cbiAgICBpZiAoZXhwb3J0cy5ERUJVRykgeyBjb25zb2xlLmxvZyhzdGF0ZS5zdGVwLCAnQ0lOREVYW10nLCBrKTsgfVxuXG4gICAgLy8gSW4gY2FzZSBvZiBrID09IDEsIGl0IGNvcGllcyB0aGUgbGFzdCBlbGVtZW50IGFmdGVyIHBvcHBpbmdcbiAgICAvLyB0aHVzIHN0YWNrLmxlbmd0aCAtIGsuXG4gICAgc3RhY2sucHVzaChzdGFja1tzdGFjay5sZW5ndGggLSBrXSk7XG59XG5cbi8vIE1JTkRFWFtdIE1vdmUgdGhlIElOREVYZWQgZWxlbWVudCB0byB0aGUgdG9wIG9mIHRoZSBzdGFja1xuLy8gMHgyNlxuZnVuY3Rpb24gTUlOREVYKHN0YXRlKSB7XG4gICAgdmFyIHN0YWNrID0gc3RhdGUuc3RhY2s7XG4gICAgdmFyIGsgPSBzdGFjay5wb3AoKTtcblxuICAgIGlmIChleHBvcnRzLkRFQlVHKSB7IGNvbnNvbGUubG9nKHN0YXRlLnN0ZXAsICdNSU5ERVhbXScsIGspOyB9XG5cbiAgICBzdGFjay5wdXNoKHN0YWNrLnNwbGljZShzdGFjay5sZW5ndGggLSBrLCAxKVswXSk7XG59XG5cbi8vIEZERUZbXSBGdW5jdGlvbiBERUZpbml0aW9uXG4vLyAweDJDXG5mdW5jdGlvbiBGREVGKHN0YXRlKSB7XG4gICAgaWYgKHN0YXRlLmVudiAhPT0gJ2ZwZ20nKSB7IHRocm93IG5ldyBFcnJvcignRkRFRiBub3QgYWxsb3dlZCBoZXJlJyk7IH1cbiAgICB2YXIgc3RhY2sgPSBzdGF0ZS5zdGFjaztcbiAgICB2YXIgcHJvZyA9IHN0YXRlLnByb2c7XG4gICAgdmFyIGlwID0gc3RhdGUuaXA7XG5cbiAgICB2YXIgZm4gPSBzdGFjay5wb3AoKTtcbiAgICB2YXIgaXBCZWdpbiA9IGlwO1xuXG4gICAgaWYgKGV4cG9ydHMuREVCVUcpIHsgY29uc29sZS5sb2coc3RhdGUuc3RlcCwgJ0ZERUZbXScsIGZuKTsgfVxuXG4gICAgd2hpbGUgKHByb2dbKytpcF0gIT09IDB4MkQpeyB9XG5cbiAgICBzdGF0ZS5pcCA9IGlwO1xuICAgIHN0YXRlLmZ1bmNzW2ZuXSA9IHByb2cuc2xpY2UoaXBCZWdpbiArIDEsIGlwKTtcbn1cblxuLy8gTURBUFthXSBNb3ZlIERpcmVjdCBBYnNvbHV0ZSBQb2ludFxuLy8gMHgyRS0weDJGXG5mdW5jdGlvbiBNREFQKHJvdW5kLCBzdGF0ZSkge1xuICAgIHZhciBwaSA9IHN0YXRlLnN0YWNrLnBvcCgpO1xuICAgIHZhciBwID0gc3RhdGUuejBbcGldO1xuICAgIHZhciBmdiA9IHN0YXRlLmZ2O1xuICAgIHZhciBwdiA9IHN0YXRlLnB2O1xuXG4gICAgaWYgKGV4cG9ydHMuREVCVUcpIHsgY29uc29sZS5sb2coc3RhdGUuc3RlcCwgJ01EQVBbJyArIHJvdW5kICsgJ10nLCBwaSk7IH1cblxuICAgIHZhciBkID0gcHYuZGlzdGFuY2UocCwgSFBaZXJvKTtcblxuICAgIGlmIChyb3VuZCkgeyBkID0gc3RhdGUucm91bmQoZCk7IH1cblxuICAgIGZ2LnNldFJlbGF0aXZlKHAsIEhQWmVybywgZCwgcHYpO1xuICAgIGZ2LnRvdWNoKHApO1xuXG4gICAgc3RhdGUucnAwID0gc3RhdGUucnAxID0gcGk7XG59XG5cbi8vIElVUFthXSBJbnRlcnBvbGF0ZSBVbnRvdWNoZWQgUG9pbnRzIHRocm91Z2ggdGhlIG91dGxpbmVcbi8vIDB4MzBcbmZ1bmN0aW9uIElVUCh2LCBzdGF0ZSkge1xuICAgIHZhciB6MiA9IHN0YXRlLnoyO1xuICAgIHZhciBwTGVuID0gejIubGVuZ3RoIC0gMjtcbiAgICB2YXIgY3A7XG4gICAgdmFyIHBwO1xuICAgIHZhciBucDtcblxuICAgIGlmIChleHBvcnRzLkRFQlVHKSB7IGNvbnNvbGUubG9nKHN0YXRlLnN0ZXAsICdJVVBbJyArIHYuYXhpcyArICddJyk7IH1cblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcExlbjsgaSsrKSB7XG4gICAgICAgIGNwID0gejJbaV07IC8vIGN1cnJlbnQgcG9pbnRcblxuICAgICAgICAvLyBpZiB0aGlzIHBvaW50IGhhcyBiZWVuIHRvdWNoZWQgZ28gb25cbiAgICAgICAgaWYgKHYudG91Y2hlZChjcCkpIHsgY29udGludWU7IH1cblxuICAgICAgICBwcCA9IGNwLnByZXZUb3VjaGVkKHYpO1xuXG4gICAgICAgIC8vIG5vIHBvaW50IG9uIHRoZSBjb250b3VyIGhhcyBiZWVuIHRvdWNoZWQ/XG4gICAgICAgIGlmIChwcCA9PT0gY3ApIHsgY29udGludWU7IH1cblxuICAgICAgICBucCA9IGNwLm5leHRUb3VjaGVkKHYpO1xuXG4gICAgICAgIGlmIChwcCA9PT0gbnApIHtcbiAgICAgICAgICAgIC8vIG9ubHkgb25lIHBvaW50IG9uIHRoZSBjb250b3VyIGhhcyBiZWVuIHRvdWNoZWRcbiAgICAgICAgICAgIC8vIHNvIHNpbXBseSBtb3ZlcyB0aGUgcG9pbnQgbGlrZSB0aGF0XG5cbiAgICAgICAgICAgIHYuc2V0UmVsYXRpdmUoY3AsIGNwLCB2LmRpc3RhbmNlKHBwLCBwcCwgZmFsc2UsIHRydWUpLCB2LCB0cnVlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHYuaW50ZXJwb2xhdGUoY3AsIHBwLCBucCwgdik7XG4gICAgfVxufVxuXG4vLyBTSFBbXSBTSGlmdCBQb2ludCB1c2luZyByZWZlcmVuY2UgcG9pbnRcbi8vIDB4MzItMHgzM1xuZnVuY3Rpb24gU0hQKGEsIHN0YXRlKSB7XG4gICAgdmFyIHN0YWNrID0gc3RhdGUuc3RhY2s7XG4gICAgdmFyIHJwaSA9IGEgPyBzdGF0ZS5ycDEgOiBzdGF0ZS5ycDI7XG4gICAgdmFyIHJwID0gKGEgPyBzdGF0ZS56MCA6IHN0YXRlLnoxKVtycGldO1xuICAgIHZhciBmdiA9IHN0YXRlLmZ2O1xuICAgIHZhciBwdiA9IHN0YXRlLnB2O1xuICAgIHZhciBsb29wID0gc3RhdGUubG9vcDtcbiAgICB2YXIgejIgPSBzdGF0ZS56MjtcblxuICAgIHdoaWxlIChsb29wLS0pXG4gICAge1xuICAgICAgICB2YXIgcGkgPSBzdGFjay5wb3AoKTtcbiAgICAgICAgdmFyIHAgPSB6MltwaV07XG5cbiAgICAgICAgdmFyIGQgPSBwdi5kaXN0YW5jZShycCwgcnAsIGZhbHNlLCB0cnVlKTtcbiAgICAgICAgZnYuc2V0UmVsYXRpdmUocCwgcCwgZCwgcHYpO1xuICAgICAgICBmdi50b3VjaChwKTtcblxuICAgICAgICBpZiAoZXhwb3J0cy5ERUJVRykge1xuICAgICAgICAgICAgY29uc29sZS5sb2coXG4gICAgICAgICAgICAgICAgc3RhdGUuc3RlcCxcbiAgICAgICAgICAgICAgICAoc3RhdGUubG9vcCA+IDEgP1xuICAgICAgICAgICAgICAgICAgICdsb29wICcgKyAoc3RhdGUubG9vcCAtIGxvb3ApICsgJzogJyA6XG4gICAgICAgICAgICAgICAgICAgJydcbiAgICAgICAgICAgICAgICApICtcbiAgICAgICAgICAgICAgICAnU0hQWycgKyAoYSA/ICdycDEnIDogJ3JwMicpICsgJ10nLCBwaVxuICAgICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHN0YXRlLmxvb3AgPSAxO1xufVxuXG4vLyBTSENbXSBTSGlmdCBDb250b3VyIHVzaW5nIHJlZmVyZW5jZSBwb2ludFxuLy8gMHgzNi0weDM3XG5mdW5jdGlvbiBTSEMoYSwgc3RhdGUpIHtcbiAgICB2YXIgc3RhY2sgPSBzdGF0ZS5zdGFjaztcbiAgICB2YXIgcnBpID0gYSA/IHN0YXRlLnJwMSA6IHN0YXRlLnJwMjtcbiAgICB2YXIgcnAgPSAoYSA/IHN0YXRlLnowIDogc3RhdGUuejEpW3JwaV07XG4gICAgdmFyIGZ2ID0gc3RhdGUuZnY7XG4gICAgdmFyIHB2ID0gc3RhdGUucHY7XG4gICAgdmFyIGNpID0gc3RhY2sucG9wKCk7XG4gICAgdmFyIHNwID0gc3RhdGUuejJbc3RhdGUuY29udG91cnNbY2ldXTtcbiAgICB2YXIgcCA9IHNwO1xuXG4gICAgaWYgKGV4cG9ydHMuREVCVUcpIHsgY29uc29sZS5sb2coc3RhdGUuc3RlcCwgJ1NIQ1snICsgYSArICddJywgY2kpOyB9XG5cbiAgICB2YXIgZCA9IHB2LmRpc3RhbmNlKHJwLCBycCwgZmFsc2UsIHRydWUpO1xuXG4gICAgZG8ge1xuICAgICAgICBpZiAocCAhPT0gcnApIHsgZnYuc2V0UmVsYXRpdmUocCwgcCwgZCwgcHYpOyB9XG4gICAgICAgIHAgPSBwLm5leHRQb2ludE9uQ29udG91cjtcbiAgICB9IHdoaWxlIChwICE9PSBzcCk7XG59XG5cbi8vIFNIWltdIFNIaWZ0IFpvbmUgdXNpbmcgcmVmZXJlbmNlIHBvaW50XG4vLyAweDM2LTB4MzdcbmZ1bmN0aW9uIFNIWihhLCBzdGF0ZSkge1xuICAgIHZhciBzdGFjayA9IHN0YXRlLnN0YWNrO1xuICAgIHZhciBycGkgPSBhID8gc3RhdGUucnAxIDogc3RhdGUucnAyO1xuICAgIHZhciBycCA9IChhID8gc3RhdGUuejAgOiBzdGF0ZS56MSlbcnBpXTtcbiAgICB2YXIgZnYgPSBzdGF0ZS5mdjtcbiAgICB2YXIgcHYgPSBzdGF0ZS5wdjtcblxuICAgIHZhciBlID0gc3RhY2sucG9wKCk7XG5cbiAgICBpZiAoZXhwb3J0cy5ERUJVRykgeyBjb25zb2xlLmxvZyhzdGF0ZS5zdGVwLCAnU0haWycgKyBhICsgJ10nLCBlKTsgfVxuXG4gICAgdmFyIHo7XG4gICAgc3dpdGNoIChlKSB7XG4gICAgICAgIGNhc2UgMCA6IHogPSBzdGF0ZS50Wm9uZTsgYnJlYWs7XG4gICAgICAgIGNhc2UgMSA6IHogPSBzdGF0ZS5nWm9uZTsgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQgOiB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgem9uZScpO1xuICAgIH1cblxuICAgIHZhciBwO1xuICAgIHZhciBkID0gcHYuZGlzdGFuY2UocnAsIHJwLCBmYWxzZSwgdHJ1ZSk7XG4gICAgdmFyIHBMZW4gPSB6Lmxlbmd0aCAtIDI7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwTGVuOyBpKyspXG4gICAge1xuICAgICAgICBwID0geltpXTtcbiAgICAgICAgZnYuc2V0UmVsYXRpdmUocCwgcCwgZCwgcHYpO1xuICAgICAgICAvL2lmIChwICE9PSBycCkgZnYuc2V0UmVsYXRpdmUocCwgcCwgZCwgcHYpO1xuICAgIH1cbn1cblxuLy8gU0hQSVhbXSBTSGlmdCBwb2ludCBieSBhIFBJWGVsIGFtb3VudFxuLy8gMHgzOFxuZnVuY3Rpb24gU0hQSVgoc3RhdGUpIHtcbiAgICB2YXIgc3RhY2sgPSBzdGF0ZS5zdGFjaztcbiAgICB2YXIgbG9vcCA9IHN0YXRlLmxvb3A7XG4gICAgdmFyIGZ2ID0gc3RhdGUuZnY7XG4gICAgdmFyIGQgPSBzdGFjay5wb3AoKSAvIDB4NDA7XG4gICAgdmFyIHoyID0gc3RhdGUuejI7XG5cbiAgICB3aGlsZSAobG9vcC0tKSB7XG4gICAgICAgIHZhciBwaSA9IHN0YWNrLnBvcCgpO1xuICAgICAgICB2YXIgcCA9IHoyW3BpXTtcblxuICAgICAgICBpZiAoZXhwb3J0cy5ERUJVRykge1xuICAgICAgICAgICAgY29uc29sZS5sb2coXG4gICAgICAgICAgICAgICAgc3RhdGUuc3RlcCxcbiAgICAgICAgICAgICAgICAoc3RhdGUubG9vcCA+IDEgPyAnbG9vcCAnICsgKHN0YXRlLmxvb3AgLSBsb29wKSArICc6ICcgOiAnJykgK1xuICAgICAgICAgICAgICAgICdTSFBJWFtdJywgcGksIGRcbiAgICAgICAgICAgICk7XG4gICAgICAgIH1cblxuICAgICAgICBmdi5zZXRSZWxhdGl2ZShwLCBwLCBkKTtcbiAgICAgICAgZnYudG91Y2gocCk7XG4gICAgfVxuXG4gICAgc3RhdGUubG9vcCA9IDE7XG59XG5cbi8vIElQW10gSW50ZXJwb2xhdGUgUG9pbnRcbi8vIDB4MzlcbmZ1bmN0aW9uIElQKHN0YXRlKSB7XG4gICAgdmFyIHN0YWNrID0gc3RhdGUuc3RhY2s7XG4gICAgdmFyIHJwMWkgPSBzdGF0ZS5ycDE7XG4gICAgdmFyIHJwMmkgPSBzdGF0ZS5ycDI7XG4gICAgdmFyIGxvb3AgPSBzdGF0ZS5sb29wO1xuICAgIHZhciBycDEgPSBzdGF0ZS56MFtycDFpXTtcbiAgICB2YXIgcnAyID0gc3RhdGUuejFbcnAyaV07XG4gICAgdmFyIGZ2ID0gc3RhdGUuZnY7XG4gICAgdmFyIHB2ID0gc3RhdGUuZHB2O1xuICAgIHZhciB6MiA9IHN0YXRlLnoyO1xuXG4gICAgd2hpbGUgKGxvb3AtLSkge1xuICAgICAgICB2YXIgcGkgPSBzdGFjay5wb3AoKTtcbiAgICAgICAgdmFyIHAgPSB6MltwaV07XG5cbiAgICAgICAgaWYgKGV4cG9ydHMuREVCVUcpIHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKFxuICAgICAgICAgICAgICAgIHN0YXRlLnN0ZXAsXG4gICAgICAgICAgICAgICAgKHN0YXRlLmxvb3AgPiAxID8gJ2xvb3AgJyArIChzdGF0ZS5sb29wIC0gbG9vcCkgKyAnOiAnIDogJycpICtcbiAgICAgICAgICAgICAgICAnSVBbXScsIHBpLCBycDFpLCAnPC0+JywgcnAyaVxuICAgICAgICAgICAgKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZ2LmludGVycG9sYXRlKHAsIHJwMSwgcnAyLCBwdik7XG5cbiAgICAgICAgZnYudG91Y2gocCk7XG4gICAgfVxuXG4gICAgc3RhdGUubG9vcCA9IDE7XG59XG5cbi8vIE1TSVJQW2FdIE1vdmUgU3RhY2sgSW5kaXJlY3QgUmVsYXRpdmUgUG9pbnRcbi8vIDB4M0EtMHgzQlxuZnVuY3Rpb24gTVNJUlAoYSwgc3RhdGUpIHtcbiAgICB2YXIgc3RhY2sgPSBzdGF0ZS5zdGFjaztcbiAgICB2YXIgZCA9IHN0YWNrLnBvcCgpIC8gNjQ7XG4gICAgdmFyIHBpID0gc3RhY2sucG9wKCk7XG4gICAgdmFyIHAgPSBzdGF0ZS56MVtwaV07XG4gICAgdmFyIHJwMCA9IHN0YXRlLnowW3N0YXRlLnJwMF07XG4gICAgdmFyIGZ2ID0gc3RhdGUuZnY7XG4gICAgdmFyIHB2ID0gc3RhdGUucHY7XG5cbiAgICBmdi5zZXRSZWxhdGl2ZShwLCBycDAsIGQsIHB2KTtcbiAgICBmdi50b3VjaChwKTtcblxuICAgIGlmIChleHBvcnRzLkRFQlVHKSB7IGNvbnNvbGUubG9nKHN0YXRlLnN0ZXAsICdNU0lSUFsnICsgYSArICddJywgZCwgcGkpOyB9XG5cbiAgICBzdGF0ZS5ycDEgPSBzdGF0ZS5ycDA7XG4gICAgc3RhdGUucnAyID0gcGk7XG4gICAgaWYgKGEpIHsgc3RhdGUucnAwID0gcGk7IH1cbn1cblxuLy8gQUxJR05SUFtdIEFsaWduIHRvIHJlZmVyZW5jZSBwb2ludC5cbi8vIDB4M0NcbmZ1bmN0aW9uIEFMSUdOUlAoc3RhdGUpIHtcbiAgICB2YXIgc3RhY2sgPSBzdGF0ZS5zdGFjaztcbiAgICB2YXIgcnAwaSA9IHN0YXRlLnJwMDtcbiAgICB2YXIgcnAwID0gc3RhdGUuejBbcnAwaV07XG4gICAgdmFyIGxvb3AgPSBzdGF0ZS5sb29wO1xuICAgIHZhciBmdiA9IHN0YXRlLmZ2O1xuICAgIHZhciBwdiA9IHN0YXRlLnB2O1xuICAgIHZhciB6MSA9IHN0YXRlLnoxO1xuXG4gICAgd2hpbGUgKGxvb3AtLSkge1xuICAgICAgICB2YXIgcGkgPSBzdGFjay5wb3AoKTtcbiAgICAgICAgdmFyIHAgPSB6MVtwaV07XG5cbiAgICAgICAgaWYgKGV4cG9ydHMuREVCVUcpIHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKFxuICAgICAgICAgICAgICAgIHN0YXRlLnN0ZXAsXG4gICAgICAgICAgICAgICAgKHN0YXRlLmxvb3AgPiAxID8gJ2xvb3AgJyArIChzdGF0ZS5sb29wIC0gbG9vcCkgKyAnOiAnIDogJycpICtcbiAgICAgICAgICAgICAgICAnQUxJR05SUFtdJywgcGlcbiAgICAgICAgICAgICk7XG4gICAgICAgIH1cblxuICAgICAgICBmdi5zZXRSZWxhdGl2ZShwLCBycDAsIDAsIHB2KTtcbiAgICAgICAgZnYudG91Y2gocCk7XG4gICAgfVxuXG4gICAgc3RhdGUubG9vcCA9IDE7XG59XG5cbi8vIFJUR1tdIFJvdW5kIFRvIERvdWJsZSBHcmlkXG4vLyAweDNEXG5mdW5jdGlvbiBSVERHKHN0YXRlKSB7XG4gICAgaWYgKGV4cG9ydHMuREVCVUcpIHsgY29uc29sZS5sb2coc3RhdGUuc3RlcCwgJ1JUREdbXScpOyB9XG5cbiAgICBzdGF0ZS5yb3VuZCA9IHJvdW5kVG9Eb3VibGVHcmlkO1xufVxuXG4vLyBNSUFQW2FdIE1vdmUgSW5kaXJlY3QgQWJzb2x1dGUgUG9pbnRcbi8vIDB4M0UtMHgzRlxuZnVuY3Rpb24gTUlBUChyb3VuZCwgc3RhdGUpIHtcbiAgICB2YXIgc3RhY2sgPSBzdGF0ZS5zdGFjaztcbiAgICB2YXIgbiA9IHN0YWNrLnBvcCgpO1xuICAgIHZhciBwaSA9IHN0YWNrLnBvcCgpO1xuICAgIHZhciBwID0gc3RhdGUuejBbcGldO1xuICAgIHZhciBmdiA9IHN0YXRlLmZ2O1xuICAgIHZhciBwdiA9IHN0YXRlLnB2O1xuICAgIHZhciBjdiA9IHN0YXRlLmN2dFtuXTtcblxuICAgIGlmIChleHBvcnRzLkRFQlVHKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKFxuICAgICAgICAgICAgc3RhdGUuc3RlcCxcbiAgICAgICAgICAgICdNSUFQWycgKyByb3VuZCArICddJyxcbiAgICAgICAgICAgIG4sICcoJywgY3YsICcpJywgcGlcbiAgICAgICAgKTtcbiAgICB9XG5cbiAgICB2YXIgZCA9IHB2LmRpc3RhbmNlKHAsIEhQWmVybyk7XG5cbiAgICBpZiAocm91bmQpIHtcbiAgICAgICAgaWYgKE1hdGguYWJzKGQgLSBjdikgPCBzdGF0ZS5jdkN1dEluKSB7IGQgPSBjdjsgfVxuXG4gICAgICAgIGQgPSBzdGF0ZS5yb3VuZChkKTtcbiAgICB9XG5cbiAgICBmdi5zZXRSZWxhdGl2ZShwLCBIUFplcm8sIGQsIHB2KTtcblxuICAgIGlmIChzdGF0ZS56cDAgPT09IDApIHtcbiAgICAgICAgcC54byA9IHAueDtcbiAgICAgICAgcC55byA9IHAueTtcbiAgICB9XG5cbiAgICBmdi50b3VjaChwKTtcblxuICAgIHN0YXRlLnJwMCA9IHN0YXRlLnJwMSA9IHBpO1xufVxuXG4vLyBOUFVTQltdIFBVU0ggTiBCeXRlc1xuLy8gMHg0MFxuZnVuY3Rpb24gTlBVU0hCKHN0YXRlKSB7XG4gICAgdmFyIHByb2cgPSBzdGF0ZS5wcm9nO1xuICAgIHZhciBpcCA9IHN0YXRlLmlwO1xuICAgIHZhciBzdGFjayA9IHN0YXRlLnN0YWNrO1xuXG4gICAgdmFyIG4gPSBwcm9nWysraXBdO1xuXG4gICAgaWYgKGV4cG9ydHMuREVCVUcpIHsgY29uc29sZS5sb2coc3RhdGUuc3RlcCwgJ05QVVNIQltdJywgbik7IH1cblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbjsgaSsrKSB7IHN0YWNrLnB1c2gocHJvZ1srK2lwXSk7IH1cblxuICAgIHN0YXRlLmlwID0gaXA7XG59XG5cbi8vIE5QVVNIV1tdIFBVU0ggTiBXb3Jkc1xuLy8gMHg0MVxuZnVuY3Rpb24gTlBVU0hXKHN0YXRlKSB7XG4gICAgdmFyIGlwID0gc3RhdGUuaXA7XG4gICAgdmFyIHByb2cgPSBzdGF0ZS5wcm9nO1xuICAgIHZhciBzdGFjayA9IHN0YXRlLnN0YWNrO1xuICAgIHZhciBuID0gcHJvZ1srK2lwXTtcblxuICAgIGlmIChleHBvcnRzLkRFQlVHKSB7IGNvbnNvbGUubG9nKHN0YXRlLnN0ZXAsICdOUFVTSFdbXScsIG4pOyB9XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG47IGkrKykge1xuICAgICAgICB2YXIgdyA9IChwcm9nWysraXBdIDw8IDgpIHwgcHJvZ1srK2lwXTtcbiAgICAgICAgaWYgKHcgJiAweDgwMDApIHsgdyA9IC0oKHcgXiAweGZmZmYpICsgMSk7IH1cbiAgICAgICAgc3RhY2sucHVzaCh3KTtcbiAgICB9XG5cbiAgICBzdGF0ZS5pcCA9IGlwO1xufVxuXG4vLyBXU1tdIFdyaXRlIFN0b3JlXG4vLyAweDQyXG5mdW5jdGlvbiBXUyhzdGF0ZSkge1xuICAgIHZhciBzdGFjayA9IHN0YXRlLnN0YWNrO1xuICAgIHZhciBzdG9yZSA9IHN0YXRlLnN0b3JlO1xuXG4gICAgaWYgKCFzdG9yZSkgeyBzdG9yZSA9IHN0YXRlLnN0b3JlID0gW107IH1cblxuICAgIHZhciB2ID0gc3RhY2sucG9wKCk7XG4gICAgdmFyIGwgPSBzdGFjay5wb3AoKTtcblxuICAgIGlmIChleHBvcnRzLkRFQlVHKSB7IGNvbnNvbGUubG9nKHN0YXRlLnN0ZXAsICdXUycsIHYsIGwpOyB9XG5cbiAgICBzdG9yZVtsXSA9IHY7XG59XG5cbi8vIFJTW10gUmVhZCBTdG9yZVxuLy8gMHg0M1xuZnVuY3Rpb24gUlMoc3RhdGUpIHtcbiAgICB2YXIgc3RhY2sgPSBzdGF0ZS5zdGFjaztcbiAgICB2YXIgc3RvcmUgPSBzdGF0ZS5zdG9yZTtcblxuICAgIHZhciBsID0gc3RhY2sucG9wKCk7XG5cbiAgICBpZiAoZXhwb3J0cy5ERUJVRykgeyBjb25zb2xlLmxvZyhzdGF0ZS5zdGVwLCAnUlMnLCBsKTsgfVxuXG4gICAgdmFyIHYgPSAoc3RvcmUgJiYgc3RvcmVbbF0pIHx8IDA7XG5cbiAgICBzdGFjay5wdXNoKHYpO1xufVxuXG4vLyBXQ1ZUUFtdIFdyaXRlIENvbnRyb2wgVmFsdWUgVGFibGUgaW4gUGl4ZWwgdW5pdHNcbi8vIDB4NDRcbmZ1bmN0aW9uIFdDVlRQKHN0YXRlKSB7XG4gICAgdmFyIHN0YWNrID0gc3RhdGUuc3RhY2s7XG5cbiAgICB2YXIgdiA9IHN0YWNrLnBvcCgpO1xuICAgIHZhciBsID0gc3RhY2sucG9wKCk7XG5cbiAgICBpZiAoZXhwb3J0cy5ERUJVRykgeyBjb25zb2xlLmxvZyhzdGF0ZS5zdGVwLCAnV0NWVFAnLCB2LCBsKTsgfVxuXG4gICAgc3RhdGUuY3Z0W2xdID0gdiAvIDB4NDA7XG59XG5cbi8vIFJDVlRbXSBSZWFkIENvbnRyb2wgVmFsdWUgVGFibGUgZW50cnlcbi8vIDB4NDVcbmZ1bmN0aW9uIFJDVlQoc3RhdGUpIHtcbiAgICB2YXIgc3RhY2sgPSBzdGF0ZS5zdGFjaztcbiAgICB2YXIgY3Z0ZSA9IHN0YWNrLnBvcCgpO1xuXG4gICAgaWYgKGV4cG9ydHMuREVCVUcpIHsgY29uc29sZS5sb2coc3RhdGUuc3RlcCwgJ1JDVlQnLCBjdnRlKTsgfVxuXG4gICAgc3RhY2sucHVzaChzdGF0ZS5jdnRbY3Z0ZV0gKiAweDQwKTtcbn1cblxuLy8gR0NbXSBHZXQgQ29vcmRpbmF0ZSBwcm9qZWN0ZWQgb250byB0aGUgcHJvamVjdGlvbiB2ZWN0b3Jcbi8vIDB4NDYtMHg0N1xuZnVuY3Rpb24gR0MoYSwgc3RhdGUpIHtcbiAgICB2YXIgc3RhY2sgPSBzdGF0ZS5zdGFjaztcbiAgICB2YXIgcGkgPSBzdGFjay5wb3AoKTtcbiAgICB2YXIgcCA9IHN0YXRlLnoyW3BpXTtcblxuICAgIGlmIChleHBvcnRzLkRFQlVHKSB7IGNvbnNvbGUubG9nKHN0YXRlLnN0ZXAsICdHQ1snICsgYSArICddJywgcGkpOyB9XG5cbiAgICBzdGFjay5wdXNoKHN0YXRlLmRwdi5kaXN0YW5jZShwLCBIUFplcm8sIGEsIGZhbHNlKSAqIDB4NDApO1xufVxuXG4vLyBNRFthXSBNZWFzdXJlIERpc3RhbmNlXG4vLyAweDQ5LTB4NEFcbmZ1bmN0aW9uIE1EKGEsIHN0YXRlKSB7XG4gICAgdmFyIHN0YWNrID0gc3RhdGUuc3RhY2s7XG4gICAgdmFyIHBpMiA9IHN0YWNrLnBvcCgpO1xuICAgIHZhciBwaTEgPSBzdGFjay5wb3AoKTtcbiAgICB2YXIgcDIgPSBzdGF0ZS56MVtwaTJdO1xuICAgIHZhciBwMSA9IHN0YXRlLnowW3BpMV07XG4gICAgdmFyIGQgPSBzdGF0ZS5kcHYuZGlzdGFuY2UocDEsIHAyLCBhLCBhKTtcblxuICAgIGlmIChleHBvcnRzLkRFQlVHKSB7IGNvbnNvbGUubG9nKHN0YXRlLnN0ZXAsICdNRFsnICsgYSArICddJywgcGkyLCBwaTEsICctPicsIGQpOyB9XG5cbiAgICBzdGF0ZS5zdGFjay5wdXNoKE1hdGgucm91bmQoZCAqIDY0KSk7XG59XG5cbi8vIE1QUEVNW10gTWVhc3VyZSBQaXhlbHMgUGVyIEVNXG4vLyAweDRCXG5mdW5jdGlvbiBNUFBFTShzdGF0ZSkge1xuICAgIGlmIChleHBvcnRzLkRFQlVHKSB7IGNvbnNvbGUubG9nKHN0YXRlLnN0ZXAsICdNUFBFTVtdJyk7IH1cbiAgICBzdGF0ZS5zdGFjay5wdXNoKHN0YXRlLnBwZW0pO1xufVxuXG4vLyBGTElQT05bXSBzZXQgdGhlIGF1dG8gRkxJUCBCb29sZWFuIHRvIE9OXG4vLyAweDREXG5mdW5jdGlvbiBGTElQT04oc3RhdGUpIHtcbiAgICBpZiAoZXhwb3J0cy5ERUJVRykgeyBjb25zb2xlLmxvZyhzdGF0ZS5zdGVwLCAnRkxJUE9OW10nKTsgfVxuICAgIHN0YXRlLmF1dG9GbGlwID0gdHJ1ZTtcbn1cblxuLy8gTFRbXSBMZXNzIFRoYW5cbi8vIDB4NTBcbmZ1bmN0aW9uIExUKHN0YXRlKSB7XG4gICAgdmFyIHN0YWNrID0gc3RhdGUuc3RhY2s7XG4gICAgdmFyIGUyID0gc3RhY2sucG9wKCk7XG4gICAgdmFyIGUxID0gc3RhY2sucG9wKCk7XG5cbiAgICBpZiAoZXhwb3J0cy5ERUJVRykgeyBjb25zb2xlLmxvZyhzdGF0ZS5zdGVwLCAnTFRbXScsIGUyLCBlMSk7IH1cblxuICAgIHN0YWNrLnB1c2goZTEgPCBlMiA/IDEgOiAwKTtcbn1cblxuLy8gTFRFUVtdIExlc3MgVGhhbiBvciBFUXVhbFxuLy8gMHg1M1xuZnVuY3Rpb24gTFRFUShzdGF0ZSkge1xuICAgIHZhciBzdGFjayA9IHN0YXRlLnN0YWNrO1xuICAgIHZhciBlMiA9IHN0YWNrLnBvcCgpO1xuICAgIHZhciBlMSA9IHN0YWNrLnBvcCgpO1xuXG4gICAgaWYgKGV4cG9ydHMuREVCVUcpIHsgY29uc29sZS5sb2coc3RhdGUuc3RlcCwgJ0xURVFbXScsIGUyLCBlMSk7IH1cblxuICAgIHN0YWNrLnB1c2goZTEgPD0gZTIgPyAxIDogMCk7XG59XG5cbi8vIEdURVFbXSBHcmVhdGVyIFRoYW5cbi8vIDB4NTJcbmZ1bmN0aW9uIEdUKHN0YXRlKSB7XG4gICAgdmFyIHN0YWNrID0gc3RhdGUuc3RhY2s7XG4gICAgdmFyIGUyID0gc3RhY2sucG9wKCk7XG4gICAgdmFyIGUxID0gc3RhY2sucG9wKCk7XG5cbiAgICBpZiAoZXhwb3J0cy5ERUJVRykgeyBjb25zb2xlLmxvZyhzdGF0ZS5zdGVwLCAnR1RbXScsIGUyLCBlMSk7IH1cblxuICAgIHN0YWNrLnB1c2goZTEgPiBlMiA/IDEgOiAwKTtcbn1cblxuLy8gR1RFUVtdIEdyZWF0ZXIgVGhhbiBvciBFUXVhbFxuLy8gMHg1M1xuZnVuY3Rpb24gR1RFUShzdGF0ZSkge1xuICAgIHZhciBzdGFjayA9IHN0YXRlLnN0YWNrO1xuICAgIHZhciBlMiA9IHN0YWNrLnBvcCgpO1xuICAgIHZhciBlMSA9IHN0YWNrLnBvcCgpO1xuXG4gICAgaWYgKGV4cG9ydHMuREVCVUcpIHsgY29uc29sZS5sb2coc3RhdGUuc3RlcCwgJ0dURVFbXScsIGUyLCBlMSk7IH1cblxuICAgIHN0YWNrLnB1c2goZTEgPj0gZTIgPyAxIDogMCk7XG59XG5cbi8vIEVRW10gRVF1YWxcbi8vIDB4NTRcbmZ1bmN0aW9uIEVRKHN0YXRlKSB7XG4gICAgdmFyIHN0YWNrID0gc3RhdGUuc3RhY2s7XG4gICAgdmFyIGUyID0gc3RhY2sucG9wKCk7XG4gICAgdmFyIGUxID0gc3RhY2sucG9wKCk7XG5cbiAgICBpZiAoZXhwb3J0cy5ERUJVRykgeyBjb25zb2xlLmxvZyhzdGF0ZS5zdGVwLCAnRVFbXScsIGUyLCBlMSk7IH1cblxuICAgIHN0YWNrLnB1c2goZTIgPT09IGUxID8gMSA6IDApO1xufVxuXG4vLyBORVFbXSBOb3QgRVF1YWxcbi8vIDB4NTVcbmZ1bmN0aW9uIE5FUShzdGF0ZSkge1xuICAgIHZhciBzdGFjayA9IHN0YXRlLnN0YWNrO1xuICAgIHZhciBlMiA9IHN0YWNrLnBvcCgpO1xuICAgIHZhciBlMSA9IHN0YWNrLnBvcCgpO1xuXG4gICAgaWYgKGV4cG9ydHMuREVCVUcpIHsgY29uc29sZS5sb2coc3RhdGUuc3RlcCwgJ05FUVtdJywgZTIsIGUxKTsgfVxuXG4gICAgc3RhY2sucHVzaChlMiAhPT0gZTEgPyAxIDogMCk7XG59XG5cbi8vIE9ERFtdIE9ERFxuLy8gMHg1NlxuZnVuY3Rpb24gT0REKHN0YXRlKSB7XG4gICAgdmFyIHN0YWNrID0gc3RhdGUuc3RhY2s7XG4gICAgdmFyIG4gPSBzdGFjay5wb3AoKTtcblxuICAgIGlmIChleHBvcnRzLkRFQlVHKSB7IGNvbnNvbGUubG9nKHN0YXRlLnN0ZXAsICdPRERbXScsIG4pOyB9XG5cbiAgICBzdGFjay5wdXNoKE1hdGgudHJ1bmMobikgJSAyID8gMSA6IDApO1xufVxuXG4vLyBFVkVOW10gRVZFTlxuLy8gMHg1N1xuZnVuY3Rpb24gRVZFTihzdGF0ZSkge1xuICAgIHZhciBzdGFjayA9IHN0YXRlLnN0YWNrO1xuICAgIHZhciBuID0gc3RhY2sucG9wKCk7XG5cbiAgICBpZiAoZXhwb3J0cy5ERUJVRykgeyBjb25zb2xlLmxvZyhzdGF0ZS5zdGVwLCAnRVZFTltdJywgbik7IH1cblxuICAgIHN0YWNrLnB1c2goTWF0aC50cnVuYyhuKSAlIDIgPyAwIDogMSk7XG59XG5cbi8vIElGW10gSUYgdGVzdFxuLy8gMHg1OFxuZnVuY3Rpb24gSUYoc3RhdGUpIHtcbiAgICB2YXIgdGVzdCA9IHN0YXRlLnN0YWNrLnBvcCgpO1xuXG4gICAgaWYgKGV4cG9ydHMuREVCVUcpIHsgY29uc29sZS5sb2coc3RhdGUuc3RlcCwgJ0lGW10nLCB0ZXN0KTsgfVxuXG4gICAgLy8gaWYgdGVzdCBpcyB0cnVlIGl0IGp1c3QgY29udGludWVzXG4gICAgLy8gaWYgbm90IHRoZSBpcCBpcyBza2lwcGVkIHVudGlsIG1hdGNoaW5nIEVMU0Ugb3IgRUlGXG4gICAgaWYgKCF0ZXN0KSB7XG4gICAgICAgIHNraXAoc3RhdGUsIHRydWUpO1xuXG4gICAgICAgIGlmIChleHBvcnRzLkRFQlVHKSB7IGNvbnNvbGUubG9nKHN0YXRlLnN0ZXAsICAnRUlGW10nKTsgfVxuICAgIH1cbn1cblxuLy8gRUlGW10gRW5kIElGXG4vLyAweDU5XG5mdW5jdGlvbiBFSUYoc3RhdGUpIHtcbiAgICAvLyB0aGlzIGNhbiBiZSByZWFjaGVkIG5vcm1hbGx5IHdoZW5cbiAgICAvLyBleGVjdXRpbmcgYW4gZWxzZSBicmFuY2guXG4gICAgLy8gLT4ganVzdCBpZ25vcmUgaXRcblxuICAgIGlmIChleHBvcnRzLkRFQlVHKSB7IGNvbnNvbGUubG9nKHN0YXRlLnN0ZXAsICdFSUZbXScpOyB9XG59XG5cbi8vIEFORFtdIGxvZ2ljYWwgQU5EXG4vLyAweDVBXG5mdW5jdGlvbiBBTkQoc3RhdGUpIHtcbiAgICB2YXIgc3RhY2sgPSBzdGF0ZS5zdGFjaztcbiAgICB2YXIgZTIgPSBzdGFjay5wb3AoKTtcbiAgICB2YXIgZTEgPSBzdGFjay5wb3AoKTtcblxuICAgIGlmIChleHBvcnRzLkRFQlVHKSB7IGNvbnNvbGUubG9nKHN0YXRlLnN0ZXAsICdBTkRbXScsIGUyLCBlMSk7IH1cblxuICAgIHN0YWNrLnB1c2goZTIgJiYgZTEgPyAxIDogMCk7XG59XG5cbi8vIE9SW10gbG9naWNhbCBPUlxuLy8gMHg1QlxuZnVuY3Rpb24gT1Ioc3RhdGUpIHtcbiAgICB2YXIgc3RhY2sgPSBzdGF0ZS5zdGFjaztcbiAgICB2YXIgZTIgPSBzdGFjay5wb3AoKTtcbiAgICB2YXIgZTEgPSBzdGFjay5wb3AoKTtcblxuICAgIGlmIChleHBvcnRzLkRFQlVHKSB7IGNvbnNvbGUubG9nKHN0YXRlLnN0ZXAsICdPUltdJywgZTIsIGUxKTsgfVxuXG4gICAgc3RhY2sucHVzaChlMiB8fCBlMSA/IDEgOiAwKTtcbn1cblxuLy8gTk9UW10gbG9naWNhbCBOT1Rcbi8vIDB4NUNcbmZ1bmN0aW9uIE5PVChzdGF0ZSkge1xuICAgIHZhciBzdGFjayA9IHN0YXRlLnN0YWNrO1xuICAgIHZhciBlID0gc3RhY2sucG9wKCk7XG5cbiAgICBpZiAoZXhwb3J0cy5ERUJVRykgeyBjb25zb2xlLmxvZyhzdGF0ZS5zdGVwLCAnTk9UW10nLCBlKTsgfVxuXG4gICAgc3RhY2sucHVzaChlID8gMCA6IDEpO1xufVxuXG4vLyBERUxUQVAxW10gREVMVEEgZXhjZXB0aW9uIFAxXG4vLyBERUxUQVAyW10gREVMVEEgZXhjZXB0aW9uIFAyXG4vLyBERUxUQVAzW10gREVMVEEgZXhjZXB0aW9uIFAzXG4vLyAweDVELCAweDcxLCAweDcyXG5mdW5jdGlvbiBERUxUQVAxMjMoYiwgc3RhdGUpIHtcbiAgICB2YXIgc3RhY2sgPSBzdGF0ZS5zdGFjaztcbiAgICB2YXIgbiA9IHN0YWNrLnBvcCgpO1xuICAgIHZhciBmdiA9IHN0YXRlLmZ2O1xuICAgIHZhciBwdiA9IHN0YXRlLnB2O1xuICAgIHZhciBwcGVtID0gc3RhdGUucHBlbTtcbiAgICB2YXIgYmFzZSA9IHN0YXRlLmRlbHRhQmFzZSArIChiIC0gMSkgKiAxNjtcbiAgICB2YXIgZHMgPSBzdGF0ZS5kZWx0YVNoaWZ0O1xuICAgIHZhciB6MCA9IHN0YXRlLnowO1xuXG4gICAgaWYgKGV4cG9ydHMuREVCVUcpIHsgY29uc29sZS5sb2coc3RhdGUuc3RlcCwgJ0RFTFRBUFsnICsgYiArICddJywgbiwgc3RhY2spOyB9XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG47IGkrKykge1xuICAgICAgICB2YXIgcGkgPSBzdGFjay5wb3AoKTtcbiAgICAgICAgdmFyIGFyZyA9IHN0YWNrLnBvcCgpO1xuICAgICAgICB2YXIgYXBwZW0gPSBiYXNlICsgKChhcmcgJiAweEYwKSA+PiA0KTtcbiAgICAgICAgaWYgKGFwcGVtICE9PSBwcGVtKSB7IGNvbnRpbnVlOyB9XG5cbiAgICAgICAgdmFyIG1hZyA9IChhcmcgJiAweDBGKSAtIDg7XG4gICAgICAgIGlmIChtYWcgPj0gMCkgeyBtYWcrKzsgfVxuICAgICAgICBpZiAoZXhwb3J0cy5ERUJVRykgeyBjb25zb2xlLmxvZyhzdGF0ZS5zdGVwLCAnREVMVEFQRklYJywgcGksICdieScsIG1hZyAqIGRzKTsgfVxuXG4gICAgICAgIHZhciBwID0gejBbcGldO1xuICAgICAgICBmdi5zZXRSZWxhdGl2ZShwLCBwLCBtYWcgKiBkcywgcHYpO1xuICAgIH1cbn1cblxuLy8gU0RCW10gU2V0IERlbHRhIEJhc2UgaW4gdGhlIGdyYXBoaWNzIHN0YXRlXG4vLyAweDVFXG5mdW5jdGlvbiBTREIoc3RhdGUpIHtcbiAgICB2YXIgc3RhY2sgPSBzdGF0ZS5zdGFjaztcbiAgICB2YXIgbiA9IHN0YWNrLnBvcCgpO1xuXG4gICAgaWYgKGV4cG9ydHMuREVCVUcpIHsgY29uc29sZS5sb2coc3RhdGUuc3RlcCwgJ1NEQltdJywgbik7IH1cblxuICAgIHN0YXRlLmRlbHRhQmFzZSA9IG47XG59XG5cbi8vIFNEU1tdIFNldCBEZWx0YSBTaGlmdCBpbiB0aGUgZ3JhcGhpY3Mgc3RhdGVcbi8vIDB4NUZcbmZ1bmN0aW9uIFNEUyhzdGF0ZSkge1xuICAgIHZhciBzdGFjayA9IHN0YXRlLnN0YWNrO1xuICAgIHZhciBuID0gc3RhY2sucG9wKCk7XG5cbiAgICBpZiAoZXhwb3J0cy5ERUJVRykgeyBjb25zb2xlLmxvZyhzdGF0ZS5zdGVwLCAnU0RTW10nLCBuKTsgfVxuXG4gICAgc3RhdGUuZGVsdGFTaGlmdCA9IE1hdGgucG93KDAuNSwgbik7XG59XG5cbi8vIEFERFtdIEFERFxuLy8gMHg2MFxuZnVuY3Rpb24gQUREKHN0YXRlKSB7XG4gICAgdmFyIHN0YWNrID0gc3RhdGUuc3RhY2s7XG4gICAgdmFyIG4yID0gc3RhY2sucG9wKCk7XG4gICAgdmFyIG4xID0gc3RhY2sucG9wKCk7XG5cbiAgICBpZiAoZXhwb3J0cy5ERUJVRykgeyBjb25zb2xlLmxvZyhzdGF0ZS5zdGVwLCAnQUREW10nLCBuMiwgbjEpOyB9XG5cbiAgICBzdGFjay5wdXNoKG4xICsgbjIpO1xufVxuXG4vLyBTVUJbXSBTVUJcbi8vIDB4NjFcbmZ1bmN0aW9uIFNVQihzdGF0ZSkge1xuICAgIHZhciBzdGFjayA9IHN0YXRlLnN0YWNrO1xuICAgIHZhciBuMiA9IHN0YWNrLnBvcCgpO1xuICAgIHZhciBuMSA9IHN0YWNrLnBvcCgpO1xuXG4gICAgaWYgKGV4cG9ydHMuREVCVUcpIHsgY29uc29sZS5sb2coc3RhdGUuc3RlcCwgJ1NVQltdJywgbjIsIG4xKTsgfVxuXG4gICAgc3RhY2sucHVzaChuMSAtIG4yKTtcbn1cblxuLy8gRElWW10gRElWXG4vLyAweDYyXG5mdW5jdGlvbiBESVYoc3RhdGUpIHtcbiAgICB2YXIgc3RhY2sgPSBzdGF0ZS5zdGFjaztcbiAgICB2YXIgbjIgPSBzdGFjay5wb3AoKTtcbiAgICB2YXIgbjEgPSBzdGFjay5wb3AoKTtcblxuICAgIGlmIChleHBvcnRzLkRFQlVHKSB7IGNvbnNvbGUubG9nKHN0YXRlLnN0ZXAsICdESVZbXScsIG4yLCBuMSk7IH1cblxuICAgIHN0YWNrLnB1c2gobjEgKiA2NCAvIG4yKTtcbn1cblxuLy8gTVVMW10gTVVMXG4vLyAweDYzXG5mdW5jdGlvbiBNVUwoc3RhdGUpIHtcbiAgICB2YXIgc3RhY2sgPSBzdGF0ZS5zdGFjaztcbiAgICB2YXIgbjIgPSBzdGFjay5wb3AoKTtcbiAgICB2YXIgbjEgPSBzdGFjay5wb3AoKTtcblxuICAgIGlmIChleHBvcnRzLkRFQlVHKSB7IGNvbnNvbGUubG9nKHN0YXRlLnN0ZXAsICdNVUxbXScsIG4yLCBuMSk7IH1cblxuICAgIHN0YWNrLnB1c2gobjEgKiBuMiAvIDY0KTtcbn1cblxuLy8gQUJTW10gQUJTb2x1dGUgdmFsdWVcbi8vIDB4NjRcbmZ1bmN0aW9uIEFCUyhzdGF0ZSkge1xuICAgIHZhciBzdGFjayA9IHN0YXRlLnN0YWNrO1xuICAgIHZhciBuID0gc3RhY2sucG9wKCk7XG5cbiAgICBpZiAoZXhwb3J0cy5ERUJVRykgeyBjb25zb2xlLmxvZyhzdGF0ZS5zdGVwLCAnQUJTW10nLCBuKTsgfVxuXG4gICAgc3RhY2sucHVzaChNYXRoLmFicyhuKSk7XG59XG5cbi8vIE5FR1tdIE5FR2F0ZVxuLy8gMHg2NVxuZnVuY3Rpb24gTkVHKHN0YXRlKSB7XG4gICAgdmFyIHN0YWNrID0gc3RhdGUuc3RhY2s7XG4gICAgdmFyIG4gPSBzdGFjay5wb3AoKTtcblxuICAgIGlmIChleHBvcnRzLkRFQlVHKSB7IGNvbnNvbGUubG9nKHN0YXRlLnN0ZXAsICdORUdbXScsIG4pOyB9XG5cbiAgICBzdGFjay5wdXNoKC1uKTtcbn1cblxuLy8gRkxPT1JbXSBGTE9PUlxuLy8gMHg2NlxuZnVuY3Rpb24gRkxPT1Ioc3RhdGUpIHtcbiAgICB2YXIgc3RhY2sgPSBzdGF0ZS5zdGFjaztcbiAgICB2YXIgbiA9IHN0YWNrLnBvcCgpO1xuXG4gICAgaWYgKGV4cG9ydHMuREVCVUcpIHsgY29uc29sZS5sb2coc3RhdGUuc3RlcCwgJ0ZMT09SW10nLCBuKTsgfVxuXG4gICAgc3RhY2sucHVzaChNYXRoLmZsb29yKG4gLyAweDQwKSAqIDB4NDApO1xufVxuXG4vLyBDRUlMSU5HW10gQ0VJTElOR1xuLy8gMHg2N1xuZnVuY3Rpb24gQ0VJTElORyhzdGF0ZSkge1xuICAgIHZhciBzdGFjayA9IHN0YXRlLnN0YWNrO1xuICAgIHZhciBuID0gc3RhY2sucG9wKCk7XG5cbiAgICBpZiAoZXhwb3J0cy5ERUJVRykgeyBjb25zb2xlLmxvZyhzdGF0ZS5zdGVwLCAnQ0VJTElOR1tdJywgbik7IH1cblxuICAgIHN0YWNrLnB1c2goTWF0aC5jZWlsKG4gLyAweDQwKSAqIDB4NDApO1xufVxuXG4vLyBST1VORFthYl0gUk9VTkQgdmFsdWVcbi8vIDB4NjgtMHg2QlxuZnVuY3Rpb24gUk9VTkQoZHQsIHN0YXRlKSB7XG4gICAgdmFyIHN0YWNrID0gc3RhdGUuc3RhY2s7XG4gICAgdmFyIG4gPSBzdGFjay5wb3AoKTtcblxuICAgIGlmIChleHBvcnRzLkRFQlVHKSB7IGNvbnNvbGUubG9nKHN0YXRlLnN0ZXAsICdST1VORFtdJyk7IH1cblxuICAgIHN0YWNrLnB1c2goc3RhdGUucm91bmQobiAvIDB4NDApICogMHg0MCk7XG59XG5cbi8vIFdDVlRGW10gV3JpdGUgQ29udHJvbCBWYWx1ZSBUYWJsZSBpbiBGdW5pdHNcbi8vIDB4NzBcbmZ1bmN0aW9uIFdDVlRGKHN0YXRlKSB7XG4gICAgdmFyIHN0YWNrID0gc3RhdGUuc3RhY2s7XG4gICAgdmFyIHYgPSBzdGFjay5wb3AoKTtcbiAgICB2YXIgbCA9IHN0YWNrLnBvcCgpO1xuXG4gICAgaWYgKGV4cG9ydHMuREVCVUcpIHsgY29uc29sZS5sb2coc3RhdGUuc3RlcCwgJ1dDVlRGW10nLCB2LCBsKTsgfVxuXG4gICAgc3RhdGUuY3Z0W2xdID0gdiAqIHN0YXRlLnBwZW0gLyBzdGF0ZS5mb250LnVuaXRzUGVyRW07XG59XG5cbi8vIERFTFRBQzFbXSBERUxUQSBleGNlcHRpb24gQzFcbi8vIERFTFRBQzJbXSBERUxUQSBleGNlcHRpb24gQzJcbi8vIERFTFRBQzNbXSBERUxUQSBleGNlcHRpb24gQzNcbi8vIDB4NzMsIDB4NzQsIDB4NzVcbmZ1bmN0aW9uIERFTFRBQzEyMyhiLCBzdGF0ZSkge1xuICAgIHZhciBzdGFjayA9IHN0YXRlLnN0YWNrO1xuICAgIHZhciBuID0gc3RhY2sucG9wKCk7XG4gICAgdmFyIHBwZW0gPSBzdGF0ZS5wcGVtO1xuICAgIHZhciBiYXNlID0gc3RhdGUuZGVsdGFCYXNlICsgKGIgLSAxKSAqIDE2O1xuICAgIHZhciBkcyA9IHN0YXRlLmRlbHRhU2hpZnQ7XG5cbiAgICBpZiAoZXhwb3J0cy5ERUJVRykgeyBjb25zb2xlLmxvZyhzdGF0ZS5zdGVwLCAnREVMVEFDWycgKyBiICsgJ10nLCBuLCBzdGFjayk7IH1cblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbjsgaSsrKSB7XG4gICAgICAgIHZhciBjID0gc3RhY2sucG9wKCk7XG4gICAgICAgIHZhciBhcmcgPSBzdGFjay5wb3AoKTtcbiAgICAgICAgdmFyIGFwcGVtID0gYmFzZSArICgoYXJnICYgMHhGMCkgPj4gNCk7XG4gICAgICAgIGlmIChhcHBlbSAhPT0gcHBlbSkgeyBjb250aW51ZTsgfVxuXG4gICAgICAgIHZhciBtYWcgPSAoYXJnICYgMHgwRikgLSA4O1xuICAgICAgICBpZiAobWFnID49IDApIHsgbWFnKys7IH1cblxuICAgICAgICB2YXIgZGVsdGEgPSBtYWcgKiBkcztcblxuICAgICAgICBpZiAoZXhwb3J0cy5ERUJVRykgeyBjb25zb2xlLmxvZyhzdGF0ZS5zdGVwLCAnREVMVEFDRklYJywgYywgJ2J5JywgZGVsdGEpOyB9XG5cbiAgICAgICAgc3RhdGUuY3Z0W2NdICs9IGRlbHRhO1xuICAgIH1cbn1cblxuLy8gU1JPVU5EW10gU3VwZXIgUk9VTkRcbi8vIDB4NzZcbmZ1bmN0aW9uIFNST1VORChzdGF0ZSkge1xuICAgIHZhciBuID0gc3RhdGUuc3RhY2sucG9wKCk7XG5cbiAgICBpZiAoZXhwb3J0cy5ERUJVRykgeyBjb25zb2xlLmxvZyhzdGF0ZS5zdGVwLCAnU1JPVU5EW10nLCBuKTsgfVxuXG4gICAgc3RhdGUucm91bmQgPSByb3VuZFN1cGVyO1xuXG4gICAgdmFyIHBlcmlvZDtcblxuICAgIHN3aXRjaCAobiAmIDB4QzApIHtcbiAgICAgICAgY2FzZSAweDAwOlxuICAgICAgICAgICAgcGVyaW9kID0gMC41O1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMHg0MDpcbiAgICAgICAgICAgIHBlcmlvZCA9IDE7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAweDgwOlxuICAgICAgICAgICAgcGVyaW9kID0gMjtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIFNST1VORCB2YWx1ZScpO1xuICAgIH1cblxuICAgIHN0YXRlLnNyUGVyaW9kID0gcGVyaW9kO1xuXG4gICAgc3dpdGNoIChuICYgMHgzMCkge1xuICAgICAgICBjYXNlIDB4MDA6XG4gICAgICAgICAgICBzdGF0ZS5zclBoYXNlID0gMDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDB4MTA6XG4gICAgICAgICAgICBzdGF0ZS5zclBoYXNlID0gMC4yNSAqIHBlcmlvZDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDB4MjA6XG4gICAgICAgICAgICBzdGF0ZS5zclBoYXNlID0gMC41ICAqIHBlcmlvZDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDB4MzA6XG4gICAgICAgICAgICBzdGF0ZS5zclBoYXNlID0gMC43NSAqIHBlcmlvZDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OiB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgU1JPVU5EIHZhbHVlJyk7XG4gICAgfVxuXG4gICAgbiAmPSAweDBGO1xuXG4gICAgaWYgKG4gPT09IDApIHsgc3RhdGUuc3JUaHJlc2hvbGQgPSAwOyB9XG4gICAgZWxzZSB7IHN0YXRlLnNyVGhyZXNob2xkID0gKG4gLyA4IC0gMC41KSAqIHBlcmlvZDsgfVxufVxuXG4vLyBTNDVST1VORFtdIFN1cGVyIFJPVU5EIDQ1IGRlZ3JlZXNcbi8vIDB4NzdcbmZ1bmN0aW9uIFM0NVJPVU5EKHN0YXRlKSB7XG4gICAgdmFyIG4gPSBzdGF0ZS5zdGFjay5wb3AoKTtcblxuICAgIGlmIChleHBvcnRzLkRFQlVHKSB7IGNvbnNvbGUubG9nKHN0YXRlLnN0ZXAsICdTNDVST1VORFtdJywgbik7IH1cblxuICAgIHN0YXRlLnJvdW5kID0gcm91bmRTdXBlcjtcblxuICAgIHZhciBwZXJpb2Q7XG5cbiAgICBzd2l0Y2ggKG4gJiAweEMwKSB7XG4gICAgICAgIGNhc2UgMHgwMDpcbiAgICAgICAgICAgIHBlcmlvZCA9IE1hdGguc3FydCgyKSAvIDI7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAweDQwOlxuICAgICAgICAgICAgcGVyaW9kID0gTWF0aC5zcXJ0KDIpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMHg4MDpcbiAgICAgICAgICAgIHBlcmlvZCA9IDIgKiBNYXRoLnNxcnQoMik7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBTNDVST1VORCB2YWx1ZScpO1xuICAgIH1cblxuICAgIHN0YXRlLnNyUGVyaW9kID0gcGVyaW9kO1xuXG4gICAgc3dpdGNoIChuICYgMHgzMCkge1xuICAgICAgICBjYXNlIDB4MDA6XG4gICAgICAgICAgICBzdGF0ZS5zclBoYXNlID0gMDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDB4MTA6XG4gICAgICAgICAgICBzdGF0ZS5zclBoYXNlID0gMC4yNSAqIHBlcmlvZDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDB4MjA6XG4gICAgICAgICAgICBzdGF0ZS5zclBoYXNlID0gMC41ICAqIHBlcmlvZDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDB4MzA6XG4gICAgICAgICAgICBzdGF0ZS5zclBoYXNlID0gMC43NSAqIHBlcmlvZDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIFM0NVJPVU5EIHZhbHVlJyk7XG4gICAgfVxuXG4gICAgbiAmPSAweDBGO1xuXG4gICAgaWYgKG4gPT09IDApIHsgc3RhdGUuc3JUaHJlc2hvbGQgPSAwOyB9XG4gICAgZWxzZSB7IHN0YXRlLnNyVGhyZXNob2xkID0gKG4gLyA4IC0gMC41KSAqIHBlcmlvZDsgfVxufVxuXG4vLyBST0ZGW10gUm91bmQgT2ZmXG4vLyAweDdBXG5mdW5jdGlvbiBST0ZGKHN0YXRlKSB7XG4gICAgaWYgKGV4cG9ydHMuREVCVUcpIHsgY29uc29sZS5sb2coc3RhdGUuc3RlcCwgJ1JPRkZbXScpOyB9XG5cbiAgICBzdGF0ZS5yb3VuZCA9IHJvdW5kT2ZmO1xufVxuXG4vLyBSVVRHW10gUm91bmQgVXAgVG8gR3JpZFxuLy8gMHg3Q1xuZnVuY3Rpb24gUlVURyhzdGF0ZSkge1xuICAgIGlmIChleHBvcnRzLkRFQlVHKSB7IGNvbnNvbGUubG9nKHN0YXRlLnN0ZXAsICdSVVRHW10nKTsgfVxuXG4gICAgc3RhdGUucm91bmQgPSByb3VuZFVwVG9HcmlkO1xufVxuXG4vLyBSRFRHW10gUm91bmQgRG93biBUbyBHcmlkXG4vLyAweDdEXG5mdW5jdGlvbiBSRFRHKHN0YXRlKSB7XG4gICAgaWYgKGV4cG9ydHMuREVCVUcpIHsgY29uc29sZS5sb2coc3RhdGUuc3RlcCwgJ1JEVEdbXScpOyB9XG5cbiAgICBzdGF0ZS5yb3VuZCA9IHJvdW5kRG93blRvR3JpZDtcbn1cblxuLy8gU0NBTkNUUkxbXSBTQ0FOIGNvbnZlcnNpb24gQ29uVFJvTFxuLy8gMHg4NVxuZnVuY3Rpb24gU0NBTkNUUkwoc3RhdGUpIHtcbiAgICB2YXIgbiA9IHN0YXRlLnN0YWNrLnBvcCgpO1xuXG4gICAgLy8gaWdub3JlZCBieSBvcGVudHlwZS5qc1xuXG4gICAgaWYgKGV4cG9ydHMuREVCVUcpIHsgY29uc29sZS5sb2coc3RhdGUuc3RlcCwgJ1NDQU5DVFJMW10nLCBuKTsgfVxufVxuXG4vLyBTRFBWVExbYV0gU2V0IER1YWwgUHJvamVjdGlvbiBWZWN0b3IgVG8gTGluZVxuLy8gMHg4Ni0weDg3XG5mdW5jdGlvbiBTRFBWVEwoYSwgc3RhdGUpIHtcbiAgICB2YXIgc3RhY2sgPSBzdGF0ZS5zdGFjaztcbiAgICB2YXIgcDJpID0gc3RhY2sucG9wKCk7XG4gICAgdmFyIHAxaSA9IHN0YWNrLnBvcCgpO1xuICAgIHZhciBwMiA9IHN0YXRlLnoyW3AyaV07XG4gICAgdmFyIHAxID0gc3RhdGUuejFbcDFpXTtcblxuICAgIGlmIChleHBvcnRzLkRFQlVHKSB7IGNvbnNvbGUubG9nKHN0YXRlLnN0ZXAsICdTRFBWVExbJyArIGEgKyAnXScsIHAyaSwgcDFpKTsgfVxuXG4gICAgdmFyIGR4O1xuICAgIHZhciBkeTtcblxuICAgIGlmICghYSkge1xuICAgICAgICBkeCA9IHAxLnggLSBwMi54O1xuICAgICAgICBkeSA9IHAxLnkgLSBwMi55O1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGR4ID0gcDIueSAtIHAxLnk7XG4gICAgICAgIGR5ID0gcDEueCAtIHAyLng7XG4gICAgfVxuXG4gICAgc3RhdGUuZHB2ID0gZ2V0VW5pdFZlY3RvcihkeCwgZHkpO1xufVxuXG4vLyBHRVRJTkZPW10gR0VUIElORk9ybWF0aW9uXG4vLyAweDg4XG5mdW5jdGlvbiBHRVRJTkZPKHN0YXRlKSB7XG4gICAgdmFyIHN0YWNrID0gc3RhdGUuc3RhY2s7XG4gICAgdmFyIHNlbCA9IHN0YWNrLnBvcCgpO1xuICAgIHZhciByID0gMDtcblxuICAgIGlmIChleHBvcnRzLkRFQlVHKSB7IGNvbnNvbGUubG9nKHN0YXRlLnN0ZXAsICdHRVRJTkZPW10nLCBzZWwpOyB9XG5cbiAgICAvLyB2MzUgYXMgaW4gbm8gc3VicGl4ZWwgaGludGluZ1xuICAgIGlmIChzZWwgJiAweDAxKSB7IHIgPSAzNTsgfVxuXG4gICAgLy8gVE9ETyByb3RhdGlvbiBhbmQgc3RyZXRjaCBjdXJyZW50bHkgbm90IHN1cHBvcnRlZFxuICAgIC8vIGFuZCB0aHVzIHRob3NlIEdFVElORk8gYXJlIGFsd2F5cyAwLlxuXG4gICAgLy8gb3BlbnR5cGUuanMgaXMgYWx3YXlzIGdyYXkgc2NhbGluZ1xuICAgIGlmIChzZWwgJiAweDIwKSB7IHIgfD0gMHgxMDAwOyB9XG5cbiAgICBzdGFjay5wdXNoKHIpO1xufVxuXG4vLyBST0xMW10gUk9MTCB0aGUgdG9wIHRocmVlIHN0YWNrIGVsZW1lbnRzXG4vLyAweDhBXG5mdW5jdGlvbiBST0xMKHN0YXRlKSB7XG4gICAgdmFyIHN0YWNrID0gc3RhdGUuc3RhY2s7XG4gICAgdmFyIGEgPSBzdGFjay5wb3AoKTtcbiAgICB2YXIgYiA9IHN0YWNrLnBvcCgpO1xuICAgIHZhciBjID0gc3RhY2sucG9wKCk7XG5cbiAgICBpZiAoZXhwb3J0cy5ERUJVRykgeyBjb25zb2xlLmxvZyhzdGF0ZS5zdGVwLCAnUk9MTFtdJyk7IH1cblxuICAgIHN0YWNrLnB1c2goYik7XG4gICAgc3RhY2sucHVzaChhKTtcbiAgICBzdGFjay5wdXNoKGMpO1xufVxuXG4vLyBNQVhbXSBNQVhpbXVtIG9mIHRvcCB0d28gc3RhY2sgZWxlbWVudHNcbi8vIDB4OEJcbmZ1bmN0aW9uIE1BWChzdGF0ZSkge1xuICAgIHZhciBzdGFjayA9IHN0YXRlLnN0YWNrO1xuICAgIHZhciBlMiA9IHN0YWNrLnBvcCgpO1xuICAgIHZhciBlMSA9IHN0YWNrLnBvcCgpO1xuXG4gICAgaWYgKGV4cG9ydHMuREVCVUcpIHsgY29uc29sZS5sb2coc3RhdGUuc3RlcCwgJ01BWFtdJywgZTIsIGUxKTsgfVxuXG4gICAgc3RhY2sucHVzaChNYXRoLm1heChlMSwgZTIpKTtcbn1cblxuLy8gTUlOW10gTUlOaW11bSBvZiB0b3AgdHdvIHN0YWNrIGVsZW1lbnRzXG4vLyAweDhDXG5mdW5jdGlvbiBNSU4oc3RhdGUpIHtcbiAgICB2YXIgc3RhY2sgPSBzdGF0ZS5zdGFjaztcbiAgICB2YXIgZTIgPSBzdGFjay5wb3AoKTtcbiAgICB2YXIgZTEgPSBzdGFjay5wb3AoKTtcblxuICAgIGlmIChleHBvcnRzLkRFQlVHKSB7IGNvbnNvbGUubG9nKHN0YXRlLnN0ZXAsICdNSU5bXScsIGUyLCBlMSk7IH1cblxuICAgIHN0YWNrLnB1c2goTWF0aC5taW4oZTEsIGUyKSk7XG59XG5cbi8vIFNDQU5UWVBFW10gU0NBTlRZUEVcbi8vIDB4OERcbmZ1bmN0aW9uIFNDQU5UWVBFKHN0YXRlKSB7XG4gICAgdmFyIG4gPSBzdGF0ZS5zdGFjay5wb3AoKTtcbiAgICAvLyBpZ25vcmVkIGJ5IG9wZW50eXBlLmpzXG4gICAgaWYgKGV4cG9ydHMuREVCVUcpIHsgY29uc29sZS5sb2coc3RhdGUuc3RlcCwgJ1NDQU5UWVBFW10nLCBuKTsgfVxufVxuXG4vLyBJTlNUQ1RSTFtdIElOU1RDVFJMXG4vLyAweDhEXG5mdW5jdGlvbiBJTlNUQ1RSTChzdGF0ZSkge1xuICAgIHZhciBzID0gc3RhdGUuc3RhY2sucG9wKCk7XG4gICAgdmFyIHYgPSBzdGF0ZS5zdGFjay5wb3AoKTtcblxuICAgIGlmIChleHBvcnRzLkRFQlVHKSB7IGNvbnNvbGUubG9nKHN0YXRlLnN0ZXAsICdJTlNUQ1RSTFtdJywgcywgdik7IH1cblxuICAgIHN3aXRjaCAocykge1xuICAgICAgICBjYXNlIDEgOiBzdGF0ZS5pbmhpYml0R3JpZEZpdCA9ICEhdjsgcmV0dXJuO1xuICAgICAgICBjYXNlIDIgOiBzdGF0ZS5pZ25vcmVDdnQgPSAhIXY7IHJldHVybjtcbiAgICAgICAgZGVmYXVsdDogdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIElOU1RDVFJMW10gc2VsZWN0b3InKTtcbiAgICB9XG59XG5cbi8vIFBVU0hCW2FiY10gUFVTSCBCeXRlc1xuLy8gMHhCMC0weEI3XG5mdW5jdGlvbiBQVVNIQihuLCBzdGF0ZSkge1xuICAgIHZhciBzdGFjayA9IHN0YXRlLnN0YWNrO1xuICAgIHZhciBwcm9nID0gc3RhdGUucHJvZztcbiAgICB2YXIgaXAgPSBzdGF0ZS5pcDtcblxuICAgIGlmIChleHBvcnRzLkRFQlVHKSB7IGNvbnNvbGUubG9nKHN0YXRlLnN0ZXAsICdQVVNIQlsnICsgbiArICddJyk7IH1cblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbjsgaSsrKSB7IHN0YWNrLnB1c2gocHJvZ1srK2lwXSk7IH1cblxuICAgIHN0YXRlLmlwID0gaXA7XG59XG5cbi8vIFBVU0hXW2FiY10gUFVTSCBXb3Jkc1xuLy8gMHhCOC0weEJGXG5mdW5jdGlvbiBQVVNIVyhuLCBzdGF0ZSkge1xuICAgIHZhciBpcCA9IHN0YXRlLmlwO1xuICAgIHZhciBwcm9nID0gc3RhdGUucHJvZztcbiAgICB2YXIgc3RhY2sgPSBzdGF0ZS5zdGFjaztcblxuICAgIGlmIChleHBvcnRzLkRFQlVHKSB7IGNvbnNvbGUubG9nKHN0YXRlLmlwLCAnUFVTSFdbJyArIG4gKyAnXScpOyB9XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG47IGkrKykge1xuICAgICAgICB2YXIgdyA9IChwcm9nWysraXBdIDw8IDgpIHwgcHJvZ1srK2lwXTtcbiAgICAgICAgaWYgKHcgJiAweDgwMDApIHsgdyA9IC0oKHcgXiAweGZmZmYpICsgMSk7IH1cbiAgICAgICAgc3RhY2sucHVzaCh3KTtcbiAgICB9XG5cbiAgICBzdGF0ZS5pcCA9IGlwO1xufVxuXG4vLyBNRFJQW2FiY2RlXSBNb3ZlIERpcmVjdCBSZWxhdGl2ZSBQb2ludFxuLy8gMHhEMC0weEVGXG4vLyAoaWYgaW5kaXJlY3QgaXMgMClcbi8vXG4vLyBhbmRcbi8vXG4vLyBNSVJQW2FiY2RlXSBNb3ZlIEluZGlyZWN0IFJlbGF0aXZlIFBvaW50XG4vLyAweEUwLTB4RkZcbi8vIChpZiBpbmRpcmVjdCBpcyAxKVxuXG5mdW5jdGlvbiBNRFJQX01JUlAoaW5kaXJlY3QsIHNldFJwMCwga2VlcEQsIHJvLCBkdCwgc3RhdGUpIHtcbiAgICB2YXIgc3RhY2sgPSBzdGF0ZS5zdGFjaztcbiAgICB2YXIgY3Z0ZSA9IGluZGlyZWN0ICYmIHN0YWNrLnBvcCgpO1xuICAgIHZhciBwaSA9IHN0YWNrLnBvcCgpO1xuICAgIHZhciBycDBpID0gc3RhdGUucnAwO1xuICAgIHZhciBycCA9IHN0YXRlLnowW3JwMGldO1xuICAgIHZhciBwID0gc3RhdGUuejFbcGldO1xuXG4gICAgdmFyIG1kID0gc3RhdGUubWluRGlzO1xuICAgIHZhciBmdiA9IHN0YXRlLmZ2O1xuICAgIHZhciBwdiA9IHN0YXRlLmRwdjtcbiAgICB2YXIgb2Q7IC8vIG9yaWdpbmFsIGRpc3RhbmNlXG4gICAgdmFyIGQ7IC8vIG1vdmluZyBkaXN0YW5jZVxuICAgIHZhciBzaWduOyAvLyBzaWduIG9mIGRpc3RhbmNlXG4gICAgdmFyIGN2O1xuXG4gICAgZCA9IG9kID0gcHYuZGlzdGFuY2UocCwgcnAsIHRydWUsIHRydWUpO1xuICAgIHNpZ24gPSBkID49IDAgPyAxIDogLTE7IC8vIE1hdGguc2lnbiB3b3VsZCBiZSAwIGluIGNhc2Ugb2YgMFxuXG4gICAgLy8gVE9ETyBjb25zaWRlciBhdXRvRmxpcFxuICAgIGQgPSBNYXRoLmFicyhkKTtcblxuICAgIGlmIChpbmRpcmVjdCkge1xuICAgICAgICBjdiA9IHN0YXRlLmN2dFtjdnRlXTtcblxuICAgICAgICBpZiAocm8gJiYgTWF0aC5hYnMoZCAtIGN2KSA8IHN0YXRlLmN2Q3V0SW4pIHsgZCA9IGN2OyB9XG4gICAgfVxuXG4gICAgaWYgKGtlZXBEICYmIGQgPCBtZCkgeyBkID0gbWQ7IH1cblxuICAgIGlmIChybykgeyBkID0gc3RhdGUucm91bmQoZCk7IH1cblxuICAgIGZ2LnNldFJlbGF0aXZlKHAsIHJwLCBzaWduICogZCwgcHYpO1xuICAgIGZ2LnRvdWNoKHApO1xuXG4gICAgaWYgKGV4cG9ydHMuREVCVUcpIHtcbiAgICAgICAgY29uc29sZS5sb2coXG4gICAgICAgICAgICBzdGF0ZS5zdGVwLFxuICAgICAgICAgICAgKGluZGlyZWN0ID8gJ01JUlBbJyA6ICdNRFJQWycpICtcbiAgICAgICAgICAgIChzZXRScDAgPyAnTScgOiAnbScpICtcbiAgICAgICAgICAgIChrZWVwRCA/ICc+JyA6ICdfJykgK1xuICAgICAgICAgICAgKHJvID8gJ1InIDogJ18nKSArXG4gICAgICAgICAgICAoZHQgPT09IDAgPyAnR3InIDogKGR0ID09PSAxID8gJ0JsJyA6IChkdCA9PT0gMiA/ICdXaCcgOiAnJykpKSArXG4gICAgICAgICAgICAnXScsXG4gICAgICAgICAgICBpbmRpcmVjdCA/XG4gICAgICAgICAgICAgICAgY3Z0ZSArICcoJyArIHN0YXRlLmN2dFtjdnRlXSArICcsJyArICBjdiArICcpJyA6XG4gICAgICAgICAgICAgICAgJycsXG4gICAgICAgICAgICBwaSxcbiAgICAgICAgICAgICcoZCA9Jywgb2QsICctPicsIHNpZ24gKiBkLCAnKSdcbiAgICAgICAgKTtcbiAgICB9XG5cbiAgICBzdGF0ZS5ycDEgPSBzdGF0ZS5ycDA7XG4gICAgc3RhdGUucnAyID0gcGk7XG4gICAgaWYgKHNldFJwMCkgeyBzdGF0ZS5ycDAgPSBwaTsgfVxufVxuXG4vKlxuKiBUaGUgaW5zdHJ1Y3Rpb24gdGFibGUuXG4qL1xuaW5zdHJ1Y3Rpb25UYWJsZSA9IFtcbiAgICAvKiAweDAwICovIFNWVENBLmJpbmQodW5kZWZpbmVkLCB5VW5pdFZlY3RvciksXG4gICAgLyogMHgwMSAqLyBTVlRDQS5iaW5kKHVuZGVmaW5lZCwgeFVuaXRWZWN0b3IpLFxuICAgIC8qIDB4MDIgKi8gU1BWVENBLmJpbmQodW5kZWZpbmVkLCB5VW5pdFZlY3RvciksXG4gICAgLyogMHgwMyAqLyBTUFZUQ0EuYmluZCh1bmRlZmluZWQsIHhVbml0VmVjdG9yKSxcbiAgICAvKiAweDA0ICovIFNGVlRDQS5iaW5kKHVuZGVmaW5lZCwgeVVuaXRWZWN0b3IpLFxuICAgIC8qIDB4MDUgKi8gU0ZWVENBLmJpbmQodW5kZWZpbmVkLCB4VW5pdFZlY3RvciksXG4gICAgLyogMHgwNiAqLyBTUFZUTC5iaW5kKHVuZGVmaW5lZCwgMCksXG4gICAgLyogMHgwNyAqLyBTUFZUTC5iaW5kKHVuZGVmaW5lZCwgMSksXG4gICAgLyogMHgwOCAqLyBTRlZUTC5iaW5kKHVuZGVmaW5lZCwgMCksXG4gICAgLyogMHgwOSAqLyBTRlZUTC5iaW5kKHVuZGVmaW5lZCwgMSksXG4gICAgLyogMHgwQSAqLyBTUFZGUyxcbiAgICAvKiAweDBCICovIFNGVkZTLFxuICAgIC8qIDB4MEMgKi8gR1BWLFxuICAgIC8qIDB4MEQgKi8gR0ZWLFxuICAgIC8qIDB4MEUgKi8gU0ZWVFBWLFxuICAgIC8qIDB4MEYgKi8gSVNFQ1QsXG4gICAgLyogMHgxMCAqLyBTUlAwLFxuICAgIC8qIDB4MTEgKi8gU1JQMSxcbiAgICAvKiAweDEyICovIFNSUDIsXG4gICAgLyogMHgxMyAqLyBTWlAwLFxuICAgIC8qIDB4MTQgKi8gU1pQMSxcbiAgICAvKiAweDE1ICovIFNaUDIsXG4gICAgLyogMHgxNiAqLyBTWlBTLFxuICAgIC8qIDB4MTcgKi8gU0xPT1AsXG4gICAgLyogMHgxOCAqLyBSVEcsXG4gICAgLyogMHgxOSAqLyBSVEhHLFxuICAgIC8qIDB4MUEgKi8gU01ELFxuICAgIC8qIDB4MUIgKi8gRUxTRSxcbiAgICAvKiAweDFDICovIEpNUFIsXG4gICAgLyogMHgxRCAqLyBTQ1ZUQ0ksXG4gICAgLyogMHgxRSAqLyB1bmRlZmluZWQsICAgLy8gVE9ETyBTU1dDSVxuICAgIC8qIDB4MUYgKi8gdW5kZWZpbmVkLCAgIC8vIFRPRE8gU1NXXG4gICAgLyogMHgyMCAqLyBEVVAsXG4gICAgLyogMHgyMSAqLyBQT1AsXG4gICAgLyogMHgyMiAqLyBDTEVBUixcbiAgICAvKiAweDIzICovIFNXQVAsXG4gICAgLyogMHgyNCAqLyBERVBUSCxcbiAgICAvKiAweDI1ICovIENJTkRFWCxcbiAgICAvKiAweDI2ICovIE1JTkRFWCxcbiAgICAvKiAweDI3ICovIHVuZGVmaW5lZCwgICAvLyBUT0RPIEFMSUdOUFRTXG4gICAgLyogMHgyOCAqLyB1bmRlZmluZWQsXG4gICAgLyogMHgyOSAqLyB1bmRlZmluZWQsICAgLy8gVE9ETyBVVFBcbiAgICAvKiAweDJBICovIExPT1BDQUxMLFxuICAgIC8qIDB4MkIgKi8gQ0FMTCxcbiAgICAvKiAweDJDICovIEZERUYsXG4gICAgLyogMHgyRCAqLyB1bmRlZmluZWQsICAgLy8gRU5ERiAoZWF0ZW4gYnkgRkRFRilcbiAgICAvKiAweDJFICovIE1EQVAuYmluZCh1bmRlZmluZWQsIDApLFxuICAgIC8qIDB4MkYgKi8gTURBUC5iaW5kKHVuZGVmaW5lZCwgMSksXG4gICAgLyogMHgzMCAqLyBJVVAuYmluZCh1bmRlZmluZWQsIHlVbml0VmVjdG9yKSxcbiAgICAvKiAweDMxICovIElVUC5iaW5kKHVuZGVmaW5lZCwgeFVuaXRWZWN0b3IpLFxuICAgIC8qIDB4MzIgKi8gU0hQLmJpbmQodW5kZWZpbmVkLCAwKSxcbiAgICAvKiAweDMzICovIFNIUC5iaW5kKHVuZGVmaW5lZCwgMSksXG4gICAgLyogMHgzNCAqLyBTSEMuYmluZCh1bmRlZmluZWQsIDApLFxuICAgIC8qIDB4MzUgKi8gU0hDLmJpbmQodW5kZWZpbmVkLCAxKSxcbiAgICAvKiAweDM2ICovIFNIWi5iaW5kKHVuZGVmaW5lZCwgMCksXG4gICAgLyogMHgzNyAqLyBTSFouYmluZCh1bmRlZmluZWQsIDEpLFxuICAgIC8qIDB4MzggKi8gU0hQSVgsXG4gICAgLyogMHgzOSAqLyBJUCxcbiAgICAvKiAweDNBICovIE1TSVJQLmJpbmQodW5kZWZpbmVkLCAwKSxcbiAgICAvKiAweDNCICovIE1TSVJQLmJpbmQodW5kZWZpbmVkLCAxKSxcbiAgICAvKiAweDNDICovIEFMSUdOUlAsXG4gICAgLyogMHgzRCAqLyBSVERHLFxuICAgIC8qIDB4M0UgKi8gTUlBUC5iaW5kKHVuZGVmaW5lZCwgMCksXG4gICAgLyogMHgzRiAqLyBNSUFQLmJpbmQodW5kZWZpbmVkLCAxKSxcbiAgICAvKiAweDQwICovIE5QVVNIQixcbiAgICAvKiAweDQxICovIE5QVVNIVyxcbiAgICAvKiAweDQyICovIFdTLFxuICAgIC8qIDB4NDMgKi8gUlMsXG4gICAgLyogMHg0NCAqLyBXQ1ZUUCxcbiAgICAvKiAweDQ1ICovIFJDVlQsXG4gICAgLyogMHg0NiAqLyBHQy5iaW5kKHVuZGVmaW5lZCwgMCksXG4gICAgLyogMHg0NyAqLyBHQy5iaW5kKHVuZGVmaW5lZCwgMSksXG4gICAgLyogMHg0OCAqLyB1bmRlZmluZWQsICAgLy8gVE9ETyBTQ0ZTXG4gICAgLyogMHg0OSAqLyBNRC5iaW5kKHVuZGVmaW5lZCwgMCksXG4gICAgLyogMHg0QSAqLyBNRC5iaW5kKHVuZGVmaW5lZCwgMSksXG4gICAgLyogMHg0QiAqLyBNUFBFTSxcbiAgICAvKiAweDRDICovIHVuZGVmaW5lZCwgICAvLyBUT0RPIE1QU1xuICAgIC8qIDB4NEQgKi8gRkxJUE9OLFxuICAgIC8qIDB4NEUgKi8gdW5kZWZpbmVkLCAgIC8vIFRPRE8gRkxJUE9GRlxuICAgIC8qIDB4NEYgKi8gdW5kZWZpbmVkLCAgIC8vIFRPRE8gREVCVUdcbiAgICAvKiAweDUwICovIExULFxuICAgIC8qIDB4NTEgKi8gTFRFUSxcbiAgICAvKiAweDUyICovIEdULFxuICAgIC8qIDB4NTMgKi8gR1RFUSxcbiAgICAvKiAweDU0ICovIEVRLFxuICAgIC8qIDB4NTUgKi8gTkVRLFxuICAgIC8qIDB4NTYgKi8gT0RELFxuICAgIC8qIDB4NTcgKi8gRVZFTixcbiAgICAvKiAweDU4ICovIElGLFxuICAgIC8qIDB4NTkgKi8gRUlGLFxuICAgIC8qIDB4NUEgKi8gQU5ELFxuICAgIC8qIDB4NUIgKi8gT1IsXG4gICAgLyogMHg1QyAqLyBOT1QsXG4gICAgLyogMHg1RCAqLyBERUxUQVAxMjMuYmluZCh1bmRlZmluZWQsIDEpLFxuICAgIC8qIDB4NUUgKi8gU0RCLFxuICAgIC8qIDB4NUYgKi8gU0RTLFxuICAgIC8qIDB4NjAgKi8gQURELFxuICAgIC8qIDB4NjEgKi8gU1VCLFxuICAgIC8qIDB4NjIgKi8gRElWLFxuICAgIC8qIDB4NjMgKi8gTVVMLFxuICAgIC8qIDB4NjQgKi8gQUJTLFxuICAgIC8qIDB4NjUgKi8gTkVHLFxuICAgIC8qIDB4NjYgKi8gRkxPT1IsXG4gICAgLyogMHg2NyAqLyBDRUlMSU5HLFxuICAgIC8qIDB4NjggKi8gUk9VTkQuYmluZCh1bmRlZmluZWQsIDApLFxuICAgIC8qIDB4NjkgKi8gUk9VTkQuYmluZCh1bmRlZmluZWQsIDEpLFxuICAgIC8qIDB4NkEgKi8gUk9VTkQuYmluZCh1bmRlZmluZWQsIDIpLFxuICAgIC8qIDB4NkIgKi8gUk9VTkQuYmluZCh1bmRlZmluZWQsIDMpLFxuICAgIC8qIDB4NkMgKi8gdW5kZWZpbmVkLCAgIC8vIFRPRE8gTlJPVU5EW2FiXVxuICAgIC8qIDB4NkQgKi8gdW5kZWZpbmVkLCAgIC8vIFRPRE8gTlJPVU5EW2FiXVxuICAgIC8qIDB4NkUgKi8gdW5kZWZpbmVkLCAgIC8vIFRPRE8gTlJPVU5EW2FiXVxuICAgIC8qIDB4NkYgKi8gdW5kZWZpbmVkLCAgIC8vIFRPRE8gTlJPVU5EW2FiXVxuICAgIC8qIDB4NzAgKi8gV0NWVEYsXG4gICAgLyogMHg3MSAqLyBERUxUQVAxMjMuYmluZCh1bmRlZmluZWQsIDIpLFxuICAgIC8qIDB4NzIgKi8gREVMVEFQMTIzLmJpbmQodW5kZWZpbmVkLCAzKSxcbiAgICAvKiAweDczICovIERFTFRBQzEyMy5iaW5kKHVuZGVmaW5lZCwgMSksXG4gICAgLyogMHg3NCAqLyBERUxUQUMxMjMuYmluZCh1bmRlZmluZWQsIDIpLFxuICAgIC8qIDB4NzUgKi8gREVMVEFDMTIzLmJpbmQodW5kZWZpbmVkLCAzKSxcbiAgICAvKiAweDc2ICovIFNST1VORCxcbiAgICAvKiAweDc3ICovIFM0NVJPVU5ELFxuICAgIC8qIDB4NzggKi8gdW5kZWZpbmVkLCAgIC8vIFRPRE8gSlJPVFtdXG4gICAgLyogMHg3OSAqLyB1bmRlZmluZWQsICAgLy8gVE9ETyBKUk9GW11cbiAgICAvKiAweDdBICovIFJPRkYsXG4gICAgLyogMHg3QiAqLyB1bmRlZmluZWQsXG4gICAgLyogMHg3QyAqLyBSVVRHLFxuICAgIC8qIDB4N0QgKi8gUkRURyxcbiAgICAvKiAweDdFICovIFBPUCwgLy8gYWN0dWFsbHkgU0FOR1csIHN1cHBvc2VkIHRvIGRvIG9ubHkgYSBwb3AgdGhvdWdoXG4gICAgLyogMHg3RiAqLyBQT1AsIC8vIGFjdHVhbGx5IEFBLCBzdXBwb3NlZCB0byBkbyBvbmx5IGEgcG9wIHRob3VnaFxuICAgIC8qIDB4ODAgKi8gdW5kZWZpbmVkLCAgIC8vIFRPRE8gRkxJUFBUXG4gICAgLyogMHg4MSAqLyB1bmRlZmluZWQsICAgLy8gVE9ETyBGTElQUkdPTlxuICAgIC8qIDB4ODIgKi8gdW5kZWZpbmVkLCAgIC8vIFRPRE8gRkxJUFJHT0ZGXG4gICAgLyogMHg4MyAqLyB1bmRlZmluZWQsXG4gICAgLyogMHg4NCAqLyB1bmRlZmluZWQsXG4gICAgLyogMHg4NSAqLyBTQ0FOQ1RSTCxcbiAgICAvKiAweDg2ICovIFNEUFZUTC5iaW5kKHVuZGVmaW5lZCwgMCksXG4gICAgLyogMHg4NyAqLyBTRFBWVEwuYmluZCh1bmRlZmluZWQsIDEpLFxuICAgIC8qIDB4ODggKi8gR0VUSU5GTyxcbiAgICAvKiAweDg5ICovIHVuZGVmaW5lZCwgICAvLyBUT0RPIElERUZcbiAgICAvKiAweDhBICovIFJPTEwsXG4gICAgLyogMHg4QiAqLyBNQVgsXG4gICAgLyogMHg4QyAqLyBNSU4sXG4gICAgLyogMHg4RCAqLyBTQ0FOVFlQRSxcbiAgICAvKiAweDhFICovIElOU1RDVFJMLFxuICAgIC8qIDB4OEYgKi8gdW5kZWZpbmVkLFxuICAgIC8qIDB4OTAgKi8gdW5kZWZpbmVkLFxuICAgIC8qIDB4OTEgKi8gdW5kZWZpbmVkLFxuICAgIC8qIDB4OTIgKi8gdW5kZWZpbmVkLFxuICAgIC8qIDB4OTMgKi8gdW5kZWZpbmVkLFxuICAgIC8qIDB4OTQgKi8gdW5kZWZpbmVkLFxuICAgIC8qIDB4OTUgKi8gdW5kZWZpbmVkLFxuICAgIC8qIDB4OTYgKi8gdW5kZWZpbmVkLFxuICAgIC8qIDB4OTcgKi8gdW5kZWZpbmVkLFxuICAgIC8qIDB4OTggKi8gdW5kZWZpbmVkLFxuICAgIC8qIDB4OTkgKi8gdW5kZWZpbmVkLFxuICAgIC8qIDB4OUEgKi8gdW5kZWZpbmVkLFxuICAgIC8qIDB4OUIgKi8gdW5kZWZpbmVkLFxuICAgIC8qIDB4OUMgKi8gdW5kZWZpbmVkLFxuICAgIC8qIDB4OUQgKi8gdW5kZWZpbmVkLFxuICAgIC8qIDB4OUUgKi8gdW5kZWZpbmVkLFxuICAgIC8qIDB4OUYgKi8gdW5kZWZpbmVkLFxuICAgIC8qIDB4QTAgKi8gdW5kZWZpbmVkLFxuICAgIC8qIDB4QTEgKi8gdW5kZWZpbmVkLFxuICAgIC8qIDB4QTIgKi8gdW5kZWZpbmVkLFxuICAgIC8qIDB4QTMgKi8gdW5kZWZpbmVkLFxuICAgIC8qIDB4QTQgKi8gdW5kZWZpbmVkLFxuICAgIC8qIDB4QTUgKi8gdW5kZWZpbmVkLFxuICAgIC8qIDB4QTYgKi8gdW5kZWZpbmVkLFxuICAgIC8qIDB4QTcgKi8gdW5kZWZpbmVkLFxuICAgIC8qIDB4QTggKi8gdW5kZWZpbmVkLFxuICAgIC8qIDB4QTkgKi8gdW5kZWZpbmVkLFxuICAgIC8qIDB4QUEgKi8gdW5kZWZpbmVkLFxuICAgIC8qIDB4QUIgKi8gdW5kZWZpbmVkLFxuICAgIC8qIDB4QUMgKi8gdW5kZWZpbmVkLFxuICAgIC8qIDB4QUQgKi8gdW5kZWZpbmVkLFxuICAgIC8qIDB4QUUgKi8gdW5kZWZpbmVkLFxuICAgIC8qIDB4QUYgKi8gdW5kZWZpbmVkLFxuICAgIC8qIDB4QjAgKi8gUFVTSEIuYmluZCh1bmRlZmluZWQsIDEpLFxuICAgIC8qIDB4QjEgKi8gUFVTSEIuYmluZCh1bmRlZmluZWQsIDIpLFxuICAgIC8qIDB4QjIgKi8gUFVTSEIuYmluZCh1bmRlZmluZWQsIDMpLFxuICAgIC8qIDB4QjMgKi8gUFVTSEIuYmluZCh1bmRlZmluZWQsIDQpLFxuICAgIC8qIDB4QjQgKi8gUFVTSEIuYmluZCh1bmRlZmluZWQsIDUpLFxuICAgIC8qIDB4QjUgKi8gUFVTSEIuYmluZCh1bmRlZmluZWQsIDYpLFxuICAgIC8qIDB4QjYgKi8gUFVTSEIuYmluZCh1bmRlZmluZWQsIDcpLFxuICAgIC8qIDB4QjcgKi8gUFVTSEIuYmluZCh1bmRlZmluZWQsIDgpLFxuICAgIC8qIDB4QjggKi8gUFVTSFcuYmluZCh1bmRlZmluZWQsIDEpLFxuICAgIC8qIDB4QjkgKi8gUFVTSFcuYmluZCh1bmRlZmluZWQsIDIpLFxuICAgIC8qIDB4QkEgKi8gUFVTSFcuYmluZCh1bmRlZmluZWQsIDMpLFxuICAgIC8qIDB4QkIgKi8gUFVTSFcuYmluZCh1bmRlZmluZWQsIDQpLFxuICAgIC8qIDB4QkMgKi8gUFVTSFcuYmluZCh1bmRlZmluZWQsIDUpLFxuICAgIC8qIDB4QkQgKi8gUFVTSFcuYmluZCh1bmRlZmluZWQsIDYpLFxuICAgIC8qIDB4QkUgKi8gUFVTSFcuYmluZCh1bmRlZmluZWQsIDcpLFxuICAgIC8qIDB4QkYgKi8gUFVTSFcuYmluZCh1bmRlZmluZWQsIDgpLFxuICAgIC8qIDB4QzAgKi8gTURSUF9NSVJQLmJpbmQodW5kZWZpbmVkLCAwLCAwLCAwLCAwLCAwKSxcbiAgICAvKiAweEMxICovIE1EUlBfTUlSUC5iaW5kKHVuZGVmaW5lZCwgMCwgMCwgMCwgMCwgMSksXG4gICAgLyogMHhDMiAqLyBNRFJQX01JUlAuYmluZCh1bmRlZmluZWQsIDAsIDAsIDAsIDAsIDIpLFxuICAgIC8qIDB4QzMgKi8gTURSUF9NSVJQLmJpbmQodW5kZWZpbmVkLCAwLCAwLCAwLCAwLCAzKSxcbiAgICAvKiAweEM0ICovIE1EUlBfTUlSUC5iaW5kKHVuZGVmaW5lZCwgMCwgMCwgMCwgMSwgMCksXG4gICAgLyogMHhDNSAqLyBNRFJQX01JUlAuYmluZCh1bmRlZmluZWQsIDAsIDAsIDAsIDEsIDEpLFxuICAgIC8qIDB4QzYgKi8gTURSUF9NSVJQLmJpbmQodW5kZWZpbmVkLCAwLCAwLCAwLCAxLCAyKSxcbiAgICAvKiAweEM3ICovIE1EUlBfTUlSUC5iaW5kKHVuZGVmaW5lZCwgMCwgMCwgMCwgMSwgMyksXG4gICAgLyogMHhDOCAqLyBNRFJQX01JUlAuYmluZCh1bmRlZmluZWQsIDAsIDAsIDEsIDAsIDApLFxuICAgIC8qIDB4QzkgKi8gTURSUF9NSVJQLmJpbmQodW5kZWZpbmVkLCAwLCAwLCAxLCAwLCAxKSxcbiAgICAvKiAweENBICovIE1EUlBfTUlSUC5iaW5kKHVuZGVmaW5lZCwgMCwgMCwgMSwgMCwgMiksXG4gICAgLyogMHhDQiAqLyBNRFJQX01JUlAuYmluZCh1bmRlZmluZWQsIDAsIDAsIDEsIDAsIDMpLFxuICAgIC8qIDB4Q0MgKi8gTURSUF9NSVJQLmJpbmQodW5kZWZpbmVkLCAwLCAwLCAxLCAxLCAwKSxcbiAgICAvKiAweENEICovIE1EUlBfTUlSUC5iaW5kKHVuZGVmaW5lZCwgMCwgMCwgMSwgMSwgMSksXG4gICAgLyogMHhDRSAqLyBNRFJQX01JUlAuYmluZCh1bmRlZmluZWQsIDAsIDAsIDEsIDEsIDIpLFxuICAgIC8qIDB4Q0YgKi8gTURSUF9NSVJQLmJpbmQodW5kZWZpbmVkLCAwLCAwLCAxLCAxLCAzKSxcbiAgICAvKiAweEQwICovIE1EUlBfTUlSUC5iaW5kKHVuZGVmaW5lZCwgMCwgMSwgMCwgMCwgMCksXG4gICAgLyogMHhEMSAqLyBNRFJQX01JUlAuYmluZCh1bmRlZmluZWQsIDAsIDEsIDAsIDAsIDEpLFxuICAgIC8qIDB4RDIgKi8gTURSUF9NSVJQLmJpbmQodW5kZWZpbmVkLCAwLCAxLCAwLCAwLCAyKSxcbiAgICAvKiAweEQzICovIE1EUlBfTUlSUC5iaW5kKHVuZGVmaW5lZCwgMCwgMSwgMCwgMCwgMyksXG4gICAgLyogMHhENCAqLyBNRFJQX01JUlAuYmluZCh1bmRlZmluZWQsIDAsIDEsIDAsIDEsIDApLFxuICAgIC8qIDB4RDUgKi8gTURSUF9NSVJQLmJpbmQodW5kZWZpbmVkLCAwLCAxLCAwLCAxLCAxKSxcbiAgICAvKiAweEQ2ICovIE1EUlBfTUlSUC5iaW5kKHVuZGVmaW5lZCwgMCwgMSwgMCwgMSwgMiksXG4gICAgLyogMHhENyAqLyBNRFJQX01JUlAuYmluZCh1bmRlZmluZWQsIDAsIDEsIDAsIDEsIDMpLFxuICAgIC8qIDB4RDggKi8gTURSUF9NSVJQLmJpbmQodW5kZWZpbmVkLCAwLCAxLCAxLCAwLCAwKSxcbiAgICAvKiAweEQ5ICovIE1EUlBfTUlSUC5iaW5kKHVuZGVmaW5lZCwgMCwgMSwgMSwgMCwgMSksXG4gICAgLyogMHhEQSAqLyBNRFJQX01JUlAuYmluZCh1bmRlZmluZWQsIDAsIDEsIDEsIDAsIDIpLFxuICAgIC8qIDB4REIgKi8gTURSUF9NSVJQLmJpbmQodW5kZWZpbmVkLCAwLCAxLCAxLCAwLCAzKSxcbiAgICAvKiAweERDICovIE1EUlBfTUlSUC5iaW5kKHVuZGVmaW5lZCwgMCwgMSwgMSwgMSwgMCksXG4gICAgLyogMHhERCAqLyBNRFJQX01JUlAuYmluZCh1bmRlZmluZWQsIDAsIDEsIDEsIDEsIDEpLFxuICAgIC8qIDB4REUgKi8gTURSUF9NSVJQLmJpbmQodW5kZWZpbmVkLCAwLCAxLCAxLCAxLCAyKSxcbiAgICAvKiAweERGICovIE1EUlBfTUlSUC5iaW5kKHVuZGVmaW5lZCwgMCwgMSwgMSwgMSwgMyksXG4gICAgLyogMHhFMCAqLyBNRFJQX01JUlAuYmluZCh1bmRlZmluZWQsIDEsIDAsIDAsIDAsIDApLFxuICAgIC8qIDB4RTEgKi8gTURSUF9NSVJQLmJpbmQodW5kZWZpbmVkLCAxLCAwLCAwLCAwLCAxKSxcbiAgICAvKiAweEUyICovIE1EUlBfTUlSUC5iaW5kKHVuZGVmaW5lZCwgMSwgMCwgMCwgMCwgMiksXG4gICAgLyogMHhFMyAqLyBNRFJQX01JUlAuYmluZCh1bmRlZmluZWQsIDEsIDAsIDAsIDAsIDMpLFxuICAgIC8qIDB4RTQgKi8gTURSUF9NSVJQLmJpbmQodW5kZWZpbmVkLCAxLCAwLCAwLCAxLCAwKSxcbiAgICAvKiAweEU1ICovIE1EUlBfTUlSUC5iaW5kKHVuZGVmaW5lZCwgMSwgMCwgMCwgMSwgMSksXG4gICAgLyogMHhFNiAqLyBNRFJQX01JUlAuYmluZCh1bmRlZmluZWQsIDEsIDAsIDAsIDEsIDIpLFxuICAgIC8qIDB4RTcgKi8gTURSUF9NSVJQLmJpbmQodW5kZWZpbmVkLCAxLCAwLCAwLCAxLCAzKSxcbiAgICAvKiAweEU4ICovIE1EUlBfTUlSUC5iaW5kKHVuZGVmaW5lZCwgMSwgMCwgMSwgMCwgMCksXG4gICAgLyogMHhFOSAqLyBNRFJQX01JUlAuYmluZCh1bmRlZmluZWQsIDEsIDAsIDEsIDAsIDEpLFxuICAgIC8qIDB4RUEgKi8gTURSUF9NSVJQLmJpbmQodW5kZWZpbmVkLCAxLCAwLCAxLCAwLCAyKSxcbiAgICAvKiAweEVCICovIE1EUlBfTUlSUC5iaW5kKHVuZGVmaW5lZCwgMSwgMCwgMSwgMCwgMyksXG4gICAgLyogMHhFQyAqLyBNRFJQX01JUlAuYmluZCh1bmRlZmluZWQsIDEsIDAsIDEsIDEsIDApLFxuICAgIC8qIDB4RUQgKi8gTURSUF9NSVJQLmJpbmQodW5kZWZpbmVkLCAxLCAwLCAxLCAxLCAxKSxcbiAgICAvKiAweEVFICovIE1EUlBfTUlSUC5iaW5kKHVuZGVmaW5lZCwgMSwgMCwgMSwgMSwgMiksXG4gICAgLyogMHhFRiAqLyBNRFJQX01JUlAuYmluZCh1bmRlZmluZWQsIDEsIDAsIDEsIDEsIDMpLFxuICAgIC8qIDB4RjAgKi8gTURSUF9NSVJQLmJpbmQodW5kZWZpbmVkLCAxLCAxLCAwLCAwLCAwKSxcbiAgICAvKiAweEYxICovIE1EUlBfTUlSUC5iaW5kKHVuZGVmaW5lZCwgMSwgMSwgMCwgMCwgMSksXG4gICAgLyogMHhGMiAqLyBNRFJQX01JUlAuYmluZCh1bmRlZmluZWQsIDEsIDEsIDAsIDAsIDIpLFxuICAgIC8qIDB4RjMgKi8gTURSUF9NSVJQLmJpbmQodW5kZWZpbmVkLCAxLCAxLCAwLCAwLCAzKSxcbiAgICAvKiAweEY0ICovIE1EUlBfTUlSUC5iaW5kKHVuZGVmaW5lZCwgMSwgMSwgMCwgMSwgMCksXG4gICAgLyogMHhGNSAqLyBNRFJQX01JUlAuYmluZCh1bmRlZmluZWQsIDEsIDEsIDAsIDEsIDEpLFxuICAgIC8qIDB4RjYgKi8gTURSUF9NSVJQLmJpbmQodW5kZWZpbmVkLCAxLCAxLCAwLCAxLCAyKSxcbiAgICAvKiAweEY3ICovIE1EUlBfTUlSUC5iaW5kKHVuZGVmaW5lZCwgMSwgMSwgMCwgMSwgMyksXG4gICAgLyogMHhGOCAqLyBNRFJQX01JUlAuYmluZCh1bmRlZmluZWQsIDEsIDEsIDEsIDAsIDApLFxuICAgIC8qIDB4RjkgKi8gTURSUF9NSVJQLmJpbmQodW5kZWZpbmVkLCAxLCAxLCAxLCAwLCAxKSxcbiAgICAvKiAweEZBICovIE1EUlBfTUlSUC5iaW5kKHVuZGVmaW5lZCwgMSwgMSwgMSwgMCwgMiksXG4gICAgLyogMHhGQiAqLyBNRFJQX01JUlAuYmluZCh1bmRlZmluZWQsIDEsIDEsIDEsIDAsIDMpLFxuICAgIC8qIDB4RkMgKi8gTURSUF9NSVJQLmJpbmQodW5kZWZpbmVkLCAxLCAxLCAxLCAxLCAwKSxcbiAgICAvKiAweEZEICovIE1EUlBfTUlSUC5iaW5kKHVuZGVmaW5lZCwgMSwgMSwgMSwgMSwgMSksXG4gICAgLyogMHhGRSAqLyBNRFJQX01JUlAuYmluZCh1bmRlZmluZWQsIDEsIDEsIDEsIDEsIDIpLFxuICAgIC8qIDB4RkYgKi8gTURSUF9NSVJQLmJpbmQodW5kZWZpbmVkLCAxLCAxLCAxLCAxLCAzKVxuXTtcblxuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4gIE1hdGhlbWF0aWNhbCBDb25zaWRlcmF0aW9uc1xuKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG5cbmZ2IC4uLiByZWZlcnMgdG8gZnJlZWRvbSB2ZWN0b3JcbnB2IC4uLiByZWZlcnMgdG8gcHJvamVjdGlvbiB2ZWN0b3JcbnJwIC4uLiByZWZlcnMgdG8gcmVmZXJlbmNlIHBvaW50XG5wICAuLi4gcmVmZXJzIHRvIHRvIHBvaW50IGJlaW5nIG9wZXJhdGVkIG9uXG5kICAuLi4gcmVmZXJzIHRvIGRpc3RhbmNlXG5cblNFVFJFTEFUSVZFOlxuPT09PT09PT09PT09XG5cbmNhc2UgZnJlZWRvbSB2ZWN0b3IgPT0geC1heGlzOlxuLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgICAgICAgICAgICAgICAgICAgICAgIChwdilcbiAgICAgICAgICAgICAgICAgICAgIC4tJ1xuICAgICAgICAgICAgICBycGQgLi0nXG4gICAgICAgICAgICAgICAuLSpcbiAgICAgICAgICBkIC4tJzkwwrAnXG4gICAgICAgICAuLScgICAgICAgJ1xuICAgICAgLi0nICAgICAgICAgICAnXG4gICAqLScgICAgICAgICAgICAgICAnIGJcbiAgcnAgICAgICAgICAgICAgICAgICAnXG4gICAgICAgICAgICAgICAgICAgICAgICdcbiAgICAgICAgICAgICAgICAgICAgICAgICdcbiAgICAgICAgICAgIHAgKi0tLS0tLS0tLS0qLS0tLS0tLS0tLS0tLS0gKGZ2KVxuICAgICAgICAgICAgICAgICAgICAgICAgICBwbVxuXG4gIHJwZHggPSBycHggKyBkICogcHYueFxuICBycGR5ID0gcnB5ICsgZCAqIHB2LnlcblxuICBlcXVhdGlvbiBvZiBsaW5lIGJcblxuICAgeSAtIHJwZHkgPSBwdm5zICogKHgtIHJwZHgpXG5cbiAgIHkgPSBwLnlcblxuICAgeCA9IHJwZHggKyAoIHAueSAtIHJwZHkgKSAvIHB2bnNcblxuXG5jYXNlIGZyZWVkb20gdmVjdG9yID09IHktYXhpczpcbi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gICAgKiBwbVxuICAgIHxcXFxuICAgIHwgXFxcbiAgICB8ICBcXFxuICAgIHwgICBcXFxuICAgIHwgICAgXFxcbiAgICB8ICAgICBcXFxuICAgIHwgICAgICBcXFxuICAgIHwgICAgICAgXFxcbiAgICB8ICAgICAgICBcXFxuICAgIHwgICAgICAgICBcXCBiXG4gICAgfCAgICAgICAgICBcXFxuICAgIHwgICAgICAgICAgIFxcXG4gICAgfCAgICAgICAgICAgIFxcICAgIC4tJyAocHYpXG4gICAgfCAgICAgICAgIDkwwrAgXFwuLSdcbiAgICB8ICAgICAgICAgICAuLScqIHJwZFxuICAgIHwgICAgICAgIC4tJ1xuICAgICogICAgICotJyAgZFxuICAgIHAgICAgIHJwXG5cbiAgcnBkeCA9IHJweCArIGQgKiBwdi54XG4gIHJwZHkgPSBycHkgKyBkICogcHYueVxuXG4gIGVxdWF0aW9uIG9mIGxpbmUgYjpcbiAgICAgICAgICAgcHZucyAuLi4gbm9ybWFsIHNsb3BlIHRvIHB2XG5cbiAgIHkgLSBycGR5ID0gcHZucyAqICh4IC0gcnBkeClcblxuICAgeCA9IHAueFxuXG4gICB5ID0gcnBkeSArICBwdm5zICogKHAueCAtIHJwZHgpXG5cblxuXG5nZW5lcmljIGNhc2U6XG4tLS0tLS0tLS0tLS0tXG5cblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLicoZnYpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLidcbiAgICAgICAgICAgICAgICAgICAgICAgICAgLiogcG1cbiAgICAgICAgICAgICAgICAgICAgICAgIC4nICFcbiAgICAgICAgICAgICAgICAgICAgICAuJyAgICAuXG4gICAgICAgICAgICAgICAgICAgIC4nICAgICAgIVxuICAgICAgICAgICAgICAgICAgLicgICAgICAgICAuIGJcbiAgICAgICAgICAgICAgICAuJyAgICAgICAgICAgIVxuICAgICAgICAgICAgICAgKiAgICAgICAgICAgICAgLlxuICAgICAgICAgICAgICBwICAgICAgICAgICAgICAgIVxuICAgICAgICAgICAgICAgICAgICAgICAgIDkwwrAgICAuICAgIC4uLiAocHYpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAuLi4tKi0nJydcbiAgICAgICAgICAgICAgICAgIC4uLi0tLScnJyAgICBycGRcbiAgICAgICAgIC4uLi0tLScnJyAgIGRcbiAgICotLScnJ1xuICBycFxuXG4gICAgcnBkeCA9IHJweCArIGQgKiBwdi54XG4gICAgcnBkeSA9IHJweSArIGQgKiBwdi55XG5cbiBlcXVhdGlvbiBvZiBsaW5lIGI6XG4gICAgcHZucy4uLiBub3JtYWwgc2xvcGUgdG8gcHZcblxuICAgIHkgLSBycGR5ID0gcHZucyAqICh4IC0gcnBkeClcblxuIGVxdWF0aW9uIG9mIGZyZWVkb20gdmVjdG9yIGxpbmU6XG4gICAgZnZzIC4uLiBzbG9wZSBvZiBmcmVlZG9tIHZlY3RvciAoPWZ5L2Z4KVxuXG4gICAgeSAtIHB5ID0gZnZzICogKHggLSBweClcblxuXG4gIG9uIHBtIGJvdGggZXF1YXRpb25zIGFyZSB0cnVlIGZvciBzYW1lIHgveVxuXG4gICAgeSAtIHJwZHkgPSBwdm5zICogKHggLSBycGR4KVxuXG4gICAgeSAtIHB5ID0gZnZzICogKHggLSBweClcblxuICBmb3JtIHRvIHkgYW5kIHNldCBlcXVhbDpcblxuICAgIHB2bnMgKiAoeCAtIHJwZHgpICsgcnBkeSA9IGZ2cyAqICh4IC0gcHgpICsgcHlcblxuICBleHBhbmQ6XG5cbiAgICBwdm5zICogeCAtIHB2bnMgKiBycGR4ICsgcnBkeSA9IGZ2cyAqIHggLSBmdnMgKiBweCArIHB5XG5cbiAgc3dpdGNoOlxuXG4gICAgZnZzICogeCAtIGZ2cyAqIHB4ICsgcHkgPSBwdm5zICogeCAtIHB2bnMgKiBycGR4ICsgcnBkeVxuXG4gIHNvbHZlIGZvciB4OlxuXG4gICAgZnZzICogeCAtIHB2bnMgKiB4ID0gZnZzICogcHggLSBwdm5zICogcnBkeCAtIHB5ICsgcnBkeVxuXG5cblxuICAgICAgICAgIGZ2cyAqIHB4IC0gcHZucyAqIHJwZHggKyBycGR5IC0gcHlcbiAgICB4ID0gIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgICAgICAgICAgICAgIGZ2cyAtIHB2bnNcblxuICBhbmQ6XG5cbiAgICB5ID0gZnZzICogKHggLSBweCkgKyBweVxuXG5cblxuSU5URVJQT0xBVEU6XG49PT09PT09PT09PT1cblxuRXhhbXBsZXMgb2YgcG9pbnQgaW50ZXJwb2xhdGlvbi5cblxuVGhlIHdlaWdodCBvZiB0aGUgbW92ZW1lbnQgb2YgdGhlIHJlZmVyZW5jZSBwb2ludCBnZXRzIGJpZ2dlclxudGhlIGZ1cnRoZXIgdGhlIG90aGVyIHJlZmVyZW5jZSBwb2ludCBpcyBhd2F5LCB0aHVzIHRoZSBzYWZlc3Rcbm9wdGlvbiAodGhhdCBpcyBhdm9pZGluZyAwLzAgZGl2aXNpb25zKSBpcyB0byB3ZWlnaHQgdGhlXG5vcmlnaW5hbCBkaXN0YW5jZSBvZiB0aGUgb3RoZXIgcG9pbnQgYnkgdGhlIHN1bSBvZiBib3RoIGRpc3RhbmNlcy5cblxuSWYgdGhlIHN1bSBvZiBib3RoIGRpc3RhbmNlcyBpcyAwLCB0aGVuIG1vdmUgdGhlIHBvaW50IGJ5IHRoZVxuYXJpdGhtZXRpYyBhdmVyYWdlIG9mIHRoZSBtb3ZlbWVudCBvZiBib3RoIHJlZmVyZW5jZSBwb2ludHMuXG5cblxuXG5cbiAgICAgICAgICAgKCs2KVxuICAgIHJwMW8gKi0tLS0+KnJwMVxuICAgICAgICAgLiAgICAgLiAgICAgICAgICAgICAgICAgICAgICAgICAgKCsxMilcbiAgICAgICAgIC4gICAgIC4gICAgICAgICAgICAgICAgICBycDJvICotLS0tLS0tLS0tPiogcnAyXG4gICAgICAgICAuICAgICAuICAgICAgICAgICAgICAgICAgICAgICAuICAgICAgICAgICAuXG4gICAgICAgICAuICAgICAuICAgICAgICAgICAgICAgICAgICAgICAuICAgICAgICAgICAuXG4gICAgICAgICAuICAgIDEwICAgICAgICAgIDIwICAgICAgICAgICAuICAgICAgICAgICAuXG4gICAgICAgICB8Li4uLi4uLi4ufC4uLi4uLi4uLi4uLi4uLi4uLi58ICAgICAgICAgICAuXG4gICAgICAgICAgICAgICAuICAgLiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAuXG4gICAgICAgICAgICAgICAuICAgLiAoKzgpICAgICAgICAgICAgICAgICAgICAgICAgICAuXG4gICAgICAgICAgICAgICAgcG8gKi0tLS0tLT4qcCAgICAgICAgICAgICAgICAgICAgICAuXG4gICAgICAgICAgICAgICAuICAgICAgICAgICAuICAgICAgICAgICAgICAgICAgICAgICAuXG4gICAgICAgICAgICAgICAuICAgIDEyICAgICAuICAgICAgICAgIDI0ICAgICAgICAgICAuXG4gICAgICAgICAgICAgICB8Li4uLi4uLi4uLi58Li4uLi4uLi4uLi4uLi4uLi4uLi4uLi58XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgMzZcblxuXG4tLS0tLS0tXG5cblxuXG4gICAgICAgICAgICgrMTApXG4gICAgcnAxbyAqLS0tLS0tLS0+KnJwMVxuICAgICAgICAgLiAgICAgICAgIC4gICAgICAgICAgICAgICAgICAgICAgKC0xMClcbiAgICAgICAgIC4gICAgICAgICAuICAgICAgICAgICAgICBycDIgKjwtLS0tLS0tLS0qIHJwbzJcbiAgICAgICAgIC4gICAgICAgICAuICAgICAgICAgICAgICAgICAgIC4gICAgICAgICAuXG4gICAgICAgICAuICAgICAgICAgLiAgICAgICAgICAgICAgICAgICAuICAgICAgICAgLlxuICAgICAgICAgLiAgICAxMCAgIC4gICAgICAgICAgMzAgICAgICAgLiAgICAgICAgIC5cbiAgICAgICAgIHwuLi4uLi4uLi58Li4uLi4uLi4uLi4uLi4uLi4uLi4uLi4uLi4uLi58XG4gICAgICAgICAgICAgICAgICAgLiAgICAgICAgICAgICAgICAgICAuXG4gICAgICAgICAgICAgICAgICAgLiAoKzUpICAgICAgICAgICAgICAuXG4gICAgICAgICAgICAgICAgcG8gKi0tLT4qIHAgICAgICAgICAgICAuXG4gICAgICAgICAgICAgICAgICAgLiAgICAuICAgICAgICAgICAgICAuXG4gICAgICAgICAgICAgICAgICAgLiAgICAuICAgMjAgICAgICAgICAuXG4gICAgICAgICAgICAgICAgICAgfC4uLi58Li4uLi4uLi4uLi4uLi58XG4gICAgICAgICAgICAgICAgICAgICA1ICAgICAgICAxNVxuXG5cbi0tLS0tLS1cblxuXG4gICAgICAgICAgICgrMTApXG4gICAgcnAxbyAqLS0tLS0tLS0+KnJwMVxuICAgICAgICAgLiAgICAgICAgIC5cbiAgICAgICAgIC4gICAgICAgICAuXG4gICAgcnAybyAqLS0tLS0tLS0+KnJwMlxuXG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKzEwKVxuICAgICAgICAgICAgICAgICAgICAgICAgICBwbyAqLS0tLS0tLS0+KiBwXG5cbi0tLS0tLS1cblxuXG4gICAgICAgICAgICgrMTApXG4gICAgcnAxbyAqLS0tLS0tLS0+KnJwMVxuICAgICAgICAgLiAgICAgICAgIC5cbiAgICAgICAgIC4gICAgICAgICAuKCszMClcbiAgICBycDJvICotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tPipycDJcblxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCsyNSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgcG8gKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tPiogcFxuXG5cblxudmltOiBzZXQgdHM9NCBzdz00IGV4cGFuZHRhYjpcbioqKioqL1xuXG4vKipcbiAqIENvbnZlcnRzIGEgc3RyaW5nIGludG8gYSBsaXN0IG9mIHRva2Vucy5cbiAqL1xuXG4vKipcbiAqIENyZWF0ZSBhIG5ldyB0b2tlblxuICogQHBhcmFtIHtzdHJpbmd9IGNoYXIgYSBzaW5nbGUgY2hhclxuICovXG5mdW5jdGlvbiBUb2tlbihjaGFyKSB7XG4gICAgdGhpcy5jaGFyID0gY2hhcjtcbiAgICB0aGlzLnN0YXRlID0ge307XG4gICAgdGhpcy5hY3RpdmVTdGF0ZSA9IG51bGw7XG59XG5cbi8qKlxuICogQ3JlYXRlIGEgbmV3IGNvbnRleHQgcmFuZ2VcbiAqIEBwYXJhbSB7bnVtYmVyfSBzdGFydEluZGV4IHJhbmdlIHN0YXJ0IGluZGV4XG4gKiBAcGFyYW0ge251bWJlcn0gZW5kT2Zmc2V0IHJhbmdlIGVuZCBpbmRleCBvZmZzZXRcbiAqIEBwYXJhbSB7c3RyaW5nfSBjb250ZXh0TmFtZSBvd25lciBjb250ZXh0IG5hbWVcbiAqL1xuZnVuY3Rpb24gQ29udGV4dFJhbmdlKHN0YXJ0SW5kZXgsIGVuZE9mZnNldCwgY29udGV4dE5hbWUpIHtcbiAgICB0aGlzLmNvbnRleHROYW1lID0gY29udGV4dE5hbWU7XG4gICAgdGhpcy5zdGFydEluZGV4ID0gc3RhcnRJbmRleDtcbiAgICB0aGlzLmVuZE9mZnNldCA9IGVuZE9mZnNldDtcbn1cblxuLyoqXG4gKiBDaGVjayBjb250ZXh0IHN0YXJ0IGFuZCBlbmRcbiAqIEBwYXJhbSB7c3RyaW5nfSBjb250ZXh0TmFtZSBhIHVuaXF1ZSBjb250ZXh0IG5hbWVcbiAqIEBwYXJhbSB7ZnVuY3Rpb259IGNoZWNrU3RhcnQgYSBwcmVkaWNhdGUgZnVuY3Rpb24gdGhlIGluZGljYXRlcyBhIGNvbnRleHQncyBzdGFydFxuICogQHBhcmFtIHtmdW5jdGlvbn0gY2hlY2tFbmQgYSBwcmVkaWNhdGUgZnVuY3Rpb24gdGhlIGluZGljYXRlcyBhIGNvbnRleHQncyBlbmRcbiAqL1xuZnVuY3Rpb24gQ29udGV4dENoZWNrZXIoY29udGV4dE5hbWUsIGNoZWNrU3RhcnQsIGNoZWNrRW5kKSB7XG4gICAgdGhpcy5jb250ZXh0TmFtZSA9IGNvbnRleHROYW1lO1xuICAgIHRoaXMub3BlblJhbmdlID0gbnVsbDtcbiAgICB0aGlzLnJhbmdlcyA9IFtdO1xuICAgIHRoaXMuY2hlY2tTdGFydCA9IGNoZWNrU3RhcnQ7XG4gICAgdGhpcy5jaGVja0VuZCA9IGNoZWNrRW5kO1xufVxuXG4vKipcbiAqIEB0eXBlZGVmIENvbnRleHRQYXJhbXNcbiAqIEB0eXBlIE9iamVjdFxuICogQHByb3BlcnR5IHthcnJheX0gY29udGV4dCBjb250ZXh0IGl0ZW1zXG4gKiBAcHJvcGVydHkge251bWJlcn0gY3VycmVudEluZGV4IGN1cnJlbnQgaXRlbSBpbmRleFxuICovXG5cbi8qKlxuICogQ3JlYXRlIGEgY29udGV4dCBwYXJhbXNcbiAqIEBwYXJhbSB7YXJyYXl9IGNvbnRleHQgYSBsaXN0IG9mIGl0ZW1zXG4gKiBAcGFyYW0ge251bWJlcn0gY3VycmVudEluZGV4IGN1cnJlbnQgaXRlbSBpbmRleFxuICovXG5mdW5jdGlvbiBDb250ZXh0UGFyYW1zKGNvbnRleHQsIGN1cnJlbnRJbmRleCkge1xuICAgIHRoaXMuY29udGV4dCA9IGNvbnRleHQ7XG4gICAgdGhpcy5pbmRleCA9IGN1cnJlbnRJbmRleDtcbiAgICB0aGlzLmxlbmd0aCA9IGNvbnRleHQubGVuZ3RoO1xuICAgIHRoaXMuY3VycmVudCA9IGNvbnRleHRbY3VycmVudEluZGV4XTtcbiAgICB0aGlzLmJhY2t0cmFjayA9IGNvbnRleHQuc2xpY2UoMCwgY3VycmVudEluZGV4KTtcbiAgICB0aGlzLmxvb2thaGVhZCA9IGNvbnRleHQuc2xpY2UoY3VycmVudEluZGV4ICsgMSk7XG59XG5cbi8qKlxuICogQ3JlYXRlIGFuIGV2ZW50IGluc3RhbmNlXG4gKiBAcGFyYW0ge3N0cmluZ30gZXZlbnRJZCBldmVudCB1bmlxdWUgaWRcbiAqL1xuZnVuY3Rpb24gRXZlbnQoZXZlbnRJZCkge1xuICAgIHRoaXMuZXZlbnRJZCA9IGV2ZW50SWQ7XG4gICAgdGhpcy5zdWJzY3JpYmVycyA9IFtdO1xufVxuXG4vKipcbiAqIEluaXRpYWxpemUgYSBjb3JlIGV2ZW50cyBhbmQgYXV0byBzdWJzY3JpYmUgcmVxdWlyZWQgZXZlbnQgaGFuZGxlcnNcbiAqIEBwYXJhbSB7YW55fSBldmVudHMgYW4gb2JqZWN0IHRoYXQgZW5saXN0cyBjb3JlIGV2ZW50cyBoYW5kbGVyc1xuICovXG5mdW5jdGlvbiBpbml0aWFsaXplQ29yZUV2ZW50cyhldmVudHMpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICAgIHZhciBjb3JlRXZlbnRzID0gW1xuICAgICAgICAnc3RhcnQnLCAnZW5kJywgJ25leHQnLCAnbmV3VG9rZW4nLCAnY29udGV4dFN0YXJ0JyxcbiAgICAgICAgJ2NvbnRleHRFbmQnLCAnaW5zZXJ0VG9rZW4nLCAncmVtb3ZlVG9rZW4nLCAncmVtb3ZlUmFuZ2UnLFxuICAgICAgICAncmVwbGFjZVRva2VuJywgJ3JlcGxhY2VSYW5nZScsICdjb21wb3NlUlVEJywgJ3VwZGF0ZUNvbnRleHRzUmFuZ2VzJ1xuICAgIF07XG5cbiAgICBjb3JlRXZlbnRzLmZvckVhY2goZnVuY3Rpb24gKGV2ZW50SWQpIHtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMkMS5ldmVudHMsIGV2ZW50SWQsIHtcbiAgICAgICAgICAgIHZhbHVlOiBuZXcgRXZlbnQoZXZlbnRJZClcbiAgICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICBpZiAoISFldmVudHMpIHtcbiAgICAgICAgY29yZUV2ZW50cy5mb3JFYWNoKGZ1bmN0aW9uIChldmVudElkKSB7XG4gICAgICAgICAgICB2YXIgZXZlbnQgPSBldmVudHNbZXZlbnRJZF07XG4gICAgICAgICAgICBpZiAodHlwZW9mIGV2ZW50ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgdGhpcyQxLmV2ZW50c1tldmVudElkXS5zdWJzY3JpYmUoZXZlbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgdmFyIHJlcXVpcmVzQ29udGV4dFVwZGF0ZSA9IFtcbiAgICAgICAgJ2luc2VydFRva2VuJywgJ3JlbW92ZVRva2VuJywgJ3JlbW92ZVJhbmdlJyxcbiAgICAgICAgJ3JlcGxhY2VUb2tlbicsICdyZXBsYWNlUmFuZ2UnLCAnY29tcG9zZVJVRCdcbiAgICBdO1xuICAgIHJlcXVpcmVzQ29udGV4dFVwZGF0ZS5mb3JFYWNoKGZ1bmN0aW9uIChldmVudElkKSB7XG4gICAgICAgIHRoaXMkMS5ldmVudHNbZXZlbnRJZF0uc3Vic2NyaWJlKFxuICAgICAgICAgICAgdGhpcyQxLnVwZGF0ZUNvbnRleHRzUmFuZ2VzXG4gICAgICAgICk7XG4gICAgfSk7XG59XG5cbi8qKlxuICogQ29udmVydHMgYSBzdHJpbmcgaW50byBhIGxpc3Qgb2YgdG9rZW5zXG4gKiBAcGFyYW0ge2FueX0gZXZlbnRzIHRva2VuaXplciBjb3JlIGV2ZW50c1xuICovXG5mdW5jdGlvbiBUb2tlbml6ZXIoZXZlbnRzKSB7XG4gICAgdGhpcy50b2tlbnMgPSBbXTtcbiAgICB0aGlzLnJlZ2lzdGVyZWRDb250ZXh0cyA9IHt9O1xuICAgIHRoaXMuY29udGV4dENoZWNrZXJzID0gW107XG4gICAgdGhpcy5ldmVudHMgPSB7fTtcbiAgICB0aGlzLnJlZ2lzdGVyZWRNb2RpZmllcnMgPSBbXTtcblxuICAgIGluaXRpYWxpemVDb3JlRXZlbnRzLmNhbGwodGhpcywgZXZlbnRzKTtcbn1cblxuLyoqXG4gKiBTZXRzIHRoZSBzdGF0ZSBvZiBhIHRva2VuLCB1c3VhbGx5IGNhbGxlZCBieSBhIHN0YXRlIG1vZGlmaWVyLlxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBzdGF0ZSBpdGVtIGtleVxuICogQHBhcmFtIHthbnl9IHZhbHVlIHN0YXRlIGl0ZW0gdmFsdWVcbiAqL1xuVG9rZW4ucHJvdG90eXBlLnNldFN0YXRlID0gZnVuY3Rpb24oa2V5LCB2YWx1ZSkge1xuICAgIHRoaXMuc3RhdGVba2V5XSA9IHZhbHVlO1xuICAgIHRoaXMuYWN0aXZlU3RhdGUgPSB7IGtleToga2V5LCB2YWx1ZTogdGhpcy5zdGF0ZVtrZXldIH07XG4gICAgcmV0dXJuIHRoaXMuYWN0aXZlU3RhdGU7XG59O1xuXG5Ub2tlbi5wcm90b3R5cGUuZ2V0U3RhdGUgPSBmdW5jdGlvbiAoc3RhdGVJZCkge1xuICAgIHJldHVybiB0aGlzLnN0YXRlW3N0YXRlSWRdIHx8IG51bGw7XG59O1xuXG4vKipcbiAqIENoZWNrcyBpZiBhbiBpbmRleCBleGlzdHMgaW4gdGhlIHRva2VucyBsaXN0LlxuICogQHBhcmFtIHtudW1iZXJ9IGluZGV4IHRva2VuIGluZGV4XG4gKi9cblRva2VuaXplci5wcm90b3R5cGUuaW5ib3VuZEluZGV4ID0gZnVuY3Rpb24oaW5kZXgpIHtcbiAgICByZXR1cm4gaW5kZXggPj0gMCAmJiBpbmRleCA8IHRoaXMudG9rZW5zLmxlbmd0aDtcbn07XG5cbi8qKlxuICogQ29tcG9zZSBhbmQgYXBwbHkgYSBsaXN0IG9mIG9wZXJhdGlvbnMgKHJlcGxhY2UsIHVwZGF0ZSwgZGVsZXRlKVxuICogQHBhcmFtIHthcnJheX0gUlVEcyByZXBsYWNlLCB1cGRhdGUgYW5kIGRlbGV0ZSBvcGVyYXRpb25zXG4gKiBUT0RPOiBQZXJmLiBPcHRpbWl6YXRpb24gKGxlbmd0aEJlZm9yZSA9PT0gbGVuZ3RoQWZ0ZXIgPyBkaXNwYXRjaCBvbmNlKVxuICovXG5Ub2tlbml6ZXIucHJvdG90eXBlLmNvbXBvc2VSVUQgPSBmdW5jdGlvbiAoUlVEcykge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gICAgdmFyIHNpbGVudCA9IHRydWU7XG4gICAgdmFyIHN0YXRlID0gUlVEcy5tYXAoZnVuY3Rpb24gKFJVRCkgeyByZXR1cm4gKFxuICAgICAgICB0aGlzJDFbUlVEWzBdXS5hcHBseSh0aGlzJDEsIFJVRC5zbGljZSgxKS5jb25jYXQoc2lsZW50KSlcbiAgICApOyB9KTtcbiAgICB2YXIgaGFzRkFJTE9iamVjdCA9IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIChcbiAgICAgICAgdHlwZW9mIG9iaiA9PT0gJ29iamVjdCcgJiZcbiAgICAgICAgb2JqLmhhc093blByb3BlcnR5KCdGQUlMJylcbiAgICApOyB9O1xuICAgIGlmIChzdGF0ZS5ldmVyeShoYXNGQUlMT2JqZWN0KSkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgRkFJTDogXCJjb21wb3NlUlVEOiBvbmUgb3IgbW9yZSBvcGVyYXRpb25zIGhhc24ndCBjb21wbGV0ZWQgc3VjY2Vzc2Z1bGx5XCIsXG4gICAgICAgICAgICByZXBvcnQ6IHN0YXRlLmZpbHRlcihoYXNGQUlMT2JqZWN0KVxuICAgICAgICB9O1xuICAgIH1cbiAgICB0aGlzLmRpc3BhdGNoKCdjb21wb3NlUlVEJywgW3N0YXRlLmZpbHRlcihmdW5jdGlvbiAob3ApIHsgcmV0dXJuICFoYXNGQUlMT2JqZWN0KG9wKTsgfSldKTtcbn07XG5cbi8qKlxuICogUmVwbGFjZSBhIHJhbmdlIG9mIHRva2VucyB3aXRoIGEgbGlzdCBvZiB0b2tlbnNcbiAqIEBwYXJhbSB7bnVtYmVyfSBzdGFydEluZGV4IHJhbmdlIHN0YXJ0IGluZGV4XG4gKiBAcGFyYW0ge251bWJlcn0gb2Zmc2V0IHJhbmdlIG9mZnNldFxuICogQHBhcmFtIHt0b2tlbn0gdG9rZW5zIGEgbGlzdCBvZiB0b2tlbnMgdG8gcmVwbGFjZVxuICogQHBhcmFtIHtib29sZWFufSBzaWxlbnQgZGlzcGF0Y2ggZXZlbnRzIGFuZCB1cGRhdGUgY29udGV4dCByYW5nZXNcbiAqL1xuVG9rZW5pemVyLnByb3RvdHlwZS5yZXBsYWNlUmFuZ2UgPSBmdW5jdGlvbiAoc3RhcnRJbmRleCwgb2Zmc2V0LCB0b2tlbnMsIHNpbGVudCkge1xuICAgIG9mZnNldCA9IG9mZnNldCAhPT0gbnVsbCA/IG9mZnNldCA6IHRoaXMudG9rZW5zLmxlbmd0aDtcbiAgICB2YXIgaXNUb2tlblR5cGUgPSB0b2tlbnMuZXZlcnkoZnVuY3Rpb24gKHRva2VuKSB7IHJldHVybiB0b2tlbiBpbnN0YW5jZW9mIFRva2VuOyB9KTtcbiAgICBpZiAoIWlzTmFOKHN0YXJ0SW5kZXgpICYmIHRoaXMuaW5ib3VuZEluZGV4KHN0YXJ0SW5kZXgpICYmIGlzVG9rZW5UeXBlKSB7XG4gICAgICAgIHZhciByZXBsYWNlZCA9IHRoaXMudG9rZW5zLnNwbGljZS5hcHBseShcbiAgICAgICAgICAgIHRoaXMudG9rZW5zLCBbc3RhcnRJbmRleCwgb2Zmc2V0XS5jb25jYXQodG9rZW5zKVxuICAgICAgICApO1xuICAgICAgICBpZiAoIXNpbGVudCkgeyB0aGlzLmRpc3BhdGNoKCdyZXBsYWNlVG9rZW4nLCBbc3RhcnRJbmRleCwgb2Zmc2V0LCB0b2tlbnNdKTsgfVxuICAgICAgICByZXR1cm4gW3JlcGxhY2VkLCB0b2tlbnNdO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB7IEZBSUw6ICdyZXBsYWNlUmFuZ2U6IGludmFsaWQgdG9rZW5zIG9yIHN0YXJ0SW5kZXguJyB9O1xuICAgIH1cbn07XG5cbi8qKlxuICogUmVwbGFjZSBhIHRva2VuIHdpdGggYW5vdGhlciB0b2tlblxuICogQHBhcmFtIHtudW1iZXJ9IGluZGV4IHRva2VuIGluZGV4XG4gKiBAcGFyYW0ge3Rva2VufSB0b2tlbiBhIHRva2VuIHRvIHJlcGxhY2VcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gc2lsZW50IGRpc3BhdGNoIGV2ZW50cyBhbmQgdXBkYXRlIGNvbnRleHQgcmFuZ2VzXG4gKi9cblRva2VuaXplci5wcm90b3R5cGUucmVwbGFjZVRva2VuID0gZnVuY3Rpb24gKGluZGV4LCB0b2tlbiwgc2lsZW50KSB7XG4gICAgaWYgKCFpc05hTihpbmRleCkgJiYgdGhpcy5pbmJvdW5kSW5kZXgoaW5kZXgpICYmIHRva2VuIGluc3RhbmNlb2YgVG9rZW4pIHtcbiAgICAgICAgdmFyIHJlcGxhY2VkID0gdGhpcy50b2tlbnMuc3BsaWNlKGluZGV4LCAxLCB0b2tlbik7XG4gICAgICAgIGlmICghc2lsZW50KSB7IHRoaXMuZGlzcGF0Y2goJ3JlcGxhY2VUb2tlbicsIFtpbmRleCwgdG9rZW5dKTsgfVxuICAgICAgICByZXR1cm4gW3JlcGxhY2VkWzBdLCB0b2tlbl07XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHsgRkFJTDogJ3JlcGxhY2VUb2tlbjogaW52YWxpZCB0b2tlbiBvciBpbmRleC4nIH07XG4gICAgfVxufTtcblxuLyoqXG4gKiBSZW1vdmVzIGEgcmFuZ2Ugb2YgdG9rZW5zXG4gKiBAcGFyYW0ge251bWJlcn0gc3RhcnRJbmRleCByYW5nZSBzdGFydCBpbmRleFxuICogQHBhcmFtIHtudW1iZXJ9IG9mZnNldCByYW5nZSBvZmZzZXRcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gc2lsZW50IGRpc3BhdGNoIGV2ZW50cyBhbmQgdXBkYXRlIGNvbnRleHQgcmFuZ2VzXG4gKi9cblRva2VuaXplci5wcm90b3R5cGUucmVtb3ZlUmFuZ2UgPSBmdW5jdGlvbihzdGFydEluZGV4LCBvZmZzZXQsIHNpbGVudCkge1xuICAgIG9mZnNldCA9ICFpc05hTihvZmZzZXQpID8gb2Zmc2V0IDogdGhpcy50b2tlbnMubGVuZ3RoO1xuICAgIHZhciB0b2tlbnMgPSB0aGlzLnRva2Vucy5zcGxpY2Uoc3RhcnRJbmRleCwgb2Zmc2V0KTtcbiAgICBpZiAoIXNpbGVudCkgeyB0aGlzLmRpc3BhdGNoKCdyZW1vdmVSYW5nZScsIFt0b2tlbnMsIHN0YXJ0SW5kZXgsIG9mZnNldF0pOyB9XG4gICAgcmV0dXJuIHRva2Vucztcbn07XG5cbi8qKlxuICogUmVtb3ZlIGEgdG9rZW4gYXQgYSBjZXJ0YWluIGluZGV4XG4gKiBAcGFyYW0ge251bWJlcn0gaW5kZXggdG9rZW4gaW5kZXhcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gc2lsZW50IGRpc3BhdGNoIGV2ZW50cyBhbmQgdXBkYXRlIGNvbnRleHQgcmFuZ2VzXG4gKi9cblRva2VuaXplci5wcm90b3R5cGUucmVtb3ZlVG9rZW4gPSBmdW5jdGlvbihpbmRleCwgc2lsZW50KSB7XG4gICAgaWYgKCFpc05hTihpbmRleCkgJiYgdGhpcy5pbmJvdW5kSW5kZXgoaW5kZXgpKSB7XG4gICAgICAgIHZhciB0b2tlbiA9IHRoaXMudG9rZW5zLnNwbGljZShpbmRleCwgMSk7XG4gICAgICAgIGlmICghc2lsZW50KSB7IHRoaXMuZGlzcGF0Y2goJ3JlbW92ZVRva2VuJywgW3Rva2VuLCBpbmRleF0pOyB9XG4gICAgICAgIHJldHVybiB0b2tlbjtcbiAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4geyBGQUlMOiAncmVtb3ZlVG9rZW46IGludmFsaWQgdG9rZW4gaW5kZXguJyB9O1xuICAgIH1cbn07XG5cbi8qKlxuICogSW5zZXJ0IGEgbGlzdCBvZiB0b2tlbnMgYXQgYSBjZXJ0YWluIGluZGV4XG4gKiBAcGFyYW0ge2FycmF5fSB0b2tlbnMgYSBsaXN0IG9mIHRva2VucyB0byBpbnNlcnRcbiAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleCBpbnNlcnQgdGhlIGxpc3Qgb2YgdG9rZW5zIGF0IGluZGV4XG4gKiBAcGFyYW0ge2Jvb2xlYW59IHNpbGVudCBkaXNwYXRjaCBldmVudHMgYW5kIHVwZGF0ZSBjb250ZXh0IHJhbmdlc1xuICovXG5Ub2tlbml6ZXIucHJvdG90eXBlLmluc2VydFRva2VuID0gZnVuY3Rpb24gKHRva2VucywgaW5kZXgsIHNpbGVudCkge1xuICAgIHZhciB0b2tlblR5cGUgPSB0b2tlbnMuZXZlcnkoXG4gICAgICAgIGZ1bmN0aW9uICh0b2tlbikgeyByZXR1cm4gdG9rZW4gaW5zdGFuY2VvZiBUb2tlbjsgfVxuICAgICk7XG4gICAgaWYgKHRva2VuVHlwZSkge1xuICAgICAgICB0aGlzLnRva2Vucy5zcGxpY2UuYXBwbHkoXG4gICAgICAgICAgICB0aGlzLnRva2VucywgW2luZGV4LCAwXS5jb25jYXQodG9rZW5zKVxuICAgICAgICApO1xuICAgICAgICBpZiAoIXNpbGVudCkgeyB0aGlzLmRpc3BhdGNoKCdpbnNlcnRUb2tlbicsIFt0b2tlbnMsIGluZGV4XSk7IH1cbiAgICAgICAgcmV0dXJuIHRva2VucztcbiAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4geyBGQUlMOiAnaW5zZXJ0VG9rZW46IGludmFsaWQgdG9rZW4ocykuJyB9O1xuICAgIH1cbn07XG5cbi8qKlxuICogQSBzdGF0ZSBtb2RpZmllciB0aGF0IGlzIGNhbGxlZCBvbiAnbmV3VG9rZW4nIGV2ZW50XG4gKiBAcGFyYW0ge3N0cmluZ30gbW9kaWZpZXJJZCBzdGF0ZSBtb2RpZmllciBpZFxuICogQHBhcmFtIHtmdW5jdGlvbn0gY29uZGl0aW9uIGEgcHJlZGljYXRlIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyB0cnVlIG9yIGZhbHNlXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBtb2RpZmllciBhIGZ1bmN0aW9uIHRvIHVwZGF0ZSB0b2tlbiBzdGF0ZVxuICovXG5Ub2tlbml6ZXIucHJvdG90eXBlLnJlZ2lzdGVyTW9kaWZpZXIgPSBmdW5jdGlvbihtb2RpZmllcklkLCBjb25kaXRpb24sIG1vZGlmaWVyKSB7XG4gICAgdGhpcy5ldmVudHMubmV3VG9rZW4uc3Vic2NyaWJlKGZ1bmN0aW9uKHRva2VuLCBjb250ZXh0UGFyYW1zKSB7XG4gICAgICAgIHZhciBjb25kaXRpb25QYXJhbXMgPSBbdG9rZW4sIGNvbnRleHRQYXJhbXNdO1xuICAgICAgICB2YXIgY2FuQXBwbHlNb2RpZmllciA9IChcbiAgICAgICAgICAgIGNvbmRpdGlvbiA9PT0gbnVsbCB8fFxuICAgICAgICAgICAgY29uZGl0aW9uLmFwcGx5KHRoaXMsIGNvbmRpdGlvblBhcmFtcykgPT09IHRydWVcbiAgICAgICAgKTtcbiAgICAgICAgdmFyIG1vZGlmaWVyUGFyYW1zID0gW3Rva2VuLCBjb250ZXh0UGFyYW1zXTtcbiAgICAgICAgaWYgKGNhbkFwcGx5TW9kaWZpZXIpIHtcbiAgICAgICAgICAgIHZhciBuZXdTdGF0ZVZhbHVlID0gbW9kaWZpZXIuYXBwbHkodGhpcywgbW9kaWZpZXJQYXJhbXMpO1xuICAgICAgICAgICAgdG9rZW4uc2V0U3RhdGUobW9kaWZpZXJJZCwgbmV3U3RhdGVWYWx1ZSk7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICB0aGlzLnJlZ2lzdGVyZWRNb2RpZmllcnMucHVzaChtb2RpZmllcklkKTtcbn07XG5cbi8qKlxuICogU3Vic2NyaWJlIGEgaGFuZGxlciB0byBhbiBldmVudFxuICogQHBhcmFtIHtmdW5jdGlvbn0gZXZlbnRIYW5kbGVyIGFuIGV2ZW50IGhhbmRsZXIgZnVuY3Rpb25cbiAqL1xuRXZlbnQucHJvdG90eXBlLnN1YnNjcmliZSA9IGZ1bmN0aW9uIChldmVudEhhbmRsZXIpIHtcbiAgICBpZiAodHlwZW9mIGV2ZW50SGFuZGxlciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICByZXR1cm4gKCh0aGlzLnN1YnNjcmliZXJzLnB1c2goZXZlbnRIYW5kbGVyKSkgLSAxKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4geyBGQUlMOiAoXCJpbnZhbGlkICdcIiArICh0aGlzLmV2ZW50SWQpICsgXCInIGV2ZW50IGhhbmRsZXJcIil9O1xuICAgIH1cbn07XG5cbi8qKlxuICogVW5zdWJzY3JpYmUgYW4gZXZlbnQgaGFuZGxlclxuICogQHBhcmFtIHtzdHJpbmd9IHN1YnNJZCBzdWJzY3JpcHRpb24gaWRcbiAqL1xuRXZlbnQucHJvdG90eXBlLnVuc3Vic2NyaWJlID0gZnVuY3Rpb24gKHN1YnNJZCkge1xuICAgIHRoaXMuc3Vic2NyaWJlcnMuc3BsaWNlKHN1YnNJZCwgMSk7XG59O1xuXG4vKipcbiAqIFNldHMgY29udGV4dCBwYXJhbXMgY3VycmVudCB2YWx1ZSBpbmRleFxuICogQHBhcmFtIHtudW1iZXJ9IGluZGV4IGNvbnRleHQgcGFyYW1zIGN1cnJlbnQgdmFsdWUgaW5kZXhcbiAqL1xuQ29udGV4dFBhcmFtcy5wcm90b3R5cGUuc2V0Q3VycmVudEluZGV4ID0gZnVuY3Rpb24oaW5kZXgpIHtcbiAgICB0aGlzLmluZGV4ID0gaW5kZXg7XG4gICAgdGhpcy5jdXJyZW50ID0gdGhpcy5jb250ZXh0W2luZGV4XTtcbiAgICB0aGlzLmJhY2t0cmFjayA9IHRoaXMuY29udGV4dC5zbGljZSgwLCBpbmRleCk7XG4gICAgdGhpcy5sb29rYWhlYWQgPSB0aGlzLmNvbnRleHQuc2xpY2UoaW5kZXggKyAxKTtcbn07XG5cbi8qKlxuICogR2V0IGFuIGl0ZW0gYXQgYW4gb2Zmc2V0IGZyb20gdGhlIGN1cnJlbnQgdmFsdWVcbiAqIGV4YW1wbGUgKGN1cnJlbnQgdmFsdWUgaXMgMyk6XG4gKiAgMSAgICAyICAgWzNdICAgNCAgICA1ICAgfCAgIGl0ZW1zIHZhbHVlc1xuICogLTIgICAtMSAgICAwICAgIDEgICAgMiAgIHwgICBvZmZzZXQgdmFsdWVzXG4gKiBAcGFyYW0ge251bWJlcn0gb2Zmc2V0IGFuIG9mZnNldCBmcm9tIGN1cnJlbnQgdmFsdWUgaW5kZXhcbiAqL1xuQ29udGV4dFBhcmFtcy5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24gKG9mZnNldCkge1xuICAgIHN3aXRjaCAodHJ1ZSkge1xuICAgICAgICBjYXNlIChvZmZzZXQgPT09IDApOlxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY3VycmVudDtcbiAgICAgICAgY2FzZSAob2Zmc2V0IDwgMCAmJiBNYXRoLmFicyhvZmZzZXQpIDw9IHRoaXMuYmFja3RyYWNrLmxlbmd0aCk6XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5iYWNrdHJhY2suc2xpY2Uob2Zmc2V0KVswXTtcbiAgICAgICAgY2FzZSAob2Zmc2V0ID4gMCAmJiBvZmZzZXQgPD0gdGhpcy5sb29rYWhlYWQubGVuZ3RoKTpcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmxvb2thaGVhZFtvZmZzZXQgLSAxXTtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbn07XG5cbi8qKlxuICogQ29udmVydHMgYSBjb250ZXh0IHJhbmdlIGludG8gYSBzdHJpbmcgdmFsdWVcbiAqIEBwYXJhbSB7Y29udGV4dFJhbmdlfSByYW5nZSBhIGNvbnRleHQgcmFuZ2VcbiAqL1xuVG9rZW5pemVyLnByb3RvdHlwZS5yYW5nZVRvVGV4dCA9IGZ1bmN0aW9uIChyYW5nZSkge1xuICAgIGlmIChyYW5nZSBpbnN0YW5jZW9mIENvbnRleHRSYW5nZSkge1xuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgdGhpcy5nZXRSYW5nZVRva2VucyhyYW5nZSlcbiAgICAgICAgICAgICAgICAubWFwKGZ1bmN0aW9uICh0b2tlbikgeyByZXR1cm4gdG9rZW4uY2hhcjsgfSkuam9pbignJylcbiAgICAgICAgKTtcbiAgICB9XG59O1xuXG4vKipcbiAqIENvbnZlcnRzIGFsbCB0b2tlbnMgaW50byBhIHN0cmluZ1xuICovXG5Ub2tlbml6ZXIucHJvdG90eXBlLmdldFRleHQgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMudG9rZW5zLm1hcChmdW5jdGlvbiAodG9rZW4pIHsgcmV0dXJuIHRva2VuLmNoYXI7IH0pLmpvaW4oJycpO1xufTtcblxuLyoqXG4gKiBHZXQgYSBjb250ZXh0IGJ5IG5hbWVcbiAqIEBwYXJhbSB7c3RyaW5nfSBjb250ZXh0TmFtZSBjb250ZXh0IG5hbWUgdG8gZ2V0XG4gKi9cblRva2VuaXplci5wcm90b3R5cGUuZ2V0Q29udGV4dCA9IGZ1bmN0aW9uIChjb250ZXh0TmFtZSkge1xuICAgIHZhciBjb250ZXh0ID0gdGhpcy5yZWdpc3RlcmVkQ29udGV4dHNbY29udGV4dE5hbWVdO1xuICAgIHJldHVybiAhIWNvbnRleHQgPyBjb250ZXh0IDogbnVsbDtcbn07XG5cbi8qKlxuICogU3Vic2NyaWJlcyBhIG5ldyBldmVudCBoYW5kbGVyIHRvIGFuIGV2ZW50XG4gKiBAcGFyYW0ge3N0cmluZ30gZXZlbnROYW1lIGV2ZW50IG5hbWUgdG8gc3Vic2NyaWJlIHRvXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBldmVudEhhbmRsZXIgYSBmdW5jdGlvbiB0byBiZSBpbnZva2VkIG9uIGV2ZW50XG4gKi9cblRva2VuaXplci5wcm90b3R5cGUub24gPSBmdW5jdGlvbihldmVudE5hbWUsIGV2ZW50SGFuZGxlcikge1xuICAgIHZhciBldmVudCA9IHRoaXMuZXZlbnRzW2V2ZW50TmFtZV07XG4gICAgaWYgKCEhZXZlbnQpIHtcbiAgICAgICAgcmV0dXJuIGV2ZW50LnN1YnNjcmliZShldmVudEhhbmRsZXIpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbn07XG5cbi8qKlxuICogRGlzcGF0Y2hlcyBhbiBldmVudFxuICogQHBhcmFtIHtzdHJpbmd9IGV2ZW50TmFtZSBldmVudCBuYW1lXG4gKiBAcGFyYW0ge2FueX0gYXJncyBldmVudCBoYW5kbGVyIGFyZ3VtZW50c1xuICovXG5Ub2tlbml6ZXIucHJvdG90eXBlLmRpc3BhdGNoID0gZnVuY3Rpb24oZXZlbnROYW1lLCBhcmdzKSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgICB2YXIgZXZlbnQgPSB0aGlzLmV2ZW50c1tldmVudE5hbWVdO1xuICAgIGlmIChldmVudCBpbnN0YW5jZW9mIEV2ZW50KSB7XG4gICAgICAgIGV2ZW50LnN1YnNjcmliZXJzLmZvckVhY2goZnVuY3Rpb24gKHN1YnNjcmliZXIpIHtcbiAgICAgICAgICAgIHN1YnNjcmliZXIuYXBwbHkodGhpcyQxLCBhcmdzIHx8IFtdKTtcbiAgICAgICAgfSk7XG4gICAgfVxufTtcblxuLyoqXG4gKiBSZWdpc3RlciBhIG5ldyBjb250ZXh0IGNoZWNrZXJcbiAqIEBwYXJhbSB7c3RyaW5nfSBjb250ZXh0TmFtZSBhIHVuaXF1ZSBjb250ZXh0IG5hbWVcbiAqIEBwYXJhbSB7ZnVuY3Rpb259IGNvbnRleHRTdGFydENoZWNrIGEgcHJlZGljYXRlIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyB0cnVlIG9uIGNvbnRleHQgc3RhcnRcbiAqIEBwYXJhbSB7ZnVuY3Rpb259IGNvbnRleHRFbmRDaGVjayAgYSBwcmVkaWNhdGUgZnVuY3Rpb24gdGhhdCByZXR1cm5zIHRydWUgb24gY29udGV4dCBlbmRcbiAqIFRPRE86IGNhbGwgdG9rZW5pemUgb24gcmVnaXN0cmF0aW9uIHRvIHVwZGF0ZSBjb250ZXh0IHJhbmdlcyB3aXRoIHRoZSBuZXcgY29udGV4dC5cbiAqL1xuVG9rZW5pemVyLnByb3RvdHlwZS5yZWdpc3RlckNvbnRleHRDaGVja2VyID0gZnVuY3Rpb24oY29udGV4dE5hbWUsIGNvbnRleHRTdGFydENoZWNrLCBjb250ZXh0RW5kQ2hlY2spIHtcbiAgICBpZiAoISF0aGlzLmdldENvbnRleHQoY29udGV4dE5hbWUpKSB7IHJldHVybiB7XG4gICAgICAgIEZBSUw6XG4gICAgICAgIChcImNvbnRleHQgbmFtZSAnXCIgKyBjb250ZXh0TmFtZSArIFwiJyBpcyBhbHJlYWR5IHJlZ2lzdGVyZWQuXCIpXG4gICAgfTsgfVxuICAgIGlmICh0eXBlb2YgY29udGV4dFN0YXJ0Q2hlY2sgIT09ICdmdW5jdGlvbicpIHsgcmV0dXJuIHtcbiAgICAgICAgRkFJTDpcbiAgICAgICAgXCJtaXNzaW5nIGNvbnRleHQgc3RhcnQgY2hlY2suXCJcbiAgICB9OyB9XG4gICAgaWYgKHR5cGVvZiBjb250ZXh0RW5kQ2hlY2sgIT09ICdmdW5jdGlvbicpIHsgcmV0dXJuIHtcbiAgICAgICAgRkFJTDpcbiAgICAgICAgXCJtaXNzaW5nIGNvbnRleHQgZW5kIGNoZWNrLlwiXG4gICAgfTsgfVxuICAgIHZhciBjb250ZXh0Q2hlY2tlcnMgPSBuZXcgQ29udGV4dENoZWNrZXIoXG4gICAgICAgIGNvbnRleHROYW1lLCBjb250ZXh0U3RhcnRDaGVjaywgY29udGV4dEVuZENoZWNrXG4gICAgKTtcbiAgICB0aGlzLnJlZ2lzdGVyZWRDb250ZXh0c1tjb250ZXh0TmFtZV0gPSBjb250ZXh0Q2hlY2tlcnM7XG4gICAgdGhpcy5jb250ZXh0Q2hlY2tlcnMucHVzaChjb250ZXh0Q2hlY2tlcnMpO1xuICAgIHJldHVybiBjb250ZXh0Q2hlY2tlcnM7XG59O1xuXG4vKipcbiAqIEdldHMgYSBjb250ZXh0IHJhbmdlIHRva2Vuc1xuICogQHBhcmFtIHtjb250ZXh0UmFuZ2V9IHJhbmdlIGEgY29udGV4dCByYW5nZVxuICovXG5Ub2tlbml6ZXIucHJvdG90eXBlLmdldFJhbmdlVG9rZW5zID0gZnVuY3Rpb24ocmFuZ2UpIHtcbiAgICB2YXIgZW5kSW5kZXggPSByYW5nZS5zdGFydEluZGV4ICsgcmFuZ2UuZW5kT2Zmc2V0O1xuICAgIHJldHVybiBbXS5jb25jYXQoXG4gICAgICAgIHRoaXMudG9rZW5zXG4gICAgICAgICAgICAuc2xpY2UocmFuZ2Uuc3RhcnRJbmRleCwgZW5kSW5kZXgpXG4gICAgKTtcbn07XG5cbi8qKlxuICogR2V0cyB0aGUgcmFuZ2VzIG9mIGEgY29udGV4dFxuICogQHBhcmFtIHtzdHJpbmd9IGNvbnRleHROYW1lIGNvbnRleHQgbmFtZVxuICovXG5Ub2tlbml6ZXIucHJvdG90eXBlLmdldENvbnRleHRSYW5nZXMgPSBmdW5jdGlvbihjb250ZXh0TmFtZSkge1xuICAgIHZhciBjb250ZXh0ID0gdGhpcy5nZXRDb250ZXh0KGNvbnRleHROYW1lKTtcbiAgICBpZiAoISFjb250ZXh0KSB7XG4gICAgICAgIHJldHVybiBjb250ZXh0LnJhbmdlcztcbiAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4geyBGQUlMOiAoXCJjb250ZXh0IGNoZWNrZXIgJ1wiICsgY29udGV4dE5hbWUgKyBcIicgaXMgbm90IHJlZ2lzdGVyZWQuXCIpIH07XG4gICAgfVxufTtcblxuLyoqXG4gKiBSZXNldHMgY29udGV4dCByYW5nZXMgdG8gcnVuIGNvbnRleHQgdXBkYXRlXG4gKi9cblRva2VuaXplci5wcm90b3R5cGUucmVzZXRDb250ZXh0c1JhbmdlcyA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgcmVnaXN0ZXJlZENvbnRleHRzID0gdGhpcy5yZWdpc3RlcmVkQ29udGV4dHM7XG4gICAgZm9yICh2YXIgY29udGV4dE5hbWUgaW4gcmVnaXN0ZXJlZENvbnRleHRzKSB7XG4gICAgICAgIGlmIChyZWdpc3RlcmVkQ29udGV4dHMuaGFzT3duUHJvcGVydHkoY29udGV4dE5hbWUpKSB7XG4gICAgICAgICAgICB2YXIgY29udGV4dCA9IHJlZ2lzdGVyZWRDb250ZXh0c1tjb250ZXh0TmFtZV07XG4gICAgICAgICAgICBjb250ZXh0LnJhbmdlcyA9IFtdO1xuICAgICAgICB9XG4gICAgfVxufTtcblxuLyoqXG4gKiBVcGRhdGVzIGNvbnRleHQgcmFuZ2VzXG4gKi9cblRva2VuaXplci5wcm90b3R5cGUudXBkYXRlQ29udGV4dHNSYW5nZXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5yZXNldENvbnRleHRzUmFuZ2VzKCk7XG4gICAgdmFyIGNoYXJzID0gdGhpcy50b2tlbnMubWFwKGZ1bmN0aW9uICh0b2tlbikgeyByZXR1cm4gdG9rZW4uY2hhcjsgfSk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaGFycy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgY29udGV4dFBhcmFtcyA9IG5ldyBDb250ZXh0UGFyYW1zKGNoYXJzLCBpKTtcbiAgICAgICAgdGhpcy5ydW5Db250ZXh0Q2hlY2soY29udGV4dFBhcmFtcyk7XG4gICAgfVxuICAgIHRoaXMuZGlzcGF0Y2goJ3VwZGF0ZUNvbnRleHRzUmFuZ2VzJywgW3RoaXMucmVnaXN0ZXJlZENvbnRleHRzXSk7XG59O1xuXG4vKipcbiAqIFNldHMgdGhlIGVuZCBvZmZzZXQgb2YgYW4gb3BlbiByYW5nZVxuICogQHBhcmFtIHtudW1iZXJ9IG9mZnNldCByYW5nZSBlbmQgb2Zmc2V0XG4gKiBAcGFyYW0ge3N0cmluZ30gY29udGV4dE5hbWUgY29udGV4dCBuYW1lXG4gKi9cblRva2VuaXplci5wcm90b3R5cGUuc2V0RW5kT2Zmc2V0ID0gZnVuY3Rpb24gKG9mZnNldCwgY29udGV4dE5hbWUpIHtcbiAgICB2YXIgc3RhcnRJbmRleCA9IHRoaXMuZ2V0Q29udGV4dChjb250ZXh0TmFtZSkub3BlblJhbmdlLnN0YXJ0SW5kZXg7XG4gICAgdmFyIHJhbmdlID0gbmV3IENvbnRleHRSYW5nZShzdGFydEluZGV4LCBvZmZzZXQsIGNvbnRleHROYW1lKTtcbiAgICB2YXIgcmFuZ2VzID0gdGhpcy5nZXRDb250ZXh0KGNvbnRleHROYW1lKS5yYW5nZXM7XG4gICAgcmFuZ2UucmFuZ2VJZCA9IGNvbnRleHROYW1lICsgXCIuXCIgKyAocmFuZ2VzLmxlbmd0aCk7XG4gICAgcmFuZ2VzLnB1c2gocmFuZ2UpO1xuICAgIHRoaXMuZ2V0Q29udGV4dChjb250ZXh0TmFtZSkub3BlblJhbmdlID0gbnVsbDtcbiAgICByZXR1cm4gcmFuZ2U7XG59O1xuXG4vKipcbiAqIFJ1bnMgYSBjb250ZXh0IGNoZWNrIG9uIHRoZSBjdXJyZW50IGNvbnRleHRcbiAqIEBwYXJhbSB7Y29udGV4dFBhcmFtc30gY29udGV4dFBhcmFtcyBjdXJyZW50IGNvbnRleHQgcGFyYW1zXG4gKi9cblRva2VuaXplci5wcm90b3R5cGUucnVuQ29udGV4dENoZWNrID0gZnVuY3Rpb24oY29udGV4dFBhcmFtcykge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gICAgdmFyIGluZGV4ID0gY29udGV4dFBhcmFtcy5pbmRleDtcbiAgICB0aGlzLmNvbnRleHRDaGVja2Vycy5mb3JFYWNoKGZ1bmN0aW9uIChjb250ZXh0Q2hlY2tlcikge1xuICAgICAgICB2YXIgY29udGV4dE5hbWUgPSBjb250ZXh0Q2hlY2tlci5jb250ZXh0TmFtZTtcbiAgICAgICAgdmFyIG9wZW5SYW5nZSA9IHRoaXMkMS5nZXRDb250ZXh0KGNvbnRleHROYW1lKS5vcGVuUmFuZ2U7XG4gICAgICAgIGlmICghb3BlblJhbmdlICYmIGNvbnRleHRDaGVja2VyLmNoZWNrU3RhcnQoY29udGV4dFBhcmFtcykpIHtcbiAgICAgICAgICAgIG9wZW5SYW5nZSA9IG5ldyBDb250ZXh0UmFuZ2UoaW5kZXgsIG51bGwsIGNvbnRleHROYW1lKTtcbiAgICAgICAgICAgIHRoaXMkMS5nZXRDb250ZXh0KGNvbnRleHROYW1lKS5vcGVuUmFuZ2UgPSBvcGVuUmFuZ2U7XG4gICAgICAgICAgICB0aGlzJDEuZGlzcGF0Y2goJ2NvbnRleHRTdGFydCcsIFtjb250ZXh0TmFtZSwgaW5kZXhdKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoISFvcGVuUmFuZ2UgJiYgY29udGV4dENoZWNrZXIuY2hlY2tFbmQoY29udGV4dFBhcmFtcykpIHtcbiAgICAgICAgICAgIHZhciBvZmZzZXQgPSAoaW5kZXggLSBvcGVuUmFuZ2Uuc3RhcnRJbmRleCkgKyAxO1xuICAgICAgICAgICAgdmFyIHJhbmdlID0gdGhpcyQxLnNldEVuZE9mZnNldChvZmZzZXQsIGNvbnRleHROYW1lKTtcbiAgICAgICAgICAgIHRoaXMkMS5kaXNwYXRjaCgnY29udGV4dEVuZCcsIFtjb250ZXh0TmFtZSwgcmFuZ2VdKTtcbiAgICAgICAgfVxuICAgIH0pO1xufTtcblxuLyoqXG4gKiBDb252ZXJ0cyBhIHRleHQgaW50byBhIGxpc3Qgb2YgdG9rZW5zXG4gKiBAcGFyYW0ge3N0cmluZ30gdGV4dCBhIHRleHQgdG8gdG9rZW5pemVcbiAqL1xuVG9rZW5pemVyLnByb3RvdHlwZS50b2tlbml6ZSA9IGZ1bmN0aW9uICh0ZXh0KSB7XG4gICAgdGhpcy50b2tlbnMgPSBbXTtcbiAgICB0aGlzLnJlc2V0Q29udGV4dHNSYW5nZXMoKTtcbiAgICB2YXIgY2hhcnMgPSBBcnJheS5mcm9tKHRleHQpO1xuICAgIHRoaXMuZGlzcGF0Y2goJ3N0YXJ0Jyk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaGFycy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgY2hhciA9IGNoYXJzW2ldO1xuICAgICAgICB2YXIgY29udGV4dFBhcmFtcyA9IG5ldyBDb250ZXh0UGFyYW1zKGNoYXJzLCBpKTtcbiAgICAgICAgdGhpcy5kaXNwYXRjaCgnbmV4dCcsIFtjb250ZXh0UGFyYW1zXSk7XG4gICAgICAgIHRoaXMucnVuQ29udGV4dENoZWNrKGNvbnRleHRQYXJhbXMpO1xuICAgICAgICB2YXIgdG9rZW4gPSBuZXcgVG9rZW4oY2hhcik7XG4gICAgICAgIHRoaXMudG9rZW5zLnB1c2godG9rZW4pO1xuICAgICAgICB0aGlzLmRpc3BhdGNoKCduZXdUb2tlbicsIFt0b2tlbiwgY29udGV4dFBhcmFtc10pO1xuICAgIH1cbiAgICB0aGlzLmRpc3BhdGNoKCdlbmQnLCBbdGhpcy50b2tlbnNdKTtcbiAgICByZXR1cm4gdGhpcy50b2tlbnM7XG59O1xuXG4vLyDila3ilIDilITilITilITilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilITilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDila5cbi8vIOKUiiBDaGFyYWN0ZXIgQ2xhc3MgQXNzZXJ0aW9ucyDilIogQ2hlY2tzIGlmIGEgY2hhciBiZWxvbmdzIHRvIGEgY2VydGFpbiBjbGFzcyDilIpcbi8vIOKVsOKUgOKVvuKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUhOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKVr1xuLy8ganNjczpkaXNhYmxlIG1heGltdW1MaW5lTGVuZ3RoXG4vKipcbiAqIENoZWNrIGlmIGEgY2hhciBpcyBBcmFiaWNcbiAqIEBwYXJhbSB7c3RyaW5nfSBjIGEgc2luZ2xlIGNoYXJcbiAqL1xuZnVuY3Rpb24gaXNBcmFiaWNDaGFyKGMpIHtcbiAgICByZXR1cm4gL1tcXHUwNjAwLVxcdTA2NUZcXHUwNjZBLVxcdTA2RDJcXHUwNkZBLVxcdTA2RkZdLy50ZXN0KGMpO1xufVxuXG4vKipcbiAqIENoZWNrIGlmIGEgY2hhciBpcyBhbiBpc29sYXRlZCBhcmFiaWMgY2hhclxuICogQHBhcmFtIHtzdHJpbmd9IGMgYSBzaW5nbGUgY2hhclxuICovXG5mdW5jdGlvbiBpc0lzb2xhdGVkQXJhYmljQ2hhcihjaGFyKSB7XG4gICAgcmV0dXJuIC9bXFx1MDYzMFxcdTA2OTBcXHUwNjIxXFx1MDYzMVxcdTA2NjFcXHUwNjcxXFx1MDYyMlxcdTA2MzJcXHUwNjcyXFx1MDY5MlxcdTA2QzJcXHUwNjIzXFx1MDY3M1xcdTA2OTNcXHUwNkMzXFx1MDYyNFxcdTA2OTRcXHUwNkM0XFx1MDYyNVxcdTA2NzVcXHUwNjk1XFx1MDZDNVxcdTA2RTVcXHUwNjc2XFx1MDY5NlxcdTA2QzZcXHUwNjI3XFx1MDY3N1xcdTA2OTdcXHUwNkM3XFx1MDY0OFxcdTA2ODhcXHUwNjk4XFx1MDZDOFxcdTA2ODlcXHUwNjk5XFx1MDZDOVxcdTA2OEFcXHUwNkNBXFx1MDY2QlxcdTA2OEJcXHUwNkNCXFx1MDY4Q1xcdTA2OERcXHUwNkNEXFx1MDZGRFxcdTA2OEVcXHUwNkVFXFx1MDZGRVxcdTA2MkZcXHUwNjhGXFx1MDZDRlxcdTA2RUZdLy50ZXN0KGNoYXIpO1xufVxuXG4vKipcbiAqIENoZWNrIGlmIGEgY2hhciBpcyBhbiBBcmFiaWMgVGFzaGtlZWwgY2hhclxuICogQHBhcmFtIHtzdHJpbmd9IGMgYSBzaW5nbGUgY2hhclxuICovXG5mdW5jdGlvbiBpc1Rhc2hrZWVsQXJhYmljQ2hhcihjaGFyKSB7XG4gICAgcmV0dXJuIC9bXFx1MDYwMC1cXHUwNjA1XFx1MDYwQy1cXHUwNjBFXFx1MDYxMC1cXHUwNjFCXFx1MDYxRVxcdTA2NEItXFx1MDY1RlxcdTA2NzBcXHUwNkQ2LVxcdTA2RENcXHUwNkRGLVxcdTA2RTRcXHUwNkU3XFx1MDZFOFxcdTA2RUEtXFx1MDZFRF0vLnRlc3QoY2hhcik7XG59XG5cbi8qKlxuICogQ2hlY2sgaWYgYSBjaGFyIGlzIExhdGluXG4gKiBAcGFyYW0ge3N0cmluZ30gYyBhIHNpbmdsZSBjaGFyXG4gKi9cbmZ1bmN0aW9uIGlzTGF0aW5DaGFyKGMpIHtcbiAgICByZXR1cm4gL1tBLXpdLy50ZXN0KGMpO1xufVxuXG4vKipcbiAqIENoZWNrIGlmIGEgY2hhciBpcyB3aGl0ZXNwYWNlIGNoYXJcbiAqIEBwYXJhbSB7c3RyaW5nfSBjIGEgc2luZ2xlIGNoYXJcbiAqL1xuZnVuY3Rpb24gaXNXaGl0ZVNwYWNlKGMpIHtcbiAgICByZXR1cm4gL1xccy8udGVzdChjKTtcbn1cblxuLyoqXG4gKiBRdWVyeSBhIGZlYXR1cmUgYnkgc29tZSBvZiBpdCdzIHByb3BlcnRpZXMgdG8gbG9va3VwIGEgZ2x5cGggc3Vic3RpdHV0aW9uLlxuICovXG5cbi8qKlxuICogQ3JlYXRlIGZlYXR1cmUgcXVlcnkgaW5zdGFuY2VcbiAqIEBwYXJhbSB7Rm9udH0gZm9udCBvcGVudHlwZSBmb250IGluc3RhbmNlXG4gKi9cbmZ1bmN0aW9uIEZlYXR1cmVRdWVyeShmb250KSB7XG4gICAgdGhpcy5mb250ID0gZm9udDtcbiAgICB0aGlzLmZlYXR1cmVzID0ge307XG59XG5cbi8qKlxuICogQHR5cGVkZWYgU3Vic3RpdHV0aW9uQWN0aW9uXG4gKiBAdHlwZSBPYmplY3RcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBpZCBzdWJzdGl0dXRpb24gdHlwZVxuICogQHByb3BlcnR5IHtzdHJpbmd9IHRhZyBmZWF0dXJlIHRhZ1xuICogQHByb3BlcnR5IHthbnl9IHN1YnN0aXR1dGlvbiBzdWJzdGl0dXRpb24gdmFsdWUocylcbiAqL1xuXG4vKipcbiAqIENyZWF0ZSBhIHN1YnN0aXR1dGlvbiBhY3Rpb24gaW5zdGFuY2VcbiAqIEBwYXJhbSB7U3Vic3RpdHV0aW9uQWN0aW9ufSBhY3Rpb25cbiAqL1xuZnVuY3Rpb24gU3Vic3RpdHV0aW9uQWN0aW9uKGFjdGlvbikge1xuICAgIHRoaXMuaWQgPSBhY3Rpb24uaWQ7XG4gICAgdGhpcy50YWcgPSBhY3Rpb24udGFnO1xuICAgIHRoaXMuc3Vic3RpdHV0aW9uID0gYWN0aW9uLnN1YnN0aXR1dGlvbjtcbn1cblxuLyoqXG4gKiBMb29rdXAgYSBjb3ZlcmFnZSB0YWJsZVxuICogQHBhcmFtIHtudW1iZXJ9IGdseXBoSW5kZXggZ2x5cGggaW5kZXhcbiAqIEBwYXJhbSB7Q292ZXJhZ2VUYWJsZX0gY292ZXJhZ2UgY292ZXJhZ2UgdGFibGVcbiAqL1xuZnVuY3Rpb24gbG9va3VwQ292ZXJhZ2UoZ2x5cGhJbmRleCwgY292ZXJhZ2UpIHtcbiAgICBpZiAoIWdseXBoSW5kZXgpIHsgcmV0dXJuIC0xOyB9XG4gICAgc3dpdGNoIChjb3ZlcmFnZS5mb3JtYXQpIHtcbiAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgcmV0dXJuIGNvdmVyYWdlLmdseXBocy5pbmRleE9mKGdseXBoSW5kZXgpO1xuXG4gICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgIHZhciByYW5nZXMgPSBjb3ZlcmFnZS5yYW5nZXM7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHJhbmdlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIHZhciByYW5nZSA9IHJhbmdlc1tpXTtcbiAgICAgICAgICAgICAgICBpZiAoZ2x5cGhJbmRleCA+PSByYW5nZS5zdGFydCAmJiBnbHlwaEluZGV4IDw9IHJhbmdlLmVuZCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgb2Zmc2V0ID0gZ2x5cGhJbmRleCAtIHJhbmdlLnN0YXJ0O1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmFuZ2UuaW5kZXggKyBvZmZzZXQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICByZXR1cm4gLTE7IC8vIG5vdCBmb3VuZFxuICAgIH1cbiAgICByZXR1cm4gLTE7XG59XG5cbi8qKlxuICogSGFuZGxlIGEgc2luZ2xlIHN1YnN0aXR1dGlvbiAtIGZvcm1hdCAxXG4gKiBAcGFyYW0ge0NvbnRleHRQYXJhbXN9IGNvbnRleHRQYXJhbXMgY29udGV4dCBwYXJhbXMgdG8gbG9va3VwXG4gKi9cbmZ1bmN0aW9uIHNpbmdsZVN1YnN0aXR1dGlvbkZvcm1hdDEoZ2x5cGhJbmRleCwgc3VidGFibGUpIHtcbiAgICB2YXIgc3Vic3RpdHV0ZUluZGV4ID0gbG9va3VwQ292ZXJhZ2UoZ2x5cGhJbmRleCwgc3VidGFibGUuY292ZXJhZ2UpO1xuICAgIGlmIChzdWJzdGl0dXRlSW5kZXggPT09IC0xKSB7IHJldHVybiBudWxsOyB9XG4gICAgcmV0dXJuIGdseXBoSW5kZXggKyBzdWJ0YWJsZS5kZWx0YUdseXBoSWQ7XG59XG5cbi8qKlxuICogSGFuZGxlIGEgc2luZ2xlIHN1YnN0aXR1dGlvbiAtIGZvcm1hdCAyXG4gKiBAcGFyYW0ge0NvbnRleHRQYXJhbXN9IGNvbnRleHRQYXJhbXMgY29udGV4dCBwYXJhbXMgdG8gbG9va3VwXG4gKi9cbmZ1bmN0aW9uIHNpbmdsZVN1YnN0aXR1dGlvbkZvcm1hdDIoZ2x5cGhJbmRleCwgc3VidGFibGUpIHtcbiAgICB2YXIgc3Vic3RpdHV0ZUluZGV4ID0gbG9va3VwQ292ZXJhZ2UoZ2x5cGhJbmRleCwgc3VidGFibGUuY292ZXJhZ2UpO1xuICAgIGlmIChzdWJzdGl0dXRlSW5kZXggPT09IC0xKSB7IHJldHVybiBudWxsOyB9XG4gICAgcmV0dXJuIHN1YnRhYmxlLnN1YnN0aXR1dGVbc3Vic3RpdHV0ZUluZGV4XTtcbn1cblxuLyoqXG4gKiBMb29rdXAgYSBsaXN0IG9mIGNvdmVyYWdlIHRhYmxlc1xuICogQHBhcmFtIHthbnl9IGNvdmVyYWdlTGlzdCBhIGxpc3Qgb2YgY292ZXJhZ2UgdGFibGVzXG4gKiBAcGFyYW0ge0NvbnRleHRQYXJhbXN9IGNvbnRleHRQYXJhbXMgY29udGV4dCBwYXJhbXMgdG8gbG9va3VwXG4gKi9cbmZ1bmN0aW9uIGxvb2t1cENvdmVyYWdlTGlzdChjb3ZlcmFnZUxpc3QsIGNvbnRleHRQYXJhbXMpIHtcbiAgICB2YXIgbG9va3VwTGlzdCA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY292ZXJhZ2VMaXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBjb3ZlcmFnZSA9IGNvdmVyYWdlTGlzdFtpXTtcbiAgICAgICAgdmFyIGdseXBoSW5kZXggPSBjb250ZXh0UGFyYW1zLmN1cnJlbnQ7XG4gICAgICAgIGdseXBoSW5kZXggPSBBcnJheS5pc0FycmF5KGdseXBoSW5kZXgpID8gZ2x5cGhJbmRleFswXSA6IGdseXBoSW5kZXg7XG4gICAgICAgIHZhciBsb29rdXBJbmRleCA9IGxvb2t1cENvdmVyYWdlKGdseXBoSW5kZXgsIGNvdmVyYWdlKTtcbiAgICAgICAgaWYgKGxvb2t1cEluZGV4ICE9PSAtMSkge1xuICAgICAgICAgICAgbG9va3VwTGlzdC5wdXNoKGxvb2t1cEluZGV4KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAobG9va3VwTGlzdC5sZW5ndGggIT09IGNvdmVyYWdlTGlzdC5sZW5ndGgpIHsgcmV0dXJuIC0xOyB9XG4gICAgcmV0dXJuIGxvb2t1cExpc3Q7XG59XG5cbi8qKlxuICogSGFuZGxlIGNoYWluaW5nIGNvbnRleHQgc3Vic3RpdHV0aW9uIC0gZm9ybWF0IDNcbiAqIEBwYXJhbSB7Q29udGV4dFBhcmFtc30gY29udGV4dFBhcmFtcyBjb250ZXh0IHBhcmFtcyB0byBsb29rdXBcbiAqL1xuZnVuY3Rpb24gY2hhaW5pbmdTdWJzdGl0dXRpb25Gb3JtYXQzKGNvbnRleHRQYXJhbXMsIHN1YnRhYmxlKSB7XG4gICAgdmFyIGxvb2t1cHNDb3VudCA9IChcbiAgICAgICAgc3VidGFibGUuaW5wdXRDb3ZlcmFnZS5sZW5ndGggK1xuICAgICAgICBzdWJ0YWJsZS5sb29rYWhlYWRDb3ZlcmFnZS5sZW5ndGggK1xuICAgICAgICBzdWJ0YWJsZS5iYWNrdHJhY2tDb3ZlcmFnZS5sZW5ndGhcbiAgICApO1xuICAgIGlmIChjb250ZXh0UGFyYW1zLmNvbnRleHQubGVuZ3RoIDwgbG9va3Vwc0NvdW50KSB7IHJldHVybiBbXTsgfVxuICAgIC8vIElOUFVUIExPT0tVUCAvL1xuICAgIHZhciBpbnB1dExvb2t1cHMgPSBsb29rdXBDb3ZlcmFnZUxpc3QoXG4gICAgICAgIHN1YnRhYmxlLmlucHV0Q292ZXJhZ2UsIGNvbnRleHRQYXJhbXNcbiAgICApO1xuICAgIGlmIChpbnB1dExvb2t1cHMgPT09IC0xKSB7IHJldHVybiBbXTsgfVxuICAgIC8vIExPT0tBSEVBRCBMT09LVVAgLy9cbiAgICB2YXIgbG9va2FoZWFkT2Zmc2V0ID0gc3VidGFibGUuaW5wdXRDb3ZlcmFnZS5sZW5ndGggLSAxO1xuICAgIGlmIChjb250ZXh0UGFyYW1zLmxvb2thaGVhZC5sZW5ndGggPCBzdWJ0YWJsZS5sb29rYWhlYWRDb3ZlcmFnZS5sZW5ndGgpIHsgcmV0dXJuIFtdOyB9XG4gICAgdmFyIGxvb2thaGVhZENvbnRleHQgPSBjb250ZXh0UGFyYW1zLmxvb2thaGVhZC5zbGljZShsb29rYWhlYWRPZmZzZXQpO1xuICAgIHdoaWxlIChsb29rYWhlYWRDb250ZXh0Lmxlbmd0aCAmJiBpc1Rhc2hrZWVsQXJhYmljQ2hhcihsb29rYWhlYWRDb250ZXh0WzBdLmNoYXIpKSB7XG4gICAgICAgIGxvb2thaGVhZENvbnRleHQuc2hpZnQoKTtcbiAgICB9XG4gICAgdmFyIGxvb2thaGVhZFBhcmFtcyA9IG5ldyBDb250ZXh0UGFyYW1zKGxvb2thaGVhZENvbnRleHQsIDApO1xuICAgIHZhciBsb29rYWhlYWRMb29rdXBzID0gbG9va3VwQ292ZXJhZ2VMaXN0KFxuICAgICAgICBzdWJ0YWJsZS5sb29rYWhlYWRDb3ZlcmFnZSwgbG9va2FoZWFkUGFyYW1zXG4gICAgKTtcbiAgICAvLyBCQUNLVFJBQ0sgTE9PS1VQIC8vXG4gICAgdmFyIGJhY2t0cmFja0NvbnRleHQgPSBbXS5jb25jYXQoY29udGV4dFBhcmFtcy5iYWNrdHJhY2spO1xuICAgIGJhY2t0cmFja0NvbnRleHQucmV2ZXJzZSgpO1xuICAgIHdoaWxlIChiYWNrdHJhY2tDb250ZXh0Lmxlbmd0aCAmJiBpc1Rhc2hrZWVsQXJhYmljQ2hhcihiYWNrdHJhY2tDb250ZXh0WzBdLmNoYXIpKSB7XG4gICAgICAgIGJhY2t0cmFja0NvbnRleHQuc2hpZnQoKTtcbiAgICB9XG4gICAgaWYgKGJhY2t0cmFja0NvbnRleHQubGVuZ3RoIDwgc3VidGFibGUuYmFja3RyYWNrQ292ZXJhZ2UubGVuZ3RoKSB7IHJldHVybiBbXTsgfVxuICAgIHZhciBiYWNrdHJhY2tQYXJhbXMgPSBuZXcgQ29udGV4dFBhcmFtcyhiYWNrdHJhY2tDb250ZXh0LCAwKTtcbiAgICB2YXIgYmFja3RyYWNrTG9va3VwcyA9IGxvb2t1cENvdmVyYWdlTGlzdChcbiAgICAgICAgc3VidGFibGUuYmFja3RyYWNrQ292ZXJhZ2UsIGJhY2t0cmFja1BhcmFtc1xuICAgICk7XG4gICAgdmFyIGNvbnRleHRSdWxlc01hdGNoID0gKFxuICAgICAgICBpbnB1dExvb2t1cHMubGVuZ3RoID09PSBzdWJ0YWJsZS5pbnB1dENvdmVyYWdlLmxlbmd0aCAmJlxuICAgICAgICBsb29rYWhlYWRMb29rdXBzLmxlbmd0aCA9PT0gc3VidGFibGUubG9va2FoZWFkQ292ZXJhZ2UubGVuZ3RoICYmXG4gICAgICAgIGJhY2t0cmFja0xvb2t1cHMubGVuZ3RoID09PSBzdWJ0YWJsZS5iYWNrdHJhY2tDb3ZlcmFnZS5sZW5ndGhcbiAgICApO1xuICAgIHZhciBzdWJzdGl0dXRpb25zID0gW107XG4gICAgaWYgKGNvbnRleHRSdWxlc01hdGNoKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc3VidGFibGUubG9va3VwUmVjb3Jkcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIGxvb2t1cFJlY29yZCA9IHN1YnRhYmxlLmxvb2t1cFJlY29yZHNbaV07XG4gICAgICAgICAgICB2YXIgbG9va3VwTGlzdEluZGV4ID0gbG9va3VwUmVjb3JkLmxvb2t1cExpc3RJbmRleDtcbiAgICAgICAgICAgIHZhciBsb29rdXBUYWJsZSA9IHRoaXMuZ2V0TG9va3VwQnlJbmRleChsb29rdXBMaXN0SW5kZXgpO1xuICAgICAgICAgICAgZm9yICh2YXIgcyA9IDA7IHMgPCBsb29rdXBUYWJsZS5zdWJ0YWJsZXMubGVuZ3RoOyBzKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgc3VidGFibGUkMSA9IGxvb2t1cFRhYmxlLnN1YnRhYmxlc1tzXTtcbiAgICAgICAgICAgICAgICB2YXIgbG9va3VwID0gdGhpcy5nZXRMb29rdXBNZXRob2QobG9va3VwVGFibGUsIHN1YnRhYmxlJDEpO1xuICAgICAgICAgICAgICAgIHZhciBzdWJzdGl0dXRpb25UeXBlID0gdGhpcy5nZXRTdWJzdGl0dXRpb25UeXBlKGxvb2t1cFRhYmxlLCBzdWJ0YWJsZSQxKTtcbiAgICAgICAgICAgICAgICBpZiAoc3Vic3RpdHV0aW9uVHlwZSA9PT0gJzEyJykge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBuID0gMDsgbiA8IGlucHV0TG9va3Vwcy5sZW5ndGg7IG4rKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGdseXBoSW5kZXggPSBjb250ZXh0UGFyYW1zLmdldChuKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzdWJzdGl0dXRpb24gPSBsb29rdXAoZ2x5cGhJbmRleCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoc3Vic3RpdHV0aW9uKSB7IHN1YnN0aXR1dGlvbnMucHVzaChzdWJzdGl0dXRpb24pOyB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHN1YnN0aXR1dGlvbnM7XG59XG5cbi8qKlxuICogSGFuZGxlIGxpZ2F0dXJlIHN1YnN0aXR1dGlvbiAtIGZvcm1hdCAxXG4gKiBAcGFyYW0ge0NvbnRleHRQYXJhbXN9IGNvbnRleHRQYXJhbXMgY29udGV4dCBwYXJhbXMgdG8gbG9va3VwXG4gKi9cbmZ1bmN0aW9uIGxpZ2F0dXJlU3Vic3RpdHV0aW9uRm9ybWF0MShjb250ZXh0UGFyYW1zLCBzdWJ0YWJsZSkge1xuICAgIC8vIENPVkVSQUdFIExPT0tVUCAvL1xuICAgIHZhciBnbHlwaEluZGV4ID0gY29udGV4dFBhcmFtcy5jdXJyZW50O1xuICAgIHZhciBsaWdTZXRJbmRleCA9IGxvb2t1cENvdmVyYWdlKGdseXBoSW5kZXgsIHN1YnRhYmxlLmNvdmVyYWdlKTtcbiAgICBpZiAobGlnU2V0SW5kZXggPT09IC0xKSB7IHJldHVybiBudWxsOyB9XG4gICAgLy8gQ09NUE9ORU5UUyBMT09LVVBcbiAgICAvLyAoISkgbm90ZSwgY29tcG9uZW50cyBhcmUgb3JkZXJlZCBpbiB0aGUgd3JpdHRlbiBkaXJlY3Rpb24uXG4gICAgdmFyIGxpZ2F0dXJlO1xuICAgIHZhciBsaWdhdHVyZVNldCA9IHN1YnRhYmxlLmxpZ2F0dXJlU2V0c1tsaWdTZXRJbmRleF07XG4gICAgZm9yICh2YXIgcyA9IDA7IHMgPCBsaWdhdHVyZVNldC5sZW5ndGg7IHMrKykge1xuICAgICAgICBsaWdhdHVyZSA9IGxpZ2F0dXJlU2V0W3NdO1xuICAgICAgICBmb3IgKHZhciBsID0gMDsgbCA8IGxpZ2F0dXJlLmNvbXBvbmVudHMubGVuZ3RoOyBsKyspIHtcbiAgICAgICAgICAgIHZhciBsb29rYWhlYWRJdGVtID0gY29udGV4dFBhcmFtcy5sb29rYWhlYWRbbF07XG4gICAgICAgICAgICB2YXIgY29tcG9uZW50ID0gbGlnYXR1cmUuY29tcG9uZW50c1tsXTtcbiAgICAgICAgICAgIGlmIChsb29rYWhlYWRJdGVtICE9PSBjb21wb25lbnQpIHsgYnJlYWs7IH1cbiAgICAgICAgICAgIGlmIChsID09PSBsaWdhdHVyZS5jb21wb25lbnRzLmxlbmd0aCAtIDEpIHsgcmV0dXJuIGxpZ2F0dXJlOyB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG59XG5cbi8qKlxuICogSGFuZGxlIGRlY29tcG9zaXRpb24gc3Vic3RpdHV0aW9uIC0gZm9ybWF0IDFcbiAqIEBwYXJhbSB7bnVtYmVyfSBnbHlwaEluZGV4IGdseXBoIGluZGV4XG4gKiBAcGFyYW0ge2FueX0gc3VidGFibGUgc3VidGFibGVcbiAqL1xuZnVuY3Rpb24gZGVjb21wb3NpdGlvblN1YnN0aXR1dGlvbkZvcm1hdDEoZ2x5cGhJbmRleCwgc3VidGFibGUpIHtcbiAgICB2YXIgc3Vic3RpdHV0ZUluZGV4ID0gbG9va3VwQ292ZXJhZ2UoZ2x5cGhJbmRleCwgc3VidGFibGUuY292ZXJhZ2UpO1xuICAgIGlmIChzdWJzdGl0dXRlSW5kZXggPT09IC0xKSB7IHJldHVybiBudWxsOyB9XG4gICAgcmV0dXJuIHN1YnRhYmxlLnNlcXVlbmNlc1tzdWJzdGl0dXRlSW5kZXhdO1xufVxuXG4vKipcbiAqIEdldCBkZWZhdWx0IHNjcmlwdCBmZWF0dXJlcyBpbmRleGVzXG4gKi9cbkZlYXR1cmVRdWVyeS5wcm90b3R5cGUuZ2V0RGVmYXVsdFNjcmlwdEZlYXR1cmVzSW5kZXhlcyA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgc2NyaXB0cyA9IHRoaXMuZm9udC50YWJsZXMuZ3N1Yi5zY3JpcHRzO1xuICAgIGZvciAodmFyIHMgPSAwOyBzIDwgc2NyaXB0cy5sZW5ndGg7IHMrKykge1xuICAgICAgICB2YXIgc2NyaXB0ID0gc2NyaXB0c1tzXTtcbiAgICAgICAgaWYgKHNjcmlwdC50YWcgPT09ICdERkxUJykgeyByZXR1cm4gKFxuICAgICAgICAgICAgc2NyaXB0LnNjcmlwdC5kZWZhdWx0TGFuZ1N5cy5mZWF0dXJlSW5kZXhlc1xuICAgICAgICApOyB9XG4gICAgfVxuICAgIHJldHVybiBbXTtcbn07XG5cbi8qKlxuICogR2V0IGZlYXR1cmUgaW5kZXhlcyBvZiBhIHNwZWNpZmljIHNjcmlwdFxuICogQHBhcmFtIHtzdHJpbmd9IHNjcmlwdFRhZyBzY3JpcHQgdGFnXG4gKi9cbkZlYXR1cmVRdWVyeS5wcm90b3R5cGUuZ2V0U2NyaXB0RmVhdHVyZXNJbmRleGVzID0gZnVuY3Rpb24oc2NyaXB0VGFnKSB7XG4gICAgdmFyIHRhYmxlcyA9IHRoaXMuZm9udC50YWJsZXM7XG4gICAgaWYgKCF0YWJsZXMuZ3N1YikgeyByZXR1cm4gW107IH1cbiAgICBpZiAoIXNjcmlwdFRhZykgeyByZXR1cm4gdGhpcy5nZXREZWZhdWx0U2NyaXB0RmVhdHVyZXNJbmRleGVzKCk7IH1cbiAgICB2YXIgc2NyaXB0cyA9IHRoaXMuZm9udC50YWJsZXMuZ3N1Yi5zY3JpcHRzO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2NyaXB0cy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgc2NyaXB0ID0gc2NyaXB0c1tpXTtcbiAgICAgICAgaWYgKHNjcmlwdC50YWcgPT09IHNjcmlwdFRhZyAmJiBzY3JpcHQuc2NyaXB0LmRlZmF1bHRMYW5nU3lzKSB7XG4gICAgICAgICAgICByZXR1cm4gc2NyaXB0LnNjcmlwdC5kZWZhdWx0TGFuZ1N5cy5mZWF0dXJlSW5kZXhlcztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhciBsYW5nU3lzUmVjb3JkcyA9IHNjcmlwdC5sYW5nU3lzUmVjb3JkcztcbiAgICAgICAgICAgIGlmICghIWxhbmdTeXNSZWNvcmRzKSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBsYW5nU3lzUmVjb3Jkcy5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgbGFuZ1N5c1JlY29yZCA9IGxhbmdTeXNSZWNvcmRzW2pdO1xuICAgICAgICAgICAgICAgICAgICBpZiAobGFuZ1N5c1JlY29yZC50YWcgPT09IHNjcmlwdFRhZykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGxhbmdTeXMgPSBsYW5nU3lzUmVjb3JkLmxhbmdTeXM7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbGFuZ1N5cy5mZWF0dXJlSW5kZXhlcztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdGhpcy5nZXREZWZhdWx0U2NyaXB0RmVhdHVyZXNJbmRleGVzKCk7XG59O1xuXG4vKipcbiAqIE1hcCBhIGZlYXR1cmUgdGFnIHRvIGEgZ3N1YiBmZWF0dXJlXG4gKiBAcGFyYW0ge2FueX0gZmVhdHVyZXMgZ3N1YiBmZWF0dXJlc1xuICogQHBhcmFtIHtzdHJpbmd9IHNjcmlwdFRhZyBzY3JpcHQgdGFnXG4gKi9cbkZlYXR1cmVRdWVyeS5wcm90b3R5cGUubWFwVGFnc1RvRmVhdHVyZXMgPSBmdW5jdGlvbiAoZmVhdHVyZXMsIHNjcmlwdFRhZykge1xuICAgIHZhciB0YWdzID0ge307XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBmZWF0dXJlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgdGFnID0gZmVhdHVyZXNbaV0udGFnO1xuICAgICAgICB2YXIgZmVhdHVyZSA9IGZlYXR1cmVzW2ldLmZlYXR1cmU7XG4gICAgICAgIHRhZ3NbdGFnXSA9IGZlYXR1cmU7XG4gICAgfVxuICAgIHRoaXMuZmVhdHVyZXNbc2NyaXB0VGFnXS50YWdzID0gdGFncztcbn07XG5cbi8qKlxuICogR2V0IGZlYXR1cmVzIG9mIGEgc3BlY2lmaWMgc2NyaXB0XG4gKiBAcGFyYW0ge3N0cmluZ30gc2NyaXB0VGFnIHNjcmlwdCB0YWdcbiAqL1xuRmVhdHVyZVF1ZXJ5LnByb3RvdHlwZS5nZXRTY3JpcHRGZWF0dXJlcyA9IGZ1bmN0aW9uIChzY3JpcHRUYWcpIHtcbiAgICB2YXIgZmVhdHVyZXMgPSB0aGlzLmZlYXR1cmVzW3NjcmlwdFRhZ107XG4gICAgaWYgKHRoaXMuZmVhdHVyZXMuaGFzT3duUHJvcGVydHkoc2NyaXB0VGFnKSkgeyByZXR1cm4gZmVhdHVyZXM7IH1cbiAgICB2YXIgZmVhdHVyZXNJbmRleGVzID0gdGhpcy5nZXRTY3JpcHRGZWF0dXJlc0luZGV4ZXMoc2NyaXB0VGFnKTtcbiAgICBpZiAoIWZlYXR1cmVzSW5kZXhlcykgeyByZXR1cm4gbnVsbDsgfVxuICAgIHZhciBnc3ViID0gdGhpcy5mb250LnRhYmxlcy5nc3ViO1xuICAgIGZlYXR1cmVzID0gZmVhdHVyZXNJbmRleGVzLm1hcChmdW5jdGlvbiAoaW5kZXgpIHsgcmV0dXJuIGdzdWIuZmVhdHVyZXNbaW5kZXhdOyB9KTtcbiAgICB0aGlzLmZlYXR1cmVzW3NjcmlwdFRhZ10gPSBmZWF0dXJlcztcbiAgICB0aGlzLm1hcFRhZ3NUb0ZlYXR1cmVzKGZlYXR1cmVzLCBzY3JpcHRUYWcpO1xuICAgIHJldHVybiBmZWF0dXJlcztcbn07XG5cbi8qKlxuICogR2V0IHN1YnN0aXR1dGlvbiB0eXBlXG4gKiBAcGFyYW0ge2FueX0gbG9va3VwVGFibGUgbG9va3VwIHRhYmxlXG4gKiBAcGFyYW0ge2FueX0gc3VidGFibGUgc3VidGFibGVcbiAqL1xuRmVhdHVyZVF1ZXJ5LnByb3RvdHlwZS5nZXRTdWJzdGl0dXRpb25UeXBlID0gZnVuY3Rpb24obG9va3VwVGFibGUsIHN1YnRhYmxlKSB7XG4gICAgdmFyIGxvb2t1cFR5cGUgPSBsb29rdXBUYWJsZS5sb29rdXBUeXBlLnRvU3RyaW5nKCk7XG4gICAgdmFyIHN1YnN0Rm9ybWF0ID0gc3VidGFibGUuc3Vic3RGb3JtYXQudG9TdHJpbmcoKTtcbiAgICByZXR1cm4gbG9va3VwVHlwZSArIHN1YnN0Rm9ybWF0O1xufTtcblxuLyoqXG4gKiBHZXQgbG9va3VwIG1ldGhvZFxuICogQHBhcmFtIHthbnl9IGxvb2t1cFRhYmxlIGxvb2t1cCB0YWJsZVxuICogQHBhcmFtIHthbnl9IHN1YnRhYmxlIHN1YnRhYmxlXG4gKi9cbkZlYXR1cmVRdWVyeS5wcm90b3R5cGUuZ2V0TG9va3VwTWV0aG9kID0gZnVuY3Rpb24obG9va3VwVGFibGUsIHN1YnRhYmxlKSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgICB2YXIgc3Vic3RpdHV0aW9uVHlwZSA9IHRoaXMuZ2V0U3Vic3RpdHV0aW9uVHlwZShsb29rdXBUYWJsZSwgc3VidGFibGUpO1xuICAgIHN3aXRjaCAoc3Vic3RpdHV0aW9uVHlwZSkge1xuICAgICAgICBjYXNlICcxMSc6XG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGdseXBoSW5kZXgpIHsgcmV0dXJuIHNpbmdsZVN1YnN0aXR1dGlvbkZvcm1hdDEuYXBwbHkoXG4gICAgICAgICAgICAgICAgdGhpcyQxLCBbZ2x5cGhJbmRleCwgc3VidGFibGVdXG4gICAgICAgICAgICApOyB9O1xuICAgICAgICBjYXNlICcxMic6XG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGdseXBoSW5kZXgpIHsgcmV0dXJuIHNpbmdsZVN1YnN0aXR1dGlvbkZvcm1hdDIuYXBwbHkoXG4gICAgICAgICAgICAgICAgdGhpcyQxLCBbZ2x5cGhJbmRleCwgc3VidGFibGVdXG4gICAgICAgICAgICApOyB9O1xuICAgICAgICBjYXNlICc2Myc6XG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGNvbnRleHRQYXJhbXMpIHsgcmV0dXJuIGNoYWluaW5nU3Vic3RpdHV0aW9uRm9ybWF0My5hcHBseShcbiAgICAgICAgICAgICAgICB0aGlzJDEsIFtjb250ZXh0UGFyYW1zLCBzdWJ0YWJsZV1cbiAgICAgICAgICAgICk7IH07XG4gICAgICAgIGNhc2UgJzQxJzpcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoY29udGV4dFBhcmFtcykgeyByZXR1cm4gbGlnYXR1cmVTdWJzdGl0dXRpb25Gb3JtYXQxLmFwcGx5KFxuICAgICAgICAgICAgICAgIHRoaXMkMSwgW2NvbnRleHRQYXJhbXMsIHN1YnRhYmxlXVxuICAgICAgICAgICAgKTsgfTtcbiAgICAgICAgY2FzZSAnMjEnOlxuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChnbHlwaEluZGV4KSB7IHJldHVybiBkZWNvbXBvc2l0aW9uU3Vic3RpdHV0aW9uRm9ybWF0MS5hcHBseShcbiAgICAgICAgICAgICAgICB0aGlzJDEsIFtnbHlwaEluZGV4LCBzdWJ0YWJsZV1cbiAgICAgICAgICAgICk7IH07XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgICAgICAgXCJsb29rdXBUeXBlOiBcIiArIChsb29rdXBUYWJsZS5sb29rdXBUeXBlKSArIFwiIC0gXCIgK1xuICAgICAgICAgICAgICAgIFwic3Vic3RGb3JtYXQ6IFwiICsgKHN1YnRhYmxlLnN1YnN0Rm9ybWF0KSArIFwiIFwiICtcbiAgICAgICAgICAgICAgICBcImlzIG5vdCB5ZXQgc3VwcG9ydGVkXCJcbiAgICAgICAgICAgICk7XG4gICAgfVxufTtcblxuLyoqXG4gKiBbIExPT0tVUCBUWVBFUyBdXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiBTaW5nbGUgICAgICAgICAgICAgICAgICAgICAgICAxO1xuICogTXVsdGlwbGUgICAgICAgICAgICAgICAgICAgICAgMjtcbiAqIEFsdGVybmF0ZSAgICAgICAgICAgICAgICAgICAgIDM7XG4gKiBMaWdhdHVyZSAgICAgICAgICAgICAgICAgICAgICA0O1xuICogQ29udGV4dCAgICAgICAgICAgICAgICAgICAgICAgNTtcbiAqIENoYWluaW5nQ29udGV4dCAgICAgICAgICAgICAgIDY7XG4gKiBFeHRlbnNpb25TdWJzdGl0dXRpb24gICAgICAgICA3O1xuICogUmV2ZXJzZUNoYWluaW5nQ29udGV4dCAgICAgICAgODtcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqXG4gKi9cblxuLyoqXG4gKiBAdHlwZWRlZiBGUXVlcnlcbiAqIEB0eXBlIE9iamVjdFxuICogQHBhcmFtIHtzdHJpbmd9IHRhZyBmZWF0dXJlIHRhZ1xuICogQHBhcmFtIHtzdHJpbmd9IHNjcmlwdCBmZWF0dXJlIHNjcmlwdFxuICogQHBhcmFtIHtDb250ZXh0UGFyYW1zfSBjb250ZXh0UGFyYW1zIGNvbnRleHQgcGFyYW1zXG4gKi9cblxuLyoqXG4gKiBMb29rdXAgYSBmZWF0dXJlIHVzaW5nIGEgcXVlcnkgcGFyYW1ldGVyc1xuICogQHBhcmFtIHtGUXVlcnl9IHF1ZXJ5IGZlYXR1cmUgcXVlcnlcbiAqL1xuRmVhdHVyZVF1ZXJ5LnByb3RvdHlwZS5sb29rdXBGZWF0dXJlID0gZnVuY3Rpb24gKHF1ZXJ5KSB7XG4gICAgdmFyIGNvbnRleHRQYXJhbXMgPSBxdWVyeS5jb250ZXh0UGFyYW1zO1xuICAgIHZhciBjdXJyZW50SW5kZXggPSBjb250ZXh0UGFyYW1zLmluZGV4O1xuICAgIHZhciBmZWF0dXJlID0gdGhpcy5nZXRGZWF0dXJlKHtcbiAgICAgICAgdGFnOiBxdWVyeS50YWcsIHNjcmlwdDogcXVlcnkuc2NyaXB0XG4gICAgfSk7XG4gICAgaWYgKCFmZWF0dXJlKSB7IHJldHVybiBuZXcgRXJyb3IoXG4gICAgICAgIFwiZm9udCAnXCIgKyAodGhpcy5mb250Lm5hbWVzLmZ1bGxOYW1lLmVuKSArIFwiJyBcIiArXG4gICAgICAgIFwiZG9lc24ndCBzdXBwb3J0IGZlYXR1cmUgJ1wiICsgKHF1ZXJ5LnRhZykgKyBcIicgXCIgK1xuICAgICAgICBcImZvciBzY3JpcHQgJ1wiICsgKHF1ZXJ5LnNjcmlwdCkgKyBcIicuXCJcbiAgICApOyB9XG4gICAgdmFyIGxvb2t1cHMgPSB0aGlzLmdldEZlYXR1cmVMb29rdXBzKGZlYXR1cmUpO1xuICAgIHZhciBzdWJzdGl0dXRpb25zID0gW10uY29uY2F0KGNvbnRleHRQYXJhbXMuY29udGV4dCk7XG4gICAgZm9yICh2YXIgbCA9IDA7IGwgPCBsb29rdXBzLmxlbmd0aDsgbCsrKSB7XG4gICAgICAgIHZhciBsb29rdXBUYWJsZSA9IGxvb2t1cHNbbF07XG4gICAgICAgIHZhciBzdWJ0YWJsZXMgPSB0aGlzLmdldExvb2t1cFN1YnRhYmxlcyhsb29rdXBUYWJsZSk7XG4gICAgICAgIGZvciAodmFyIHMgPSAwOyBzIDwgc3VidGFibGVzLmxlbmd0aDsgcysrKSB7XG4gICAgICAgICAgICB2YXIgc3VidGFibGUgPSBzdWJ0YWJsZXNbc107XG4gICAgICAgICAgICB2YXIgc3Vic3RUeXBlID0gdGhpcy5nZXRTdWJzdGl0dXRpb25UeXBlKGxvb2t1cFRhYmxlLCBzdWJ0YWJsZSk7XG4gICAgICAgICAgICB2YXIgbG9va3VwID0gdGhpcy5nZXRMb29rdXBNZXRob2QobG9va3VwVGFibGUsIHN1YnRhYmxlKTtcbiAgICAgICAgICAgIHZhciBzdWJzdGl0dXRpb24gPSAodm9pZCAwKTtcbiAgICAgICAgICAgIHN3aXRjaCAoc3Vic3RUeXBlKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAnMTEnOlxuICAgICAgICAgICAgICAgICAgICBzdWJzdGl0dXRpb24gPSBsb29rdXAoY29udGV4dFBhcmFtcy5jdXJyZW50KTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHN1YnN0aXR1dGlvbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3Vic3RpdHV0aW9ucy5zcGxpY2UoY3VycmVudEluZGV4LCAxLCBuZXcgU3Vic3RpdHV0aW9uQWN0aW9uKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZDogMTEsIHRhZzogcXVlcnkudGFnLCBzdWJzdGl0dXRpb246IHN1YnN0aXR1dGlvblxuICAgICAgICAgICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJzEyJzpcbiAgICAgICAgICAgICAgICAgICAgc3Vic3RpdHV0aW9uID0gbG9va3VwKGNvbnRleHRQYXJhbXMuY3VycmVudCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzdWJzdGl0dXRpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN1YnN0aXR1dGlvbnMuc3BsaWNlKGN1cnJlbnRJbmRleCwgMSwgbmV3IFN1YnN0aXR1dGlvbkFjdGlvbih7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWQ6IDEyLCB0YWc6IHF1ZXJ5LnRhZywgc3Vic3RpdHV0aW9uOiBzdWJzdGl0dXRpb25cbiAgICAgICAgICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICc2Myc6XG4gICAgICAgICAgICAgICAgICAgIHN1YnN0aXR1dGlvbiA9IGxvb2t1cChjb250ZXh0UGFyYW1zKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoc3Vic3RpdHV0aW9uKSAmJiBzdWJzdGl0dXRpb24ubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdWJzdGl0dXRpb25zLnNwbGljZShjdXJyZW50SW5kZXgsIDEsIG5ldyBTdWJzdGl0dXRpb25BY3Rpb24oe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlkOiA2MywgdGFnOiBxdWVyeS50YWcsIHN1YnN0aXR1dGlvbjogc3Vic3RpdHV0aW9uXG4gICAgICAgICAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAnNDEnOlxuICAgICAgICAgICAgICAgICAgICBzdWJzdGl0dXRpb24gPSBsb29rdXAoY29udGV4dFBhcmFtcyk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzdWJzdGl0dXRpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN1YnN0aXR1dGlvbnMuc3BsaWNlKGN1cnJlbnRJbmRleCwgMSwgbmV3IFN1YnN0aXR1dGlvbkFjdGlvbih7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWQ6IDQxLCB0YWc6IHF1ZXJ5LnRhZywgc3Vic3RpdHV0aW9uOiBzdWJzdGl0dXRpb25cbiAgICAgICAgICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICcyMSc6XG4gICAgICAgICAgICAgICAgICAgIHN1YnN0aXR1dGlvbiA9IGxvb2t1cChjb250ZXh0UGFyYW1zLmN1cnJlbnQpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoc3Vic3RpdHV0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdWJzdGl0dXRpb25zLnNwbGljZShjdXJyZW50SW5kZXgsIDEsIG5ldyBTdWJzdGl0dXRpb25BY3Rpb24oe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlkOiAyMSwgdGFnOiBxdWVyeS50YWcsIHN1YnN0aXR1dGlvbjogc3Vic3RpdHV0aW9uXG4gICAgICAgICAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb250ZXh0UGFyYW1zID0gbmV3IENvbnRleHRQYXJhbXMoc3Vic3RpdHV0aW9ucywgY3VycmVudEluZGV4KTtcbiAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KHN1YnN0aXR1dGlvbikgJiYgIXN1YnN0aXR1dGlvbi5sZW5ndGgpIHsgY29udGludWU7IH1cbiAgICAgICAgICAgIHN1YnN0aXR1dGlvbiA9IG51bGw7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHN1YnN0aXR1dGlvbnMubGVuZ3RoID8gc3Vic3RpdHV0aW9ucyA6IG51bGw7XG59O1xuXG4vKipcbiAqIENoZWNrcyBpZiBhIGZvbnQgc3VwcG9ydHMgYSBzcGVjaWZpYyBmZWF0dXJlc1xuICogQHBhcmFtIHtGUXVlcnl9IHF1ZXJ5IGZlYXR1cmUgcXVlcnkgb2JqZWN0XG4gKi9cbkZlYXR1cmVRdWVyeS5wcm90b3R5cGUuc3VwcG9ydHMgPSBmdW5jdGlvbiAocXVlcnkpIHtcbiAgICBpZiAoIXF1ZXJ5LnNjcmlwdCkgeyByZXR1cm4gZmFsc2U7IH1cbiAgICB0aGlzLmdldFNjcmlwdEZlYXR1cmVzKHF1ZXJ5LnNjcmlwdCk7XG4gICAgdmFyIHN1cHBvcnRlZFNjcmlwdCA9IHRoaXMuZmVhdHVyZXMuaGFzT3duUHJvcGVydHkocXVlcnkuc2NyaXB0KTtcbiAgICBpZiAoIXF1ZXJ5LnRhZykgeyByZXR1cm4gc3VwcG9ydGVkU2NyaXB0OyB9XG4gICAgdmFyIHN1cHBvcnRlZEZlYXR1cmUgPSAoXG4gICAgICAgIHRoaXMuZmVhdHVyZXNbcXVlcnkuc2NyaXB0XS5zb21lKGZ1bmN0aW9uIChmZWF0dXJlKSB7IHJldHVybiBmZWF0dXJlLnRhZyA9PT0gcXVlcnkudGFnOyB9KVxuICAgICk7XG4gICAgcmV0dXJuIHN1cHBvcnRlZFNjcmlwdCAmJiBzdXBwb3J0ZWRGZWF0dXJlO1xufTtcblxuLyoqXG4gKiBHZXQgbG9va3VwIHRhYmxlIHN1YnRhYmxlc1xuICogQHBhcmFtIHthbnl9IGxvb2t1cFRhYmxlIGxvb2t1cCB0YWJsZVxuICovXG5GZWF0dXJlUXVlcnkucHJvdG90eXBlLmdldExvb2t1cFN1YnRhYmxlcyA9IGZ1bmN0aW9uIChsb29rdXBUYWJsZSkge1xuICAgIHJldHVybiBsb29rdXBUYWJsZS5zdWJ0YWJsZXMgfHwgbnVsbDtcbn07XG5cbi8qKlxuICogR2V0IGxvb2t1cCB0YWJsZSBieSBpbmRleFxuICogQHBhcmFtIHtudW1iZXJ9IGluZGV4IGxvb2t1cCB0YWJsZSBpbmRleFxuICovXG5GZWF0dXJlUXVlcnkucHJvdG90eXBlLmdldExvb2t1cEJ5SW5kZXggPSBmdW5jdGlvbiAoaW5kZXgpIHtcbiAgICB2YXIgbG9va3VwcyA9IHRoaXMuZm9udC50YWJsZXMuZ3N1Yi5sb29rdXBzO1xuICAgIHJldHVybiBsb29rdXBzW2luZGV4XSB8fCBudWxsO1xufTtcblxuLyoqXG4gKiBHZXQgbG9va3VwIHRhYmxlcyBmb3IgYSBmZWF0dXJlXG4gKiBAcGFyYW0ge3N0cmluZ30gZmVhdHVyZVxuICovXG5GZWF0dXJlUXVlcnkucHJvdG90eXBlLmdldEZlYXR1cmVMb29rdXBzID0gZnVuY3Rpb24gKGZlYXR1cmUpIHtcbiAgICAvLyBUT0RPOiBtZW1vaXplXG4gICAgcmV0dXJuIGZlYXR1cmUubG9va3VwTGlzdEluZGV4ZXMubWFwKHRoaXMuZ2V0TG9va3VwQnlJbmRleC5iaW5kKHRoaXMpKTtcbn07XG5cbi8qKlxuICogUXVlcnkgYSBmZWF0dXJlIGJ5IGl0J3MgcHJvcGVydGllc1xuICogQHBhcmFtIHthbnl9IHF1ZXJ5IGFuIG9iamVjdCB0aGF0IGRlc2NyaWJlcyB0aGUgcHJvcGVydGllcyBvZiBhIHF1ZXJ5XG4gKi9cbkZlYXR1cmVRdWVyeS5wcm90b3R5cGUuZ2V0RmVhdHVyZSA9IGZ1bmN0aW9uIGdldEZlYXR1cmUocXVlcnkpIHtcbiAgICBpZiAoIXRoaXMuZm9udCkgeyByZXR1cm4geyBGQUlMOiBcIk5vIGZvbnQgd2FzIGZvdW5kXCJ9OyB9XG4gICAgaWYgKCF0aGlzLmZlYXR1cmVzLmhhc093blByb3BlcnR5KHF1ZXJ5LnNjcmlwdCkpIHtcbiAgICAgICAgdGhpcy5nZXRTY3JpcHRGZWF0dXJlcyhxdWVyeS5zY3JpcHQpO1xuICAgIH1cbiAgICB2YXIgc2NyaXB0RmVhdHVyZXMgPSB0aGlzLmZlYXR1cmVzW3F1ZXJ5LnNjcmlwdF07XG4gICAgaWYgKCFzY3JpcHRGZWF0dXJlcykgeyByZXR1cm4gKFxuICAgICAgICB7IEZBSUw6IChcIk5vIGZlYXR1cmUgZm9yIHNjcmlwdCBcIiArIChxdWVyeS5zY3JpcHQpKX1cbiAgICApOyB9XG4gICAgaWYgKCFzY3JpcHRGZWF0dXJlcy50YWdzW3F1ZXJ5LnRhZ10pIHsgcmV0dXJuIG51bGw7IH1cbiAgICByZXR1cm4gdGhpcy5mZWF0dXJlc1txdWVyeS5zY3JpcHRdLnRhZ3NbcXVlcnkudGFnXTtcbn07XG5cbi8qKlxuICogQXJhYmljIHdvcmQgY29udGV4dCBjaGVja2Vyc1xuICovXG5cbmZ1bmN0aW9uIGFyYWJpY1dvcmRTdGFydENoZWNrKGNvbnRleHRQYXJhbXMpIHtcbiAgICB2YXIgY2hhciA9IGNvbnRleHRQYXJhbXMuY3VycmVudDtcbiAgICB2YXIgcHJldkNoYXIgPSBjb250ZXh0UGFyYW1zLmdldCgtMSk7XG4gICAgcmV0dXJuIChcbiAgICAgICAgLy8gPyBhcmFiaWMgZmlyc3QgY2hhclxuICAgICAgICAocHJldkNoYXIgPT09IG51bGwgJiYgaXNBcmFiaWNDaGFyKGNoYXIpKSB8fFxuICAgICAgICAvLyA/IGFyYWJpYyBjaGFyIHByZWNlZGVkIHdpdGggYSBub24gYXJhYmljIGNoYXJcbiAgICAgICAgKCFpc0FyYWJpY0NoYXIocHJldkNoYXIpICYmIGlzQXJhYmljQ2hhcihjaGFyKSlcbiAgICApO1xufVxuXG5mdW5jdGlvbiBhcmFiaWNXb3JkRW5kQ2hlY2soY29udGV4dFBhcmFtcykge1xuICAgIHZhciBuZXh0Q2hhciA9IGNvbnRleHRQYXJhbXMuZ2V0KDEpO1xuICAgIHJldHVybiAoXG4gICAgICAgIC8vID8gbGFzdCBhcmFiaWMgY2hhclxuICAgICAgICAobmV4dENoYXIgPT09IG51bGwpIHx8XG4gICAgICAgIC8vID8gbmV4dCBjaGFyIGlzIG5vdCBhcmFiaWNcbiAgICAgICAgKCFpc0FyYWJpY0NoYXIobmV4dENoYXIpKVxuICAgICk7XG59XG5cbnZhciBhcmFiaWNXb3JkQ2hlY2sgPSB7XG4gICAgc3RhcnRDaGVjazogYXJhYmljV29yZFN0YXJ0Q2hlY2ssXG4gICAgZW5kQ2hlY2s6IGFyYWJpY1dvcmRFbmRDaGVja1xufTtcblxuLyoqXG4gKiBBcmFiaWMgc2VudGVuY2UgY29udGV4dCBjaGVja2Vyc1xuICovXG5cbmZ1bmN0aW9uIGFyYWJpY1NlbnRlbmNlU3RhcnRDaGVjayhjb250ZXh0UGFyYW1zKSB7XG4gICAgdmFyIGNoYXIgPSBjb250ZXh0UGFyYW1zLmN1cnJlbnQ7XG4gICAgdmFyIHByZXZDaGFyID0gY29udGV4dFBhcmFtcy5nZXQoLTEpO1xuICAgIHJldHVybiAoXG4gICAgICAgIC8vID8gYW4gYXJhYmljIGNoYXIgcHJlY2VkZWQgd2l0aCBhIG5vbiBhcmFiaWMgY2hhclxuICAgICAgICAoaXNBcmFiaWNDaGFyKGNoYXIpIHx8IGlzVGFzaGtlZWxBcmFiaWNDaGFyKGNoYXIpKSAmJlxuICAgICAgICAhaXNBcmFiaWNDaGFyKHByZXZDaGFyKVxuICAgICk7XG59XG5cbmZ1bmN0aW9uIGFyYWJpY1NlbnRlbmNlRW5kQ2hlY2soY29udGV4dFBhcmFtcykge1xuICAgIHZhciBuZXh0Q2hhciA9IGNvbnRleHRQYXJhbXMuZ2V0KDEpO1xuICAgIHN3aXRjaCAodHJ1ZSkge1xuICAgICAgICBjYXNlIG5leHRDaGFyID09PSBudWxsOlxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIGNhc2UgKCFpc0FyYWJpY0NoYXIobmV4dENoYXIpICYmICFpc1Rhc2hrZWVsQXJhYmljQ2hhcihuZXh0Q2hhcikpOlxuICAgICAgICAgICAgdmFyIG5leHRJc1doaXRlc3BhY2UgPSBpc1doaXRlU3BhY2UobmV4dENoYXIpO1xuICAgICAgICAgICAgaWYgKCFuZXh0SXNXaGl0ZXNwYWNlKSB7IHJldHVybiB0cnVlOyB9XG4gICAgICAgICAgICBpZiAobmV4dElzV2hpdGVzcGFjZSkge1xuICAgICAgICAgICAgICAgIHZhciBhcmFiaWNDaGFyQWhlYWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBhcmFiaWNDaGFyQWhlYWQgPSAoXG4gICAgICAgICAgICAgICAgICAgIGNvbnRleHRQYXJhbXMubG9va2FoZWFkLnNvbWUoXG4gICAgICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbiAoYykgeyByZXR1cm4gaXNBcmFiaWNDaGFyKGMpIHx8IGlzVGFzaGtlZWxBcmFiaWNDaGFyKGMpOyB9XG4gICAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIGlmICghYXJhYmljQ2hhckFoZWFkKSB7IHJldHVybiB0cnVlOyB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG59XG5cbnZhciBhcmFiaWNTZW50ZW5jZUNoZWNrID0ge1xuICAgIHN0YXJ0Q2hlY2s6IGFyYWJpY1NlbnRlbmNlU3RhcnRDaGVjayxcbiAgICBlbmRDaGVjazogYXJhYmljU2VudGVuY2VFbmRDaGVja1xufTtcblxuLyoqXG4gKiBBcHBseSBzaW5nbGUgc3Vic3RpdHV0aW9uIGZvcm1hdCAxXG4gKiBAcGFyYW0ge0FycmF5fSBzdWJzdGl0dXRpb25zIHN1YnN0aXR1dGlvbnNcbiAqIEBwYXJhbSB7YW55fSB0b2tlbnMgYSBsaXN0IG9mIHRva2Vuc1xuICogQHBhcmFtIHtudW1iZXJ9IGluZGV4IHRva2VuIGluZGV4XG4gKi9cbmZ1bmN0aW9uIHNpbmdsZVN1YnN0aXR1dGlvbkZvcm1hdDEkMShhY3Rpb24sIHRva2VucywgaW5kZXgpIHtcbiAgICB0b2tlbnNbaW5kZXhdLnNldFN0YXRlKGFjdGlvbi50YWcsIGFjdGlvbi5zdWJzdGl0dXRpb24pO1xufVxuXG4vKipcbiAqIEFwcGx5IHNpbmdsZSBzdWJzdGl0dXRpb24gZm9ybWF0IDJcbiAqIEBwYXJhbSB7QXJyYXl9IHN1YnN0aXR1dGlvbnMgc3Vic3RpdHV0aW9uc1xuICogQHBhcmFtIHthbnl9IHRva2VucyBhIGxpc3Qgb2YgdG9rZW5zXG4gKiBAcGFyYW0ge251bWJlcn0gaW5kZXggdG9rZW4gaW5kZXhcbiAqL1xuZnVuY3Rpb24gc2luZ2xlU3Vic3RpdHV0aW9uRm9ybWF0MiQxKGFjdGlvbiwgdG9rZW5zLCBpbmRleCkge1xuICAgIHRva2Vuc1tpbmRleF0uc2V0U3RhdGUoYWN0aW9uLnRhZywgYWN0aW9uLnN1YnN0aXR1dGlvbik7XG59XG5cbi8qKlxuICogQXBwbHkgY2hhaW5pbmcgY29udGV4dCBzdWJzdGl0dXRpb24gZm9ybWF0IDNcbiAqIEBwYXJhbSB7QXJyYXl9IHN1YnN0aXR1dGlvbnMgc3Vic3RpdHV0aW9uc1xuICogQHBhcmFtIHthbnl9IHRva2VucyBhIGxpc3Qgb2YgdG9rZW5zXG4gKiBAcGFyYW0ge251bWJlcn0gaW5kZXggdG9rZW4gaW5kZXhcbiAqL1xuZnVuY3Rpb24gY2hhaW5pbmdTdWJzdGl0dXRpb25Gb3JtYXQzJDEoYWN0aW9uLCB0b2tlbnMsIGluZGV4KSB7XG4gICAgYWN0aW9uLnN1YnN0aXR1dGlvbi5mb3JFYWNoKGZ1bmN0aW9uIChzdWJzdCwgb2Zmc2V0KSB7XG4gICAgICAgIHZhciB0b2tlbiA9IHRva2Vuc1tpbmRleCArIG9mZnNldF07XG4gICAgICAgIHRva2VuLnNldFN0YXRlKGFjdGlvbi50YWcsIHN1YnN0KTtcbiAgICB9KTtcbn1cblxuLyoqXG4gKiBBcHBseSBsaWdhdHVyZSBzdWJzdGl0dXRpb24gZm9ybWF0IDFcbiAqIEBwYXJhbSB7QXJyYXl9IHN1YnN0aXR1dGlvbnMgc3Vic3RpdHV0aW9uc1xuICogQHBhcmFtIHthbnl9IHRva2VucyBhIGxpc3Qgb2YgdG9rZW5zXG4gKiBAcGFyYW0ge251bWJlcn0gaW5kZXggdG9rZW4gaW5kZXhcbiAqL1xuZnVuY3Rpb24gbGlnYXR1cmVTdWJzdGl0dXRpb25Gb3JtYXQxJDEoYWN0aW9uLCB0b2tlbnMsIGluZGV4KSB7XG4gICAgdmFyIHRva2VuID0gdG9rZW5zW2luZGV4XTtcbiAgICB0b2tlbi5zZXRTdGF0ZShhY3Rpb24udGFnLCBhY3Rpb24uc3Vic3RpdHV0aW9uLmxpZ0dseXBoKTtcbiAgICB2YXIgY29tcHNDb3VudCA9IGFjdGlvbi5zdWJzdGl0dXRpb24uY29tcG9uZW50cy5sZW5ndGg7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb21wc0NvdW50OyBpKyspIHtcbiAgICAgICAgdG9rZW4gPSB0b2tlbnNbaW5kZXggKyBpICsgMV07XG4gICAgICAgIHRva2VuLnNldFN0YXRlKCdkZWxldGVkJywgdHJ1ZSk7XG4gICAgfVxufVxuXG4vKipcbiAqIFN1cHBvcnRlZCBzdWJzdGl0dXRpb25zXG4gKi9cbnZhciBTVUJTVElUVVRJT05TID0ge1xuICAgIDExOiBzaW5nbGVTdWJzdGl0dXRpb25Gb3JtYXQxJDEsXG4gICAgMTI6IHNpbmdsZVN1YnN0aXR1dGlvbkZvcm1hdDIkMSxcbiAgICA2MzogY2hhaW5pbmdTdWJzdGl0dXRpb25Gb3JtYXQzJDEsXG4gICAgNDE6IGxpZ2F0dXJlU3Vic3RpdHV0aW9uRm9ybWF0MSQxXG59O1xuXG4vKipcbiAqIEFwcGx5IHN1YnN0aXR1dGlvbnMgdG8gYSBsaXN0IG9mIHRva2Vuc1xuICogQHBhcmFtIHtBcnJheX0gc3Vic3RpdHV0aW9ucyBzdWJzdGl0dXRpb25zXG4gKiBAcGFyYW0ge2FueX0gdG9rZW5zIGEgbGlzdCBvZiB0b2tlbnNcbiAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleCB0b2tlbiBpbmRleFxuICovXG5mdW5jdGlvbiBhcHBseVN1YnN0aXR1dGlvbihhY3Rpb24sIHRva2VucywgaW5kZXgpIHtcbiAgICBpZiAoYWN0aW9uIGluc3RhbmNlb2YgU3Vic3RpdHV0aW9uQWN0aW9uICYmIFNVQlNUSVRVVElPTlNbYWN0aW9uLmlkXSkge1xuICAgICAgICBTVUJTVElUVVRJT05TW2FjdGlvbi5pZF0oYWN0aW9uLCB0b2tlbnMsIGluZGV4KTtcbiAgICB9XG59XG5cbi8qKlxuICogQXBwbHkgQXJhYmljIHByZXNlbnRhdGlvbiBmb3JtcyB0byBhIHJhbmdlIG9mIHRva2Vuc1xuICovXG5cbi8qKlxuICogQ2hlY2sgaWYgYSBjaGFyIGNhbiBiZSBjb25uZWN0ZWQgdG8gaXQncyBwcmVjZWRpbmcgY2hhclxuICogQHBhcmFtIHtDb250ZXh0UGFyYW1zfSBjaGFyQ29udGV4dFBhcmFtcyBjb250ZXh0IHBhcmFtcyBvZiBhIGNoYXJcbiAqL1xuZnVuY3Rpb24gd2lsbENvbm5lY3RQcmV2KGNoYXJDb250ZXh0UGFyYW1zKSB7XG4gICAgdmFyIGJhY2t0cmFjayA9IFtdLmNvbmNhdChjaGFyQ29udGV4dFBhcmFtcy5iYWNrdHJhY2spO1xuICAgIGZvciAodmFyIGkgPSBiYWNrdHJhY2subGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgdmFyIHByZXZDaGFyID0gYmFja3RyYWNrW2ldO1xuICAgICAgICB2YXIgaXNvbGF0ZWQgPSBpc0lzb2xhdGVkQXJhYmljQ2hhcihwcmV2Q2hhcik7XG4gICAgICAgIHZhciB0YXNoa2VlbCA9IGlzVGFzaGtlZWxBcmFiaWNDaGFyKHByZXZDaGFyKTtcbiAgICAgICAgaWYgKCFpc29sYXRlZCAmJiAhdGFzaGtlZWwpIHsgcmV0dXJuIHRydWU7IH1cbiAgICAgICAgaWYgKGlzb2xhdGVkKSB7IHJldHVybiBmYWxzZTsgfVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59XG5cbi8qKlxuICogQ2hlY2sgaWYgYSBjaGFyIGNhbiBiZSBjb25uZWN0ZWQgdG8gaXQncyBwcm9jZWVkaW5nIGNoYXJcbiAqIEBwYXJhbSB7Q29udGV4dFBhcmFtc30gY2hhckNvbnRleHRQYXJhbXMgY29udGV4dCBwYXJhbXMgb2YgYSBjaGFyXG4gKi9cbmZ1bmN0aW9uIHdpbGxDb25uZWN0TmV4dChjaGFyQ29udGV4dFBhcmFtcykge1xuICAgIGlmIChpc0lzb2xhdGVkQXJhYmljQ2hhcihjaGFyQ29udGV4dFBhcmFtcy5jdXJyZW50KSkgeyByZXR1cm4gZmFsc2U7IH1cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNoYXJDb250ZXh0UGFyYW1zLmxvb2thaGVhZC5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgbmV4dENoYXIgPSBjaGFyQ29udGV4dFBhcmFtcy5sb29rYWhlYWRbaV07XG4gICAgICAgIHZhciB0YXNoa2VlbCA9IGlzVGFzaGtlZWxBcmFiaWNDaGFyKG5leHRDaGFyKTtcbiAgICAgICAgaWYgKCF0YXNoa2VlbCkgeyByZXR1cm4gdHJ1ZTsgfVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59XG5cbi8qKlxuICogQXBwbHkgYXJhYmljIHByZXNlbnRhdGlvbiBmb3JtcyB0byBhIGxpc3Qgb2YgdG9rZW5zXG4gKiBAcGFyYW0ge0NvbnRleHRSYW5nZX0gcmFuZ2UgYSByYW5nZSBvZiB0b2tlbnNcbiAqL1xuZnVuY3Rpb24gYXJhYmljUHJlc2VudGF0aW9uRm9ybXMocmFuZ2UpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICAgIHZhciBzY3JpcHQgPSAnYXJhYic7XG4gICAgdmFyIHRhZ3MgPSB0aGlzLmZlYXR1cmVzVGFnc1tzY3JpcHRdO1xuICAgIHZhciB0b2tlbnMgPSB0aGlzLnRva2VuaXplci5nZXRSYW5nZVRva2VucyhyYW5nZSk7XG4gICAgaWYgKHRva2Vucy5sZW5ndGggPT09IDEpIHsgcmV0dXJuOyB9XG4gICAgdmFyIGNvbnRleHRQYXJhbXMgPSBuZXcgQ29udGV4dFBhcmFtcyhcbiAgICAgICAgdG9rZW5zLm1hcChmdW5jdGlvbiAodG9rZW4pIHsgcmV0dXJuIHRva2VuLmdldFN0YXRlKCdnbHlwaEluZGV4Jyk7IH1cbiAgICApLCAwKTtcbiAgICB2YXIgY2hhckNvbnRleHRQYXJhbXMgPSBuZXcgQ29udGV4dFBhcmFtcyhcbiAgICAgICAgdG9rZW5zLm1hcChmdW5jdGlvbiAodG9rZW4pIHsgcmV0dXJuIHRva2VuLmNoYXI7IH1cbiAgICApLCAwKTtcbiAgICB0b2tlbnMuZm9yRWFjaChmdW5jdGlvbiAodG9rZW4sIGluZGV4KSB7XG4gICAgICAgIGlmIChpc1Rhc2hrZWVsQXJhYmljQ2hhcih0b2tlbi5jaGFyKSkgeyByZXR1cm47IH1cbiAgICAgICAgY29udGV4dFBhcmFtcy5zZXRDdXJyZW50SW5kZXgoaW5kZXgpO1xuICAgICAgICBjaGFyQ29udGV4dFBhcmFtcy5zZXRDdXJyZW50SW5kZXgoaW5kZXgpO1xuICAgICAgICB2YXIgQ09OTkVDVCA9IDA7IC8vIDIgYml0cyAwMCAoMTA6IGNhbiBjb25uZWN0IG5leHQpICgwMTogY2FuIGNvbm5lY3QgcHJldilcbiAgICAgICAgaWYgKHdpbGxDb25uZWN0UHJldihjaGFyQ29udGV4dFBhcmFtcykpIHsgQ09OTkVDVCB8PSAxOyB9XG4gICAgICAgIGlmICh3aWxsQ29ubmVjdE5leHQoY2hhckNvbnRleHRQYXJhbXMpKSB7IENPTk5FQ1QgfD0gMjsgfVxuICAgICAgICB2YXIgdGFnO1xuICAgICAgICBzd2l0Y2ggKENPTk5FQ1QpIHtcbiAgICAgICAgICAgIGNhc2UgMTogKHRhZyA9ICdmaW5hJyk7IGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAyOiAodGFnID0gJ2luaXQnKTsgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIDM6ICh0YWcgPSAnbWVkaScpOyBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBpZiAodGFncy5pbmRleE9mKHRhZykgPT09IC0xKSB7IHJldHVybjsgfVxuICAgICAgICB2YXIgc3Vic3RpdHV0aW9ucyA9IHRoaXMkMS5xdWVyeS5sb29rdXBGZWF0dXJlKHtcbiAgICAgICAgICAgIHRhZzogdGFnLCBzY3JpcHQ6IHNjcmlwdCwgY29udGV4dFBhcmFtczogY29udGV4dFBhcmFtc1xuICAgICAgICB9KTtcbiAgICAgICAgaWYgKHN1YnN0aXR1dGlvbnMgaW5zdGFuY2VvZiBFcnJvcikgeyByZXR1cm4gY29uc29sZS5pbmZvKHN1YnN0aXR1dGlvbnMubWVzc2FnZSk7IH1cbiAgICAgICAgc3Vic3RpdHV0aW9ucy5mb3JFYWNoKGZ1bmN0aW9uIChhY3Rpb24sIGluZGV4KSB7XG4gICAgICAgICAgICBpZiAoYWN0aW9uIGluc3RhbmNlb2YgU3Vic3RpdHV0aW9uQWN0aW9uKSB7XG4gICAgICAgICAgICAgICAgYXBwbHlTdWJzdGl0dXRpb24oYWN0aW9uLCB0b2tlbnMsIGluZGV4KTtcbiAgICAgICAgICAgICAgICBjb250ZXh0UGFyYW1zLmNvbnRleHRbaW5kZXhdID0gYWN0aW9uLnN1YnN0aXR1dGlvbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfSk7XG59XG5cbi8qKlxuICogQXBwbHkgQXJhYmljIHJlcXVpcmVkIGxpZ2F0dXJlcyBmZWF0dXJlIHRvIGEgcmFuZ2Ugb2YgdG9rZW5zXG4gKi9cblxuLyoqXG4gKiBVcGRhdGUgY29udGV4dCBwYXJhbXNcbiAqIEBwYXJhbSB7YW55fSB0b2tlbnMgYSBsaXN0IG9mIHRva2Vuc1xuICogQHBhcmFtIHtudW1iZXJ9IGluZGV4IGN1cnJlbnQgaXRlbSBpbmRleFxuICovXG5mdW5jdGlvbiBnZXRDb250ZXh0UGFyYW1zKHRva2VucywgaW5kZXgpIHtcbiAgICB2YXIgY29udGV4dCA9IHRva2Vucy5tYXAoZnVuY3Rpb24gKHRva2VuKSB7IHJldHVybiB0b2tlbi5hY3RpdmVTdGF0ZS52YWx1ZTsgfSk7XG4gICAgcmV0dXJuIG5ldyBDb250ZXh0UGFyYW1zKGNvbnRleHQsIGluZGV4IHx8IDApO1xufVxuXG4vKipcbiAqIEFwcGx5IEFyYWJpYyByZXF1aXJlZCBsaWdhdHVyZXMgdG8gYSBjb250ZXh0IHJhbmdlXG4gKiBAcGFyYW0ge0NvbnRleHRSYW5nZX0gcmFuZ2UgYSByYW5nZSBvZiB0b2tlbnNcbiAqL1xuZnVuY3Rpb24gYXJhYmljUmVxdWlyZWRMaWdhdHVyZXMocmFuZ2UpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICAgIHZhciBzY3JpcHQgPSAnYXJhYic7XG4gICAgdmFyIHRva2VucyA9IHRoaXMudG9rZW5pemVyLmdldFJhbmdlVG9rZW5zKHJhbmdlKTtcbiAgICB2YXIgY29udGV4dFBhcmFtcyA9IGdldENvbnRleHRQYXJhbXModG9rZW5zKTtcbiAgICBjb250ZXh0UGFyYW1zLmNvbnRleHQuZm9yRWFjaChmdW5jdGlvbiAoZ2x5cGhJbmRleCwgaW5kZXgpIHtcbiAgICAgICAgY29udGV4dFBhcmFtcy5zZXRDdXJyZW50SW5kZXgoaW5kZXgpO1xuICAgICAgICB2YXIgc3Vic3RpdHV0aW9ucyA9IHRoaXMkMS5xdWVyeS5sb29rdXBGZWF0dXJlKHtcbiAgICAgICAgICAgIHRhZzogJ3JsaWcnLCBzY3JpcHQ6IHNjcmlwdCwgY29udGV4dFBhcmFtczogY29udGV4dFBhcmFtc1xuICAgICAgICB9KTtcbiAgICAgICAgaWYgKHN1YnN0aXR1dGlvbnMubGVuZ3RoKSB7XG4gICAgICAgICAgICBzdWJzdGl0dXRpb25zLmZvckVhY2goXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gKGFjdGlvbikgeyByZXR1cm4gYXBwbHlTdWJzdGl0dXRpb24oYWN0aW9uLCB0b2tlbnMsIGluZGV4KTsgfVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGNvbnRleHRQYXJhbXMgPSBnZXRDb250ZXh0UGFyYW1zKHRva2Vucyk7XG4gICAgICAgIH1cbiAgICB9KTtcbn1cblxuLyoqXG4gKiBMYXRpbiB3b3JkIGNvbnRleHQgY2hlY2tlcnNcbiAqL1xuXG5mdW5jdGlvbiBsYXRpbldvcmRTdGFydENoZWNrKGNvbnRleHRQYXJhbXMpIHtcbiAgICB2YXIgY2hhciA9IGNvbnRleHRQYXJhbXMuY3VycmVudDtcbiAgICB2YXIgcHJldkNoYXIgPSBjb250ZXh0UGFyYW1zLmdldCgtMSk7XG4gICAgcmV0dXJuIChcbiAgICAgICAgLy8gPyBsYXRpbiBmaXJzdCBjaGFyXG4gICAgICAgIChwcmV2Q2hhciA9PT0gbnVsbCAmJiBpc0xhdGluQ2hhcihjaGFyKSkgfHxcbiAgICAgICAgLy8gPyBsYXRpbiBjaGFyIHByZWNlZGVkIHdpdGggYSBub24gbGF0aW4gY2hhclxuICAgICAgICAoIWlzTGF0aW5DaGFyKHByZXZDaGFyKSAmJiBpc0xhdGluQ2hhcihjaGFyKSlcbiAgICApO1xufVxuXG5mdW5jdGlvbiBsYXRpbldvcmRFbmRDaGVjayhjb250ZXh0UGFyYW1zKSB7XG4gICAgdmFyIG5leHRDaGFyID0gY29udGV4dFBhcmFtcy5nZXQoMSk7XG4gICAgcmV0dXJuIChcbiAgICAgICAgLy8gPyBsYXN0IGxhdGluIGNoYXJcbiAgICAgICAgKG5leHRDaGFyID09PSBudWxsKSB8fFxuICAgICAgICAvLyA/IG5leHQgY2hhciBpcyBub3QgbGF0aW5cbiAgICAgICAgKCFpc0xhdGluQ2hhcihuZXh0Q2hhcikpXG4gICAgKTtcbn1cblxudmFyIGxhdGluV29yZENoZWNrID0ge1xuICAgIHN0YXJ0Q2hlY2s6IGxhdGluV29yZFN0YXJ0Q2hlY2ssXG4gICAgZW5kQ2hlY2s6IGxhdGluV29yZEVuZENoZWNrXG59O1xuXG4vKipcbiAqIEFwcGx5IExhdGluIGxpZ2F0dXJlIGZlYXR1cmUgdG8gYSByYW5nZSBvZiB0b2tlbnNcbiAqL1xuXG4vKipcbiAqIFVwZGF0ZSBjb250ZXh0IHBhcmFtc1xuICogQHBhcmFtIHthbnl9IHRva2VucyBhIGxpc3Qgb2YgdG9rZW5zXG4gKiBAcGFyYW0ge251bWJlcn0gaW5kZXggY3VycmVudCBpdGVtIGluZGV4XG4gKi9cbmZ1bmN0aW9uIGdldENvbnRleHRQYXJhbXMkMSh0b2tlbnMsIGluZGV4KSB7XG4gICAgdmFyIGNvbnRleHQgPSB0b2tlbnMubWFwKGZ1bmN0aW9uICh0b2tlbikgeyByZXR1cm4gdG9rZW4uYWN0aXZlU3RhdGUudmFsdWU7IH0pO1xuICAgIHJldHVybiBuZXcgQ29udGV4dFBhcmFtcyhjb250ZXh0LCBpbmRleCB8fCAwKTtcbn1cblxuLyoqXG4gKiBBcHBseSBBcmFiaWMgcmVxdWlyZWQgbGlnYXR1cmVzIHRvIGEgY29udGV4dCByYW5nZVxuICogQHBhcmFtIHtDb250ZXh0UmFuZ2V9IHJhbmdlIGEgcmFuZ2Ugb2YgdG9rZW5zXG4gKi9cbmZ1bmN0aW9uIGxhdGluTGlnYXR1cmUocmFuZ2UpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICAgIHZhciBzY3JpcHQgPSAnbGF0bic7XG4gICAgdmFyIHRva2VucyA9IHRoaXMudG9rZW5pemVyLmdldFJhbmdlVG9rZW5zKHJhbmdlKTtcbiAgICB2YXIgY29udGV4dFBhcmFtcyA9IGdldENvbnRleHRQYXJhbXMkMSh0b2tlbnMpO1xuICAgIGNvbnRleHRQYXJhbXMuY29udGV4dC5mb3JFYWNoKGZ1bmN0aW9uIChnbHlwaEluZGV4LCBpbmRleCkge1xuICAgICAgICBjb250ZXh0UGFyYW1zLnNldEN1cnJlbnRJbmRleChpbmRleCk7XG4gICAgICAgIHZhciBzdWJzdGl0dXRpb25zID0gdGhpcyQxLnF1ZXJ5Lmxvb2t1cEZlYXR1cmUoe1xuICAgICAgICAgICAgdGFnOiAnbGlnYScsIHNjcmlwdDogc2NyaXB0LCBjb250ZXh0UGFyYW1zOiBjb250ZXh0UGFyYW1zXG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoc3Vic3RpdHV0aW9ucy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHN1YnN0aXR1dGlvbnMuZm9yRWFjaChcbiAgICAgICAgICAgICAgICBmdW5jdGlvbiAoYWN0aW9uKSB7IHJldHVybiBhcHBseVN1YnN0aXR1dGlvbihhY3Rpb24sIHRva2VucywgaW5kZXgpOyB9XG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgY29udGV4dFBhcmFtcyA9IGdldENvbnRleHRQYXJhbXMkMSh0b2tlbnMpO1xuICAgICAgICB9XG4gICAgfSk7XG59XG5cbi8qKlxuICogSW5mZXIgYmlkaXJlY3Rpb25hbCBwcm9wZXJ0aWVzIGZvciBhIGdpdmVuIHRleHQgYW5kIGFwcGx5XG4gKiB0aGUgY29ycmVzcG9uZGluZyBsYXlvdXQgcnVsZXMuXG4gKi9cblxuLyoqXG4gKiBDcmVhdGUgQmlkaS4gZmVhdHVyZXNcbiAqIEBwYXJhbSB7c3RyaW5nfSBiYXNlRGlyIHRleHQgYmFzZSBkaXJlY3Rpb24uIHZhbHVlIGVpdGhlciAnbHRyJyBvciAncnRsJ1xuICovXG5mdW5jdGlvbiBCaWRpKGJhc2VEaXIpIHtcbiAgICB0aGlzLmJhc2VEaXIgPSBiYXNlRGlyIHx8ICdsdHInO1xuICAgIHRoaXMudG9rZW5pemVyID0gbmV3IFRva2VuaXplcigpO1xuICAgIHRoaXMuZmVhdHVyZXNUYWdzID0ge307XG59XG5cbi8qKlxuICogU2V0cyBCaWRpIHRleHRcbiAqIEBwYXJhbSB7c3RyaW5nfSB0ZXh0IGEgdGV4dCBpbnB1dFxuICovXG5CaWRpLnByb3RvdHlwZS5zZXRUZXh0ID0gZnVuY3Rpb24gKHRleHQpIHtcbiAgICB0aGlzLnRleHQgPSB0ZXh0O1xufTtcblxuLyoqXG4gKiBTdG9yZSBlc3NlbnRpYWwgY29udGV4dCBjaGVja3M6XG4gKiBhcmFiaWMgd29yZCBjaGVjayBmb3IgYXBwbHlpbmcgZ3N1YiBmZWF0dXJlc1xuICogYXJhYmljIHNlbnRlbmNlIGNoZWNrIGZvciBhZGp1c3RpbmcgYXJhYmljIGxheW91dFxuICovXG5CaWRpLnByb3RvdHlwZS5jb250ZXh0Q2hlY2tzID0gKHtcbiAgICBsYXRpbldvcmRDaGVjazogbGF0aW5Xb3JkQ2hlY2ssXG4gICAgYXJhYmljV29yZENoZWNrOiBhcmFiaWNXb3JkQ2hlY2ssXG4gICAgYXJhYmljU2VudGVuY2VDaGVjazogYXJhYmljU2VudGVuY2VDaGVja1xufSk7XG5cbi8qKlxuICogUmVnaXN0ZXIgYXJhYmljIHdvcmQgY2hlY2tcbiAqL1xuZnVuY3Rpb24gcmVnaXN0ZXJDb250ZXh0Q2hlY2tlcihjaGVja0lkKSB7XG4gICAgdmFyIGNoZWNrID0gdGhpcy5jb250ZXh0Q2hlY2tzWyhjaGVja0lkICsgXCJDaGVja1wiKV07XG4gICAgcmV0dXJuIHRoaXMudG9rZW5pemVyLnJlZ2lzdGVyQ29udGV4dENoZWNrZXIoXG4gICAgICAgIGNoZWNrSWQsIGNoZWNrLnN0YXJ0Q2hlY2ssIGNoZWNrLmVuZENoZWNrXG4gICAgKTtcbn1cblxuLyoqXG4gKiBQZXJmb3JtIHByZSB0b2tlbml6YXRpb24gcHJvY2VkdXJlIHRoZW5cbiAqIHRva2VuaXplIHRleHQgaW5wdXRcbiAqL1xuZnVuY3Rpb24gdG9rZW5pemVUZXh0KCkge1xuICAgIHJlZ2lzdGVyQ29udGV4dENoZWNrZXIuY2FsbCh0aGlzLCAnbGF0aW5Xb3JkJyk7XG4gICAgcmVnaXN0ZXJDb250ZXh0Q2hlY2tlci5jYWxsKHRoaXMsICdhcmFiaWNXb3JkJyk7XG4gICAgcmVnaXN0ZXJDb250ZXh0Q2hlY2tlci5jYWxsKHRoaXMsICdhcmFiaWNTZW50ZW5jZScpO1xuICAgIHJldHVybiB0aGlzLnRva2VuaXplci50b2tlbml6ZSh0aGlzLnRleHQpO1xufVxuXG4vKipcbiAqIFJldmVyc2UgYXJhYmljIHNlbnRlbmNlIGxheW91dFxuICogVE9ETzogY2hlY2sgYmFzZSBkaXIgYmVmb3JlIGFwcGx5aW5nIGFkanVzdG1lbnRzIC0gcHJpb3JpdHkgbG93XG4gKi9cbmZ1bmN0aW9uIHJldmVyc2VBcmFiaWNTZW50ZW5jZXMoKSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgICB2YXIgcmFuZ2VzID0gdGhpcy50b2tlbml6ZXIuZ2V0Q29udGV4dFJhbmdlcygnYXJhYmljU2VudGVuY2UnKTtcbiAgICByYW5nZXMuZm9yRWFjaChmdW5jdGlvbiAocmFuZ2UpIHtcbiAgICAgICAgdmFyIHJhbmdlVG9rZW5zID0gdGhpcyQxLnRva2VuaXplci5nZXRSYW5nZVRva2VucyhyYW5nZSk7XG4gICAgICAgIHRoaXMkMS50b2tlbml6ZXIucmVwbGFjZVJhbmdlKFxuICAgICAgICAgICAgcmFuZ2Uuc3RhcnRJbmRleCxcbiAgICAgICAgICAgIHJhbmdlLmVuZE9mZnNldCxcbiAgICAgICAgICAgIHJhbmdlVG9rZW5zLnJldmVyc2UoKVxuICAgICAgICApO1xuICAgIH0pO1xufVxuXG4vKipcbiAqIFJlZ2lzdGVyIHN1cHBvcnRlZCBmZWF0dXJlcyB0YWdzXG4gKiBAcGFyYW0ge3NjcmlwdH0gc2NyaXB0IHNjcmlwdCB0YWdcbiAqIEBwYXJhbSB7QXJyYXl9IHRhZ3MgZmVhdHVyZXMgdGFncyBsaXN0XG4gKi9cbkJpZGkucHJvdG90eXBlLnJlZ2lzdGVyRmVhdHVyZXMgPSBmdW5jdGlvbiAoc2NyaXB0LCB0YWdzKSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgICB2YXIgc3VwcG9ydGVkVGFncyA9IHRhZ3MuZmlsdGVyKFxuICAgICAgICBmdW5jdGlvbiAodGFnKSB7IHJldHVybiB0aGlzJDEucXVlcnkuc3VwcG9ydHMoe3NjcmlwdDogc2NyaXB0LCB0YWc6IHRhZ30pOyB9XG4gICAgKTtcbiAgICBpZiAoIXRoaXMuZmVhdHVyZXNUYWdzLmhhc093blByb3BlcnR5KHNjcmlwdCkpIHtcbiAgICAgICAgdGhpcy5mZWF0dXJlc1RhZ3Nbc2NyaXB0XSA9IHN1cHBvcnRlZFRhZ3M7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5mZWF0dXJlc1RhZ3Nbc2NyaXB0XSA9XG4gICAgICAgIHRoaXMuZmVhdHVyZXNUYWdzW3NjcmlwdF0uY29uY2F0KHN1cHBvcnRlZFRhZ3MpO1xuICAgIH1cbn07XG5cbi8qKlxuICogQXBwbHkgR1NVQiBmZWF0dXJlc1xuICogQHBhcmFtIHtBcnJheX0gdGFnc0xpc3QgYSBsaXN0IG9mIGZlYXR1cmVzIHRhZ3NcbiAqIEBwYXJhbSB7c3RyaW5nfSBzY3JpcHQgYSBzY3JpcHQgdGFnXG4gKiBAcGFyYW0ge0ZvbnR9IGZvbnQgb3BlbnR5cGUgZm9udCBpbnN0YW5jZVxuICovXG5CaWRpLnByb3RvdHlwZS5hcHBseUZlYXR1cmVzID0gZnVuY3Rpb24gKGZvbnQsIGZlYXR1cmVzKSB7XG4gICAgaWYgKCFmb250KSB7IHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgJ05vIHZhbGlkIGZvbnQgd2FzIHByb3ZpZGVkIHRvIGFwcGx5IGZlYXR1cmVzJ1xuICAgICk7IH1cbiAgICBpZiAoIXRoaXMucXVlcnkpIHsgdGhpcy5xdWVyeSA9IG5ldyBGZWF0dXJlUXVlcnkoZm9udCk7IH1cbiAgICBmb3IgKHZhciBmID0gMDsgZiA8IGZlYXR1cmVzLmxlbmd0aDsgZisrKSB7XG4gICAgICAgIHZhciBmZWF0dXJlID0gZmVhdHVyZXNbZl07XG4gICAgICAgIGlmICghdGhpcy5xdWVyeS5zdXBwb3J0cyh7c2NyaXB0OiBmZWF0dXJlLnNjcmlwdH0pKSB7IGNvbnRpbnVlOyB9XG4gICAgICAgIHRoaXMucmVnaXN0ZXJGZWF0dXJlcyhmZWF0dXJlLnNjcmlwdCwgZmVhdHVyZS50YWdzKTtcbiAgICB9XG59O1xuXG4vKipcbiAqIFJlZ2lzdGVyIGEgc3RhdGUgbW9kaWZpZXJcbiAqIEBwYXJhbSB7c3RyaW5nfSBtb2RpZmllcklkIHN0YXRlIG1vZGlmaWVyIGlkXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBjb25kaXRpb24gYSBwcmVkaWNhdGUgZnVuY3Rpb24gdGhhdCByZXR1cm5zIHRydWUgb3IgZmFsc2VcbiAqIEBwYXJhbSB7ZnVuY3Rpb259IG1vZGlmaWVyIGEgbW9kaWZpZXIgZnVuY3Rpb24gdG8gc2V0IHRva2VuIHN0YXRlXG4gKi9cbkJpZGkucHJvdG90eXBlLnJlZ2lzdGVyTW9kaWZpZXIgPSBmdW5jdGlvbiAobW9kaWZpZXJJZCwgY29uZGl0aW9uLCBtb2RpZmllcikge1xuICAgIHRoaXMudG9rZW5pemVyLnJlZ2lzdGVyTW9kaWZpZXIobW9kaWZpZXJJZCwgY29uZGl0aW9uLCBtb2RpZmllcik7XG59O1xuXG4vKipcbiAqIENoZWNrIGlmICdnbHlwaEluZGV4JyBpcyByZWdpc3RlcmVkXG4gKi9cbmZ1bmN0aW9uIGNoZWNrR2x5cGhJbmRleFN0YXR1cygpIHtcbiAgICBpZiAodGhpcy50b2tlbml6ZXIucmVnaXN0ZXJlZE1vZGlmaWVycy5pbmRleE9mKCdnbHlwaEluZGV4JykgPT09IC0xKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAgICdnbHlwaEluZGV4IG1vZGlmaWVyIGlzIHJlcXVpcmVkIHRvIGFwcGx5ICcgK1xuICAgICAgICAgICAgJ2FyYWJpYyBwcmVzZW50YXRpb24gZmVhdHVyZXMuJ1xuICAgICAgICApO1xuICAgIH1cbn1cblxuLyoqXG4gKiBBcHBseSBhcmFiaWMgcHJlc2VudGF0aW9uIGZvcm1zIGZlYXR1cmVzXG4gKi9cbmZ1bmN0aW9uIGFwcGx5QXJhYmljUHJlc2VudGF0aW9uRm9ybXMoKSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgICB2YXIgc2NyaXB0ID0gJ2FyYWInO1xuICAgIGlmICghdGhpcy5mZWF0dXJlc1RhZ3MuaGFzT3duUHJvcGVydHkoc2NyaXB0KSkgeyByZXR1cm47IH1cbiAgICBjaGVja0dseXBoSW5kZXhTdGF0dXMuY2FsbCh0aGlzKTtcbiAgICB2YXIgcmFuZ2VzID0gdGhpcy50b2tlbml6ZXIuZ2V0Q29udGV4dFJhbmdlcygnYXJhYmljV29yZCcpO1xuICAgIHJhbmdlcy5mb3JFYWNoKGZ1bmN0aW9uIChyYW5nZSkge1xuICAgICAgICBhcmFiaWNQcmVzZW50YXRpb25Gb3Jtcy5jYWxsKHRoaXMkMSwgcmFuZ2UpO1xuICAgIH0pO1xufVxuXG4vKipcbiAqIEFwcGx5IHJlcXVpcmVkIGFyYWJpYyBsaWdhdHVyZXNcbiAqL1xuZnVuY3Rpb24gYXBwbHlBcmFiaWNSZXF1aXJlTGlnYXR1cmVzKCkge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gICAgdmFyIHNjcmlwdCA9ICdhcmFiJztcbiAgICBpZiAoIXRoaXMuZmVhdHVyZXNUYWdzLmhhc093blByb3BlcnR5KHNjcmlwdCkpIHsgcmV0dXJuOyB9XG4gICAgdmFyIHRhZ3MgPSB0aGlzLmZlYXR1cmVzVGFnc1tzY3JpcHRdO1xuICAgIGlmICh0YWdzLmluZGV4T2YoJ3JsaWcnKSA9PT0gLTEpIHsgcmV0dXJuOyB9XG4gICAgY2hlY2tHbHlwaEluZGV4U3RhdHVzLmNhbGwodGhpcyk7XG4gICAgdmFyIHJhbmdlcyA9IHRoaXMudG9rZW5pemVyLmdldENvbnRleHRSYW5nZXMoJ2FyYWJpY1dvcmQnKTtcbiAgICByYW5nZXMuZm9yRWFjaChmdW5jdGlvbiAocmFuZ2UpIHtcbiAgICAgICAgYXJhYmljUmVxdWlyZWRMaWdhdHVyZXMuY2FsbCh0aGlzJDEsIHJhbmdlKTtcbiAgICB9KTtcbn1cblxuLyoqXG4gKiBBcHBseSByZXF1aXJlZCBhcmFiaWMgbGlnYXR1cmVzXG4gKi9cbmZ1bmN0aW9uIGFwcGx5TGF0aW5MaWdhdHVyZXMoKSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgICB2YXIgc2NyaXB0ID0gJ2xhdG4nO1xuICAgIGlmICghdGhpcy5mZWF0dXJlc1RhZ3MuaGFzT3duUHJvcGVydHkoc2NyaXB0KSkgeyByZXR1cm47IH1cbiAgICB2YXIgdGFncyA9IHRoaXMuZmVhdHVyZXNUYWdzW3NjcmlwdF07XG4gICAgaWYgKHRhZ3MuaW5kZXhPZignbGlnYScpID09PSAtMSkgeyByZXR1cm47IH1cbiAgICBjaGVja0dseXBoSW5kZXhTdGF0dXMuY2FsbCh0aGlzKTtcbiAgICB2YXIgcmFuZ2VzID0gdGhpcy50b2tlbml6ZXIuZ2V0Q29udGV4dFJhbmdlcygnbGF0aW5Xb3JkJyk7XG4gICAgcmFuZ2VzLmZvckVhY2goZnVuY3Rpb24gKHJhbmdlKSB7XG4gICAgICAgIGxhdGluTGlnYXR1cmUuY2FsbCh0aGlzJDEsIHJhbmdlKTtcbiAgICB9KTtcbn1cblxuLyoqXG4gKiBDaGVjayBpZiBhIGNvbnRleHQgaXMgcmVnaXN0ZXJlZFxuICogQHBhcmFtIHtzdHJpbmd9IGNvbnRleHRJZCBjb250ZXh0IGlkXG4gKi9cbkJpZGkucHJvdG90eXBlLmNoZWNrQ29udGV4dFJlYWR5ID0gZnVuY3Rpb24gKGNvbnRleHRJZCkge1xuICAgIHJldHVybiAhIXRoaXMudG9rZW5pemVyLmdldENvbnRleHQoY29udGV4dElkKTtcbn07XG5cbi8qKlxuICogQXBwbHkgZmVhdHVyZXMgdG8gcmVnaXN0ZXJlZCBjb250ZXh0c1xuICovXG5CaWRpLnByb3RvdHlwZS5hcHBseUZlYXR1cmVzVG9Db250ZXh0cyA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAodGhpcy5jaGVja0NvbnRleHRSZWFkeSgnYXJhYmljV29yZCcpKSB7XG4gICAgICAgIGFwcGx5QXJhYmljUHJlc2VudGF0aW9uRm9ybXMuY2FsbCh0aGlzKTtcbiAgICAgICAgYXBwbHlBcmFiaWNSZXF1aXJlTGlnYXR1cmVzLmNhbGwodGhpcyk7XG4gICAgfVxuICAgIGlmICh0aGlzLmNoZWNrQ29udGV4dFJlYWR5KCdsYXRpbldvcmQnKSkge1xuICAgICAgICBhcHBseUxhdGluTGlnYXR1cmVzLmNhbGwodGhpcyk7XG4gICAgfVxuICAgIGlmICh0aGlzLmNoZWNrQ29udGV4dFJlYWR5KCdhcmFiaWNTZW50ZW5jZScpKSB7XG4gICAgICAgIHJldmVyc2VBcmFiaWNTZW50ZW5jZXMuY2FsbCh0aGlzKTtcbiAgICB9XG59O1xuXG4vKipcbiAqIHByb2Nlc3MgdGV4dCBpbnB1dFxuICogQHBhcmFtIHtzdHJpbmd9IHRleHQgYW4gaW5wdXQgdGV4dFxuICovXG5CaWRpLnByb3RvdHlwZS5wcm9jZXNzVGV4dCA9IGZ1bmN0aW9uKHRleHQpIHtcbiAgICBpZiAoIXRoaXMudGV4dCB8fCB0aGlzLnRleHQgIT09IHRleHQpIHtcbiAgICAgICAgdGhpcy5zZXRUZXh0KHRleHQpO1xuICAgICAgICB0b2tlbml6ZVRleHQuY2FsbCh0aGlzKTtcbiAgICAgICAgdGhpcy5hcHBseUZlYXR1cmVzVG9Db250ZXh0cygpO1xuICAgIH1cbn07XG5cbi8qKlxuICogUHJvY2VzcyBhIHN0cmluZyBvZiB0ZXh0IHRvIGlkZW50aWZ5IGFuZCBhZGp1c3RcbiAqIGJpZGlyZWN0aW9uYWwgdGV4dCBlbnRpdGllcy5cbiAqIEBwYXJhbSB7c3RyaW5nfSB0ZXh0IGlucHV0IHRleHRcbiAqL1xuQmlkaS5wcm90b3R5cGUuZ2V0QmlkaVRleHQgPSBmdW5jdGlvbiAodGV4dCkge1xuICAgIHRoaXMucHJvY2Vzc1RleHQodGV4dCk7XG4gICAgcmV0dXJuIHRoaXMudG9rZW5pemVyLmdldFRleHQoKTtcbn07XG5cbi8qKlxuICogR2V0IHRoZSBjdXJyZW50IHN0YXRlIGluZGV4IG9mIGVhY2ggdG9rZW5cbiAqIEBwYXJhbSB7dGV4dH0gdGV4dCBhbiBpbnB1dCB0ZXh0XG4gKi9cbkJpZGkucHJvdG90eXBlLmdldFRleHRHbHlwaHMgPSBmdW5jdGlvbiAodGV4dCkge1xuICAgIHRoaXMucHJvY2Vzc1RleHQodGV4dCk7XG4gICAgdmFyIGluZGV4ZXMgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMudG9rZW5pemVyLnRva2Vucy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgdG9rZW4gPSB0aGlzLnRva2VuaXplci50b2tlbnNbaV07XG4gICAgICAgIGlmICh0b2tlbi5zdGF0ZS5kZWxldGVkKSB7IGNvbnRpbnVlOyB9XG4gICAgICAgIHZhciBpbmRleCA9IHRva2VuLmFjdGl2ZVN0YXRlLnZhbHVlO1xuICAgICAgICBpbmRleGVzLnB1c2goQXJyYXkuaXNBcnJheShpbmRleCkgPyBpbmRleFswXSA6IGluZGV4KTtcbiAgICB9XG4gICAgcmV0dXJuIGluZGV4ZXM7XG59O1xuXG4vLyBUaGUgRm9udCBvYmplY3RcblxuLyoqXG4gKiBAdHlwZWRlZiBGb250T3B0aW9uc1xuICogQHR5cGUgT2JqZWN0XG4gKiBAcHJvcGVydHkge0Jvb2xlYW59IGVtcHR5IC0gd2hldGhlciB0byBjcmVhdGUgYSBuZXcgZW1wdHkgZm9udFxuICogQHByb3BlcnR5IHtzdHJpbmd9IGZhbWlseU5hbWVcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBzdHlsZU5hbWVcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nPX0gZnVsbE5hbWVcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nPX0gcG9zdFNjcmlwdE5hbWVcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nPX0gZGVzaWduZXJcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nPX0gZGVzaWduZXJVUkxcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nPX0gbWFudWZhY3R1cmVyXG4gKiBAcHJvcGVydHkge3N0cmluZz19IG1hbnVmYWN0dXJlclVSTFxuICogQHByb3BlcnR5IHtzdHJpbmc9fSBsaWNlbnNlXG4gKiBAcHJvcGVydHkge3N0cmluZz19IGxpY2Vuc2VVUkxcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nPX0gdmVyc2lvblxuICogQHByb3BlcnR5IHtzdHJpbmc9fSBkZXNjcmlwdGlvblxuICogQHByb3BlcnR5IHtzdHJpbmc9fSBjb3B5cmlnaHRcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nPX0gdHJhZGVtYXJrXG4gKiBAcHJvcGVydHkge051bWJlcn0gdW5pdHNQZXJFbVxuICogQHByb3BlcnR5IHtOdW1iZXJ9IGFzY2VuZGVyXG4gKiBAcHJvcGVydHkge051bWJlcn0gZGVzY2VuZGVyXG4gKiBAcHJvcGVydHkge051bWJlcn0gY3JlYXRlZFRpbWVzdGFtcFxuICogQHByb3BlcnR5IHtzdHJpbmc9fSB3ZWlnaHRDbGFzc1xuICogQHByb3BlcnR5IHtzdHJpbmc9fSB3aWR0aENsYXNzXG4gKiBAcHJvcGVydHkge3N0cmluZz19IGZzU2VsZWN0aW9uXG4gKi9cblxuLyoqXG4gKiBBIEZvbnQgcmVwcmVzZW50cyBhIGxvYWRlZCBPcGVuVHlwZSBmb250IGZpbGUuXG4gKiBJdCBjb250YWlucyBhIHNldCBvZiBnbHlwaHMgYW5kIG1ldGhvZHMgdG8gZHJhdyB0ZXh0IG9uIGEgZHJhd2luZyBjb250ZXh0LFxuICogb3IgdG8gZ2V0IGEgcGF0aCByZXByZXNlbnRpbmcgdGhlIHRleHQuXG4gKiBAZXhwb3J0cyBvcGVudHlwZS5Gb250XG4gKiBAY2xhc3NcbiAqIEBwYXJhbSB7Rm9udE9wdGlvbnN9XG4gKiBAY29uc3RydWN0b3JcbiAqL1xuZnVuY3Rpb24gRm9udChvcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgb3B0aW9ucy50YWJsZXMgPSBvcHRpb25zLnRhYmxlcyB8fCB7fTtcblxuICAgIGlmICghb3B0aW9ucy5lbXB0eSkge1xuICAgICAgICAvLyBDaGVjayB0aGF0IHdlJ3ZlIHByb3ZpZGVkIHRoZSBtaW5pbXVtIHNldCBvZiBuYW1lcy5cbiAgICAgICAgY2hlY2tBcmd1bWVudChvcHRpb25zLmZhbWlseU5hbWUsICdXaGVuIGNyZWF0aW5nIGEgbmV3IEZvbnQgb2JqZWN0LCBmYW1pbHlOYW1lIGlzIHJlcXVpcmVkLicpO1xuICAgICAgICBjaGVja0FyZ3VtZW50KG9wdGlvbnMuc3R5bGVOYW1lLCAnV2hlbiBjcmVhdGluZyBhIG5ldyBGb250IG9iamVjdCwgc3R5bGVOYW1lIGlzIHJlcXVpcmVkLicpO1xuICAgICAgICBjaGVja0FyZ3VtZW50KG9wdGlvbnMudW5pdHNQZXJFbSwgJ1doZW4gY3JlYXRpbmcgYSBuZXcgRm9udCBvYmplY3QsIHVuaXRzUGVyRW0gaXMgcmVxdWlyZWQuJyk7XG4gICAgICAgIGNoZWNrQXJndW1lbnQob3B0aW9ucy5hc2NlbmRlciwgJ1doZW4gY3JlYXRpbmcgYSBuZXcgRm9udCBvYmplY3QsIGFzY2VuZGVyIGlzIHJlcXVpcmVkLicpO1xuICAgICAgICBjaGVja0FyZ3VtZW50KG9wdGlvbnMuZGVzY2VuZGVyIDw9IDAsICdXaGVuIGNyZWF0aW5nIGEgbmV3IEZvbnQgb2JqZWN0LCBuZWdhdGl2ZSBkZXNjZW5kZXIgdmFsdWUgaXMgcmVxdWlyZWQuJyk7XG5cbiAgICAgICAgLy8gT1MgWCB3aWxsIGNvbXBsYWluIGlmIHRoZSBuYW1lcyBhcmUgZW1wdHksIHNvIHdlIHB1dCBhIHNpbmdsZSBzcGFjZSBldmVyeXdoZXJlIGJ5IGRlZmF1bHQuXG4gICAgICAgIHRoaXMubmFtZXMgPSB7XG4gICAgICAgICAgICBmb250RmFtaWx5OiB7ZW46IG9wdGlvbnMuZmFtaWx5TmFtZSB8fCAnICd9LFxuICAgICAgICAgICAgZm9udFN1YmZhbWlseToge2VuOiBvcHRpb25zLnN0eWxlTmFtZSB8fCAnICd9LFxuICAgICAgICAgICAgZnVsbE5hbWU6IHtlbjogb3B0aW9ucy5mdWxsTmFtZSB8fCBvcHRpb25zLmZhbWlseU5hbWUgKyAnICcgKyBvcHRpb25zLnN0eWxlTmFtZX0sXG4gICAgICAgICAgICAvLyBwb3N0U2NyaXB0TmFtZSBtYXkgbm90IGNvbnRhaW4gYW55IHdoaXRlc3BhY2VcbiAgICAgICAgICAgIHBvc3RTY3JpcHROYW1lOiB7ZW46IG9wdGlvbnMucG9zdFNjcmlwdE5hbWUgfHwgKG9wdGlvbnMuZmFtaWx5TmFtZSArIG9wdGlvbnMuc3R5bGVOYW1lKS5yZXBsYWNlKC9cXHMvZywgJycpfSxcbiAgICAgICAgICAgIGRlc2lnbmVyOiB7ZW46IG9wdGlvbnMuZGVzaWduZXIgfHwgJyAnfSxcbiAgICAgICAgICAgIGRlc2lnbmVyVVJMOiB7ZW46IG9wdGlvbnMuZGVzaWduZXJVUkwgfHwgJyAnfSxcbiAgICAgICAgICAgIG1hbnVmYWN0dXJlcjoge2VuOiBvcHRpb25zLm1hbnVmYWN0dXJlciB8fCAnICd9LFxuICAgICAgICAgICAgbWFudWZhY3R1cmVyVVJMOiB7ZW46IG9wdGlvbnMubWFudWZhY3R1cmVyVVJMIHx8ICcgJ30sXG4gICAgICAgICAgICBsaWNlbnNlOiB7ZW46IG9wdGlvbnMubGljZW5zZSB8fCAnICd9LFxuICAgICAgICAgICAgbGljZW5zZVVSTDoge2VuOiBvcHRpb25zLmxpY2Vuc2VVUkwgfHwgJyAnfSxcbiAgICAgICAgICAgIHZlcnNpb246IHtlbjogb3B0aW9ucy52ZXJzaW9uIHx8ICdWZXJzaW9uIDAuMSd9LFxuICAgICAgICAgICAgZGVzY3JpcHRpb246IHtlbjogb3B0aW9ucy5kZXNjcmlwdGlvbiB8fCAnICd9LFxuICAgICAgICAgICAgY29weXJpZ2h0OiB7ZW46IG9wdGlvbnMuY29weXJpZ2h0IHx8ICcgJ30sXG4gICAgICAgICAgICB0cmFkZW1hcms6IHtlbjogb3B0aW9ucy50cmFkZW1hcmsgfHwgJyAnfVxuICAgICAgICB9O1xuICAgICAgICB0aGlzLnVuaXRzUGVyRW0gPSBvcHRpb25zLnVuaXRzUGVyRW0gfHwgMTAwMDtcbiAgICAgICAgdGhpcy5hc2NlbmRlciA9IG9wdGlvbnMuYXNjZW5kZXI7XG4gICAgICAgIHRoaXMuZGVzY2VuZGVyID0gb3B0aW9ucy5kZXNjZW5kZXI7XG4gICAgICAgIHRoaXMuY3JlYXRlZFRpbWVzdGFtcCA9IG9wdGlvbnMuY3JlYXRlZFRpbWVzdGFtcDtcbiAgICAgICAgdGhpcy50YWJsZXMgPSBPYmplY3QuYXNzaWduKG9wdGlvbnMudGFibGVzLCB7XG4gICAgICAgICAgICBvczI6IE9iamVjdC5hc3NpZ24oe1xuICAgICAgICAgICAgICAgIHVzV2VpZ2h0Q2xhc3M6IG9wdGlvbnMud2VpZ2h0Q2xhc3MgfHwgdGhpcy51c1dlaWdodENsYXNzZXMuTUVESVVNLFxuICAgICAgICAgICAgICAgIHVzV2lkdGhDbGFzczogb3B0aW9ucy53aWR0aENsYXNzIHx8IHRoaXMudXNXaWR0aENsYXNzZXMuTUVESVVNLFxuICAgICAgICAgICAgICAgIGZzU2VsZWN0aW9uOiBvcHRpb25zLmZzU2VsZWN0aW9uIHx8IHRoaXMuZnNTZWxlY3Rpb25WYWx1ZXMuUkVHVUxBUixcbiAgICAgICAgICAgIH0sIG9wdGlvbnMudGFibGVzLm9zMilcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgdGhpcy5zdXBwb3J0ZWQgPSB0cnVlOyAvLyBEZXByZWNhdGVkOiBwYXJzZUJ1ZmZlciB3aWxsIHRocm93IGFuIGVycm9yIGlmIGZvbnQgaXMgbm90IHN1cHBvcnRlZC5cbiAgICB0aGlzLmdseXBocyA9IG5ldyBnbHlwaHNldC5HbHlwaFNldCh0aGlzLCBvcHRpb25zLmdseXBocyB8fCBbXSk7XG4gICAgdGhpcy5lbmNvZGluZyA9IG5ldyBEZWZhdWx0RW5jb2RpbmcodGhpcyk7XG4gICAgdGhpcy5wb3NpdGlvbiA9IG5ldyBQb3NpdGlvbih0aGlzKTtcbiAgICB0aGlzLnN1YnN0aXR1dGlvbiA9IG5ldyBTdWJzdGl0dXRpb24odGhpcyk7XG4gICAgdGhpcy50YWJsZXMgPSB0aGlzLnRhYmxlcyB8fCB7fTtcblxuICAgIC8vIG5lZWRlZCBmb3IgbG93IG1lbW9yeSBtb2RlIG9ubHkuXG4gICAgdGhpcy5fcHVzaCA9IG51bGw7XG4gICAgdGhpcy5faG10eFRhYmxlRGF0YSA9IHt9O1xuXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsICdoaW50aW5nJywge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuX2hpbnRpbmcpIHsgcmV0dXJuIHRoaXMuX2hpbnRpbmc7IH1cbiAgICAgICAgICAgIGlmICh0aGlzLm91dGxpbmVzRm9ybWF0ID09PSAndHJ1ZXR5cGUnKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICh0aGlzLl9oaW50aW5nID0gbmV3IEhpbnRpbmcodGhpcykpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSk7XG59XG5cbi8qKlxuICogQ2hlY2sgaWYgdGhlIGZvbnQgaGFzIGEgZ2x5cGggZm9yIHRoZSBnaXZlbiBjaGFyYWN0ZXIuXG4gKiBAcGFyYW0gIHtzdHJpbmd9XG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICovXG5Gb250LnByb3RvdHlwZS5oYXNDaGFyID0gZnVuY3Rpb24oYykge1xuICAgIHJldHVybiB0aGlzLmVuY29kaW5nLmNoYXJUb0dseXBoSW5kZXgoYykgIT09IG51bGw7XG59O1xuXG4vKipcbiAqIENvbnZlcnQgdGhlIGdpdmVuIGNoYXJhY3RlciB0byBhIHNpbmdsZSBnbHlwaCBpbmRleC5cbiAqIE5vdGUgdGhhdCB0aGlzIGZ1bmN0aW9uIGFzc3VtZXMgdGhhdCB0aGVyZSBpcyBhIG9uZS10by1vbmUgbWFwcGluZyBiZXR3ZWVuXG4gKiB0aGUgZ2l2ZW4gY2hhcmFjdGVyIGFuZCBhIGdseXBoOyBmb3IgY29tcGxleCBzY3JpcHRzIHRoaXMgbWlnaHQgbm90IGJlIHRoZSBjYXNlLlxuICogQHBhcmFtICB7c3RyaW5nfVxuICogQHJldHVybiB7TnVtYmVyfVxuICovXG5Gb250LnByb3RvdHlwZS5jaGFyVG9HbHlwaEluZGV4ID0gZnVuY3Rpb24ocykge1xuICAgIHJldHVybiB0aGlzLmVuY29kaW5nLmNoYXJUb0dseXBoSW5kZXgocyk7XG59O1xuXG4vKipcbiAqIENvbnZlcnQgdGhlIGdpdmVuIGNoYXJhY3RlciB0byBhIHNpbmdsZSBHbHlwaCBvYmplY3QuXG4gKiBOb3RlIHRoYXQgdGhpcyBmdW5jdGlvbiBhc3N1bWVzIHRoYXQgdGhlcmUgaXMgYSBvbmUtdG8tb25lIG1hcHBpbmcgYmV0d2VlblxuICogdGhlIGdpdmVuIGNoYXJhY3RlciBhbmQgYSBnbHlwaDsgZm9yIGNvbXBsZXggc2NyaXB0cyB0aGlzIG1pZ2h0IG5vdCBiZSB0aGUgY2FzZS5cbiAqIEBwYXJhbSAge3N0cmluZ31cbiAqIEByZXR1cm4ge29wZW50eXBlLkdseXBofVxuICovXG5Gb250LnByb3RvdHlwZS5jaGFyVG9HbHlwaCA9IGZ1bmN0aW9uKGMpIHtcbiAgICB2YXIgZ2x5cGhJbmRleCA9IHRoaXMuY2hhclRvR2x5cGhJbmRleChjKTtcbiAgICB2YXIgZ2x5cGggPSB0aGlzLmdseXBocy5nZXQoZ2x5cGhJbmRleCk7XG4gICAgaWYgKCFnbHlwaCkge1xuICAgICAgICAvLyAubm90ZGVmXG4gICAgICAgIGdseXBoID0gdGhpcy5nbHlwaHMuZ2V0KDApO1xuICAgIH1cblxuICAgIHJldHVybiBnbHlwaDtcbn07XG5cbi8qKlxuICogVXBkYXRlIGZlYXR1cmVzXG4gKiBAcGFyYW0ge2FueX0gb3B0aW9ucyBmZWF0dXJlcyBvcHRpb25zXG4gKi9cbkZvbnQucHJvdG90eXBlLnVwZGF0ZUZlYXR1cmVzID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAvLyBUT0RPOiB1cGRhdGUgYWxsIGZlYXR1cmVzIG9wdGlvbnMgbm90IG9ubHkgJ2xhdG4nLlxuICAgIHJldHVybiB0aGlzLmRlZmF1bHRSZW5kZXJPcHRpb25zLmZlYXR1cmVzLm1hcChmdW5jdGlvbiAoZmVhdHVyZSkge1xuICAgICAgICBpZiAoZmVhdHVyZS5zY3JpcHQgPT09ICdsYXRuJykge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBzY3JpcHQ6ICdsYXRuJyxcbiAgICAgICAgICAgICAgICB0YWdzOiBmZWF0dXJlLnRhZ3MuZmlsdGVyKGZ1bmN0aW9uICh0YWcpIHsgcmV0dXJuIG9wdGlvbnNbdGFnXTsgfSlcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gZmVhdHVyZTtcbiAgICAgICAgfVxuICAgIH0pO1xufTtcblxuLyoqXG4gKiBDb252ZXJ0IHRoZSBnaXZlbiB0ZXh0IHRvIGEgbGlzdCBvZiBHbHlwaCBvYmplY3RzLlxuICogTm90ZSB0aGF0IHRoZXJlIGlzIG5vIHN0cmljdCBvbmUtdG8tb25lIG1hcHBpbmcgYmV0d2VlbiBjaGFyYWN0ZXJzIGFuZFxuICogZ2x5cGhzLCBzbyB0aGUgbGlzdCBvZiByZXR1cm5lZCBnbHlwaHMgY2FuIGJlIGxhcmdlciBvciBzbWFsbGVyIHRoYW4gdGhlXG4gKiBsZW5ndGggb2YgdGhlIGdpdmVuIHN0cmluZy5cbiAqIEBwYXJhbSAge3N0cmluZ31cbiAqIEBwYXJhbSAge0dseXBoUmVuZGVyT3B0aW9uc30gW29wdGlvbnNdXG4gKiBAcmV0dXJuIHtvcGVudHlwZS5HbHlwaFtdfVxuICovXG5Gb250LnByb3RvdHlwZS5zdHJpbmdUb0dseXBocyA9IGZ1bmN0aW9uKHMsIG9wdGlvbnMpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuXG4gICAgdmFyIGJpZGkgPSBuZXcgQmlkaSgpO1xuXG4gICAgLy8gQ3JlYXRlIGFuZCByZWdpc3RlciAnZ2x5cGhJbmRleCcgc3RhdGUgbW9kaWZpZXJcbiAgICB2YXIgY2hhclRvR2x5cGhJbmRleE1vZCA9IGZ1bmN0aW9uICh0b2tlbikgeyByZXR1cm4gdGhpcyQxLmNoYXJUb0dseXBoSW5kZXgodG9rZW4uY2hhcik7IH07XG4gICAgYmlkaS5yZWdpc3Rlck1vZGlmaWVyKCdnbHlwaEluZGV4JywgbnVsbCwgY2hhclRvR2x5cGhJbmRleE1vZCk7XG5cbiAgICAvLyByb2xsLWJhY2sgdG8gZGVmYXVsdCBmZWF0dXJlc1xuICAgIHZhciBmZWF0dXJlcyA9IG9wdGlvbnMgP1xuICAgIHRoaXMudXBkYXRlRmVhdHVyZXMob3B0aW9ucy5mZWF0dXJlcykgOlxuICAgIHRoaXMuZGVmYXVsdFJlbmRlck9wdGlvbnMuZmVhdHVyZXM7XG5cbiAgICBiaWRpLmFwcGx5RmVhdHVyZXModGhpcywgZmVhdHVyZXMpO1xuXG4gICAgdmFyIGluZGV4ZXMgPSBiaWRpLmdldFRleHRHbHlwaHMocyk7XG5cbiAgICB2YXIgbGVuZ3RoID0gaW5kZXhlcy5sZW5ndGg7XG5cbiAgICAvLyBjb252ZXJ0IGdseXBoIGluZGV4ZXMgdG8gZ2x5cGggb2JqZWN0c1xuICAgIHZhciBnbHlwaHMgPSBuZXcgQXJyYXkobGVuZ3RoKTtcbiAgICB2YXIgbm90ZGVmID0gdGhpcy5nbHlwaHMuZ2V0KDApO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgZ2x5cGhzW2ldID0gdGhpcy5nbHlwaHMuZ2V0KGluZGV4ZXNbaV0pIHx8IG5vdGRlZjtcbiAgICB9XG4gICAgcmV0dXJuIGdseXBocztcbn07XG5cbi8qKlxuICogQHBhcmFtICB7c3RyaW5nfVxuICogQHJldHVybiB7TnVtYmVyfVxuICovXG5Gb250LnByb3RvdHlwZS5uYW1lVG9HbHlwaEluZGV4ID0gZnVuY3Rpb24obmFtZSkge1xuICAgIHJldHVybiB0aGlzLmdseXBoTmFtZXMubmFtZVRvR2x5cGhJbmRleChuYW1lKTtcbn07XG5cbi8qKlxuICogQHBhcmFtICB7c3RyaW5nfVxuICogQHJldHVybiB7b3BlbnR5cGUuR2x5cGh9XG4gKi9cbkZvbnQucHJvdG90eXBlLm5hbWVUb0dseXBoID0gZnVuY3Rpb24obmFtZSkge1xuICAgIHZhciBnbHlwaEluZGV4ID0gdGhpcy5uYW1lVG9HbHlwaEluZGV4KG5hbWUpO1xuICAgIHZhciBnbHlwaCA9IHRoaXMuZ2x5cGhzLmdldChnbHlwaEluZGV4KTtcbiAgICBpZiAoIWdseXBoKSB7XG4gICAgICAgIC8vIC5ub3RkZWZcbiAgICAgICAgZ2x5cGggPSB0aGlzLmdseXBocy5nZXQoMCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGdseXBoO1xufTtcblxuLyoqXG4gKiBAcGFyYW0gIHtOdW1iZXJ9XG4gKiBAcmV0dXJuIHtTdHJpbmd9XG4gKi9cbkZvbnQucHJvdG90eXBlLmdseXBoSW5kZXhUb05hbWUgPSBmdW5jdGlvbihnaWQpIHtcbiAgICBpZiAoIXRoaXMuZ2x5cGhOYW1lcy5nbHlwaEluZGV4VG9OYW1lKSB7XG4gICAgICAgIHJldHVybiAnJztcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5nbHlwaE5hbWVzLmdseXBoSW5kZXhUb05hbWUoZ2lkKTtcbn07XG5cbi8qKlxuICogUmV0cmlldmUgdGhlIHZhbHVlIG9mIHRoZSBrZXJuaW5nIHBhaXIgYmV0d2VlbiB0aGUgbGVmdCBnbHlwaCAob3IgaXRzIGluZGV4KVxuICogYW5kIHRoZSByaWdodCBnbHlwaCAob3IgaXRzIGluZGV4KS4gSWYgbm8ga2VybmluZyBwYWlyIGlzIGZvdW5kLCByZXR1cm4gMC5cbiAqIFRoZSBrZXJuaW5nIHZhbHVlIGdldHMgYWRkZWQgdG8gdGhlIGFkdmFuY2Ugd2lkdGggd2hlbiBjYWxjdWxhdGluZyB0aGUgc3BhY2luZ1xuICogYmV0d2VlbiBnbHlwaHMuXG4gKiBGb3IgR1BPUyBrZXJuaW5nLCB0aGlzIG1ldGhvZCB1c2VzIHRoZSBkZWZhdWx0IHNjcmlwdCBhbmQgbGFuZ3VhZ2UsIHdoaWNoIGNvdmVyc1xuICogbW9zdCB1c2UgY2FzZXMuIFRvIGhhdmUgZ3JlYXRlciBjb250cm9sLCB1c2UgZm9udC5wb3NpdGlvbi5nZXRLZXJuaW5nVmFsdWUgLlxuICogQHBhcmFtICB7b3BlbnR5cGUuR2x5cGh9IGxlZnRHbHlwaFxuICogQHBhcmFtICB7b3BlbnR5cGUuR2x5cGh9IHJpZ2h0R2x5cGhcbiAqIEByZXR1cm4ge051bWJlcn1cbiAqL1xuRm9udC5wcm90b3R5cGUuZ2V0S2VybmluZ1ZhbHVlID0gZnVuY3Rpb24obGVmdEdseXBoLCByaWdodEdseXBoKSB7XG4gICAgbGVmdEdseXBoID0gbGVmdEdseXBoLmluZGV4IHx8IGxlZnRHbHlwaDtcbiAgICByaWdodEdseXBoID0gcmlnaHRHbHlwaC5pbmRleCB8fCByaWdodEdseXBoO1xuICAgIHZhciBncG9zS2VybmluZyA9IHRoaXMucG9zaXRpb24uZGVmYXVsdEtlcm5pbmdUYWJsZXM7XG4gICAgaWYgKGdwb3NLZXJuaW5nKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnBvc2l0aW9uLmdldEtlcm5pbmdWYWx1ZShncG9zS2VybmluZywgbGVmdEdseXBoLCByaWdodEdseXBoKTtcbiAgICB9XG4gICAgLy8gXCJrZXJuXCIgdGFibGVcbiAgICByZXR1cm4gdGhpcy5rZXJuaW5nUGFpcnNbbGVmdEdseXBoICsgJywnICsgcmlnaHRHbHlwaF0gfHwgMDtcbn07XG5cbi8qKlxuICogQHR5cGVkZWYgR2x5cGhSZW5kZXJPcHRpb25zXG4gKiBAdHlwZSBPYmplY3RcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbc2NyaXB0XSAtIHNjcmlwdCB1c2VkIHRvIGRldGVybWluZSB3aGljaCBmZWF0dXJlcyB0byBhcHBseS4gQnkgZGVmYXVsdCwgJ0RGTFQnIG9yICdsYXRuJyBpcyB1c2VkLlxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgU2VlIGh0dHBzOi8vd3d3Lm1pY3Jvc29mdC5jb20vdHlwb2dyYXBoeS9vdHNwZWMvc2NyaXB0dGFncy5odG1cbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbbGFuZ3VhZ2U9J2RmbHQnXSAtIGxhbmd1YWdlIHN5c3RlbSB1c2VkIHRvIGRldGVybWluZSB3aGljaCBmZWF0dXJlcyB0byBhcHBseS5cbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFNlZSBodHRwczovL3d3dy5taWNyb3NvZnQuY29tL3R5cG9ncmFwaHkvZGV2ZWxvcGVycy9vcGVudHlwZS9sYW5ndWFnZXRhZ3MuYXNweFxuICogQHByb3BlcnR5IHtib29sZWFufSBba2VybmluZz10cnVlXSAtIHdoZXRoZXIgdG8gaW5jbHVkZSBrZXJuaW5nIHZhbHVlc1xuICogQHByb3BlcnR5IHtvYmplY3R9IFtmZWF0dXJlc10gLSBPcGVuVHlwZSBMYXlvdXQgZmVhdHVyZSB0YWdzLiBVc2VkIHRvIGVuYWJsZSBvciBkaXNhYmxlIHRoZSBmZWF0dXJlcyBvZiB0aGUgZ2l2ZW4gc2NyaXB0L2xhbmd1YWdlIHN5c3RlbS5cbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgU2VlIGh0dHBzOi8vd3d3Lm1pY3Jvc29mdC5jb20vdHlwb2dyYXBoeS9vdHNwZWMvZmVhdHVyZXRhZ3MuaHRtXG4gKi9cbkZvbnQucHJvdG90eXBlLmRlZmF1bHRSZW5kZXJPcHRpb25zID0ge1xuICAgIGtlcm5pbmc6IHRydWUsXG4gICAgZmVhdHVyZXM6IFtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIHRoZXNlIDQgZmVhdHVyZXMgYXJlIHJlcXVpcmVkIHRvIHJlbmRlciBBcmFiaWMgdGV4dCBwcm9wZXJseVxuICAgICAgICAgKiBhbmQgc2hvdWxkbid0IGJlIHR1cm5lZCBvZmYgd2hlbiByZW5kZXJpbmcgYXJhYmljIHRleHQuXG4gICAgICAgICAqL1xuICAgICAgICB7IHNjcmlwdDogJ2FyYWInLCB0YWdzOiBbJ2luaXQnLCAnbWVkaScsICdmaW5hJywgJ3JsaWcnXSB9LFxuICAgICAgICB7IHNjcmlwdDogJ2xhdG4nLCB0YWdzOiBbJ2xpZ2EnLCAncmxpZyddIH1cbiAgICBdXG59O1xuXG4vKipcbiAqIEhlbHBlciBmdW5jdGlvbiB0aGF0IGludm9rZXMgdGhlIGdpdmVuIGNhbGxiYWNrIGZvciBlYWNoIGdseXBoIGluIHRoZSBnaXZlbiB0ZXh0LlxuICogVGhlIGNhbGxiYWNrIGdldHMgYChnbHlwaCwgeCwgeSwgZm9udFNpemUsIG9wdGlvbnMpYC4qIEBwYXJhbSAge3N0cmluZ30gdGV4dFxuICogQHBhcmFtIHtzdHJpbmd9IHRleHQgLSBUaGUgdGV4dCB0byBhcHBseS5cbiAqIEBwYXJhbSAge251bWJlcn0gW3g9MF0gLSBIb3Jpem9udGFsIHBvc2l0aW9uIG9mIHRoZSBiZWdpbm5pbmcgb2YgdGhlIHRleHQuXG4gKiBAcGFyYW0gIHtudW1iZXJ9IFt5PTBdIC0gVmVydGljYWwgcG9zaXRpb24gb2YgdGhlICpiYXNlbGluZSogb2YgdGhlIHRleHQuXG4gKiBAcGFyYW0gIHtudW1iZXJ9IFtmb250U2l6ZT03Ml0gLSBGb250IHNpemUgaW4gcGl4ZWxzLiBXZSBzY2FsZSB0aGUgZ2x5cGggdW5pdHMgYnkgYDEgLyB1bml0c1BlckVtICogZm9udFNpemVgLlxuICogQHBhcmFtICB7R2x5cGhSZW5kZXJPcHRpb25zPX0gb3B0aW9uc1xuICogQHBhcmFtICB7RnVuY3Rpb259IGNhbGxiYWNrXG4gKi9cbkZvbnQucHJvdG90eXBlLmZvckVhY2hHbHlwaCA9IGZ1bmN0aW9uKHRleHQsIHgsIHksIGZvbnRTaXplLCBvcHRpb25zLCBjYWxsYmFjaykge1xuICAgIHggPSB4ICE9PSB1bmRlZmluZWQgPyB4IDogMDtcbiAgICB5ID0geSAhPT0gdW5kZWZpbmVkID8geSA6IDA7XG4gICAgZm9udFNpemUgPSBmb250U2l6ZSAhPT0gdW5kZWZpbmVkID8gZm9udFNpemUgOiA3MjtcbiAgICBvcHRpb25zID0gT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5kZWZhdWx0UmVuZGVyT3B0aW9ucywgb3B0aW9ucyk7XG4gICAgdmFyIGZvbnRTY2FsZSA9IDEgLyB0aGlzLnVuaXRzUGVyRW0gKiBmb250U2l6ZTtcbiAgICB2YXIgZ2x5cGhzID0gdGhpcy5zdHJpbmdUb0dseXBocyh0ZXh0LCBvcHRpb25zKTtcbiAgICB2YXIga2VybmluZ0xvb2t1cHM7XG4gICAgaWYgKG9wdGlvbnMua2VybmluZykge1xuICAgICAgICB2YXIgc2NyaXB0ID0gb3B0aW9ucy5zY3JpcHQgfHwgdGhpcy5wb3NpdGlvbi5nZXREZWZhdWx0U2NyaXB0TmFtZSgpO1xuICAgICAgICBrZXJuaW5nTG9va3VwcyA9IHRoaXMucG9zaXRpb24uZ2V0S2VybmluZ1RhYmxlcyhzY3JpcHQsIG9wdGlvbnMubGFuZ3VhZ2UpO1xuICAgIH1cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGdseXBocy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICB2YXIgZ2x5cGggPSBnbHlwaHNbaV07XG4gICAgICAgIGNhbGxiYWNrLmNhbGwodGhpcywgZ2x5cGgsIHgsIHksIGZvbnRTaXplLCBvcHRpb25zKTtcbiAgICAgICAgaWYgKGdseXBoLmFkdmFuY2VXaWR0aCkge1xuICAgICAgICAgICAgeCArPSBnbHlwaC5hZHZhbmNlV2lkdGggKiBmb250U2NhbGU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAob3B0aW9ucy5rZXJuaW5nICYmIGkgPCBnbHlwaHMubGVuZ3RoIC0gMSkge1xuICAgICAgICAgICAgLy8gV2Ugc2hvdWxkIGFwcGx5IHBvc2l0aW9uIGFkanVzdG1lbnQgbG9va3VwcyBpbiBhIG1vcmUgZ2VuZXJpYyB3YXkuXG4gICAgICAgICAgICAvLyBIZXJlIHdlIG9ubHkgdXNlIHRoZSB4QWR2YW5jZSB2YWx1ZS5cbiAgICAgICAgICAgIHZhciBrZXJuaW5nVmFsdWUgPSBrZXJuaW5nTG9va3VwcyA/XG4gICAgICAgICAgICAgICAgICB0aGlzLnBvc2l0aW9uLmdldEtlcm5pbmdWYWx1ZShrZXJuaW5nTG9va3VwcywgZ2x5cGguaW5kZXgsIGdseXBoc1tpICsgMV0uaW5kZXgpIDpcbiAgICAgICAgICAgICAgICAgIHRoaXMuZ2V0S2VybmluZ1ZhbHVlKGdseXBoLCBnbHlwaHNbaSArIDFdKTtcbiAgICAgICAgICAgIHggKz0ga2VybmluZ1ZhbHVlICogZm9udFNjYWxlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG9wdGlvbnMubGV0dGVyU3BhY2luZykge1xuICAgICAgICAgICAgeCArPSBvcHRpb25zLmxldHRlclNwYWNpbmcgKiBmb250U2l6ZTtcbiAgICAgICAgfSBlbHNlIGlmIChvcHRpb25zLnRyYWNraW5nKSB7XG4gICAgICAgICAgICB4ICs9IChvcHRpb25zLnRyYWNraW5nIC8gMTAwMCkgKiBmb250U2l6ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4geDtcbn07XG5cbi8qKlxuICogQ3JlYXRlIGEgUGF0aCBvYmplY3QgdGhhdCByZXByZXNlbnRzIHRoZSBnaXZlbiB0ZXh0LlxuICogQHBhcmFtICB7c3RyaW5nfSB0ZXh0IC0gVGhlIHRleHQgdG8gY3JlYXRlLlxuICogQHBhcmFtICB7bnVtYmVyfSBbeD0wXSAtIEhvcml6b250YWwgcG9zaXRpb24gb2YgdGhlIGJlZ2lubmluZyBvZiB0aGUgdGV4dC5cbiAqIEBwYXJhbSAge251bWJlcn0gW3k9MF0gLSBWZXJ0aWNhbCBwb3NpdGlvbiBvZiB0aGUgKmJhc2VsaW5lKiBvZiB0aGUgdGV4dC5cbiAqIEBwYXJhbSAge251bWJlcn0gW2ZvbnRTaXplPTcyXSAtIEZvbnQgc2l6ZSBpbiBwaXhlbHMuIFdlIHNjYWxlIHRoZSBnbHlwaCB1bml0cyBieSBgMSAvIHVuaXRzUGVyRW0gKiBmb250U2l6ZWAuXG4gKiBAcGFyYW0gIHtHbHlwaFJlbmRlck9wdGlvbnM9fSBvcHRpb25zXG4gKiBAcmV0dXJuIHtvcGVudHlwZS5QYXRofVxuICovXG5Gb250LnByb3RvdHlwZS5nZXRQYXRoID0gZnVuY3Rpb24odGV4dCwgeCwgeSwgZm9udFNpemUsIG9wdGlvbnMpIHtcbiAgICB2YXIgZnVsbFBhdGggPSBuZXcgUGF0aCgpO1xuICAgIHRoaXMuZm9yRWFjaEdseXBoKHRleHQsIHgsIHksIGZvbnRTaXplLCBvcHRpb25zLCBmdW5jdGlvbihnbHlwaCwgZ1gsIGdZLCBnRm9udFNpemUpIHtcbiAgICAgICAgdmFyIGdseXBoUGF0aCA9IGdseXBoLmdldFBhdGgoZ1gsIGdZLCBnRm9udFNpemUsIG9wdGlvbnMsIHRoaXMpO1xuICAgICAgICBmdWxsUGF0aC5leHRlbmQoZ2x5cGhQYXRoKTtcbiAgICB9KTtcbiAgICByZXR1cm4gZnVsbFBhdGg7XG59O1xuXG4vKipcbiAqIENyZWF0ZSBhbiBhcnJheSBvZiBQYXRoIG9iamVjdHMgdGhhdCByZXByZXNlbnQgdGhlIGdseXBocyBvZiBhIGdpdmVuIHRleHQuXG4gKiBAcGFyYW0gIHtzdHJpbmd9IHRleHQgLSBUaGUgdGV4dCB0byBjcmVhdGUuXG4gKiBAcGFyYW0gIHtudW1iZXJ9IFt4PTBdIC0gSG9yaXpvbnRhbCBwb3NpdGlvbiBvZiB0aGUgYmVnaW5uaW5nIG9mIHRoZSB0ZXh0LlxuICogQHBhcmFtICB7bnVtYmVyfSBbeT0wXSAtIFZlcnRpY2FsIHBvc2l0aW9uIG9mIHRoZSAqYmFzZWxpbmUqIG9mIHRoZSB0ZXh0LlxuICogQHBhcmFtICB7bnVtYmVyfSBbZm9udFNpemU9NzJdIC0gRm9udCBzaXplIGluIHBpeGVscy4gV2Ugc2NhbGUgdGhlIGdseXBoIHVuaXRzIGJ5IGAxIC8gdW5pdHNQZXJFbSAqIGZvbnRTaXplYC5cbiAqIEBwYXJhbSAge0dseXBoUmVuZGVyT3B0aW9ucz19IG9wdGlvbnNcbiAqIEByZXR1cm4ge29wZW50eXBlLlBhdGhbXX1cbiAqL1xuRm9udC5wcm90b3R5cGUuZ2V0UGF0aHMgPSBmdW5jdGlvbih0ZXh0LCB4LCB5LCBmb250U2l6ZSwgb3B0aW9ucykge1xuICAgIHZhciBnbHlwaFBhdGhzID0gW107XG4gICAgdGhpcy5mb3JFYWNoR2x5cGgodGV4dCwgeCwgeSwgZm9udFNpemUsIG9wdGlvbnMsIGZ1bmN0aW9uKGdseXBoLCBnWCwgZ1ksIGdGb250U2l6ZSkge1xuICAgICAgICB2YXIgZ2x5cGhQYXRoID0gZ2x5cGguZ2V0UGF0aChnWCwgZ1ksIGdGb250U2l6ZSwgb3B0aW9ucywgdGhpcyk7XG4gICAgICAgIGdseXBoUGF0aHMucHVzaChnbHlwaFBhdGgpO1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIGdseXBoUGF0aHM7XG59O1xuXG4vKipcbiAqIFJldHVybnMgdGhlIGFkdmFuY2Ugd2lkdGggb2YgYSB0ZXh0LlxuICpcbiAqIFRoaXMgaXMgc29tZXRoaW5nIGRpZmZlcmVudCB0aGFuIFBhdGguZ2V0Qm91bmRpbmdCb3goKSBhcyBmb3IgZXhhbXBsZSBhXG4gKiBzdWZmaXhlZCB3aGl0ZXNwYWNlIGluY3JlYXNlcyB0aGUgYWR2YW5jZVdpZHRoIGJ1dCBub3QgdGhlIGJvdW5kaW5nIGJveFxuICogb3IgYW4gb3ZlcmhhbmdpbmcgbGV0dGVyIGxpa2UgYSBjYWxsaWdyYXBoaWMgJ2YnIG1pZ2h0IGhhdmUgYSBxdWl0ZSBsYXJnZXJcbiAqIGJvdW5kaW5nIGJveCB0aGFuIGl0cyBhZHZhbmNlIHdpZHRoLlxuICpcbiAqIFRoaXMgY29ycmVzcG9uZHMgdG8gY2FudmFzMmRDb250ZXh0Lm1lYXN1cmVUZXh0KHRleHQpLndpZHRoXG4gKlxuICogQHBhcmFtICB7c3RyaW5nfSB0ZXh0IC0gVGhlIHRleHQgdG8gY3JlYXRlLlxuICogQHBhcmFtICB7bnVtYmVyfSBbZm9udFNpemU9NzJdIC0gRm9udCBzaXplIGluIHBpeGVscy4gV2Ugc2NhbGUgdGhlIGdseXBoIHVuaXRzIGJ5IGAxIC8gdW5pdHNQZXJFbSAqIGZvbnRTaXplYC5cbiAqIEBwYXJhbSAge0dseXBoUmVuZGVyT3B0aW9ucz19IG9wdGlvbnNcbiAqIEByZXR1cm4gYWR2YW5jZSB3aWR0aFxuICovXG5Gb250LnByb3RvdHlwZS5nZXRBZHZhbmNlV2lkdGggPSBmdW5jdGlvbih0ZXh0LCBmb250U2l6ZSwgb3B0aW9ucykge1xuICAgIHJldHVybiB0aGlzLmZvckVhY2hHbHlwaCh0ZXh0LCAwLCAwLCBmb250U2l6ZSwgb3B0aW9ucywgZnVuY3Rpb24oKSB7fSk7XG59O1xuXG4vKipcbiAqIERyYXcgdGhlIHRleHQgb24gdGhlIGdpdmVuIGRyYXdpbmcgY29udGV4dC5cbiAqIEBwYXJhbSAge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4IC0gQSAyRCBkcmF3aW5nIGNvbnRleHQsIGxpa2UgQ2FudmFzLlxuICogQHBhcmFtICB7c3RyaW5nfSB0ZXh0IC0gVGhlIHRleHQgdG8gY3JlYXRlLlxuICogQHBhcmFtICB7bnVtYmVyfSBbeD0wXSAtIEhvcml6b250YWwgcG9zaXRpb24gb2YgdGhlIGJlZ2lubmluZyBvZiB0aGUgdGV4dC5cbiAqIEBwYXJhbSAge251bWJlcn0gW3k9MF0gLSBWZXJ0aWNhbCBwb3NpdGlvbiBvZiB0aGUgKmJhc2VsaW5lKiBvZiB0aGUgdGV4dC5cbiAqIEBwYXJhbSAge251bWJlcn0gW2ZvbnRTaXplPTcyXSAtIEZvbnQgc2l6ZSBpbiBwaXhlbHMuIFdlIHNjYWxlIHRoZSBnbHlwaCB1bml0cyBieSBgMSAvIHVuaXRzUGVyRW0gKiBmb250U2l6ZWAuXG4gKiBAcGFyYW0gIHtHbHlwaFJlbmRlck9wdGlvbnM9fSBvcHRpb25zXG4gKi9cbkZvbnQucHJvdG90eXBlLmRyYXcgPSBmdW5jdGlvbihjdHgsIHRleHQsIHgsIHksIGZvbnRTaXplLCBvcHRpb25zKSB7XG4gICAgdGhpcy5nZXRQYXRoKHRleHQsIHgsIHksIGZvbnRTaXplLCBvcHRpb25zKS5kcmF3KGN0eCk7XG59O1xuXG4vKipcbiAqIERyYXcgdGhlIHBvaW50cyBvZiBhbGwgZ2x5cGhzIGluIHRoZSB0ZXh0LlxuICogT24tY3VydmUgcG9pbnRzIHdpbGwgYmUgZHJhd24gaW4gYmx1ZSwgb2ZmLWN1cnZlIHBvaW50cyB3aWxsIGJlIGRyYXduIGluIHJlZC5cbiAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHggLSBBIDJEIGRyYXdpbmcgY29udGV4dCwgbGlrZSBDYW52YXMuXG4gKiBAcGFyYW0ge3N0cmluZ30gdGV4dCAtIFRoZSB0ZXh0IHRvIGNyZWF0ZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbeD0wXSAtIEhvcml6b250YWwgcG9zaXRpb24gb2YgdGhlIGJlZ2lubmluZyBvZiB0aGUgdGV4dC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbeT0wXSAtIFZlcnRpY2FsIHBvc2l0aW9uIG9mIHRoZSAqYmFzZWxpbmUqIG9mIHRoZSB0ZXh0LlxuICogQHBhcmFtIHtudW1iZXJ9IFtmb250U2l6ZT03Ml0gLSBGb250IHNpemUgaW4gcGl4ZWxzLiBXZSBzY2FsZSB0aGUgZ2x5cGggdW5pdHMgYnkgYDEgLyB1bml0c1BlckVtICogZm9udFNpemVgLlxuICogQHBhcmFtIHtHbHlwaFJlbmRlck9wdGlvbnM9fSBvcHRpb25zXG4gKi9cbkZvbnQucHJvdG90eXBlLmRyYXdQb2ludHMgPSBmdW5jdGlvbihjdHgsIHRleHQsIHgsIHksIGZvbnRTaXplLCBvcHRpb25zKSB7XG4gICAgdGhpcy5mb3JFYWNoR2x5cGgodGV4dCwgeCwgeSwgZm9udFNpemUsIG9wdGlvbnMsIGZ1bmN0aW9uKGdseXBoLCBnWCwgZ1ksIGdGb250U2l6ZSkge1xuICAgICAgICBnbHlwaC5kcmF3UG9pbnRzKGN0eCwgZ1gsIGdZLCBnRm9udFNpemUpO1xuICAgIH0pO1xufTtcblxuLyoqXG4gKiBEcmF3IGxpbmVzIGluZGljYXRpbmcgaW1wb3J0YW50IGZvbnQgbWVhc3VyZW1lbnRzIGZvciBhbGwgZ2x5cGhzIGluIHRoZSB0ZXh0LlxuICogQmxhY2sgbGluZXMgaW5kaWNhdGUgdGhlIG9yaWdpbiBvZiB0aGUgY29vcmRpbmF0ZSBzeXN0ZW0gKHBvaW50IDAsMCkuXG4gKiBCbHVlIGxpbmVzIGluZGljYXRlIHRoZSBnbHlwaCBib3VuZGluZyBib3guXG4gKiBHcmVlbiBsaW5lIGluZGljYXRlcyB0aGUgYWR2YW5jZSB3aWR0aCBvZiB0aGUgZ2x5cGguXG4gKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4IC0gQSAyRCBkcmF3aW5nIGNvbnRleHQsIGxpa2UgQ2FudmFzLlxuICogQHBhcmFtIHtzdHJpbmd9IHRleHQgLSBUaGUgdGV4dCB0byBjcmVhdGUuXG4gKiBAcGFyYW0ge251bWJlcn0gW3g9MF0gLSBIb3Jpem9udGFsIHBvc2l0aW9uIG9mIHRoZSBiZWdpbm5pbmcgb2YgdGhlIHRleHQuXG4gKiBAcGFyYW0ge251bWJlcn0gW3k9MF0gLSBWZXJ0aWNhbCBwb3NpdGlvbiBvZiB0aGUgKmJhc2VsaW5lKiBvZiB0aGUgdGV4dC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbZm9udFNpemU9NzJdIC0gRm9udCBzaXplIGluIHBpeGVscy4gV2Ugc2NhbGUgdGhlIGdseXBoIHVuaXRzIGJ5IGAxIC8gdW5pdHNQZXJFbSAqIGZvbnRTaXplYC5cbiAqIEBwYXJhbSB7R2x5cGhSZW5kZXJPcHRpb25zPX0gb3B0aW9uc1xuICovXG5Gb250LnByb3RvdHlwZS5kcmF3TWV0cmljcyA9IGZ1bmN0aW9uKGN0eCwgdGV4dCwgeCwgeSwgZm9udFNpemUsIG9wdGlvbnMpIHtcbiAgICB0aGlzLmZvckVhY2hHbHlwaCh0ZXh0LCB4LCB5LCBmb250U2l6ZSwgb3B0aW9ucywgZnVuY3Rpb24oZ2x5cGgsIGdYLCBnWSwgZ0ZvbnRTaXplKSB7XG4gICAgICAgIGdseXBoLmRyYXdNZXRyaWNzKGN0eCwgZ1gsIGdZLCBnRm9udFNpemUpO1xuICAgIH0pO1xufTtcblxuLyoqXG4gKiBAcGFyYW0gIHtzdHJpbmd9XG4gKiBAcmV0dXJuIHtzdHJpbmd9XG4gKi9cbkZvbnQucHJvdG90eXBlLmdldEVuZ2xpc2hOYW1lID0gZnVuY3Rpb24obmFtZSkge1xuICAgIHZhciB0cmFuc2xhdGlvbnMgPSB0aGlzLm5hbWVzW25hbWVdO1xuICAgIGlmICh0cmFuc2xhdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIHRyYW5zbGF0aW9ucy5lbjtcbiAgICB9XG59O1xuXG4vKipcbiAqIFZhbGlkYXRlXG4gKi9cbkZvbnQucHJvdG90eXBlLnZhbGlkYXRlID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgIGZ1bmN0aW9uIGFzc2VydChwcmVkaWNhdGUsIG1lc3NhZ2UpIHtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBhc3NlcnROYW1lUHJlc2VudChuYW1lKSB7XG4gICAgICAgIHZhciBlbmdsaXNoTmFtZSA9IF90aGlzLmdldEVuZ2xpc2hOYW1lKG5hbWUpO1xuICAgICAgICBhc3NlcnQoZW5nbGlzaE5hbWUgJiYgZW5nbGlzaE5hbWUudHJpbSgpLmxlbmd0aCA+IDApO1xuICAgIH1cblxuICAgIC8vIElkZW50aWZpY2F0aW9uIGluZm9ybWF0aW9uXG4gICAgYXNzZXJ0TmFtZVByZXNlbnQoJ2ZvbnRGYW1pbHknKTtcbiAgICBhc3NlcnROYW1lUHJlc2VudCgnd2VpZ2h0TmFtZScpO1xuICAgIGFzc2VydE5hbWVQcmVzZW50KCdtYW51ZmFjdHVyZXInKTtcbiAgICBhc3NlcnROYW1lUHJlc2VudCgnY29weXJpZ2h0Jyk7XG4gICAgYXNzZXJ0TmFtZVByZXNlbnQoJ3ZlcnNpb24nKTtcblxuICAgIC8vIERpbWVuc2lvbiBpbmZvcm1hdGlvblxuICAgIGFzc2VydCh0aGlzLnVuaXRzUGVyRW0gPiAwKTtcbn07XG5cbi8qKlxuICogQ29udmVydCB0aGUgZm9udCBvYmplY3QgdG8gYSBTRk5UIGRhdGEgc3RydWN0dXJlLlxuICogVGhpcyBzdHJ1Y3R1cmUgY29udGFpbnMgYWxsIHRoZSBuZWNlc3NhcnkgdGFibGVzIGFuZCBtZXRhZGF0YSB0byBjcmVhdGUgYSBiaW5hcnkgT1RGIGZpbGUuXG4gKiBAcmV0dXJuIHtvcGVudHlwZS5UYWJsZX1cbiAqL1xuRm9udC5wcm90b3R5cGUudG9UYWJsZXMgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gc2ZudC5mb250VG9UYWJsZSh0aGlzKTtcbn07XG4vKipcbiAqIEBkZXByZWNhdGVkIEZvbnQudG9CdWZmZXIgaXMgZGVwcmVjYXRlZC4gVXNlIEZvbnQudG9BcnJheUJ1ZmZlciBpbnN0ZWFkLlxuICovXG5Gb250LnByb3RvdHlwZS50b0J1ZmZlciA9IGZ1bmN0aW9uKCkge1xuICAgIGNvbnNvbGUud2FybignRm9udC50b0J1ZmZlciBpcyBkZXByZWNhdGVkLiBVc2UgRm9udC50b0FycmF5QnVmZmVyIGluc3RlYWQuJyk7XG4gICAgcmV0dXJuIHRoaXMudG9BcnJheUJ1ZmZlcigpO1xufTtcbi8qKlxuICogQ29udmVydHMgYSBgb3BlbnR5cGUuRm9udGAgaW50byBhbiBgQXJyYXlCdWZmZXJgXG4gKiBAcmV0dXJuIHtBcnJheUJ1ZmZlcn1cbiAqL1xuRm9udC5wcm90b3R5cGUudG9BcnJheUJ1ZmZlciA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBzZm50VGFibGUgPSB0aGlzLnRvVGFibGVzKCk7XG4gICAgdmFyIGJ5dGVzID0gc2ZudFRhYmxlLmVuY29kZSgpO1xuICAgIHZhciBidWZmZXIgPSBuZXcgQXJyYXlCdWZmZXIoYnl0ZXMubGVuZ3RoKTtcbiAgICB2YXIgaW50QXJyYXkgPSBuZXcgVWludDhBcnJheShidWZmZXIpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYnl0ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaW50QXJyYXlbaV0gPSBieXRlc1tpXTtcbiAgICB9XG5cbiAgICByZXR1cm4gYnVmZmVyO1xufTtcblxuLyoqXG4gKiBJbml0aWF0ZSBhIGRvd25sb2FkIG9mIHRoZSBPcGVuVHlwZSBmb250LlxuICovXG5Gb250LnByb3RvdHlwZS5kb3dubG9hZCA9IGZ1bmN0aW9uKGZpbGVOYW1lKSB7XG4gICAgdmFyIGZhbWlseU5hbWUgPSB0aGlzLmdldEVuZ2xpc2hOYW1lKCdmb250RmFtaWx5Jyk7XG4gICAgdmFyIHN0eWxlTmFtZSA9IHRoaXMuZ2V0RW5nbGlzaE5hbWUoJ2ZvbnRTdWJmYW1pbHknKTtcbiAgICBmaWxlTmFtZSA9IGZpbGVOYW1lIHx8IGZhbWlseU5hbWUucmVwbGFjZSgvXFxzL2csICcnKSArICctJyArIHN0eWxlTmFtZSArICcub3RmJztcbiAgICB2YXIgYXJyYXlCdWZmZXIgPSB0aGlzLnRvQXJyYXlCdWZmZXIoKTtcblxuICAgIGlmIChpc0Jyb3dzZXIoKSkge1xuICAgICAgICB3aW5kb3cuVVJMID0gd2luZG93LlVSTCB8fCB3aW5kb3cud2Via2l0VVJMO1xuXG4gICAgICAgIGlmICh3aW5kb3cuVVJMKSB7XG4gICAgICAgICAgICB2YXIgZGF0YVZpZXcgPSBuZXcgRGF0YVZpZXcoYXJyYXlCdWZmZXIpO1xuICAgICAgICAgICAgdmFyIGJsb2IgPSBuZXcgQmxvYihbZGF0YVZpZXddLCB7dHlwZTogJ2ZvbnQvb3BlbnR5cGUnfSk7XG5cbiAgICAgICAgICAgIHZhciBsaW5rID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnYScpO1xuICAgICAgICAgICAgbGluay5ocmVmID0gd2luZG93LlVSTC5jcmVhdGVPYmplY3RVUkwoYmxvYik7XG4gICAgICAgICAgICBsaW5rLmRvd25sb2FkID0gZmlsZU5hbWU7XG5cbiAgICAgICAgICAgIHZhciBldmVudCA9IGRvY3VtZW50LmNyZWF0ZUV2ZW50KCdNb3VzZUV2ZW50cycpO1xuICAgICAgICAgICAgZXZlbnQuaW5pdEV2ZW50KCdjbGljaycsIHRydWUsIGZhbHNlKTtcbiAgICAgICAgICAgIGxpbmsuZGlzcGF0Y2hFdmVudChldmVudCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oJ0ZvbnQgZmlsZSBjb3VsZCBub3QgYmUgZG93bmxvYWRlZC4gVHJ5IHVzaW5nIGEgZGlmZmVyZW50IGJyb3dzZXIuJyk7XG4gICAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgZnMgPSByZXF1aXJlKCdmcycpO1xuICAgICAgICB2YXIgYnVmZmVyID0gYXJyYXlCdWZmZXJUb05vZGVCdWZmZXIoYXJyYXlCdWZmZXIpO1xuICAgICAgICBmcy53cml0ZUZpbGVTeW5jKGZpbGVOYW1lLCBidWZmZXIpO1xuICAgIH1cbn07XG4vKipcbiAqIEBwcml2YXRlXG4gKi9cbkZvbnQucHJvdG90eXBlLmZzU2VsZWN0aW9uVmFsdWVzID0ge1xuICAgIElUQUxJQzogICAgICAgICAgICAgIDB4MDAxLCAvLzFcbiAgICBVTkRFUlNDT1JFOiAgICAgICAgICAweDAwMiwgLy8yXG4gICAgTkVHQVRJVkU6ICAgICAgICAgICAgMHgwMDQsIC8vNFxuICAgIE9VVExJTkVEOiAgICAgICAgICAgIDB4MDA4LCAvLzhcbiAgICBTVFJJS0VPVVQ6ICAgICAgICAgICAweDAxMCwgLy8xNlxuICAgIEJPTEQ6ICAgICAgICAgICAgICAgIDB4MDIwLCAvLzMyXG4gICAgUkVHVUxBUjogICAgICAgICAgICAgMHgwNDAsIC8vNjRcbiAgICBVU0VSX1RZUE9fTUVUUklDUzogICAweDA4MCwgLy8xMjhcbiAgICBXV1M6ICAgICAgICAgICAgICAgICAweDEwMCwgLy8yNTZcbiAgICBPQkxJUVVFOiAgICAgICAgICAgICAweDIwMCAgLy81MTJcbn07XG5cbi8qKlxuICogQHByaXZhdGVcbiAqL1xuRm9udC5wcm90b3R5cGUudXNXaWR0aENsYXNzZXMgPSB7XG4gICAgVUxUUkFfQ09OREVOU0VEOiAxLFxuICAgIEVYVFJBX0NPTkRFTlNFRDogMixcbiAgICBDT05ERU5TRUQ6IDMsXG4gICAgU0VNSV9DT05ERU5TRUQ6IDQsXG4gICAgTUVESVVNOiA1LFxuICAgIFNFTUlfRVhQQU5ERUQ6IDYsXG4gICAgRVhQQU5ERUQ6IDcsXG4gICAgRVhUUkFfRVhQQU5ERUQ6IDgsXG4gICAgVUxUUkFfRVhQQU5ERUQ6IDlcbn07XG5cbi8qKlxuICogQHByaXZhdGVcbiAqL1xuRm9udC5wcm90b3R5cGUudXNXZWlnaHRDbGFzc2VzID0ge1xuICAgIFRISU46IDEwMCxcbiAgICBFWFRSQV9MSUdIVDogMjAwLFxuICAgIExJR0hUOiAzMDAsXG4gICAgTk9STUFMOiA0MDAsXG4gICAgTUVESVVNOiA1MDAsXG4gICAgU0VNSV9CT0xEOiA2MDAsXG4gICAgQk9MRDogNzAwLFxuICAgIEVYVFJBX0JPTEQ6IDgwMCxcbiAgICBCTEFDSzogICAgOTAwXG59O1xuXG4vLyBUaGUgYGZ2YXJgIHRhYmxlIHN0b3JlcyBmb250IHZhcmlhdGlvbiBheGVzIGFuZCBpbnN0YW5jZXMuXG5cbmZ1bmN0aW9uIGFkZE5hbWUobmFtZSwgbmFtZXMpIHtcbiAgICB2YXIgbmFtZVN0cmluZyA9IEpTT04uc3RyaW5naWZ5KG5hbWUpO1xuICAgIHZhciBuYW1lSUQgPSAyNTY7XG4gICAgZm9yICh2YXIgbmFtZUtleSBpbiBuYW1lcykge1xuICAgICAgICB2YXIgbiA9IHBhcnNlSW50KG5hbWVLZXkpO1xuICAgICAgICBpZiAoIW4gfHwgbiA8IDI1Nikge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoSlNPTi5zdHJpbmdpZnkobmFtZXNbbmFtZUtleV0pID09PSBuYW1lU3RyaW5nKSB7XG4gICAgICAgICAgICByZXR1cm4gbjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChuYW1lSUQgPD0gbikge1xuICAgICAgICAgICAgbmFtZUlEID0gbiArIDE7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBuYW1lc1tuYW1lSURdID0gbmFtZTtcbiAgICByZXR1cm4gbmFtZUlEO1xufVxuXG5mdW5jdGlvbiBtYWtlRnZhckF4aXMobiwgYXhpcywgbmFtZXMpIHtcbiAgICB2YXIgbmFtZUlEID0gYWRkTmFtZShheGlzLm5hbWUsIG5hbWVzKTtcbiAgICByZXR1cm4gW1xuICAgICAgICB7bmFtZTogJ3RhZ18nICsgbiwgdHlwZTogJ1RBRycsIHZhbHVlOiBheGlzLnRhZ30sXG4gICAgICAgIHtuYW1lOiAnbWluVmFsdWVfJyArIG4sIHR5cGU6ICdGSVhFRCcsIHZhbHVlOiBheGlzLm1pblZhbHVlIDw8IDE2fSxcbiAgICAgICAge25hbWU6ICdkZWZhdWx0VmFsdWVfJyArIG4sIHR5cGU6ICdGSVhFRCcsIHZhbHVlOiBheGlzLmRlZmF1bHRWYWx1ZSA8PCAxNn0sXG4gICAgICAgIHtuYW1lOiAnbWF4VmFsdWVfJyArIG4sIHR5cGU6ICdGSVhFRCcsIHZhbHVlOiBheGlzLm1heFZhbHVlIDw8IDE2fSxcbiAgICAgICAge25hbWU6ICdmbGFnc18nICsgbiwgdHlwZTogJ1VTSE9SVCcsIHZhbHVlOiAwfSxcbiAgICAgICAge25hbWU6ICduYW1lSURfJyArIG4sIHR5cGU6ICdVU0hPUlQnLCB2YWx1ZTogbmFtZUlEfVxuICAgIF07XG59XG5cbmZ1bmN0aW9uIHBhcnNlRnZhckF4aXMoZGF0YSwgc3RhcnQsIG5hbWVzKSB7XG4gICAgdmFyIGF4aXMgPSB7fTtcbiAgICB2YXIgcCA9IG5ldyBwYXJzZS5QYXJzZXIoZGF0YSwgc3RhcnQpO1xuICAgIGF4aXMudGFnID0gcC5wYXJzZVRhZygpO1xuICAgIGF4aXMubWluVmFsdWUgPSBwLnBhcnNlRml4ZWQoKTtcbiAgICBheGlzLmRlZmF1bHRWYWx1ZSA9IHAucGFyc2VGaXhlZCgpO1xuICAgIGF4aXMubWF4VmFsdWUgPSBwLnBhcnNlRml4ZWQoKTtcbiAgICBwLnNraXAoJ3VTaG9ydCcsIDEpOyAgLy8gcmVzZXJ2ZWQgZm9yIGZsYWdzOyBubyB2YWx1ZXMgZGVmaW5lZFxuICAgIGF4aXMubmFtZSA9IG5hbWVzW3AucGFyc2VVU2hvcnQoKV0gfHwge307XG4gICAgcmV0dXJuIGF4aXM7XG59XG5cbmZ1bmN0aW9uIG1ha2VGdmFySW5zdGFuY2UobiwgaW5zdCwgYXhlcywgbmFtZXMpIHtcbiAgICB2YXIgbmFtZUlEID0gYWRkTmFtZShpbnN0Lm5hbWUsIG5hbWVzKTtcbiAgICB2YXIgZmllbGRzID0gW1xuICAgICAgICB7bmFtZTogJ25hbWVJRF8nICsgbiwgdHlwZTogJ1VTSE9SVCcsIHZhbHVlOiBuYW1lSUR9LFxuICAgICAgICB7bmFtZTogJ2ZsYWdzXycgKyBuLCB0eXBlOiAnVVNIT1JUJywgdmFsdWU6IDB9XG4gICAgXTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXhlcy5sZW5ndGg7ICsraSkge1xuICAgICAgICB2YXIgYXhpc1RhZyA9IGF4ZXNbaV0udGFnO1xuICAgICAgICBmaWVsZHMucHVzaCh7XG4gICAgICAgICAgICBuYW1lOiAnYXhpc18nICsgbiArICcgJyArIGF4aXNUYWcsXG4gICAgICAgICAgICB0eXBlOiAnRklYRUQnLFxuICAgICAgICAgICAgdmFsdWU6IGluc3QuY29vcmRpbmF0ZXNbYXhpc1RhZ10gPDwgMTZcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZpZWxkcztcbn1cblxuZnVuY3Rpb24gcGFyc2VGdmFySW5zdGFuY2UoZGF0YSwgc3RhcnQsIGF4ZXMsIG5hbWVzKSB7XG4gICAgdmFyIGluc3QgPSB7fTtcbiAgICB2YXIgcCA9IG5ldyBwYXJzZS5QYXJzZXIoZGF0YSwgc3RhcnQpO1xuICAgIGluc3QubmFtZSA9IG5hbWVzW3AucGFyc2VVU2hvcnQoKV0gfHwge307XG4gICAgcC5za2lwKCd1U2hvcnQnLCAxKTsgIC8vIHJlc2VydmVkIGZvciBmbGFnczsgbm8gdmFsdWVzIGRlZmluZWRcblxuICAgIGluc3QuY29vcmRpbmF0ZXMgPSB7fTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGF4ZXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgaW5zdC5jb29yZGluYXRlc1theGVzW2ldLnRhZ10gPSBwLnBhcnNlRml4ZWQoKTtcbiAgICB9XG5cbiAgICByZXR1cm4gaW5zdDtcbn1cblxuZnVuY3Rpb24gbWFrZUZ2YXJUYWJsZShmdmFyLCBuYW1lcykge1xuICAgIHZhciByZXN1bHQgPSBuZXcgdGFibGUuVGFibGUoJ2Z2YXInLCBbXG4gICAgICAgIHtuYW1lOiAndmVyc2lvbicsIHR5cGU6ICdVTE9ORycsIHZhbHVlOiAweDEwMDAwfSxcbiAgICAgICAge25hbWU6ICdvZmZzZXRUb0RhdGEnLCB0eXBlOiAnVVNIT1JUJywgdmFsdWU6IDB9LFxuICAgICAgICB7bmFtZTogJ2NvdW50U2l6ZVBhaXJzJywgdHlwZTogJ1VTSE9SVCcsIHZhbHVlOiAyfSxcbiAgICAgICAge25hbWU6ICdheGlzQ291bnQnLCB0eXBlOiAnVVNIT1JUJywgdmFsdWU6IGZ2YXIuYXhlcy5sZW5ndGh9LFxuICAgICAgICB7bmFtZTogJ2F4aXNTaXplJywgdHlwZTogJ1VTSE9SVCcsIHZhbHVlOiAyMH0sXG4gICAgICAgIHtuYW1lOiAnaW5zdGFuY2VDb3VudCcsIHR5cGU6ICdVU0hPUlQnLCB2YWx1ZTogZnZhci5pbnN0YW5jZXMubGVuZ3RofSxcbiAgICAgICAge25hbWU6ICdpbnN0YW5jZVNpemUnLCB0eXBlOiAnVVNIT1JUJywgdmFsdWU6IDQgKyBmdmFyLmF4ZXMubGVuZ3RoICogNH1cbiAgICBdKTtcbiAgICByZXN1bHQub2Zmc2V0VG9EYXRhID0gcmVzdWx0LnNpemVPZigpO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBmdmFyLmF4ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgcmVzdWx0LmZpZWxkcyA9IHJlc3VsdC5maWVsZHMuY29uY2F0KG1ha2VGdmFyQXhpcyhpLCBmdmFyLmF4ZXNbaV0sIG5hbWVzKSk7XG4gICAgfVxuXG4gICAgZm9yICh2YXIgaiA9IDA7IGogPCBmdmFyLmluc3RhbmNlcy5sZW5ndGg7IGorKykge1xuICAgICAgICByZXN1bHQuZmllbGRzID0gcmVzdWx0LmZpZWxkcy5jb25jYXQobWFrZUZ2YXJJbnN0YW5jZShqLCBmdmFyLmluc3RhbmNlc1tqXSwgZnZhci5heGVzLCBuYW1lcykpO1xuICAgIH1cblxuICAgIHJldHVybiByZXN1bHQ7XG59XG5cbmZ1bmN0aW9uIHBhcnNlRnZhclRhYmxlKGRhdGEsIHN0YXJ0LCBuYW1lcykge1xuICAgIHZhciBwID0gbmV3IHBhcnNlLlBhcnNlcihkYXRhLCBzdGFydCk7XG4gICAgdmFyIHRhYmxlVmVyc2lvbiA9IHAucGFyc2VVTG9uZygpO1xuICAgIGNoZWNrLmFyZ3VtZW50KHRhYmxlVmVyc2lvbiA9PT0gMHgwMDAxMDAwMCwgJ1Vuc3VwcG9ydGVkIGZ2YXIgdGFibGUgdmVyc2lvbi4nKTtcbiAgICB2YXIgb2Zmc2V0VG9EYXRhID0gcC5wYXJzZU9mZnNldDE2KCk7XG4gICAgLy8gU2tpcCBjb3VudFNpemVQYWlycy5cbiAgICBwLnNraXAoJ3VTaG9ydCcsIDEpO1xuICAgIHZhciBheGlzQ291bnQgPSBwLnBhcnNlVVNob3J0KCk7XG4gICAgdmFyIGF4aXNTaXplID0gcC5wYXJzZVVTaG9ydCgpO1xuICAgIHZhciBpbnN0YW5jZUNvdW50ID0gcC5wYXJzZVVTaG9ydCgpO1xuICAgIHZhciBpbnN0YW5jZVNpemUgPSBwLnBhcnNlVVNob3J0KCk7XG5cbiAgICB2YXIgYXhlcyA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXhpc0NvdW50OyBpKyspIHtcbiAgICAgICAgYXhlcy5wdXNoKHBhcnNlRnZhckF4aXMoZGF0YSwgc3RhcnQgKyBvZmZzZXRUb0RhdGEgKyBpICogYXhpc1NpemUsIG5hbWVzKSk7XG4gICAgfVxuXG4gICAgdmFyIGluc3RhbmNlcyA9IFtdO1xuICAgIHZhciBpbnN0YW5jZVN0YXJ0ID0gc3RhcnQgKyBvZmZzZXRUb0RhdGEgKyBheGlzQ291bnQgKiBheGlzU2l6ZTtcbiAgICBmb3IgKHZhciBqID0gMDsgaiA8IGluc3RhbmNlQ291bnQ7IGorKykge1xuICAgICAgICBpbnN0YW5jZXMucHVzaChwYXJzZUZ2YXJJbnN0YW5jZShkYXRhLCBpbnN0YW5jZVN0YXJ0ICsgaiAqIGluc3RhbmNlU2l6ZSwgYXhlcywgbmFtZXMpKTtcbiAgICB9XG5cbiAgICByZXR1cm4ge2F4ZXM6IGF4ZXMsIGluc3RhbmNlczogaW5zdGFuY2VzfTtcbn1cblxudmFyIGZ2YXIgPSB7IG1ha2U6IG1ha2VGdmFyVGFibGUsIHBhcnNlOiBwYXJzZUZ2YXJUYWJsZSB9O1xuXG4vLyBUaGUgYEdERUZgIHRhYmxlIGNvbnRhaW5zIHZhcmlvdXMgZ2x5cGggcHJvcGVydGllc1xuXG52YXIgYXR0YWNoTGlzdCA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB7XG4gICAgICAgIGNvdmVyYWdlOiB0aGlzLnBhcnNlUG9pbnRlcihQYXJzZXIuY292ZXJhZ2UpLFxuICAgICAgICBhdHRhY2hQb2ludHM6IHRoaXMucGFyc2VMaXN0KFBhcnNlci5wb2ludGVyKFBhcnNlci51U2hvcnRMaXN0KSlcbiAgICB9O1xufTtcblxudmFyIGNhcmV0VmFsdWUgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgZm9ybWF0ID0gdGhpcy5wYXJzZVVTaG9ydCgpO1xuICAgIGNoZWNrLmFyZ3VtZW50KGZvcm1hdCA9PT0gMSB8fCBmb3JtYXQgPT09IDIgfHwgZm9ybWF0ID09PSAzLFxuICAgICAgICAnVW5zdXBwb3J0ZWQgQ2FyZXRWYWx1ZSB0YWJsZSB2ZXJzaW9uLicpO1xuICAgIGlmIChmb3JtYXQgPT09IDEpIHtcbiAgICAgICAgcmV0dXJuIHsgY29vcmRpbmF0ZTogdGhpcy5wYXJzZVNob3J0KCkgfTtcbiAgICB9IGVsc2UgaWYgKGZvcm1hdCA9PT0gMikge1xuICAgICAgICByZXR1cm4geyBwb2ludGluZGV4OiB0aGlzLnBhcnNlU2hvcnQoKSB9O1xuICAgIH0gZWxzZSBpZiAoZm9ybWF0ID09PSAzKSB7XG4gICAgICAgIC8vIERldmljZSAvIFZhcmlhdGlvbiBJbmRleCB0YWJsZXMgdW5zdXBwb3J0ZWRcbiAgICAgICAgcmV0dXJuIHsgY29vcmRpbmF0ZTogdGhpcy5wYXJzZVNob3J0KCkgfTtcbiAgICB9XG59O1xuXG52YXIgbGlnR2x5cGggPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5wYXJzZUxpc3QoUGFyc2VyLnBvaW50ZXIoY2FyZXRWYWx1ZSkpO1xufTtcblxudmFyIGxpZ0NhcmV0TGlzdCA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB7XG4gICAgICAgIGNvdmVyYWdlOiB0aGlzLnBhcnNlUG9pbnRlcihQYXJzZXIuY292ZXJhZ2UpLFxuICAgICAgICBsaWdHbHlwaHM6IHRoaXMucGFyc2VMaXN0KFBhcnNlci5wb2ludGVyKGxpZ0dseXBoKSlcbiAgICB9O1xufTtcblxudmFyIG1hcmtHbHlwaFNldHMgPSBmdW5jdGlvbigpIHtcbiAgICB0aGlzLnBhcnNlVVNob3J0KCk7IC8vIFZlcnNpb25cbiAgICByZXR1cm4gdGhpcy5wYXJzZUxpc3QoUGFyc2VyLnBvaW50ZXIoUGFyc2VyLmNvdmVyYWdlKSk7XG59O1xuXG5mdW5jdGlvbiBwYXJzZUdERUZUYWJsZShkYXRhLCBzdGFydCkge1xuICAgIHN0YXJ0ID0gc3RhcnQgfHwgMDtcbiAgICB2YXIgcCA9IG5ldyBQYXJzZXIoZGF0YSwgc3RhcnQpO1xuICAgIHZhciB0YWJsZVZlcnNpb24gPSBwLnBhcnNlVmVyc2lvbigxKTtcbiAgICBjaGVjay5hcmd1bWVudCh0YWJsZVZlcnNpb24gPT09IDEgfHwgdGFibGVWZXJzaW9uID09PSAxLjIgfHwgdGFibGVWZXJzaW9uID09PSAxLjMsXG4gICAgICAgICdVbnN1cHBvcnRlZCBHREVGIHRhYmxlIHZlcnNpb24uJyk7XG4gICAgdmFyIGdkZWYgPSB7XG4gICAgICAgIHZlcnNpb246IHRhYmxlVmVyc2lvbixcbiAgICAgICAgY2xhc3NEZWY6IHAucGFyc2VQb2ludGVyKFBhcnNlci5jbGFzc0RlZiksXG4gICAgICAgIGF0dGFjaExpc3Q6IHAucGFyc2VQb2ludGVyKGF0dGFjaExpc3QpLFxuICAgICAgICBsaWdDYXJldExpc3Q6IHAucGFyc2VQb2ludGVyKGxpZ0NhcmV0TGlzdCksXG4gICAgICAgIG1hcmtBdHRhY2hDbGFzc0RlZjogcC5wYXJzZVBvaW50ZXIoUGFyc2VyLmNsYXNzRGVmKVxuICAgIH07XG4gICAgaWYgKHRhYmxlVmVyc2lvbiA+PSAxLjIpIHtcbiAgICAgICAgZ2RlZi5tYXJrR2x5cGhTZXRzID0gcC5wYXJzZVBvaW50ZXIobWFya0dseXBoU2V0cyk7XG4gICAgfVxuICAgIHJldHVybiBnZGVmO1xufVxudmFyIGdkZWYgPSB7IHBhcnNlOiBwYXJzZUdERUZUYWJsZSB9O1xuXG4vLyBUaGUgYEdQT1NgIHRhYmxlIGNvbnRhaW5zIGtlcm5pbmcgcGFpcnMsIGFtb25nIG90aGVyIHRoaW5ncy5cblxudmFyIHN1YnRhYmxlUGFyc2VycyQxID0gbmV3IEFycmF5KDEwKTsgICAgICAgICAvLyBzdWJ0YWJsZVBhcnNlcnNbMF0gaXMgdW51c2VkXG5cbi8vIGh0dHBzOi8vZG9jcy5taWNyb3NvZnQuY29tL2VuLXVzL3R5cG9ncmFwaHkvb3BlbnR5cGUvc3BlYy9ncG9zI2xvb2t1cC10eXBlLTEtc2luZ2xlLWFkanVzdG1lbnQtcG9zaXRpb25pbmctc3VidGFibGVcbi8vIHRoaXMgPSBQYXJzZXIgaW5zdGFuY2VcbnN1YnRhYmxlUGFyc2VycyQxWzFdID0gZnVuY3Rpb24gcGFyc2VMb29rdXAxKCkge1xuICAgIHZhciBzdGFydCA9IHRoaXMub2Zmc2V0ICsgdGhpcy5yZWxhdGl2ZU9mZnNldDtcbiAgICB2YXIgcG9zZm9ybWF0ID0gdGhpcy5wYXJzZVVTaG9ydCgpO1xuICAgIGlmIChwb3Nmb3JtYXQgPT09IDEpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHBvc0Zvcm1hdDogMSxcbiAgICAgICAgICAgIGNvdmVyYWdlOiB0aGlzLnBhcnNlUG9pbnRlcihQYXJzZXIuY292ZXJhZ2UpLFxuICAgICAgICAgICAgdmFsdWU6IHRoaXMucGFyc2VWYWx1ZVJlY29yZCgpXG4gICAgICAgIH07XG4gICAgfSBlbHNlIGlmIChwb3Nmb3JtYXQgPT09IDIpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHBvc0Zvcm1hdDogMixcbiAgICAgICAgICAgIGNvdmVyYWdlOiB0aGlzLnBhcnNlUG9pbnRlcihQYXJzZXIuY292ZXJhZ2UpLFxuICAgICAgICAgICAgdmFsdWVzOiB0aGlzLnBhcnNlVmFsdWVSZWNvcmRMaXN0KClcbiAgICAgICAgfTtcbiAgICB9XG4gICAgY2hlY2suYXNzZXJ0KGZhbHNlLCAnMHgnICsgc3RhcnQudG9TdHJpbmcoMTYpICsgJzogR1BPUyBsb29rdXAgdHlwZSAxIGZvcm1hdCBtdXN0IGJlIDEgb3IgMi4nKTtcbn07XG5cbi8vIGh0dHBzOi8vZG9jcy5taWNyb3NvZnQuY29tL2VuLXVzL3R5cG9ncmFwaHkvb3BlbnR5cGUvc3BlYy9ncG9zI2xvb2t1cC10eXBlLTItcGFpci1hZGp1c3RtZW50LXBvc2l0aW9uaW5nLXN1YnRhYmxlXG5zdWJ0YWJsZVBhcnNlcnMkMVsyXSA9IGZ1bmN0aW9uIHBhcnNlTG9va3VwMigpIHtcbiAgICB2YXIgc3RhcnQgPSB0aGlzLm9mZnNldCArIHRoaXMucmVsYXRpdmVPZmZzZXQ7XG4gICAgdmFyIHBvc0Zvcm1hdCA9IHRoaXMucGFyc2VVU2hvcnQoKTtcbiAgICBjaGVjay5hc3NlcnQocG9zRm9ybWF0ID09PSAxIHx8IHBvc0Zvcm1hdCA9PT0gMiwgJzB4JyArIHN0YXJ0LnRvU3RyaW5nKDE2KSArICc6IEdQT1MgbG9va3VwIHR5cGUgMiBmb3JtYXQgbXVzdCBiZSAxIG9yIDIuJyk7XG4gICAgdmFyIGNvdmVyYWdlID0gdGhpcy5wYXJzZVBvaW50ZXIoUGFyc2VyLmNvdmVyYWdlKTtcbiAgICB2YXIgdmFsdWVGb3JtYXQxID0gdGhpcy5wYXJzZVVTaG9ydCgpO1xuICAgIHZhciB2YWx1ZUZvcm1hdDIgPSB0aGlzLnBhcnNlVVNob3J0KCk7XG4gICAgaWYgKHBvc0Zvcm1hdCA9PT0gMSkge1xuICAgICAgICAvLyBBZGp1c3RtZW50cyBmb3IgR2x5cGggUGFpcnNcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHBvc0Zvcm1hdDogcG9zRm9ybWF0LFxuICAgICAgICAgICAgY292ZXJhZ2U6IGNvdmVyYWdlLFxuICAgICAgICAgICAgdmFsdWVGb3JtYXQxOiB2YWx1ZUZvcm1hdDEsXG4gICAgICAgICAgICB2YWx1ZUZvcm1hdDI6IHZhbHVlRm9ybWF0MixcbiAgICAgICAgICAgIHBhaXJTZXRzOiB0aGlzLnBhcnNlTGlzdChQYXJzZXIucG9pbnRlcihQYXJzZXIubGlzdChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4geyAgICAgICAgLy8gcGFpclZhbHVlUmVjb3JkXG4gICAgICAgICAgICAgICAgICAgIHNlY29uZEdseXBoOiB0aGlzLnBhcnNlVVNob3J0KCksXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlMTogdGhpcy5wYXJzZVZhbHVlUmVjb3JkKHZhbHVlRm9ybWF0MSksXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlMjogdGhpcy5wYXJzZVZhbHVlUmVjb3JkKHZhbHVlRm9ybWF0MilcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSkpKVxuICAgICAgICB9O1xuICAgIH0gZWxzZSBpZiAocG9zRm9ybWF0ID09PSAyKSB7XG4gICAgICAgIHZhciBjbGFzc0RlZjEgPSB0aGlzLnBhcnNlUG9pbnRlcihQYXJzZXIuY2xhc3NEZWYpO1xuICAgICAgICB2YXIgY2xhc3NEZWYyID0gdGhpcy5wYXJzZVBvaW50ZXIoUGFyc2VyLmNsYXNzRGVmKTtcbiAgICAgICAgdmFyIGNsYXNzMUNvdW50ID0gdGhpcy5wYXJzZVVTaG9ydCgpO1xuICAgICAgICB2YXIgY2xhc3MyQ291bnQgPSB0aGlzLnBhcnNlVVNob3J0KCk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAvLyBDbGFzcyBQYWlyIEFkanVzdG1lbnRcbiAgICAgICAgICAgIHBvc0Zvcm1hdDogcG9zRm9ybWF0LFxuICAgICAgICAgICAgY292ZXJhZ2U6IGNvdmVyYWdlLFxuICAgICAgICAgICAgdmFsdWVGb3JtYXQxOiB2YWx1ZUZvcm1hdDEsXG4gICAgICAgICAgICB2YWx1ZUZvcm1hdDI6IHZhbHVlRm9ybWF0MixcbiAgICAgICAgICAgIGNsYXNzRGVmMTogY2xhc3NEZWYxLFxuICAgICAgICAgICAgY2xhc3NEZWYyOiBjbGFzc0RlZjIsXG4gICAgICAgICAgICBjbGFzczFDb3VudDogY2xhc3MxQ291bnQsXG4gICAgICAgICAgICBjbGFzczJDb3VudDogY2xhc3MyQ291bnQsXG4gICAgICAgICAgICBjbGFzc1JlY29yZHM6IHRoaXMucGFyc2VMaXN0KGNsYXNzMUNvdW50LCBQYXJzZXIubGlzdChjbGFzczJDb3VudCwgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUxOiB0aGlzLnBhcnNlVmFsdWVSZWNvcmQodmFsdWVGb3JtYXQxKSxcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUyOiB0aGlzLnBhcnNlVmFsdWVSZWNvcmQodmFsdWVGb3JtYXQyKVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9KSlcbiAgICAgICAgfTtcbiAgICB9XG59O1xuXG5zdWJ0YWJsZVBhcnNlcnMkMVszXSA9IGZ1bmN0aW9uIHBhcnNlTG9va3VwMygpIHsgcmV0dXJuIHsgZXJyb3I6ICdHUE9TIExvb2t1cCAzIG5vdCBzdXBwb3J0ZWQnIH07IH07XG5zdWJ0YWJsZVBhcnNlcnMkMVs0XSA9IGZ1bmN0aW9uIHBhcnNlTG9va3VwNCgpIHsgcmV0dXJuIHsgZXJyb3I6ICdHUE9TIExvb2t1cCA0IG5vdCBzdXBwb3J0ZWQnIH07IH07XG5zdWJ0YWJsZVBhcnNlcnMkMVs1XSA9IGZ1bmN0aW9uIHBhcnNlTG9va3VwNSgpIHsgcmV0dXJuIHsgZXJyb3I6ICdHUE9TIExvb2t1cCA1IG5vdCBzdXBwb3J0ZWQnIH07IH07XG5zdWJ0YWJsZVBhcnNlcnMkMVs2XSA9IGZ1bmN0aW9uIHBhcnNlTG9va3VwNigpIHsgcmV0dXJuIHsgZXJyb3I6ICdHUE9TIExvb2t1cCA2IG5vdCBzdXBwb3J0ZWQnIH07IH07XG5zdWJ0YWJsZVBhcnNlcnMkMVs3XSA9IGZ1bmN0aW9uIHBhcnNlTG9va3VwNygpIHsgcmV0dXJuIHsgZXJyb3I6ICdHUE9TIExvb2t1cCA3IG5vdCBzdXBwb3J0ZWQnIH07IH07XG5zdWJ0YWJsZVBhcnNlcnMkMVs4XSA9IGZ1bmN0aW9uIHBhcnNlTG9va3VwOCgpIHsgcmV0dXJuIHsgZXJyb3I6ICdHUE9TIExvb2t1cCA4IG5vdCBzdXBwb3J0ZWQnIH07IH07XG5zdWJ0YWJsZVBhcnNlcnMkMVs5XSA9IGZ1bmN0aW9uIHBhcnNlTG9va3VwOSgpIHsgcmV0dXJuIHsgZXJyb3I6ICdHUE9TIExvb2t1cCA5IG5vdCBzdXBwb3J0ZWQnIH07IH07XG5cbi8vIGh0dHBzOi8vZG9jcy5taWNyb3NvZnQuY29tL2VuLXVzL3R5cG9ncmFwaHkvb3BlbnR5cGUvc3BlYy9ncG9zXG5mdW5jdGlvbiBwYXJzZUdwb3NUYWJsZShkYXRhLCBzdGFydCkge1xuICAgIHN0YXJ0ID0gc3RhcnQgfHwgMDtcbiAgICB2YXIgcCA9IG5ldyBQYXJzZXIoZGF0YSwgc3RhcnQpO1xuICAgIHZhciB0YWJsZVZlcnNpb24gPSBwLnBhcnNlVmVyc2lvbigxKTtcbiAgICBjaGVjay5hcmd1bWVudCh0YWJsZVZlcnNpb24gPT09IDEgfHwgdGFibGVWZXJzaW9uID09PSAxLjEsICdVbnN1cHBvcnRlZCBHUE9TIHRhYmxlIHZlcnNpb24gJyArIHRhYmxlVmVyc2lvbik7XG5cbiAgICBpZiAodGFibGVWZXJzaW9uID09PSAxKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB2ZXJzaW9uOiB0YWJsZVZlcnNpb24sXG4gICAgICAgICAgICBzY3JpcHRzOiBwLnBhcnNlU2NyaXB0TGlzdCgpLFxuICAgICAgICAgICAgZmVhdHVyZXM6IHAucGFyc2VGZWF0dXJlTGlzdCgpLFxuICAgICAgICAgICAgbG9va3VwczogcC5wYXJzZUxvb2t1cExpc3Qoc3VidGFibGVQYXJzZXJzJDEpXG4gICAgICAgIH07XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHZlcnNpb246IHRhYmxlVmVyc2lvbixcbiAgICAgICAgICAgIHNjcmlwdHM6IHAucGFyc2VTY3JpcHRMaXN0KCksXG4gICAgICAgICAgICBmZWF0dXJlczogcC5wYXJzZUZlYXR1cmVMaXN0KCksXG4gICAgICAgICAgICBsb29rdXBzOiBwLnBhcnNlTG9va3VwTGlzdChzdWJ0YWJsZVBhcnNlcnMkMSksXG4gICAgICAgICAgICB2YXJpYXRpb25zOiBwLnBhcnNlRmVhdHVyZVZhcmlhdGlvbnNMaXN0KClcbiAgICAgICAgfTtcbiAgICB9XG5cbn1cblxuLy8gR1BPUyBXcml0aW5nIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIE5PVCBTVVBQT1JURURcbnZhciBzdWJ0YWJsZU1ha2VycyQxID0gbmV3IEFycmF5KDEwKTtcblxuZnVuY3Rpb24gbWFrZUdwb3NUYWJsZShncG9zKSB7XG4gICAgcmV0dXJuIG5ldyB0YWJsZS5UYWJsZSgnR1BPUycsIFtcbiAgICAgICAge25hbWU6ICd2ZXJzaW9uJywgdHlwZTogJ1VMT05HJywgdmFsdWU6IDB4MTAwMDB9LFxuICAgICAgICB7bmFtZTogJ3NjcmlwdHMnLCB0eXBlOiAnVEFCTEUnLCB2YWx1ZTogbmV3IHRhYmxlLlNjcmlwdExpc3QoZ3Bvcy5zY3JpcHRzKX0sXG4gICAgICAgIHtuYW1lOiAnZmVhdHVyZXMnLCB0eXBlOiAnVEFCTEUnLCB2YWx1ZTogbmV3IHRhYmxlLkZlYXR1cmVMaXN0KGdwb3MuZmVhdHVyZXMpfSxcbiAgICAgICAge25hbWU6ICdsb29rdXBzJywgdHlwZTogJ1RBQkxFJywgdmFsdWU6IG5ldyB0YWJsZS5Mb29rdXBMaXN0KGdwb3MubG9va3Vwcywgc3VidGFibGVNYWtlcnMkMSl9XG4gICAgXSk7XG59XG5cbnZhciBncG9zID0geyBwYXJzZTogcGFyc2VHcG9zVGFibGUsIG1ha2U6IG1ha2VHcG9zVGFibGUgfTtcblxuLy8gVGhlIGBrZXJuYCB0YWJsZSBjb250YWlucyBrZXJuaW5nIHBhaXJzLlxuXG5mdW5jdGlvbiBwYXJzZVdpbmRvd3NLZXJuVGFibGUocCkge1xuICAgIHZhciBwYWlycyA9IHt9O1xuICAgIC8vIFNraXAgblRhYmxlcy5cbiAgICBwLnNraXAoJ3VTaG9ydCcpO1xuICAgIHZhciBzdWJ0YWJsZVZlcnNpb24gPSBwLnBhcnNlVVNob3J0KCk7XG4gICAgY2hlY2suYXJndW1lbnQoc3VidGFibGVWZXJzaW9uID09PSAwLCAnVW5zdXBwb3J0ZWQga2VybiBzdWItdGFibGUgdmVyc2lvbi4nKTtcbiAgICAvLyBTa2lwIHN1YnRhYmxlTGVuZ3RoLCBzdWJ0YWJsZUNvdmVyYWdlXG4gICAgcC5za2lwKCd1U2hvcnQnLCAyKTtcbiAgICB2YXIgblBhaXJzID0gcC5wYXJzZVVTaG9ydCgpO1xuICAgIC8vIFNraXAgc2VhcmNoUmFuZ2UsIGVudHJ5U2VsZWN0b3IsIHJhbmdlU2hpZnQuXG4gICAgcC5za2lwKCd1U2hvcnQnLCAzKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5QYWlyczsgaSArPSAxKSB7XG4gICAgICAgIHZhciBsZWZ0SW5kZXggPSBwLnBhcnNlVVNob3J0KCk7XG4gICAgICAgIHZhciByaWdodEluZGV4ID0gcC5wYXJzZVVTaG9ydCgpO1xuICAgICAgICB2YXIgdmFsdWUgPSBwLnBhcnNlU2hvcnQoKTtcbiAgICAgICAgcGFpcnNbbGVmdEluZGV4ICsgJywnICsgcmlnaHRJbmRleF0gPSB2YWx1ZTtcbiAgICB9XG4gICAgcmV0dXJuIHBhaXJzO1xufVxuXG5mdW5jdGlvbiBwYXJzZU1hY0tlcm5UYWJsZShwKSB7XG4gICAgdmFyIHBhaXJzID0ge307XG4gICAgLy8gVGhlIE1hYyBrZXJuIHRhYmxlIHN0b3JlcyB0aGUgdmVyc2lvbiBhcyBhIGZpeGVkICgzMiBiaXRzKSBidXQgd2Ugb25seSBsb2FkZWQgdGhlIGZpcnN0IDE2IGJpdHMuXG4gICAgLy8gU2tpcCB0aGUgcmVzdC5cbiAgICBwLnNraXAoJ3VTaG9ydCcpO1xuICAgIHZhciBuVGFibGVzID0gcC5wYXJzZVVMb25nKCk7XG4gICAgLy9jaGVjay5hcmd1bWVudChuVGFibGVzID09PSAxLCAnT25seSAxIHN1YnRhYmxlIGlzIHN1cHBvcnRlZCAoZ290ICcgKyBuVGFibGVzICsgJykuJyk7XG4gICAgaWYgKG5UYWJsZXMgPiAxKSB7XG4gICAgICAgIGNvbnNvbGUud2FybignT25seSB0aGUgZmlyc3Qga2VybiBzdWJ0YWJsZSBpcyBzdXBwb3J0ZWQuJyk7XG4gICAgfVxuICAgIHAuc2tpcCgndUxvbmcnKTtcbiAgICB2YXIgY292ZXJhZ2UgPSBwLnBhcnNlVVNob3J0KCk7XG4gICAgdmFyIHN1YnRhYmxlVmVyc2lvbiA9IGNvdmVyYWdlICYgMHhGRjtcbiAgICBwLnNraXAoJ3VTaG9ydCcpO1xuICAgIGlmIChzdWJ0YWJsZVZlcnNpb24gPT09IDApIHtcbiAgICAgICAgdmFyIG5QYWlycyA9IHAucGFyc2VVU2hvcnQoKTtcbiAgICAgICAgLy8gU2tpcCBzZWFyY2hSYW5nZSwgZW50cnlTZWxlY3RvciwgcmFuZ2VTaGlmdC5cbiAgICAgICAgcC5za2lwKCd1U2hvcnQnLCAzKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBuUGFpcnM7IGkgKz0gMSkge1xuICAgICAgICAgICAgdmFyIGxlZnRJbmRleCA9IHAucGFyc2VVU2hvcnQoKTtcbiAgICAgICAgICAgIHZhciByaWdodEluZGV4ID0gcC5wYXJzZVVTaG9ydCgpO1xuICAgICAgICAgICAgdmFyIHZhbHVlID0gcC5wYXJzZVNob3J0KCk7XG4gICAgICAgICAgICBwYWlyc1tsZWZ0SW5kZXggKyAnLCcgKyByaWdodEluZGV4XSA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBwYWlycztcbn1cblxuLy8gUGFyc2UgdGhlIGBrZXJuYCB0YWJsZSB3aGljaCBjb250YWlucyBrZXJuaW5nIHBhaXJzLlxuZnVuY3Rpb24gcGFyc2VLZXJuVGFibGUoZGF0YSwgc3RhcnQpIHtcbiAgICB2YXIgcCA9IG5ldyBwYXJzZS5QYXJzZXIoZGF0YSwgc3RhcnQpO1xuICAgIHZhciB0YWJsZVZlcnNpb24gPSBwLnBhcnNlVVNob3J0KCk7XG4gICAgaWYgKHRhYmxlVmVyc2lvbiA9PT0gMCkge1xuICAgICAgICByZXR1cm4gcGFyc2VXaW5kb3dzS2VyblRhYmxlKHApO1xuICAgIH0gZWxzZSBpZiAodGFibGVWZXJzaW9uID09PSAxKSB7XG4gICAgICAgIHJldHVybiBwYXJzZU1hY0tlcm5UYWJsZShwKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vuc3VwcG9ydGVkIGtlcm4gdGFibGUgdmVyc2lvbiAoJyArIHRhYmxlVmVyc2lvbiArICcpLicpO1xuICAgIH1cbn1cblxudmFyIGtlcm4gPSB7IHBhcnNlOiBwYXJzZUtlcm5UYWJsZSB9O1xuXG4vLyBUaGUgYGxvY2FgIHRhYmxlIHN0b3JlcyB0aGUgb2Zmc2V0cyB0byB0aGUgbG9jYXRpb25zIG9mIHRoZSBnbHlwaHMgaW4gdGhlIGZvbnQuXG5cbi8vIFBhcnNlIHRoZSBgbG9jYWAgdGFibGUuIFRoaXMgdGFibGUgc3RvcmVzIHRoZSBvZmZzZXRzIHRvIHRoZSBsb2NhdGlvbnMgb2YgdGhlIGdseXBocyBpbiB0aGUgZm9udCxcbi8vIHJlbGF0aXZlIHRvIHRoZSBiZWdpbm5pbmcgb2YgdGhlIGdseXBoRGF0YSB0YWJsZS5cbi8vIFRoZSBudW1iZXIgb2YgZ2x5cGhzIHN0b3JlZCBpbiB0aGUgYGxvY2FgIHRhYmxlIGlzIHNwZWNpZmllZCBpbiB0aGUgYG1heHBgIHRhYmxlICh1bmRlciBudW1HbHlwaHMpXG4vLyBUaGUgbG9jYSB0YWJsZSBoYXMgdHdvIHZlcnNpb25zOiBhIHNob3J0IHZlcnNpb24gd2hlcmUgb2Zmc2V0cyBhcmUgc3RvcmVkIGFzIHVTaG9ydHMsIGFuZCBhIGxvbmdcbi8vIHZlcnNpb24gd2hlcmUgb2Zmc2V0cyBhcmUgc3RvcmVkIGFzIHVMb25ncy4gVGhlIGBoZWFkYCB0YWJsZSBzcGVjaWZpZXMgd2hpY2ggdmVyc2lvbiB0byB1c2Vcbi8vICh1bmRlciBpbmRleFRvTG9jRm9ybWF0KS5cbmZ1bmN0aW9uIHBhcnNlTG9jYVRhYmxlKGRhdGEsIHN0YXJ0LCBudW1HbHlwaHMsIHNob3J0VmVyc2lvbikge1xuICAgIHZhciBwID0gbmV3IHBhcnNlLlBhcnNlcihkYXRhLCBzdGFydCk7XG4gICAgdmFyIHBhcnNlRm4gPSBzaG9ydFZlcnNpb24gPyBwLnBhcnNlVVNob3J0IDogcC5wYXJzZVVMb25nO1xuICAgIC8vIFRoZXJlIGlzIGFuIGV4dHJhIGVudHJ5IGFmdGVyIHRoZSBsYXN0IGluZGV4IGVsZW1lbnQgdG8gY29tcHV0ZSB0aGUgbGVuZ3RoIG9mIHRoZSBsYXN0IGdseXBoLlxuICAgIC8vIFRoYXQncyB3aHkgd2UgdXNlIG51bUdseXBocyArIDEuXG4gICAgdmFyIGdseXBoT2Zmc2V0cyA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbnVtR2x5cGhzICsgMTsgaSArPSAxKSB7XG4gICAgICAgIHZhciBnbHlwaE9mZnNldCA9IHBhcnNlRm4uY2FsbChwKTtcbiAgICAgICAgaWYgKHNob3J0VmVyc2lvbikge1xuICAgICAgICAgICAgLy8gVGhlIHNob3J0IHRhYmxlIHZlcnNpb24gc3RvcmVzIHRoZSBhY3R1YWwgb2Zmc2V0IGRpdmlkZWQgYnkgMi5cbiAgICAgICAgICAgIGdseXBoT2Zmc2V0ICo9IDI7XG4gICAgICAgIH1cblxuICAgICAgICBnbHlwaE9mZnNldHMucHVzaChnbHlwaE9mZnNldCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGdseXBoT2Zmc2V0cztcbn1cblxudmFyIGxvY2EgPSB7IHBhcnNlOiBwYXJzZUxvY2FUYWJsZSB9O1xuXG4vLyBvcGVudHlwZS5qc1xuXG4vKipcbiAqIFRoZSBvcGVudHlwZSBsaWJyYXJ5LlxuICogQG5hbWVzcGFjZSBvcGVudHlwZVxuICovXG5cbi8vIEZpbGUgbG9hZGVycyAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbi8qKlxuICogTG9hZHMgYSBmb250IGZyb20gYSBmaWxlLiBUaGUgY2FsbGJhY2sgdGhyb3dzIGFuIGVycm9yIG1lc3NhZ2UgYXMgdGhlIGZpcnN0IHBhcmFtZXRlciBpZiBpdCBmYWlsc1xuICogYW5kIHRoZSBmb250IGFzIGFuIEFycmF5QnVmZmVyIGluIHRoZSBzZWNvbmQgcGFyYW1ldGVyIGlmIGl0IHN1Y2NlZWRzLlxuICogQHBhcmFtICB7c3RyaW5nfSBwYXRoIC0gVGhlIHBhdGggb2YgdGhlIGZpbGVcbiAqIEBwYXJhbSAge0Z1bmN0aW9ufSBjYWxsYmFjayAtIFRoZSBmdW5jdGlvbiB0byBjYWxsIHdoZW4gdGhlIGZvbnQgbG9hZCBjb21wbGV0ZXNcbiAqL1xuZnVuY3Rpb24gbG9hZEZyb21GaWxlKHBhdGgsIGNhbGxiYWNrKSB7XG4gICAgdmFyIGZzID0gcmVxdWlyZSgnZnMnKTtcbiAgICBmcy5yZWFkRmlsZShwYXRoLCBmdW5jdGlvbihlcnIsIGJ1ZmZlcikge1xuICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICByZXR1cm4gY2FsbGJhY2soZXJyLm1lc3NhZ2UpO1xuICAgICAgICB9XG5cbiAgICAgICAgY2FsbGJhY2sobnVsbCwgbm9kZUJ1ZmZlclRvQXJyYXlCdWZmZXIoYnVmZmVyKSk7XG4gICAgfSk7XG59XG4vKipcbiAqIExvYWRzIGEgZm9udCBmcm9tIGEgVVJMLiBUaGUgY2FsbGJhY2sgdGhyb3dzIGFuIGVycm9yIG1lc3NhZ2UgYXMgdGhlIGZpcnN0IHBhcmFtZXRlciBpZiBpdCBmYWlsc1xuICogYW5kIHRoZSBmb250IGFzIGFuIEFycmF5QnVmZmVyIGluIHRoZSBzZWNvbmQgcGFyYW1ldGVyIGlmIGl0IHN1Y2NlZWRzLlxuICogQHBhcmFtICB7c3RyaW5nfSB1cmwgLSBUaGUgVVJMIG9mIHRoZSBmb250IGZpbGUuXG4gKiBAcGFyYW0gIHtGdW5jdGlvbn0gY2FsbGJhY2sgLSBUaGUgZnVuY3Rpb24gdG8gY2FsbCB3aGVuIHRoZSBmb250IGxvYWQgY29tcGxldGVzXG4gKi9cbmZ1bmN0aW9uIGxvYWRGcm9tVXJsKHVybCwgY2FsbGJhY2spIHtcbiAgICB2YXIgcmVxdWVzdCA9IG5ldyBYTUxIdHRwUmVxdWVzdCgpO1xuICAgIHJlcXVlc3Qub3BlbignZ2V0JywgdXJsLCB0cnVlKTtcbiAgICByZXF1ZXN0LnJlc3BvbnNlVHlwZSA9ICdhcnJheWJ1ZmZlcic7XG4gICAgcmVxdWVzdC5vbmxvYWQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKHJlcXVlc3QucmVzcG9uc2UpIHtcbiAgICAgICAgICAgIHJldHVybiBjYWxsYmFjayhudWxsLCByZXF1ZXN0LnJlc3BvbnNlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBjYWxsYmFjaygnRm9udCBjb3VsZCBub3QgYmUgbG9hZGVkOiAnICsgcmVxdWVzdC5zdGF0dXNUZXh0KTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICByZXF1ZXN0Lm9uZXJyb3IgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGNhbGxiYWNrKCdGb250IGNvdWxkIG5vdCBiZSBsb2FkZWQnKTtcbiAgICB9O1xuXG4gICAgcmVxdWVzdC5zZW5kKCk7XG59XG5cbi8vIFRhYmxlIERpcmVjdG9yeSBFbnRyaWVzIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbi8qKlxuICogUGFyc2VzIE9wZW5UeXBlIHRhYmxlIGVudHJpZXMuXG4gKiBAcGFyYW0gIHtEYXRhVmlld31cbiAqIEBwYXJhbSAge051bWJlcn1cbiAqIEByZXR1cm4ge09iamVjdFtdfVxuICovXG5mdW5jdGlvbiBwYXJzZU9wZW5UeXBlVGFibGVFbnRyaWVzKGRhdGEsIG51bVRhYmxlcykge1xuICAgIHZhciB0YWJsZUVudHJpZXMgPSBbXTtcbiAgICB2YXIgcCA9IDEyO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbnVtVGFibGVzOyBpICs9IDEpIHtcbiAgICAgICAgdmFyIHRhZyA9IHBhcnNlLmdldFRhZyhkYXRhLCBwKTtcbiAgICAgICAgdmFyIGNoZWNrc3VtID0gcGFyc2UuZ2V0VUxvbmcoZGF0YSwgcCArIDQpO1xuICAgICAgICB2YXIgb2Zmc2V0ID0gcGFyc2UuZ2V0VUxvbmcoZGF0YSwgcCArIDgpO1xuICAgICAgICB2YXIgbGVuZ3RoID0gcGFyc2UuZ2V0VUxvbmcoZGF0YSwgcCArIDEyKTtcbiAgICAgICAgdGFibGVFbnRyaWVzLnB1c2goe3RhZzogdGFnLCBjaGVja3N1bTogY2hlY2tzdW0sIG9mZnNldDogb2Zmc2V0LCBsZW5ndGg6IGxlbmd0aCwgY29tcHJlc3Npb246IGZhbHNlfSk7XG4gICAgICAgIHAgKz0gMTY7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRhYmxlRW50cmllcztcbn1cblxuLyoqXG4gKiBQYXJzZXMgV09GRiB0YWJsZSBlbnRyaWVzLlxuICogQHBhcmFtICB7RGF0YVZpZXd9XG4gKiBAcGFyYW0gIHtOdW1iZXJ9XG4gKiBAcmV0dXJuIHtPYmplY3RbXX1cbiAqL1xuZnVuY3Rpb24gcGFyc2VXT0ZGVGFibGVFbnRyaWVzKGRhdGEsIG51bVRhYmxlcykge1xuICAgIHZhciB0YWJsZUVudHJpZXMgPSBbXTtcbiAgICB2YXIgcCA9IDQ0OyAvLyBvZmZzZXQgdG8gdGhlIGZpcnN0IHRhYmxlIGRpcmVjdG9yeSBlbnRyeS5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG51bVRhYmxlczsgaSArPSAxKSB7XG4gICAgICAgIHZhciB0YWcgPSBwYXJzZS5nZXRUYWcoZGF0YSwgcCk7XG4gICAgICAgIHZhciBvZmZzZXQgPSBwYXJzZS5nZXRVTG9uZyhkYXRhLCBwICsgNCk7XG4gICAgICAgIHZhciBjb21wTGVuZ3RoID0gcGFyc2UuZ2V0VUxvbmcoZGF0YSwgcCArIDgpO1xuICAgICAgICB2YXIgb3JpZ0xlbmd0aCA9IHBhcnNlLmdldFVMb25nKGRhdGEsIHAgKyAxMik7XG4gICAgICAgIHZhciBjb21wcmVzc2lvbiA9ICh2b2lkIDApO1xuICAgICAgICBpZiAoY29tcExlbmd0aCA8IG9yaWdMZW5ndGgpIHtcbiAgICAgICAgICAgIGNvbXByZXNzaW9uID0gJ1dPRkYnO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29tcHJlc3Npb24gPSBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRhYmxlRW50cmllcy5wdXNoKHt0YWc6IHRhZywgb2Zmc2V0OiBvZmZzZXQsIGNvbXByZXNzaW9uOiBjb21wcmVzc2lvbixcbiAgICAgICAgICAgIGNvbXByZXNzZWRMZW5ndGg6IGNvbXBMZW5ndGgsIGxlbmd0aDogb3JpZ0xlbmd0aH0pO1xuICAgICAgICBwICs9IDIwO1xuICAgIH1cblxuICAgIHJldHVybiB0YWJsZUVudHJpZXM7XG59XG5cbi8qKlxuICogQHR5cGVkZWYgVGFibGVEYXRhXG4gKiBAdHlwZSBPYmplY3RcbiAqIEBwcm9wZXJ0eSB7RGF0YVZpZXd9IGRhdGEgLSBUaGUgRGF0YVZpZXdcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBvZmZzZXQgLSBUaGUgZGF0YSBvZmZzZXQuXG4gKi9cblxuLyoqXG4gKiBAcGFyYW0gIHtEYXRhVmlld31cbiAqIEBwYXJhbSAge09iamVjdH1cbiAqIEByZXR1cm4ge1RhYmxlRGF0YX1cbiAqL1xuZnVuY3Rpb24gdW5jb21wcmVzc1RhYmxlKGRhdGEsIHRhYmxlRW50cnkpIHtcbiAgICBpZiAodGFibGVFbnRyeS5jb21wcmVzc2lvbiA9PT0gJ1dPRkYnKSB7XG4gICAgICAgIHZhciBpbkJ1ZmZlciA9IG5ldyBVaW50OEFycmF5KGRhdGEuYnVmZmVyLCB0YWJsZUVudHJ5Lm9mZnNldCArIDIsIHRhYmxlRW50cnkuY29tcHJlc3NlZExlbmd0aCAtIDIpO1xuICAgICAgICB2YXIgb3V0QnVmZmVyID0gbmV3IFVpbnQ4QXJyYXkodGFibGVFbnRyeS5sZW5ndGgpO1xuICAgICAgICB0aW55SW5mbGF0ZShpbkJ1ZmZlciwgb3V0QnVmZmVyKTtcbiAgICAgICAgaWYgKG91dEJ1ZmZlci5ieXRlTGVuZ3RoICE9PSB0YWJsZUVudHJ5Lmxlbmd0aCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdEZWNvbXByZXNzaW9uIGVycm9yOiAnICsgdGFibGVFbnRyeS50YWcgKyAnIGRlY29tcHJlc3NlZCBsZW5ndGggZG9lc25cXCd0IG1hdGNoIHJlY29yZGVkIGxlbmd0aCcpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHZpZXcgPSBuZXcgRGF0YVZpZXcob3V0QnVmZmVyLmJ1ZmZlciwgMCk7XG4gICAgICAgIHJldHVybiB7ZGF0YTogdmlldywgb2Zmc2V0OiAwfTtcbiAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4ge2RhdGE6IGRhdGEsIG9mZnNldDogdGFibGVFbnRyeS5vZmZzZXR9O1xuICAgIH1cbn1cblxuLy8gUHVibGljIEFQSSAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXG4vKipcbiAqIFBhcnNlIHRoZSBPcGVuVHlwZSBmaWxlIGRhdGEgKGFzIGFuIEFycmF5QnVmZmVyKSBhbmQgcmV0dXJuIGEgRm9udCBvYmplY3QuXG4gKiBUaHJvd3MgYW4gZXJyb3IgaWYgdGhlIGZvbnQgY291bGQgbm90IGJlIHBhcnNlZC5cbiAqIEBwYXJhbSAge0FycmF5QnVmZmVyfVxuICogQHBhcmFtICB7T2JqZWN0fSBvcHQgLSBvcHRpb25zIGZvciBwYXJzaW5nXG4gKiBAcmV0dXJuIHtvcGVudHlwZS5Gb250fVxuICovXG5mdW5jdGlvbiBwYXJzZUJ1ZmZlcihidWZmZXIsIG9wdCkge1xuICAgIG9wdCA9IChvcHQgPT09IHVuZGVmaW5lZCB8fCBvcHQgPT09IG51bGwpID8gIHt9IDogb3B0O1xuXG4gICAgdmFyIGluZGV4VG9Mb2NGb3JtYXQ7XG4gICAgdmFyIGx0YWdUYWJsZTtcblxuICAgIC8vIFNpbmNlIHRoZSBjb25zdHJ1Y3RvciBjYW4gYWxzbyBiZSBjYWxsZWQgdG8gY3JlYXRlIG5ldyBmb250cyBmcm9tIHNjcmF0Y2gsIHdlIGluZGljYXRlIHRoaXNcbiAgICAvLyBzaG91bGQgYmUgYW4gZW1wdHkgZm9udCB0aGF0IHdlJ2xsIGZpbGwgd2l0aCBvdXIgb3duIGRhdGEuXG4gICAgdmFyIGZvbnQgPSBuZXcgRm9udCh7ZW1wdHk6IHRydWV9KTtcblxuICAgIC8vIE9wZW5UeXBlIGZvbnRzIHVzZSBiaWcgZW5kaWFuIGJ5dGUgb3JkZXJpbmcuXG4gICAgLy8gV2UgY2FuJ3QgcmVseSBvbiB0eXBlZCBhcnJheSB2aWV3IHR5cGVzLCBiZWNhdXNlIHRoZXkgb3BlcmF0ZSB3aXRoIHRoZSBlbmRpYW5uZXNzIG9mIHRoZSBob3N0IGNvbXB1dGVyLlxuICAgIC8vIEluc3RlYWQgd2UgdXNlIERhdGFWaWV3cyB3aGVyZSB3ZSBjYW4gc3BlY2lmeSBlbmRpYW5uZXNzLlxuICAgIHZhciBkYXRhID0gbmV3IERhdGFWaWV3KGJ1ZmZlciwgMCk7XG4gICAgdmFyIG51bVRhYmxlcztcbiAgICB2YXIgdGFibGVFbnRyaWVzID0gW107XG4gICAgdmFyIHNpZ25hdHVyZSA9IHBhcnNlLmdldFRhZyhkYXRhLCAwKTtcbiAgICBpZiAoc2lnbmF0dXJlID09PSBTdHJpbmcuZnJvbUNoYXJDb2RlKDAsIDEsIDAsIDApIHx8IHNpZ25hdHVyZSA9PT0gJ3RydWUnIHx8IHNpZ25hdHVyZSA9PT0gJ3R5cDEnKSB7XG4gICAgICAgIGZvbnQub3V0bGluZXNGb3JtYXQgPSAndHJ1ZXR5cGUnO1xuICAgICAgICBudW1UYWJsZXMgPSBwYXJzZS5nZXRVU2hvcnQoZGF0YSwgNCk7XG4gICAgICAgIHRhYmxlRW50cmllcyA9IHBhcnNlT3BlblR5cGVUYWJsZUVudHJpZXMoZGF0YSwgbnVtVGFibGVzKTtcbiAgICB9IGVsc2UgaWYgKHNpZ25hdHVyZSA9PT0gJ09UVE8nKSB7XG4gICAgICAgIGZvbnQub3V0bGluZXNGb3JtYXQgPSAnY2ZmJztcbiAgICAgICAgbnVtVGFibGVzID0gcGFyc2UuZ2V0VVNob3J0KGRhdGEsIDQpO1xuICAgICAgICB0YWJsZUVudHJpZXMgPSBwYXJzZU9wZW5UeXBlVGFibGVFbnRyaWVzKGRhdGEsIG51bVRhYmxlcyk7XG4gICAgfSBlbHNlIGlmIChzaWduYXR1cmUgPT09ICd3T0ZGJykge1xuICAgICAgICB2YXIgZmxhdm9yID0gcGFyc2UuZ2V0VGFnKGRhdGEsIDQpO1xuICAgICAgICBpZiAoZmxhdm9yID09PSBTdHJpbmcuZnJvbUNoYXJDb2RlKDAsIDEsIDAsIDApKSB7XG4gICAgICAgICAgICBmb250Lm91dGxpbmVzRm9ybWF0ID0gJ3RydWV0eXBlJztcbiAgICAgICAgfSBlbHNlIGlmIChmbGF2b3IgPT09ICdPVFRPJykge1xuICAgICAgICAgICAgZm9udC5vdXRsaW5lc0Zvcm1hdCA9ICdjZmYnO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbnN1cHBvcnRlZCBPcGVuVHlwZSBmbGF2b3IgJyArIHNpZ25hdHVyZSk7XG4gICAgICAgIH1cblxuICAgICAgICBudW1UYWJsZXMgPSBwYXJzZS5nZXRVU2hvcnQoZGF0YSwgMTIpO1xuICAgICAgICB0YWJsZUVudHJpZXMgPSBwYXJzZVdPRkZUYWJsZUVudHJpZXMoZGF0YSwgbnVtVGFibGVzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vuc3VwcG9ydGVkIE9wZW5UeXBlIHNpZ25hdHVyZSAnICsgc2lnbmF0dXJlKTtcbiAgICB9XG5cbiAgICB2YXIgY2ZmVGFibGVFbnRyeTtcbiAgICB2YXIgZnZhclRhYmxlRW50cnk7XG4gICAgdmFyIGdseWZUYWJsZUVudHJ5O1xuICAgIHZhciBnZGVmVGFibGVFbnRyeTtcbiAgICB2YXIgZ3Bvc1RhYmxlRW50cnk7XG4gICAgdmFyIGdzdWJUYWJsZUVudHJ5O1xuICAgIHZhciBobXR4VGFibGVFbnRyeTtcbiAgICB2YXIga2VyblRhYmxlRW50cnk7XG4gICAgdmFyIGxvY2FUYWJsZUVudHJ5O1xuICAgIHZhciBuYW1lVGFibGVFbnRyeTtcbiAgICB2YXIgbWV0YVRhYmxlRW50cnk7XG4gICAgdmFyIHA7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG51bVRhYmxlczsgaSArPSAxKSB7XG4gICAgICAgIHZhciB0YWJsZUVudHJ5ID0gdGFibGVFbnRyaWVzW2ldO1xuICAgICAgICB2YXIgdGFibGUgPSAodm9pZCAwKTtcbiAgICAgICAgc3dpdGNoICh0YWJsZUVudHJ5LnRhZykge1xuICAgICAgICAgICAgY2FzZSAnY21hcCc6XG4gICAgICAgICAgICAgICAgdGFibGUgPSB1bmNvbXByZXNzVGFibGUoZGF0YSwgdGFibGVFbnRyeSk7XG4gICAgICAgICAgICAgICAgZm9udC50YWJsZXMuY21hcCA9IGNtYXAucGFyc2UodGFibGUuZGF0YSwgdGFibGUub2Zmc2V0KTtcbiAgICAgICAgICAgICAgICBmb250LmVuY29kaW5nID0gbmV3IENtYXBFbmNvZGluZyhmb250LnRhYmxlcy5jbWFwKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ2N2dCAnIDpcbiAgICAgICAgICAgICAgICB0YWJsZSA9IHVuY29tcHJlc3NUYWJsZShkYXRhLCB0YWJsZUVudHJ5KTtcbiAgICAgICAgICAgICAgICBwID0gbmV3IHBhcnNlLlBhcnNlcih0YWJsZS5kYXRhLCB0YWJsZS5vZmZzZXQpO1xuICAgICAgICAgICAgICAgIGZvbnQudGFibGVzLmN2dCA9IHAucGFyc2VTaG9ydExpc3QodGFibGVFbnRyeS5sZW5ndGggLyAyKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ2Z2YXInOlxuICAgICAgICAgICAgICAgIGZ2YXJUYWJsZUVudHJ5ID0gdGFibGVFbnRyeTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ2ZwZ20nIDpcbiAgICAgICAgICAgICAgICB0YWJsZSA9IHVuY29tcHJlc3NUYWJsZShkYXRhLCB0YWJsZUVudHJ5KTtcbiAgICAgICAgICAgICAgICBwID0gbmV3IHBhcnNlLlBhcnNlcih0YWJsZS5kYXRhLCB0YWJsZS5vZmZzZXQpO1xuICAgICAgICAgICAgICAgIGZvbnQudGFibGVzLmZwZ20gPSBwLnBhcnNlQnl0ZUxpc3QodGFibGVFbnRyeS5sZW5ndGgpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnaGVhZCc6XG4gICAgICAgICAgICAgICAgdGFibGUgPSB1bmNvbXByZXNzVGFibGUoZGF0YSwgdGFibGVFbnRyeSk7XG4gICAgICAgICAgICAgICAgZm9udC50YWJsZXMuaGVhZCA9IGhlYWQucGFyc2UodGFibGUuZGF0YSwgdGFibGUub2Zmc2V0KTtcbiAgICAgICAgICAgICAgICBmb250LnVuaXRzUGVyRW0gPSBmb250LnRhYmxlcy5oZWFkLnVuaXRzUGVyRW07XG4gICAgICAgICAgICAgICAgaW5kZXhUb0xvY0Zvcm1hdCA9IGZvbnQudGFibGVzLmhlYWQuaW5kZXhUb0xvY0Zvcm1hdDtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ2hoZWEnOlxuICAgICAgICAgICAgICAgIHRhYmxlID0gdW5jb21wcmVzc1RhYmxlKGRhdGEsIHRhYmxlRW50cnkpO1xuICAgICAgICAgICAgICAgIGZvbnQudGFibGVzLmhoZWEgPSBoaGVhLnBhcnNlKHRhYmxlLmRhdGEsIHRhYmxlLm9mZnNldCk7XG4gICAgICAgICAgICAgICAgZm9udC5hc2NlbmRlciA9IGZvbnQudGFibGVzLmhoZWEuYXNjZW5kZXI7XG4gICAgICAgICAgICAgICAgZm9udC5kZXNjZW5kZXIgPSBmb250LnRhYmxlcy5oaGVhLmRlc2NlbmRlcjtcbiAgICAgICAgICAgICAgICBmb250Lm51bWJlck9mSE1ldHJpY3MgPSBmb250LnRhYmxlcy5oaGVhLm51bWJlck9mSE1ldHJpY3M7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdobXR4JzpcbiAgICAgICAgICAgICAgICBobXR4VGFibGVFbnRyeSA9IHRhYmxlRW50cnk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdsdGFnJzpcbiAgICAgICAgICAgICAgICB0YWJsZSA9IHVuY29tcHJlc3NUYWJsZShkYXRhLCB0YWJsZUVudHJ5KTtcbiAgICAgICAgICAgICAgICBsdGFnVGFibGUgPSBsdGFnLnBhcnNlKHRhYmxlLmRhdGEsIHRhYmxlLm9mZnNldCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdtYXhwJzpcbiAgICAgICAgICAgICAgICB0YWJsZSA9IHVuY29tcHJlc3NUYWJsZShkYXRhLCB0YWJsZUVudHJ5KTtcbiAgICAgICAgICAgICAgICBmb250LnRhYmxlcy5tYXhwID0gbWF4cC5wYXJzZSh0YWJsZS5kYXRhLCB0YWJsZS5vZmZzZXQpO1xuICAgICAgICAgICAgICAgIGZvbnQubnVtR2x5cGhzID0gZm9udC50YWJsZXMubWF4cC5udW1HbHlwaHM7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICduYW1lJzpcbiAgICAgICAgICAgICAgICBuYW1lVGFibGVFbnRyeSA9IHRhYmxlRW50cnk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdPUy8yJzpcbiAgICAgICAgICAgICAgICB0YWJsZSA9IHVuY29tcHJlc3NUYWJsZShkYXRhLCB0YWJsZUVudHJ5KTtcbiAgICAgICAgICAgICAgICBmb250LnRhYmxlcy5vczIgPSBvczIucGFyc2UodGFibGUuZGF0YSwgdGFibGUub2Zmc2V0KTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ3Bvc3QnOlxuICAgICAgICAgICAgICAgIHRhYmxlID0gdW5jb21wcmVzc1RhYmxlKGRhdGEsIHRhYmxlRW50cnkpO1xuICAgICAgICAgICAgICAgIGZvbnQudGFibGVzLnBvc3QgPSBwb3N0LnBhcnNlKHRhYmxlLmRhdGEsIHRhYmxlLm9mZnNldCk7XG4gICAgICAgICAgICAgICAgZm9udC5nbHlwaE5hbWVzID0gbmV3IEdseXBoTmFtZXMoZm9udC50YWJsZXMucG9zdCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdwcmVwJyA6XG4gICAgICAgICAgICAgICAgdGFibGUgPSB1bmNvbXByZXNzVGFibGUoZGF0YSwgdGFibGVFbnRyeSk7XG4gICAgICAgICAgICAgICAgcCA9IG5ldyBwYXJzZS5QYXJzZXIodGFibGUuZGF0YSwgdGFibGUub2Zmc2V0KTtcbiAgICAgICAgICAgICAgICBmb250LnRhYmxlcy5wcmVwID0gcC5wYXJzZUJ5dGVMaXN0KHRhYmxlRW50cnkubGVuZ3RoKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ2dseWYnOlxuICAgICAgICAgICAgICAgIGdseWZUYWJsZUVudHJ5ID0gdGFibGVFbnRyeTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ2xvY2EnOlxuICAgICAgICAgICAgICAgIGxvY2FUYWJsZUVudHJ5ID0gdGFibGVFbnRyeTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ0NGRiAnOlxuICAgICAgICAgICAgICAgIGNmZlRhYmxlRW50cnkgPSB0YWJsZUVudHJ5O1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAna2Vybic6XG4gICAgICAgICAgICAgICAga2VyblRhYmxlRW50cnkgPSB0YWJsZUVudHJ5O1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnR0RFRic6XG4gICAgICAgICAgICAgICAgZ2RlZlRhYmxlRW50cnkgPSB0YWJsZUVudHJ5O1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnR1BPUyc6XG4gICAgICAgICAgICAgICAgZ3Bvc1RhYmxlRW50cnkgPSB0YWJsZUVudHJ5O1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnR1NVQic6XG4gICAgICAgICAgICAgICAgZ3N1YlRhYmxlRW50cnkgPSB0YWJsZUVudHJ5O1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnbWV0YSc6XG4gICAgICAgICAgICAgICAgbWV0YVRhYmxlRW50cnkgPSB0YWJsZUVudHJ5O1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgdmFyIG5hbWVUYWJsZSA9IHVuY29tcHJlc3NUYWJsZShkYXRhLCBuYW1lVGFibGVFbnRyeSk7XG4gICAgZm9udC50YWJsZXMubmFtZSA9IF9uYW1lLnBhcnNlKG5hbWVUYWJsZS5kYXRhLCBuYW1lVGFibGUub2Zmc2V0LCBsdGFnVGFibGUpO1xuICAgIGZvbnQubmFtZXMgPSBmb250LnRhYmxlcy5uYW1lO1xuXG4gICAgaWYgKGdseWZUYWJsZUVudHJ5ICYmIGxvY2FUYWJsZUVudHJ5KSB7XG4gICAgICAgIHZhciBzaG9ydFZlcnNpb24gPSBpbmRleFRvTG9jRm9ybWF0ID09PSAwO1xuICAgICAgICB2YXIgbG9jYVRhYmxlID0gdW5jb21wcmVzc1RhYmxlKGRhdGEsIGxvY2FUYWJsZUVudHJ5KTtcbiAgICAgICAgdmFyIGxvY2FPZmZzZXRzID0gbG9jYS5wYXJzZShsb2NhVGFibGUuZGF0YSwgbG9jYVRhYmxlLm9mZnNldCwgZm9udC5udW1HbHlwaHMsIHNob3J0VmVyc2lvbik7XG4gICAgICAgIHZhciBnbHlmVGFibGUgPSB1bmNvbXByZXNzVGFibGUoZGF0YSwgZ2x5ZlRhYmxlRW50cnkpO1xuICAgICAgICBmb250LmdseXBocyA9IGdseWYucGFyc2UoZ2x5ZlRhYmxlLmRhdGEsIGdseWZUYWJsZS5vZmZzZXQsIGxvY2FPZmZzZXRzLCBmb250LCBvcHQpO1xuICAgIH0gZWxzZSBpZiAoY2ZmVGFibGVFbnRyeSkge1xuICAgICAgICB2YXIgY2ZmVGFibGUgPSB1bmNvbXByZXNzVGFibGUoZGF0YSwgY2ZmVGFibGVFbnRyeSk7XG4gICAgICAgIGNmZi5wYXJzZShjZmZUYWJsZS5kYXRhLCBjZmZUYWJsZS5vZmZzZXQsIGZvbnQsIG9wdCk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdGb250IGRvZXNuXFwndCBjb250YWluIFRydWVUeXBlIG9yIENGRiBvdXRsaW5lcy4nKTtcbiAgICB9XG5cbiAgICB2YXIgaG10eFRhYmxlID0gdW5jb21wcmVzc1RhYmxlKGRhdGEsIGhtdHhUYWJsZUVudHJ5KTtcbiAgICBobXR4LnBhcnNlKGZvbnQsIGhtdHhUYWJsZS5kYXRhLCBobXR4VGFibGUub2Zmc2V0LCBmb250Lm51bWJlck9mSE1ldHJpY3MsIGZvbnQubnVtR2x5cGhzLCBmb250LmdseXBocywgb3B0KTtcbiAgICBhZGRHbHlwaE5hbWVzKGZvbnQsIG9wdCk7XG5cbiAgICBpZiAoa2VyblRhYmxlRW50cnkpIHtcbiAgICAgICAgdmFyIGtlcm5UYWJsZSA9IHVuY29tcHJlc3NUYWJsZShkYXRhLCBrZXJuVGFibGVFbnRyeSk7XG4gICAgICAgIGZvbnQua2VybmluZ1BhaXJzID0ga2Vybi5wYXJzZShrZXJuVGFibGUuZGF0YSwga2VyblRhYmxlLm9mZnNldCk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgZm9udC5rZXJuaW5nUGFpcnMgPSB7fTtcbiAgICB9XG5cbiAgICBpZiAoZ2RlZlRhYmxlRW50cnkpIHtcbiAgICAgICAgdmFyIGdkZWZUYWJsZSA9IHVuY29tcHJlc3NUYWJsZShkYXRhLCBnZGVmVGFibGVFbnRyeSk7XG4gICAgICAgIGZvbnQudGFibGVzLmdkZWYgPSBnZGVmLnBhcnNlKGdkZWZUYWJsZS5kYXRhLCBnZGVmVGFibGUub2Zmc2V0KTtcbiAgICB9XG5cbiAgICBpZiAoZ3Bvc1RhYmxlRW50cnkpIHtcbiAgICAgICAgdmFyIGdwb3NUYWJsZSA9IHVuY29tcHJlc3NUYWJsZShkYXRhLCBncG9zVGFibGVFbnRyeSk7XG4gICAgICAgIGZvbnQudGFibGVzLmdwb3MgPSBncG9zLnBhcnNlKGdwb3NUYWJsZS5kYXRhLCBncG9zVGFibGUub2Zmc2V0KTtcbiAgICAgICAgZm9udC5wb3NpdGlvbi5pbml0KCk7XG4gICAgfVxuXG4gICAgaWYgKGdzdWJUYWJsZUVudHJ5KSB7XG4gICAgICAgIHZhciBnc3ViVGFibGUgPSB1bmNvbXByZXNzVGFibGUoZGF0YSwgZ3N1YlRhYmxlRW50cnkpO1xuICAgICAgICBmb250LnRhYmxlcy5nc3ViID0gZ3N1Yi5wYXJzZShnc3ViVGFibGUuZGF0YSwgZ3N1YlRhYmxlLm9mZnNldCk7XG4gICAgfVxuXG4gICAgaWYgKGZ2YXJUYWJsZUVudHJ5KSB7XG4gICAgICAgIHZhciBmdmFyVGFibGUgPSB1bmNvbXByZXNzVGFibGUoZGF0YSwgZnZhclRhYmxlRW50cnkpO1xuICAgICAgICBmb250LnRhYmxlcy5mdmFyID0gZnZhci5wYXJzZShmdmFyVGFibGUuZGF0YSwgZnZhclRhYmxlLm9mZnNldCwgZm9udC5uYW1lcyk7XG4gICAgfVxuXG4gICAgaWYgKG1ldGFUYWJsZUVudHJ5KSB7XG4gICAgICAgIHZhciBtZXRhVGFibGUgPSB1bmNvbXByZXNzVGFibGUoZGF0YSwgbWV0YVRhYmxlRW50cnkpO1xuICAgICAgICBmb250LnRhYmxlcy5tZXRhID0gbWV0YS5wYXJzZShtZXRhVGFibGUuZGF0YSwgbWV0YVRhYmxlLm9mZnNldCk7XG4gICAgICAgIGZvbnQubWV0YXMgPSBmb250LnRhYmxlcy5tZXRhO1xuICAgIH1cblxuICAgIHJldHVybiBmb250O1xufVxuXG4vKipcbiAqIEFzeW5jaHJvbm91c2x5IGxvYWQgdGhlIGZvbnQgZnJvbSBhIFVSTCBvciBhIGZpbGVzeXN0ZW0uIFdoZW4gZG9uZSwgY2FsbCB0aGUgY2FsbGJhY2tcbiAqIHdpdGggdHdvIGFyZ3VtZW50cyBgKGVyciwgZm9udClgLiBUaGUgYGVycmAgd2lsbCBiZSBudWxsIG9uIHN1Y2Nlc3MsXG4gKiB0aGUgYGZvbnRgIGlzIGEgRm9udCBvYmplY3QuXG4gKiBXZSB1c2UgdGhlIG5vZGUuanMgY2FsbGJhY2sgY29udmVudGlvbiBzbyB0aGF0XG4gKiBvcGVudHlwZS5qcyBjYW4gaW50ZWdyYXRlIHdpdGggZnJhbWV3b3JrcyBsaWtlIGFzeW5jLmpzLlxuICogQGFsaWFzIG9wZW50eXBlLmxvYWRcbiAqIEBwYXJhbSAge3N0cmluZ30gdXJsIC0gVGhlIFVSTCBvZiB0aGUgZm9udCB0byBsb2FkLlxuICogQHBhcmFtICB7RnVuY3Rpb259IGNhbGxiYWNrIC0gVGhlIGNhbGxiYWNrLlxuICovXG5mdW5jdGlvbiBsb2FkKHVybCwgY2FsbGJhY2ssIG9wdCkge1xuICAgIG9wdCA9IChvcHQgPT09IHVuZGVmaW5lZCB8fCBvcHQgPT09IG51bGwpID8gIHt9IDogb3B0O1xuICAgIHZhciBpc05vZGUgPSB0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJztcbiAgICB2YXIgbG9hZEZuID0gaXNOb2RlICYmICFvcHQuaXNVcmwgPyBsb2FkRnJvbUZpbGUgOiBsb2FkRnJvbVVybDtcblxuICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIGxvYWRGbih1cmwsIGZ1bmN0aW9uKGVyciwgYXJyYXlCdWZmZXIpIHtcbiAgICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgICAgICBpZiAoY2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGVycik7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmVqZWN0KGVycik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGZvbnQ7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGZvbnQgPSBwYXJzZUJ1ZmZlcihhcnJheUJ1ZmZlciwgb3B0KTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICBpZiAoY2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGUsIG51bGwpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJlamVjdChlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoY2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY2FsbGJhY2sobnVsbCwgZm9udCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJlc29sdmUoZm9udCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH0pO1xufVxuXG4vKipcbiAqIFN5bmNocm9ub3VzbHkgbG9hZCB0aGUgZm9udCBmcm9tIGEgVVJMIG9yIGZpbGUuXG4gKiBXaGVuIGRvbmUsIHJldHVybnMgdGhlIGZvbnQgb2JqZWN0IG9yIHRocm93cyBhbiBlcnJvci5cbiAqIEBhbGlhcyBvcGVudHlwZS5sb2FkU3luY1xuICogQHBhcmFtICB7c3RyaW5nfSB1cmwgLSBUaGUgVVJMIG9mIHRoZSBmb250IHRvIGxvYWQuXG4gKiBAcGFyYW0gIHtPYmplY3R9IG9wdCAtIG9wdC5sb3dNZW1vcnlcbiAqIEByZXR1cm4ge29wZW50eXBlLkZvbnR9XG4gKi9cbmZ1bmN0aW9uIGxvYWRTeW5jKHVybCwgb3B0KSB7XG4gICAgdmFyIGZzID0gcmVxdWlyZSgnZnMnKTtcbiAgICB2YXIgYnVmZmVyID0gZnMucmVhZEZpbGVTeW5jKHVybCk7XG4gICAgcmV0dXJuIHBhcnNlQnVmZmVyKG5vZGVCdWZmZXJUb0FycmF5QnVmZmVyKGJ1ZmZlciksIG9wdCk7XG59XG5cbnZhciBvcGVudHlwZSA9IC8qI19fUFVSRV9fKi9PYmplY3QuZnJlZXplKHtcblx0X19wcm90b19fOiBudWxsLFxuXHRGb250OiBGb250LFxuXHRHbHlwaDogR2x5cGgsXG5cdFBhdGg6IFBhdGgsXG5cdEJvdW5kaW5nQm94OiBCb3VuZGluZ0JveCxcblx0X3BhcnNlOiBwYXJzZSxcblx0cGFyc2U6IHBhcnNlQnVmZmVyLFxuXHRsb2FkOiBsb2FkLFxuXHRsb2FkU3luYzogbG9hZFN5bmNcbn0pO1xuXG5leHBvcnQgZGVmYXVsdCBvcGVudHlwZTtcbmV4cG9ydCB7IEJvdW5kaW5nQm94LCBGb250LCBHbHlwaCwgUGF0aCwgcGFyc2UgYXMgX3BhcnNlLCBsb2FkLCBsb2FkU3luYywgcGFyc2VCdWZmZXIgYXMgcGFyc2UgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW9wZW50eXBlLm1vZHVsZS5qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/opentype.js/dist/opentype.module.js\n"));

/***/ }),

/***/ "./node_modules/react/cjs/react-jsx-dev-runtime.development.js":
/*!*********************************************************************!*\
  !*** ./node_modules/react/cjs/react-jsx-dev-runtime.development.js ***!
  \*********************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("/**\n * @license React\n * react-jsx-dev-runtime.development.js\n *\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\n\nif (true) {\n  (function() {\n'use strict';\n\nvar React = __webpack_require__(/*! react */ \"./node_modules/react/index.js\");\n\n// ATTENTION\n// When adding new symbols to this file,\n// Please consider also adding to 'react-devtools-shared/src/backend/ReactSymbols'\n// The Symbol used to tag the ReactElement-like types.\nvar REACT_ELEMENT_TYPE = Symbol.for('react.element');\nvar REACT_PORTAL_TYPE = Symbol.for('react.portal');\nvar REACT_FRAGMENT_TYPE = Symbol.for('react.fragment');\nvar REACT_STRICT_MODE_TYPE = Symbol.for('react.strict_mode');\nvar REACT_PROFILER_TYPE = Symbol.for('react.profiler');\nvar REACT_PROVIDER_TYPE = Symbol.for('react.provider');\nvar REACT_CONTEXT_TYPE = Symbol.for('react.context');\nvar REACT_FORWARD_REF_TYPE = Symbol.for('react.forward_ref');\nvar REACT_SUSPENSE_TYPE = Symbol.for('react.suspense');\nvar REACT_SUSPENSE_LIST_TYPE = Symbol.for('react.suspense_list');\nvar REACT_MEMO_TYPE = Symbol.for('react.memo');\nvar REACT_LAZY_TYPE = Symbol.for('react.lazy');\nvar REACT_OFFSCREEN_TYPE = Symbol.for('react.offscreen');\nvar MAYBE_ITERATOR_SYMBOL = Symbol.iterator;\nvar FAUX_ITERATOR_SYMBOL = '@@iterator';\nfunction getIteratorFn(maybeIterable) {\n  if (maybeIterable === null || typeof maybeIterable !== 'object') {\n    return null;\n  }\n\n  var maybeIterator = MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL];\n\n  if (typeof maybeIterator === 'function') {\n    return maybeIterator;\n  }\n\n  return null;\n}\n\nvar ReactSharedInternals = React.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;\n\nfunction error(format) {\n  {\n    {\n      for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n        args[_key2 - 1] = arguments[_key2];\n      }\n\n      printWarning('error', format, args);\n    }\n  }\n}\n\nfunction printWarning(level, format, args) {\n  // When changing this logic, you might want to also\n  // update consoleWithStackDev.www.js as well.\n  {\n    var ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;\n    var stack = ReactDebugCurrentFrame.getStackAddendum();\n\n    if (stack !== '') {\n      format += '%s';\n      args = args.concat([stack]);\n    } // eslint-disable-next-line react-internal/safe-string-coercion\n\n\n    var argsWithFormat = args.map(function (item) {\n      return String(item);\n    }); // Careful: RN currently depends on this prefix\n\n    argsWithFormat.unshift('Warning: ' + format); // We intentionally don't use spread (or .apply) directly because it\n    // breaks IE9: https://github.com/facebook/react/issues/13610\n    // eslint-disable-next-line react-internal/no-production-logging\n\n    Function.prototype.apply.call(console[level], console, argsWithFormat);\n  }\n}\n\n// -----------------------------------------------------------------------------\n\nvar enableScopeAPI = false; // Experimental Create Event Handle API.\nvar enableCacheElement = false;\nvar enableTransitionTracing = false; // No known bugs, but needs performance testing\n\nvar enableLegacyHidden = false; // Enables unstable_avoidThisFallback feature in Fiber\n// stuff. Intended to enable React core members to more easily debug scheduling\n// issues in DEV builds.\n\nvar enableDebugTracing = false; // Track which Fiber(s) schedule render work.\n\nvar REACT_MODULE_REFERENCE;\n\n{\n  REACT_MODULE_REFERENCE = Symbol.for('react.module.reference');\n}\n\nfunction isValidElementType(type) {\n  if (typeof type === 'string' || typeof type === 'function') {\n    return true;\n  } // Note: typeof might be other than 'symbol' or 'number' (e.g. if it's a polyfill).\n\n\n  if (type === REACT_FRAGMENT_TYPE || type === REACT_PROFILER_TYPE || enableDebugTracing  || type === REACT_STRICT_MODE_TYPE || type === REACT_SUSPENSE_TYPE || type === REACT_SUSPENSE_LIST_TYPE || enableLegacyHidden  || type === REACT_OFFSCREEN_TYPE || enableScopeAPI  || enableCacheElement  || enableTransitionTracing ) {\n    return true;\n  }\n\n  if (typeof type === 'object' && type !== null) {\n    if (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_PROVIDER_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE || // This needs to include all possible module reference object\n    // types supported by any Flight configuration anywhere since\n    // we don't know which Flight build this will end up being used\n    // with.\n    type.$$typeof === REACT_MODULE_REFERENCE || type.getModuleId !== undefined) {\n      return true;\n    }\n  }\n\n  return false;\n}\n\nfunction getWrappedName(outerType, innerType, wrapperName) {\n  var displayName = outerType.displayName;\n\n  if (displayName) {\n    return displayName;\n  }\n\n  var functionName = innerType.displayName || innerType.name || '';\n  return functionName !== '' ? wrapperName + \"(\" + functionName + \")\" : wrapperName;\n} // Keep in sync with react-reconciler/getComponentNameFromFiber\n\n\nfunction getContextName(type) {\n  return type.displayName || 'Context';\n} // Note that the reconciler package should generally prefer to use getComponentNameFromFiber() instead.\n\n\nfunction getComponentNameFromType(type) {\n  if (type == null) {\n    // Host root, text node or just invalid type.\n    return null;\n  }\n\n  {\n    if (typeof type.tag === 'number') {\n      error('Received an unexpected object in getComponentNameFromType(). ' + 'This is likely a bug in React. Please file an issue.');\n    }\n  }\n\n  if (typeof type === 'function') {\n    return type.displayName || type.name || null;\n  }\n\n  if (typeof type === 'string') {\n    return type;\n  }\n\n  switch (type) {\n    case REACT_FRAGMENT_TYPE:\n      return 'Fragment';\n\n    case REACT_PORTAL_TYPE:\n      return 'Portal';\n\n    case REACT_PROFILER_TYPE:\n      return 'Profiler';\n\n    case REACT_STRICT_MODE_TYPE:\n      return 'StrictMode';\n\n    case REACT_SUSPENSE_TYPE:\n      return 'Suspense';\n\n    case REACT_SUSPENSE_LIST_TYPE:\n      return 'SuspenseList';\n\n  }\n\n  if (typeof type === 'object') {\n    switch (type.$$typeof) {\n      case REACT_CONTEXT_TYPE:\n        var context = type;\n        return getContextName(context) + '.Consumer';\n\n      case REACT_PROVIDER_TYPE:\n        var provider = type;\n        return getContextName(provider._context) + '.Provider';\n\n      case REACT_FORWARD_REF_TYPE:\n        return getWrappedName(type, type.render, 'ForwardRef');\n\n      case REACT_MEMO_TYPE:\n        var outerName = type.displayName || null;\n\n        if (outerName !== null) {\n          return outerName;\n        }\n\n        return getComponentNameFromType(type.type) || 'Memo';\n\n      case REACT_LAZY_TYPE:\n        {\n          var lazyComponent = type;\n          var payload = lazyComponent._payload;\n          var init = lazyComponent._init;\n\n          try {\n            return getComponentNameFromType(init(payload));\n          } catch (x) {\n            return null;\n          }\n        }\n\n      // eslint-disable-next-line no-fallthrough\n    }\n  }\n\n  return null;\n}\n\nvar assign = Object.assign;\n\n// Helpers to patch console.logs to avoid logging during side-effect free\n// replaying on render function. This currently only patches the object\n// lazily which won't cover if the log function was extracted eagerly.\n// We could also eagerly patch the method.\nvar disabledDepth = 0;\nvar prevLog;\nvar prevInfo;\nvar prevWarn;\nvar prevError;\nvar prevGroup;\nvar prevGroupCollapsed;\nvar prevGroupEnd;\n\nfunction disabledLog() {}\n\ndisabledLog.__reactDisabledLog = true;\nfunction disableLogs() {\n  {\n    if (disabledDepth === 0) {\n      /* eslint-disable react-internal/no-production-logging */\n      prevLog = console.log;\n      prevInfo = console.info;\n      prevWarn = console.warn;\n      prevError = console.error;\n      prevGroup = console.group;\n      prevGroupCollapsed = console.groupCollapsed;\n      prevGroupEnd = console.groupEnd; // https://github.com/facebook/react/issues/19099\n\n      var props = {\n        configurable: true,\n        enumerable: true,\n        value: disabledLog,\n        writable: true\n      }; // $FlowFixMe Flow thinks console is immutable.\n\n      Object.defineProperties(console, {\n        info: props,\n        log: props,\n        warn: props,\n        error: props,\n        group: props,\n        groupCollapsed: props,\n        groupEnd: props\n      });\n      /* eslint-enable react-internal/no-production-logging */\n    }\n\n    disabledDepth++;\n  }\n}\nfunction reenableLogs() {\n  {\n    disabledDepth--;\n\n    if (disabledDepth === 0) {\n      /* eslint-disable react-internal/no-production-logging */\n      var props = {\n        configurable: true,\n        enumerable: true,\n        writable: true\n      }; // $FlowFixMe Flow thinks console is immutable.\n\n      Object.defineProperties(console, {\n        log: assign({}, props, {\n          value: prevLog\n        }),\n        info: assign({}, props, {\n          value: prevInfo\n        }),\n        warn: assign({}, props, {\n          value: prevWarn\n        }),\n        error: assign({}, props, {\n          value: prevError\n        }),\n        group: assign({}, props, {\n          value: prevGroup\n        }),\n        groupCollapsed: assign({}, props, {\n          value: prevGroupCollapsed\n        }),\n        groupEnd: assign({}, props, {\n          value: prevGroupEnd\n        })\n      });\n      /* eslint-enable react-internal/no-production-logging */\n    }\n\n    if (disabledDepth < 0) {\n      error('disabledDepth fell below zero. ' + 'This is a bug in React. Please file an issue.');\n    }\n  }\n}\n\nvar ReactCurrentDispatcher = ReactSharedInternals.ReactCurrentDispatcher;\nvar prefix;\nfunction describeBuiltInComponentFrame(name, source, ownerFn) {\n  {\n    if (prefix === undefined) {\n      // Extract the VM specific prefix used by each line.\n      try {\n        throw Error();\n      } catch (x) {\n        var match = x.stack.trim().match(/\\n( *(at )?)/);\n        prefix = match && match[1] || '';\n      }\n    } // We use the prefix to ensure our stacks line up with native stack frames.\n\n\n    return '\\n' + prefix + name;\n  }\n}\nvar reentry = false;\nvar componentFrameCache;\n\n{\n  var PossiblyWeakMap = typeof WeakMap === 'function' ? WeakMap : Map;\n  componentFrameCache = new PossiblyWeakMap();\n}\n\nfunction describeNativeComponentFrame(fn, construct) {\n  // If something asked for a stack inside a fake render, it should get ignored.\n  if ( !fn || reentry) {\n    return '';\n  }\n\n  {\n    var frame = componentFrameCache.get(fn);\n\n    if (frame !== undefined) {\n      return frame;\n    }\n  }\n\n  var control;\n  reentry = true;\n  var previousPrepareStackTrace = Error.prepareStackTrace; // $FlowFixMe It does accept undefined.\n\n  Error.prepareStackTrace = undefined;\n  var previousDispatcher;\n\n  {\n    previousDispatcher = ReactCurrentDispatcher.current; // Set the dispatcher in DEV because this might be call in the render function\n    // for warnings.\n\n    ReactCurrentDispatcher.current = null;\n    disableLogs();\n  }\n\n  try {\n    // This should throw.\n    if (construct) {\n      // Something should be setting the props in the constructor.\n      var Fake = function () {\n        throw Error();\n      }; // $FlowFixMe\n\n\n      Object.defineProperty(Fake.prototype, 'props', {\n        set: function () {\n          // We use a throwing setter instead of frozen or non-writable props\n          // because that won't throw in a non-strict mode function.\n          throw Error();\n        }\n      });\n\n      if (typeof Reflect === 'object' && Reflect.construct) {\n        // We construct a different control for this case to include any extra\n        // frames added by the construct call.\n        try {\n          Reflect.construct(Fake, []);\n        } catch (x) {\n          control = x;\n        }\n\n        Reflect.construct(fn, [], Fake);\n      } else {\n        try {\n          Fake.call();\n        } catch (x) {\n          control = x;\n        }\n\n        fn.call(Fake.prototype);\n      }\n    } else {\n      try {\n        throw Error();\n      } catch (x) {\n        control = x;\n      }\n\n      fn();\n    }\n  } catch (sample) {\n    // This is inlined manually because closure doesn't do it for us.\n    if (sample && control && typeof sample.stack === 'string') {\n      // This extracts the first frame from the sample that isn't also in the control.\n      // Skipping one frame that we assume is the frame that calls the two.\n      var sampleLines = sample.stack.split('\\n');\n      var controlLines = control.stack.split('\\n');\n      var s = sampleLines.length - 1;\n      var c = controlLines.length - 1;\n\n      while (s >= 1 && c >= 0 && sampleLines[s] !== controlLines[c]) {\n        // We expect at least one stack frame to be shared.\n        // Typically this will be the root most one. However, stack frames may be\n        // cut off due to maximum stack limits. In this case, one maybe cut off\n        // earlier than the other. We assume that the sample is longer or the same\n        // and there for cut off earlier. So we should find the root most frame in\n        // the sample somewhere in the control.\n        c--;\n      }\n\n      for (; s >= 1 && c >= 0; s--, c--) {\n        // Next we find the first one that isn't the same which should be the\n        // frame that called our sample function and the control.\n        if (sampleLines[s] !== controlLines[c]) {\n          // In V8, the first line is describing the message but other VMs don't.\n          // If we're about to return the first line, and the control is also on the same\n          // line, that's a pretty good indicator that our sample threw at same line as\n          // the control. I.e. before we entered the sample frame. So we ignore this result.\n          // This can happen if you passed a class to function component, or non-function.\n          if (s !== 1 || c !== 1) {\n            do {\n              s--;\n              c--; // We may still have similar intermediate frames from the construct call.\n              // The next one that isn't the same should be our match though.\n\n              if (c < 0 || sampleLines[s] !== controlLines[c]) {\n                // V8 adds a \"new\" prefix for native classes. Let's remove it to make it prettier.\n                var _frame = '\\n' + sampleLines[s].replace(' at new ', ' at '); // If our component frame is labeled \"<anonymous>\"\n                // but we have a user-provided \"displayName\"\n                // splice it in to make the stack more readable.\n\n\n                if (fn.displayName && _frame.includes('<anonymous>')) {\n                  _frame = _frame.replace('<anonymous>', fn.displayName);\n                }\n\n                {\n                  if (typeof fn === 'function') {\n                    componentFrameCache.set(fn, _frame);\n                  }\n                } // Return the line we found.\n\n\n                return _frame;\n              }\n            } while (s >= 1 && c >= 0);\n          }\n\n          break;\n        }\n      }\n    }\n  } finally {\n    reentry = false;\n\n    {\n      ReactCurrentDispatcher.current = previousDispatcher;\n      reenableLogs();\n    }\n\n    Error.prepareStackTrace = previousPrepareStackTrace;\n  } // Fallback to just using the name if we couldn't make it throw.\n\n\n  var name = fn ? fn.displayName || fn.name : '';\n  var syntheticFrame = name ? describeBuiltInComponentFrame(name) : '';\n\n  {\n    if (typeof fn === 'function') {\n      componentFrameCache.set(fn, syntheticFrame);\n    }\n  }\n\n  return syntheticFrame;\n}\nfunction describeFunctionComponentFrame(fn, source, ownerFn) {\n  {\n    return describeNativeComponentFrame(fn, false);\n  }\n}\n\nfunction shouldConstruct(Component) {\n  var prototype = Component.prototype;\n  return !!(prototype && prototype.isReactComponent);\n}\n\nfunction describeUnknownElementTypeFrameInDEV(type, source, ownerFn) {\n\n  if (type == null) {\n    return '';\n  }\n\n  if (typeof type === 'function') {\n    {\n      return describeNativeComponentFrame(type, shouldConstruct(type));\n    }\n  }\n\n  if (typeof type === 'string') {\n    return describeBuiltInComponentFrame(type);\n  }\n\n  switch (type) {\n    case REACT_SUSPENSE_TYPE:\n      return describeBuiltInComponentFrame('Suspense');\n\n    case REACT_SUSPENSE_LIST_TYPE:\n      return describeBuiltInComponentFrame('SuspenseList');\n  }\n\n  if (typeof type === 'object') {\n    switch (type.$$typeof) {\n      case REACT_FORWARD_REF_TYPE:\n        return describeFunctionComponentFrame(type.render);\n\n      case REACT_MEMO_TYPE:\n        // Memo may contain any component type so we recursively resolve it.\n        return describeUnknownElementTypeFrameInDEV(type.type, source, ownerFn);\n\n      case REACT_LAZY_TYPE:\n        {\n          var lazyComponent = type;\n          var payload = lazyComponent._payload;\n          var init = lazyComponent._init;\n\n          try {\n            // Lazy may contain any component type so we recursively resolve it.\n            return describeUnknownElementTypeFrameInDEV(init(payload), source, ownerFn);\n          } catch (x) {}\n        }\n    }\n  }\n\n  return '';\n}\n\nvar hasOwnProperty = Object.prototype.hasOwnProperty;\n\nvar loggedTypeFailures = {};\nvar ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;\n\nfunction setCurrentlyValidatingElement(element) {\n  {\n    if (element) {\n      var owner = element._owner;\n      var stack = describeUnknownElementTypeFrameInDEV(element.type, element._source, owner ? owner.type : null);\n      ReactDebugCurrentFrame.setExtraStackFrame(stack);\n    } else {\n      ReactDebugCurrentFrame.setExtraStackFrame(null);\n    }\n  }\n}\n\nfunction checkPropTypes(typeSpecs, values, location, componentName, element) {\n  {\n    // $FlowFixMe This is okay but Flow doesn't know it.\n    var has = Function.call.bind(hasOwnProperty);\n\n    for (var typeSpecName in typeSpecs) {\n      if (has(typeSpecs, typeSpecName)) {\n        var error$1 = void 0; // Prop type validation may throw. In case they do, we don't want to\n        // fail the render phase where it didn't fail before. So we log it.\n        // After these have been cleaned up, we'll let them throw.\n\n        try {\n          // This is intentionally an invariant that gets caught. It's the same\n          // behavior as without this statement except with a better message.\n          if (typeof typeSpecs[typeSpecName] !== 'function') {\n            // eslint-disable-next-line react-internal/prod-error-codes\n            var err = Error((componentName || 'React class') + ': ' + location + ' type `' + typeSpecName + '` is invalid; ' + 'it must be a function, usually from the `prop-types` package, but received `' + typeof typeSpecs[typeSpecName] + '`.' + 'This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.');\n            err.name = 'Invariant Violation';\n            throw err;\n          }\n\n          error$1 = typeSpecs[typeSpecName](values, typeSpecName, componentName, location, null, 'SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED');\n        } catch (ex) {\n          error$1 = ex;\n        }\n\n        if (error$1 && !(error$1 instanceof Error)) {\n          setCurrentlyValidatingElement(element);\n\n          error('%s: type specification of %s' + ' `%s` is invalid; the type checker ' + 'function must return `null` or an `Error` but returned a %s. ' + 'You may have forgotten to pass an argument to the type checker ' + 'creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and ' + 'shape all require an argument).', componentName || 'React class', location, typeSpecName, typeof error$1);\n\n          setCurrentlyValidatingElement(null);\n        }\n\n        if (error$1 instanceof Error && !(error$1.message in loggedTypeFailures)) {\n          // Only monitor this failure once because there tends to be a lot of the\n          // same error.\n          loggedTypeFailures[error$1.message] = true;\n          setCurrentlyValidatingElement(element);\n\n          error('Failed %s type: %s', location, error$1.message);\n\n          setCurrentlyValidatingElement(null);\n        }\n      }\n    }\n  }\n}\n\nvar isArrayImpl = Array.isArray; // eslint-disable-next-line no-redeclare\n\nfunction isArray(a) {\n  return isArrayImpl(a);\n}\n\n/*\n * The `'' + value` pattern (used in in perf-sensitive code) throws for Symbol\n * and Temporal.* types. See https://github.com/facebook/react/pull/22064.\n *\n * The functions in this module will throw an easier-to-understand,\n * easier-to-debug exception with a clear errors message message explaining the\n * problem. (Instead of a confusing exception thrown inside the implementation\n * of the `value` object).\n */\n// $FlowFixMe only called in DEV, so void return is not possible.\nfunction typeName(value) {\n  {\n    // toStringTag is needed for namespaced types like Temporal.Instant\n    var hasToStringTag = typeof Symbol === 'function' && Symbol.toStringTag;\n    var type = hasToStringTag && value[Symbol.toStringTag] || value.constructor.name || 'Object';\n    return type;\n  }\n} // $FlowFixMe only called in DEV, so void return is not possible.\n\n\nfunction willCoercionThrow(value) {\n  {\n    try {\n      testStringCoercion(value);\n      return false;\n    } catch (e) {\n      return true;\n    }\n  }\n}\n\nfunction testStringCoercion(value) {\n  // If you ended up here by following an exception call stack, here's what's\n  // happened: you supplied an object or symbol value to React (as a prop, key,\n  // DOM attribute, CSS property, string ref, etc.) and when React tried to\n  // coerce it to a string using `'' + value`, an exception was thrown.\n  //\n  // The most common types that will cause this exception are `Symbol` instances\n  // and Temporal objects like `Temporal.Instant`. But any object that has a\n  // `valueOf` or `[Symbol.toPrimitive]` method that throws will also cause this\n  // exception. (Library authors do this to prevent users from using built-in\n  // numeric operators like `+` or comparison operators like `>=` because custom\n  // methods are needed to perform accurate arithmetic or comparison.)\n  //\n  // To fix the problem, coerce this object or symbol value to a string before\n  // passing it to React. The most reliable way is usually `String(value)`.\n  //\n  // To find which value is throwing, check the browser or debugger console.\n  // Before this exception was thrown, there should be `console.error` output\n  // that shows the type (Symbol, Temporal.PlainDate, etc.) that caused the\n  // problem and how that type was used: key, atrribute, input value prop, etc.\n  // In most cases, this console output also shows the component and its\n  // ancestor components where the exception happened.\n  //\n  // eslint-disable-next-line react-internal/safe-string-coercion\n  return '' + value;\n}\nfunction checkKeyStringCoercion(value) {\n  {\n    if (willCoercionThrow(value)) {\n      error('The provided key is an unsupported type %s.' + ' This value must be coerced to a string before before using it here.', typeName(value));\n\n      return testStringCoercion(value); // throw (to help callers find troubleshooting comments)\n    }\n  }\n}\n\nvar ReactCurrentOwner = ReactSharedInternals.ReactCurrentOwner;\nvar RESERVED_PROPS = {\n  key: true,\n  ref: true,\n  __self: true,\n  __source: true\n};\nvar specialPropKeyWarningShown;\nvar specialPropRefWarningShown;\nvar didWarnAboutStringRefs;\n\n{\n  didWarnAboutStringRefs = {};\n}\n\nfunction hasValidRef(config) {\n  {\n    if (hasOwnProperty.call(config, 'ref')) {\n      var getter = Object.getOwnPropertyDescriptor(config, 'ref').get;\n\n      if (getter && getter.isReactWarning) {\n        return false;\n      }\n    }\n  }\n\n  return config.ref !== undefined;\n}\n\nfunction hasValidKey(config) {\n  {\n    if (hasOwnProperty.call(config, 'key')) {\n      var getter = Object.getOwnPropertyDescriptor(config, 'key').get;\n\n      if (getter && getter.isReactWarning) {\n        return false;\n      }\n    }\n  }\n\n  return config.key !== undefined;\n}\n\nfunction warnIfStringRefCannotBeAutoConverted(config, self) {\n  {\n    if (typeof config.ref === 'string' && ReactCurrentOwner.current && self && ReactCurrentOwner.current.stateNode !== self) {\n      var componentName = getComponentNameFromType(ReactCurrentOwner.current.type);\n\n      if (!didWarnAboutStringRefs[componentName]) {\n        error('Component \"%s\" contains the string ref \"%s\". ' + 'Support for string refs will be removed in a future major release. ' + 'This case cannot be automatically converted to an arrow function. ' + 'We ask you to manually fix this case by using useRef() or createRef() instead. ' + 'Learn more about using refs safely here: ' + 'https://reactjs.org/link/strict-mode-string-ref', getComponentNameFromType(ReactCurrentOwner.current.type), config.ref);\n\n        didWarnAboutStringRefs[componentName] = true;\n      }\n    }\n  }\n}\n\nfunction defineKeyPropWarningGetter(props, displayName) {\n  {\n    var warnAboutAccessingKey = function () {\n      if (!specialPropKeyWarningShown) {\n        specialPropKeyWarningShown = true;\n\n        error('%s: `key` is not a prop. Trying to access it will result ' + 'in `undefined` being returned. If you need to access the same ' + 'value within the child component, you should pass it as a different ' + 'prop. (https://reactjs.org/link/special-props)', displayName);\n      }\n    };\n\n    warnAboutAccessingKey.isReactWarning = true;\n    Object.defineProperty(props, 'key', {\n      get: warnAboutAccessingKey,\n      configurable: true\n    });\n  }\n}\n\nfunction defineRefPropWarningGetter(props, displayName) {\n  {\n    var warnAboutAccessingRef = function () {\n      if (!specialPropRefWarningShown) {\n        specialPropRefWarningShown = true;\n\n        error('%s: `ref` is not a prop. Trying to access it will result ' + 'in `undefined` being returned. If you need to access the same ' + 'value within the child component, you should pass it as a different ' + 'prop. (https://reactjs.org/link/special-props)', displayName);\n      }\n    };\n\n    warnAboutAccessingRef.isReactWarning = true;\n    Object.defineProperty(props, 'ref', {\n      get: warnAboutAccessingRef,\n      configurable: true\n    });\n  }\n}\n/**\n * Factory method to create a new React element. This no longer adheres to\n * the class pattern, so do not use new to call it. Also, instanceof check\n * will not work. Instead test $$typeof field against Symbol.for('react.element') to check\n * if something is a React Element.\n *\n * @param {*} type\n * @param {*} props\n * @param {*} key\n * @param {string|object} ref\n * @param {*} owner\n * @param {*} self A *temporary* helper to detect places where `this` is\n * different from the `owner` when React.createElement is called, so that we\n * can warn. We want to get rid of owner and replace string `ref`s with arrow\n * functions, and as long as `this` and owner are the same, there will be no\n * change in behavior.\n * @param {*} source An annotation object (added by a transpiler or otherwise)\n * indicating filename, line number, and/or other information.\n * @internal\n */\n\n\nvar ReactElement = function (type, key, ref, self, source, owner, props) {\n  var element = {\n    // This tag allows us to uniquely identify this as a React Element\n    $$typeof: REACT_ELEMENT_TYPE,\n    // Built-in properties that belong on the element\n    type: type,\n    key: key,\n    ref: ref,\n    props: props,\n    // Record the component responsible for creating this element.\n    _owner: owner\n  };\n\n  {\n    // The validation flag is currently mutative. We put it on\n    // an external backing store so that we can freeze the whole object.\n    // This can be replaced with a WeakMap once they are implemented in\n    // commonly used development environments.\n    element._store = {}; // To make comparing ReactElements easier for testing purposes, we make\n    // the validation flag non-enumerable (where possible, which should\n    // include every environment we run tests in), so the test framework\n    // ignores it.\n\n    Object.defineProperty(element._store, 'validated', {\n      configurable: false,\n      enumerable: false,\n      writable: true,\n      value: false\n    }); // self and source are DEV only properties.\n\n    Object.defineProperty(element, '_self', {\n      configurable: false,\n      enumerable: false,\n      writable: false,\n      value: self\n    }); // Two elements created in two different places should be considered\n    // equal for testing purposes and therefore we hide it from enumeration.\n\n    Object.defineProperty(element, '_source', {\n      configurable: false,\n      enumerable: false,\n      writable: false,\n      value: source\n    });\n\n    if (Object.freeze) {\n      Object.freeze(element.props);\n      Object.freeze(element);\n    }\n  }\n\n  return element;\n};\n/**\n * https://github.com/reactjs/rfcs/pull/107\n * @param {*} type\n * @param {object} props\n * @param {string} key\n */\n\nfunction jsxDEV(type, config, maybeKey, source, self) {\n  {\n    var propName; // Reserved names are extracted\n\n    var props = {};\n    var key = null;\n    var ref = null; // Currently, key can be spread in as a prop. This causes a potential\n    // issue if key is also explicitly declared (ie. <div {...props} key=\"Hi\" />\n    // or <div key=\"Hi\" {...props} /> ). We want to deprecate key spread,\n    // but as an intermediary step, we will use jsxDEV for everything except\n    // <div {...props} key=\"Hi\" />, because we aren't currently able to tell if\n    // key is explicitly declared to be undefined or not.\n\n    if (maybeKey !== undefined) {\n      {\n        checkKeyStringCoercion(maybeKey);\n      }\n\n      key = '' + maybeKey;\n    }\n\n    if (hasValidKey(config)) {\n      {\n        checkKeyStringCoercion(config.key);\n      }\n\n      key = '' + config.key;\n    }\n\n    if (hasValidRef(config)) {\n      ref = config.ref;\n      warnIfStringRefCannotBeAutoConverted(config, self);\n    } // Remaining properties are added to a new props object\n\n\n    for (propName in config) {\n      if (hasOwnProperty.call(config, propName) && !RESERVED_PROPS.hasOwnProperty(propName)) {\n        props[propName] = config[propName];\n      }\n    } // Resolve default props\n\n\n    if (type && type.defaultProps) {\n      var defaultProps = type.defaultProps;\n\n      for (propName in defaultProps) {\n        if (props[propName] === undefined) {\n          props[propName] = defaultProps[propName];\n        }\n      }\n    }\n\n    if (key || ref) {\n      var displayName = typeof type === 'function' ? type.displayName || type.name || 'Unknown' : type;\n\n      if (key) {\n        defineKeyPropWarningGetter(props, displayName);\n      }\n\n      if (ref) {\n        defineRefPropWarningGetter(props, displayName);\n      }\n    }\n\n    return ReactElement(type, key, ref, self, source, ReactCurrentOwner.current, props);\n  }\n}\n\nvar ReactCurrentOwner$1 = ReactSharedInternals.ReactCurrentOwner;\nvar ReactDebugCurrentFrame$1 = ReactSharedInternals.ReactDebugCurrentFrame;\n\nfunction setCurrentlyValidatingElement$1(element) {\n  {\n    if (element) {\n      var owner = element._owner;\n      var stack = describeUnknownElementTypeFrameInDEV(element.type, element._source, owner ? owner.type : null);\n      ReactDebugCurrentFrame$1.setExtraStackFrame(stack);\n    } else {\n      ReactDebugCurrentFrame$1.setExtraStackFrame(null);\n    }\n  }\n}\n\nvar propTypesMisspellWarningShown;\n\n{\n  propTypesMisspellWarningShown = false;\n}\n/**\n * Verifies the object is a ReactElement.\n * See https://reactjs.org/docs/react-api.html#isvalidelement\n * @param {?object} object\n * @return {boolean} True if `object` is a ReactElement.\n * @final\n */\n\n\nfunction isValidElement(object) {\n  {\n    return typeof object === 'object' && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;\n  }\n}\n\nfunction getDeclarationErrorAddendum() {\n  {\n    if (ReactCurrentOwner$1.current) {\n      var name = getComponentNameFromType(ReactCurrentOwner$1.current.type);\n\n      if (name) {\n        return '\\n\\nCheck the render method of `' + name + '`.';\n      }\n    }\n\n    return '';\n  }\n}\n\nfunction getSourceInfoErrorAddendum(source) {\n  {\n    if (source !== undefined) {\n      var fileName = source.fileName.replace(/^.*[\\\\\\/]/, '');\n      var lineNumber = source.lineNumber;\n      return '\\n\\nCheck your code at ' + fileName + ':' + lineNumber + '.';\n    }\n\n    return '';\n  }\n}\n/**\n * Warn if there's no key explicitly set on dynamic arrays of children or\n * object keys are not valid. This allows us to keep track of children between\n * updates.\n */\n\n\nvar ownerHasKeyUseWarning = {};\n\nfunction getCurrentComponentErrorInfo(parentType) {\n  {\n    var info = getDeclarationErrorAddendum();\n\n    if (!info) {\n      var parentName = typeof parentType === 'string' ? parentType : parentType.displayName || parentType.name;\n\n      if (parentName) {\n        info = \"\\n\\nCheck the top-level render call using <\" + parentName + \">.\";\n      }\n    }\n\n    return info;\n  }\n}\n/**\n * Warn if the element doesn't have an explicit key assigned to it.\n * This element is in an array. The array could grow and shrink or be\n * reordered. All children that haven't already been validated are required to\n * have a \"key\" property assigned to it. Error statuses are cached so a warning\n * will only be shown once.\n *\n * @internal\n * @param {ReactElement} element Element that requires a key.\n * @param {*} parentType element's parent's type.\n */\n\n\nfunction validateExplicitKey(element, parentType) {\n  {\n    if (!element._store || element._store.validated || element.key != null) {\n      return;\n    }\n\n    element._store.validated = true;\n    var currentComponentErrorInfo = getCurrentComponentErrorInfo(parentType);\n\n    if (ownerHasKeyUseWarning[currentComponentErrorInfo]) {\n      return;\n    }\n\n    ownerHasKeyUseWarning[currentComponentErrorInfo] = true; // Usually the current owner is the offender, but if it accepts children as a\n    // property, it may be the creator of the child that's responsible for\n    // assigning it a key.\n\n    var childOwner = '';\n\n    if (element && element._owner && element._owner !== ReactCurrentOwner$1.current) {\n      // Give the component that originally created this child.\n      childOwner = \" It was passed a child from \" + getComponentNameFromType(element._owner.type) + \".\";\n    }\n\n    setCurrentlyValidatingElement$1(element);\n\n    error('Each child in a list should have a unique \"key\" prop.' + '%s%s See https://reactjs.org/link/warning-keys for more information.', currentComponentErrorInfo, childOwner);\n\n    setCurrentlyValidatingElement$1(null);\n  }\n}\n/**\n * Ensure that every element either is passed in a static location, in an\n * array with an explicit keys property defined, or in an object literal\n * with valid key property.\n *\n * @internal\n * @param {ReactNode} node Statically passed child of any type.\n * @param {*} parentType node's parent's type.\n */\n\n\nfunction validateChildKeys(node, parentType) {\n  {\n    if (typeof node !== 'object') {\n      return;\n    }\n\n    if (isArray(node)) {\n      for (var i = 0; i < node.length; i++) {\n        var child = node[i];\n\n        if (isValidElement(child)) {\n          validateExplicitKey(child, parentType);\n        }\n      }\n    } else if (isValidElement(node)) {\n      // This element was passed in a valid location.\n      if (node._store) {\n        node._store.validated = true;\n      }\n    } else if (node) {\n      var iteratorFn = getIteratorFn(node);\n\n      if (typeof iteratorFn === 'function') {\n        // Entry iterators used to provide implicit keys,\n        // but now we print a separate warning for them later.\n        if (iteratorFn !== node.entries) {\n          var iterator = iteratorFn.call(node);\n          var step;\n\n          while (!(step = iterator.next()).done) {\n            if (isValidElement(step.value)) {\n              validateExplicitKey(step.value, parentType);\n            }\n          }\n        }\n      }\n    }\n  }\n}\n/**\n * Given an element, validate that its props follow the propTypes definition,\n * provided by the type.\n *\n * @param {ReactElement} element\n */\n\n\nfunction validatePropTypes(element) {\n  {\n    var type = element.type;\n\n    if (type === null || type === undefined || typeof type === 'string') {\n      return;\n    }\n\n    var propTypes;\n\n    if (typeof type === 'function') {\n      propTypes = type.propTypes;\n    } else if (typeof type === 'object' && (type.$$typeof === REACT_FORWARD_REF_TYPE || // Note: Memo only checks outer props here.\n    // Inner props are checked in the reconciler.\n    type.$$typeof === REACT_MEMO_TYPE)) {\n      propTypes = type.propTypes;\n    } else {\n      return;\n    }\n\n    if (propTypes) {\n      // Intentionally inside to avoid triggering lazy initializers:\n      var name = getComponentNameFromType(type);\n      checkPropTypes(propTypes, element.props, 'prop', name, element);\n    } else if (type.PropTypes !== undefined && !propTypesMisspellWarningShown) {\n      propTypesMisspellWarningShown = true; // Intentionally inside to avoid triggering lazy initializers:\n\n      var _name = getComponentNameFromType(type);\n\n      error('Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?', _name || 'Unknown');\n    }\n\n    if (typeof type.getDefaultProps === 'function' && !type.getDefaultProps.isReactClassApproved) {\n      error('getDefaultProps is only used on classic React.createClass ' + 'definitions. Use a static property named `defaultProps` instead.');\n    }\n  }\n}\n/**\n * Given a fragment, validate that it can only be provided with fragment props\n * @param {ReactElement} fragment\n */\n\n\nfunction validateFragmentProps(fragment) {\n  {\n    var keys = Object.keys(fragment.props);\n\n    for (var i = 0; i < keys.length; i++) {\n      var key = keys[i];\n\n      if (key !== 'children' && key !== 'key') {\n        setCurrentlyValidatingElement$1(fragment);\n\n        error('Invalid prop `%s` supplied to `React.Fragment`. ' + 'React.Fragment can only have `key` and `children` props.', key);\n\n        setCurrentlyValidatingElement$1(null);\n        break;\n      }\n    }\n\n    if (fragment.ref !== null) {\n      setCurrentlyValidatingElement$1(fragment);\n\n      error('Invalid attribute `ref` supplied to `React.Fragment`.');\n\n      setCurrentlyValidatingElement$1(null);\n    }\n  }\n}\n\nvar didWarnAboutKeySpread = {};\nfunction jsxWithValidation(type, props, key, isStaticChildren, source, self) {\n  {\n    var validType = isValidElementType(type); // We warn in this case but don't throw. We expect the element creation to\n    // succeed and there will likely be errors in render.\n\n    if (!validType) {\n      var info = '';\n\n      if (type === undefined || typeof type === 'object' && type !== null && Object.keys(type).length === 0) {\n        info += ' You likely forgot to export your component from the file ' + \"it's defined in, or you might have mixed up default and named imports.\";\n      }\n\n      var sourceInfo = getSourceInfoErrorAddendum(source);\n\n      if (sourceInfo) {\n        info += sourceInfo;\n      } else {\n        info += getDeclarationErrorAddendum();\n      }\n\n      var typeString;\n\n      if (type === null) {\n        typeString = 'null';\n      } else if (isArray(type)) {\n        typeString = 'array';\n      } else if (type !== undefined && type.$$typeof === REACT_ELEMENT_TYPE) {\n        typeString = \"<\" + (getComponentNameFromType(type.type) || 'Unknown') + \" />\";\n        info = ' Did you accidentally export a JSX literal instead of a component?';\n      } else {\n        typeString = typeof type;\n      }\n\n      error('React.jsx: type is invalid -- expected a string (for ' + 'built-in components) or a class/function (for composite ' + 'components) but got: %s.%s', typeString, info);\n    }\n\n    var element = jsxDEV(type, props, key, source, self); // The result can be nullish if a mock or a custom function is used.\n    // TODO: Drop this when these are no longer allowed as the type argument.\n\n    if (element == null) {\n      return element;\n    } // Skip key warning if the type isn't valid since our key validation logic\n    // doesn't expect a non-string/function type and can throw confusing errors.\n    // We don't want exception behavior to differ between dev and prod.\n    // (Rendering will throw with a helpful message and as soon as the type is\n    // fixed, the key warnings will appear.)\n\n\n    if (validType) {\n      var children = props.children;\n\n      if (children !== undefined) {\n        if (isStaticChildren) {\n          if (isArray(children)) {\n            for (var i = 0; i < children.length; i++) {\n              validateChildKeys(children[i], type);\n            }\n\n            if (Object.freeze) {\n              Object.freeze(children);\n            }\n          } else {\n            error('React.jsx: Static children should always be an array. ' + 'You are likely explicitly calling React.jsxs or React.jsxDEV. ' + 'Use the Babel transform instead.');\n          }\n        } else {\n          validateChildKeys(children, type);\n        }\n      }\n    }\n\n    {\n      if (hasOwnProperty.call(props, 'key')) {\n        var componentName = getComponentNameFromType(type);\n        var keys = Object.keys(props).filter(function (k) {\n          return k !== 'key';\n        });\n        var beforeExample = keys.length > 0 ? '{key: someKey, ' + keys.join(': ..., ') + ': ...}' : '{key: someKey}';\n\n        if (!didWarnAboutKeySpread[componentName + beforeExample]) {\n          var afterExample = keys.length > 0 ? '{' + keys.join(': ..., ') + ': ...}' : '{}';\n\n          error('A props object containing a \"key\" prop is being spread into JSX:\\n' + '  let props = %s;\\n' + '  <%s {...props} />\\n' + 'React keys must be passed directly to JSX without using spread:\\n' + '  let props = %s;\\n' + '  <%s key={someKey} {...props} />', beforeExample, componentName, afterExample, componentName);\n\n          didWarnAboutKeySpread[componentName + beforeExample] = true;\n        }\n      }\n    }\n\n    if (type === REACT_FRAGMENT_TYPE) {\n      validateFragmentProps(element);\n    } else {\n      validatePropTypes(element);\n    }\n\n    return element;\n  }\n} // These two functions exist to still get child warnings in dev\n\nvar jsxDEV$1 =  jsxWithValidation ;\n\nexports.Fragment = REACT_FRAGMENT_TYPE;\nexports.jsxDEV = jsxDEV$1;\n  })();\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcmVhY3QvY2pzL3JlYWN0LWpzeC1kZXYtcnVudGltZS5kZXZlbG9wbWVudC5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRWE7O0FBRWIsSUFBSSxJQUFxQztBQUN6QztBQUNBOztBQUVBLFlBQVksbUJBQU8sQ0FBQyw0Q0FBTzs7QUFFM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxpR0FBaUcsZUFBZTtBQUNoSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNOzs7QUFHTjtBQUNBO0FBQ0EsS0FBSyxHQUFHOztBQUVSLGtEQUFrRDtBQUNsRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSw0QkFBNEI7QUFDNUI7QUFDQSxxQ0FBcUM7O0FBRXJDLGdDQUFnQztBQUNoQztBQUNBOztBQUVBLGdDQUFnQzs7QUFFaEM7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7OztBQUdKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsRUFBRTs7O0FBR0Y7QUFDQTtBQUNBLEVBQUU7OztBQUdGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDOztBQUV2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQSxTQUFTO0FBQ1QsdUJBQXVCO0FBQ3ZCO0FBQ0EsU0FBUztBQUNULHVCQUF1QjtBQUN2QjtBQUNBLFNBQVM7QUFDVCx3QkFBd0I7QUFDeEI7QUFDQSxTQUFTO0FBQ1Qsd0JBQXdCO0FBQ3hCO0FBQ0EsU0FBUztBQUNULGlDQUFpQztBQUNqQztBQUNBLFNBQVM7QUFDVCwyQkFBMkI7QUFDM0I7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLE1BQU07OztBQUdOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSwyREFBMkQ7O0FBRTNEO0FBQ0E7O0FBRUE7QUFDQSx5REFBeUQ7QUFDekQ7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7OztBQUdUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBOztBQUVBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGFBQWEsa0JBQWtCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7O0FBRUE7QUFDQTtBQUNBLGdGQUFnRjtBQUNoRjtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7OztBQUdsQjtBQUNBO0FBQ0EsY0FBYztBQUNkOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsSUFBSTs7O0FBR0o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJIQUEySDtBQUMzSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxVQUFVO0FBQ1Y7QUFDQTs7QUFFQTtBQUNBOztBQUVBLG9FQUFvRTs7QUFFcEU7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxpQ0FBaUM7O0FBRWpDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7O0FBR0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsd0NBQXdDO0FBQ3hDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxHQUFHO0FBQ2QsV0FBVyxHQUFHO0FBQ2QsV0FBVyxHQUFHO0FBQ2QsV0FBVyxlQUFlO0FBQzFCLFdBQVcsR0FBRztBQUNkLFdBQVcsR0FBRztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxHQUFHO0FBQ2Q7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUssR0FBRzs7QUFFUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSyxHQUFHO0FBQ1I7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsR0FBRztBQUNkLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkI7O0FBRUE7QUFDQTtBQUNBLGtCQUFrQjs7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O0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLHFCQUFxQjtBQUNqRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsZ0RBQWdELGdEQUFnRCxNQUFNLGFBQWE7O0FBRW5IO0FBQ0EsaURBQWlELGtDQUFrQyxPQUFPOztBQUUxRix5R0FBeUcsY0FBYyxVQUFVLGdHQUFnRyxrQkFBa0IsVUFBVSxVQUFVOztBQUV2UTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEVBQUU7O0FBRUY7O0FBRUEsZ0JBQWdCO0FBQ2hCLGNBQWM7QUFDZCxHQUFHO0FBQ0giLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL3JlYWN0L2Nqcy9yZWFjdC1qc3gtZGV2LXJ1bnRpbWUuZGV2ZWxvcG1lbnQuanM/MTdlMSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBsaWNlbnNlIFJlYWN0XG4gKiByZWFjdC1qc3gtZGV2LXJ1bnRpbWUuZGV2ZWxvcG1lbnQuanNcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIEZhY2Vib29rLCBJbmMuIGFuZCBpdHMgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgKGZ1bmN0aW9uKCkge1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgUmVhY3QgPSByZXF1aXJlKCdyZWFjdCcpO1xuXG4vLyBBVFRFTlRJT05cbi8vIFdoZW4gYWRkaW5nIG5ldyBzeW1ib2xzIHRvIHRoaXMgZmlsZSxcbi8vIFBsZWFzZSBjb25zaWRlciBhbHNvIGFkZGluZyB0byAncmVhY3QtZGV2dG9vbHMtc2hhcmVkL3NyYy9iYWNrZW5kL1JlYWN0U3ltYm9scydcbi8vIFRoZSBTeW1ib2wgdXNlZCB0byB0YWcgdGhlIFJlYWN0RWxlbWVudC1saWtlIHR5cGVzLlxudmFyIFJFQUNUX0VMRU1FTlRfVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0LmVsZW1lbnQnKTtcbnZhciBSRUFDVF9QT1JUQUxfVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0LnBvcnRhbCcpO1xudmFyIFJFQUNUX0ZSQUdNRU5UX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5mcmFnbWVudCcpO1xudmFyIFJFQUNUX1NUUklDVF9NT0RFX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5zdHJpY3RfbW9kZScpO1xudmFyIFJFQUNUX1BST0ZJTEVSX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5wcm9maWxlcicpO1xudmFyIFJFQUNUX1BST1ZJREVSX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5wcm92aWRlcicpO1xudmFyIFJFQUNUX0NPTlRFWFRfVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0LmNvbnRleHQnKTtcbnZhciBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFID0gU3ltYm9sLmZvcigncmVhY3QuZm9yd2FyZF9yZWYnKTtcbnZhciBSRUFDVF9TVVNQRU5TRV9UWVBFID0gU3ltYm9sLmZvcigncmVhY3Quc3VzcGVuc2UnKTtcbnZhciBSRUFDVF9TVVNQRU5TRV9MSVNUX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5zdXNwZW5zZV9saXN0Jyk7XG52YXIgUkVBQ1RfTUVNT19UWVBFID0gU3ltYm9sLmZvcigncmVhY3QubWVtbycpO1xudmFyIFJFQUNUX0xBWllfVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0LmxhenknKTtcbnZhciBSRUFDVF9PRkZTQ1JFRU5fVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0Lm9mZnNjcmVlbicpO1xudmFyIE1BWUJFX0lURVJBVE9SX1NZTUJPTCA9IFN5bWJvbC5pdGVyYXRvcjtcbnZhciBGQVVYX0lURVJBVE9SX1NZTUJPTCA9ICdAQGl0ZXJhdG9yJztcbmZ1bmN0aW9uIGdldEl0ZXJhdG9yRm4obWF5YmVJdGVyYWJsZSkge1xuICBpZiAobWF5YmVJdGVyYWJsZSA9PT0gbnVsbCB8fCB0eXBlb2YgbWF5YmVJdGVyYWJsZSAhPT0gJ29iamVjdCcpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHZhciBtYXliZUl0ZXJhdG9yID0gTUFZQkVfSVRFUkFUT1JfU1lNQk9MICYmIG1heWJlSXRlcmFibGVbTUFZQkVfSVRFUkFUT1JfU1lNQk9MXSB8fCBtYXliZUl0ZXJhYmxlW0ZBVVhfSVRFUkFUT1JfU1lNQk9MXTtcblxuICBpZiAodHlwZW9mIG1heWJlSXRlcmF0b3IgPT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gbWF5YmVJdGVyYXRvcjtcbiAgfVxuXG4gIHJldHVybiBudWxsO1xufVxuXG52YXIgUmVhY3RTaGFyZWRJbnRlcm5hbHMgPSBSZWFjdC5fX1NFQ1JFVF9JTlRFUk5BTFNfRE9fTk9UX1VTRV9PUl9ZT1VfV0lMTF9CRV9GSVJFRDtcblxuZnVuY3Rpb24gZXJyb3IoZm9ybWF0KSB7XG4gIHtcbiAgICB7XG4gICAgICBmb3IgKHZhciBfbGVuMiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbjIgPiAxID8gX2xlbjIgLSAxIDogMCksIF9rZXkyID0gMTsgX2tleTIgPCBfbGVuMjsgX2tleTIrKykge1xuICAgICAgICBhcmdzW19rZXkyIC0gMV0gPSBhcmd1bWVudHNbX2tleTJdO1xuICAgICAgfVxuXG4gICAgICBwcmludFdhcm5pbmcoJ2Vycm9yJywgZm9ybWF0LCBhcmdzKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gcHJpbnRXYXJuaW5nKGxldmVsLCBmb3JtYXQsIGFyZ3MpIHtcbiAgLy8gV2hlbiBjaGFuZ2luZyB0aGlzIGxvZ2ljLCB5b3UgbWlnaHQgd2FudCB0byBhbHNvXG4gIC8vIHVwZGF0ZSBjb25zb2xlV2l0aFN0YWNrRGV2Lnd3dy5qcyBhcyB3ZWxsLlxuICB7XG4gICAgdmFyIFJlYWN0RGVidWdDdXJyZW50RnJhbWUgPSBSZWFjdFNoYXJlZEludGVybmFscy5SZWFjdERlYnVnQ3VycmVudEZyYW1lO1xuICAgIHZhciBzdGFjayA9IFJlYWN0RGVidWdDdXJyZW50RnJhbWUuZ2V0U3RhY2tBZGRlbmR1bSgpO1xuXG4gICAgaWYgKHN0YWNrICE9PSAnJykge1xuICAgICAgZm9ybWF0ICs9ICclcyc7XG4gICAgICBhcmdzID0gYXJncy5jb25jYXQoW3N0YWNrXSk7XG4gICAgfSAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaW50ZXJuYWwvc2FmZS1zdHJpbmctY29lcmNpb25cblxuXG4gICAgdmFyIGFyZ3NXaXRoRm9ybWF0ID0gYXJncy5tYXAoZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgIHJldHVybiBTdHJpbmcoaXRlbSk7XG4gICAgfSk7IC8vIENhcmVmdWw6IFJOIGN1cnJlbnRseSBkZXBlbmRzIG9uIHRoaXMgcHJlZml4XG5cbiAgICBhcmdzV2l0aEZvcm1hdC51bnNoaWZ0KCdXYXJuaW5nOiAnICsgZm9ybWF0KTsgLy8gV2UgaW50ZW50aW9uYWxseSBkb24ndCB1c2Ugc3ByZWFkIChvciAuYXBwbHkpIGRpcmVjdGx5IGJlY2F1c2UgaXRcbiAgICAvLyBicmVha3MgSUU5OiBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvaXNzdWVzLzEzNjEwXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWludGVybmFsL25vLXByb2R1Y3Rpb24tbG9nZ2luZ1xuXG4gICAgRnVuY3Rpb24ucHJvdG90eXBlLmFwcGx5LmNhbGwoY29uc29sZVtsZXZlbF0sIGNvbnNvbGUsIGFyZ3NXaXRoRm9ybWF0KTtcbiAgfVxufVxuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG52YXIgZW5hYmxlU2NvcGVBUEkgPSBmYWxzZTsgLy8gRXhwZXJpbWVudGFsIENyZWF0ZSBFdmVudCBIYW5kbGUgQVBJLlxudmFyIGVuYWJsZUNhY2hlRWxlbWVudCA9IGZhbHNlO1xudmFyIGVuYWJsZVRyYW5zaXRpb25UcmFjaW5nID0gZmFsc2U7IC8vIE5vIGtub3duIGJ1Z3MsIGJ1dCBuZWVkcyBwZXJmb3JtYW5jZSB0ZXN0aW5nXG5cbnZhciBlbmFibGVMZWdhY3lIaWRkZW4gPSBmYWxzZTsgLy8gRW5hYmxlcyB1bnN0YWJsZV9hdm9pZFRoaXNGYWxsYmFjayBmZWF0dXJlIGluIEZpYmVyXG4vLyBzdHVmZi4gSW50ZW5kZWQgdG8gZW5hYmxlIFJlYWN0IGNvcmUgbWVtYmVycyB0byBtb3JlIGVhc2lseSBkZWJ1ZyBzY2hlZHVsaW5nXG4vLyBpc3N1ZXMgaW4gREVWIGJ1aWxkcy5cblxudmFyIGVuYWJsZURlYnVnVHJhY2luZyA9IGZhbHNlOyAvLyBUcmFjayB3aGljaCBGaWJlcihzKSBzY2hlZHVsZSByZW5kZXIgd29yay5cblxudmFyIFJFQUNUX01PRFVMRV9SRUZFUkVOQ0U7XG5cbntcbiAgUkVBQ1RfTU9EVUxFX1JFRkVSRU5DRSA9IFN5bWJvbC5mb3IoJ3JlYWN0Lm1vZHVsZS5yZWZlcmVuY2UnKTtcbn1cblxuZnVuY3Rpb24gaXNWYWxpZEVsZW1lbnRUeXBlKHR5cGUpIHtcbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnc3RyaW5nJyB8fCB0eXBlb2YgdHlwZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiB0cnVlO1xuICB9IC8vIE5vdGU6IHR5cGVvZiBtaWdodCBiZSBvdGhlciB0aGFuICdzeW1ib2wnIG9yICdudW1iZXInIChlLmcuIGlmIGl0J3MgYSBwb2x5ZmlsbCkuXG5cblxuICBpZiAodHlwZSA9PT0gUkVBQ1RfRlJBR01FTlRfVFlQRSB8fCB0eXBlID09PSBSRUFDVF9QUk9GSUxFUl9UWVBFIHx8IGVuYWJsZURlYnVnVHJhY2luZyAgfHwgdHlwZSA9PT0gUkVBQ1RfU1RSSUNUX01PREVfVFlQRSB8fCB0eXBlID09PSBSRUFDVF9TVVNQRU5TRV9UWVBFIHx8IHR5cGUgPT09IFJFQUNUX1NVU1BFTlNFX0xJU1RfVFlQRSB8fCBlbmFibGVMZWdhY3lIaWRkZW4gIHx8IHR5cGUgPT09IFJFQUNUX09GRlNDUkVFTl9UWVBFIHx8IGVuYWJsZVNjb3BlQVBJICB8fCBlbmFibGVDYWNoZUVsZW1lbnQgIHx8IGVuYWJsZVRyYW5zaXRpb25UcmFjaW5nICkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnb2JqZWN0JyAmJiB0eXBlICE9PSBudWxsKSB7XG4gICAgaWYgKHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0xBWllfVFlQRSB8fCB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9NRU1PX1RZUEUgfHwgdHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfUFJPVklERVJfVFlQRSB8fCB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9DT05URVhUX1RZUEUgfHwgdHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfRk9SV0FSRF9SRUZfVFlQRSB8fCAvLyBUaGlzIG5lZWRzIHRvIGluY2x1ZGUgYWxsIHBvc3NpYmxlIG1vZHVsZSByZWZlcmVuY2Ugb2JqZWN0XG4gICAgLy8gdHlwZXMgc3VwcG9ydGVkIGJ5IGFueSBGbGlnaHQgY29uZmlndXJhdGlvbiBhbnl3aGVyZSBzaW5jZVxuICAgIC8vIHdlIGRvbid0IGtub3cgd2hpY2ggRmxpZ2h0IGJ1aWxkIHRoaXMgd2lsbCBlbmQgdXAgYmVpbmcgdXNlZFxuICAgIC8vIHdpdGguXG4gICAgdHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfTU9EVUxFX1JFRkVSRU5DRSB8fCB0eXBlLmdldE1vZHVsZUlkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gZ2V0V3JhcHBlZE5hbWUob3V0ZXJUeXBlLCBpbm5lclR5cGUsIHdyYXBwZXJOYW1lKSB7XG4gIHZhciBkaXNwbGF5TmFtZSA9IG91dGVyVHlwZS5kaXNwbGF5TmFtZTtcblxuICBpZiAoZGlzcGxheU5hbWUpIHtcbiAgICByZXR1cm4gZGlzcGxheU5hbWU7XG4gIH1cblxuICB2YXIgZnVuY3Rpb25OYW1lID0gaW5uZXJUeXBlLmRpc3BsYXlOYW1lIHx8IGlubmVyVHlwZS5uYW1lIHx8ICcnO1xuICByZXR1cm4gZnVuY3Rpb25OYW1lICE9PSAnJyA/IHdyYXBwZXJOYW1lICsgXCIoXCIgKyBmdW5jdGlvbk5hbWUgKyBcIilcIiA6IHdyYXBwZXJOYW1lO1xufSAvLyBLZWVwIGluIHN5bmMgd2l0aCByZWFjdC1yZWNvbmNpbGVyL2dldENvbXBvbmVudE5hbWVGcm9tRmliZXJcblxuXG5mdW5jdGlvbiBnZXRDb250ZXh0TmFtZSh0eXBlKSB7XG4gIHJldHVybiB0eXBlLmRpc3BsYXlOYW1lIHx8ICdDb250ZXh0Jztcbn0gLy8gTm90ZSB0aGF0IHRoZSByZWNvbmNpbGVyIHBhY2thZ2Ugc2hvdWxkIGdlbmVyYWxseSBwcmVmZXIgdG8gdXNlIGdldENvbXBvbmVudE5hbWVGcm9tRmliZXIoKSBpbnN0ZWFkLlxuXG5cbmZ1bmN0aW9uIGdldENvbXBvbmVudE5hbWVGcm9tVHlwZSh0eXBlKSB7XG4gIGlmICh0eXBlID09IG51bGwpIHtcbiAgICAvLyBIb3N0IHJvb3QsIHRleHQgbm9kZSBvciBqdXN0IGludmFsaWQgdHlwZS5cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHtcbiAgICBpZiAodHlwZW9mIHR5cGUudGFnID09PSAnbnVtYmVyJykge1xuICAgICAgZXJyb3IoJ1JlY2VpdmVkIGFuIHVuZXhwZWN0ZWQgb2JqZWN0IGluIGdldENvbXBvbmVudE5hbWVGcm9tVHlwZSgpLiAnICsgJ1RoaXMgaXMgbGlrZWx5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nKTtcbiAgICB9XG4gIH1cblxuICBpZiAodHlwZW9mIHR5cGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gdHlwZS5kaXNwbGF5TmFtZSB8fCB0eXBlLm5hbWUgfHwgbnVsbDtcbiAgfVxuXG4gIGlmICh0eXBlb2YgdHlwZSA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gdHlwZTtcbiAgfVxuXG4gIHN3aXRjaCAodHlwZSkge1xuICAgIGNhc2UgUkVBQ1RfRlJBR01FTlRfVFlQRTpcbiAgICAgIHJldHVybiAnRnJhZ21lbnQnO1xuXG4gICAgY2FzZSBSRUFDVF9QT1JUQUxfVFlQRTpcbiAgICAgIHJldHVybiAnUG9ydGFsJztcblxuICAgIGNhc2UgUkVBQ1RfUFJPRklMRVJfVFlQRTpcbiAgICAgIHJldHVybiAnUHJvZmlsZXInO1xuXG4gICAgY2FzZSBSRUFDVF9TVFJJQ1RfTU9ERV9UWVBFOlxuICAgICAgcmV0dXJuICdTdHJpY3RNb2RlJztcblxuICAgIGNhc2UgUkVBQ1RfU1VTUEVOU0VfVFlQRTpcbiAgICAgIHJldHVybiAnU3VzcGVuc2UnO1xuXG4gICAgY2FzZSBSRUFDVF9TVVNQRU5TRV9MSVNUX1RZUEU6XG4gICAgICByZXR1cm4gJ1N1c3BlbnNlTGlzdCc7XG5cbiAgfVxuXG4gIGlmICh0eXBlb2YgdHlwZSA9PT0gJ29iamVjdCcpIHtcbiAgICBzd2l0Y2ggKHR5cGUuJCR0eXBlb2YpIHtcbiAgICAgIGNhc2UgUkVBQ1RfQ09OVEVYVF9UWVBFOlxuICAgICAgICB2YXIgY29udGV4dCA9IHR5cGU7XG4gICAgICAgIHJldHVybiBnZXRDb250ZXh0TmFtZShjb250ZXh0KSArICcuQ29uc3VtZXInO1xuXG4gICAgICBjYXNlIFJFQUNUX1BST1ZJREVSX1RZUEU6XG4gICAgICAgIHZhciBwcm92aWRlciA9IHR5cGU7XG4gICAgICAgIHJldHVybiBnZXRDb250ZXh0TmFtZShwcm92aWRlci5fY29udGV4dCkgKyAnLlByb3ZpZGVyJztcblxuICAgICAgY2FzZSBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFOlxuICAgICAgICByZXR1cm4gZ2V0V3JhcHBlZE5hbWUodHlwZSwgdHlwZS5yZW5kZXIsICdGb3J3YXJkUmVmJyk7XG5cbiAgICAgIGNhc2UgUkVBQ1RfTUVNT19UWVBFOlxuICAgICAgICB2YXIgb3V0ZXJOYW1lID0gdHlwZS5kaXNwbGF5TmFtZSB8fCBudWxsO1xuXG4gICAgICAgIGlmIChvdXRlck5hbWUgIT09IG51bGwpIHtcbiAgICAgICAgICByZXR1cm4gb3V0ZXJOYW1lO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGdldENvbXBvbmVudE5hbWVGcm9tVHlwZSh0eXBlLnR5cGUpIHx8ICdNZW1vJztcblxuICAgICAgY2FzZSBSRUFDVF9MQVpZX1RZUEU6XG4gICAgICAgIHtcbiAgICAgICAgICB2YXIgbGF6eUNvbXBvbmVudCA9IHR5cGU7XG4gICAgICAgICAgdmFyIHBheWxvYWQgPSBsYXp5Q29tcG9uZW50Ll9wYXlsb2FkO1xuICAgICAgICAgIHZhciBpbml0ID0gbGF6eUNvbXBvbmVudC5faW5pdDtcblxuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXR1cm4gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKGluaXQocGF5bG9hZCkpO1xuICAgICAgICAgIH0gY2F0Y2ggKHgpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tZmFsbHRocm91Z2hcbiAgICB9XG4gIH1cblxuICByZXR1cm4gbnVsbDtcbn1cblxudmFyIGFzc2lnbiA9IE9iamVjdC5hc3NpZ247XG5cbi8vIEhlbHBlcnMgdG8gcGF0Y2ggY29uc29sZS5sb2dzIHRvIGF2b2lkIGxvZ2dpbmcgZHVyaW5nIHNpZGUtZWZmZWN0IGZyZWVcbi8vIHJlcGxheWluZyBvbiByZW5kZXIgZnVuY3Rpb24uIFRoaXMgY3VycmVudGx5IG9ubHkgcGF0Y2hlcyB0aGUgb2JqZWN0XG4vLyBsYXppbHkgd2hpY2ggd29uJ3QgY292ZXIgaWYgdGhlIGxvZyBmdW5jdGlvbiB3YXMgZXh0cmFjdGVkIGVhZ2VybHkuXG4vLyBXZSBjb3VsZCBhbHNvIGVhZ2VybHkgcGF0Y2ggdGhlIG1ldGhvZC5cbnZhciBkaXNhYmxlZERlcHRoID0gMDtcbnZhciBwcmV2TG9nO1xudmFyIHByZXZJbmZvO1xudmFyIHByZXZXYXJuO1xudmFyIHByZXZFcnJvcjtcbnZhciBwcmV2R3JvdXA7XG52YXIgcHJldkdyb3VwQ29sbGFwc2VkO1xudmFyIHByZXZHcm91cEVuZDtcblxuZnVuY3Rpb24gZGlzYWJsZWRMb2coKSB7fVxuXG5kaXNhYmxlZExvZy5fX3JlYWN0RGlzYWJsZWRMb2cgPSB0cnVlO1xuZnVuY3Rpb24gZGlzYWJsZUxvZ3MoKSB7XG4gIHtcbiAgICBpZiAoZGlzYWJsZWREZXB0aCA9PT0gMCkge1xuICAgICAgLyogZXNsaW50LWRpc2FibGUgcmVhY3QtaW50ZXJuYWwvbm8tcHJvZHVjdGlvbi1sb2dnaW5nICovXG4gICAgICBwcmV2TG9nID0gY29uc29sZS5sb2c7XG4gICAgICBwcmV2SW5mbyA9IGNvbnNvbGUuaW5mbztcbiAgICAgIHByZXZXYXJuID0gY29uc29sZS53YXJuO1xuICAgICAgcHJldkVycm9yID0gY29uc29sZS5lcnJvcjtcbiAgICAgIHByZXZHcm91cCA9IGNvbnNvbGUuZ3JvdXA7XG4gICAgICBwcmV2R3JvdXBDb2xsYXBzZWQgPSBjb25zb2xlLmdyb3VwQ29sbGFwc2VkO1xuICAgICAgcHJldkdyb3VwRW5kID0gY29uc29sZS5ncm91cEVuZDsgLy8gaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L2lzc3Vlcy8xOTA5OVxuXG4gICAgICB2YXIgcHJvcHMgPSB7XG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgdmFsdWU6IGRpc2FibGVkTG9nLFxuICAgICAgICB3cml0YWJsZTogdHJ1ZVxuICAgICAgfTsgLy8gJEZsb3dGaXhNZSBGbG93IHRoaW5rcyBjb25zb2xlIGlzIGltbXV0YWJsZS5cblxuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoY29uc29sZSwge1xuICAgICAgICBpbmZvOiBwcm9wcyxcbiAgICAgICAgbG9nOiBwcm9wcyxcbiAgICAgICAgd2FybjogcHJvcHMsXG4gICAgICAgIGVycm9yOiBwcm9wcyxcbiAgICAgICAgZ3JvdXA6IHByb3BzLFxuICAgICAgICBncm91cENvbGxhcHNlZDogcHJvcHMsXG4gICAgICAgIGdyb3VwRW5kOiBwcm9wc1xuICAgICAgfSk7XG4gICAgICAvKiBlc2xpbnQtZW5hYmxlIHJlYWN0LWludGVybmFsL25vLXByb2R1Y3Rpb24tbG9nZ2luZyAqL1xuICAgIH1cblxuICAgIGRpc2FibGVkRGVwdGgrKztcbiAgfVxufVxuZnVuY3Rpb24gcmVlbmFibGVMb2dzKCkge1xuICB7XG4gICAgZGlzYWJsZWREZXB0aC0tO1xuXG4gICAgaWYgKGRpc2FibGVkRGVwdGggPT09IDApIHtcbiAgICAgIC8qIGVzbGludC1kaXNhYmxlIHJlYWN0LWludGVybmFsL25vLXByb2R1Y3Rpb24tbG9nZ2luZyAqL1xuICAgICAgdmFyIHByb3BzID0ge1xuICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIHdyaXRhYmxlOiB0cnVlXG4gICAgICB9OyAvLyAkRmxvd0ZpeE1lIEZsb3cgdGhpbmtzIGNvbnNvbGUgaXMgaW1tdXRhYmxlLlxuXG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhjb25zb2xlLCB7XG4gICAgICAgIGxvZzogYXNzaWduKHt9LCBwcm9wcywge1xuICAgICAgICAgIHZhbHVlOiBwcmV2TG9nXG4gICAgICAgIH0pLFxuICAgICAgICBpbmZvOiBhc3NpZ24oe30sIHByb3BzLCB7XG4gICAgICAgICAgdmFsdWU6IHByZXZJbmZvXG4gICAgICAgIH0pLFxuICAgICAgICB3YXJuOiBhc3NpZ24oe30sIHByb3BzLCB7XG4gICAgICAgICAgdmFsdWU6IHByZXZXYXJuXG4gICAgICAgIH0pLFxuICAgICAgICBlcnJvcjogYXNzaWduKHt9LCBwcm9wcywge1xuICAgICAgICAgIHZhbHVlOiBwcmV2RXJyb3JcbiAgICAgICAgfSksXG4gICAgICAgIGdyb3VwOiBhc3NpZ24oe30sIHByb3BzLCB7XG4gICAgICAgICAgdmFsdWU6IHByZXZHcm91cFxuICAgICAgICB9KSxcbiAgICAgICAgZ3JvdXBDb2xsYXBzZWQ6IGFzc2lnbih7fSwgcHJvcHMsIHtcbiAgICAgICAgICB2YWx1ZTogcHJldkdyb3VwQ29sbGFwc2VkXG4gICAgICAgIH0pLFxuICAgICAgICBncm91cEVuZDogYXNzaWduKHt9LCBwcm9wcywge1xuICAgICAgICAgIHZhbHVlOiBwcmV2R3JvdXBFbmRcbiAgICAgICAgfSlcbiAgICAgIH0pO1xuICAgICAgLyogZXNsaW50LWVuYWJsZSByZWFjdC1pbnRlcm5hbC9uby1wcm9kdWN0aW9uLWxvZ2dpbmcgKi9cbiAgICB9XG5cbiAgICBpZiAoZGlzYWJsZWREZXB0aCA8IDApIHtcbiAgICAgIGVycm9yKCdkaXNhYmxlZERlcHRoIGZlbGwgYmVsb3cgemVyby4gJyArICdUaGlzIGlzIGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nKTtcbiAgICB9XG4gIH1cbn1cblxudmFyIFJlYWN0Q3VycmVudERpc3BhdGNoZXIgPSBSZWFjdFNoYXJlZEludGVybmFscy5SZWFjdEN1cnJlbnREaXNwYXRjaGVyO1xudmFyIHByZWZpeDtcbmZ1bmN0aW9uIGRlc2NyaWJlQnVpbHRJbkNvbXBvbmVudEZyYW1lKG5hbWUsIHNvdXJjZSwgb3duZXJGbikge1xuICB7XG4gICAgaWYgKHByZWZpeCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAvLyBFeHRyYWN0IHRoZSBWTSBzcGVjaWZpYyBwcmVmaXggdXNlZCBieSBlYWNoIGxpbmUuXG4gICAgICB0cnkge1xuICAgICAgICB0aHJvdyBFcnJvcigpO1xuICAgICAgfSBjYXRjaCAoeCkge1xuICAgICAgICB2YXIgbWF0Y2ggPSB4LnN0YWNrLnRyaW0oKS5tYXRjaCgvXFxuKCAqKGF0ICk/KS8pO1xuICAgICAgICBwcmVmaXggPSBtYXRjaCAmJiBtYXRjaFsxXSB8fCAnJztcbiAgICAgIH1cbiAgICB9IC8vIFdlIHVzZSB0aGUgcHJlZml4IHRvIGVuc3VyZSBvdXIgc3RhY2tzIGxpbmUgdXAgd2l0aCBuYXRpdmUgc3RhY2sgZnJhbWVzLlxuXG5cbiAgICByZXR1cm4gJ1xcbicgKyBwcmVmaXggKyBuYW1lO1xuICB9XG59XG52YXIgcmVlbnRyeSA9IGZhbHNlO1xudmFyIGNvbXBvbmVudEZyYW1lQ2FjaGU7XG5cbntcbiAgdmFyIFBvc3NpYmx5V2Vha01hcCA9IHR5cGVvZiBXZWFrTWFwID09PSAnZnVuY3Rpb24nID8gV2Vha01hcCA6IE1hcDtcbiAgY29tcG9uZW50RnJhbWVDYWNoZSA9IG5ldyBQb3NzaWJseVdlYWtNYXAoKTtcbn1cblxuZnVuY3Rpb24gZGVzY3JpYmVOYXRpdmVDb21wb25lbnRGcmFtZShmbiwgY29uc3RydWN0KSB7XG4gIC8vIElmIHNvbWV0aGluZyBhc2tlZCBmb3IgYSBzdGFjayBpbnNpZGUgYSBmYWtlIHJlbmRlciwgaXQgc2hvdWxkIGdldCBpZ25vcmVkLlxuICBpZiAoICFmbiB8fCByZWVudHJ5KSB7XG4gICAgcmV0dXJuICcnO1xuICB9XG5cbiAge1xuICAgIHZhciBmcmFtZSA9IGNvbXBvbmVudEZyYW1lQ2FjaGUuZ2V0KGZuKTtcblxuICAgIGlmIChmcmFtZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gZnJhbWU7XG4gICAgfVxuICB9XG5cbiAgdmFyIGNvbnRyb2w7XG4gIHJlZW50cnkgPSB0cnVlO1xuICB2YXIgcHJldmlvdXNQcmVwYXJlU3RhY2tUcmFjZSA9IEVycm9yLnByZXBhcmVTdGFja1RyYWNlOyAvLyAkRmxvd0ZpeE1lIEl0IGRvZXMgYWNjZXB0IHVuZGVmaW5lZC5cblxuICBFcnJvci5wcmVwYXJlU3RhY2tUcmFjZSA9IHVuZGVmaW5lZDtcbiAgdmFyIHByZXZpb3VzRGlzcGF0Y2hlcjtcblxuICB7XG4gICAgcHJldmlvdXNEaXNwYXRjaGVyID0gUmVhY3RDdXJyZW50RGlzcGF0Y2hlci5jdXJyZW50OyAvLyBTZXQgdGhlIGRpc3BhdGNoZXIgaW4gREVWIGJlY2F1c2UgdGhpcyBtaWdodCBiZSBjYWxsIGluIHRoZSByZW5kZXIgZnVuY3Rpb25cbiAgICAvLyBmb3Igd2FybmluZ3MuXG5cbiAgICBSZWFjdEN1cnJlbnREaXNwYXRjaGVyLmN1cnJlbnQgPSBudWxsO1xuICAgIGRpc2FibGVMb2dzKCk7XG4gIH1cblxuICB0cnkge1xuICAgIC8vIFRoaXMgc2hvdWxkIHRocm93LlxuICAgIGlmIChjb25zdHJ1Y3QpIHtcbiAgICAgIC8vIFNvbWV0aGluZyBzaG91bGQgYmUgc2V0dGluZyB0aGUgcHJvcHMgaW4gdGhlIGNvbnN0cnVjdG9yLlxuICAgICAgdmFyIEZha2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRocm93IEVycm9yKCk7XG4gICAgICB9OyAvLyAkRmxvd0ZpeE1lXG5cblxuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEZha2UucHJvdG90eXBlLCAncHJvcHMnLCB7XG4gICAgICAgIHNldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgIC8vIFdlIHVzZSBhIHRocm93aW5nIHNldHRlciBpbnN0ZWFkIG9mIGZyb3plbiBvciBub24td3JpdGFibGUgcHJvcHNcbiAgICAgICAgICAvLyBiZWNhdXNlIHRoYXQgd29uJ3QgdGhyb3cgaW4gYSBub24tc3RyaWN0IG1vZGUgZnVuY3Rpb24uXG4gICAgICAgICAgdGhyb3cgRXJyb3IoKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gJ29iamVjdCcgJiYgUmVmbGVjdC5jb25zdHJ1Y3QpIHtcbiAgICAgICAgLy8gV2UgY29uc3RydWN0IGEgZGlmZmVyZW50IGNvbnRyb2wgZm9yIHRoaXMgY2FzZSB0byBpbmNsdWRlIGFueSBleHRyYVxuICAgICAgICAvLyBmcmFtZXMgYWRkZWQgYnkgdGhlIGNvbnN0cnVjdCBjYWxsLlxuICAgICAgICB0cnkge1xuICAgICAgICAgIFJlZmxlY3QuY29uc3RydWN0KEZha2UsIFtdKTtcbiAgICAgICAgfSBjYXRjaCAoeCkge1xuICAgICAgICAgIGNvbnRyb2wgPSB4O1xuICAgICAgICB9XG5cbiAgICAgICAgUmVmbGVjdC5jb25zdHJ1Y3QoZm4sIFtdLCBGYWtlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgRmFrZS5jYWxsKCk7XG4gICAgICAgIH0gY2F0Y2ggKHgpIHtcbiAgICAgICAgICBjb250cm9sID0geDtcbiAgICAgICAgfVxuXG4gICAgICAgIGZuLmNhbGwoRmFrZS5wcm90b3R5cGUpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB0cnkge1xuICAgICAgICB0aHJvdyBFcnJvcigpO1xuICAgICAgfSBjYXRjaCAoeCkge1xuICAgICAgICBjb250cm9sID0geDtcbiAgICAgIH1cblxuICAgICAgZm4oKTtcbiAgICB9XG4gIH0gY2F0Y2ggKHNhbXBsZSkge1xuICAgIC8vIFRoaXMgaXMgaW5saW5lZCBtYW51YWxseSBiZWNhdXNlIGNsb3N1cmUgZG9lc24ndCBkbyBpdCBmb3IgdXMuXG4gICAgaWYgKHNhbXBsZSAmJiBjb250cm9sICYmIHR5cGVvZiBzYW1wbGUuc3RhY2sgPT09ICdzdHJpbmcnKSB7XG4gICAgICAvLyBUaGlzIGV4dHJhY3RzIHRoZSBmaXJzdCBmcmFtZSBmcm9tIHRoZSBzYW1wbGUgdGhhdCBpc24ndCBhbHNvIGluIHRoZSBjb250cm9sLlxuICAgICAgLy8gU2tpcHBpbmcgb25lIGZyYW1lIHRoYXQgd2UgYXNzdW1lIGlzIHRoZSBmcmFtZSB0aGF0IGNhbGxzIHRoZSB0d28uXG4gICAgICB2YXIgc2FtcGxlTGluZXMgPSBzYW1wbGUuc3RhY2suc3BsaXQoJ1xcbicpO1xuICAgICAgdmFyIGNvbnRyb2xMaW5lcyA9IGNvbnRyb2wuc3RhY2suc3BsaXQoJ1xcbicpO1xuICAgICAgdmFyIHMgPSBzYW1wbGVMaW5lcy5sZW5ndGggLSAxO1xuICAgICAgdmFyIGMgPSBjb250cm9sTGluZXMubGVuZ3RoIC0gMTtcblxuICAgICAgd2hpbGUgKHMgPj0gMSAmJiBjID49IDAgJiYgc2FtcGxlTGluZXNbc10gIT09IGNvbnRyb2xMaW5lc1tjXSkge1xuICAgICAgICAvLyBXZSBleHBlY3QgYXQgbGVhc3Qgb25lIHN0YWNrIGZyYW1lIHRvIGJlIHNoYXJlZC5cbiAgICAgICAgLy8gVHlwaWNhbGx5IHRoaXMgd2lsbCBiZSB0aGUgcm9vdCBtb3N0IG9uZS4gSG93ZXZlciwgc3RhY2sgZnJhbWVzIG1heSBiZVxuICAgICAgICAvLyBjdXQgb2ZmIGR1ZSB0byBtYXhpbXVtIHN0YWNrIGxpbWl0cy4gSW4gdGhpcyBjYXNlLCBvbmUgbWF5YmUgY3V0IG9mZlxuICAgICAgICAvLyBlYXJsaWVyIHRoYW4gdGhlIG90aGVyLiBXZSBhc3N1bWUgdGhhdCB0aGUgc2FtcGxlIGlzIGxvbmdlciBvciB0aGUgc2FtZVxuICAgICAgICAvLyBhbmQgdGhlcmUgZm9yIGN1dCBvZmYgZWFybGllci4gU28gd2Ugc2hvdWxkIGZpbmQgdGhlIHJvb3QgbW9zdCBmcmFtZSBpblxuICAgICAgICAvLyB0aGUgc2FtcGxlIHNvbWV3aGVyZSBpbiB0aGUgY29udHJvbC5cbiAgICAgICAgYy0tO1xuICAgICAgfVxuXG4gICAgICBmb3IgKDsgcyA+PSAxICYmIGMgPj0gMDsgcy0tLCBjLS0pIHtcbiAgICAgICAgLy8gTmV4dCB3ZSBmaW5kIHRoZSBmaXJzdCBvbmUgdGhhdCBpc24ndCB0aGUgc2FtZSB3aGljaCBzaG91bGQgYmUgdGhlXG4gICAgICAgIC8vIGZyYW1lIHRoYXQgY2FsbGVkIG91ciBzYW1wbGUgZnVuY3Rpb24gYW5kIHRoZSBjb250cm9sLlxuICAgICAgICBpZiAoc2FtcGxlTGluZXNbc10gIT09IGNvbnRyb2xMaW5lc1tjXSkge1xuICAgICAgICAgIC8vIEluIFY4LCB0aGUgZmlyc3QgbGluZSBpcyBkZXNjcmliaW5nIHRoZSBtZXNzYWdlIGJ1dCBvdGhlciBWTXMgZG9uJ3QuXG4gICAgICAgICAgLy8gSWYgd2UncmUgYWJvdXQgdG8gcmV0dXJuIHRoZSBmaXJzdCBsaW5lLCBhbmQgdGhlIGNvbnRyb2wgaXMgYWxzbyBvbiB0aGUgc2FtZVxuICAgICAgICAgIC8vIGxpbmUsIHRoYXQncyBhIHByZXR0eSBnb29kIGluZGljYXRvciB0aGF0IG91ciBzYW1wbGUgdGhyZXcgYXQgc2FtZSBsaW5lIGFzXG4gICAgICAgICAgLy8gdGhlIGNvbnRyb2wuIEkuZS4gYmVmb3JlIHdlIGVudGVyZWQgdGhlIHNhbXBsZSBmcmFtZS4gU28gd2UgaWdub3JlIHRoaXMgcmVzdWx0LlxuICAgICAgICAgIC8vIFRoaXMgY2FuIGhhcHBlbiBpZiB5b3UgcGFzc2VkIGEgY2xhc3MgdG8gZnVuY3Rpb24gY29tcG9uZW50LCBvciBub24tZnVuY3Rpb24uXG4gICAgICAgICAgaWYgKHMgIT09IDEgfHwgYyAhPT0gMSkge1xuICAgICAgICAgICAgZG8ge1xuICAgICAgICAgICAgICBzLS07XG4gICAgICAgICAgICAgIGMtLTsgLy8gV2UgbWF5IHN0aWxsIGhhdmUgc2ltaWxhciBpbnRlcm1lZGlhdGUgZnJhbWVzIGZyb20gdGhlIGNvbnN0cnVjdCBjYWxsLlxuICAgICAgICAgICAgICAvLyBUaGUgbmV4dCBvbmUgdGhhdCBpc24ndCB0aGUgc2FtZSBzaG91bGQgYmUgb3VyIG1hdGNoIHRob3VnaC5cblxuICAgICAgICAgICAgICBpZiAoYyA8IDAgfHwgc2FtcGxlTGluZXNbc10gIT09IGNvbnRyb2xMaW5lc1tjXSkge1xuICAgICAgICAgICAgICAgIC8vIFY4IGFkZHMgYSBcIm5ld1wiIHByZWZpeCBmb3IgbmF0aXZlIGNsYXNzZXMuIExldCdzIHJlbW92ZSBpdCB0byBtYWtlIGl0IHByZXR0aWVyLlxuICAgICAgICAgICAgICAgIHZhciBfZnJhbWUgPSAnXFxuJyArIHNhbXBsZUxpbmVzW3NdLnJlcGxhY2UoJyBhdCBuZXcgJywgJyBhdCAnKTsgLy8gSWYgb3VyIGNvbXBvbmVudCBmcmFtZSBpcyBsYWJlbGVkIFwiPGFub255bW91cz5cIlxuICAgICAgICAgICAgICAgIC8vIGJ1dCB3ZSBoYXZlIGEgdXNlci1wcm92aWRlZCBcImRpc3BsYXlOYW1lXCJcbiAgICAgICAgICAgICAgICAvLyBzcGxpY2UgaXQgaW4gdG8gbWFrZSB0aGUgc3RhY2sgbW9yZSByZWFkYWJsZS5cblxuXG4gICAgICAgICAgICAgICAgaWYgKGZuLmRpc3BsYXlOYW1lICYmIF9mcmFtZS5pbmNsdWRlcygnPGFub255bW91cz4nKSkge1xuICAgICAgICAgICAgICAgICAgX2ZyYW1lID0gX2ZyYW1lLnJlcGxhY2UoJzxhbm9ueW1vdXM+JywgZm4uZGlzcGxheU5hbWUpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgZm4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICAgICAgY29tcG9uZW50RnJhbWVDYWNoZS5zZXQoZm4sIF9mcmFtZSk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSAvLyBSZXR1cm4gdGhlIGxpbmUgd2UgZm91bmQuXG5cblxuICAgICAgICAgICAgICAgIHJldHVybiBfZnJhbWU7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gd2hpbGUgKHMgPj0gMSAmJiBjID49IDApO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9IGZpbmFsbHkge1xuICAgIHJlZW50cnkgPSBmYWxzZTtcblxuICAgIHtcbiAgICAgIFJlYWN0Q3VycmVudERpc3BhdGNoZXIuY3VycmVudCA9IHByZXZpb3VzRGlzcGF0Y2hlcjtcbiAgICAgIHJlZW5hYmxlTG9ncygpO1xuICAgIH1cblxuICAgIEVycm9yLnByZXBhcmVTdGFja1RyYWNlID0gcHJldmlvdXNQcmVwYXJlU3RhY2tUcmFjZTtcbiAgfSAvLyBGYWxsYmFjayB0byBqdXN0IHVzaW5nIHRoZSBuYW1lIGlmIHdlIGNvdWxkbid0IG1ha2UgaXQgdGhyb3cuXG5cblxuICB2YXIgbmFtZSA9IGZuID8gZm4uZGlzcGxheU5hbWUgfHwgZm4ubmFtZSA6ICcnO1xuICB2YXIgc3ludGhldGljRnJhbWUgPSBuYW1lID8gZGVzY3JpYmVCdWlsdEluQ29tcG9uZW50RnJhbWUobmFtZSkgOiAnJztcblxuICB7XG4gICAgaWYgKHR5cGVvZiBmbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgY29tcG9uZW50RnJhbWVDYWNoZS5zZXQoZm4sIHN5bnRoZXRpY0ZyYW1lKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gc3ludGhldGljRnJhbWU7XG59XG5mdW5jdGlvbiBkZXNjcmliZUZ1bmN0aW9uQ29tcG9uZW50RnJhbWUoZm4sIHNvdXJjZSwgb3duZXJGbikge1xuICB7XG4gICAgcmV0dXJuIGRlc2NyaWJlTmF0aXZlQ29tcG9uZW50RnJhbWUoZm4sIGZhbHNlKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBzaG91bGRDb25zdHJ1Y3QoQ29tcG9uZW50KSB7XG4gIHZhciBwcm90b3R5cGUgPSBDb21wb25lbnQucHJvdG90eXBlO1xuICByZXR1cm4gISEocHJvdG90eXBlICYmIHByb3RvdHlwZS5pc1JlYWN0Q29tcG9uZW50KTtcbn1cblxuZnVuY3Rpb24gZGVzY3JpYmVVbmtub3duRWxlbWVudFR5cGVGcmFtZUluREVWKHR5cGUsIHNvdXJjZSwgb3duZXJGbikge1xuXG4gIGlmICh0eXBlID09IG51bGwpIHtcbiAgICByZXR1cm4gJyc7XG4gIH1cblxuICBpZiAodHlwZW9mIHR5cGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICB7XG4gICAgICByZXR1cm4gZGVzY3JpYmVOYXRpdmVDb21wb25lbnRGcmFtZSh0eXBlLCBzaG91bGRDb25zdHJ1Y3QodHlwZSkpO1xuICAgIH1cbiAgfVxuXG4gIGlmICh0eXBlb2YgdHlwZSA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gZGVzY3JpYmVCdWlsdEluQ29tcG9uZW50RnJhbWUodHlwZSk7XG4gIH1cblxuICBzd2l0Y2ggKHR5cGUpIHtcbiAgICBjYXNlIFJFQUNUX1NVU1BFTlNFX1RZUEU6XG4gICAgICByZXR1cm4gZGVzY3JpYmVCdWlsdEluQ29tcG9uZW50RnJhbWUoJ1N1c3BlbnNlJyk7XG5cbiAgICBjYXNlIFJFQUNUX1NVU1BFTlNFX0xJU1RfVFlQRTpcbiAgICAgIHJldHVybiBkZXNjcmliZUJ1aWx0SW5Db21wb25lbnRGcmFtZSgnU3VzcGVuc2VMaXN0Jyk7XG4gIH1cblxuICBpZiAodHlwZW9mIHR5cGUgPT09ICdvYmplY3QnKSB7XG4gICAgc3dpdGNoICh0eXBlLiQkdHlwZW9mKSB7XG4gICAgICBjYXNlIFJFQUNUX0ZPUldBUkRfUkVGX1RZUEU6XG4gICAgICAgIHJldHVybiBkZXNjcmliZUZ1bmN0aW9uQ29tcG9uZW50RnJhbWUodHlwZS5yZW5kZXIpO1xuXG4gICAgICBjYXNlIFJFQUNUX01FTU9fVFlQRTpcbiAgICAgICAgLy8gTWVtbyBtYXkgY29udGFpbiBhbnkgY29tcG9uZW50IHR5cGUgc28gd2UgcmVjdXJzaXZlbHkgcmVzb2x2ZSBpdC5cbiAgICAgICAgcmV0dXJuIGRlc2NyaWJlVW5rbm93bkVsZW1lbnRUeXBlRnJhbWVJbkRFVih0eXBlLnR5cGUsIHNvdXJjZSwgb3duZXJGbik7XG5cbiAgICAgIGNhc2UgUkVBQ1RfTEFaWV9UWVBFOlxuICAgICAgICB7XG4gICAgICAgICAgdmFyIGxhenlDb21wb25lbnQgPSB0eXBlO1xuICAgICAgICAgIHZhciBwYXlsb2FkID0gbGF6eUNvbXBvbmVudC5fcGF5bG9hZDtcbiAgICAgICAgICB2YXIgaW5pdCA9IGxhenlDb21wb25lbnQuX2luaXQ7XG5cbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gTGF6eSBtYXkgY29udGFpbiBhbnkgY29tcG9uZW50IHR5cGUgc28gd2UgcmVjdXJzaXZlbHkgcmVzb2x2ZSBpdC5cbiAgICAgICAgICAgIHJldHVybiBkZXNjcmliZVVua25vd25FbGVtZW50VHlwZUZyYW1lSW5ERVYoaW5pdChwYXlsb2FkKSwgc291cmNlLCBvd25lckZuKTtcbiAgICAgICAgICB9IGNhdGNoICh4KSB7fVxuICAgICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuICcnO1xufVxuXG52YXIgaGFzT3duUHJvcGVydHkgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xuXG52YXIgbG9nZ2VkVHlwZUZhaWx1cmVzID0ge307XG52YXIgUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZSA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLlJlYWN0RGVidWdDdXJyZW50RnJhbWU7XG5cbmZ1bmN0aW9uIHNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50KGVsZW1lbnQpIHtcbiAge1xuICAgIGlmIChlbGVtZW50KSB7XG4gICAgICB2YXIgb3duZXIgPSBlbGVtZW50Ll9vd25lcjtcbiAgICAgIHZhciBzdGFjayA9IGRlc2NyaWJlVW5rbm93bkVsZW1lbnRUeXBlRnJhbWVJbkRFVihlbGVtZW50LnR5cGUsIGVsZW1lbnQuX3NvdXJjZSwgb3duZXIgPyBvd25lci50eXBlIDogbnVsbCk7XG4gICAgICBSZWFjdERlYnVnQ3VycmVudEZyYW1lLnNldEV4dHJhU3RhY2tGcmFtZShzdGFjayk7XG4gICAgfSBlbHNlIHtcbiAgICAgIFJlYWN0RGVidWdDdXJyZW50RnJhbWUuc2V0RXh0cmFTdGFja0ZyYW1lKG51bGwpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBjaGVja1Byb3BUeXBlcyh0eXBlU3BlY3MsIHZhbHVlcywgbG9jYXRpb24sIGNvbXBvbmVudE5hbWUsIGVsZW1lbnQpIHtcbiAge1xuICAgIC8vICRGbG93Rml4TWUgVGhpcyBpcyBva2F5IGJ1dCBGbG93IGRvZXNuJ3Qga25vdyBpdC5cbiAgICB2YXIgaGFzID0gRnVuY3Rpb24uY2FsbC5iaW5kKGhhc093blByb3BlcnR5KTtcblxuICAgIGZvciAodmFyIHR5cGVTcGVjTmFtZSBpbiB0eXBlU3BlY3MpIHtcbiAgICAgIGlmIChoYXModHlwZVNwZWNzLCB0eXBlU3BlY05hbWUpKSB7XG4gICAgICAgIHZhciBlcnJvciQxID0gdm9pZCAwOyAvLyBQcm9wIHR5cGUgdmFsaWRhdGlvbiBtYXkgdGhyb3cuIEluIGNhc2UgdGhleSBkbywgd2UgZG9uJ3Qgd2FudCB0b1xuICAgICAgICAvLyBmYWlsIHRoZSByZW5kZXIgcGhhc2Ugd2hlcmUgaXQgZGlkbid0IGZhaWwgYmVmb3JlLiBTbyB3ZSBsb2cgaXQuXG4gICAgICAgIC8vIEFmdGVyIHRoZXNlIGhhdmUgYmVlbiBjbGVhbmVkIHVwLCB3ZSdsbCBsZXQgdGhlbSB0aHJvdy5cblxuICAgICAgICB0cnkge1xuICAgICAgICAgIC8vIFRoaXMgaXMgaW50ZW50aW9uYWxseSBhbiBpbnZhcmlhbnQgdGhhdCBnZXRzIGNhdWdodC4gSXQncyB0aGUgc2FtZVxuICAgICAgICAgIC8vIGJlaGF2aW9yIGFzIHdpdGhvdXQgdGhpcyBzdGF0ZW1lbnQgZXhjZXB0IHdpdGggYSBiZXR0ZXIgbWVzc2FnZS5cbiAgICAgICAgICBpZiAodHlwZW9mIHR5cGVTcGVjc1t0eXBlU3BlY05hbWVdICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaW50ZXJuYWwvcHJvZC1lcnJvci1jb2Rlc1xuICAgICAgICAgICAgdmFyIGVyciA9IEVycm9yKChjb21wb25lbnROYW1lIHx8ICdSZWFjdCBjbGFzcycpICsgJzogJyArIGxvY2F0aW9uICsgJyB0eXBlIGAnICsgdHlwZVNwZWNOYW1lICsgJ2AgaXMgaW52YWxpZDsgJyArICdpdCBtdXN0IGJlIGEgZnVuY3Rpb24sIHVzdWFsbHkgZnJvbSB0aGUgYHByb3AtdHlwZXNgIHBhY2thZ2UsIGJ1dCByZWNlaXZlZCBgJyArIHR5cGVvZiB0eXBlU3BlY3NbdHlwZVNwZWNOYW1lXSArICdgLicgKyAnVGhpcyBvZnRlbiBoYXBwZW5zIGJlY2F1c2Ugb2YgdHlwb3Mgc3VjaCBhcyBgUHJvcFR5cGVzLmZ1bmN0aW9uYCBpbnN0ZWFkIG9mIGBQcm9wVHlwZXMuZnVuY2AuJyk7XG4gICAgICAgICAgICBlcnIubmFtZSA9ICdJbnZhcmlhbnQgVmlvbGF0aW9uJztcbiAgICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBlcnJvciQxID0gdHlwZVNwZWNzW3R5cGVTcGVjTmFtZV0odmFsdWVzLCB0eXBlU3BlY05hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBudWxsLCAnU0VDUkVUX0RPX05PVF9QQVNTX1RISVNfT1JfWU9VX1dJTExfQkVfRklSRUQnKTtcbiAgICAgICAgfSBjYXRjaCAoZXgpIHtcbiAgICAgICAgICBlcnJvciQxID0gZXg7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZXJyb3IkMSAmJiAhKGVycm9yJDEgaW5zdGFuY2VvZiBFcnJvcikpIHtcbiAgICAgICAgICBzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudChlbGVtZW50KTtcblxuICAgICAgICAgIGVycm9yKCclczogdHlwZSBzcGVjaWZpY2F0aW9uIG9mICVzJyArICcgYCVzYCBpcyBpbnZhbGlkOyB0aGUgdHlwZSBjaGVja2VyICcgKyAnZnVuY3Rpb24gbXVzdCByZXR1cm4gYG51bGxgIG9yIGFuIGBFcnJvcmAgYnV0IHJldHVybmVkIGEgJXMuICcgKyAnWW91IG1heSBoYXZlIGZvcmdvdHRlbiB0byBwYXNzIGFuIGFyZ3VtZW50IHRvIHRoZSB0eXBlIGNoZWNrZXIgJyArICdjcmVhdG9yIChhcnJheU9mLCBpbnN0YW5jZU9mLCBvYmplY3RPZiwgb25lT2YsIG9uZU9mVHlwZSwgYW5kICcgKyAnc2hhcGUgYWxsIHJlcXVpcmUgYW4gYXJndW1lbnQpLicsIGNvbXBvbmVudE5hbWUgfHwgJ1JlYWN0IGNsYXNzJywgbG9jYXRpb24sIHR5cGVTcGVjTmFtZSwgdHlwZW9mIGVycm9yJDEpO1xuXG4gICAgICAgICAgc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQobnVsbCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZXJyb3IkMSBpbnN0YW5jZW9mIEVycm9yICYmICEoZXJyb3IkMS5tZXNzYWdlIGluIGxvZ2dlZFR5cGVGYWlsdXJlcykpIHtcbiAgICAgICAgICAvLyBPbmx5IG1vbml0b3IgdGhpcyBmYWlsdXJlIG9uY2UgYmVjYXVzZSB0aGVyZSB0ZW5kcyB0byBiZSBhIGxvdCBvZiB0aGVcbiAgICAgICAgICAvLyBzYW1lIGVycm9yLlxuICAgICAgICAgIGxvZ2dlZFR5cGVGYWlsdXJlc1tlcnJvciQxLm1lc3NhZ2VdID0gdHJ1ZTtcbiAgICAgICAgICBzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudChlbGVtZW50KTtcblxuICAgICAgICAgIGVycm9yKCdGYWlsZWQgJXMgdHlwZTogJXMnLCBsb2NhdGlvbiwgZXJyb3IkMS5tZXNzYWdlKTtcblxuICAgICAgICAgIHNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50KG51bGwpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbnZhciBpc0FycmF5SW1wbCA9IEFycmF5LmlzQXJyYXk7IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1yZWRlY2xhcmVcblxuZnVuY3Rpb24gaXNBcnJheShhKSB7XG4gIHJldHVybiBpc0FycmF5SW1wbChhKTtcbn1cblxuLypcbiAqIFRoZSBgJycgKyB2YWx1ZWAgcGF0dGVybiAodXNlZCBpbiBpbiBwZXJmLXNlbnNpdGl2ZSBjb2RlKSB0aHJvd3MgZm9yIFN5bWJvbFxuICogYW5kIFRlbXBvcmFsLiogdHlwZXMuIFNlZSBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvcHVsbC8yMjA2NC5cbiAqXG4gKiBUaGUgZnVuY3Rpb25zIGluIHRoaXMgbW9kdWxlIHdpbGwgdGhyb3cgYW4gZWFzaWVyLXRvLXVuZGVyc3RhbmQsXG4gKiBlYXNpZXItdG8tZGVidWcgZXhjZXB0aW9uIHdpdGggYSBjbGVhciBlcnJvcnMgbWVzc2FnZSBtZXNzYWdlIGV4cGxhaW5pbmcgdGhlXG4gKiBwcm9ibGVtLiAoSW5zdGVhZCBvZiBhIGNvbmZ1c2luZyBleGNlcHRpb24gdGhyb3duIGluc2lkZSB0aGUgaW1wbGVtZW50YXRpb25cbiAqIG9mIHRoZSBgdmFsdWVgIG9iamVjdCkuXG4gKi9cbi8vICRGbG93Rml4TWUgb25seSBjYWxsZWQgaW4gREVWLCBzbyB2b2lkIHJldHVybiBpcyBub3QgcG9zc2libGUuXG5mdW5jdGlvbiB0eXBlTmFtZSh2YWx1ZSkge1xuICB7XG4gICAgLy8gdG9TdHJpbmdUYWcgaXMgbmVlZGVkIGZvciBuYW1lc3BhY2VkIHR5cGVzIGxpa2UgVGVtcG9yYWwuSW5zdGFudFxuICAgIHZhciBoYXNUb1N0cmluZ1RhZyA9IHR5cGVvZiBTeW1ib2wgPT09ICdmdW5jdGlvbicgJiYgU3ltYm9sLnRvU3RyaW5nVGFnO1xuICAgIHZhciB0eXBlID0gaGFzVG9TdHJpbmdUYWcgJiYgdmFsdWVbU3ltYm9sLnRvU3RyaW5nVGFnXSB8fCB2YWx1ZS5jb25zdHJ1Y3Rvci5uYW1lIHx8ICdPYmplY3QnO1xuICAgIHJldHVybiB0eXBlO1xuICB9XG59IC8vICRGbG93Rml4TWUgb25seSBjYWxsZWQgaW4gREVWLCBzbyB2b2lkIHJldHVybiBpcyBub3QgcG9zc2libGUuXG5cblxuZnVuY3Rpb24gd2lsbENvZXJjaW9uVGhyb3codmFsdWUpIHtcbiAge1xuICAgIHRyeSB7XG4gICAgICB0ZXN0U3RyaW5nQ29lcmNpb24odmFsdWUpO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiB0ZXN0U3RyaW5nQ29lcmNpb24odmFsdWUpIHtcbiAgLy8gSWYgeW91IGVuZGVkIHVwIGhlcmUgYnkgZm9sbG93aW5nIGFuIGV4Y2VwdGlvbiBjYWxsIHN0YWNrLCBoZXJlJ3Mgd2hhdCdzXG4gIC8vIGhhcHBlbmVkOiB5b3Ugc3VwcGxpZWQgYW4gb2JqZWN0IG9yIHN5bWJvbCB2YWx1ZSB0byBSZWFjdCAoYXMgYSBwcm9wLCBrZXksXG4gIC8vIERPTSBhdHRyaWJ1dGUsIENTUyBwcm9wZXJ0eSwgc3RyaW5nIHJlZiwgZXRjLikgYW5kIHdoZW4gUmVhY3QgdHJpZWQgdG9cbiAgLy8gY29lcmNlIGl0IHRvIGEgc3RyaW5nIHVzaW5nIGAnJyArIHZhbHVlYCwgYW4gZXhjZXB0aW9uIHdhcyB0aHJvd24uXG4gIC8vXG4gIC8vIFRoZSBtb3N0IGNvbW1vbiB0eXBlcyB0aGF0IHdpbGwgY2F1c2UgdGhpcyBleGNlcHRpb24gYXJlIGBTeW1ib2xgIGluc3RhbmNlc1xuICAvLyBhbmQgVGVtcG9yYWwgb2JqZWN0cyBsaWtlIGBUZW1wb3JhbC5JbnN0YW50YC4gQnV0IGFueSBvYmplY3QgdGhhdCBoYXMgYVxuICAvLyBgdmFsdWVPZmAgb3IgYFtTeW1ib2wudG9QcmltaXRpdmVdYCBtZXRob2QgdGhhdCB0aHJvd3Mgd2lsbCBhbHNvIGNhdXNlIHRoaXNcbiAgLy8gZXhjZXB0aW9uLiAoTGlicmFyeSBhdXRob3JzIGRvIHRoaXMgdG8gcHJldmVudCB1c2VycyBmcm9tIHVzaW5nIGJ1aWx0LWluXG4gIC8vIG51bWVyaWMgb3BlcmF0b3JzIGxpa2UgYCtgIG9yIGNvbXBhcmlzb24gb3BlcmF0b3JzIGxpa2UgYD49YCBiZWNhdXNlIGN1c3RvbVxuICAvLyBtZXRob2RzIGFyZSBuZWVkZWQgdG8gcGVyZm9ybSBhY2N1cmF0ZSBhcml0aG1ldGljIG9yIGNvbXBhcmlzb24uKVxuICAvL1xuICAvLyBUbyBmaXggdGhlIHByb2JsZW0sIGNvZXJjZSB0aGlzIG9iamVjdCBvciBzeW1ib2wgdmFsdWUgdG8gYSBzdHJpbmcgYmVmb3JlXG4gIC8vIHBhc3NpbmcgaXQgdG8gUmVhY3QuIFRoZSBtb3N0IHJlbGlhYmxlIHdheSBpcyB1c3VhbGx5IGBTdHJpbmcodmFsdWUpYC5cbiAgLy9cbiAgLy8gVG8gZmluZCB3aGljaCB2YWx1ZSBpcyB0aHJvd2luZywgY2hlY2sgdGhlIGJyb3dzZXIgb3IgZGVidWdnZXIgY29uc29sZS5cbiAgLy8gQmVmb3JlIHRoaXMgZXhjZXB0aW9uIHdhcyB0aHJvd24sIHRoZXJlIHNob3VsZCBiZSBgY29uc29sZS5lcnJvcmAgb3V0cHV0XG4gIC8vIHRoYXQgc2hvd3MgdGhlIHR5cGUgKFN5bWJvbCwgVGVtcG9yYWwuUGxhaW5EYXRlLCBldGMuKSB0aGF0IGNhdXNlZCB0aGVcbiAgLy8gcHJvYmxlbSBhbmQgaG93IHRoYXQgdHlwZSB3YXMgdXNlZDoga2V5LCBhdHJyaWJ1dGUsIGlucHV0IHZhbHVlIHByb3AsIGV0Yy5cbiAgLy8gSW4gbW9zdCBjYXNlcywgdGhpcyBjb25zb2xlIG91dHB1dCBhbHNvIHNob3dzIHRoZSBjb21wb25lbnQgYW5kIGl0c1xuICAvLyBhbmNlc3RvciBjb21wb25lbnRzIHdoZXJlIHRoZSBleGNlcHRpb24gaGFwcGVuZWQuXG4gIC8vXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1pbnRlcm5hbC9zYWZlLXN0cmluZy1jb2VyY2lvblxuICByZXR1cm4gJycgKyB2YWx1ZTtcbn1cbmZ1bmN0aW9uIGNoZWNrS2V5U3RyaW5nQ29lcmNpb24odmFsdWUpIHtcbiAge1xuICAgIGlmICh3aWxsQ29lcmNpb25UaHJvdyh2YWx1ZSkpIHtcbiAgICAgIGVycm9yKCdUaGUgcHJvdmlkZWQga2V5IGlzIGFuIHVuc3VwcG9ydGVkIHR5cGUgJXMuJyArICcgVGhpcyB2YWx1ZSBtdXN0IGJlIGNvZXJjZWQgdG8gYSBzdHJpbmcgYmVmb3JlIGJlZm9yZSB1c2luZyBpdCBoZXJlLicsIHR5cGVOYW1lKHZhbHVlKSk7XG5cbiAgICAgIHJldHVybiB0ZXN0U3RyaW5nQ29lcmNpb24odmFsdWUpOyAvLyB0aHJvdyAodG8gaGVscCBjYWxsZXJzIGZpbmQgdHJvdWJsZXNob290aW5nIGNvbW1lbnRzKVxuICAgIH1cbiAgfVxufVxuXG52YXIgUmVhY3RDdXJyZW50T3duZXIgPSBSZWFjdFNoYXJlZEludGVybmFscy5SZWFjdEN1cnJlbnRPd25lcjtcbnZhciBSRVNFUlZFRF9QUk9QUyA9IHtcbiAga2V5OiB0cnVlLFxuICByZWY6IHRydWUsXG4gIF9fc2VsZjogdHJ1ZSxcbiAgX19zb3VyY2U6IHRydWVcbn07XG52YXIgc3BlY2lhbFByb3BLZXlXYXJuaW5nU2hvd247XG52YXIgc3BlY2lhbFByb3BSZWZXYXJuaW5nU2hvd247XG52YXIgZGlkV2FybkFib3V0U3RyaW5nUmVmcztcblxue1xuICBkaWRXYXJuQWJvdXRTdHJpbmdSZWZzID0ge307XG59XG5cbmZ1bmN0aW9uIGhhc1ZhbGlkUmVmKGNvbmZpZykge1xuICB7XG4gICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwoY29uZmlnLCAncmVmJykpIHtcbiAgICAgIHZhciBnZXR0ZXIgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGNvbmZpZywgJ3JlZicpLmdldDtcblxuICAgICAgaWYgKGdldHRlciAmJiBnZXR0ZXIuaXNSZWFjdFdhcm5pbmcpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBjb25maWcucmVmICE9PSB1bmRlZmluZWQ7XG59XG5cbmZ1bmN0aW9uIGhhc1ZhbGlkS2V5KGNvbmZpZykge1xuICB7XG4gICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwoY29uZmlnLCAna2V5JykpIHtcbiAgICAgIHZhciBnZXR0ZXIgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGNvbmZpZywgJ2tleScpLmdldDtcblxuICAgICAgaWYgKGdldHRlciAmJiBnZXR0ZXIuaXNSZWFjdFdhcm5pbmcpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBjb25maWcua2V5ICE9PSB1bmRlZmluZWQ7XG59XG5cbmZ1bmN0aW9uIHdhcm5JZlN0cmluZ1JlZkNhbm5vdEJlQXV0b0NvbnZlcnRlZChjb25maWcsIHNlbGYpIHtcbiAge1xuICAgIGlmICh0eXBlb2YgY29uZmlnLnJlZiA9PT0gJ3N0cmluZycgJiYgUmVhY3RDdXJyZW50T3duZXIuY3VycmVudCAmJiBzZWxmICYmIFJlYWN0Q3VycmVudE93bmVyLmN1cnJlbnQuc3RhdGVOb2RlICE9PSBzZWxmKSB7XG4gICAgICB2YXIgY29tcG9uZW50TmFtZSA9IGdldENvbXBvbmVudE5hbWVGcm9tVHlwZShSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50LnR5cGUpO1xuXG4gICAgICBpZiAoIWRpZFdhcm5BYm91dFN0cmluZ1JlZnNbY29tcG9uZW50TmFtZV0pIHtcbiAgICAgICAgZXJyb3IoJ0NvbXBvbmVudCBcIiVzXCIgY29udGFpbnMgdGhlIHN0cmluZyByZWYgXCIlc1wiLiAnICsgJ1N1cHBvcnQgZm9yIHN0cmluZyByZWZzIHdpbGwgYmUgcmVtb3ZlZCBpbiBhIGZ1dHVyZSBtYWpvciByZWxlYXNlLiAnICsgJ1RoaXMgY2FzZSBjYW5ub3QgYmUgYXV0b21hdGljYWxseSBjb252ZXJ0ZWQgdG8gYW4gYXJyb3cgZnVuY3Rpb24uICcgKyAnV2UgYXNrIHlvdSB0byBtYW51YWxseSBmaXggdGhpcyBjYXNlIGJ5IHVzaW5nIHVzZVJlZigpIG9yIGNyZWF0ZVJlZigpIGluc3RlYWQuICcgKyAnTGVhcm4gbW9yZSBhYm91dCB1c2luZyByZWZzIHNhZmVseSBoZXJlOiAnICsgJ2h0dHBzOi8vcmVhY3Rqcy5vcmcvbGluay9zdHJpY3QtbW9kZS1zdHJpbmctcmVmJywgZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKFJlYWN0Q3VycmVudE93bmVyLmN1cnJlbnQudHlwZSksIGNvbmZpZy5yZWYpO1xuXG4gICAgICAgIGRpZFdhcm5BYm91dFN0cmluZ1JlZnNbY29tcG9uZW50TmFtZV0gPSB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBkZWZpbmVLZXlQcm9wV2FybmluZ0dldHRlcihwcm9wcywgZGlzcGxheU5hbWUpIHtcbiAge1xuICAgIHZhciB3YXJuQWJvdXRBY2Nlc3NpbmdLZXkgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAoIXNwZWNpYWxQcm9wS2V5V2FybmluZ1Nob3duKSB7XG4gICAgICAgIHNwZWNpYWxQcm9wS2V5V2FybmluZ1Nob3duID0gdHJ1ZTtcblxuICAgICAgICBlcnJvcignJXM6IGBrZXlgIGlzIG5vdCBhIHByb3AuIFRyeWluZyB0byBhY2Nlc3MgaXQgd2lsbCByZXN1bHQgJyArICdpbiBgdW5kZWZpbmVkYCBiZWluZyByZXR1cm5lZC4gSWYgeW91IG5lZWQgdG8gYWNjZXNzIHRoZSBzYW1lICcgKyAndmFsdWUgd2l0aGluIHRoZSBjaGlsZCBjb21wb25lbnQsIHlvdSBzaG91bGQgcGFzcyBpdCBhcyBhIGRpZmZlcmVudCAnICsgJ3Byb3AuIChodHRwczovL3JlYWN0anMub3JnL2xpbmsvc3BlY2lhbC1wcm9wcyknLCBkaXNwbGF5TmFtZSk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIHdhcm5BYm91dEFjY2Vzc2luZ0tleS5pc1JlYWN0V2FybmluZyA9IHRydWU7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHByb3BzLCAna2V5Jywge1xuICAgICAgZ2V0OiB3YXJuQWJvdXRBY2Nlc3NpbmdLZXksXG4gICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgfVxufVxuXG5mdW5jdGlvbiBkZWZpbmVSZWZQcm9wV2FybmluZ0dldHRlcihwcm9wcywgZGlzcGxheU5hbWUpIHtcbiAge1xuICAgIHZhciB3YXJuQWJvdXRBY2Nlc3NpbmdSZWYgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAoIXNwZWNpYWxQcm9wUmVmV2FybmluZ1Nob3duKSB7XG4gICAgICAgIHNwZWNpYWxQcm9wUmVmV2FybmluZ1Nob3duID0gdHJ1ZTtcblxuICAgICAgICBlcnJvcignJXM6IGByZWZgIGlzIG5vdCBhIHByb3AuIFRyeWluZyB0byBhY2Nlc3MgaXQgd2lsbCByZXN1bHQgJyArICdpbiBgdW5kZWZpbmVkYCBiZWluZyByZXR1cm5lZC4gSWYgeW91IG5lZWQgdG8gYWNjZXNzIHRoZSBzYW1lICcgKyAndmFsdWUgd2l0aGluIHRoZSBjaGlsZCBjb21wb25lbnQsIHlvdSBzaG91bGQgcGFzcyBpdCBhcyBhIGRpZmZlcmVudCAnICsgJ3Byb3AuIChodHRwczovL3JlYWN0anMub3JnL2xpbmsvc3BlY2lhbC1wcm9wcyknLCBkaXNwbGF5TmFtZSk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIHdhcm5BYm91dEFjY2Vzc2luZ1JlZi5pc1JlYWN0V2FybmluZyA9IHRydWU7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHByb3BzLCAncmVmJywge1xuICAgICAgZ2V0OiB3YXJuQWJvdXRBY2Nlc3NpbmdSZWYsXG4gICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgfVxufVxuLyoqXG4gKiBGYWN0b3J5IG1ldGhvZCB0byBjcmVhdGUgYSBuZXcgUmVhY3QgZWxlbWVudC4gVGhpcyBubyBsb25nZXIgYWRoZXJlcyB0b1xuICogdGhlIGNsYXNzIHBhdHRlcm4sIHNvIGRvIG5vdCB1c2UgbmV3IHRvIGNhbGwgaXQuIEFsc28sIGluc3RhbmNlb2YgY2hlY2tcbiAqIHdpbGwgbm90IHdvcmsuIEluc3RlYWQgdGVzdCAkJHR5cGVvZiBmaWVsZCBhZ2FpbnN0IFN5bWJvbC5mb3IoJ3JlYWN0LmVsZW1lbnQnKSB0byBjaGVja1xuICogaWYgc29tZXRoaW5nIGlzIGEgUmVhY3QgRWxlbWVudC5cbiAqXG4gKiBAcGFyYW0geyp9IHR5cGVcbiAqIEBwYXJhbSB7Kn0gcHJvcHNcbiAqIEBwYXJhbSB7Kn0ga2V5XG4gKiBAcGFyYW0ge3N0cmluZ3xvYmplY3R9IHJlZlxuICogQHBhcmFtIHsqfSBvd25lclxuICogQHBhcmFtIHsqfSBzZWxmIEEgKnRlbXBvcmFyeSogaGVscGVyIHRvIGRldGVjdCBwbGFjZXMgd2hlcmUgYHRoaXNgIGlzXG4gKiBkaWZmZXJlbnQgZnJvbSB0aGUgYG93bmVyYCB3aGVuIFJlYWN0LmNyZWF0ZUVsZW1lbnQgaXMgY2FsbGVkLCBzbyB0aGF0IHdlXG4gKiBjYW4gd2Fybi4gV2Ugd2FudCB0byBnZXQgcmlkIG9mIG93bmVyIGFuZCByZXBsYWNlIHN0cmluZyBgcmVmYHMgd2l0aCBhcnJvd1xuICogZnVuY3Rpb25zLCBhbmQgYXMgbG9uZyBhcyBgdGhpc2AgYW5kIG93bmVyIGFyZSB0aGUgc2FtZSwgdGhlcmUgd2lsbCBiZSBub1xuICogY2hhbmdlIGluIGJlaGF2aW9yLlxuICogQHBhcmFtIHsqfSBzb3VyY2UgQW4gYW5ub3RhdGlvbiBvYmplY3QgKGFkZGVkIGJ5IGEgdHJhbnNwaWxlciBvciBvdGhlcndpc2UpXG4gKiBpbmRpY2F0aW5nIGZpbGVuYW1lLCBsaW5lIG51bWJlciwgYW5kL29yIG90aGVyIGluZm9ybWF0aW9uLlxuICogQGludGVybmFsXG4gKi9cblxuXG52YXIgUmVhY3RFbGVtZW50ID0gZnVuY3Rpb24gKHR5cGUsIGtleSwgcmVmLCBzZWxmLCBzb3VyY2UsIG93bmVyLCBwcm9wcykge1xuICB2YXIgZWxlbWVudCA9IHtcbiAgICAvLyBUaGlzIHRhZyBhbGxvd3MgdXMgdG8gdW5pcXVlbHkgaWRlbnRpZnkgdGhpcyBhcyBhIFJlYWN0IEVsZW1lbnRcbiAgICAkJHR5cGVvZjogUkVBQ1RfRUxFTUVOVF9UWVBFLFxuICAgIC8vIEJ1aWx0LWluIHByb3BlcnRpZXMgdGhhdCBiZWxvbmcgb24gdGhlIGVsZW1lbnRcbiAgICB0eXBlOiB0eXBlLFxuICAgIGtleToga2V5LFxuICAgIHJlZjogcmVmLFxuICAgIHByb3BzOiBwcm9wcyxcbiAgICAvLyBSZWNvcmQgdGhlIGNvbXBvbmVudCByZXNwb25zaWJsZSBmb3IgY3JlYXRpbmcgdGhpcyBlbGVtZW50LlxuICAgIF9vd25lcjogb3duZXJcbiAgfTtcblxuICB7XG4gICAgLy8gVGhlIHZhbGlkYXRpb24gZmxhZyBpcyBjdXJyZW50bHkgbXV0YXRpdmUuIFdlIHB1dCBpdCBvblxuICAgIC8vIGFuIGV4dGVybmFsIGJhY2tpbmcgc3RvcmUgc28gdGhhdCB3ZSBjYW4gZnJlZXplIHRoZSB3aG9sZSBvYmplY3QuXG4gICAgLy8gVGhpcyBjYW4gYmUgcmVwbGFjZWQgd2l0aCBhIFdlYWtNYXAgb25jZSB0aGV5IGFyZSBpbXBsZW1lbnRlZCBpblxuICAgIC8vIGNvbW1vbmx5IHVzZWQgZGV2ZWxvcG1lbnQgZW52aXJvbm1lbnRzLlxuICAgIGVsZW1lbnQuX3N0b3JlID0ge307IC8vIFRvIG1ha2UgY29tcGFyaW5nIFJlYWN0RWxlbWVudHMgZWFzaWVyIGZvciB0ZXN0aW5nIHB1cnBvc2VzLCB3ZSBtYWtlXG4gICAgLy8gdGhlIHZhbGlkYXRpb24gZmxhZyBub24tZW51bWVyYWJsZSAod2hlcmUgcG9zc2libGUsIHdoaWNoIHNob3VsZFxuICAgIC8vIGluY2x1ZGUgZXZlcnkgZW52aXJvbm1lbnQgd2UgcnVuIHRlc3RzIGluKSwgc28gdGhlIHRlc3QgZnJhbWV3b3JrXG4gICAgLy8gaWdub3JlcyBpdC5cblxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlbGVtZW50Ll9zdG9yZSwgJ3ZhbGlkYXRlZCcsIHtcbiAgICAgIGNvbmZpZ3VyYWJsZTogZmFsc2UsXG4gICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgdmFsdWU6IGZhbHNlXG4gICAgfSk7IC8vIHNlbGYgYW5kIHNvdXJjZSBhcmUgREVWIG9ubHkgcHJvcGVydGllcy5cblxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlbGVtZW50LCAnX3NlbGYnLCB7XG4gICAgICBjb25maWd1cmFibGU6IGZhbHNlLFxuICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICB3cml0YWJsZTogZmFsc2UsXG4gICAgICB2YWx1ZTogc2VsZlxuICAgIH0pOyAvLyBUd28gZWxlbWVudHMgY3JlYXRlZCBpbiB0d28gZGlmZmVyZW50IHBsYWNlcyBzaG91bGQgYmUgY29uc2lkZXJlZFxuICAgIC8vIGVxdWFsIGZvciB0ZXN0aW5nIHB1cnBvc2VzIGFuZCB0aGVyZWZvcmUgd2UgaGlkZSBpdCBmcm9tIGVudW1lcmF0aW9uLlxuXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGVsZW1lbnQsICdfc291cmNlJywge1xuICAgICAgY29uZmlndXJhYmxlOiBmYWxzZSxcbiAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgd3JpdGFibGU6IGZhbHNlLFxuICAgICAgdmFsdWU6IHNvdXJjZVxuICAgIH0pO1xuXG4gICAgaWYgKE9iamVjdC5mcmVlemUpIHtcbiAgICAgIE9iamVjdC5mcmVlemUoZWxlbWVudC5wcm9wcyk7XG4gICAgICBPYmplY3QuZnJlZXplKGVsZW1lbnQpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBlbGVtZW50O1xufTtcbi8qKlxuICogaHR0cHM6Ly9naXRodWIuY29tL3JlYWN0anMvcmZjcy9wdWxsLzEwN1xuICogQHBhcmFtIHsqfSB0eXBlXG4gKiBAcGFyYW0ge29iamVjdH0gcHJvcHNcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXlcbiAqL1xuXG5mdW5jdGlvbiBqc3hERVYodHlwZSwgY29uZmlnLCBtYXliZUtleSwgc291cmNlLCBzZWxmKSB7XG4gIHtcbiAgICB2YXIgcHJvcE5hbWU7IC8vIFJlc2VydmVkIG5hbWVzIGFyZSBleHRyYWN0ZWRcblxuICAgIHZhciBwcm9wcyA9IHt9O1xuICAgIHZhciBrZXkgPSBudWxsO1xuICAgIHZhciByZWYgPSBudWxsOyAvLyBDdXJyZW50bHksIGtleSBjYW4gYmUgc3ByZWFkIGluIGFzIGEgcHJvcC4gVGhpcyBjYXVzZXMgYSBwb3RlbnRpYWxcbiAgICAvLyBpc3N1ZSBpZiBrZXkgaXMgYWxzbyBleHBsaWNpdGx5IGRlY2xhcmVkIChpZS4gPGRpdiB7Li4ucHJvcHN9IGtleT1cIkhpXCIgLz5cbiAgICAvLyBvciA8ZGl2IGtleT1cIkhpXCIgey4uLnByb3BzfSAvPiApLiBXZSB3YW50IHRvIGRlcHJlY2F0ZSBrZXkgc3ByZWFkLFxuICAgIC8vIGJ1dCBhcyBhbiBpbnRlcm1lZGlhcnkgc3RlcCwgd2Ugd2lsbCB1c2UganN4REVWIGZvciBldmVyeXRoaW5nIGV4Y2VwdFxuICAgIC8vIDxkaXYgey4uLnByb3BzfSBrZXk9XCJIaVwiIC8+LCBiZWNhdXNlIHdlIGFyZW4ndCBjdXJyZW50bHkgYWJsZSB0byB0ZWxsIGlmXG4gICAgLy8ga2V5IGlzIGV4cGxpY2l0bHkgZGVjbGFyZWQgdG8gYmUgdW5kZWZpbmVkIG9yIG5vdC5cblxuICAgIGlmIChtYXliZUtleSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICB7XG4gICAgICAgIGNoZWNrS2V5U3RyaW5nQ29lcmNpb24obWF5YmVLZXkpO1xuICAgICAgfVxuXG4gICAgICBrZXkgPSAnJyArIG1heWJlS2V5O1xuICAgIH1cblxuICAgIGlmIChoYXNWYWxpZEtleShjb25maWcpKSB7XG4gICAgICB7XG4gICAgICAgIGNoZWNrS2V5U3RyaW5nQ29lcmNpb24oY29uZmlnLmtleSk7XG4gICAgICB9XG5cbiAgICAgIGtleSA9ICcnICsgY29uZmlnLmtleTtcbiAgICB9XG5cbiAgICBpZiAoaGFzVmFsaWRSZWYoY29uZmlnKSkge1xuICAgICAgcmVmID0gY29uZmlnLnJlZjtcbiAgICAgIHdhcm5JZlN0cmluZ1JlZkNhbm5vdEJlQXV0b0NvbnZlcnRlZChjb25maWcsIHNlbGYpO1xuICAgIH0gLy8gUmVtYWluaW5nIHByb3BlcnRpZXMgYXJlIGFkZGVkIHRvIGEgbmV3IHByb3BzIG9iamVjdFxuXG5cbiAgICBmb3IgKHByb3BOYW1lIGluIGNvbmZpZykge1xuICAgICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwoY29uZmlnLCBwcm9wTmFtZSkgJiYgIVJFU0VSVkVEX1BST1BTLmhhc093blByb3BlcnR5KHByb3BOYW1lKSkge1xuICAgICAgICBwcm9wc1twcm9wTmFtZV0gPSBjb25maWdbcHJvcE5hbWVdO1xuICAgICAgfVxuICAgIH0gLy8gUmVzb2x2ZSBkZWZhdWx0IHByb3BzXG5cblxuICAgIGlmICh0eXBlICYmIHR5cGUuZGVmYXVsdFByb3BzKSB7XG4gICAgICB2YXIgZGVmYXVsdFByb3BzID0gdHlwZS5kZWZhdWx0UHJvcHM7XG5cbiAgICAgIGZvciAocHJvcE5hbWUgaW4gZGVmYXVsdFByb3BzKSB7XG4gICAgICAgIGlmIChwcm9wc1twcm9wTmFtZV0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHByb3BzW3Byb3BOYW1lXSA9IGRlZmF1bHRQcm9wc1twcm9wTmFtZV07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoa2V5IHx8IHJlZikge1xuICAgICAgdmFyIGRpc3BsYXlOYW1lID0gdHlwZW9mIHR5cGUgPT09ICdmdW5jdGlvbicgPyB0eXBlLmRpc3BsYXlOYW1lIHx8IHR5cGUubmFtZSB8fCAnVW5rbm93bicgOiB0eXBlO1xuXG4gICAgICBpZiAoa2V5KSB7XG4gICAgICAgIGRlZmluZUtleVByb3BXYXJuaW5nR2V0dGVyKHByb3BzLCBkaXNwbGF5TmFtZSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChyZWYpIHtcbiAgICAgICAgZGVmaW5lUmVmUHJvcFdhcm5pbmdHZXR0ZXIocHJvcHMsIGRpc3BsYXlOYW1lKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gUmVhY3RFbGVtZW50KHR5cGUsIGtleSwgcmVmLCBzZWxmLCBzb3VyY2UsIFJlYWN0Q3VycmVudE93bmVyLmN1cnJlbnQsIHByb3BzKTtcbiAgfVxufVxuXG52YXIgUmVhY3RDdXJyZW50T3duZXIkMSA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLlJlYWN0Q3VycmVudE93bmVyO1xudmFyIFJlYWN0RGVidWdDdXJyZW50RnJhbWUkMSA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLlJlYWN0RGVidWdDdXJyZW50RnJhbWU7XG5cbmZ1bmN0aW9uIHNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50JDEoZWxlbWVudCkge1xuICB7XG4gICAgaWYgKGVsZW1lbnQpIHtcbiAgICAgIHZhciBvd25lciA9IGVsZW1lbnQuX293bmVyO1xuICAgICAgdmFyIHN0YWNrID0gZGVzY3JpYmVVbmtub3duRWxlbWVudFR5cGVGcmFtZUluREVWKGVsZW1lbnQudHlwZSwgZWxlbWVudC5fc291cmNlLCBvd25lciA/IG93bmVyLnR5cGUgOiBudWxsKTtcbiAgICAgIFJlYWN0RGVidWdDdXJyZW50RnJhbWUkMS5zZXRFeHRyYVN0YWNrRnJhbWUoc3RhY2spO1xuICAgIH0gZWxzZSB7XG4gICAgICBSZWFjdERlYnVnQ3VycmVudEZyYW1lJDEuc2V0RXh0cmFTdGFja0ZyYW1lKG51bGwpO1xuICAgIH1cbiAgfVxufVxuXG52YXIgcHJvcFR5cGVzTWlzc3BlbGxXYXJuaW5nU2hvd247XG5cbntcbiAgcHJvcFR5cGVzTWlzc3BlbGxXYXJuaW5nU2hvd24gPSBmYWxzZTtcbn1cbi8qKlxuICogVmVyaWZpZXMgdGhlIG9iamVjdCBpcyBhIFJlYWN0RWxlbWVudC5cbiAqIFNlZSBodHRwczovL3JlYWN0anMub3JnL2RvY3MvcmVhY3QtYXBpLmh0bWwjaXN2YWxpZGVsZW1lbnRcbiAqIEBwYXJhbSB7P29iamVjdH0gb2JqZWN0XG4gKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIGBvYmplY3RgIGlzIGEgUmVhY3RFbGVtZW50LlxuICogQGZpbmFsXG4gKi9cblxuXG5mdW5jdGlvbiBpc1ZhbGlkRWxlbWVudChvYmplY3QpIHtcbiAge1xuICAgIHJldHVybiB0eXBlb2Ygb2JqZWN0ID09PSAnb2JqZWN0JyAmJiBvYmplY3QgIT09IG51bGwgJiYgb2JqZWN0LiQkdHlwZW9mID09PSBSRUFDVF9FTEVNRU5UX1RZUEU7XG4gIH1cbn1cblxuZnVuY3Rpb24gZ2V0RGVjbGFyYXRpb25FcnJvckFkZGVuZHVtKCkge1xuICB7XG4gICAgaWYgKFJlYWN0Q3VycmVudE93bmVyJDEuY3VycmVudCkge1xuICAgICAgdmFyIG5hbWUgPSBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUoUmVhY3RDdXJyZW50T3duZXIkMS5jdXJyZW50LnR5cGUpO1xuXG4gICAgICBpZiAobmFtZSkge1xuICAgICAgICByZXR1cm4gJ1xcblxcbkNoZWNrIHRoZSByZW5kZXIgbWV0aG9kIG9mIGAnICsgbmFtZSArICdgLic7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuICcnO1xuICB9XG59XG5cbmZ1bmN0aW9uIGdldFNvdXJjZUluZm9FcnJvckFkZGVuZHVtKHNvdXJjZSkge1xuICB7XG4gICAgaWYgKHNvdXJjZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICB2YXIgZmlsZU5hbWUgPSBzb3VyY2UuZmlsZU5hbWUucmVwbGFjZSgvXi4qW1xcXFxcXC9dLywgJycpO1xuICAgICAgdmFyIGxpbmVOdW1iZXIgPSBzb3VyY2UubGluZU51bWJlcjtcbiAgICAgIHJldHVybiAnXFxuXFxuQ2hlY2sgeW91ciBjb2RlIGF0ICcgKyBmaWxlTmFtZSArICc6JyArIGxpbmVOdW1iZXIgKyAnLic7XG4gICAgfVxuXG4gICAgcmV0dXJuICcnO1xuICB9XG59XG4vKipcbiAqIFdhcm4gaWYgdGhlcmUncyBubyBrZXkgZXhwbGljaXRseSBzZXQgb24gZHluYW1pYyBhcnJheXMgb2YgY2hpbGRyZW4gb3JcbiAqIG9iamVjdCBrZXlzIGFyZSBub3QgdmFsaWQuIFRoaXMgYWxsb3dzIHVzIHRvIGtlZXAgdHJhY2sgb2YgY2hpbGRyZW4gYmV0d2VlblxuICogdXBkYXRlcy5cbiAqL1xuXG5cbnZhciBvd25lckhhc0tleVVzZVdhcm5pbmcgPSB7fTtcblxuZnVuY3Rpb24gZ2V0Q3VycmVudENvbXBvbmVudEVycm9ySW5mbyhwYXJlbnRUeXBlKSB7XG4gIHtcbiAgICB2YXIgaW5mbyA9IGdldERlY2xhcmF0aW9uRXJyb3JBZGRlbmR1bSgpO1xuXG4gICAgaWYgKCFpbmZvKSB7XG4gICAgICB2YXIgcGFyZW50TmFtZSA9IHR5cGVvZiBwYXJlbnRUeXBlID09PSAnc3RyaW5nJyA/IHBhcmVudFR5cGUgOiBwYXJlbnRUeXBlLmRpc3BsYXlOYW1lIHx8IHBhcmVudFR5cGUubmFtZTtcblxuICAgICAgaWYgKHBhcmVudE5hbWUpIHtcbiAgICAgICAgaW5mbyA9IFwiXFxuXFxuQ2hlY2sgdGhlIHRvcC1sZXZlbCByZW5kZXIgY2FsbCB1c2luZyA8XCIgKyBwYXJlbnROYW1lICsgXCI+LlwiO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBpbmZvO1xuICB9XG59XG4vKipcbiAqIFdhcm4gaWYgdGhlIGVsZW1lbnQgZG9lc24ndCBoYXZlIGFuIGV4cGxpY2l0IGtleSBhc3NpZ25lZCB0byBpdC5cbiAqIFRoaXMgZWxlbWVudCBpcyBpbiBhbiBhcnJheS4gVGhlIGFycmF5IGNvdWxkIGdyb3cgYW5kIHNocmluayBvciBiZVxuICogcmVvcmRlcmVkLiBBbGwgY2hpbGRyZW4gdGhhdCBoYXZlbid0IGFscmVhZHkgYmVlbiB2YWxpZGF0ZWQgYXJlIHJlcXVpcmVkIHRvXG4gKiBoYXZlIGEgXCJrZXlcIiBwcm9wZXJ0eSBhc3NpZ25lZCB0byBpdC4gRXJyb3Igc3RhdHVzZXMgYXJlIGNhY2hlZCBzbyBhIHdhcm5pbmdcbiAqIHdpbGwgb25seSBiZSBzaG93biBvbmNlLlxuICpcbiAqIEBpbnRlcm5hbFxuICogQHBhcmFtIHtSZWFjdEVsZW1lbnR9IGVsZW1lbnQgRWxlbWVudCB0aGF0IHJlcXVpcmVzIGEga2V5LlxuICogQHBhcmFtIHsqfSBwYXJlbnRUeXBlIGVsZW1lbnQncyBwYXJlbnQncyB0eXBlLlxuICovXG5cblxuZnVuY3Rpb24gdmFsaWRhdGVFeHBsaWNpdEtleShlbGVtZW50LCBwYXJlbnRUeXBlKSB7XG4gIHtcbiAgICBpZiAoIWVsZW1lbnQuX3N0b3JlIHx8IGVsZW1lbnQuX3N0b3JlLnZhbGlkYXRlZCB8fCBlbGVtZW50LmtleSAhPSBudWxsKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgZWxlbWVudC5fc3RvcmUudmFsaWRhdGVkID0gdHJ1ZTtcbiAgICB2YXIgY3VycmVudENvbXBvbmVudEVycm9ySW5mbyA9IGdldEN1cnJlbnRDb21wb25lbnRFcnJvckluZm8ocGFyZW50VHlwZSk7XG5cbiAgICBpZiAob3duZXJIYXNLZXlVc2VXYXJuaW5nW2N1cnJlbnRDb21wb25lbnRFcnJvckluZm9dKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgb3duZXJIYXNLZXlVc2VXYXJuaW5nW2N1cnJlbnRDb21wb25lbnRFcnJvckluZm9dID0gdHJ1ZTsgLy8gVXN1YWxseSB0aGUgY3VycmVudCBvd25lciBpcyB0aGUgb2ZmZW5kZXIsIGJ1dCBpZiBpdCBhY2NlcHRzIGNoaWxkcmVuIGFzIGFcbiAgICAvLyBwcm9wZXJ0eSwgaXQgbWF5IGJlIHRoZSBjcmVhdG9yIG9mIHRoZSBjaGlsZCB0aGF0J3MgcmVzcG9uc2libGUgZm9yXG4gICAgLy8gYXNzaWduaW5nIGl0IGEga2V5LlxuXG4gICAgdmFyIGNoaWxkT3duZXIgPSAnJztcblxuICAgIGlmIChlbGVtZW50ICYmIGVsZW1lbnQuX293bmVyICYmIGVsZW1lbnQuX293bmVyICE9PSBSZWFjdEN1cnJlbnRPd25lciQxLmN1cnJlbnQpIHtcbiAgICAgIC8vIEdpdmUgdGhlIGNvbXBvbmVudCB0aGF0IG9yaWdpbmFsbHkgY3JlYXRlZCB0aGlzIGNoaWxkLlxuICAgICAgY2hpbGRPd25lciA9IFwiIEl0IHdhcyBwYXNzZWQgYSBjaGlsZCBmcm9tIFwiICsgZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKGVsZW1lbnQuX293bmVyLnR5cGUpICsgXCIuXCI7XG4gICAgfVxuXG4gICAgc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQkMShlbGVtZW50KTtcblxuICAgIGVycm9yKCdFYWNoIGNoaWxkIGluIGEgbGlzdCBzaG91bGQgaGF2ZSBhIHVuaXF1ZSBcImtleVwiIHByb3AuJyArICclcyVzIFNlZSBodHRwczovL3JlYWN0anMub3JnL2xpbmsvd2FybmluZy1rZXlzIGZvciBtb3JlIGluZm9ybWF0aW9uLicsIGN1cnJlbnRDb21wb25lbnRFcnJvckluZm8sIGNoaWxkT3duZXIpO1xuXG4gICAgc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQkMShudWxsKTtcbiAgfVxufVxuLyoqXG4gKiBFbnN1cmUgdGhhdCBldmVyeSBlbGVtZW50IGVpdGhlciBpcyBwYXNzZWQgaW4gYSBzdGF0aWMgbG9jYXRpb24sIGluIGFuXG4gKiBhcnJheSB3aXRoIGFuIGV4cGxpY2l0IGtleXMgcHJvcGVydHkgZGVmaW5lZCwgb3IgaW4gYW4gb2JqZWN0IGxpdGVyYWxcbiAqIHdpdGggdmFsaWQga2V5IHByb3BlcnR5LlxuICpcbiAqIEBpbnRlcm5hbFxuICogQHBhcmFtIHtSZWFjdE5vZGV9IG5vZGUgU3RhdGljYWxseSBwYXNzZWQgY2hpbGQgb2YgYW55IHR5cGUuXG4gKiBAcGFyYW0geyp9IHBhcmVudFR5cGUgbm9kZSdzIHBhcmVudCdzIHR5cGUuXG4gKi9cblxuXG5mdW5jdGlvbiB2YWxpZGF0ZUNoaWxkS2V5cyhub2RlLCBwYXJlbnRUeXBlKSB7XG4gIHtcbiAgICBpZiAodHlwZW9mIG5vZGUgIT09ICdvYmplY3QnKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKGlzQXJyYXkobm9kZSkpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbm9kZS5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgY2hpbGQgPSBub2RlW2ldO1xuXG4gICAgICAgIGlmIChpc1ZhbGlkRWxlbWVudChjaGlsZCkpIHtcbiAgICAgICAgICB2YWxpZGF0ZUV4cGxpY2l0S2V5KGNoaWxkLCBwYXJlbnRUeXBlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoaXNWYWxpZEVsZW1lbnQobm9kZSkpIHtcbiAgICAgIC8vIFRoaXMgZWxlbWVudCB3YXMgcGFzc2VkIGluIGEgdmFsaWQgbG9jYXRpb24uXG4gICAgICBpZiAobm9kZS5fc3RvcmUpIHtcbiAgICAgICAgbm9kZS5fc3RvcmUudmFsaWRhdGVkID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKG5vZGUpIHtcbiAgICAgIHZhciBpdGVyYXRvckZuID0gZ2V0SXRlcmF0b3JGbihub2RlKTtcblxuICAgICAgaWYgKHR5cGVvZiBpdGVyYXRvckZuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIC8vIEVudHJ5IGl0ZXJhdG9ycyB1c2VkIHRvIHByb3ZpZGUgaW1wbGljaXQga2V5cyxcbiAgICAgICAgLy8gYnV0IG5vdyB3ZSBwcmludCBhIHNlcGFyYXRlIHdhcm5pbmcgZm9yIHRoZW0gbGF0ZXIuXG4gICAgICAgIGlmIChpdGVyYXRvckZuICE9PSBub2RlLmVudHJpZXMpIHtcbiAgICAgICAgICB2YXIgaXRlcmF0b3IgPSBpdGVyYXRvckZuLmNhbGwobm9kZSk7XG4gICAgICAgICAgdmFyIHN0ZXA7XG5cbiAgICAgICAgICB3aGlsZSAoIShzdGVwID0gaXRlcmF0b3IubmV4dCgpKS5kb25lKSB7XG4gICAgICAgICAgICBpZiAoaXNWYWxpZEVsZW1lbnQoc3RlcC52YWx1ZSkpIHtcbiAgICAgICAgICAgICAgdmFsaWRhdGVFeHBsaWNpdEtleShzdGVwLnZhbHVlLCBwYXJlbnRUeXBlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cbi8qKlxuICogR2l2ZW4gYW4gZWxlbWVudCwgdmFsaWRhdGUgdGhhdCBpdHMgcHJvcHMgZm9sbG93IHRoZSBwcm9wVHlwZXMgZGVmaW5pdGlvbixcbiAqIHByb3ZpZGVkIGJ5IHRoZSB0eXBlLlxuICpcbiAqIEBwYXJhbSB7UmVhY3RFbGVtZW50fSBlbGVtZW50XG4gKi9cblxuXG5mdW5jdGlvbiB2YWxpZGF0ZVByb3BUeXBlcyhlbGVtZW50KSB7XG4gIHtcbiAgICB2YXIgdHlwZSA9IGVsZW1lbnQudHlwZTtcblxuICAgIGlmICh0eXBlID09PSBudWxsIHx8IHR5cGUgPT09IHVuZGVmaW5lZCB8fCB0eXBlb2YgdHlwZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgcHJvcFR5cGVzO1xuXG4gICAgaWYgKHR5cGVvZiB0eXBlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBwcm9wVHlwZXMgPSB0eXBlLnByb3BUeXBlcztcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiB0eXBlID09PSAnb2JqZWN0JyAmJiAodHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfRk9SV0FSRF9SRUZfVFlQRSB8fCAvLyBOb3RlOiBNZW1vIG9ubHkgY2hlY2tzIG91dGVyIHByb3BzIGhlcmUuXG4gICAgLy8gSW5uZXIgcHJvcHMgYXJlIGNoZWNrZWQgaW4gdGhlIHJlY29uY2lsZXIuXG4gICAgdHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfTUVNT19UWVBFKSkge1xuICAgICAgcHJvcFR5cGVzID0gdHlwZS5wcm9wVHlwZXM7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAocHJvcFR5cGVzKSB7XG4gICAgICAvLyBJbnRlbnRpb25hbGx5IGluc2lkZSB0byBhdm9pZCB0cmlnZ2VyaW5nIGxhenkgaW5pdGlhbGl6ZXJzOlxuICAgICAgdmFyIG5hbWUgPSBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUodHlwZSk7XG4gICAgICBjaGVja1Byb3BUeXBlcyhwcm9wVHlwZXMsIGVsZW1lbnQucHJvcHMsICdwcm9wJywgbmFtZSwgZWxlbWVudCk7XG4gICAgfSBlbHNlIGlmICh0eXBlLlByb3BUeXBlcyAhPT0gdW5kZWZpbmVkICYmICFwcm9wVHlwZXNNaXNzcGVsbFdhcm5pbmdTaG93bikge1xuICAgICAgcHJvcFR5cGVzTWlzc3BlbGxXYXJuaW5nU2hvd24gPSB0cnVlOyAvLyBJbnRlbnRpb25hbGx5IGluc2lkZSB0byBhdm9pZCB0cmlnZ2VyaW5nIGxhenkgaW5pdGlhbGl6ZXJzOlxuXG4gICAgICB2YXIgX25hbWUgPSBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUodHlwZSk7XG5cbiAgICAgIGVycm9yKCdDb21wb25lbnQgJXMgZGVjbGFyZWQgYFByb3BUeXBlc2AgaW5zdGVhZCBvZiBgcHJvcFR5cGVzYC4gRGlkIHlvdSBtaXNzcGVsbCB0aGUgcHJvcGVydHkgYXNzaWdubWVudD8nLCBfbmFtZSB8fCAnVW5rbm93bicpO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgdHlwZS5nZXREZWZhdWx0UHJvcHMgPT09ICdmdW5jdGlvbicgJiYgIXR5cGUuZ2V0RGVmYXVsdFByb3BzLmlzUmVhY3RDbGFzc0FwcHJvdmVkKSB7XG4gICAgICBlcnJvcignZ2V0RGVmYXVsdFByb3BzIGlzIG9ubHkgdXNlZCBvbiBjbGFzc2ljIFJlYWN0LmNyZWF0ZUNsYXNzICcgKyAnZGVmaW5pdGlvbnMuIFVzZSBhIHN0YXRpYyBwcm9wZXJ0eSBuYW1lZCBgZGVmYXVsdFByb3BzYCBpbnN0ZWFkLicpO1xuICAgIH1cbiAgfVxufVxuLyoqXG4gKiBHaXZlbiBhIGZyYWdtZW50LCB2YWxpZGF0ZSB0aGF0IGl0IGNhbiBvbmx5IGJlIHByb3ZpZGVkIHdpdGggZnJhZ21lbnQgcHJvcHNcbiAqIEBwYXJhbSB7UmVhY3RFbGVtZW50fSBmcmFnbWVudFxuICovXG5cblxuZnVuY3Rpb24gdmFsaWRhdGVGcmFnbWVudFByb3BzKGZyYWdtZW50KSB7XG4gIHtcbiAgICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKGZyYWdtZW50LnByb3BzKTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGtleSA9IGtleXNbaV07XG5cbiAgICAgIGlmIChrZXkgIT09ICdjaGlsZHJlbicgJiYga2V5ICE9PSAna2V5Jykge1xuICAgICAgICBzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudCQxKGZyYWdtZW50KTtcblxuICAgICAgICBlcnJvcignSW52YWxpZCBwcm9wIGAlc2Agc3VwcGxpZWQgdG8gYFJlYWN0LkZyYWdtZW50YC4gJyArICdSZWFjdC5GcmFnbWVudCBjYW4gb25seSBoYXZlIGBrZXlgIGFuZCBgY2hpbGRyZW5gIHByb3BzLicsIGtleSk7XG5cbiAgICAgICAgc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQkMShudWxsKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGZyYWdtZW50LnJlZiAhPT0gbnVsbCkge1xuICAgICAgc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQkMShmcmFnbWVudCk7XG5cbiAgICAgIGVycm9yKCdJbnZhbGlkIGF0dHJpYnV0ZSBgcmVmYCBzdXBwbGllZCB0byBgUmVhY3QuRnJhZ21lbnRgLicpO1xuXG4gICAgICBzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudCQxKG51bGwpO1xuICAgIH1cbiAgfVxufVxuXG52YXIgZGlkV2FybkFib3V0S2V5U3ByZWFkID0ge307XG5mdW5jdGlvbiBqc3hXaXRoVmFsaWRhdGlvbih0eXBlLCBwcm9wcywga2V5LCBpc1N0YXRpY0NoaWxkcmVuLCBzb3VyY2UsIHNlbGYpIHtcbiAge1xuICAgIHZhciB2YWxpZFR5cGUgPSBpc1ZhbGlkRWxlbWVudFR5cGUodHlwZSk7IC8vIFdlIHdhcm4gaW4gdGhpcyBjYXNlIGJ1dCBkb24ndCB0aHJvdy4gV2UgZXhwZWN0IHRoZSBlbGVtZW50IGNyZWF0aW9uIHRvXG4gICAgLy8gc3VjY2VlZCBhbmQgdGhlcmUgd2lsbCBsaWtlbHkgYmUgZXJyb3JzIGluIHJlbmRlci5cblxuICAgIGlmICghdmFsaWRUeXBlKSB7XG4gICAgICB2YXIgaW5mbyA9ICcnO1xuXG4gICAgICBpZiAodHlwZSA9PT0gdW5kZWZpbmVkIHx8IHR5cGVvZiB0eXBlID09PSAnb2JqZWN0JyAmJiB0eXBlICE9PSBudWxsICYmIE9iamVjdC5rZXlzKHR5cGUpLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICBpbmZvICs9ICcgWW91IGxpa2VseSBmb3Jnb3QgdG8gZXhwb3J0IHlvdXIgY29tcG9uZW50IGZyb20gdGhlIGZpbGUgJyArIFwiaXQncyBkZWZpbmVkIGluLCBvciB5b3UgbWlnaHQgaGF2ZSBtaXhlZCB1cCBkZWZhdWx0IGFuZCBuYW1lZCBpbXBvcnRzLlwiO1xuICAgICAgfVxuXG4gICAgICB2YXIgc291cmNlSW5mbyA9IGdldFNvdXJjZUluZm9FcnJvckFkZGVuZHVtKHNvdXJjZSk7XG5cbiAgICAgIGlmIChzb3VyY2VJbmZvKSB7XG4gICAgICAgIGluZm8gKz0gc291cmNlSW5mbztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGluZm8gKz0gZ2V0RGVjbGFyYXRpb25FcnJvckFkZGVuZHVtKCk7XG4gICAgICB9XG5cbiAgICAgIHZhciB0eXBlU3RyaW5nO1xuXG4gICAgICBpZiAodHlwZSA9PT0gbnVsbCkge1xuICAgICAgICB0eXBlU3RyaW5nID0gJ251bGwnO1xuICAgICAgfSBlbHNlIGlmIChpc0FycmF5KHR5cGUpKSB7XG4gICAgICAgIHR5cGVTdHJpbmcgPSAnYXJyYXknO1xuICAgICAgfSBlbHNlIGlmICh0eXBlICE9PSB1bmRlZmluZWQgJiYgdHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfRUxFTUVOVF9UWVBFKSB7XG4gICAgICAgIHR5cGVTdHJpbmcgPSBcIjxcIiArIChnZXRDb21wb25lbnROYW1lRnJvbVR5cGUodHlwZS50eXBlKSB8fCAnVW5rbm93bicpICsgXCIgLz5cIjtcbiAgICAgICAgaW5mbyA9ICcgRGlkIHlvdSBhY2NpZGVudGFsbHkgZXhwb3J0IGEgSlNYIGxpdGVyYWwgaW5zdGVhZCBvZiBhIGNvbXBvbmVudD8nO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdHlwZVN0cmluZyA9IHR5cGVvZiB0eXBlO1xuICAgICAgfVxuXG4gICAgICBlcnJvcignUmVhY3QuanN4OiB0eXBlIGlzIGludmFsaWQgLS0gZXhwZWN0ZWQgYSBzdHJpbmcgKGZvciAnICsgJ2J1aWx0LWluIGNvbXBvbmVudHMpIG9yIGEgY2xhc3MvZnVuY3Rpb24gKGZvciBjb21wb3NpdGUgJyArICdjb21wb25lbnRzKSBidXQgZ290OiAlcy4lcycsIHR5cGVTdHJpbmcsIGluZm8pO1xuICAgIH1cblxuICAgIHZhciBlbGVtZW50ID0ganN4REVWKHR5cGUsIHByb3BzLCBrZXksIHNvdXJjZSwgc2VsZik7IC8vIFRoZSByZXN1bHQgY2FuIGJlIG51bGxpc2ggaWYgYSBtb2NrIG9yIGEgY3VzdG9tIGZ1bmN0aW9uIGlzIHVzZWQuXG4gICAgLy8gVE9ETzogRHJvcCB0aGlzIHdoZW4gdGhlc2UgYXJlIG5vIGxvbmdlciBhbGxvd2VkIGFzIHRoZSB0eXBlIGFyZ3VtZW50LlxuXG4gICAgaWYgKGVsZW1lbnQgPT0gbnVsbCkge1xuICAgICAgcmV0dXJuIGVsZW1lbnQ7XG4gICAgfSAvLyBTa2lwIGtleSB3YXJuaW5nIGlmIHRoZSB0eXBlIGlzbid0IHZhbGlkIHNpbmNlIG91ciBrZXkgdmFsaWRhdGlvbiBsb2dpY1xuICAgIC8vIGRvZXNuJ3QgZXhwZWN0IGEgbm9uLXN0cmluZy9mdW5jdGlvbiB0eXBlIGFuZCBjYW4gdGhyb3cgY29uZnVzaW5nIGVycm9ycy5cbiAgICAvLyBXZSBkb24ndCB3YW50IGV4Y2VwdGlvbiBiZWhhdmlvciB0byBkaWZmZXIgYmV0d2VlbiBkZXYgYW5kIHByb2QuXG4gICAgLy8gKFJlbmRlcmluZyB3aWxsIHRocm93IHdpdGggYSBoZWxwZnVsIG1lc3NhZ2UgYW5kIGFzIHNvb24gYXMgdGhlIHR5cGUgaXNcbiAgICAvLyBmaXhlZCwgdGhlIGtleSB3YXJuaW5ncyB3aWxsIGFwcGVhci4pXG5cblxuICAgIGlmICh2YWxpZFR5cGUpIHtcbiAgICAgIHZhciBjaGlsZHJlbiA9IHByb3BzLmNoaWxkcmVuO1xuXG4gICAgICBpZiAoY2hpbGRyZW4gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBpZiAoaXNTdGF0aWNDaGlsZHJlbikge1xuICAgICAgICAgIGlmIChpc0FycmF5KGNoaWxkcmVuKSkge1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICB2YWxpZGF0ZUNoaWxkS2V5cyhjaGlsZHJlbltpXSwgdHlwZSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChPYmplY3QuZnJlZXplKSB7XG4gICAgICAgICAgICAgIE9iamVjdC5mcmVlemUoY2hpbGRyZW4pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBlcnJvcignUmVhY3QuanN4OiBTdGF0aWMgY2hpbGRyZW4gc2hvdWxkIGFsd2F5cyBiZSBhbiBhcnJheS4gJyArICdZb3UgYXJlIGxpa2VseSBleHBsaWNpdGx5IGNhbGxpbmcgUmVhY3QuanN4cyBvciBSZWFjdC5qc3hERVYuICcgKyAnVXNlIHRoZSBCYWJlbCB0cmFuc2Zvcm0gaW5zdGVhZC4nKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFsaWRhdGVDaGlsZEtleXMoY2hpbGRyZW4sIHR5cGUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAge1xuICAgICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwocHJvcHMsICdrZXknKSkge1xuICAgICAgICB2YXIgY29tcG9uZW50TmFtZSA9IGdldENvbXBvbmVudE5hbWVGcm9tVHlwZSh0eXBlKTtcbiAgICAgICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhwcm9wcykuZmlsdGVyKGZ1bmN0aW9uIChrKSB7XG4gICAgICAgICAgcmV0dXJuIGsgIT09ICdrZXknO1xuICAgICAgICB9KTtcbiAgICAgICAgdmFyIGJlZm9yZUV4YW1wbGUgPSBrZXlzLmxlbmd0aCA+IDAgPyAne2tleTogc29tZUtleSwgJyArIGtleXMuam9pbignOiAuLi4sICcpICsgJzogLi4ufScgOiAne2tleTogc29tZUtleX0nO1xuXG4gICAgICAgIGlmICghZGlkV2FybkFib3V0S2V5U3ByZWFkW2NvbXBvbmVudE5hbWUgKyBiZWZvcmVFeGFtcGxlXSkge1xuICAgICAgICAgIHZhciBhZnRlckV4YW1wbGUgPSBrZXlzLmxlbmd0aCA+IDAgPyAneycgKyBrZXlzLmpvaW4oJzogLi4uLCAnKSArICc6IC4uLn0nIDogJ3t9JztcblxuICAgICAgICAgIGVycm9yKCdBIHByb3BzIG9iamVjdCBjb250YWluaW5nIGEgXCJrZXlcIiBwcm9wIGlzIGJlaW5nIHNwcmVhZCBpbnRvIEpTWDpcXG4nICsgJyAgbGV0IHByb3BzID0gJXM7XFxuJyArICcgIDwlcyB7Li4ucHJvcHN9IC8+XFxuJyArICdSZWFjdCBrZXlzIG11c3QgYmUgcGFzc2VkIGRpcmVjdGx5IHRvIEpTWCB3aXRob3V0IHVzaW5nIHNwcmVhZDpcXG4nICsgJyAgbGV0IHByb3BzID0gJXM7XFxuJyArICcgIDwlcyBrZXk9e3NvbWVLZXl9IHsuLi5wcm9wc30gLz4nLCBiZWZvcmVFeGFtcGxlLCBjb21wb25lbnROYW1lLCBhZnRlckV4YW1wbGUsIGNvbXBvbmVudE5hbWUpO1xuXG4gICAgICAgICAgZGlkV2FybkFib3V0S2V5U3ByZWFkW2NvbXBvbmVudE5hbWUgKyBiZWZvcmVFeGFtcGxlXSA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAodHlwZSA9PT0gUkVBQ1RfRlJBR01FTlRfVFlQRSkge1xuICAgICAgdmFsaWRhdGVGcmFnbWVudFByb3BzKGVsZW1lbnQpO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YWxpZGF0ZVByb3BUeXBlcyhlbGVtZW50KTtcbiAgICB9XG5cbiAgICByZXR1cm4gZWxlbWVudDtcbiAgfVxufSAvLyBUaGVzZSB0d28gZnVuY3Rpb25zIGV4aXN0IHRvIHN0aWxsIGdldCBjaGlsZCB3YXJuaW5ncyBpbiBkZXZcblxudmFyIGpzeERFViQxID0gIGpzeFdpdGhWYWxpZGF0aW9uIDtcblxuZXhwb3J0cy5GcmFnbWVudCA9IFJFQUNUX0ZSQUdNRU5UX1RZUEU7XG5leHBvcnRzLmpzeERFViA9IGpzeERFViQxO1xuICB9KSgpO1xufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/react/cjs/react-jsx-dev-runtime.development.js\n"));

/***/ }),

/***/ "./node_modules/react/jsx-dev-runtime.js":
/*!***********************************************!*\
  !*** ./node_modules/react/jsx-dev-runtime.js ***!
  \***********************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\n\nif (false) {} else {\n  module.exports = __webpack_require__(/*! ./cjs/react-jsx-dev-runtime.development.js */ \"./node_modules/react/cjs/react-jsx-dev-runtime.development.js\");\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcmVhY3QvanN4LWRldi1ydW50aW1lLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViLElBQUksS0FBcUMsRUFBRSxFQUUxQyxDQUFDO0FBQ0YsRUFBRSx1SkFBc0U7QUFDeEUiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL3JlYWN0L2pzeC1kZXYtcnVudGltZS5qcz81Nzc3Il0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAncHJvZHVjdGlvbicpIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2Nqcy9yZWFjdC1qc3gtZGV2LXJ1bnRpbWUucHJvZHVjdGlvbi5taW4uanMnKTtcbn0gZWxzZSB7XG4gIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9janMvcmVhY3QtanN4LWRldi1ydW50aW1lLmRldmVsb3BtZW50LmpzJyk7XG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/react/jsx-dev-runtime.js\n"));

/***/ }),

/***/ "../../node_modules/base64-js/index.js":
/*!*********************************************!*\
  !*** ../../node_modules/base64-js/index.js ***!
  \*********************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\n\nexports.byteLength = byteLength\nexports.toByteArray = toByteArray\nexports.fromByteArray = fromByteArray\n\nvar lookup = []\nvar revLookup = []\nvar Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array\n\nvar code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'\nfor (var i = 0, len = code.length; i < len; ++i) {\n  lookup[i] = code[i]\n  revLookup[code.charCodeAt(i)] = i\n}\n\n// Support decoding URL-safe base64 strings, as Node.js does.\n// See: https://en.wikipedia.org/wiki/Base64#URL_applications\nrevLookup['-'.charCodeAt(0)] = 62\nrevLookup['_'.charCodeAt(0)] = 63\n\nfunction getLens (b64) {\n  var len = b64.length\n\n  if (len % 4 > 0) {\n    throw new Error('Invalid string. Length must be a multiple of 4')\n  }\n\n  // Trim off extra bytes after placeholder bytes are found\n  // See: https://github.com/beatgammit/base64-js/issues/42\n  var validLen = b64.indexOf('=')\n  if (validLen === -1) validLen = len\n\n  var placeHoldersLen = validLen === len\n    ? 0\n    : 4 - (validLen % 4)\n\n  return [validLen, placeHoldersLen]\n}\n\n// base64 is 4/3 + up to two characters of the original data\nfunction byteLength (b64) {\n  var lens = getLens(b64)\n  var validLen = lens[0]\n  var placeHoldersLen = lens[1]\n  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen\n}\n\nfunction _byteLength (b64, validLen, placeHoldersLen) {\n  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen\n}\n\nfunction toByteArray (b64) {\n  var tmp\n  var lens = getLens(b64)\n  var validLen = lens[0]\n  var placeHoldersLen = lens[1]\n\n  var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen))\n\n  var curByte = 0\n\n  // if there are placeholders, only get up to the last complete 4 chars\n  var len = placeHoldersLen > 0\n    ? validLen - 4\n    : validLen\n\n  var i\n  for (i = 0; i < len; i += 4) {\n    tmp =\n      (revLookup[b64.charCodeAt(i)] << 18) |\n      (revLookup[b64.charCodeAt(i + 1)] << 12) |\n      (revLookup[b64.charCodeAt(i + 2)] << 6) |\n      revLookup[b64.charCodeAt(i + 3)]\n    arr[curByte++] = (tmp >> 16) & 0xFF\n    arr[curByte++] = (tmp >> 8) & 0xFF\n    arr[curByte++] = tmp & 0xFF\n  }\n\n  if (placeHoldersLen === 2) {\n    tmp =\n      (revLookup[b64.charCodeAt(i)] << 2) |\n      (revLookup[b64.charCodeAt(i + 1)] >> 4)\n    arr[curByte++] = tmp & 0xFF\n  }\n\n  if (placeHoldersLen === 1) {\n    tmp =\n      (revLookup[b64.charCodeAt(i)] << 10) |\n      (revLookup[b64.charCodeAt(i + 1)] << 4) |\n      (revLookup[b64.charCodeAt(i + 2)] >> 2)\n    arr[curByte++] = (tmp >> 8) & 0xFF\n    arr[curByte++] = tmp & 0xFF\n  }\n\n  return arr\n}\n\nfunction tripletToBase64 (num) {\n  return lookup[num >> 18 & 0x3F] +\n    lookup[num >> 12 & 0x3F] +\n    lookup[num >> 6 & 0x3F] +\n    lookup[num & 0x3F]\n}\n\nfunction encodeChunk (uint8, start, end) {\n  var tmp\n  var output = []\n  for (var i = start; i < end; i += 3) {\n    tmp =\n      ((uint8[i] << 16) & 0xFF0000) +\n      ((uint8[i + 1] << 8) & 0xFF00) +\n      (uint8[i + 2] & 0xFF)\n    output.push(tripletToBase64(tmp))\n  }\n  return output.join('')\n}\n\nfunction fromByteArray (uint8) {\n  var tmp\n  var len = uint8.length\n  var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes\n  var parts = []\n  var maxChunkLength = 16383 // must be multiple of 3\n\n  // go through the array every three bytes, we'll deal with trailing stuff later\n  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {\n    parts.push(encodeChunk(uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)))\n  }\n\n  // pad the end with zeros, but make sure to not forget the extra bytes\n  if (extraBytes === 1) {\n    tmp = uint8[len - 1]\n    parts.push(\n      lookup[tmp >> 2] +\n      lookup[(tmp << 4) & 0x3F] +\n      '=='\n    )\n  } else if (extraBytes === 2) {\n    tmp = (uint8[len - 2] << 8) + uint8[len - 1]\n    parts.push(\n      lookup[tmp >> 10] +\n      lookup[(tmp >> 4) & 0x3F] +\n      lookup[(tmp << 2) & 0x3F] +\n      '='\n    )\n  }\n\n  return parts.join('')\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vLi4vbm9kZV9tb2R1bGVzL2Jhc2U2NC1qcy9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBWTs7QUFFWixrQkFBa0I7QUFDbEIsbUJBQW1CO0FBQ25CLHFCQUFxQjs7QUFFckI7QUFDQTtBQUNBOztBQUVBO0FBQ0EsbUNBQW1DLFNBQVM7QUFDNUM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsY0FBYyxTQUFTO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsU0FBUztBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDJDQUEyQyxVQUFVO0FBQ3JEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4uLy4uL25vZGVfbW9kdWxlcy9iYXNlNjQtanMvaW5kZXguanM/NjAyYSJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCdcblxuZXhwb3J0cy5ieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aFxuZXhwb3J0cy50b0J5dGVBcnJheSA9IHRvQnl0ZUFycmF5XG5leHBvcnRzLmZyb21CeXRlQXJyYXkgPSBmcm9tQnl0ZUFycmF5XG5cbnZhciBsb29rdXAgPSBbXVxudmFyIHJldkxvb2t1cCA9IFtdXG52YXIgQXJyID0gdHlwZW9mIFVpbnQ4QXJyYXkgIT09ICd1bmRlZmluZWQnID8gVWludDhBcnJheSA6IEFycmF5XG5cbnZhciBjb2RlID0gJ0FCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXowMTIzNDU2Nzg5Ky8nXG5mb3IgKHZhciBpID0gMCwgbGVuID0gY29kZS5sZW5ndGg7IGkgPCBsZW47ICsraSkge1xuICBsb29rdXBbaV0gPSBjb2RlW2ldXG4gIHJldkxvb2t1cFtjb2RlLmNoYXJDb2RlQXQoaSldID0gaVxufVxuXG4vLyBTdXBwb3J0IGRlY29kaW5nIFVSTC1zYWZlIGJhc2U2NCBzdHJpbmdzLCBhcyBOb2RlLmpzIGRvZXMuXG4vLyBTZWU6IGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0Jhc2U2NCNVUkxfYXBwbGljYXRpb25zXG5yZXZMb29rdXBbJy0nLmNoYXJDb2RlQXQoMCldID0gNjJcbnJldkxvb2t1cFsnXycuY2hhckNvZGVBdCgwKV0gPSA2M1xuXG5mdW5jdGlvbiBnZXRMZW5zIChiNjQpIHtcbiAgdmFyIGxlbiA9IGI2NC5sZW5ndGhcblxuICBpZiAobGVuICUgNCA+IDApIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgc3RyaW5nLiBMZW5ndGggbXVzdCBiZSBhIG11bHRpcGxlIG9mIDQnKVxuICB9XG5cbiAgLy8gVHJpbSBvZmYgZXh0cmEgYnl0ZXMgYWZ0ZXIgcGxhY2Vob2xkZXIgYnl0ZXMgYXJlIGZvdW5kXG4gIC8vIFNlZTogaHR0cHM6Ly9naXRodWIuY29tL2JlYXRnYW1taXQvYmFzZTY0LWpzL2lzc3Vlcy80MlxuICB2YXIgdmFsaWRMZW4gPSBiNjQuaW5kZXhPZignPScpXG4gIGlmICh2YWxpZExlbiA9PT0gLTEpIHZhbGlkTGVuID0gbGVuXG5cbiAgdmFyIHBsYWNlSG9sZGVyc0xlbiA9IHZhbGlkTGVuID09PSBsZW5cbiAgICA/IDBcbiAgICA6IDQgLSAodmFsaWRMZW4gJSA0KVxuXG4gIHJldHVybiBbdmFsaWRMZW4sIHBsYWNlSG9sZGVyc0xlbl1cbn1cblxuLy8gYmFzZTY0IGlzIDQvMyArIHVwIHRvIHR3byBjaGFyYWN0ZXJzIG9mIHRoZSBvcmlnaW5hbCBkYXRhXG5mdW5jdGlvbiBieXRlTGVuZ3RoIChiNjQpIHtcbiAgdmFyIGxlbnMgPSBnZXRMZW5zKGI2NClcbiAgdmFyIHZhbGlkTGVuID0gbGVuc1swXVxuICB2YXIgcGxhY2VIb2xkZXJzTGVuID0gbGVuc1sxXVxuICByZXR1cm4gKCh2YWxpZExlbiArIHBsYWNlSG9sZGVyc0xlbikgKiAzIC8gNCkgLSBwbGFjZUhvbGRlcnNMZW5cbn1cblxuZnVuY3Rpb24gX2J5dGVMZW5ndGggKGI2NCwgdmFsaWRMZW4sIHBsYWNlSG9sZGVyc0xlbikge1xuICByZXR1cm4gKCh2YWxpZExlbiArIHBsYWNlSG9sZGVyc0xlbikgKiAzIC8gNCkgLSBwbGFjZUhvbGRlcnNMZW5cbn1cblxuZnVuY3Rpb24gdG9CeXRlQXJyYXkgKGI2NCkge1xuICB2YXIgdG1wXG4gIHZhciBsZW5zID0gZ2V0TGVucyhiNjQpXG4gIHZhciB2YWxpZExlbiA9IGxlbnNbMF1cbiAgdmFyIHBsYWNlSG9sZGVyc0xlbiA9IGxlbnNbMV1cblxuICB2YXIgYXJyID0gbmV3IEFycihfYnl0ZUxlbmd0aChiNjQsIHZhbGlkTGVuLCBwbGFjZUhvbGRlcnNMZW4pKVxuXG4gIHZhciBjdXJCeXRlID0gMFxuXG4gIC8vIGlmIHRoZXJlIGFyZSBwbGFjZWhvbGRlcnMsIG9ubHkgZ2V0IHVwIHRvIHRoZSBsYXN0IGNvbXBsZXRlIDQgY2hhcnNcbiAgdmFyIGxlbiA9IHBsYWNlSG9sZGVyc0xlbiA+IDBcbiAgICA/IHZhbGlkTGVuIC0gNFxuICAgIDogdmFsaWRMZW5cblxuICB2YXIgaVxuICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpICs9IDQpIHtcbiAgICB0bXAgPVxuICAgICAgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpKV0gPDwgMTgpIHxcbiAgICAgIChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSArIDEpXSA8PCAxMikgfFxuICAgICAgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpICsgMildIDw8IDYpIHxcbiAgICAgIHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpICsgMyldXG4gICAgYXJyW2N1ckJ5dGUrK10gPSAodG1wID4+IDE2KSAmIDB4RkZcbiAgICBhcnJbY3VyQnl0ZSsrXSA9ICh0bXAgPj4gOCkgJiAweEZGXG4gICAgYXJyW2N1ckJ5dGUrK10gPSB0bXAgJiAweEZGXG4gIH1cblxuICBpZiAocGxhY2VIb2xkZXJzTGVuID09PSAyKSB7XG4gICAgdG1wID1cbiAgICAgIChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSldIDw8IDIpIHxcbiAgICAgIChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSArIDEpXSA+PiA0KVxuICAgIGFycltjdXJCeXRlKytdID0gdG1wICYgMHhGRlxuICB9XG5cbiAgaWYgKHBsYWNlSG9sZGVyc0xlbiA9PT0gMSkge1xuICAgIHRtcCA9XG4gICAgICAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkpXSA8PCAxMCkgfFxuICAgICAgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpICsgMSldIDw8IDQpIHxcbiAgICAgIChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSArIDIpXSA+PiAyKVxuICAgIGFycltjdXJCeXRlKytdID0gKHRtcCA+PiA4KSAmIDB4RkZcbiAgICBhcnJbY3VyQnl0ZSsrXSA9IHRtcCAmIDB4RkZcbiAgfVxuXG4gIHJldHVybiBhcnJcbn1cblxuZnVuY3Rpb24gdHJpcGxldFRvQmFzZTY0IChudW0pIHtcbiAgcmV0dXJuIGxvb2t1cFtudW0gPj4gMTggJiAweDNGXSArXG4gICAgbG9va3VwW251bSA+PiAxMiAmIDB4M0ZdICtcbiAgICBsb29rdXBbbnVtID4+IDYgJiAweDNGXSArXG4gICAgbG9va3VwW251bSAmIDB4M0ZdXG59XG5cbmZ1bmN0aW9uIGVuY29kZUNodW5rICh1aW50OCwgc3RhcnQsIGVuZCkge1xuICB2YXIgdG1wXG4gIHZhciBvdXRwdXQgPSBbXVxuICBmb3IgKHZhciBpID0gc3RhcnQ7IGkgPCBlbmQ7IGkgKz0gMykge1xuICAgIHRtcCA9XG4gICAgICAoKHVpbnQ4W2ldIDw8IDE2KSAmIDB4RkYwMDAwKSArXG4gICAgICAoKHVpbnQ4W2kgKyAxXSA8PCA4KSAmIDB4RkYwMCkgK1xuICAgICAgKHVpbnQ4W2kgKyAyXSAmIDB4RkYpXG4gICAgb3V0cHV0LnB1c2godHJpcGxldFRvQmFzZTY0KHRtcCkpXG4gIH1cbiAgcmV0dXJuIG91dHB1dC5qb2luKCcnKVxufVxuXG5mdW5jdGlvbiBmcm9tQnl0ZUFycmF5ICh1aW50OCkge1xuICB2YXIgdG1wXG4gIHZhciBsZW4gPSB1aW50OC5sZW5ndGhcbiAgdmFyIGV4dHJhQnl0ZXMgPSBsZW4gJSAzIC8vIGlmIHdlIGhhdmUgMSBieXRlIGxlZnQsIHBhZCAyIGJ5dGVzXG4gIHZhciBwYXJ0cyA9IFtdXG4gIHZhciBtYXhDaHVua0xlbmd0aCA9IDE2MzgzIC8vIG11c3QgYmUgbXVsdGlwbGUgb2YgM1xuXG4gIC8vIGdvIHRocm91Z2ggdGhlIGFycmF5IGV2ZXJ5IHRocmVlIGJ5dGVzLCB3ZSdsbCBkZWFsIHdpdGggdHJhaWxpbmcgc3R1ZmYgbGF0ZXJcbiAgZm9yICh2YXIgaSA9IDAsIGxlbjIgPSBsZW4gLSBleHRyYUJ5dGVzOyBpIDwgbGVuMjsgaSArPSBtYXhDaHVua0xlbmd0aCkge1xuICAgIHBhcnRzLnB1c2goZW5jb2RlQ2h1bmsodWludDgsIGksIChpICsgbWF4Q2h1bmtMZW5ndGgpID4gbGVuMiA/IGxlbjIgOiAoaSArIG1heENodW5rTGVuZ3RoKSkpXG4gIH1cblxuICAvLyBwYWQgdGhlIGVuZCB3aXRoIHplcm9zLCBidXQgbWFrZSBzdXJlIHRvIG5vdCBmb3JnZXQgdGhlIGV4dHJhIGJ5dGVzXG4gIGlmIChleHRyYUJ5dGVzID09PSAxKSB7XG4gICAgdG1wID0gdWludDhbbGVuIC0gMV1cbiAgICBwYXJ0cy5wdXNoKFxuICAgICAgbG9va3VwW3RtcCA+PiAyXSArXG4gICAgICBsb29rdXBbKHRtcCA8PCA0KSAmIDB4M0ZdICtcbiAgICAgICc9PSdcbiAgICApXG4gIH0gZWxzZSBpZiAoZXh0cmFCeXRlcyA9PT0gMikge1xuICAgIHRtcCA9ICh1aW50OFtsZW4gLSAyXSA8PCA4KSArIHVpbnQ4W2xlbiAtIDFdXG4gICAgcGFydHMucHVzaChcbiAgICAgIGxvb2t1cFt0bXAgPj4gMTBdICtcbiAgICAgIGxvb2t1cFsodG1wID4+IDQpICYgMHgzRl0gK1xuICAgICAgbG9va3VwWyh0bXAgPDwgMikgJiAweDNGXSArXG4gICAgICAnPSdcbiAgICApXG4gIH1cblxuICByZXR1cm4gcGFydHMuam9pbignJylcbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../../node_modules/base64-js/index.js\n"));

/***/ }),

/***/ "../../node_modules/buffer/index.js":
/*!******************************************!*\
  !*** ../../node_modules/buffer/index.js ***!
  \******************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("/*!\n * The buffer module from node.js, for the browser.\n *\n * @author   Feross Aboukhadijeh <https://feross.org>\n * @license  MIT\n */\n/* eslint-disable no-proto */\n\n\n\nvar base64 = __webpack_require__(/*! base64-js */ \"../../node_modules/base64-js/index.js\")\nvar ieee754 = __webpack_require__(/*! ieee754 */ \"../../node_modules/ieee754/index.js\")\nvar customInspectSymbol =\n  (typeof Symbol === 'function' && typeof Symbol['for'] === 'function') // eslint-disable-line dot-notation\n    ? Symbol['for']('nodejs.util.inspect.custom') // eslint-disable-line dot-notation\n    : null\n\nexports.Buffer = Buffer\nexports.SlowBuffer = SlowBuffer\nexports.INSPECT_MAX_BYTES = 50\n\nvar K_MAX_LENGTH = 0x7fffffff\nexports.kMaxLength = K_MAX_LENGTH\n\n/**\n * If `Buffer.TYPED_ARRAY_SUPPORT`:\n *   === true    Use Uint8Array implementation (fastest)\n *   === false   Print warning and recommend using `buffer` v4.x which has an Object\n *               implementation (most compatible, even IE6)\n *\n * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,\n * Opera 11.6+, iOS 4.2+.\n *\n * We report that the browser does not support typed arrays if the are not subclassable\n * using __proto__. Firefox 4-29 lacks support for adding new properties to `Uint8Array`\n * (See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438). IE 10 lacks support\n * for __proto__ and has a buggy typed array implementation.\n */\nBuffer.TYPED_ARRAY_SUPPORT = typedArraySupport()\n\nif (!Buffer.TYPED_ARRAY_SUPPORT && typeof console !== 'undefined' &&\n    typeof console.error === 'function') {\n  console.error(\n    'This browser lacks typed array (Uint8Array) support which is required by ' +\n    '`buffer` v5.x. Use `buffer` v4.x if you require old browser support.'\n  )\n}\n\nfunction typedArraySupport () {\n  // Can typed array instances can be augmented?\n  try {\n    var arr = new Uint8Array(1)\n    var proto = { foo: function () { return 42 } }\n    Object.setPrototypeOf(proto, Uint8Array.prototype)\n    Object.setPrototypeOf(arr, proto)\n    return arr.foo() === 42\n  } catch (e) {\n    return false\n  }\n}\n\nObject.defineProperty(Buffer.prototype, 'parent', {\n  enumerable: true,\n  get: function () {\n    if (!Buffer.isBuffer(this)) return undefined\n    return this.buffer\n  }\n})\n\nObject.defineProperty(Buffer.prototype, 'offset', {\n  enumerable: true,\n  get: function () {\n    if (!Buffer.isBuffer(this)) return undefined\n    return this.byteOffset\n  }\n})\n\nfunction createBuffer (length) {\n  if (length > K_MAX_LENGTH) {\n    throw new RangeError('The value \"' + length + '\" is invalid for option \"size\"')\n  }\n  // Return an augmented `Uint8Array` instance\n  var buf = new Uint8Array(length)\n  Object.setPrototypeOf(buf, Buffer.prototype)\n  return buf\n}\n\n/**\n * The Buffer constructor returns instances of `Uint8Array` that have their\n * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of\n * `Uint8Array`, so the returned instances will have all the node `Buffer` methods\n * and the `Uint8Array` methods. Square bracket notation works as expected -- it\n * returns a single octet.\n *\n * The `Uint8Array` prototype remains unmodified.\n */\n\nfunction Buffer (arg, encodingOrOffset, length) {\n  // Common case.\n  if (typeof arg === 'number') {\n    if (typeof encodingOrOffset === 'string') {\n      throw new TypeError(\n        'The \"string\" argument must be of type string. Received type number'\n      )\n    }\n    return allocUnsafe(arg)\n  }\n  return from(arg, encodingOrOffset, length)\n}\n\nBuffer.poolSize = 8192 // not used by this implementation\n\nfunction from (value, encodingOrOffset, length) {\n  if (typeof value === 'string') {\n    return fromString(value, encodingOrOffset)\n  }\n\n  if (ArrayBuffer.isView(value)) {\n    return fromArrayView(value)\n  }\n\n  if (value == null) {\n    throw new TypeError(\n      'The first argument must be one of type string, Buffer, ArrayBuffer, Array, ' +\n      'or Array-like Object. Received type ' + (typeof value)\n    )\n  }\n\n  if (isInstance(value, ArrayBuffer) ||\n      (value && isInstance(value.buffer, ArrayBuffer))) {\n    return fromArrayBuffer(value, encodingOrOffset, length)\n  }\n\n  if (typeof SharedArrayBuffer !== 'undefined' &&\n      (isInstance(value, SharedArrayBuffer) ||\n      (value && isInstance(value.buffer, SharedArrayBuffer)))) {\n    return fromArrayBuffer(value, encodingOrOffset, length)\n  }\n\n  if (typeof value === 'number') {\n    throw new TypeError(\n      'The \"value\" argument must not be of type number. Received type number'\n    )\n  }\n\n  var valueOf = value.valueOf && value.valueOf()\n  if (valueOf != null && valueOf !== value) {\n    return Buffer.from(valueOf, encodingOrOffset, length)\n  }\n\n  var b = fromObject(value)\n  if (b) return b\n\n  if (typeof Symbol !== 'undefined' && Symbol.toPrimitive != null &&\n      typeof value[Symbol.toPrimitive] === 'function') {\n    return Buffer.from(\n      value[Symbol.toPrimitive]('string'), encodingOrOffset, length\n    )\n  }\n\n  throw new TypeError(\n    'The first argument must be one of type string, Buffer, ArrayBuffer, Array, ' +\n    'or Array-like Object. Received type ' + (typeof value)\n  )\n}\n\n/**\n * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError\n * if value is a number.\n * Buffer.from(str[, encoding])\n * Buffer.from(array)\n * Buffer.from(buffer)\n * Buffer.from(arrayBuffer[, byteOffset[, length]])\n **/\nBuffer.from = function (value, encodingOrOffset, length) {\n  return from(value, encodingOrOffset, length)\n}\n\n// Note: Change prototype *after* Buffer.from is defined to workaround Chrome bug:\n// https://github.com/feross/buffer/pull/148\nObject.setPrototypeOf(Buffer.prototype, Uint8Array.prototype)\nObject.setPrototypeOf(Buffer, Uint8Array)\n\nfunction assertSize (size) {\n  if (typeof size !== 'number') {\n    throw new TypeError('\"size\" argument must be of type number')\n  } else if (size < 0) {\n    throw new RangeError('The value \"' + size + '\" is invalid for option \"size\"')\n  }\n}\n\nfunction alloc (size, fill, encoding) {\n  assertSize(size)\n  if (size <= 0) {\n    return createBuffer(size)\n  }\n  if (fill !== undefined) {\n    // Only pay attention to encoding if it's a string. This\n    // prevents accidentally sending in a number that would\n    // be interpreted as a start offset.\n    return typeof encoding === 'string'\n      ? createBuffer(size).fill(fill, encoding)\n      : createBuffer(size).fill(fill)\n  }\n  return createBuffer(size)\n}\n\n/**\n * Creates a new filled Buffer instance.\n * alloc(size[, fill[, encoding]])\n **/\nBuffer.alloc = function (size, fill, encoding) {\n  return alloc(size, fill, encoding)\n}\n\nfunction allocUnsafe (size) {\n  assertSize(size)\n  return createBuffer(size < 0 ? 0 : checked(size) | 0)\n}\n\n/**\n * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.\n * */\nBuffer.allocUnsafe = function (size) {\n  return allocUnsafe(size)\n}\n/**\n * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.\n */\nBuffer.allocUnsafeSlow = function (size) {\n  return allocUnsafe(size)\n}\n\nfunction fromString (string, encoding) {\n  if (typeof encoding !== 'string' || encoding === '') {\n    encoding = 'utf8'\n  }\n\n  if (!Buffer.isEncoding(encoding)) {\n    throw new TypeError('Unknown encoding: ' + encoding)\n  }\n\n  var length = byteLength(string, encoding) | 0\n  var buf = createBuffer(length)\n\n  var actual = buf.write(string, encoding)\n\n  if (actual !== length) {\n    // Writing a hex string, for example, that contains invalid characters will\n    // cause everything after the first invalid character to be ignored. (e.g.\n    // 'abxxcd' will be treated as 'ab')\n    buf = buf.slice(0, actual)\n  }\n\n  return buf\n}\n\nfunction fromArrayLike (array) {\n  var length = array.length < 0 ? 0 : checked(array.length) | 0\n  var buf = createBuffer(length)\n  for (var i = 0; i < length; i += 1) {\n    buf[i] = array[i] & 255\n  }\n  return buf\n}\n\nfunction fromArrayView (arrayView) {\n  if (isInstance(arrayView, Uint8Array)) {\n    var copy = new Uint8Array(arrayView)\n    return fromArrayBuffer(copy.buffer, copy.byteOffset, copy.byteLength)\n  }\n  return fromArrayLike(arrayView)\n}\n\nfunction fromArrayBuffer (array, byteOffset, length) {\n  if (byteOffset < 0 || array.byteLength < byteOffset) {\n    throw new RangeError('\"offset\" is outside of buffer bounds')\n  }\n\n  if (array.byteLength < byteOffset + (length || 0)) {\n    throw new RangeError('\"length\" is outside of buffer bounds')\n  }\n\n  var buf\n  if (byteOffset === undefined && length === undefined) {\n    buf = new Uint8Array(array)\n  } else if (length === undefined) {\n    buf = new Uint8Array(array, byteOffset)\n  } else {\n    buf = new Uint8Array(array, byteOffset, length)\n  }\n\n  // Return an augmented `Uint8Array` instance\n  Object.setPrototypeOf(buf, Buffer.prototype)\n\n  return buf\n}\n\nfunction fromObject (obj) {\n  if (Buffer.isBuffer(obj)) {\n    var len = checked(obj.length) | 0\n    var buf = createBuffer(len)\n\n    if (buf.length === 0) {\n      return buf\n    }\n\n    obj.copy(buf, 0, 0, len)\n    return buf\n  }\n\n  if (obj.length !== undefined) {\n    if (typeof obj.length !== 'number' || numberIsNaN(obj.length)) {\n      return createBuffer(0)\n    }\n    return fromArrayLike(obj)\n  }\n\n  if (obj.type === 'Buffer' && Array.isArray(obj.data)) {\n    return fromArrayLike(obj.data)\n  }\n}\n\nfunction checked (length) {\n  // Note: cannot use `length < K_MAX_LENGTH` here because that fails when\n  // length is NaN (which is otherwise coerced to zero.)\n  if (length >= K_MAX_LENGTH) {\n    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +\n                         'size: 0x' + K_MAX_LENGTH.toString(16) + ' bytes')\n  }\n  return length | 0\n}\n\nfunction SlowBuffer (length) {\n  if (+length != length) { // eslint-disable-line eqeqeq\n    length = 0\n  }\n  return Buffer.alloc(+length)\n}\n\nBuffer.isBuffer = function isBuffer (b) {\n  return b != null && b._isBuffer === true &&\n    b !== Buffer.prototype // so Buffer.isBuffer(Buffer.prototype) will be false\n}\n\nBuffer.compare = function compare (a, b) {\n  if (isInstance(a, Uint8Array)) a = Buffer.from(a, a.offset, a.byteLength)\n  if (isInstance(b, Uint8Array)) b = Buffer.from(b, b.offset, b.byteLength)\n  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {\n    throw new TypeError(\n      'The \"buf1\", \"buf2\" arguments must be one of type Buffer or Uint8Array'\n    )\n  }\n\n  if (a === b) return 0\n\n  var x = a.length\n  var y = b.length\n\n  for (var i = 0, len = Math.min(x, y); i < len; ++i) {\n    if (a[i] !== b[i]) {\n      x = a[i]\n      y = b[i]\n      break\n    }\n  }\n\n  if (x < y) return -1\n  if (y < x) return 1\n  return 0\n}\n\nBuffer.isEncoding = function isEncoding (encoding) {\n  switch (String(encoding).toLowerCase()) {\n    case 'hex':\n    case 'utf8':\n    case 'utf-8':\n    case 'ascii':\n    case 'latin1':\n    case 'binary':\n    case 'base64':\n    case 'ucs2':\n    case 'ucs-2':\n    case 'utf16le':\n    case 'utf-16le':\n      return true\n    default:\n      return false\n  }\n}\n\nBuffer.concat = function concat (list, length) {\n  if (!Array.isArray(list)) {\n    throw new TypeError('\"list\" argument must be an Array of Buffers')\n  }\n\n  if (list.length === 0) {\n    return Buffer.alloc(0)\n  }\n\n  var i\n  if (length === undefined) {\n    length = 0\n    for (i = 0; i < list.length; ++i) {\n      length += list[i].length\n    }\n  }\n\n  var buffer = Buffer.allocUnsafe(length)\n  var pos = 0\n  for (i = 0; i < list.length; ++i) {\n    var buf = list[i]\n    if (isInstance(buf, Uint8Array)) {\n      if (pos + buf.length > buffer.length) {\n        Buffer.from(buf).copy(buffer, pos)\n      } else {\n        Uint8Array.prototype.set.call(\n          buffer,\n          buf,\n          pos\n        )\n      }\n    } else if (!Buffer.isBuffer(buf)) {\n      throw new TypeError('\"list\" argument must be an Array of Buffers')\n    } else {\n      buf.copy(buffer, pos)\n    }\n    pos += buf.length\n  }\n  return buffer\n}\n\nfunction byteLength (string, encoding) {\n  if (Buffer.isBuffer(string)) {\n    return string.length\n  }\n  if (ArrayBuffer.isView(string) || isInstance(string, ArrayBuffer)) {\n    return string.byteLength\n  }\n  if (typeof string !== 'string') {\n    throw new TypeError(\n      'The \"string\" argument must be one of type string, Buffer, or ArrayBuffer. ' +\n      'Received type ' + typeof string\n    )\n  }\n\n  var len = string.length\n  var mustMatch = (arguments.length > 2 && arguments[2] === true)\n  if (!mustMatch && len === 0) return 0\n\n  // Use a for loop to avoid recursion\n  var loweredCase = false\n  for (;;) {\n    switch (encoding) {\n      case 'ascii':\n      case 'latin1':\n      case 'binary':\n        return len\n      case 'utf8':\n      case 'utf-8':\n        return utf8ToBytes(string).length\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return len * 2\n      case 'hex':\n        return len >>> 1\n      case 'base64':\n        return base64ToBytes(string).length\n      default:\n        if (loweredCase) {\n          return mustMatch ? -1 : utf8ToBytes(string).length // assume utf8\n        }\n        encoding = ('' + encoding).toLowerCase()\n        loweredCase = true\n    }\n  }\n}\nBuffer.byteLength = byteLength\n\nfunction slowToString (encoding, start, end) {\n  var loweredCase = false\n\n  // No need to verify that \"this.length <= MAX_UINT32\" since it's a read-only\n  // property of a typed array.\n\n  // This behaves neither like String nor Uint8Array in that we set start/end\n  // to their upper/lower bounds if the value passed is out of range.\n  // undefined is handled specially as per ECMA-262 6th Edition,\n  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.\n  if (start === undefined || start < 0) {\n    start = 0\n  }\n  // Return early if start > this.length. Done here to prevent potential uint32\n  // coercion fail below.\n  if (start > this.length) {\n    return ''\n  }\n\n  if (end === undefined || end > this.length) {\n    end = this.length\n  }\n\n  if (end <= 0) {\n    return ''\n  }\n\n  // Force coercion to uint32. This will also coerce falsey/NaN values to 0.\n  end >>>= 0\n  start >>>= 0\n\n  if (end <= start) {\n    return ''\n  }\n\n  if (!encoding) encoding = 'utf8'\n\n  while (true) {\n    switch (encoding) {\n      case 'hex':\n        return hexSlice(this, start, end)\n\n      case 'utf8':\n      case 'utf-8':\n        return utf8Slice(this, start, end)\n\n      case 'ascii':\n        return asciiSlice(this, start, end)\n\n      case 'latin1':\n      case 'binary':\n        return latin1Slice(this, start, end)\n\n      case 'base64':\n        return base64Slice(this, start, end)\n\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return utf16leSlice(this, start, end)\n\n      default:\n        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)\n        encoding = (encoding + '').toLowerCase()\n        loweredCase = true\n    }\n  }\n}\n\n// This property is used by `Buffer.isBuffer` (and the `is-buffer` npm package)\n// to detect a Buffer instance. It's not possible to use `instanceof Buffer`\n// reliably in a browserify context because there could be multiple different\n// copies of the 'buffer' package in use. This method works even for Buffer\n// instances that were created from another copy of the `buffer` package.\n// See: https://github.com/feross/buffer/issues/154\nBuffer.prototype._isBuffer = true\n\nfunction swap (b, n, m) {\n  var i = b[n]\n  b[n] = b[m]\n  b[m] = i\n}\n\nBuffer.prototype.swap16 = function swap16 () {\n  var len = this.length\n  if (len % 2 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 16-bits')\n  }\n  for (var i = 0; i < len; i += 2) {\n    swap(this, i, i + 1)\n  }\n  return this\n}\n\nBuffer.prototype.swap32 = function swap32 () {\n  var len = this.length\n  if (len % 4 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 32-bits')\n  }\n  for (var i = 0; i < len; i += 4) {\n    swap(this, i, i + 3)\n    swap(this, i + 1, i + 2)\n  }\n  return this\n}\n\nBuffer.prototype.swap64 = function swap64 () {\n  var len = this.length\n  if (len % 8 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 64-bits')\n  }\n  for (var i = 0; i < len; i += 8) {\n    swap(this, i, i + 7)\n    swap(this, i + 1, i + 6)\n    swap(this, i + 2, i + 5)\n    swap(this, i + 3, i + 4)\n  }\n  return this\n}\n\nBuffer.prototype.toString = function toString () {\n  var length = this.length\n  if (length === 0) return ''\n  if (arguments.length === 0) return utf8Slice(this, 0, length)\n  return slowToString.apply(this, arguments)\n}\n\nBuffer.prototype.toLocaleString = Buffer.prototype.toString\n\nBuffer.prototype.equals = function equals (b) {\n  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')\n  if (this === b) return true\n  return Buffer.compare(this, b) === 0\n}\n\nBuffer.prototype.inspect = function inspect () {\n  var str = ''\n  var max = exports.INSPECT_MAX_BYTES\n  str = this.toString('hex', 0, max).replace(/(.{2})/g, '$1 ').trim()\n  if (this.length > max) str += ' ... '\n  return '<Buffer ' + str + '>'\n}\nif (customInspectSymbol) {\n  Buffer.prototype[customInspectSymbol] = Buffer.prototype.inspect\n}\n\nBuffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {\n  if (isInstance(target, Uint8Array)) {\n    target = Buffer.from(target, target.offset, target.byteLength)\n  }\n  if (!Buffer.isBuffer(target)) {\n    throw new TypeError(\n      'The \"target\" argument must be one of type Buffer or Uint8Array. ' +\n      'Received type ' + (typeof target)\n    )\n  }\n\n  if (start === undefined) {\n    start = 0\n  }\n  if (end === undefined) {\n    end = target ? target.length : 0\n  }\n  if (thisStart === undefined) {\n    thisStart = 0\n  }\n  if (thisEnd === undefined) {\n    thisEnd = this.length\n  }\n\n  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {\n    throw new RangeError('out of range index')\n  }\n\n  if (thisStart >= thisEnd && start >= end) {\n    return 0\n  }\n  if (thisStart >= thisEnd) {\n    return -1\n  }\n  if (start >= end) {\n    return 1\n  }\n\n  start >>>= 0\n  end >>>= 0\n  thisStart >>>= 0\n  thisEnd >>>= 0\n\n  if (this === target) return 0\n\n  var x = thisEnd - thisStart\n  var y = end - start\n  var len = Math.min(x, y)\n\n  var thisCopy = this.slice(thisStart, thisEnd)\n  var targetCopy = target.slice(start, end)\n\n  for (var i = 0; i < len; ++i) {\n    if (thisCopy[i] !== targetCopy[i]) {\n      x = thisCopy[i]\n      y = targetCopy[i]\n      break\n    }\n  }\n\n  if (x < y) return -1\n  if (y < x) return 1\n  return 0\n}\n\n// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,\n// OR the last index of `val` in `buffer` at offset <= `byteOffset`.\n//\n// Arguments:\n// - buffer - a Buffer to search\n// - val - a string, Buffer, or number\n// - byteOffset - an index into `buffer`; will be clamped to an int32\n// - encoding - an optional encoding, relevant is val is a string\n// - dir - true for indexOf, false for lastIndexOf\nfunction bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {\n  // Empty buffer means no match\n  if (buffer.length === 0) return -1\n\n  // Normalize byteOffset\n  if (typeof byteOffset === 'string') {\n    encoding = byteOffset\n    byteOffset = 0\n  } else if (byteOffset > 0x7fffffff) {\n    byteOffset = 0x7fffffff\n  } else if (byteOffset < -0x80000000) {\n    byteOffset = -0x80000000\n  }\n  byteOffset = +byteOffset // Coerce to Number.\n  if (numberIsNaN(byteOffset)) {\n    // byteOffset: it it's undefined, null, NaN, \"foo\", etc, search whole buffer\n    byteOffset = dir ? 0 : (buffer.length - 1)\n  }\n\n  // Normalize byteOffset: negative offsets start from the end of the buffer\n  if (byteOffset < 0) byteOffset = buffer.length + byteOffset\n  if (byteOffset >= buffer.length) {\n    if (dir) return -1\n    else byteOffset = buffer.length - 1\n  } else if (byteOffset < 0) {\n    if (dir) byteOffset = 0\n    else return -1\n  }\n\n  // Normalize val\n  if (typeof val === 'string') {\n    val = Buffer.from(val, encoding)\n  }\n\n  // Finally, search either indexOf (if dir is true) or lastIndexOf\n  if (Buffer.isBuffer(val)) {\n    // Special case: looking for empty string/buffer always fails\n    if (val.length === 0) {\n      return -1\n    }\n    return arrayIndexOf(buffer, val, byteOffset, encoding, dir)\n  } else if (typeof val === 'number') {\n    val = val & 0xFF // Search for a byte value [0-255]\n    if (typeof Uint8Array.prototype.indexOf === 'function') {\n      if (dir) {\n        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)\n      } else {\n        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)\n      }\n    }\n    return arrayIndexOf(buffer, [val], byteOffset, encoding, dir)\n  }\n\n  throw new TypeError('val must be string, number or Buffer')\n}\n\nfunction arrayIndexOf (arr, val, byteOffset, encoding, dir) {\n  var indexSize = 1\n  var arrLength = arr.length\n  var valLength = val.length\n\n  if (encoding !== undefined) {\n    encoding = String(encoding).toLowerCase()\n    if (encoding === 'ucs2' || encoding === 'ucs-2' ||\n        encoding === 'utf16le' || encoding === 'utf-16le') {\n      if (arr.length < 2 || val.length < 2) {\n        return -1\n      }\n      indexSize = 2\n      arrLength /= 2\n      valLength /= 2\n      byteOffset /= 2\n    }\n  }\n\n  function read (buf, i) {\n    if (indexSize === 1) {\n      return buf[i]\n    } else {\n      return buf.readUInt16BE(i * indexSize)\n    }\n  }\n\n  var i\n  if (dir) {\n    var foundIndex = -1\n    for (i = byteOffset; i < arrLength; i++) {\n      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {\n        if (foundIndex === -1) foundIndex = i\n        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize\n      } else {\n        if (foundIndex !== -1) i -= i - foundIndex\n        foundIndex = -1\n      }\n    }\n  } else {\n    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength\n    for (i = byteOffset; i >= 0; i--) {\n      var found = true\n      for (var j = 0; j < valLength; j++) {\n        if (read(arr, i + j) !== read(val, j)) {\n          found = false\n          break\n        }\n      }\n      if (found) return i\n    }\n  }\n\n  return -1\n}\n\nBuffer.prototype.includes = function includes (val, byteOffset, encoding) {\n  return this.indexOf(val, byteOffset, encoding) !== -1\n}\n\nBuffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {\n  return bidirectionalIndexOf(this, val, byteOffset, encoding, true)\n}\n\nBuffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {\n  return bidirectionalIndexOf(this, val, byteOffset, encoding, false)\n}\n\nfunction hexWrite (buf, string, offset, length) {\n  offset = Number(offset) || 0\n  var remaining = buf.length - offset\n  if (!length) {\n    length = remaining\n  } else {\n    length = Number(length)\n    if (length > remaining) {\n      length = remaining\n    }\n  }\n\n  var strLen = string.length\n\n  if (length > strLen / 2) {\n    length = strLen / 2\n  }\n  for (var i = 0; i < length; ++i) {\n    var parsed = parseInt(string.substr(i * 2, 2), 16)\n    if (numberIsNaN(parsed)) return i\n    buf[offset + i] = parsed\n  }\n  return i\n}\n\nfunction utf8Write (buf, string, offset, length) {\n  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)\n}\n\nfunction asciiWrite (buf, string, offset, length) {\n  return blitBuffer(asciiToBytes(string), buf, offset, length)\n}\n\nfunction base64Write (buf, string, offset, length) {\n  return blitBuffer(base64ToBytes(string), buf, offset, length)\n}\n\nfunction ucs2Write (buf, string, offset, length) {\n  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)\n}\n\nBuffer.prototype.write = function write (string, offset, length, encoding) {\n  // Buffer#write(string)\n  if (offset === undefined) {\n    encoding = 'utf8'\n    length = this.length\n    offset = 0\n  // Buffer#write(string, encoding)\n  } else if (length === undefined && typeof offset === 'string') {\n    encoding = offset\n    length = this.length\n    offset = 0\n  // Buffer#write(string, offset[, length][, encoding])\n  } else if (isFinite(offset)) {\n    offset = offset >>> 0\n    if (isFinite(length)) {\n      length = length >>> 0\n      if (encoding === undefined) encoding = 'utf8'\n    } else {\n      encoding = length\n      length = undefined\n    }\n  } else {\n    throw new Error(\n      'Buffer.write(string, encoding, offset[, length]) is no longer supported'\n    )\n  }\n\n  var remaining = this.length - offset\n  if (length === undefined || length > remaining) length = remaining\n\n  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {\n    throw new RangeError('Attempt to write outside buffer bounds')\n  }\n\n  if (!encoding) encoding = 'utf8'\n\n  var loweredCase = false\n  for (;;) {\n    switch (encoding) {\n      case 'hex':\n        return hexWrite(this, string, offset, length)\n\n      case 'utf8':\n      case 'utf-8':\n        return utf8Write(this, string, offset, length)\n\n      case 'ascii':\n      case 'latin1':\n      case 'binary':\n        return asciiWrite(this, string, offset, length)\n\n      case 'base64':\n        // Warning: maxLength not taken into account in base64Write\n        return base64Write(this, string, offset, length)\n\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return ucs2Write(this, string, offset, length)\n\n      default:\n        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)\n        encoding = ('' + encoding).toLowerCase()\n        loweredCase = true\n    }\n  }\n}\n\nBuffer.prototype.toJSON = function toJSON () {\n  return {\n    type: 'Buffer',\n    data: Array.prototype.slice.call(this._arr || this, 0)\n  }\n}\n\nfunction base64Slice (buf, start, end) {\n  if (start === 0 && end === buf.length) {\n    return base64.fromByteArray(buf)\n  } else {\n    return base64.fromByteArray(buf.slice(start, end))\n  }\n}\n\nfunction utf8Slice (buf, start, end) {\n  end = Math.min(buf.length, end)\n  var res = []\n\n  var i = start\n  while (i < end) {\n    var firstByte = buf[i]\n    var codePoint = null\n    var bytesPerSequence = (firstByte > 0xEF)\n      ? 4\n      : (firstByte > 0xDF)\n          ? 3\n          : (firstByte > 0xBF)\n              ? 2\n              : 1\n\n    if (i + bytesPerSequence <= end) {\n      var secondByte, thirdByte, fourthByte, tempCodePoint\n\n      switch (bytesPerSequence) {\n        case 1:\n          if (firstByte < 0x80) {\n            codePoint = firstByte\n          }\n          break\n        case 2:\n          secondByte = buf[i + 1]\n          if ((secondByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)\n            if (tempCodePoint > 0x7F) {\n              codePoint = tempCodePoint\n            }\n          }\n          break\n        case 3:\n          secondByte = buf[i + 1]\n          thirdByte = buf[i + 2]\n          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)\n            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {\n              codePoint = tempCodePoint\n            }\n          }\n          break\n        case 4:\n          secondByte = buf[i + 1]\n          thirdByte = buf[i + 2]\n          fourthByte = buf[i + 3]\n          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)\n            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {\n              codePoint = tempCodePoint\n            }\n          }\n      }\n    }\n\n    if (codePoint === null) {\n      // we did not generate a valid codePoint so insert a\n      // replacement char (U+FFFD) and advance only 1 byte\n      codePoint = 0xFFFD\n      bytesPerSequence = 1\n    } else if (codePoint > 0xFFFF) {\n      // encode to utf16 (surrogate pair dance)\n      codePoint -= 0x10000\n      res.push(codePoint >>> 10 & 0x3FF | 0xD800)\n      codePoint = 0xDC00 | codePoint & 0x3FF\n    }\n\n    res.push(codePoint)\n    i += bytesPerSequence\n  }\n\n  return decodeCodePointsArray(res)\n}\n\n// Based on http://stackoverflow.com/a/22747272/680742, the browser with\n// the lowest limit is Chrome, with 0x10000 args.\n// We go 1 magnitude less, for safety\nvar MAX_ARGUMENTS_LENGTH = 0x1000\n\nfunction decodeCodePointsArray (codePoints) {\n  var len = codePoints.length\n  if (len <= MAX_ARGUMENTS_LENGTH) {\n    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()\n  }\n\n  // Decode in chunks to avoid \"call stack size exceeded\".\n  var res = ''\n  var i = 0\n  while (i < len) {\n    res += String.fromCharCode.apply(\n      String,\n      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)\n    )\n  }\n  return res\n}\n\nfunction asciiSlice (buf, start, end) {\n  var ret = ''\n  end = Math.min(buf.length, end)\n\n  for (var i = start; i < end; ++i) {\n    ret += String.fromCharCode(buf[i] & 0x7F)\n  }\n  return ret\n}\n\nfunction latin1Slice (buf, start, end) {\n  var ret = ''\n  end = Math.min(buf.length, end)\n\n  for (var i = start; i < end; ++i) {\n    ret += String.fromCharCode(buf[i])\n  }\n  return ret\n}\n\nfunction hexSlice (buf, start, end) {\n  var len = buf.length\n\n  if (!start || start < 0) start = 0\n  if (!end || end < 0 || end > len) end = len\n\n  var out = ''\n  for (var i = start; i < end; ++i) {\n    out += hexSliceLookupTable[buf[i]]\n  }\n  return out\n}\n\nfunction utf16leSlice (buf, start, end) {\n  var bytes = buf.slice(start, end)\n  var res = ''\n  // If bytes.length is odd, the last 8 bits must be ignored (same as node.js)\n  for (var i = 0; i < bytes.length - 1; i += 2) {\n    res += String.fromCharCode(bytes[i] + (bytes[i + 1] * 256))\n  }\n  return res\n}\n\nBuffer.prototype.slice = function slice (start, end) {\n  var len = this.length\n  start = ~~start\n  end = end === undefined ? len : ~~end\n\n  if (start < 0) {\n    start += len\n    if (start < 0) start = 0\n  } else if (start > len) {\n    start = len\n  }\n\n  if (end < 0) {\n    end += len\n    if (end < 0) end = 0\n  } else if (end > len) {\n    end = len\n  }\n\n  if (end < start) end = start\n\n  var newBuf = this.subarray(start, end)\n  // Return an augmented `Uint8Array` instance\n  Object.setPrototypeOf(newBuf, Buffer.prototype)\n\n  return newBuf\n}\n\n/*\n * Need to make sure that buffer isn't trying to write out of bounds.\n */\nfunction checkOffset (offset, ext, length) {\n  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')\n  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')\n}\n\nBuffer.prototype.readUintLE =\nBuffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {\n  offset = offset >>> 0\n  byteLength = byteLength >>> 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  var val = this[offset]\n  var mul = 1\n  var i = 0\n  while (++i < byteLength && (mul *= 0x100)) {\n    val += this[offset + i] * mul\n  }\n\n  return val\n}\n\nBuffer.prototype.readUintBE =\nBuffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {\n  offset = offset >>> 0\n  byteLength = byteLength >>> 0\n  if (!noAssert) {\n    checkOffset(offset, byteLength, this.length)\n  }\n\n  var val = this[offset + --byteLength]\n  var mul = 1\n  while (byteLength > 0 && (mul *= 0x100)) {\n    val += this[offset + --byteLength] * mul\n  }\n\n  return val\n}\n\nBuffer.prototype.readUint8 =\nBuffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 1, this.length)\n  return this[offset]\n}\n\nBuffer.prototype.readUint16LE =\nBuffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  return this[offset] | (this[offset + 1] << 8)\n}\n\nBuffer.prototype.readUint16BE =\nBuffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  return (this[offset] << 8) | this[offset + 1]\n}\n\nBuffer.prototype.readUint32LE =\nBuffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return ((this[offset]) |\n      (this[offset + 1] << 8) |\n      (this[offset + 2] << 16)) +\n      (this[offset + 3] * 0x1000000)\n}\n\nBuffer.prototype.readUint32BE =\nBuffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset] * 0x1000000) +\n    ((this[offset + 1] << 16) |\n    (this[offset + 2] << 8) |\n    this[offset + 3])\n}\n\nBuffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {\n  offset = offset >>> 0\n  byteLength = byteLength >>> 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  var val = this[offset]\n  var mul = 1\n  var i = 0\n  while (++i < byteLength && (mul *= 0x100)) {\n    val += this[offset + i] * mul\n  }\n  mul *= 0x80\n\n  if (val >= mul) val -= Math.pow(2, 8 * byteLength)\n\n  return val\n}\n\nBuffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {\n  offset = offset >>> 0\n  byteLength = byteLength >>> 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  var i = byteLength\n  var mul = 1\n  var val = this[offset + --i]\n  while (i > 0 && (mul *= 0x100)) {\n    val += this[offset + --i] * mul\n  }\n  mul *= 0x80\n\n  if (val >= mul) val -= Math.pow(2, 8 * byteLength)\n\n  return val\n}\n\nBuffer.prototype.readInt8 = function readInt8 (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 1, this.length)\n  if (!(this[offset] & 0x80)) return (this[offset])\n  return ((0xff - this[offset] + 1) * -1)\n}\n\nBuffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  var val = this[offset] | (this[offset + 1] << 8)\n  return (val & 0x8000) ? val | 0xFFFF0000 : val\n}\n\nBuffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  var val = this[offset + 1] | (this[offset] << 8)\n  return (val & 0x8000) ? val | 0xFFFF0000 : val\n}\n\nBuffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset]) |\n    (this[offset + 1] << 8) |\n    (this[offset + 2] << 16) |\n    (this[offset + 3] << 24)\n}\n\nBuffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset] << 24) |\n    (this[offset + 1] << 16) |\n    (this[offset + 2] << 8) |\n    (this[offset + 3])\n}\n\nBuffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 4, this.length)\n  return ieee754.read(this, offset, true, 23, 4)\n}\n\nBuffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 4, this.length)\n  return ieee754.read(this, offset, false, 23, 4)\n}\n\nBuffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 8, this.length)\n  return ieee754.read(this, offset, true, 52, 8)\n}\n\nBuffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 8, this.length)\n  return ieee754.read(this, offset, false, 52, 8)\n}\n\nfunction checkInt (buf, value, offset, ext, max, min) {\n  if (!Buffer.isBuffer(buf)) throw new TypeError('\"buffer\" argument must be a Buffer instance')\n  if (value > max || value < min) throw new RangeError('\"value\" argument is out of bounds')\n  if (offset + ext > buf.length) throw new RangeError('Index out of range')\n}\n\nBuffer.prototype.writeUintLE =\nBuffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  byteLength = byteLength >>> 0\n  if (!noAssert) {\n    var maxBytes = Math.pow(2, 8 * byteLength) - 1\n    checkInt(this, value, offset, byteLength, maxBytes, 0)\n  }\n\n  var mul = 1\n  var i = 0\n  this[offset] = value & 0xFF\n  while (++i < byteLength && (mul *= 0x100)) {\n    this[offset + i] = (value / mul) & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeUintBE =\nBuffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  byteLength = byteLength >>> 0\n  if (!noAssert) {\n    var maxBytes = Math.pow(2, 8 * byteLength) - 1\n    checkInt(this, value, offset, byteLength, maxBytes, 0)\n  }\n\n  var i = byteLength - 1\n  var mul = 1\n  this[offset + i] = value & 0xFF\n  while (--i >= 0 && (mul *= 0x100)) {\n    this[offset + i] = (value / mul) & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeUint8 =\nBuffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)\n  this[offset] = (value & 0xff)\n  return offset + 1\n}\n\nBuffer.prototype.writeUint16LE =\nBuffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)\n  this[offset] = (value & 0xff)\n  this[offset + 1] = (value >>> 8)\n  return offset + 2\n}\n\nBuffer.prototype.writeUint16BE =\nBuffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)\n  this[offset] = (value >>> 8)\n  this[offset + 1] = (value & 0xff)\n  return offset + 2\n}\n\nBuffer.prototype.writeUint32LE =\nBuffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)\n  this[offset + 3] = (value >>> 24)\n  this[offset + 2] = (value >>> 16)\n  this[offset + 1] = (value >>> 8)\n  this[offset] = (value & 0xff)\n  return offset + 4\n}\n\nBuffer.prototype.writeUint32BE =\nBuffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)\n  this[offset] = (value >>> 24)\n  this[offset + 1] = (value >>> 16)\n  this[offset + 2] = (value >>> 8)\n  this[offset + 3] = (value & 0xff)\n  return offset + 4\n}\n\nBuffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) {\n    var limit = Math.pow(2, (8 * byteLength) - 1)\n\n    checkInt(this, value, offset, byteLength, limit - 1, -limit)\n  }\n\n  var i = 0\n  var mul = 1\n  var sub = 0\n  this[offset] = value & 0xFF\n  while (++i < byteLength && (mul *= 0x100)) {\n    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {\n      sub = 1\n    }\n    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) {\n    var limit = Math.pow(2, (8 * byteLength) - 1)\n\n    checkInt(this, value, offset, byteLength, limit - 1, -limit)\n  }\n\n  var i = byteLength - 1\n  var mul = 1\n  var sub = 0\n  this[offset + i] = value & 0xFF\n  while (--i >= 0 && (mul *= 0x100)) {\n    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {\n      sub = 1\n    }\n    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)\n  if (value < 0) value = 0xff + value + 1\n  this[offset] = (value & 0xff)\n  return offset + 1\n}\n\nBuffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)\n  this[offset] = (value & 0xff)\n  this[offset + 1] = (value >>> 8)\n  return offset + 2\n}\n\nBuffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)\n  this[offset] = (value >>> 8)\n  this[offset + 1] = (value & 0xff)\n  return offset + 2\n}\n\nBuffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)\n  this[offset] = (value & 0xff)\n  this[offset + 1] = (value >>> 8)\n  this[offset + 2] = (value >>> 16)\n  this[offset + 3] = (value >>> 24)\n  return offset + 4\n}\n\nBuffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)\n  if (value < 0) value = 0xffffffff + value + 1\n  this[offset] = (value >>> 24)\n  this[offset + 1] = (value >>> 16)\n  this[offset + 2] = (value >>> 8)\n  this[offset + 3] = (value & 0xff)\n  return offset + 4\n}\n\nfunction checkIEEE754 (buf, value, offset, ext, max, min) {\n  if (offset + ext > buf.length) throw new RangeError('Index out of range')\n  if (offset < 0) throw new RangeError('Index out of range')\n}\n\nfunction writeFloat (buf, value, offset, littleEndian, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) {\n    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)\n  }\n  ieee754.write(buf, value, offset, littleEndian, 23, 4)\n  return offset + 4\n}\n\nBuffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {\n  return writeFloat(this, value, offset, true, noAssert)\n}\n\nBuffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {\n  return writeFloat(this, value, offset, false, noAssert)\n}\n\nfunction writeDouble (buf, value, offset, littleEndian, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) {\n    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)\n  }\n  ieee754.write(buf, value, offset, littleEndian, 52, 8)\n  return offset + 8\n}\n\nBuffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {\n  return writeDouble(this, value, offset, true, noAssert)\n}\n\nBuffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {\n  return writeDouble(this, value, offset, false, noAssert)\n}\n\n// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)\nBuffer.prototype.copy = function copy (target, targetStart, start, end) {\n  if (!Buffer.isBuffer(target)) throw new TypeError('argument should be a Buffer')\n  if (!start) start = 0\n  if (!end && end !== 0) end = this.length\n  if (targetStart >= target.length) targetStart = target.length\n  if (!targetStart) targetStart = 0\n  if (end > 0 && end < start) end = start\n\n  // Copy 0 bytes; we're done\n  if (end === start) return 0\n  if (target.length === 0 || this.length === 0) return 0\n\n  // Fatal error conditions\n  if (targetStart < 0) {\n    throw new RangeError('targetStart out of bounds')\n  }\n  if (start < 0 || start >= this.length) throw new RangeError('Index out of range')\n  if (end < 0) throw new RangeError('sourceEnd out of bounds')\n\n  // Are we oob?\n  if (end > this.length) end = this.length\n  if (target.length - targetStart < end - start) {\n    end = target.length - targetStart + start\n  }\n\n  var len = end - start\n\n  if (this === target && typeof Uint8Array.prototype.copyWithin === 'function') {\n    // Use built-in when available, missing from IE11\n    this.copyWithin(targetStart, start, end)\n  } else {\n    Uint8Array.prototype.set.call(\n      target,\n      this.subarray(start, end),\n      targetStart\n    )\n  }\n\n  return len\n}\n\n// Usage:\n//    buffer.fill(number[, offset[, end]])\n//    buffer.fill(buffer[, offset[, end]])\n//    buffer.fill(string[, offset[, end]][, encoding])\nBuffer.prototype.fill = function fill (val, start, end, encoding) {\n  // Handle string cases:\n  if (typeof val === 'string') {\n    if (typeof start === 'string') {\n      encoding = start\n      start = 0\n      end = this.length\n    } else if (typeof end === 'string') {\n      encoding = end\n      end = this.length\n    }\n    if (encoding !== undefined && typeof encoding !== 'string') {\n      throw new TypeError('encoding must be a string')\n    }\n    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {\n      throw new TypeError('Unknown encoding: ' + encoding)\n    }\n    if (val.length === 1) {\n      var code = val.charCodeAt(0)\n      if ((encoding === 'utf8' && code < 128) ||\n          encoding === 'latin1') {\n        // Fast path: If `val` fits into a single byte, use that numeric value.\n        val = code\n      }\n    }\n  } else if (typeof val === 'number') {\n    val = val & 255\n  } else if (typeof val === 'boolean') {\n    val = Number(val)\n  }\n\n  // Invalid ranges are not set to a default, so can range check early.\n  if (start < 0 || this.length < start || this.length < end) {\n    throw new RangeError('Out of range index')\n  }\n\n  if (end <= start) {\n    return this\n  }\n\n  start = start >>> 0\n  end = end === undefined ? this.length : end >>> 0\n\n  if (!val) val = 0\n\n  var i\n  if (typeof val === 'number') {\n    for (i = start; i < end; ++i) {\n      this[i] = val\n    }\n  } else {\n    var bytes = Buffer.isBuffer(val)\n      ? val\n      : Buffer.from(val, encoding)\n    var len = bytes.length\n    if (len === 0) {\n      throw new TypeError('The value \"' + val +\n        '\" is invalid for argument \"value\"')\n    }\n    for (i = 0; i < end - start; ++i) {\n      this[i + start] = bytes[i % len]\n    }\n  }\n\n  return this\n}\n\n// HELPER FUNCTIONS\n// ================\n\nvar INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g\n\nfunction base64clean (str) {\n  // Node takes equal signs as end of the Base64 encoding\n  str = str.split('=')[0]\n  // Node strips out invalid characters like \\n and \\t from the string, base64-js does not\n  str = str.trim().replace(INVALID_BASE64_RE, '')\n  // Node converts strings with length < 2 to ''\n  if (str.length < 2) return ''\n  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not\n  while (str.length % 4 !== 0) {\n    str = str + '='\n  }\n  return str\n}\n\nfunction utf8ToBytes (string, units) {\n  units = units || Infinity\n  var codePoint\n  var length = string.length\n  var leadSurrogate = null\n  var bytes = []\n\n  for (var i = 0; i < length; ++i) {\n    codePoint = string.charCodeAt(i)\n\n    // is surrogate component\n    if (codePoint > 0xD7FF && codePoint < 0xE000) {\n      // last char was a lead\n      if (!leadSurrogate) {\n        // no lead yet\n        if (codePoint > 0xDBFF) {\n          // unexpected trail\n          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n          continue\n        } else if (i + 1 === length) {\n          // unpaired lead\n          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n          continue\n        }\n\n        // valid lead\n        leadSurrogate = codePoint\n\n        continue\n      }\n\n      // 2 leads in a row\n      if (codePoint < 0xDC00) {\n        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n        leadSurrogate = codePoint\n        continue\n      }\n\n      // valid surrogate pair\n      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000\n    } else if (leadSurrogate) {\n      // valid bmp char, but last char was a lead\n      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n    }\n\n    leadSurrogate = null\n\n    // encode utf8\n    if (codePoint < 0x80) {\n      if ((units -= 1) < 0) break\n      bytes.push(codePoint)\n    } else if (codePoint < 0x800) {\n      if ((units -= 2) < 0) break\n      bytes.push(\n        codePoint >> 0x6 | 0xC0,\n        codePoint & 0x3F | 0x80\n      )\n    } else if (codePoint < 0x10000) {\n      if ((units -= 3) < 0) break\n      bytes.push(\n        codePoint >> 0xC | 0xE0,\n        codePoint >> 0x6 & 0x3F | 0x80,\n        codePoint & 0x3F | 0x80\n      )\n    } else if (codePoint < 0x110000) {\n      if ((units -= 4) < 0) break\n      bytes.push(\n        codePoint >> 0x12 | 0xF0,\n        codePoint >> 0xC & 0x3F | 0x80,\n        codePoint >> 0x6 & 0x3F | 0x80,\n        codePoint & 0x3F | 0x80\n      )\n    } else {\n      throw new Error('Invalid code point')\n    }\n  }\n\n  return bytes\n}\n\nfunction asciiToBytes (str) {\n  var byteArray = []\n  for (var i = 0; i < str.length; ++i) {\n    // Node's code seems to be doing this and not & 0x7F..\n    byteArray.push(str.charCodeAt(i) & 0xFF)\n  }\n  return byteArray\n}\n\nfunction utf16leToBytes (str, units) {\n  var c, hi, lo\n  var byteArray = []\n  for (var i = 0; i < str.length; ++i) {\n    if ((units -= 2) < 0) break\n\n    c = str.charCodeAt(i)\n    hi = c >> 8\n    lo = c % 256\n    byteArray.push(lo)\n    byteArray.push(hi)\n  }\n\n  return byteArray\n}\n\nfunction base64ToBytes (str) {\n  return base64.toByteArray(base64clean(str))\n}\n\nfunction blitBuffer (src, dst, offset, length) {\n  for (var i = 0; i < length; ++i) {\n    if ((i + offset >= dst.length) || (i >= src.length)) break\n    dst[i + offset] = src[i]\n  }\n  return i\n}\n\n// ArrayBuffer or Uint8Array objects from other contexts (i.e. iframes) do not pass\n// the `instanceof` check but they should be treated as of that type.\n// See: https://github.com/feross/buffer/issues/166\nfunction isInstance (obj, type) {\n  return obj instanceof type ||\n    (obj != null && obj.constructor != null && obj.constructor.name != null &&\n      obj.constructor.name === type.name)\n}\nfunction numberIsNaN (obj) {\n  // For IE11 support\n  return obj !== obj // eslint-disable-line no-self-compare\n}\n\n// Create lookup table for `toString('hex')`\n// See: https://github.com/feross/buffer/issues/219\nvar hexSliceLookupTable = (function () {\n  var alphabet = '0123456789abcdef'\n  var table = new Array(256)\n  for (var i = 0; i < 16; ++i) {\n    var i16 = i * 16\n    for (var j = 0; j < 16; ++j) {\n      table[i16 + j] = alphabet[i] + alphabet[j]\n    }\n  }\n  return table\n})()\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vLi4vbm9kZV9tb2R1bGVzL2J1ZmZlci9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFWTs7QUFFWixhQUFhLG1CQUFPLENBQUMsd0RBQVc7QUFDaEMsY0FBYyxtQkFBTyxDQUFDLG9EQUFTO0FBQy9CO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGNBQWM7QUFDZCxrQkFBa0I7QUFDbEIseUJBQXlCOztBQUV6QjtBQUNBLGtCQUFrQjs7QUFFbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLG1CQUFtQjtBQUNyQztBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixZQUFZO0FBQzlCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQSx3Q0FBd0MsU0FBUztBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsaUJBQWlCO0FBQ2pDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsY0FBYyxpQkFBaUI7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsU0FBUztBQUMzQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLFNBQVM7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLFNBQVM7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsaURBQWlELEVBQUU7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLGtCQUFrQixTQUFTO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEM7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsZUFBZTtBQUN4QztBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSx5QkFBeUIsUUFBUTtBQUNqQztBQUNBLHNCQUFzQixlQUFlO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLFlBQVk7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLHNCQUFzQixTQUFTO0FBQy9CO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxzQkFBc0IsU0FBUztBQUMvQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxzQkFBc0IsU0FBUztBQUMvQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixzQkFBc0I7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxtQkFBbUI7QUFDbkI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLG9CQUFvQixTQUFTO0FBQzdCO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixpQkFBaUI7QUFDakM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsa0JBQWtCLFlBQVk7QUFDOUI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGtCQUFrQixnQkFBZ0I7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsZ0JBQWdCO0FBQ2xDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGtCQUFrQixZQUFZO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsUUFBUTtBQUMxQjtBQUNBLG9CQUFvQixRQUFRO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi4vLi4vbm9kZV9tb2R1bGVzL2J1ZmZlci9pbmRleC5qcz8yODY4Il0sInNvdXJjZXNDb250ZW50IjpbIi8qIVxuICogVGhlIGJ1ZmZlciBtb2R1bGUgZnJvbSBub2RlLmpzLCBmb3IgdGhlIGJyb3dzZXIuXG4gKlxuICogQGF1dGhvciAgIEZlcm9zcyBBYm91a2hhZGlqZWggPGh0dHBzOi8vZmVyb3NzLm9yZz5cbiAqIEBsaWNlbnNlICBNSVRcbiAqL1xuLyogZXNsaW50LWRpc2FibGUgbm8tcHJvdG8gKi9cblxuJ3VzZSBzdHJpY3QnXG5cbnZhciBiYXNlNjQgPSByZXF1aXJlKCdiYXNlNjQtanMnKVxudmFyIGllZWU3NTQgPSByZXF1aXJlKCdpZWVlNzU0JylcbnZhciBjdXN0b21JbnNwZWN0U3ltYm9sID1cbiAgKHR5cGVvZiBTeW1ib2wgPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIFN5bWJvbFsnZm9yJ10gPT09ICdmdW5jdGlvbicpIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgZG90LW5vdGF0aW9uXG4gICAgPyBTeW1ib2xbJ2ZvciddKCdub2RlanMudXRpbC5pbnNwZWN0LmN1c3RvbScpIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgZG90LW5vdGF0aW9uXG4gICAgOiBudWxsXG5cbmV4cG9ydHMuQnVmZmVyID0gQnVmZmVyXG5leHBvcnRzLlNsb3dCdWZmZXIgPSBTbG93QnVmZmVyXG5leHBvcnRzLklOU1BFQ1RfTUFYX0JZVEVTID0gNTBcblxudmFyIEtfTUFYX0xFTkdUSCA9IDB4N2ZmZmZmZmZcbmV4cG9ydHMua01heExlbmd0aCA9IEtfTUFYX0xFTkdUSFxuXG4vKipcbiAqIElmIGBCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVGA6XG4gKiAgID09PSB0cnVlICAgIFVzZSBVaW50OEFycmF5IGltcGxlbWVudGF0aW9uIChmYXN0ZXN0KVxuICogICA9PT0gZmFsc2UgICBQcmludCB3YXJuaW5nIGFuZCByZWNvbW1lbmQgdXNpbmcgYGJ1ZmZlcmAgdjQueCB3aGljaCBoYXMgYW4gT2JqZWN0XG4gKiAgICAgICAgICAgICAgIGltcGxlbWVudGF0aW9uIChtb3N0IGNvbXBhdGlibGUsIGV2ZW4gSUU2KVxuICpcbiAqIEJyb3dzZXJzIHRoYXQgc3VwcG9ydCB0eXBlZCBhcnJheXMgYXJlIElFIDEwKywgRmlyZWZveCA0KywgQ2hyb21lIDcrLCBTYWZhcmkgNS4xKyxcbiAqIE9wZXJhIDExLjYrLCBpT1MgNC4yKy5cbiAqXG4gKiBXZSByZXBvcnQgdGhhdCB0aGUgYnJvd3NlciBkb2VzIG5vdCBzdXBwb3J0IHR5cGVkIGFycmF5cyBpZiB0aGUgYXJlIG5vdCBzdWJjbGFzc2FibGVcbiAqIHVzaW5nIF9fcHJvdG9fXy4gRmlyZWZveCA0LTI5IGxhY2tzIHN1cHBvcnQgZm9yIGFkZGluZyBuZXcgcHJvcGVydGllcyB0byBgVWludDhBcnJheWBcbiAqIChTZWU6IGh0dHBzOi8vYnVnemlsbGEubW96aWxsYS5vcmcvc2hvd19idWcuY2dpP2lkPTY5NTQzOCkuIElFIDEwIGxhY2tzIHN1cHBvcnRcbiAqIGZvciBfX3Byb3RvX18gYW5kIGhhcyBhIGJ1Z2d5IHR5cGVkIGFycmF5IGltcGxlbWVudGF0aW9uLlxuICovXG5CdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCA9IHR5cGVkQXJyYXlTdXBwb3J0KClcblxuaWYgKCFCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCAmJiB0eXBlb2YgY29uc29sZSAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgICB0eXBlb2YgY29uc29sZS5lcnJvciA9PT0gJ2Z1bmN0aW9uJykge1xuICBjb25zb2xlLmVycm9yKFxuICAgICdUaGlzIGJyb3dzZXIgbGFja3MgdHlwZWQgYXJyYXkgKFVpbnQ4QXJyYXkpIHN1cHBvcnQgd2hpY2ggaXMgcmVxdWlyZWQgYnkgJyArXG4gICAgJ2BidWZmZXJgIHY1LnguIFVzZSBgYnVmZmVyYCB2NC54IGlmIHlvdSByZXF1aXJlIG9sZCBicm93c2VyIHN1cHBvcnQuJ1xuICApXG59XG5cbmZ1bmN0aW9uIHR5cGVkQXJyYXlTdXBwb3J0ICgpIHtcbiAgLy8gQ2FuIHR5cGVkIGFycmF5IGluc3RhbmNlcyBjYW4gYmUgYXVnbWVudGVkP1xuICB0cnkge1xuICAgIHZhciBhcnIgPSBuZXcgVWludDhBcnJheSgxKVxuICAgIHZhciBwcm90byA9IHsgZm9vOiBmdW5jdGlvbiAoKSB7IHJldHVybiA0MiB9IH1cbiAgICBPYmplY3Quc2V0UHJvdG90eXBlT2YocHJvdG8sIFVpbnQ4QXJyYXkucHJvdG90eXBlKVxuICAgIE9iamVjdC5zZXRQcm90b3R5cGVPZihhcnIsIHByb3RvKVxuICAgIHJldHVybiBhcnIuZm9vKCkgPT09IDQyXG4gIH0gY2F0Y2ggKGUpIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxufVxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoQnVmZmVyLnByb3RvdHlwZSwgJ3BhcmVudCcsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKCFCdWZmZXIuaXNCdWZmZXIodGhpcykpIHJldHVybiB1bmRlZmluZWRcbiAgICByZXR1cm4gdGhpcy5idWZmZXJcbiAgfVxufSlcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KEJ1ZmZlci5wcm90b3R5cGUsICdvZmZzZXQnLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIGlmICghQnVmZmVyLmlzQnVmZmVyKHRoaXMpKSByZXR1cm4gdW5kZWZpbmVkXG4gICAgcmV0dXJuIHRoaXMuYnl0ZU9mZnNldFxuICB9XG59KVxuXG5mdW5jdGlvbiBjcmVhdGVCdWZmZXIgKGxlbmd0aCkge1xuICBpZiAobGVuZ3RoID4gS19NQVhfTEVOR1RIKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1RoZSB2YWx1ZSBcIicgKyBsZW5ndGggKyAnXCIgaXMgaW52YWxpZCBmb3Igb3B0aW9uIFwic2l6ZVwiJylcbiAgfVxuICAvLyBSZXR1cm4gYW4gYXVnbWVudGVkIGBVaW50OEFycmF5YCBpbnN0YW5jZVxuICB2YXIgYnVmID0gbmV3IFVpbnQ4QXJyYXkobGVuZ3RoKVxuICBPYmplY3Quc2V0UHJvdG90eXBlT2YoYnVmLCBCdWZmZXIucHJvdG90eXBlKVxuICByZXR1cm4gYnVmXG59XG5cbi8qKlxuICogVGhlIEJ1ZmZlciBjb25zdHJ1Y3RvciByZXR1cm5zIGluc3RhbmNlcyBvZiBgVWludDhBcnJheWAgdGhhdCBoYXZlIHRoZWlyXG4gKiBwcm90b3R5cGUgY2hhbmdlZCB0byBgQnVmZmVyLnByb3RvdHlwZWAuIEZ1cnRoZXJtb3JlLCBgQnVmZmVyYCBpcyBhIHN1YmNsYXNzIG9mXG4gKiBgVWludDhBcnJheWAsIHNvIHRoZSByZXR1cm5lZCBpbnN0YW5jZXMgd2lsbCBoYXZlIGFsbCB0aGUgbm9kZSBgQnVmZmVyYCBtZXRob2RzXG4gKiBhbmQgdGhlIGBVaW50OEFycmF5YCBtZXRob2RzLiBTcXVhcmUgYnJhY2tldCBub3RhdGlvbiB3b3JrcyBhcyBleHBlY3RlZCAtLSBpdFxuICogcmV0dXJucyBhIHNpbmdsZSBvY3RldC5cbiAqXG4gKiBUaGUgYFVpbnQ4QXJyYXlgIHByb3RvdHlwZSByZW1haW5zIHVubW9kaWZpZWQuXG4gKi9cblxuZnVuY3Rpb24gQnVmZmVyIChhcmcsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aCkge1xuICAvLyBDb21tb24gY2FzZS5cbiAgaWYgKHR5cGVvZiBhcmcgPT09ICdudW1iZXInKSB7XG4gICAgaWYgKHR5cGVvZiBlbmNvZGluZ09yT2Zmc2V0ID09PSAnc3RyaW5nJykge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAgICAgJ1RoZSBcInN0cmluZ1wiIGFyZ3VtZW50IG11c3QgYmUgb2YgdHlwZSBzdHJpbmcuIFJlY2VpdmVkIHR5cGUgbnVtYmVyJ1xuICAgICAgKVxuICAgIH1cbiAgICByZXR1cm4gYWxsb2NVbnNhZmUoYXJnKVxuICB9XG4gIHJldHVybiBmcm9tKGFyZywgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKVxufVxuXG5CdWZmZXIucG9vbFNpemUgPSA4MTkyIC8vIG5vdCB1c2VkIGJ5IHRoaXMgaW1wbGVtZW50YXRpb25cblxuZnVuY3Rpb24gZnJvbSAodmFsdWUsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aCkge1xuICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiBmcm9tU3RyaW5nKHZhbHVlLCBlbmNvZGluZ09yT2Zmc2V0KVxuICB9XG5cbiAgaWYgKEFycmF5QnVmZmVyLmlzVmlldyh2YWx1ZSkpIHtcbiAgICByZXR1cm4gZnJvbUFycmF5Vmlldyh2YWx1ZSlcbiAgfVxuXG4gIGlmICh2YWx1ZSA9PSBudWxsKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAgICdUaGUgZmlyc3QgYXJndW1lbnQgbXVzdCBiZSBvbmUgb2YgdHlwZSBzdHJpbmcsIEJ1ZmZlciwgQXJyYXlCdWZmZXIsIEFycmF5LCAnICtcbiAgICAgICdvciBBcnJheS1saWtlIE9iamVjdC4gUmVjZWl2ZWQgdHlwZSAnICsgKHR5cGVvZiB2YWx1ZSlcbiAgICApXG4gIH1cblxuICBpZiAoaXNJbnN0YW5jZSh2YWx1ZSwgQXJyYXlCdWZmZXIpIHx8XG4gICAgICAodmFsdWUgJiYgaXNJbnN0YW5jZSh2YWx1ZS5idWZmZXIsIEFycmF5QnVmZmVyKSkpIHtcbiAgICByZXR1cm4gZnJvbUFycmF5QnVmZmVyKHZhbHVlLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpXG4gIH1cblxuICBpZiAodHlwZW9mIFNoYXJlZEFycmF5QnVmZmVyICE9PSAndW5kZWZpbmVkJyAmJlxuICAgICAgKGlzSW5zdGFuY2UodmFsdWUsIFNoYXJlZEFycmF5QnVmZmVyKSB8fFxuICAgICAgKHZhbHVlICYmIGlzSW5zdGFuY2UodmFsdWUuYnVmZmVyLCBTaGFyZWRBcnJheUJ1ZmZlcikpKSkge1xuICAgIHJldHVybiBmcm9tQXJyYXlCdWZmZXIodmFsdWUsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aClcbiAgfVxuXG4gIGlmICh0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAgICdUaGUgXCJ2YWx1ZVwiIGFyZ3VtZW50IG11c3Qgbm90IGJlIG9mIHR5cGUgbnVtYmVyLiBSZWNlaXZlZCB0eXBlIG51bWJlcidcbiAgICApXG4gIH1cblxuICB2YXIgdmFsdWVPZiA9IHZhbHVlLnZhbHVlT2YgJiYgdmFsdWUudmFsdWVPZigpXG4gIGlmICh2YWx1ZU9mICE9IG51bGwgJiYgdmFsdWVPZiAhPT0gdmFsdWUpIHtcbiAgICByZXR1cm4gQnVmZmVyLmZyb20odmFsdWVPZiwgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKVxuICB9XG5cbiAgdmFyIGIgPSBmcm9tT2JqZWN0KHZhbHVlKVxuICBpZiAoYikgcmV0dXJuIGJcblxuICBpZiAodHlwZW9mIFN5bWJvbCAhPT0gJ3VuZGVmaW5lZCcgJiYgU3ltYm9sLnRvUHJpbWl0aXZlICE9IG51bGwgJiZcbiAgICAgIHR5cGVvZiB2YWx1ZVtTeW1ib2wudG9QcmltaXRpdmVdID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIEJ1ZmZlci5mcm9tKFxuICAgICAgdmFsdWVbU3ltYm9sLnRvUHJpbWl0aXZlXSgnc3RyaW5nJyksIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aFxuICAgIClcbiAgfVxuXG4gIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgJ1RoZSBmaXJzdCBhcmd1bWVudCBtdXN0IGJlIG9uZSBvZiB0eXBlIHN0cmluZywgQnVmZmVyLCBBcnJheUJ1ZmZlciwgQXJyYXksICcgK1xuICAgICdvciBBcnJheS1saWtlIE9iamVjdC4gUmVjZWl2ZWQgdHlwZSAnICsgKHR5cGVvZiB2YWx1ZSlcbiAgKVxufVxuXG4vKipcbiAqIEZ1bmN0aW9uYWxseSBlcXVpdmFsZW50IHRvIEJ1ZmZlcihhcmcsIGVuY29kaW5nKSBidXQgdGhyb3dzIGEgVHlwZUVycm9yXG4gKiBpZiB2YWx1ZSBpcyBhIG51bWJlci5cbiAqIEJ1ZmZlci5mcm9tKHN0clssIGVuY29kaW5nXSlcbiAqIEJ1ZmZlci5mcm9tKGFycmF5KVxuICogQnVmZmVyLmZyb20oYnVmZmVyKVxuICogQnVmZmVyLmZyb20oYXJyYXlCdWZmZXJbLCBieXRlT2Zmc2V0WywgbGVuZ3RoXV0pXG4gKiovXG5CdWZmZXIuZnJvbSA9IGZ1bmN0aW9uICh2YWx1ZSwgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKSB7XG4gIHJldHVybiBmcm9tKHZhbHVlLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpXG59XG5cbi8vIE5vdGU6IENoYW5nZSBwcm90b3R5cGUgKmFmdGVyKiBCdWZmZXIuZnJvbSBpcyBkZWZpbmVkIHRvIHdvcmthcm91bmQgQ2hyb21lIGJ1Zzpcbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9mZXJvc3MvYnVmZmVyL3B1bGwvMTQ4XG5PYmplY3Quc2V0UHJvdG90eXBlT2YoQnVmZmVyLnByb3RvdHlwZSwgVWludDhBcnJheS5wcm90b3R5cGUpXG5PYmplY3Quc2V0UHJvdG90eXBlT2YoQnVmZmVyLCBVaW50OEFycmF5KVxuXG5mdW5jdGlvbiBhc3NlcnRTaXplIChzaXplKSB7XG4gIGlmICh0eXBlb2Ygc2l6ZSAhPT0gJ251bWJlcicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcInNpemVcIiBhcmd1bWVudCBtdXN0IGJlIG9mIHR5cGUgbnVtYmVyJylcbiAgfSBlbHNlIGlmIChzaXplIDwgMCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdUaGUgdmFsdWUgXCInICsgc2l6ZSArICdcIiBpcyBpbnZhbGlkIGZvciBvcHRpb24gXCJzaXplXCInKVxuICB9XG59XG5cbmZ1bmN0aW9uIGFsbG9jIChzaXplLCBmaWxsLCBlbmNvZGluZykge1xuICBhc3NlcnRTaXplKHNpemUpXG4gIGlmIChzaXplIDw9IDApIHtcbiAgICByZXR1cm4gY3JlYXRlQnVmZmVyKHNpemUpXG4gIH1cbiAgaWYgKGZpbGwgIT09IHVuZGVmaW5lZCkge1xuICAgIC8vIE9ubHkgcGF5IGF0dGVudGlvbiB0byBlbmNvZGluZyBpZiBpdCdzIGEgc3RyaW5nLiBUaGlzXG4gICAgLy8gcHJldmVudHMgYWNjaWRlbnRhbGx5IHNlbmRpbmcgaW4gYSBudW1iZXIgdGhhdCB3b3VsZFxuICAgIC8vIGJlIGludGVycHJldGVkIGFzIGEgc3RhcnQgb2Zmc2V0LlxuICAgIHJldHVybiB0eXBlb2YgZW5jb2RpbmcgPT09ICdzdHJpbmcnXG4gICAgICA/IGNyZWF0ZUJ1ZmZlcihzaXplKS5maWxsKGZpbGwsIGVuY29kaW5nKVxuICAgICAgOiBjcmVhdGVCdWZmZXIoc2l6ZSkuZmlsbChmaWxsKVxuICB9XG4gIHJldHVybiBjcmVhdGVCdWZmZXIoc2l6ZSlcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IGZpbGxlZCBCdWZmZXIgaW5zdGFuY2UuXG4gKiBhbGxvYyhzaXplWywgZmlsbFssIGVuY29kaW5nXV0pXG4gKiovXG5CdWZmZXIuYWxsb2MgPSBmdW5jdGlvbiAoc2l6ZSwgZmlsbCwgZW5jb2RpbmcpIHtcbiAgcmV0dXJuIGFsbG9jKHNpemUsIGZpbGwsIGVuY29kaW5nKVxufVxuXG5mdW5jdGlvbiBhbGxvY1Vuc2FmZSAoc2l6ZSkge1xuICBhc3NlcnRTaXplKHNpemUpXG4gIHJldHVybiBjcmVhdGVCdWZmZXIoc2l6ZSA8IDAgPyAwIDogY2hlY2tlZChzaXplKSB8IDApXG59XG5cbi8qKlxuICogRXF1aXZhbGVudCB0byBCdWZmZXIobnVtKSwgYnkgZGVmYXVsdCBjcmVhdGVzIGEgbm9uLXplcm8tZmlsbGVkIEJ1ZmZlciBpbnN0YW5jZS5cbiAqICovXG5CdWZmZXIuYWxsb2NVbnNhZmUgPSBmdW5jdGlvbiAoc2l6ZSkge1xuICByZXR1cm4gYWxsb2NVbnNhZmUoc2l6ZSlcbn1cbi8qKlxuICogRXF1aXZhbGVudCB0byBTbG93QnVmZmVyKG51bSksIGJ5IGRlZmF1bHQgY3JlYXRlcyBhIG5vbi16ZXJvLWZpbGxlZCBCdWZmZXIgaW5zdGFuY2UuXG4gKi9cbkJ1ZmZlci5hbGxvY1Vuc2FmZVNsb3cgPSBmdW5jdGlvbiAoc2l6ZSkge1xuICByZXR1cm4gYWxsb2NVbnNhZmUoc2l6ZSlcbn1cblxuZnVuY3Rpb24gZnJvbVN0cmluZyAoc3RyaW5nLCBlbmNvZGluZykge1xuICBpZiAodHlwZW9mIGVuY29kaW5nICE9PSAnc3RyaW5nJyB8fCBlbmNvZGluZyA9PT0gJycpIHtcbiAgICBlbmNvZGluZyA9ICd1dGY4J1xuICB9XG5cbiAgaWYgKCFCdWZmZXIuaXNFbmNvZGluZyhlbmNvZGluZykpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdVbmtub3duIGVuY29kaW5nOiAnICsgZW5jb2RpbmcpXG4gIH1cblxuICB2YXIgbGVuZ3RoID0gYnl0ZUxlbmd0aChzdHJpbmcsIGVuY29kaW5nKSB8IDBcbiAgdmFyIGJ1ZiA9IGNyZWF0ZUJ1ZmZlcihsZW5ndGgpXG5cbiAgdmFyIGFjdHVhbCA9IGJ1Zi53cml0ZShzdHJpbmcsIGVuY29kaW5nKVxuXG4gIGlmIChhY3R1YWwgIT09IGxlbmd0aCkge1xuICAgIC8vIFdyaXRpbmcgYSBoZXggc3RyaW5nLCBmb3IgZXhhbXBsZSwgdGhhdCBjb250YWlucyBpbnZhbGlkIGNoYXJhY3RlcnMgd2lsbFxuICAgIC8vIGNhdXNlIGV2ZXJ5dGhpbmcgYWZ0ZXIgdGhlIGZpcnN0IGludmFsaWQgY2hhcmFjdGVyIHRvIGJlIGlnbm9yZWQuIChlLmcuXG4gICAgLy8gJ2FieHhjZCcgd2lsbCBiZSB0cmVhdGVkIGFzICdhYicpXG4gICAgYnVmID0gYnVmLnNsaWNlKDAsIGFjdHVhbClcbiAgfVxuXG4gIHJldHVybiBidWZcbn1cblxuZnVuY3Rpb24gZnJvbUFycmF5TGlrZSAoYXJyYXkpIHtcbiAgdmFyIGxlbmd0aCA9IGFycmF5Lmxlbmd0aCA8IDAgPyAwIDogY2hlY2tlZChhcnJheS5sZW5ndGgpIHwgMFxuICB2YXIgYnVmID0gY3JlYXRlQnVmZmVyKGxlbmd0aClcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkgKz0gMSkge1xuICAgIGJ1ZltpXSA9IGFycmF5W2ldICYgMjU1XG4gIH1cbiAgcmV0dXJuIGJ1ZlxufVxuXG5mdW5jdGlvbiBmcm9tQXJyYXlWaWV3IChhcnJheVZpZXcpIHtcbiAgaWYgKGlzSW5zdGFuY2UoYXJyYXlWaWV3LCBVaW50OEFycmF5KSkge1xuICAgIHZhciBjb3B5ID0gbmV3IFVpbnQ4QXJyYXkoYXJyYXlWaWV3KVxuICAgIHJldHVybiBmcm9tQXJyYXlCdWZmZXIoY29weS5idWZmZXIsIGNvcHkuYnl0ZU9mZnNldCwgY29weS5ieXRlTGVuZ3RoKVxuICB9XG4gIHJldHVybiBmcm9tQXJyYXlMaWtlKGFycmF5Vmlldylcbn1cblxuZnVuY3Rpb24gZnJvbUFycmF5QnVmZmVyIChhcnJheSwgYnl0ZU9mZnNldCwgbGVuZ3RoKSB7XG4gIGlmIChieXRlT2Zmc2V0IDwgMCB8fCBhcnJheS5ieXRlTGVuZ3RoIDwgYnl0ZU9mZnNldCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdcIm9mZnNldFwiIGlzIG91dHNpZGUgb2YgYnVmZmVyIGJvdW5kcycpXG4gIH1cblxuICBpZiAoYXJyYXkuYnl0ZUxlbmd0aCA8IGJ5dGVPZmZzZXQgKyAobGVuZ3RoIHx8IDApKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1wibGVuZ3RoXCIgaXMgb3V0c2lkZSBvZiBidWZmZXIgYm91bmRzJylcbiAgfVxuXG4gIHZhciBidWZcbiAgaWYgKGJ5dGVPZmZzZXQgPT09IHVuZGVmaW5lZCAmJiBsZW5ndGggPT09IHVuZGVmaW5lZCkge1xuICAgIGJ1ZiA9IG5ldyBVaW50OEFycmF5KGFycmF5KVxuICB9IGVsc2UgaWYgKGxlbmd0aCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgYnVmID0gbmV3IFVpbnQ4QXJyYXkoYXJyYXksIGJ5dGVPZmZzZXQpXG4gIH0gZWxzZSB7XG4gICAgYnVmID0gbmV3IFVpbnQ4QXJyYXkoYXJyYXksIGJ5dGVPZmZzZXQsIGxlbmd0aClcbiAgfVxuXG4gIC8vIFJldHVybiBhbiBhdWdtZW50ZWQgYFVpbnQ4QXJyYXlgIGluc3RhbmNlXG4gIE9iamVjdC5zZXRQcm90b3R5cGVPZihidWYsIEJ1ZmZlci5wcm90b3R5cGUpXG5cbiAgcmV0dXJuIGJ1ZlxufVxuXG5mdW5jdGlvbiBmcm9tT2JqZWN0IChvYmopIHtcbiAgaWYgKEJ1ZmZlci5pc0J1ZmZlcihvYmopKSB7XG4gICAgdmFyIGxlbiA9IGNoZWNrZWQob2JqLmxlbmd0aCkgfCAwXG4gICAgdmFyIGJ1ZiA9IGNyZWF0ZUJ1ZmZlcihsZW4pXG5cbiAgICBpZiAoYnVmLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuIGJ1ZlxuICAgIH1cblxuICAgIG9iai5jb3B5KGJ1ZiwgMCwgMCwgbGVuKVxuICAgIHJldHVybiBidWZcbiAgfVxuXG4gIGlmIChvYmoubGVuZ3RoICE9PSB1bmRlZmluZWQpIHtcbiAgICBpZiAodHlwZW9mIG9iai5sZW5ndGggIT09ICdudW1iZXInIHx8IG51bWJlcklzTmFOKG9iai5sZW5ndGgpKSB7XG4gICAgICByZXR1cm4gY3JlYXRlQnVmZmVyKDApXG4gICAgfVxuICAgIHJldHVybiBmcm9tQXJyYXlMaWtlKG9iailcbiAgfVxuXG4gIGlmIChvYmoudHlwZSA9PT0gJ0J1ZmZlcicgJiYgQXJyYXkuaXNBcnJheShvYmouZGF0YSkpIHtcbiAgICByZXR1cm4gZnJvbUFycmF5TGlrZShvYmouZGF0YSlcbiAgfVxufVxuXG5mdW5jdGlvbiBjaGVja2VkIChsZW5ndGgpIHtcbiAgLy8gTm90ZTogY2Fubm90IHVzZSBgbGVuZ3RoIDwgS19NQVhfTEVOR1RIYCBoZXJlIGJlY2F1c2UgdGhhdCBmYWlscyB3aGVuXG4gIC8vIGxlbmd0aCBpcyBOYU4gKHdoaWNoIGlzIG90aGVyd2lzZSBjb2VyY2VkIHRvIHplcm8uKVxuICBpZiAobGVuZ3RoID49IEtfTUFYX0xFTkdUSCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdBdHRlbXB0IHRvIGFsbG9jYXRlIEJ1ZmZlciBsYXJnZXIgdGhhbiBtYXhpbXVtICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICdzaXplOiAweCcgKyBLX01BWF9MRU5HVEgudG9TdHJpbmcoMTYpICsgJyBieXRlcycpXG4gIH1cbiAgcmV0dXJuIGxlbmd0aCB8IDBcbn1cblxuZnVuY3Rpb24gU2xvd0J1ZmZlciAobGVuZ3RoKSB7XG4gIGlmICgrbGVuZ3RoICE9IGxlbmd0aCkgeyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIGVxZXFlcVxuICAgIGxlbmd0aCA9IDBcbiAgfVxuICByZXR1cm4gQnVmZmVyLmFsbG9jKCtsZW5ndGgpXG59XG5cbkJ1ZmZlci5pc0J1ZmZlciA9IGZ1bmN0aW9uIGlzQnVmZmVyIChiKSB7XG4gIHJldHVybiBiICE9IG51bGwgJiYgYi5faXNCdWZmZXIgPT09IHRydWUgJiZcbiAgICBiICE9PSBCdWZmZXIucHJvdG90eXBlIC8vIHNvIEJ1ZmZlci5pc0J1ZmZlcihCdWZmZXIucHJvdG90eXBlKSB3aWxsIGJlIGZhbHNlXG59XG5cbkJ1ZmZlci5jb21wYXJlID0gZnVuY3Rpb24gY29tcGFyZSAoYSwgYikge1xuICBpZiAoaXNJbnN0YW5jZShhLCBVaW50OEFycmF5KSkgYSA9IEJ1ZmZlci5mcm9tKGEsIGEub2Zmc2V0LCBhLmJ5dGVMZW5ndGgpXG4gIGlmIChpc0luc3RhbmNlKGIsIFVpbnQ4QXJyYXkpKSBiID0gQnVmZmVyLmZyb20oYiwgYi5vZmZzZXQsIGIuYnl0ZUxlbmd0aClcbiAgaWYgKCFCdWZmZXIuaXNCdWZmZXIoYSkgfHwgIUJ1ZmZlci5pc0J1ZmZlcihiKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgICAnVGhlIFwiYnVmMVwiLCBcImJ1ZjJcIiBhcmd1bWVudHMgbXVzdCBiZSBvbmUgb2YgdHlwZSBCdWZmZXIgb3IgVWludDhBcnJheSdcbiAgICApXG4gIH1cblxuICBpZiAoYSA9PT0gYikgcmV0dXJuIDBcblxuICB2YXIgeCA9IGEubGVuZ3RoXG4gIHZhciB5ID0gYi5sZW5ndGhcblxuICBmb3IgKHZhciBpID0gMCwgbGVuID0gTWF0aC5taW4oeCwgeSk7IGkgPCBsZW47ICsraSkge1xuICAgIGlmIChhW2ldICE9PSBiW2ldKSB7XG4gICAgICB4ID0gYVtpXVxuICAgICAgeSA9IGJbaV1cbiAgICAgIGJyZWFrXG4gICAgfVxuICB9XG5cbiAgaWYgKHggPCB5KSByZXR1cm4gLTFcbiAgaWYgKHkgPCB4KSByZXR1cm4gMVxuICByZXR1cm4gMFxufVxuXG5CdWZmZXIuaXNFbmNvZGluZyA9IGZ1bmN0aW9uIGlzRW5jb2RpbmcgKGVuY29kaW5nKSB7XG4gIHN3aXRjaCAoU3RyaW5nKGVuY29kaW5nKS50b0xvd2VyQ2FzZSgpKSB7XG4gICAgY2FzZSAnaGV4JzpcbiAgICBjYXNlICd1dGY4JzpcbiAgICBjYXNlICd1dGYtOCc6XG4gICAgY2FzZSAnYXNjaWknOlxuICAgIGNhc2UgJ2xhdGluMSc6XG4gICAgY2FzZSAnYmluYXJ5JzpcbiAgICBjYXNlICdiYXNlNjQnOlxuICAgIGNhc2UgJ3VjczInOlxuICAgIGNhc2UgJ3Vjcy0yJzpcbiAgICBjYXNlICd1dGYxNmxlJzpcbiAgICBjYXNlICd1dGYtMTZsZSc6XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gZmFsc2VcbiAgfVxufVxuXG5CdWZmZXIuY29uY2F0ID0gZnVuY3Rpb24gY29uY2F0IChsaXN0LCBsZW5ndGgpIHtcbiAgaWYgKCFBcnJheS5pc0FycmF5KGxpc3QpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJsaXN0XCIgYXJndW1lbnQgbXVzdCBiZSBhbiBBcnJheSBvZiBCdWZmZXJzJylcbiAgfVxuXG4gIGlmIChsaXN0Lmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiBCdWZmZXIuYWxsb2MoMClcbiAgfVxuXG4gIHZhciBpXG4gIGlmIChsZW5ndGggPT09IHVuZGVmaW5lZCkge1xuICAgIGxlbmd0aCA9IDBcbiAgICBmb3IgKGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7ICsraSkge1xuICAgICAgbGVuZ3RoICs9IGxpc3RbaV0ubGVuZ3RoXG4gICAgfVxuICB9XG5cbiAgdmFyIGJ1ZmZlciA9IEJ1ZmZlci5hbGxvY1Vuc2FmZShsZW5ndGgpXG4gIHZhciBwb3MgPSAwXG4gIGZvciAoaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgKytpKSB7XG4gICAgdmFyIGJ1ZiA9IGxpc3RbaV1cbiAgICBpZiAoaXNJbnN0YW5jZShidWYsIFVpbnQ4QXJyYXkpKSB7XG4gICAgICBpZiAocG9zICsgYnVmLmxlbmd0aCA+IGJ1ZmZlci5sZW5ndGgpIHtcbiAgICAgICAgQnVmZmVyLmZyb20oYnVmKS5jb3B5KGJ1ZmZlciwgcG9zKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgVWludDhBcnJheS5wcm90b3R5cGUuc2V0LmNhbGwoXG4gICAgICAgICAgYnVmZmVyLFxuICAgICAgICAgIGJ1ZixcbiAgICAgICAgICBwb3NcbiAgICAgICAgKVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihidWYpKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcImxpc3RcIiBhcmd1bWVudCBtdXN0IGJlIGFuIEFycmF5IG9mIEJ1ZmZlcnMnKVxuICAgIH0gZWxzZSB7XG4gICAgICBidWYuY29weShidWZmZXIsIHBvcylcbiAgICB9XG4gICAgcG9zICs9IGJ1Zi5sZW5ndGhcbiAgfVxuICByZXR1cm4gYnVmZmVyXG59XG5cbmZ1bmN0aW9uIGJ5dGVMZW5ndGggKHN0cmluZywgZW5jb2RpbmcpIHtcbiAgaWYgKEJ1ZmZlci5pc0J1ZmZlcihzdHJpbmcpKSB7XG4gICAgcmV0dXJuIHN0cmluZy5sZW5ndGhcbiAgfVxuICBpZiAoQXJyYXlCdWZmZXIuaXNWaWV3KHN0cmluZykgfHwgaXNJbnN0YW5jZShzdHJpbmcsIEFycmF5QnVmZmVyKSkge1xuICAgIHJldHVybiBzdHJpbmcuYnl0ZUxlbmd0aFxuICB9XG4gIGlmICh0eXBlb2Ygc3RyaW5nICE9PSAnc3RyaW5nJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgICAnVGhlIFwic3RyaW5nXCIgYXJndW1lbnQgbXVzdCBiZSBvbmUgb2YgdHlwZSBzdHJpbmcsIEJ1ZmZlciwgb3IgQXJyYXlCdWZmZXIuICcgK1xuICAgICAgJ1JlY2VpdmVkIHR5cGUgJyArIHR5cGVvZiBzdHJpbmdcbiAgICApXG4gIH1cblxuICB2YXIgbGVuID0gc3RyaW5nLmxlbmd0aFxuICB2YXIgbXVzdE1hdGNoID0gKGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSA9PT0gdHJ1ZSlcbiAgaWYgKCFtdXN0TWF0Y2ggJiYgbGVuID09PSAwKSByZXR1cm4gMFxuXG4gIC8vIFVzZSBhIGZvciBsb29wIHRvIGF2b2lkIHJlY3Vyc2lvblxuICB2YXIgbG93ZXJlZENhc2UgPSBmYWxzZVxuICBmb3IgKDs7KSB7XG4gICAgc3dpdGNoIChlbmNvZGluZykge1xuICAgICAgY2FzZSAnYXNjaWknOlxuICAgICAgY2FzZSAnbGF0aW4xJzpcbiAgICAgIGNhc2UgJ2JpbmFyeSc6XG4gICAgICAgIHJldHVybiBsZW5cbiAgICAgIGNhc2UgJ3V0ZjgnOlxuICAgICAgY2FzZSAndXRmLTgnOlxuICAgICAgICByZXR1cm4gdXRmOFRvQnl0ZXMoc3RyaW5nKS5sZW5ndGhcbiAgICAgIGNhc2UgJ3VjczInOlxuICAgICAgY2FzZSAndWNzLTInOlxuICAgICAgY2FzZSAndXRmMTZsZSc6XG4gICAgICBjYXNlICd1dGYtMTZsZSc6XG4gICAgICAgIHJldHVybiBsZW4gKiAyXG4gICAgICBjYXNlICdoZXgnOlxuICAgICAgICByZXR1cm4gbGVuID4+PiAxXG4gICAgICBjYXNlICdiYXNlNjQnOlxuICAgICAgICByZXR1cm4gYmFzZTY0VG9CeXRlcyhzdHJpbmcpLmxlbmd0aFxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgaWYgKGxvd2VyZWRDYXNlKSB7XG4gICAgICAgICAgcmV0dXJuIG11c3RNYXRjaCA/IC0xIDogdXRmOFRvQnl0ZXMoc3RyaW5nKS5sZW5ndGggLy8gYXNzdW1lIHV0ZjhcbiAgICAgICAgfVxuICAgICAgICBlbmNvZGluZyA9ICgnJyArIGVuY29kaW5nKS50b0xvd2VyQ2FzZSgpXG4gICAgICAgIGxvd2VyZWRDYXNlID0gdHJ1ZVxuICAgIH1cbiAgfVxufVxuQnVmZmVyLmJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoXG5cbmZ1bmN0aW9uIHNsb3dUb1N0cmluZyAoZW5jb2RpbmcsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIGxvd2VyZWRDYXNlID0gZmFsc2VcblxuICAvLyBObyBuZWVkIHRvIHZlcmlmeSB0aGF0IFwidGhpcy5sZW5ndGggPD0gTUFYX1VJTlQzMlwiIHNpbmNlIGl0J3MgYSByZWFkLW9ubHlcbiAgLy8gcHJvcGVydHkgb2YgYSB0eXBlZCBhcnJheS5cblxuICAvLyBUaGlzIGJlaGF2ZXMgbmVpdGhlciBsaWtlIFN0cmluZyBub3IgVWludDhBcnJheSBpbiB0aGF0IHdlIHNldCBzdGFydC9lbmRcbiAgLy8gdG8gdGhlaXIgdXBwZXIvbG93ZXIgYm91bmRzIGlmIHRoZSB2YWx1ZSBwYXNzZWQgaXMgb3V0IG9mIHJhbmdlLlxuICAvLyB1bmRlZmluZWQgaXMgaGFuZGxlZCBzcGVjaWFsbHkgYXMgcGVyIEVDTUEtMjYyIDZ0aCBFZGl0aW9uLFxuICAvLyBTZWN0aW9uIDEzLjMuMy43IFJ1bnRpbWUgU2VtYW50aWNzOiBLZXllZEJpbmRpbmdJbml0aWFsaXphdGlvbi5cbiAgaWYgKHN0YXJ0ID09PSB1bmRlZmluZWQgfHwgc3RhcnQgPCAwKSB7XG4gICAgc3RhcnQgPSAwXG4gIH1cbiAgLy8gUmV0dXJuIGVhcmx5IGlmIHN0YXJ0ID4gdGhpcy5sZW5ndGguIERvbmUgaGVyZSB0byBwcmV2ZW50IHBvdGVudGlhbCB1aW50MzJcbiAgLy8gY29lcmNpb24gZmFpbCBiZWxvdy5cbiAgaWYgKHN0YXJ0ID4gdGhpcy5sZW5ndGgpIHtcbiAgICByZXR1cm4gJydcbiAgfVxuXG4gIGlmIChlbmQgPT09IHVuZGVmaW5lZCB8fCBlbmQgPiB0aGlzLmxlbmd0aCkge1xuICAgIGVuZCA9IHRoaXMubGVuZ3RoXG4gIH1cblxuICBpZiAoZW5kIDw9IDApIHtcbiAgICByZXR1cm4gJydcbiAgfVxuXG4gIC8vIEZvcmNlIGNvZXJjaW9uIHRvIHVpbnQzMi4gVGhpcyB3aWxsIGFsc28gY29lcmNlIGZhbHNleS9OYU4gdmFsdWVzIHRvIDAuXG4gIGVuZCA+Pj49IDBcbiAgc3RhcnQgPj4+PSAwXG5cbiAgaWYgKGVuZCA8PSBzdGFydCkge1xuICAgIHJldHVybiAnJ1xuICB9XG5cbiAgaWYgKCFlbmNvZGluZykgZW5jb2RpbmcgPSAndXRmOCdcblxuICB3aGlsZSAodHJ1ZSkge1xuICAgIHN3aXRjaCAoZW5jb2RpbmcpIHtcbiAgICAgIGNhc2UgJ2hleCc6XG4gICAgICAgIHJldHVybiBoZXhTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuXG4gICAgICBjYXNlICd1dGY4JzpcbiAgICAgIGNhc2UgJ3V0Zi04JzpcbiAgICAgICAgcmV0dXJuIHV0ZjhTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuXG4gICAgICBjYXNlICdhc2NpaSc6XG4gICAgICAgIHJldHVybiBhc2NpaVNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGNhc2UgJ2xhdGluMSc6XG4gICAgICBjYXNlICdiaW5hcnknOlxuICAgICAgICByZXR1cm4gbGF0aW4xU2xpY2UodGhpcywgc3RhcnQsIGVuZClcblxuICAgICAgY2FzZSAnYmFzZTY0JzpcbiAgICAgICAgcmV0dXJuIGJhc2U2NFNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGNhc2UgJ3VjczInOlxuICAgICAgY2FzZSAndWNzLTInOlxuICAgICAgY2FzZSAndXRmMTZsZSc6XG4gICAgICBjYXNlICd1dGYtMTZsZSc6XG4gICAgICAgIHJldHVybiB1dGYxNmxlU2xpY2UodGhpcywgc3RhcnQsIGVuZClcblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgaWYgKGxvd2VyZWRDYXNlKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdVbmtub3duIGVuY29kaW5nOiAnICsgZW5jb2RpbmcpXG4gICAgICAgIGVuY29kaW5nID0gKGVuY29kaW5nICsgJycpLnRvTG93ZXJDYXNlKClcbiAgICAgICAgbG93ZXJlZENhc2UgPSB0cnVlXG4gICAgfVxuICB9XG59XG5cbi8vIFRoaXMgcHJvcGVydHkgaXMgdXNlZCBieSBgQnVmZmVyLmlzQnVmZmVyYCAoYW5kIHRoZSBgaXMtYnVmZmVyYCBucG0gcGFja2FnZSlcbi8vIHRvIGRldGVjdCBhIEJ1ZmZlciBpbnN0YW5jZS4gSXQncyBub3QgcG9zc2libGUgdG8gdXNlIGBpbnN0YW5jZW9mIEJ1ZmZlcmBcbi8vIHJlbGlhYmx5IGluIGEgYnJvd3NlcmlmeSBjb250ZXh0IGJlY2F1c2UgdGhlcmUgY291bGQgYmUgbXVsdGlwbGUgZGlmZmVyZW50XG4vLyBjb3BpZXMgb2YgdGhlICdidWZmZXInIHBhY2thZ2UgaW4gdXNlLiBUaGlzIG1ldGhvZCB3b3JrcyBldmVuIGZvciBCdWZmZXJcbi8vIGluc3RhbmNlcyB0aGF0IHdlcmUgY3JlYXRlZCBmcm9tIGFub3RoZXIgY29weSBvZiB0aGUgYGJ1ZmZlcmAgcGFja2FnZS5cbi8vIFNlZTogaHR0cHM6Ly9naXRodWIuY29tL2Zlcm9zcy9idWZmZXIvaXNzdWVzLzE1NFxuQnVmZmVyLnByb3RvdHlwZS5faXNCdWZmZXIgPSB0cnVlXG5cbmZ1bmN0aW9uIHN3YXAgKGIsIG4sIG0pIHtcbiAgdmFyIGkgPSBiW25dXG4gIGJbbl0gPSBiW21dXG4gIGJbbV0gPSBpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuc3dhcDE2ID0gZnVuY3Rpb24gc3dhcDE2ICgpIHtcbiAgdmFyIGxlbiA9IHRoaXMubGVuZ3RoXG4gIGlmIChsZW4gJSAyICE9PSAwKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0J1ZmZlciBzaXplIG11c3QgYmUgYSBtdWx0aXBsZSBvZiAxNi1iaXRzJylcbiAgfVxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSArPSAyKSB7XG4gICAgc3dhcCh0aGlzLCBpLCBpICsgMSlcbiAgfVxuICByZXR1cm4gdGhpc1xufVxuXG5CdWZmZXIucHJvdG90eXBlLnN3YXAzMiA9IGZ1bmN0aW9uIHN3YXAzMiAoKSB7XG4gIHZhciBsZW4gPSB0aGlzLmxlbmd0aFxuICBpZiAobGVuICUgNCAhPT0gMCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdCdWZmZXIgc2l6ZSBtdXN0IGJlIGEgbXVsdGlwbGUgb2YgMzItYml0cycpXG4gIH1cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkgKz0gNCkge1xuICAgIHN3YXAodGhpcywgaSwgaSArIDMpXG4gICAgc3dhcCh0aGlzLCBpICsgMSwgaSArIDIpXG4gIH1cbiAgcmV0dXJuIHRoaXNcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5zd2FwNjQgPSBmdW5jdGlvbiBzd2FwNjQgKCkge1xuICB2YXIgbGVuID0gdGhpcy5sZW5ndGhcbiAgaWYgKGxlbiAlIDggIT09IDApIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignQnVmZmVyIHNpemUgbXVzdCBiZSBhIG11bHRpcGxlIG9mIDY0LWJpdHMnKVxuICB9XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpICs9IDgpIHtcbiAgICBzd2FwKHRoaXMsIGksIGkgKyA3KVxuICAgIHN3YXAodGhpcywgaSArIDEsIGkgKyA2KVxuICAgIHN3YXAodGhpcywgaSArIDIsIGkgKyA1KVxuICAgIHN3YXAodGhpcywgaSArIDMsIGkgKyA0KVxuICB9XG4gIHJldHVybiB0aGlzXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZyAoKSB7XG4gIHZhciBsZW5ndGggPSB0aGlzLmxlbmd0aFxuICBpZiAobGVuZ3RoID09PSAwKSByZXR1cm4gJydcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHJldHVybiB1dGY4U2xpY2UodGhpcywgMCwgbGVuZ3RoKVxuICByZXR1cm4gc2xvd1RvU3RyaW5nLmFwcGx5KHRoaXMsIGFyZ3VtZW50cylcbn1cblxuQnVmZmVyLnByb3RvdHlwZS50b0xvY2FsZVN0cmluZyA9IEJ1ZmZlci5wcm90b3R5cGUudG9TdHJpbmdcblxuQnVmZmVyLnByb3RvdHlwZS5lcXVhbHMgPSBmdW5jdGlvbiBlcXVhbHMgKGIpIHtcbiAgaWYgKCFCdWZmZXIuaXNCdWZmZXIoYikpIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FyZ3VtZW50IG11c3QgYmUgYSBCdWZmZXInKVxuICBpZiAodGhpcyA9PT0gYikgcmV0dXJuIHRydWVcbiAgcmV0dXJuIEJ1ZmZlci5jb21wYXJlKHRoaXMsIGIpID09PSAwXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuaW5zcGVjdCA9IGZ1bmN0aW9uIGluc3BlY3QgKCkge1xuICB2YXIgc3RyID0gJydcbiAgdmFyIG1heCA9IGV4cG9ydHMuSU5TUEVDVF9NQVhfQllURVNcbiAgc3RyID0gdGhpcy50b1N0cmluZygnaGV4JywgMCwgbWF4KS5yZXBsYWNlKC8oLnsyfSkvZywgJyQxICcpLnRyaW0oKVxuICBpZiAodGhpcy5sZW5ndGggPiBtYXgpIHN0ciArPSAnIC4uLiAnXG4gIHJldHVybiAnPEJ1ZmZlciAnICsgc3RyICsgJz4nXG59XG5pZiAoY3VzdG9tSW5zcGVjdFN5bWJvbCkge1xuICBCdWZmZXIucHJvdG90eXBlW2N1c3RvbUluc3BlY3RTeW1ib2xdID0gQnVmZmVyLnByb3RvdHlwZS5pbnNwZWN0XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuY29tcGFyZSA9IGZ1bmN0aW9uIGNvbXBhcmUgKHRhcmdldCwgc3RhcnQsIGVuZCwgdGhpc1N0YXJ0LCB0aGlzRW5kKSB7XG4gIGlmIChpc0luc3RhbmNlKHRhcmdldCwgVWludDhBcnJheSkpIHtcbiAgICB0YXJnZXQgPSBCdWZmZXIuZnJvbSh0YXJnZXQsIHRhcmdldC5vZmZzZXQsIHRhcmdldC5ieXRlTGVuZ3RoKVxuICB9XG4gIGlmICghQnVmZmVyLmlzQnVmZmVyKHRhcmdldCkpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICAgJ1RoZSBcInRhcmdldFwiIGFyZ3VtZW50IG11c3QgYmUgb25lIG9mIHR5cGUgQnVmZmVyIG9yIFVpbnQ4QXJyYXkuICcgK1xuICAgICAgJ1JlY2VpdmVkIHR5cGUgJyArICh0eXBlb2YgdGFyZ2V0KVxuICAgIClcbiAgfVxuXG4gIGlmIChzdGFydCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgc3RhcnQgPSAwXG4gIH1cbiAgaWYgKGVuZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgZW5kID0gdGFyZ2V0ID8gdGFyZ2V0Lmxlbmd0aCA6IDBcbiAgfVxuICBpZiAodGhpc1N0YXJ0ID09PSB1bmRlZmluZWQpIHtcbiAgICB0aGlzU3RhcnQgPSAwXG4gIH1cbiAgaWYgKHRoaXNFbmQgPT09IHVuZGVmaW5lZCkge1xuICAgIHRoaXNFbmQgPSB0aGlzLmxlbmd0aFxuICB9XG5cbiAgaWYgKHN0YXJ0IDwgMCB8fCBlbmQgPiB0YXJnZXQubGVuZ3RoIHx8IHRoaXNTdGFydCA8IDAgfHwgdGhpc0VuZCA+IHRoaXMubGVuZ3RoKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ291dCBvZiByYW5nZSBpbmRleCcpXG4gIH1cblxuICBpZiAodGhpc1N0YXJ0ID49IHRoaXNFbmQgJiYgc3RhcnQgPj0gZW5kKSB7XG4gICAgcmV0dXJuIDBcbiAgfVxuICBpZiAodGhpc1N0YXJ0ID49IHRoaXNFbmQpIHtcbiAgICByZXR1cm4gLTFcbiAgfVxuICBpZiAoc3RhcnQgPj0gZW5kKSB7XG4gICAgcmV0dXJuIDFcbiAgfVxuXG4gIHN0YXJ0ID4+Pj0gMFxuICBlbmQgPj4+PSAwXG4gIHRoaXNTdGFydCA+Pj49IDBcbiAgdGhpc0VuZCA+Pj49IDBcblxuICBpZiAodGhpcyA9PT0gdGFyZ2V0KSByZXR1cm4gMFxuXG4gIHZhciB4ID0gdGhpc0VuZCAtIHRoaXNTdGFydFxuICB2YXIgeSA9IGVuZCAtIHN0YXJ0XG4gIHZhciBsZW4gPSBNYXRoLm1pbih4LCB5KVxuXG4gIHZhciB0aGlzQ29weSA9IHRoaXMuc2xpY2UodGhpc1N0YXJ0LCB0aGlzRW5kKVxuICB2YXIgdGFyZ2V0Q29weSA9IHRhcmdldC5zbGljZShzdGFydCwgZW5kKVxuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyArK2kpIHtcbiAgICBpZiAodGhpc0NvcHlbaV0gIT09IHRhcmdldENvcHlbaV0pIHtcbiAgICAgIHggPSB0aGlzQ29weVtpXVxuICAgICAgeSA9IHRhcmdldENvcHlbaV1cbiAgICAgIGJyZWFrXG4gICAgfVxuICB9XG5cbiAgaWYgKHggPCB5KSByZXR1cm4gLTFcbiAgaWYgKHkgPCB4KSByZXR1cm4gMVxuICByZXR1cm4gMFxufVxuXG4vLyBGaW5kcyBlaXRoZXIgdGhlIGZpcnN0IGluZGV4IG9mIGB2YWxgIGluIGBidWZmZXJgIGF0IG9mZnNldCA+PSBgYnl0ZU9mZnNldGAsXG4vLyBPUiB0aGUgbGFzdCBpbmRleCBvZiBgdmFsYCBpbiBgYnVmZmVyYCBhdCBvZmZzZXQgPD0gYGJ5dGVPZmZzZXRgLlxuLy9cbi8vIEFyZ3VtZW50czpcbi8vIC0gYnVmZmVyIC0gYSBCdWZmZXIgdG8gc2VhcmNoXG4vLyAtIHZhbCAtIGEgc3RyaW5nLCBCdWZmZXIsIG9yIG51bWJlclxuLy8gLSBieXRlT2Zmc2V0IC0gYW4gaW5kZXggaW50byBgYnVmZmVyYDsgd2lsbCBiZSBjbGFtcGVkIHRvIGFuIGludDMyXG4vLyAtIGVuY29kaW5nIC0gYW4gb3B0aW9uYWwgZW5jb2RpbmcsIHJlbGV2YW50IGlzIHZhbCBpcyBhIHN0cmluZ1xuLy8gLSBkaXIgLSB0cnVlIGZvciBpbmRleE9mLCBmYWxzZSBmb3IgbGFzdEluZGV4T2ZcbmZ1bmN0aW9uIGJpZGlyZWN0aW9uYWxJbmRleE9mIChidWZmZXIsIHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcsIGRpcikge1xuICAvLyBFbXB0eSBidWZmZXIgbWVhbnMgbm8gbWF0Y2hcbiAgaWYgKGJ1ZmZlci5sZW5ndGggPT09IDApIHJldHVybiAtMVxuXG4gIC8vIE5vcm1hbGl6ZSBieXRlT2Zmc2V0XG4gIGlmICh0eXBlb2YgYnl0ZU9mZnNldCA9PT0gJ3N0cmluZycpIHtcbiAgICBlbmNvZGluZyA9IGJ5dGVPZmZzZXRcbiAgICBieXRlT2Zmc2V0ID0gMFxuICB9IGVsc2UgaWYgKGJ5dGVPZmZzZXQgPiAweDdmZmZmZmZmKSB7XG4gICAgYnl0ZU9mZnNldCA9IDB4N2ZmZmZmZmZcbiAgfSBlbHNlIGlmIChieXRlT2Zmc2V0IDwgLTB4ODAwMDAwMDApIHtcbiAgICBieXRlT2Zmc2V0ID0gLTB4ODAwMDAwMDBcbiAgfVxuICBieXRlT2Zmc2V0ID0gK2J5dGVPZmZzZXQgLy8gQ29lcmNlIHRvIE51bWJlci5cbiAgaWYgKG51bWJlcklzTmFOKGJ5dGVPZmZzZXQpKSB7XG4gICAgLy8gYnl0ZU9mZnNldDogaXQgaXQncyB1bmRlZmluZWQsIG51bGwsIE5hTiwgXCJmb29cIiwgZXRjLCBzZWFyY2ggd2hvbGUgYnVmZmVyXG4gICAgYnl0ZU9mZnNldCA9IGRpciA/IDAgOiAoYnVmZmVyLmxlbmd0aCAtIDEpXG4gIH1cblxuICAvLyBOb3JtYWxpemUgYnl0ZU9mZnNldDogbmVnYXRpdmUgb2Zmc2V0cyBzdGFydCBmcm9tIHRoZSBlbmQgb2YgdGhlIGJ1ZmZlclxuICBpZiAoYnl0ZU9mZnNldCA8IDApIGJ5dGVPZmZzZXQgPSBidWZmZXIubGVuZ3RoICsgYnl0ZU9mZnNldFxuICBpZiAoYnl0ZU9mZnNldCA+PSBidWZmZXIubGVuZ3RoKSB7XG4gICAgaWYgKGRpcikgcmV0dXJuIC0xXG4gICAgZWxzZSBieXRlT2Zmc2V0ID0gYnVmZmVyLmxlbmd0aCAtIDFcbiAgfSBlbHNlIGlmIChieXRlT2Zmc2V0IDwgMCkge1xuICAgIGlmIChkaXIpIGJ5dGVPZmZzZXQgPSAwXG4gICAgZWxzZSByZXR1cm4gLTFcbiAgfVxuXG4gIC8vIE5vcm1hbGl6ZSB2YWxcbiAgaWYgKHR5cGVvZiB2YWwgPT09ICdzdHJpbmcnKSB7XG4gICAgdmFsID0gQnVmZmVyLmZyb20odmFsLCBlbmNvZGluZylcbiAgfVxuXG4gIC8vIEZpbmFsbHksIHNlYXJjaCBlaXRoZXIgaW5kZXhPZiAoaWYgZGlyIGlzIHRydWUpIG9yIGxhc3RJbmRleE9mXG4gIGlmIChCdWZmZXIuaXNCdWZmZXIodmFsKSkge1xuICAgIC8vIFNwZWNpYWwgY2FzZTogbG9va2luZyBmb3IgZW1wdHkgc3RyaW5nL2J1ZmZlciBhbHdheXMgZmFpbHNcbiAgICBpZiAodmFsLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuIC0xXG4gICAgfVxuICAgIHJldHVybiBhcnJheUluZGV4T2YoYnVmZmVyLCB2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nLCBkaXIpXG4gIH0gZWxzZSBpZiAodHlwZW9mIHZhbCA9PT0gJ251bWJlcicpIHtcbiAgICB2YWwgPSB2YWwgJiAweEZGIC8vIFNlYXJjaCBmb3IgYSBieXRlIHZhbHVlIFswLTI1NV1cbiAgICBpZiAodHlwZW9mIFVpbnQ4QXJyYXkucHJvdG90eXBlLmluZGV4T2YgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGlmIChkaXIpIHtcbiAgICAgICAgcmV0dXJuIFVpbnQ4QXJyYXkucHJvdG90eXBlLmluZGV4T2YuY2FsbChidWZmZXIsIHZhbCwgYnl0ZU9mZnNldClcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBVaW50OEFycmF5LnByb3RvdHlwZS5sYXN0SW5kZXhPZi5jYWxsKGJ1ZmZlciwgdmFsLCBieXRlT2Zmc2V0KVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gYXJyYXlJbmRleE9mKGJ1ZmZlciwgW3ZhbF0sIGJ5dGVPZmZzZXQsIGVuY29kaW5nLCBkaXIpXG4gIH1cblxuICB0aHJvdyBuZXcgVHlwZUVycm9yKCd2YWwgbXVzdCBiZSBzdHJpbmcsIG51bWJlciBvciBCdWZmZXInKVxufVxuXG5mdW5jdGlvbiBhcnJheUluZGV4T2YgKGFyciwgdmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZywgZGlyKSB7XG4gIHZhciBpbmRleFNpemUgPSAxXG4gIHZhciBhcnJMZW5ndGggPSBhcnIubGVuZ3RoXG4gIHZhciB2YWxMZW5ndGggPSB2YWwubGVuZ3RoXG5cbiAgaWYgKGVuY29kaW5nICE9PSB1bmRlZmluZWQpIHtcbiAgICBlbmNvZGluZyA9IFN0cmluZyhlbmNvZGluZykudG9Mb3dlckNhc2UoKVxuICAgIGlmIChlbmNvZGluZyA9PT0gJ3VjczInIHx8IGVuY29kaW5nID09PSAndWNzLTInIHx8XG4gICAgICAgIGVuY29kaW5nID09PSAndXRmMTZsZScgfHwgZW5jb2RpbmcgPT09ICd1dGYtMTZsZScpIHtcbiAgICAgIGlmIChhcnIubGVuZ3RoIDwgMiB8fCB2YWwubGVuZ3RoIDwgMikge1xuICAgICAgICByZXR1cm4gLTFcbiAgICAgIH1cbiAgICAgIGluZGV4U2l6ZSA9IDJcbiAgICAgIGFyckxlbmd0aCAvPSAyXG4gICAgICB2YWxMZW5ndGggLz0gMlxuICAgICAgYnl0ZU9mZnNldCAvPSAyXG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gcmVhZCAoYnVmLCBpKSB7XG4gICAgaWYgKGluZGV4U2l6ZSA9PT0gMSkge1xuICAgICAgcmV0dXJuIGJ1ZltpXVxuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gYnVmLnJlYWRVSW50MTZCRShpICogaW5kZXhTaXplKVxuICAgIH1cbiAgfVxuXG4gIHZhciBpXG4gIGlmIChkaXIpIHtcbiAgICB2YXIgZm91bmRJbmRleCA9IC0xXG4gICAgZm9yIChpID0gYnl0ZU9mZnNldDsgaSA8IGFyckxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAocmVhZChhcnIsIGkpID09PSByZWFkKHZhbCwgZm91bmRJbmRleCA9PT0gLTEgPyAwIDogaSAtIGZvdW5kSW5kZXgpKSB7XG4gICAgICAgIGlmIChmb3VuZEluZGV4ID09PSAtMSkgZm91bmRJbmRleCA9IGlcbiAgICAgICAgaWYgKGkgLSBmb3VuZEluZGV4ICsgMSA9PT0gdmFsTGVuZ3RoKSByZXR1cm4gZm91bmRJbmRleCAqIGluZGV4U2l6ZVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKGZvdW5kSW5kZXggIT09IC0xKSBpIC09IGkgLSBmb3VuZEluZGV4XG4gICAgICAgIGZvdW5kSW5kZXggPSAtMVxuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBpZiAoYnl0ZU9mZnNldCArIHZhbExlbmd0aCA+IGFyckxlbmd0aCkgYnl0ZU9mZnNldCA9IGFyckxlbmd0aCAtIHZhbExlbmd0aFxuICAgIGZvciAoaSA9IGJ5dGVPZmZzZXQ7IGkgPj0gMDsgaS0tKSB7XG4gICAgICB2YXIgZm91bmQgPSB0cnVlXG4gICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHZhbExlbmd0aDsgaisrKSB7XG4gICAgICAgIGlmIChyZWFkKGFyciwgaSArIGopICE9PSByZWFkKHZhbCwgaikpIHtcbiAgICAgICAgICBmb3VuZCA9IGZhbHNlXG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGZvdW5kKSByZXR1cm4gaVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiAtMVxufVxuXG5CdWZmZXIucHJvdG90eXBlLmluY2x1ZGVzID0gZnVuY3Rpb24gaW5jbHVkZXMgKHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcpIHtcbiAgcmV0dXJuIHRoaXMuaW5kZXhPZih2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nKSAhPT0gLTFcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5pbmRleE9mID0gZnVuY3Rpb24gaW5kZXhPZiAodmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZykge1xuICByZXR1cm4gYmlkaXJlY3Rpb25hbEluZGV4T2YodGhpcywgdmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZywgdHJ1ZSlcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5sYXN0SW5kZXhPZiA9IGZ1bmN0aW9uIGxhc3RJbmRleE9mICh2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nKSB7XG4gIHJldHVybiBiaWRpcmVjdGlvbmFsSW5kZXhPZih0aGlzLCB2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nLCBmYWxzZSlcbn1cblxuZnVuY3Rpb24gaGV4V3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICBvZmZzZXQgPSBOdW1iZXIob2Zmc2V0KSB8fCAwXG4gIHZhciByZW1haW5pbmcgPSBidWYubGVuZ3RoIC0gb2Zmc2V0XG4gIGlmICghbGVuZ3RoKSB7XG4gICAgbGVuZ3RoID0gcmVtYWluaW5nXG4gIH0gZWxzZSB7XG4gICAgbGVuZ3RoID0gTnVtYmVyKGxlbmd0aClcbiAgICBpZiAobGVuZ3RoID4gcmVtYWluaW5nKSB7XG4gICAgICBsZW5ndGggPSByZW1haW5pbmdcbiAgICB9XG4gIH1cblxuICB2YXIgc3RyTGVuID0gc3RyaW5nLmxlbmd0aFxuXG4gIGlmIChsZW5ndGggPiBzdHJMZW4gLyAyKSB7XG4gICAgbGVuZ3RoID0gc3RyTGVuIC8gMlxuICB9XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyArK2kpIHtcbiAgICB2YXIgcGFyc2VkID0gcGFyc2VJbnQoc3RyaW5nLnN1YnN0cihpICogMiwgMiksIDE2KVxuICAgIGlmIChudW1iZXJJc05hTihwYXJzZWQpKSByZXR1cm4gaVxuICAgIGJ1ZltvZmZzZXQgKyBpXSA9IHBhcnNlZFxuICB9XG4gIHJldHVybiBpXG59XG5cbmZ1bmN0aW9uIHV0ZjhXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIHJldHVybiBibGl0QnVmZmVyKHV0ZjhUb0J5dGVzKHN0cmluZywgYnVmLmxlbmd0aCAtIG9mZnNldCksIGJ1Ziwgb2Zmc2V0LCBsZW5ndGgpXG59XG5cbmZ1bmN0aW9uIGFzY2lpV3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICByZXR1cm4gYmxpdEJ1ZmZlcihhc2NpaVRvQnl0ZXMoc3RyaW5nKSwgYnVmLCBvZmZzZXQsIGxlbmd0aClcbn1cblxuZnVuY3Rpb24gYmFzZTY0V3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICByZXR1cm4gYmxpdEJ1ZmZlcihiYXNlNjRUb0J5dGVzKHN0cmluZyksIGJ1Ziwgb2Zmc2V0LCBsZW5ndGgpXG59XG5cbmZ1bmN0aW9uIHVjczJXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIHJldHVybiBibGl0QnVmZmVyKHV0ZjE2bGVUb0J5dGVzKHN0cmluZywgYnVmLmxlbmd0aCAtIG9mZnNldCksIGJ1Ziwgb2Zmc2V0LCBsZW5ndGgpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGUgPSBmdW5jdGlvbiB3cml0ZSAoc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCwgZW5jb2RpbmcpIHtcbiAgLy8gQnVmZmVyI3dyaXRlKHN0cmluZylcbiAgaWYgKG9mZnNldCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgZW5jb2RpbmcgPSAndXRmOCdcbiAgICBsZW5ndGggPSB0aGlzLmxlbmd0aFxuICAgIG9mZnNldCA9IDBcbiAgLy8gQnVmZmVyI3dyaXRlKHN0cmluZywgZW5jb2RpbmcpXG4gIH0gZWxzZSBpZiAobGVuZ3RoID09PSB1bmRlZmluZWQgJiYgdHlwZW9mIG9mZnNldCA9PT0gJ3N0cmluZycpIHtcbiAgICBlbmNvZGluZyA9IG9mZnNldFxuICAgIGxlbmd0aCA9IHRoaXMubGVuZ3RoXG4gICAgb2Zmc2V0ID0gMFxuICAvLyBCdWZmZXIjd3JpdGUoc3RyaW5nLCBvZmZzZXRbLCBsZW5ndGhdWywgZW5jb2RpbmddKVxuICB9IGVsc2UgaWYgKGlzRmluaXRlKG9mZnNldCkpIHtcbiAgICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgICBpZiAoaXNGaW5pdGUobGVuZ3RoKSkge1xuICAgICAgbGVuZ3RoID0gbGVuZ3RoID4+PiAwXG4gICAgICBpZiAoZW5jb2RpbmcgPT09IHVuZGVmaW5lZCkgZW5jb2RpbmcgPSAndXRmOCdcbiAgICB9IGVsc2Uge1xuICAgICAgZW5jb2RpbmcgPSBsZW5ndGhcbiAgICAgIGxlbmd0aCA9IHVuZGVmaW5lZFxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAnQnVmZmVyLndyaXRlKHN0cmluZywgZW5jb2RpbmcsIG9mZnNldFssIGxlbmd0aF0pIGlzIG5vIGxvbmdlciBzdXBwb3J0ZWQnXG4gICAgKVxuICB9XG5cbiAgdmFyIHJlbWFpbmluZyA9IHRoaXMubGVuZ3RoIC0gb2Zmc2V0XG4gIGlmIChsZW5ndGggPT09IHVuZGVmaW5lZCB8fCBsZW5ndGggPiByZW1haW5pbmcpIGxlbmd0aCA9IHJlbWFpbmluZ1xuXG4gIGlmICgoc3RyaW5nLmxlbmd0aCA+IDAgJiYgKGxlbmd0aCA8IDAgfHwgb2Zmc2V0IDwgMCkpIHx8IG9mZnNldCA+IHRoaXMubGVuZ3RoKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0F0dGVtcHQgdG8gd3JpdGUgb3V0c2lkZSBidWZmZXIgYm91bmRzJylcbiAgfVxuXG4gIGlmICghZW5jb2RpbmcpIGVuY29kaW5nID0gJ3V0ZjgnXG5cbiAgdmFyIGxvd2VyZWRDYXNlID0gZmFsc2VcbiAgZm9yICg7Oykge1xuICAgIHN3aXRjaCAoZW5jb2RpbmcpIHtcbiAgICAgIGNhc2UgJ2hleCc6XG4gICAgICAgIHJldHVybiBoZXhXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuXG4gICAgICBjYXNlICd1dGY4JzpcbiAgICAgIGNhc2UgJ3V0Zi04JzpcbiAgICAgICAgcmV0dXJuIHV0ZjhXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuXG4gICAgICBjYXNlICdhc2NpaSc6XG4gICAgICBjYXNlICdsYXRpbjEnOlxuICAgICAgY2FzZSAnYmluYXJ5JzpcbiAgICAgICAgcmV0dXJuIGFzY2lpV3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcblxuICAgICAgY2FzZSAnYmFzZTY0JzpcbiAgICAgICAgLy8gV2FybmluZzogbWF4TGVuZ3RoIG5vdCB0YWtlbiBpbnRvIGFjY291bnQgaW4gYmFzZTY0V3JpdGVcbiAgICAgICAgcmV0dXJuIGJhc2U2NFdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG5cbiAgICAgIGNhc2UgJ3VjczInOlxuICAgICAgY2FzZSAndWNzLTInOlxuICAgICAgY2FzZSAndXRmMTZsZSc6XG4gICAgICBjYXNlICd1dGYtMTZsZSc6XG4gICAgICAgIHJldHVybiB1Y3MyV3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgaWYgKGxvd2VyZWRDYXNlKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdVbmtub3duIGVuY29kaW5nOiAnICsgZW5jb2RpbmcpXG4gICAgICAgIGVuY29kaW5nID0gKCcnICsgZW5jb2RpbmcpLnRvTG93ZXJDYXNlKClcbiAgICAgICAgbG93ZXJlZENhc2UgPSB0cnVlXG4gICAgfVxuICB9XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUudG9KU09OID0gZnVuY3Rpb24gdG9KU09OICgpIHtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiAnQnVmZmVyJyxcbiAgICBkYXRhOiBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbCh0aGlzLl9hcnIgfHwgdGhpcywgMClcbiAgfVxufVxuXG5mdW5jdGlvbiBiYXNlNjRTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIGlmIChzdGFydCA9PT0gMCAmJiBlbmQgPT09IGJ1Zi5sZW5ndGgpIHtcbiAgICByZXR1cm4gYmFzZTY0LmZyb21CeXRlQXJyYXkoYnVmKVxuICB9IGVsc2Uge1xuICAgIHJldHVybiBiYXNlNjQuZnJvbUJ5dGVBcnJheShidWYuc2xpY2Uoc3RhcnQsIGVuZCkpXG4gIH1cbn1cblxuZnVuY3Rpb24gdXRmOFNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgZW5kID0gTWF0aC5taW4oYnVmLmxlbmd0aCwgZW5kKVxuICB2YXIgcmVzID0gW11cblxuICB2YXIgaSA9IHN0YXJ0XG4gIHdoaWxlIChpIDwgZW5kKSB7XG4gICAgdmFyIGZpcnN0Qnl0ZSA9IGJ1ZltpXVxuICAgIHZhciBjb2RlUG9pbnQgPSBudWxsXG4gICAgdmFyIGJ5dGVzUGVyU2VxdWVuY2UgPSAoZmlyc3RCeXRlID4gMHhFRilcbiAgICAgID8gNFxuICAgICAgOiAoZmlyc3RCeXRlID4gMHhERilcbiAgICAgICAgICA/IDNcbiAgICAgICAgICA6IChmaXJzdEJ5dGUgPiAweEJGKVxuICAgICAgICAgICAgICA/IDJcbiAgICAgICAgICAgICAgOiAxXG5cbiAgICBpZiAoaSArIGJ5dGVzUGVyU2VxdWVuY2UgPD0gZW5kKSB7XG4gICAgICB2YXIgc2Vjb25kQnl0ZSwgdGhpcmRCeXRlLCBmb3VydGhCeXRlLCB0ZW1wQ29kZVBvaW50XG5cbiAgICAgIHN3aXRjaCAoYnl0ZXNQZXJTZXF1ZW5jZSkge1xuICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgaWYgKGZpcnN0Qnl0ZSA8IDB4ODApIHtcbiAgICAgICAgICAgIGNvZGVQb2ludCA9IGZpcnN0Qnl0ZVxuICAgICAgICAgIH1cbiAgICAgICAgICBicmVha1xuICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgc2Vjb25kQnl0ZSA9IGJ1ZltpICsgMV1cbiAgICAgICAgICBpZiAoKHNlY29uZEJ5dGUgJiAweEMwKSA9PT0gMHg4MCkge1xuICAgICAgICAgICAgdGVtcENvZGVQb2ludCA9IChmaXJzdEJ5dGUgJiAweDFGKSA8PCAweDYgfCAoc2Vjb25kQnl0ZSAmIDB4M0YpXG4gICAgICAgICAgICBpZiAodGVtcENvZGVQb2ludCA+IDB4N0YpIHtcbiAgICAgICAgICAgICAgY29kZVBvaW50ID0gdGVtcENvZGVQb2ludFxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBicmVha1xuICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgc2Vjb25kQnl0ZSA9IGJ1ZltpICsgMV1cbiAgICAgICAgICB0aGlyZEJ5dGUgPSBidWZbaSArIDJdXG4gICAgICAgICAgaWYgKChzZWNvbmRCeXRlICYgMHhDMCkgPT09IDB4ODAgJiYgKHRoaXJkQnl0ZSAmIDB4QzApID09PSAweDgwKSB7XG4gICAgICAgICAgICB0ZW1wQ29kZVBvaW50ID0gKGZpcnN0Qnl0ZSAmIDB4RikgPDwgMHhDIHwgKHNlY29uZEJ5dGUgJiAweDNGKSA8PCAweDYgfCAodGhpcmRCeXRlICYgMHgzRilcbiAgICAgICAgICAgIGlmICh0ZW1wQ29kZVBvaW50ID4gMHg3RkYgJiYgKHRlbXBDb2RlUG9pbnQgPCAweEQ4MDAgfHwgdGVtcENvZGVQb2ludCA+IDB4REZGRikpIHtcbiAgICAgICAgICAgICAgY29kZVBvaW50ID0gdGVtcENvZGVQb2ludFxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBicmVha1xuICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgc2Vjb25kQnl0ZSA9IGJ1ZltpICsgMV1cbiAgICAgICAgICB0aGlyZEJ5dGUgPSBidWZbaSArIDJdXG4gICAgICAgICAgZm91cnRoQnl0ZSA9IGJ1ZltpICsgM11cbiAgICAgICAgICBpZiAoKHNlY29uZEJ5dGUgJiAweEMwKSA9PT0gMHg4MCAmJiAodGhpcmRCeXRlICYgMHhDMCkgPT09IDB4ODAgJiYgKGZvdXJ0aEJ5dGUgJiAweEMwKSA9PT0gMHg4MCkge1xuICAgICAgICAgICAgdGVtcENvZGVQb2ludCA9IChmaXJzdEJ5dGUgJiAweEYpIDw8IDB4MTIgfCAoc2Vjb25kQnl0ZSAmIDB4M0YpIDw8IDB4QyB8ICh0aGlyZEJ5dGUgJiAweDNGKSA8PCAweDYgfCAoZm91cnRoQnl0ZSAmIDB4M0YpXG4gICAgICAgICAgICBpZiAodGVtcENvZGVQb2ludCA+IDB4RkZGRiAmJiB0ZW1wQ29kZVBvaW50IDwgMHgxMTAwMDApIHtcbiAgICAgICAgICAgICAgY29kZVBvaW50ID0gdGVtcENvZGVQb2ludFxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoY29kZVBvaW50ID09PSBudWxsKSB7XG4gICAgICAvLyB3ZSBkaWQgbm90IGdlbmVyYXRlIGEgdmFsaWQgY29kZVBvaW50IHNvIGluc2VydCBhXG4gICAgICAvLyByZXBsYWNlbWVudCBjaGFyIChVK0ZGRkQpIGFuZCBhZHZhbmNlIG9ubHkgMSBieXRlXG4gICAgICBjb2RlUG9pbnQgPSAweEZGRkRcbiAgICAgIGJ5dGVzUGVyU2VxdWVuY2UgPSAxXG4gICAgfSBlbHNlIGlmIChjb2RlUG9pbnQgPiAweEZGRkYpIHtcbiAgICAgIC8vIGVuY29kZSB0byB1dGYxNiAoc3Vycm9nYXRlIHBhaXIgZGFuY2UpXG4gICAgICBjb2RlUG9pbnQgLT0gMHgxMDAwMFxuICAgICAgcmVzLnB1c2goY29kZVBvaW50ID4+PiAxMCAmIDB4M0ZGIHwgMHhEODAwKVxuICAgICAgY29kZVBvaW50ID0gMHhEQzAwIHwgY29kZVBvaW50ICYgMHgzRkZcbiAgICB9XG5cbiAgICByZXMucHVzaChjb2RlUG9pbnQpXG4gICAgaSArPSBieXRlc1BlclNlcXVlbmNlXG4gIH1cblxuICByZXR1cm4gZGVjb2RlQ29kZVBvaW50c0FycmF5KHJlcylcbn1cblxuLy8gQmFzZWQgb24gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMjI3NDcyNzIvNjgwNzQyLCB0aGUgYnJvd3NlciB3aXRoXG4vLyB0aGUgbG93ZXN0IGxpbWl0IGlzIENocm9tZSwgd2l0aCAweDEwMDAwIGFyZ3MuXG4vLyBXZSBnbyAxIG1hZ25pdHVkZSBsZXNzLCBmb3Igc2FmZXR5XG52YXIgTUFYX0FSR1VNRU5UU19MRU5HVEggPSAweDEwMDBcblxuZnVuY3Rpb24gZGVjb2RlQ29kZVBvaW50c0FycmF5IChjb2RlUG9pbnRzKSB7XG4gIHZhciBsZW4gPSBjb2RlUG9pbnRzLmxlbmd0aFxuICBpZiAobGVuIDw9IE1BWF9BUkdVTUVOVFNfTEVOR1RIKSB7XG4gICAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkoU3RyaW5nLCBjb2RlUG9pbnRzKSAvLyBhdm9pZCBleHRyYSBzbGljZSgpXG4gIH1cblxuICAvLyBEZWNvZGUgaW4gY2h1bmtzIHRvIGF2b2lkIFwiY2FsbCBzdGFjayBzaXplIGV4Y2VlZGVkXCIuXG4gIHZhciByZXMgPSAnJ1xuICB2YXIgaSA9IDBcbiAgd2hpbGUgKGkgPCBsZW4pIHtcbiAgICByZXMgKz0gU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShcbiAgICAgIFN0cmluZyxcbiAgICAgIGNvZGVQb2ludHMuc2xpY2UoaSwgaSArPSBNQVhfQVJHVU1FTlRTX0xFTkdUSClcbiAgICApXG4gIH1cbiAgcmV0dXJuIHJlc1xufVxuXG5mdW5jdGlvbiBhc2NpaVNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIHJldCA9ICcnXG4gIGVuZCA9IE1hdGgubWluKGJ1Zi5sZW5ndGgsIGVuZClcblxuICBmb3IgKHZhciBpID0gc3RhcnQ7IGkgPCBlbmQ7ICsraSkge1xuICAgIHJldCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGJ1ZltpXSAmIDB4N0YpXG4gIH1cbiAgcmV0dXJuIHJldFxufVxuXG5mdW5jdGlvbiBsYXRpbjFTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIHZhciByZXQgPSAnJ1xuICBlbmQgPSBNYXRoLm1pbihidWYubGVuZ3RoLCBlbmQpXG5cbiAgZm9yICh2YXIgaSA9IHN0YXJ0OyBpIDwgZW5kOyArK2kpIHtcbiAgICByZXQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShidWZbaV0pXG4gIH1cbiAgcmV0dXJuIHJldFxufVxuXG5mdW5jdGlvbiBoZXhTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIHZhciBsZW4gPSBidWYubGVuZ3RoXG5cbiAgaWYgKCFzdGFydCB8fCBzdGFydCA8IDApIHN0YXJ0ID0gMFxuICBpZiAoIWVuZCB8fCBlbmQgPCAwIHx8IGVuZCA+IGxlbikgZW5kID0gbGVuXG5cbiAgdmFyIG91dCA9ICcnXG4gIGZvciAodmFyIGkgPSBzdGFydDsgaSA8IGVuZDsgKytpKSB7XG4gICAgb3V0ICs9IGhleFNsaWNlTG9va3VwVGFibGVbYnVmW2ldXVxuICB9XG4gIHJldHVybiBvdXRcbn1cblxuZnVuY3Rpb24gdXRmMTZsZVNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIGJ5dGVzID0gYnVmLnNsaWNlKHN0YXJ0LCBlbmQpXG4gIHZhciByZXMgPSAnJ1xuICAvLyBJZiBieXRlcy5sZW5ndGggaXMgb2RkLCB0aGUgbGFzdCA4IGJpdHMgbXVzdCBiZSBpZ25vcmVkIChzYW1lIGFzIG5vZGUuanMpXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYnl0ZXMubGVuZ3RoIC0gMTsgaSArPSAyKSB7XG4gICAgcmVzICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoYnl0ZXNbaV0gKyAoYnl0ZXNbaSArIDFdICogMjU2KSlcbiAgfVxuICByZXR1cm4gcmVzXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuc2xpY2UgPSBmdW5jdGlvbiBzbGljZSAoc3RhcnQsIGVuZCkge1xuICB2YXIgbGVuID0gdGhpcy5sZW5ndGhcbiAgc3RhcnQgPSB+fnN0YXJ0XG4gIGVuZCA9IGVuZCA9PT0gdW5kZWZpbmVkID8gbGVuIDogfn5lbmRcblxuICBpZiAoc3RhcnQgPCAwKSB7XG4gICAgc3RhcnQgKz0gbGVuXG4gICAgaWYgKHN0YXJ0IDwgMCkgc3RhcnQgPSAwXG4gIH0gZWxzZSBpZiAoc3RhcnQgPiBsZW4pIHtcbiAgICBzdGFydCA9IGxlblxuICB9XG5cbiAgaWYgKGVuZCA8IDApIHtcbiAgICBlbmQgKz0gbGVuXG4gICAgaWYgKGVuZCA8IDApIGVuZCA9IDBcbiAgfSBlbHNlIGlmIChlbmQgPiBsZW4pIHtcbiAgICBlbmQgPSBsZW5cbiAgfVxuXG4gIGlmIChlbmQgPCBzdGFydCkgZW5kID0gc3RhcnRcblxuICB2YXIgbmV3QnVmID0gdGhpcy5zdWJhcnJheShzdGFydCwgZW5kKVxuICAvLyBSZXR1cm4gYW4gYXVnbWVudGVkIGBVaW50OEFycmF5YCBpbnN0YW5jZVxuICBPYmplY3Quc2V0UHJvdG90eXBlT2YobmV3QnVmLCBCdWZmZXIucHJvdG90eXBlKVxuXG4gIHJldHVybiBuZXdCdWZcbn1cblxuLypcbiAqIE5lZWQgdG8gbWFrZSBzdXJlIHRoYXQgYnVmZmVyIGlzbid0IHRyeWluZyB0byB3cml0ZSBvdXQgb2YgYm91bmRzLlxuICovXG5mdW5jdGlvbiBjaGVja09mZnNldCAob2Zmc2V0LCBleHQsIGxlbmd0aCkge1xuICBpZiAoKG9mZnNldCAlIDEpICE9PSAwIHx8IG9mZnNldCA8IDApIHRocm93IG5ldyBSYW5nZUVycm9yKCdvZmZzZXQgaXMgbm90IHVpbnQnKVxuICBpZiAob2Zmc2V0ICsgZXh0ID4gbGVuZ3RoKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignVHJ5aW5nIHRvIGFjY2VzcyBiZXlvbmQgYnVmZmVyIGxlbmd0aCcpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVpbnRMRSA9XG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50TEUgPSBmdW5jdGlvbiByZWFkVUludExFIChvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIGJ5dGVMZW5ndGgsIHRoaXMubGVuZ3RoKVxuXG4gIHZhciB2YWwgPSB0aGlzW29mZnNldF1cbiAgdmFyIG11bCA9IDFcbiAgdmFyIGkgPSAwXG4gIHdoaWxlICgrK2kgPCBieXRlTGVuZ3RoICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgdmFsICs9IHRoaXNbb2Zmc2V0ICsgaV0gKiBtdWxcbiAgfVxuXG4gIHJldHVybiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVWludEJFID1cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnRCRSA9IGZ1bmN0aW9uIHJlYWRVSW50QkUgKG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBjaGVja09mZnNldChvZmZzZXQsIGJ5dGVMZW5ndGgsIHRoaXMubGVuZ3RoKVxuICB9XG5cbiAgdmFyIHZhbCA9IHRoaXNbb2Zmc2V0ICsgLS1ieXRlTGVuZ3RoXVxuICB2YXIgbXVsID0gMVxuICB3aGlsZSAoYnl0ZUxlbmd0aCA+IDAgJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICB2YWwgKz0gdGhpc1tvZmZzZXQgKyAtLWJ5dGVMZW5ndGhdICogbXVsXG4gIH1cblxuICByZXR1cm4gdmFsXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVpbnQ4ID1cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQ4ID0gZnVuY3Rpb24gcmVhZFVJbnQ4IChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDEsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gdGhpc1tvZmZzZXRdXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVpbnQxNkxFID1cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQxNkxFID0gZnVuY3Rpb24gcmVhZFVJbnQxNkxFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDIsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gdGhpc1tvZmZzZXRdIHwgKHRoaXNbb2Zmc2V0ICsgMV0gPDwgOClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVWludDE2QkUgPVxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDE2QkUgPSBmdW5jdGlvbiByZWFkVUludDE2QkUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMiwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiAodGhpc1tvZmZzZXRdIDw8IDgpIHwgdGhpc1tvZmZzZXQgKyAxXVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVaW50MzJMRSA9XG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50MzJMRSA9IGZ1bmN0aW9uIHJlYWRVSW50MzJMRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aClcblxuICByZXR1cm4gKCh0aGlzW29mZnNldF0pIHxcbiAgICAgICh0aGlzW29mZnNldCArIDFdIDw8IDgpIHxcbiAgICAgICh0aGlzW29mZnNldCArIDJdIDw8IDE2KSkgK1xuICAgICAgKHRoaXNbb2Zmc2V0ICsgM10gKiAweDEwMDAwMDApXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVpbnQzMkJFID1cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQzMkJFID0gZnVuY3Rpb24gcmVhZFVJbnQzMkJFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKVxuXG4gIHJldHVybiAodGhpc1tvZmZzZXRdICogMHgxMDAwMDAwKSArXG4gICAgKCh0aGlzW29mZnNldCArIDFdIDw8IDE2KSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgMl0gPDwgOCkgfFxuICAgIHRoaXNbb2Zmc2V0ICsgM10pXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludExFID0gZnVuY3Rpb24gcmVhZEludExFIChvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIGJ5dGVMZW5ndGgsIHRoaXMubGVuZ3RoKVxuXG4gIHZhciB2YWwgPSB0aGlzW29mZnNldF1cbiAgdmFyIG11bCA9IDFcbiAgdmFyIGkgPSAwXG4gIHdoaWxlICgrK2kgPCBieXRlTGVuZ3RoICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgdmFsICs9IHRoaXNbb2Zmc2V0ICsgaV0gKiBtdWxcbiAgfVxuICBtdWwgKj0gMHg4MFxuXG4gIGlmICh2YWwgPj0gbXVsKSB2YWwgLT0gTWF0aC5wb3coMiwgOCAqIGJ5dGVMZW5ndGgpXG5cbiAgcmV0dXJuIHZhbFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnRCRSA9IGZ1bmN0aW9uIHJlYWRJbnRCRSAob2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCBieXRlTGVuZ3RoLCB0aGlzLmxlbmd0aClcblxuICB2YXIgaSA9IGJ5dGVMZW5ndGhcbiAgdmFyIG11bCA9IDFcbiAgdmFyIHZhbCA9IHRoaXNbb2Zmc2V0ICsgLS1pXVxuICB3aGlsZSAoaSA+IDAgJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICB2YWwgKz0gdGhpc1tvZmZzZXQgKyAtLWldICogbXVsXG4gIH1cbiAgbXVsICo9IDB4ODBcblxuICBpZiAodmFsID49IG11bCkgdmFsIC09IE1hdGgucG93KDIsIDggKiBieXRlTGVuZ3RoKVxuXG4gIHJldHVybiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50OCA9IGZ1bmN0aW9uIHJlYWRJbnQ4IChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDEsIHRoaXMubGVuZ3RoKVxuICBpZiAoISh0aGlzW29mZnNldF0gJiAweDgwKSkgcmV0dXJuICh0aGlzW29mZnNldF0pXG4gIHJldHVybiAoKDB4ZmYgLSB0aGlzW29mZnNldF0gKyAxKSAqIC0xKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnQxNkxFID0gZnVuY3Rpb24gcmVhZEludDE2TEUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMiwgdGhpcy5sZW5ndGgpXG4gIHZhciB2YWwgPSB0aGlzW29mZnNldF0gfCAodGhpc1tvZmZzZXQgKyAxXSA8PCA4KVxuICByZXR1cm4gKHZhbCAmIDB4ODAwMCkgPyB2YWwgfCAweEZGRkYwMDAwIDogdmFsXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDE2QkUgPSBmdW5jdGlvbiByZWFkSW50MTZCRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCAyLCB0aGlzLmxlbmd0aClcbiAgdmFyIHZhbCA9IHRoaXNbb2Zmc2V0ICsgMV0gfCAodGhpc1tvZmZzZXRdIDw8IDgpXG4gIHJldHVybiAodmFsICYgMHg4MDAwKSA/IHZhbCB8IDB4RkZGRjAwMDAgOiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50MzJMRSA9IGZ1bmN0aW9uIHJlYWRJbnQzMkxFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKVxuXG4gIHJldHVybiAodGhpc1tvZmZzZXRdKSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgMV0gPDwgOCkgfFxuICAgICh0aGlzW29mZnNldCArIDJdIDw8IDE2KSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgM10gPDwgMjQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDMyQkUgPSBmdW5jdGlvbiByZWFkSW50MzJCRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aClcblxuICByZXR1cm4gKHRoaXNbb2Zmc2V0XSA8PCAyNCkgfFxuICAgICh0aGlzW29mZnNldCArIDFdIDw8IDE2KSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgMl0gPDwgOCkgfFxuICAgICh0aGlzW29mZnNldCArIDNdKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRGbG9hdExFID0gZnVuY3Rpb24gcmVhZEZsb2F0TEUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiBpZWVlNzU0LnJlYWQodGhpcywgb2Zmc2V0LCB0cnVlLCAyMywgNClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkRmxvYXRCRSA9IGZ1bmN0aW9uIHJlYWRGbG9hdEJFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gaWVlZTc1NC5yZWFkKHRoaXMsIG9mZnNldCwgZmFsc2UsIDIzLCA0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWREb3VibGVMRSA9IGZ1bmN0aW9uIHJlYWREb3VibGVMRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA4LCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuIGllZWU3NTQucmVhZCh0aGlzLCBvZmZzZXQsIHRydWUsIDUyLCA4KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWREb3VibGVCRSA9IGZ1bmN0aW9uIHJlYWREb3VibGVCRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA4LCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuIGllZWU3NTQucmVhZCh0aGlzLCBvZmZzZXQsIGZhbHNlLCA1MiwgOClcbn1cblxuZnVuY3Rpb24gY2hlY2tJbnQgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgZXh0LCBtYXgsIG1pbikge1xuICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihidWYpKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdcImJ1ZmZlclwiIGFyZ3VtZW50IG11c3QgYmUgYSBCdWZmZXIgaW5zdGFuY2UnKVxuICBpZiAodmFsdWUgPiBtYXggfHwgdmFsdWUgPCBtaW4pIHRocm93IG5ldyBSYW5nZUVycm9yKCdcInZhbHVlXCIgYXJndW1lbnQgaXMgb3V0IG9mIGJvdW5kcycpXG4gIGlmIChvZmZzZXQgKyBleHQgPiBidWYubGVuZ3RoKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignSW5kZXggb3V0IG9mIHJhbmdlJylcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVpbnRMRSA9XG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludExFID0gZnVuY3Rpb24gd3JpdGVVSW50TEUgKHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgdmFyIG1heEJ5dGVzID0gTWF0aC5wb3coMiwgOCAqIGJ5dGVMZW5ndGgpIC0gMVxuICAgIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIG1heEJ5dGVzLCAwKVxuICB9XG5cbiAgdmFyIG11bCA9IDFcbiAgdmFyIGkgPSAwXG4gIHRoaXNbb2Zmc2V0XSA9IHZhbHVlICYgMHhGRlxuICB3aGlsZSAoKytpIDwgYnl0ZUxlbmd0aCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIHRoaXNbb2Zmc2V0ICsgaV0gPSAodmFsdWUgLyBtdWwpICYgMHhGRlxuICB9XG5cbiAgcmV0dXJuIG9mZnNldCArIGJ5dGVMZW5ndGhcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVpbnRCRSA9XG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludEJFID0gZnVuY3Rpb24gd3JpdGVVSW50QkUgKHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgdmFyIG1heEJ5dGVzID0gTWF0aC5wb3coMiwgOCAqIGJ5dGVMZW5ndGgpIC0gMVxuICAgIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIG1heEJ5dGVzLCAwKVxuICB9XG5cbiAgdmFyIGkgPSBieXRlTGVuZ3RoIC0gMVxuICB2YXIgbXVsID0gMVxuICB0aGlzW29mZnNldCArIGldID0gdmFsdWUgJiAweEZGXG4gIHdoaWxlICgtLWkgPj0gMCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIHRoaXNbb2Zmc2V0ICsgaV0gPSAodmFsdWUgLyBtdWwpICYgMHhGRlxuICB9XG5cbiAgcmV0dXJuIG9mZnNldCArIGJ5dGVMZW5ndGhcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVpbnQ4ID1cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50OCA9IGZ1bmN0aW9uIHdyaXRlVUludDggKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAxLCAweGZmLCAwKVxuICB0aGlzW29mZnNldF0gPSAodmFsdWUgJiAweGZmKVxuICByZXR1cm4gb2Zmc2V0ICsgMVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVWludDE2TEUgPVxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQxNkxFID0gZnVuY3Rpb24gd3JpdGVVSW50MTZMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDIsIDB4ZmZmZiwgMClcbiAgdGhpc1tvZmZzZXRdID0gKHZhbHVlICYgMHhmZilcbiAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gOClcbiAgcmV0dXJuIG9mZnNldCArIDJcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVpbnQxNkJFID1cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50MTZCRSA9IGZ1bmN0aW9uIHdyaXRlVUludDE2QkUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAyLCAweGZmZmYsIDApXG4gIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSA+Pj4gOClcbiAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIHJldHVybiBvZmZzZXQgKyAyXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVaW50MzJMRSA9XG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludDMyTEUgPSBmdW5jdGlvbiB3cml0ZVVJbnQzMkxFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgNCwgMHhmZmZmZmZmZiwgMClcbiAgdGhpc1tvZmZzZXQgKyAzXSA9ICh2YWx1ZSA+Pj4gMjQpXG4gIHRoaXNbb2Zmc2V0ICsgMl0gPSAodmFsdWUgPj4+IDE2KVxuICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiA4KVxuICB0aGlzW29mZnNldF0gPSAodmFsdWUgJiAweGZmKVxuICByZXR1cm4gb2Zmc2V0ICsgNFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVWludDMyQkUgPVxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQzMkJFID0gZnVuY3Rpb24gd3JpdGVVSW50MzJCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDQsIDB4ZmZmZmZmZmYsIDApXG4gIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSA+Pj4gMjQpXG4gIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDE2KVxuICB0aGlzW29mZnNldCArIDJdID0gKHZhbHVlID4+PiA4KVxuICB0aGlzW29mZnNldCArIDNdID0gKHZhbHVlICYgMHhmZilcbiAgcmV0dXJuIG9mZnNldCArIDRcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludExFID0gZnVuY3Rpb24gd3JpdGVJbnRMRSAodmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICB2YXIgbGltaXQgPSBNYXRoLnBvdygyLCAoOCAqIGJ5dGVMZW5ndGgpIC0gMSlcblxuICAgIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIGxpbWl0IC0gMSwgLWxpbWl0KVxuICB9XG5cbiAgdmFyIGkgPSAwXG4gIHZhciBtdWwgPSAxXG4gIHZhciBzdWIgPSAwXG4gIHRoaXNbb2Zmc2V0XSA9IHZhbHVlICYgMHhGRlxuICB3aGlsZSAoKytpIDwgYnl0ZUxlbmd0aCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIGlmICh2YWx1ZSA8IDAgJiYgc3ViID09PSAwICYmIHRoaXNbb2Zmc2V0ICsgaSAtIDFdICE9PSAwKSB7XG4gICAgICBzdWIgPSAxXG4gICAgfVxuICAgIHRoaXNbb2Zmc2V0ICsgaV0gPSAoKHZhbHVlIC8gbXVsKSA+PiAwKSAtIHN1YiAmIDB4RkZcbiAgfVxuXG4gIHJldHVybiBvZmZzZXQgKyBieXRlTGVuZ3RoXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnRCRSA9IGZ1bmN0aW9uIHdyaXRlSW50QkUgKHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgdmFyIGxpbWl0ID0gTWF0aC5wb3coMiwgKDggKiBieXRlTGVuZ3RoKSAtIDEpXG5cbiAgICBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBsaW1pdCAtIDEsIC1saW1pdClcbiAgfVxuXG4gIHZhciBpID0gYnl0ZUxlbmd0aCAtIDFcbiAgdmFyIG11bCA9IDFcbiAgdmFyIHN1YiA9IDBcbiAgdGhpc1tvZmZzZXQgKyBpXSA9IHZhbHVlICYgMHhGRlxuICB3aGlsZSAoLS1pID49IDAgJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICBpZiAodmFsdWUgPCAwICYmIHN1YiA9PT0gMCAmJiB0aGlzW29mZnNldCArIGkgKyAxXSAhPT0gMCkge1xuICAgICAgc3ViID0gMVxuICAgIH1cbiAgICB0aGlzW29mZnNldCArIGldID0gKCh2YWx1ZSAvIG11bCkgPj4gMCkgLSBzdWIgJiAweEZGXG4gIH1cblxuICByZXR1cm4gb2Zmc2V0ICsgYnl0ZUxlbmd0aFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50OCA9IGZ1bmN0aW9uIHdyaXRlSW50OCAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDEsIDB4N2YsIC0weDgwKVxuICBpZiAodmFsdWUgPCAwKSB2YWx1ZSA9IDB4ZmYgKyB2YWx1ZSArIDFcbiAgdGhpc1tvZmZzZXRdID0gKHZhbHVlICYgMHhmZilcbiAgcmV0dXJuIG9mZnNldCArIDFcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDE2TEUgPSBmdW5jdGlvbiB3cml0ZUludDE2TEUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAyLCAweDdmZmYsIC0weDgwMDApXG4gIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDgpXG4gIHJldHVybiBvZmZzZXQgKyAyXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQxNkJFID0gZnVuY3Rpb24gd3JpdGVJbnQxNkJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMiwgMHg3ZmZmLCAtMHg4MDAwKVxuICB0aGlzW29mZnNldF0gPSAodmFsdWUgPj4+IDgpXG4gIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgJiAweGZmKVxuICByZXR1cm4gb2Zmc2V0ICsgMlxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50MzJMRSA9IGZ1bmN0aW9uIHdyaXRlSW50MzJMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDQsIDB4N2ZmZmZmZmYsIC0weDgwMDAwMDAwKVxuICB0aGlzW29mZnNldF0gPSAodmFsdWUgJiAweGZmKVxuICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiA4KVxuICB0aGlzW29mZnNldCArIDJdID0gKHZhbHVlID4+PiAxNilcbiAgdGhpc1tvZmZzZXQgKyAzXSA9ICh2YWx1ZSA+Pj4gMjQpXG4gIHJldHVybiBvZmZzZXQgKyA0XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQzMkJFID0gZnVuY3Rpb24gd3JpdGVJbnQzMkJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgNCwgMHg3ZmZmZmZmZiwgLTB4ODAwMDAwMDApXG4gIGlmICh2YWx1ZSA8IDApIHZhbHVlID0gMHhmZmZmZmZmZiArIHZhbHVlICsgMVxuICB0aGlzW29mZnNldF0gPSAodmFsdWUgPj4+IDI0KVxuICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiAxNilcbiAgdGhpc1tvZmZzZXQgKyAyXSA9ICh2YWx1ZSA+Pj4gOClcbiAgdGhpc1tvZmZzZXQgKyAzXSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIHJldHVybiBvZmZzZXQgKyA0XG59XG5cbmZ1bmN0aW9uIGNoZWNrSUVFRTc1NCAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBleHQsIG1heCwgbWluKSB7XG4gIGlmIChvZmZzZXQgKyBleHQgPiBidWYubGVuZ3RoKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignSW5kZXggb3V0IG9mIHJhbmdlJylcbiAgaWYgKG9mZnNldCA8IDApIHRocm93IG5ldyBSYW5nZUVycm9yKCdJbmRleCBvdXQgb2YgcmFuZ2UnKVxufVxuXG5mdW5jdGlvbiB3cml0ZUZsb2F0IChidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBjaGVja0lFRUU3NTQoYnVmLCB2YWx1ZSwgb2Zmc2V0LCA0LCAzLjQwMjgyMzQ2NjM4NTI4ODZlKzM4LCAtMy40MDI4MjM0NjYzODUyODg2ZSszOClcbiAgfVxuICBpZWVlNzU0LndyaXRlKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCAyMywgNClcbiAgcmV0dXJuIG9mZnNldCArIDRcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUZsb2F0TEUgPSBmdW5jdGlvbiB3cml0ZUZsb2F0TEUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiB3cml0ZUZsb2F0KHRoaXMsIHZhbHVlLCBvZmZzZXQsIHRydWUsIG5vQXNzZXJ0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlRmxvYXRCRSA9IGZ1bmN0aW9uIHdyaXRlRmxvYXRCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIHdyaXRlRmxvYXQodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UsIG5vQXNzZXJ0KVxufVxuXG5mdW5jdGlvbiB3cml0ZURvdWJsZSAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgY2hlY2tJRUVFNzU0KGJ1ZiwgdmFsdWUsIG9mZnNldCwgOCwgMS43OTc2OTMxMzQ4NjIzMTU3RSszMDgsIC0xLjc5NzY5MzEzNDg2MjMxNTdFKzMwOClcbiAgfVxuICBpZWVlNzU0LndyaXRlKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCA1MiwgOClcbiAgcmV0dXJuIG9mZnNldCArIDhcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZURvdWJsZUxFID0gZnVuY3Rpb24gd3JpdGVEb3VibGVMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIHdyaXRlRG91YmxlKHRoaXMsIHZhbHVlLCBvZmZzZXQsIHRydWUsIG5vQXNzZXJ0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlRG91YmxlQkUgPSBmdW5jdGlvbiB3cml0ZURvdWJsZUJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gd3JpdGVEb3VibGUodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UsIG5vQXNzZXJ0KVxufVxuXG4vLyBjb3B5KHRhcmdldEJ1ZmZlciwgdGFyZ2V0U3RhcnQ9MCwgc291cmNlU3RhcnQ9MCwgc291cmNlRW5kPWJ1ZmZlci5sZW5ndGgpXG5CdWZmZXIucHJvdG90eXBlLmNvcHkgPSBmdW5jdGlvbiBjb3B5ICh0YXJnZXQsIHRhcmdldFN0YXJ0LCBzdGFydCwgZW5kKSB7XG4gIGlmICghQnVmZmVyLmlzQnVmZmVyKHRhcmdldCkpIHRocm93IG5ldyBUeXBlRXJyb3IoJ2FyZ3VtZW50IHNob3VsZCBiZSBhIEJ1ZmZlcicpXG4gIGlmICghc3RhcnQpIHN0YXJ0ID0gMFxuICBpZiAoIWVuZCAmJiBlbmQgIT09IDApIGVuZCA9IHRoaXMubGVuZ3RoXG4gIGlmICh0YXJnZXRTdGFydCA+PSB0YXJnZXQubGVuZ3RoKSB0YXJnZXRTdGFydCA9IHRhcmdldC5sZW5ndGhcbiAgaWYgKCF0YXJnZXRTdGFydCkgdGFyZ2V0U3RhcnQgPSAwXG4gIGlmIChlbmQgPiAwICYmIGVuZCA8IHN0YXJ0KSBlbmQgPSBzdGFydFxuXG4gIC8vIENvcHkgMCBieXRlczsgd2UncmUgZG9uZVxuICBpZiAoZW5kID09PSBzdGFydCkgcmV0dXJuIDBcbiAgaWYgKHRhcmdldC5sZW5ndGggPT09IDAgfHwgdGhpcy5sZW5ndGggPT09IDApIHJldHVybiAwXG5cbiAgLy8gRmF0YWwgZXJyb3IgY29uZGl0aW9uc1xuICBpZiAodGFyZ2V0U3RhcnQgPCAwKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ3RhcmdldFN0YXJ0IG91dCBvZiBib3VuZHMnKVxuICB9XG4gIGlmIChzdGFydCA8IDAgfHwgc3RhcnQgPj0gdGhpcy5sZW5ndGgpIHRocm93IG5ldyBSYW5nZUVycm9yKCdJbmRleCBvdXQgb2YgcmFuZ2UnKVxuICBpZiAoZW5kIDwgMCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ3NvdXJjZUVuZCBvdXQgb2YgYm91bmRzJylcblxuICAvLyBBcmUgd2Ugb29iP1xuICBpZiAoZW5kID4gdGhpcy5sZW5ndGgpIGVuZCA9IHRoaXMubGVuZ3RoXG4gIGlmICh0YXJnZXQubGVuZ3RoIC0gdGFyZ2V0U3RhcnQgPCBlbmQgLSBzdGFydCkge1xuICAgIGVuZCA9IHRhcmdldC5sZW5ndGggLSB0YXJnZXRTdGFydCArIHN0YXJ0XG4gIH1cblxuICB2YXIgbGVuID0gZW5kIC0gc3RhcnRcblxuICBpZiAodGhpcyA9PT0gdGFyZ2V0ICYmIHR5cGVvZiBVaW50OEFycmF5LnByb3RvdHlwZS5jb3B5V2l0aGluID09PSAnZnVuY3Rpb24nKSB7XG4gICAgLy8gVXNlIGJ1aWx0LWluIHdoZW4gYXZhaWxhYmxlLCBtaXNzaW5nIGZyb20gSUUxMVxuICAgIHRoaXMuY29weVdpdGhpbih0YXJnZXRTdGFydCwgc3RhcnQsIGVuZClcbiAgfSBlbHNlIHtcbiAgICBVaW50OEFycmF5LnByb3RvdHlwZS5zZXQuY2FsbChcbiAgICAgIHRhcmdldCxcbiAgICAgIHRoaXMuc3ViYXJyYXkoc3RhcnQsIGVuZCksXG4gICAgICB0YXJnZXRTdGFydFxuICAgIClcbiAgfVxuXG4gIHJldHVybiBsZW5cbn1cblxuLy8gVXNhZ2U6XG4vLyAgICBidWZmZXIuZmlsbChudW1iZXJbLCBvZmZzZXRbLCBlbmRdXSlcbi8vICAgIGJ1ZmZlci5maWxsKGJ1ZmZlclssIG9mZnNldFssIGVuZF1dKVxuLy8gICAgYnVmZmVyLmZpbGwoc3RyaW5nWywgb2Zmc2V0WywgZW5kXV1bLCBlbmNvZGluZ10pXG5CdWZmZXIucHJvdG90eXBlLmZpbGwgPSBmdW5jdGlvbiBmaWxsICh2YWwsIHN0YXJ0LCBlbmQsIGVuY29kaW5nKSB7XG4gIC8vIEhhbmRsZSBzdHJpbmcgY2FzZXM6XG4gIGlmICh0eXBlb2YgdmFsID09PSAnc3RyaW5nJykge1xuICAgIGlmICh0eXBlb2Ygc3RhcnQgPT09ICdzdHJpbmcnKSB7XG4gICAgICBlbmNvZGluZyA9IHN0YXJ0XG4gICAgICBzdGFydCA9IDBcbiAgICAgIGVuZCA9IHRoaXMubGVuZ3RoXG4gICAgfSBlbHNlIGlmICh0eXBlb2YgZW5kID09PSAnc3RyaW5nJykge1xuICAgICAgZW5jb2RpbmcgPSBlbmRcbiAgICAgIGVuZCA9IHRoaXMubGVuZ3RoXG4gICAgfVxuICAgIGlmIChlbmNvZGluZyAhPT0gdW5kZWZpbmVkICYmIHR5cGVvZiBlbmNvZGluZyAhPT0gJ3N0cmluZycpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2VuY29kaW5nIG11c3QgYmUgYSBzdHJpbmcnKVxuICAgIH1cbiAgICBpZiAodHlwZW9mIGVuY29kaW5nID09PSAnc3RyaW5nJyAmJiAhQnVmZmVyLmlzRW5jb2RpbmcoZW5jb2RpbmcpKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdVbmtub3duIGVuY29kaW5nOiAnICsgZW5jb2RpbmcpXG4gICAgfVxuICAgIGlmICh2YWwubGVuZ3RoID09PSAxKSB7XG4gICAgICB2YXIgY29kZSA9IHZhbC5jaGFyQ29kZUF0KDApXG4gICAgICBpZiAoKGVuY29kaW5nID09PSAndXRmOCcgJiYgY29kZSA8IDEyOCkgfHxcbiAgICAgICAgICBlbmNvZGluZyA9PT0gJ2xhdGluMScpIHtcbiAgICAgICAgLy8gRmFzdCBwYXRoOiBJZiBgdmFsYCBmaXRzIGludG8gYSBzaW5nbGUgYnl0ZSwgdXNlIHRoYXQgbnVtZXJpYyB2YWx1ZS5cbiAgICAgICAgdmFsID0gY29kZVxuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIGlmICh0eXBlb2YgdmFsID09PSAnbnVtYmVyJykge1xuICAgIHZhbCA9IHZhbCAmIDI1NVxuICB9IGVsc2UgaWYgKHR5cGVvZiB2YWwgPT09ICdib29sZWFuJykge1xuICAgIHZhbCA9IE51bWJlcih2YWwpXG4gIH1cblxuICAvLyBJbnZhbGlkIHJhbmdlcyBhcmUgbm90IHNldCB0byBhIGRlZmF1bHQsIHNvIGNhbiByYW5nZSBjaGVjayBlYXJseS5cbiAgaWYgKHN0YXJ0IDwgMCB8fCB0aGlzLmxlbmd0aCA8IHN0YXJ0IHx8IHRoaXMubGVuZ3RoIDwgZW5kKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ091dCBvZiByYW5nZSBpbmRleCcpXG4gIH1cblxuICBpZiAoZW5kIDw9IHN0YXJ0KSB7XG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIHN0YXJ0ID0gc3RhcnQgPj4+IDBcbiAgZW5kID0gZW5kID09PSB1bmRlZmluZWQgPyB0aGlzLmxlbmd0aCA6IGVuZCA+Pj4gMFxuXG4gIGlmICghdmFsKSB2YWwgPSAwXG5cbiAgdmFyIGlcbiAgaWYgKHR5cGVvZiB2YWwgPT09ICdudW1iZXInKSB7XG4gICAgZm9yIChpID0gc3RhcnQ7IGkgPCBlbmQ7ICsraSkge1xuICAgICAgdGhpc1tpXSA9IHZhbFxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB2YXIgYnl0ZXMgPSBCdWZmZXIuaXNCdWZmZXIodmFsKVxuICAgICAgPyB2YWxcbiAgICAgIDogQnVmZmVyLmZyb20odmFsLCBlbmNvZGluZylcbiAgICB2YXIgbGVuID0gYnl0ZXMubGVuZ3RoXG4gICAgaWYgKGxlbiA9PT0gMCkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVGhlIHZhbHVlIFwiJyArIHZhbCArXG4gICAgICAgICdcIiBpcyBpbnZhbGlkIGZvciBhcmd1bWVudCBcInZhbHVlXCInKVxuICAgIH1cbiAgICBmb3IgKGkgPSAwOyBpIDwgZW5kIC0gc3RhcnQ7ICsraSkge1xuICAgICAgdGhpc1tpICsgc3RhcnRdID0gYnl0ZXNbaSAlIGxlbl1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gdGhpc1xufVxuXG4vLyBIRUxQRVIgRlVOQ1RJT05TXG4vLyA9PT09PT09PT09PT09PT09XG5cbnZhciBJTlZBTElEX0JBU0U2NF9SRSA9IC9bXisvMC05QS1aYS16LV9dL2dcblxuZnVuY3Rpb24gYmFzZTY0Y2xlYW4gKHN0cikge1xuICAvLyBOb2RlIHRha2VzIGVxdWFsIHNpZ25zIGFzIGVuZCBvZiB0aGUgQmFzZTY0IGVuY29kaW5nXG4gIHN0ciA9IHN0ci5zcGxpdCgnPScpWzBdXG4gIC8vIE5vZGUgc3RyaXBzIG91dCBpbnZhbGlkIGNoYXJhY3RlcnMgbGlrZSBcXG4gYW5kIFxcdCBmcm9tIHRoZSBzdHJpbmcsIGJhc2U2NC1qcyBkb2VzIG5vdFxuICBzdHIgPSBzdHIudHJpbSgpLnJlcGxhY2UoSU5WQUxJRF9CQVNFNjRfUkUsICcnKVxuICAvLyBOb2RlIGNvbnZlcnRzIHN0cmluZ3Mgd2l0aCBsZW5ndGggPCAyIHRvICcnXG4gIGlmIChzdHIubGVuZ3RoIDwgMikgcmV0dXJuICcnXG4gIC8vIE5vZGUgYWxsb3dzIGZvciBub24tcGFkZGVkIGJhc2U2NCBzdHJpbmdzIChtaXNzaW5nIHRyYWlsaW5nID09PSksIGJhc2U2NC1qcyBkb2VzIG5vdFxuICB3aGlsZSAoc3RyLmxlbmd0aCAlIDQgIT09IDApIHtcbiAgICBzdHIgPSBzdHIgKyAnPSdcbiAgfVxuICByZXR1cm4gc3RyXG59XG5cbmZ1bmN0aW9uIHV0ZjhUb0J5dGVzIChzdHJpbmcsIHVuaXRzKSB7XG4gIHVuaXRzID0gdW5pdHMgfHwgSW5maW5pdHlcbiAgdmFyIGNvZGVQb2ludFxuICB2YXIgbGVuZ3RoID0gc3RyaW5nLmxlbmd0aFxuICB2YXIgbGVhZFN1cnJvZ2F0ZSA9IG51bGxcbiAgdmFyIGJ5dGVzID0gW11cblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgKytpKSB7XG4gICAgY29kZVBvaW50ID0gc3RyaW5nLmNoYXJDb2RlQXQoaSlcblxuICAgIC8vIGlzIHN1cnJvZ2F0ZSBjb21wb25lbnRcbiAgICBpZiAoY29kZVBvaW50ID4gMHhEN0ZGICYmIGNvZGVQb2ludCA8IDB4RTAwMCkge1xuICAgICAgLy8gbGFzdCBjaGFyIHdhcyBhIGxlYWRcbiAgICAgIGlmICghbGVhZFN1cnJvZ2F0ZSkge1xuICAgICAgICAvLyBubyBsZWFkIHlldFxuICAgICAgICBpZiAoY29kZVBvaW50ID4gMHhEQkZGKSB7XG4gICAgICAgICAgLy8gdW5leHBlY3RlZCB0cmFpbFxuICAgICAgICAgIGlmICgodW5pdHMgLT0gMykgPiAtMSkgYnl0ZXMucHVzaCgweEVGLCAweEJGLCAweEJEKVxuICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgIH0gZWxzZSBpZiAoaSArIDEgPT09IGxlbmd0aCkge1xuICAgICAgICAgIC8vIHVucGFpcmVkIGxlYWRcbiAgICAgICAgICBpZiAoKHVuaXRzIC09IDMpID4gLTEpIGJ5dGVzLnB1c2goMHhFRiwgMHhCRiwgMHhCRClcbiAgICAgICAgICBjb250aW51ZVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gdmFsaWQgbGVhZFxuICAgICAgICBsZWFkU3Vycm9nYXRlID0gY29kZVBvaW50XG5cbiAgICAgICAgY29udGludWVcbiAgICAgIH1cblxuICAgICAgLy8gMiBsZWFkcyBpbiBhIHJvd1xuICAgICAgaWYgKGNvZGVQb2ludCA8IDB4REMwMCkge1xuICAgICAgICBpZiAoKHVuaXRzIC09IDMpID4gLTEpIGJ5dGVzLnB1c2goMHhFRiwgMHhCRiwgMHhCRClcbiAgICAgICAgbGVhZFN1cnJvZ2F0ZSA9IGNvZGVQb2ludFxuICAgICAgICBjb250aW51ZVxuICAgICAgfVxuXG4gICAgICAvLyB2YWxpZCBzdXJyb2dhdGUgcGFpclxuICAgICAgY29kZVBvaW50ID0gKGxlYWRTdXJyb2dhdGUgLSAweEQ4MDAgPDwgMTAgfCBjb2RlUG9pbnQgLSAweERDMDApICsgMHgxMDAwMFxuICAgIH0gZWxzZSBpZiAobGVhZFN1cnJvZ2F0ZSkge1xuICAgICAgLy8gdmFsaWQgYm1wIGNoYXIsIGJ1dCBsYXN0IGNoYXIgd2FzIGEgbGVhZFxuICAgICAgaWYgKCh1bml0cyAtPSAzKSA+IC0xKSBieXRlcy5wdXNoKDB4RUYsIDB4QkYsIDB4QkQpXG4gICAgfVxuXG4gICAgbGVhZFN1cnJvZ2F0ZSA9IG51bGxcblxuICAgIC8vIGVuY29kZSB1dGY4XG4gICAgaWYgKGNvZGVQb2ludCA8IDB4ODApIHtcbiAgICAgIGlmICgodW5pdHMgLT0gMSkgPCAwKSBicmVha1xuICAgICAgYnl0ZXMucHVzaChjb2RlUG9pbnQpXG4gICAgfSBlbHNlIGlmIChjb2RlUG9pbnQgPCAweDgwMCkge1xuICAgICAgaWYgKCh1bml0cyAtPSAyKSA8IDApIGJyZWFrXG4gICAgICBieXRlcy5wdXNoKFxuICAgICAgICBjb2RlUG9pbnQgPj4gMHg2IHwgMHhDMCxcbiAgICAgICAgY29kZVBvaW50ICYgMHgzRiB8IDB4ODBcbiAgICAgIClcbiAgICB9IGVsc2UgaWYgKGNvZGVQb2ludCA8IDB4MTAwMDApIHtcbiAgICAgIGlmICgodW5pdHMgLT0gMykgPCAwKSBicmVha1xuICAgICAgYnl0ZXMucHVzaChcbiAgICAgICAgY29kZVBvaW50ID4+IDB4QyB8IDB4RTAsXG4gICAgICAgIGNvZGVQb2ludCA+PiAweDYgJiAweDNGIHwgMHg4MCxcbiAgICAgICAgY29kZVBvaW50ICYgMHgzRiB8IDB4ODBcbiAgICAgIClcbiAgICB9IGVsc2UgaWYgKGNvZGVQb2ludCA8IDB4MTEwMDAwKSB7XG4gICAgICBpZiAoKHVuaXRzIC09IDQpIDwgMCkgYnJlYWtcbiAgICAgIGJ5dGVzLnB1c2goXG4gICAgICAgIGNvZGVQb2ludCA+PiAweDEyIHwgMHhGMCxcbiAgICAgICAgY29kZVBvaW50ID4+IDB4QyAmIDB4M0YgfCAweDgwLFxuICAgICAgICBjb2RlUG9pbnQgPj4gMHg2ICYgMHgzRiB8IDB4ODAsXG4gICAgICAgIGNvZGVQb2ludCAmIDB4M0YgfCAweDgwXG4gICAgICApXG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBjb2RlIHBvaW50JylcbiAgICB9XG4gIH1cblxuICByZXR1cm4gYnl0ZXNcbn1cblxuZnVuY3Rpb24gYXNjaWlUb0J5dGVzIChzdHIpIHtcbiAgdmFyIGJ5dGVBcnJheSA9IFtdXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgKytpKSB7XG4gICAgLy8gTm9kZSdzIGNvZGUgc2VlbXMgdG8gYmUgZG9pbmcgdGhpcyBhbmQgbm90ICYgMHg3Ri4uXG4gICAgYnl0ZUFycmF5LnB1c2goc3RyLmNoYXJDb2RlQXQoaSkgJiAweEZGKVxuICB9XG4gIHJldHVybiBieXRlQXJyYXlcbn1cblxuZnVuY3Rpb24gdXRmMTZsZVRvQnl0ZXMgKHN0ciwgdW5pdHMpIHtcbiAgdmFyIGMsIGhpLCBsb1xuICB2YXIgYnl0ZUFycmF5ID0gW11cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyArK2kpIHtcbiAgICBpZiAoKHVuaXRzIC09IDIpIDwgMCkgYnJlYWtcblxuICAgIGMgPSBzdHIuY2hhckNvZGVBdChpKVxuICAgIGhpID0gYyA+PiA4XG4gICAgbG8gPSBjICUgMjU2XG4gICAgYnl0ZUFycmF5LnB1c2gobG8pXG4gICAgYnl0ZUFycmF5LnB1c2goaGkpXG4gIH1cblxuICByZXR1cm4gYnl0ZUFycmF5XG59XG5cbmZ1bmN0aW9uIGJhc2U2NFRvQnl0ZXMgKHN0cikge1xuICByZXR1cm4gYmFzZTY0LnRvQnl0ZUFycmF5KGJhc2U2NGNsZWFuKHN0cikpXG59XG5cbmZ1bmN0aW9uIGJsaXRCdWZmZXIgKHNyYywgZHN0LCBvZmZzZXQsIGxlbmd0aCkge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgKytpKSB7XG4gICAgaWYgKChpICsgb2Zmc2V0ID49IGRzdC5sZW5ndGgpIHx8IChpID49IHNyYy5sZW5ndGgpKSBicmVha1xuICAgIGRzdFtpICsgb2Zmc2V0XSA9IHNyY1tpXVxuICB9XG4gIHJldHVybiBpXG59XG5cbi8vIEFycmF5QnVmZmVyIG9yIFVpbnQ4QXJyYXkgb2JqZWN0cyBmcm9tIG90aGVyIGNvbnRleHRzIChpLmUuIGlmcmFtZXMpIGRvIG5vdCBwYXNzXG4vLyB0aGUgYGluc3RhbmNlb2ZgIGNoZWNrIGJ1dCB0aGV5IHNob3VsZCBiZSB0cmVhdGVkIGFzIG9mIHRoYXQgdHlwZS5cbi8vIFNlZTogaHR0cHM6Ly9naXRodWIuY29tL2Zlcm9zcy9idWZmZXIvaXNzdWVzLzE2NlxuZnVuY3Rpb24gaXNJbnN0YW5jZSAob2JqLCB0eXBlKSB7XG4gIHJldHVybiBvYmogaW5zdGFuY2VvZiB0eXBlIHx8XG4gICAgKG9iaiAhPSBudWxsICYmIG9iai5jb25zdHJ1Y3RvciAhPSBudWxsICYmIG9iai5jb25zdHJ1Y3Rvci5uYW1lICE9IG51bGwgJiZcbiAgICAgIG9iai5jb25zdHJ1Y3Rvci5uYW1lID09PSB0eXBlLm5hbWUpXG59XG5mdW5jdGlvbiBudW1iZXJJc05hTiAob2JqKSB7XG4gIC8vIEZvciBJRTExIHN1cHBvcnRcbiAgcmV0dXJuIG9iaiAhPT0gb2JqIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tc2VsZi1jb21wYXJlXG59XG5cbi8vIENyZWF0ZSBsb29rdXAgdGFibGUgZm9yIGB0b1N0cmluZygnaGV4JylgXG4vLyBTZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9mZXJvc3MvYnVmZmVyL2lzc3Vlcy8yMTlcbnZhciBoZXhTbGljZUxvb2t1cFRhYmxlID0gKGZ1bmN0aW9uICgpIHtcbiAgdmFyIGFscGhhYmV0ID0gJzAxMjM0NTY3ODlhYmNkZWYnXG4gIHZhciB0YWJsZSA9IG5ldyBBcnJheSgyNTYpXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgMTY7ICsraSkge1xuICAgIHZhciBpMTYgPSBpICogMTZcbiAgICBmb3IgKHZhciBqID0gMDsgaiA8IDE2OyArK2opIHtcbiAgICAgIHRhYmxlW2kxNiArIGpdID0gYWxwaGFiZXRbaV0gKyBhbHBoYWJldFtqXVxuICAgIH1cbiAgfVxuICByZXR1cm4gdGFibGVcbn0pKClcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../../node_modules/buffer/index.js\n"));

/***/ }),

/***/ "../../node_modules/ieee754/index.js":
/*!*******************************************!*\
  !*** ../../node_modules/ieee754/index.js ***!
  \*******************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval(__webpack_require__.ts("/*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */\nexports.read = function (buffer, offset, isLE, mLen, nBytes) {\n  var e, m\n  var eLen = (nBytes * 8) - mLen - 1\n  var eMax = (1 << eLen) - 1\n  var eBias = eMax >> 1\n  var nBits = -7\n  var i = isLE ? (nBytes - 1) : 0\n  var d = isLE ? -1 : 1\n  var s = buffer[offset + i]\n\n  i += d\n\n  e = s & ((1 << (-nBits)) - 1)\n  s >>= (-nBits)\n  nBits += eLen\n  for (; nBits > 0; e = (e * 256) + buffer[offset + i], i += d, nBits -= 8) {}\n\n  m = e & ((1 << (-nBits)) - 1)\n  e >>= (-nBits)\n  nBits += mLen\n  for (; nBits > 0; m = (m * 256) + buffer[offset + i], i += d, nBits -= 8) {}\n\n  if (e === 0) {\n    e = 1 - eBias\n  } else if (e === eMax) {\n    return m ? NaN : ((s ? -1 : 1) * Infinity)\n  } else {\n    m = m + Math.pow(2, mLen)\n    e = e - eBias\n  }\n  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)\n}\n\nexports.write = function (buffer, value, offset, isLE, mLen, nBytes) {\n  var e, m, c\n  var eLen = (nBytes * 8) - mLen - 1\n  var eMax = (1 << eLen) - 1\n  var eBias = eMax >> 1\n  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)\n  var i = isLE ? 0 : (nBytes - 1)\n  var d = isLE ? 1 : -1\n  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0\n\n  value = Math.abs(value)\n\n  if (isNaN(value) || value === Infinity) {\n    m = isNaN(value) ? 1 : 0\n    e = eMax\n  } else {\n    e = Math.floor(Math.log(value) / Math.LN2)\n    if (value * (c = Math.pow(2, -e)) < 1) {\n      e--\n      c *= 2\n    }\n    if (e + eBias >= 1) {\n      value += rt / c\n    } else {\n      value += rt * Math.pow(2, 1 - eBias)\n    }\n    if (value * c >= 2) {\n      e++\n      c /= 2\n    }\n\n    if (e + eBias >= eMax) {\n      m = 0\n      e = eMax\n    } else if (e + eBias >= 1) {\n      m = ((value * c) - 1) * Math.pow(2, mLen)\n      e = e + eBias\n    } else {\n      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)\n      e = 0\n    }\n  }\n\n  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}\n\n  e = (e << mLen) | m\n  eLen += mLen\n  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}\n\n  buffer[offset + i - d] |= s * 128\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vLi4vbm9kZV9tb2R1bGVzL2llZWU3NTQvaW5kZXguanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLFdBQVc7O0FBRXBCO0FBQ0E7QUFDQTtBQUNBLFNBQVMsV0FBVzs7QUFFcEI7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7O0FBRUEsU0FBUyxXQUFXOztBQUVwQjtBQUNBO0FBQ0EsU0FBUyxVQUFVOztBQUVuQjtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uLi8uLi9ub2RlX21vZHVsZXMvaWVlZTc1NC9pbmRleC5qcz81ZTEwIl0sInNvdXJjZXNDb250ZW50IjpbIi8qISBpZWVlNzU0LiBCU0QtMy1DbGF1c2UgTGljZW5zZS4gRmVyb3NzIEFib3VraGFkaWplaCA8aHR0cHM6Ly9mZXJvc3Mub3JnL29wZW5zb3VyY2U+ICovXG5leHBvcnRzLnJlYWQgPSBmdW5jdGlvbiAoYnVmZmVyLCBvZmZzZXQsIGlzTEUsIG1MZW4sIG5CeXRlcykge1xuICB2YXIgZSwgbVxuICB2YXIgZUxlbiA9IChuQnl0ZXMgKiA4KSAtIG1MZW4gLSAxXG4gIHZhciBlTWF4ID0gKDEgPDwgZUxlbikgLSAxXG4gIHZhciBlQmlhcyA9IGVNYXggPj4gMVxuICB2YXIgbkJpdHMgPSAtN1xuICB2YXIgaSA9IGlzTEUgPyAobkJ5dGVzIC0gMSkgOiAwXG4gIHZhciBkID0gaXNMRSA/IC0xIDogMVxuICB2YXIgcyA9IGJ1ZmZlcltvZmZzZXQgKyBpXVxuXG4gIGkgKz0gZFxuXG4gIGUgPSBzICYgKCgxIDw8ICgtbkJpdHMpKSAtIDEpXG4gIHMgPj49ICgtbkJpdHMpXG4gIG5CaXRzICs9IGVMZW5cbiAgZm9yICg7IG5CaXRzID4gMDsgZSA9IChlICogMjU2KSArIGJ1ZmZlcltvZmZzZXQgKyBpXSwgaSArPSBkLCBuQml0cyAtPSA4KSB7fVxuXG4gIG0gPSBlICYgKCgxIDw8ICgtbkJpdHMpKSAtIDEpXG4gIGUgPj49ICgtbkJpdHMpXG4gIG5CaXRzICs9IG1MZW5cbiAgZm9yICg7IG5CaXRzID4gMDsgbSA9IChtICogMjU2KSArIGJ1ZmZlcltvZmZzZXQgKyBpXSwgaSArPSBkLCBuQml0cyAtPSA4KSB7fVxuXG4gIGlmIChlID09PSAwKSB7XG4gICAgZSA9IDEgLSBlQmlhc1xuICB9IGVsc2UgaWYgKGUgPT09IGVNYXgpIHtcbiAgICByZXR1cm4gbSA/IE5hTiA6ICgocyA/IC0xIDogMSkgKiBJbmZpbml0eSlcbiAgfSBlbHNlIHtcbiAgICBtID0gbSArIE1hdGgucG93KDIsIG1MZW4pXG4gICAgZSA9IGUgLSBlQmlhc1xuICB9XG4gIHJldHVybiAocyA/IC0xIDogMSkgKiBtICogTWF0aC5wb3coMiwgZSAtIG1MZW4pXG59XG5cbmV4cG9ydHMud3JpdGUgPSBmdW5jdGlvbiAoYnVmZmVyLCB2YWx1ZSwgb2Zmc2V0LCBpc0xFLCBtTGVuLCBuQnl0ZXMpIHtcbiAgdmFyIGUsIG0sIGNcbiAgdmFyIGVMZW4gPSAobkJ5dGVzICogOCkgLSBtTGVuIC0gMVxuICB2YXIgZU1heCA9ICgxIDw8IGVMZW4pIC0gMVxuICB2YXIgZUJpYXMgPSBlTWF4ID4+IDFcbiAgdmFyIHJ0ID0gKG1MZW4gPT09IDIzID8gTWF0aC5wb3coMiwgLTI0KSAtIE1hdGgucG93KDIsIC03NykgOiAwKVxuICB2YXIgaSA9IGlzTEUgPyAwIDogKG5CeXRlcyAtIDEpXG4gIHZhciBkID0gaXNMRSA/IDEgOiAtMVxuICB2YXIgcyA9IHZhbHVlIDwgMCB8fCAodmFsdWUgPT09IDAgJiYgMSAvIHZhbHVlIDwgMCkgPyAxIDogMFxuXG4gIHZhbHVlID0gTWF0aC5hYnModmFsdWUpXG5cbiAgaWYgKGlzTmFOKHZhbHVlKSB8fCB2YWx1ZSA9PT0gSW5maW5pdHkpIHtcbiAgICBtID0gaXNOYU4odmFsdWUpID8gMSA6IDBcbiAgICBlID0gZU1heFxuICB9IGVsc2Uge1xuICAgIGUgPSBNYXRoLmZsb29yKE1hdGgubG9nKHZhbHVlKSAvIE1hdGguTE4yKVxuICAgIGlmICh2YWx1ZSAqIChjID0gTWF0aC5wb3coMiwgLWUpKSA8IDEpIHtcbiAgICAgIGUtLVxuICAgICAgYyAqPSAyXG4gICAgfVxuICAgIGlmIChlICsgZUJpYXMgPj0gMSkge1xuICAgICAgdmFsdWUgKz0gcnQgLyBjXG4gICAgfSBlbHNlIHtcbiAgICAgIHZhbHVlICs9IHJ0ICogTWF0aC5wb3coMiwgMSAtIGVCaWFzKVxuICAgIH1cbiAgICBpZiAodmFsdWUgKiBjID49IDIpIHtcbiAgICAgIGUrK1xuICAgICAgYyAvPSAyXG4gICAgfVxuXG4gICAgaWYgKGUgKyBlQmlhcyA+PSBlTWF4KSB7XG4gICAgICBtID0gMFxuICAgICAgZSA9IGVNYXhcbiAgICB9IGVsc2UgaWYgKGUgKyBlQmlhcyA+PSAxKSB7XG4gICAgICBtID0gKCh2YWx1ZSAqIGMpIC0gMSkgKiBNYXRoLnBvdygyLCBtTGVuKVxuICAgICAgZSA9IGUgKyBlQmlhc1xuICAgIH0gZWxzZSB7XG4gICAgICBtID0gdmFsdWUgKiBNYXRoLnBvdygyLCBlQmlhcyAtIDEpICogTWF0aC5wb3coMiwgbUxlbilcbiAgICAgIGUgPSAwXG4gICAgfVxuICB9XG5cbiAgZm9yICg7IG1MZW4gPj0gODsgYnVmZmVyW29mZnNldCArIGldID0gbSAmIDB4ZmYsIGkgKz0gZCwgbSAvPSAyNTYsIG1MZW4gLT0gOCkge31cblxuICBlID0gKGUgPDwgbUxlbikgfCBtXG4gIGVMZW4gKz0gbUxlblxuICBmb3IgKDsgZUxlbiA+IDA7IGJ1ZmZlcltvZmZzZXQgKyBpXSA9IGUgJiAweGZmLCBpICs9IGQsIGUgLz0gMjU2LCBlTGVuIC09IDgpIHt9XG5cbiAgYnVmZmVyW29mZnNldCArIGkgLSBkXSB8PSBzICogMTI4XG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../../node_modules/ieee754/index.js\n"));

/***/ }),

/***/ "?3514":
/*!********************!*\
  !*** fs (ignored) ***!
  \********************/
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

/* (ignored) */

/***/ }),

/***/ "./node_modules/clsx/dist/clsx.mjs":
/*!*****************************************!*\
  !*** ./node_modules/clsx/dist/clsx.mjs ***!
  \*****************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   clsx: function() { return /* binding */ clsx; }\n/* harmony export */ });\nfunction r(e){var t,f,n=\"\";if(\"string\"==typeof e||\"number\"==typeof e)n+=e;else if(\"object\"==typeof e)if(Array.isArray(e)){var o=e.length;for(t=0;t<o;t++)e[t]&&(f=r(e[t]))&&(n&&(n+=\" \"),n+=f)}else for(f in e)e[f]&&(n&&(n+=\" \"),n+=f);return n}function clsx(){for(var e,t,f=0,n=\"\",o=arguments.length;f<o;f++)(e=arguments[f])&&(t=r(e))&&(n&&(n+=\" \"),n+=t);return n}/* harmony default export */ __webpack_exports__[\"default\"] = (clsx);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvY2xzeC9kaXN0L2Nsc3gubWpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBQSxjQUFjLGFBQWEsK0NBQStDLGdEQUFnRCxlQUFlLFFBQVEsSUFBSSwwQ0FBMEMseUNBQXlDLFNBQWdCLGdCQUFnQix3Q0FBd0MsSUFBSSxtREFBbUQsU0FBUywrREFBZSxJQUFJIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9jbHN4L2Rpc3QvY2xzeC5tanM/M2IxMiJdLCJzb3VyY2VzQ29udGVudCI6WyJmdW5jdGlvbiByKGUpe3ZhciB0LGYsbj1cIlwiO2lmKFwic3RyaW5nXCI9PXR5cGVvZiBlfHxcIm51bWJlclwiPT10eXBlb2YgZSluKz1lO2Vsc2UgaWYoXCJvYmplY3RcIj09dHlwZW9mIGUpaWYoQXJyYXkuaXNBcnJheShlKSl7dmFyIG89ZS5sZW5ndGg7Zm9yKHQ9MDt0PG87dCsrKWVbdF0mJihmPXIoZVt0XSkpJiYobiYmKG4rPVwiIFwiKSxuKz1mKX1lbHNlIGZvcihmIGluIGUpZVtmXSYmKG4mJihuKz1cIiBcIiksbis9Zik7cmV0dXJuIG59ZXhwb3J0IGZ1bmN0aW9uIGNsc3goKXtmb3IodmFyIGUsdCxmPTAsbj1cIlwiLG89YXJndW1lbnRzLmxlbmd0aDtmPG87ZisrKShlPWFyZ3VtZW50c1tmXSkmJih0PXIoZSkpJiYobiYmKG4rPVwiIFwiKSxuKz10KTtyZXR1cm4gbn1leHBvcnQgZGVmYXVsdCBjbHN4OyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/clsx/dist/clsx.mjs\n"));

/***/ }),

/***/ "./node_modules/react-toastify/dist/index.mjs":
/*!****************************************************!*\
  !*** ./node_modules/react-toastify/dist/index.mjs ***!
  \****************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Bounce: function() { return /* binding */ lt; },\n/* harmony export */   Flip: function() { return /* binding */ uo; },\n/* harmony export */   Icons: function() { return /* binding */ W; },\n/* harmony export */   Slide: function() { return /* binding */ mo; },\n/* harmony export */   ToastContainer: function() { return /* binding */ Lt; },\n/* harmony export */   Zoom: function() { return /* binding */ po; },\n/* harmony export */   collapseToast: function() { return /* binding */ Z; },\n/* harmony export */   cssTransition: function() { return /* binding */ $; },\n/* harmony export */   toast: function() { return /* binding */ y; }\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"./node_modules/react/index.js\");\n/* harmony import */ var clsx__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! clsx */ \"./node_modules/clsx/dist/clsx.mjs\");\n\"use client\";\nfunction Mt(t){if(!t||typeof document==\"undefined\")return;let o=document.head||document.getElementsByTagName(\"head\")[0],e=document.createElement(\"style\");e.type=\"text/css\",o.firstChild?o.insertBefore(e,o.firstChild):o.appendChild(e),e.styleSheet?e.styleSheet.cssText=t:e.appendChild(document.createTextNode(t))}Mt(`:root{--toastify-color-light: #fff;--toastify-color-dark: #121212;--toastify-color-info: #3498db;--toastify-color-success: #07bc0c;--toastify-color-warning: #f1c40f;--toastify-color-error: hsl(6, 78%, 57%);--toastify-color-transparent: rgba(255, 255, 255, .7);--toastify-icon-color-info: var(--toastify-color-info);--toastify-icon-color-success: var(--toastify-color-success);--toastify-icon-color-warning: var(--toastify-color-warning);--toastify-icon-color-error: var(--toastify-color-error);--toastify-container-width: fit-content;--toastify-toast-width: 320px;--toastify-toast-offset: 16px;--toastify-toast-top: max(var(--toastify-toast-offset), env(safe-area-inset-top));--toastify-toast-right: max(var(--toastify-toast-offset), env(safe-area-inset-right));--toastify-toast-left: max(var(--toastify-toast-offset), env(safe-area-inset-left));--toastify-toast-bottom: max(var(--toastify-toast-offset), env(safe-area-inset-bottom));--toastify-toast-background: #fff;--toastify-toast-padding: 14px;--toastify-toast-min-height: 64px;--toastify-toast-max-height: 800px;--toastify-toast-bd-radius: 6px;--toastify-toast-shadow: 0px 4px 12px rgba(0, 0, 0, .1);--toastify-font-family: sans-serif;--toastify-z-index: 9999;--toastify-text-color-light: #757575;--toastify-text-color-dark: #fff;--toastify-text-color-info: #fff;--toastify-text-color-success: #fff;--toastify-text-color-warning: #fff;--toastify-text-color-error: #fff;--toastify-spinner-color: #616161;--toastify-spinner-color-empty-area: #e0e0e0;--toastify-color-progress-light: linear-gradient(to right, #4cd964, #5ac8fa, #007aff, #34aadc, #5856d6, #ff2d55);--toastify-color-progress-dark: #bb86fc;--toastify-color-progress-info: var(--toastify-color-info);--toastify-color-progress-success: var(--toastify-color-success);--toastify-color-progress-warning: var(--toastify-color-warning);--toastify-color-progress-error: var(--toastify-color-error);--toastify-color-progress-bgo: .2}.Toastify__toast-container{z-index:var(--toastify-z-index);-webkit-transform:translate3d(0,0,var(--toastify-z-index));position:fixed;width:var(--toastify-container-width);box-sizing:border-box;color:#fff;display:flex;flex-direction:column}.Toastify__toast-container--top-left{top:var(--toastify-toast-top);left:var(--toastify-toast-left)}.Toastify__toast-container--top-center{top:var(--toastify-toast-top);left:50%;transform:translate(-50%);align-items:center}.Toastify__toast-container--top-right{top:var(--toastify-toast-top);right:var(--toastify-toast-right);align-items:end}.Toastify__toast-container--bottom-left{bottom:var(--toastify-toast-bottom);left:var(--toastify-toast-left)}.Toastify__toast-container--bottom-center{bottom:var(--toastify-toast-bottom);left:50%;transform:translate(-50%);align-items:center}.Toastify__toast-container--bottom-right{bottom:var(--toastify-toast-bottom);right:var(--toastify-toast-right);align-items:end}.Toastify__toast{--y: 0;position:relative;touch-action:none;width:var(--toastify-toast-width);min-height:var(--toastify-toast-min-height);box-sizing:border-box;margin-bottom:1rem;padding:var(--toastify-toast-padding);border-radius:var(--toastify-toast-bd-radius);box-shadow:var(--toastify-toast-shadow);max-height:var(--toastify-toast-max-height);font-family:var(--toastify-font-family);z-index:0;display:flex;flex:1 auto;align-items:center;word-break:break-word}@media only screen and (max-width: 480px){.Toastify__toast-container{width:100vw;left:env(safe-area-inset-left);margin:0}.Toastify__toast-container--top-left,.Toastify__toast-container--top-center,.Toastify__toast-container--top-right{top:env(safe-area-inset-top);transform:translate(0)}.Toastify__toast-container--bottom-left,.Toastify__toast-container--bottom-center,.Toastify__toast-container--bottom-right{bottom:env(safe-area-inset-bottom);transform:translate(0)}.Toastify__toast-container--rtl{right:env(safe-area-inset-right);left:initial}.Toastify__toast{--toastify-toast-width: 100%;margin-bottom:0;border-radius:0}}.Toastify__toast-container[data-stacked=true]{width:var(--toastify-toast-width)}.Toastify__toast--stacked{position:absolute;width:100%;transform:translate3d(0,var(--y),0) scale(var(--s));transition:transform .3s}.Toastify__toast--stacked[data-collapsed] .Toastify__toast-body,.Toastify__toast--stacked[data-collapsed] .Toastify__close-button{transition:opacity .1s}.Toastify__toast--stacked[data-collapsed=false]{overflow:visible}.Toastify__toast--stacked[data-collapsed=true]:not(:last-child)>*{opacity:0}.Toastify__toast--stacked:after{content:\"\";position:absolute;left:0;right:0;height:calc(var(--g) * 1px);bottom:100%}.Toastify__toast--stacked[data-pos=top]{top:0}.Toastify__toast--stacked[data-pos=bot]{bottom:0}.Toastify__toast--stacked[data-pos=bot].Toastify__toast--stacked:before{transform-origin:top}.Toastify__toast--stacked[data-pos=top].Toastify__toast--stacked:before{transform-origin:bottom}.Toastify__toast--stacked:before{content:\"\";position:absolute;left:0;right:0;bottom:0;height:100%;transform:scaleY(3);z-index:-1}.Toastify__toast--rtl{direction:rtl}.Toastify__toast--close-on-click{cursor:pointer}.Toastify__toast-icon{margin-inline-end:10px;width:22px;flex-shrink:0;display:flex}.Toastify--animate{animation-fill-mode:both;animation-duration:.5s}.Toastify--animate-icon{animation-fill-mode:both;animation-duration:.3s}.Toastify__toast-theme--dark{background:var(--toastify-color-dark);color:var(--toastify-text-color-dark)}.Toastify__toast-theme--light,.Toastify__toast-theme--colored.Toastify__toast--default{background:var(--toastify-color-light);color:var(--toastify-text-color-light)}.Toastify__toast-theme--colored.Toastify__toast--info{color:var(--toastify-text-color-info);background:var(--toastify-color-info)}.Toastify__toast-theme--colored.Toastify__toast--success{color:var(--toastify-text-color-success);background:var(--toastify-color-success)}.Toastify__toast-theme--colored.Toastify__toast--warning{color:var(--toastify-text-color-warning);background:var(--toastify-color-warning)}.Toastify__toast-theme--colored.Toastify__toast--error{color:var(--toastify-text-color-error);background:var(--toastify-color-error)}.Toastify__progress-bar-theme--light{background:var(--toastify-color-progress-light)}.Toastify__progress-bar-theme--dark{background:var(--toastify-color-progress-dark)}.Toastify__progress-bar--info{background:var(--toastify-color-progress-info)}.Toastify__progress-bar--success{background:var(--toastify-color-progress-success)}.Toastify__progress-bar--warning{background:var(--toastify-color-progress-warning)}.Toastify__progress-bar--error{background:var(--toastify-color-progress-error)}.Toastify__progress-bar-theme--colored.Toastify__progress-bar--info,.Toastify__progress-bar-theme--colored.Toastify__progress-bar--success,.Toastify__progress-bar-theme--colored.Toastify__progress-bar--warning,.Toastify__progress-bar-theme--colored.Toastify__progress-bar--error{background:var(--toastify-color-transparent)}.Toastify__close-button{color:#fff;position:absolute;top:6px;right:6px;background:transparent;outline:none;border:none;padding:0;cursor:pointer;opacity:.7;transition:.3s ease;z-index:1}.Toastify__toast--rtl .Toastify__close-button{left:6px;right:unset}.Toastify__close-button--light{color:#000;opacity:.3}.Toastify__close-button>svg{fill:currentColor;height:16px;width:14px}.Toastify__close-button:hover,.Toastify__close-button:focus{opacity:1}@keyframes Toastify__trackProgress{0%{transform:scaleX(1)}to{transform:scaleX(0)}}.Toastify__progress-bar{position:absolute;bottom:0;left:0;width:100%;height:100%;z-index:1;opacity:.7;transform-origin:left}.Toastify__progress-bar--animated{animation:Toastify__trackProgress linear 1 forwards}.Toastify__progress-bar--controlled{transition:transform .2s}.Toastify__progress-bar--rtl{right:0;left:initial;transform-origin:right;border-bottom-left-radius:initial}.Toastify__progress-bar--wrp{position:absolute;overflow:hidden;bottom:0;left:0;width:100%;height:5px;border-bottom-left-radius:var(--toastify-toast-bd-radius);border-bottom-right-radius:var(--toastify-toast-bd-radius)}.Toastify__progress-bar--wrp[data-hidden=true]{opacity:0}.Toastify__progress-bar--bg{opacity:var(--toastify-color-progress-bgo);width:100%;height:100%}.Toastify__spinner{width:20px;height:20px;box-sizing:border-box;border:2px solid;border-radius:100%;border-color:var(--toastify-spinner-color-empty-area);border-right-color:var(--toastify-spinner-color);animation:Toastify__spin .65s linear infinite}@keyframes Toastify__bounceInRight{0%,60%,75%,90%,to{animation-timing-function:cubic-bezier(.215,.61,.355,1)}0%{opacity:0;transform:translate3d(3000px,0,0)}60%{opacity:1;transform:translate3d(-25px,0,0)}75%{transform:translate3d(10px,0,0)}90%{transform:translate3d(-5px,0,0)}to{transform:none}}@keyframes Toastify__bounceOutRight{20%{opacity:1;transform:translate3d(-20px,var(--y),0)}to{opacity:0;transform:translate3d(2000px,var(--y),0)}}@keyframes Toastify__bounceInLeft{0%,60%,75%,90%,to{animation-timing-function:cubic-bezier(.215,.61,.355,1)}0%{opacity:0;transform:translate3d(-3000px,0,0)}60%{opacity:1;transform:translate3d(25px,0,0)}75%{transform:translate3d(-10px,0,0)}90%{transform:translate3d(5px,0,0)}to{transform:none}}@keyframes Toastify__bounceOutLeft{20%{opacity:1;transform:translate3d(20px,var(--y),0)}to{opacity:0;transform:translate3d(-2000px,var(--y),0)}}@keyframes Toastify__bounceInUp{0%,60%,75%,90%,to{animation-timing-function:cubic-bezier(.215,.61,.355,1)}0%{opacity:0;transform:translate3d(0,3000px,0)}60%{opacity:1;transform:translate3d(0,-20px,0)}75%{transform:translate3d(0,10px,0)}90%{transform:translate3d(0,-5px,0)}to{transform:translateZ(0)}}@keyframes Toastify__bounceOutUp{20%{transform:translate3d(0,calc(var(--y) - 10px),0)}40%,45%{opacity:1;transform:translate3d(0,calc(var(--y) + 20px),0)}to{opacity:0;transform:translate3d(0,-2000px,0)}}@keyframes Toastify__bounceInDown{0%,60%,75%,90%,to{animation-timing-function:cubic-bezier(.215,.61,.355,1)}0%{opacity:0;transform:translate3d(0,-3000px,0)}60%{opacity:1;transform:translate3d(0,25px,0)}75%{transform:translate3d(0,-10px,0)}90%{transform:translate3d(0,5px,0)}to{transform:none}}@keyframes Toastify__bounceOutDown{20%{transform:translate3d(0,calc(var(--y) - 10px),0)}40%,45%{opacity:1;transform:translate3d(0,calc(var(--y) + 20px),0)}to{opacity:0;transform:translate3d(0,2000px,0)}}.Toastify__bounce-enter--top-left,.Toastify__bounce-enter--bottom-left{animation-name:Toastify__bounceInLeft}.Toastify__bounce-enter--top-right,.Toastify__bounce-enter--bottom-right{animation-name:Toastify__bounceInRight}.Toastify__bounce-enter--top-center{animation-name:Toastify__bounceInDown}.Toastify__bounce-enter--bottom-center{animation-name:Toastify__bounceInUp}.Toastify__bounce-exit--top-left,.Toastify__bounce-exit--bottom-left{animation-name:Toastify__bounceOutLeft}.Toastify__bounce-exit--top-right,.Toastify__bounce-exit--bottom-right{animation-name:Toastify__bounceOutRight}.Toastify__bounce-exit--top-center{animation-name:Toastify__bounceOutUp}.Toastify__bounce-exit--bottom-center{animation-name:Toastify__bounceOutDown}@keyframes Toastify__zoomIn{0%{opacity:0;transform:scale3d(.3,.3,.3)}50%{opacity:1}}@keyframes Toastify__zoomOut{0%{opacity:1}50%{opacity:0;transform:translate3d(0,var(--y),0) scale3d(.3,.3,.3)}to{opacity:0}}.Toastify__zoom-enter{animation-name:Toastify__zoomIn}.Toastify__zoom-exit{animation-name:Toastify__zoomOut}@keyframes Toastify__flipIn{0%{transform:perspective(400px) rotateX(90deg);animation-timing-function:ease-in;opacity:0}40%{transform:perspective(400px) rotateX(-20deg);animation-timing-function:ease-in}60%{transform:perspective(400px) rotateX(10deg);opacity:1}80%{transform:perspective(400px) rotateX(-5deg)}to{transform:perspective(400px)}}@keyframes Toastify__flipOut{0%{transform:translate3d(0,var(--y),0) perspective(400px)}30%{transform:translate3d(0,var(--y),0) perspective(400px) rotateX(-20deg);opacity:1}to{transform:translate3d(0,var(--y),0) perspective(400px) rotateX(90deg);opacity:0}}.Toastify__flip-enter{animation-name:Toastify__flipIn}.Toastify__flip-exit{animation-name:Toastify__flipOut}@keyframes Toastify__slideInRight{0%{transform:translate3d(110%,0,0);visibility:visible}to{transform:translate3d(0,var(--y),0)}}@keyframes Toastify__slideInLeft{0%{transform:translate3d(-110%,0,0);visibility:visible}to{transform:translate3d(0,var(--y),0)}}@keyframes Toastify__slideInUp{0%{transform:translate3d(0,110%,0);visibility:visible}to{transform:translate3d(0,var(--y),0)}}@keyframes Toastify__slideInDown{0%{transform:translate3d(0,-110%,0);visibility:visible}to{transform:translate3d(0,var(--y),0)}}@keyframes Toastify__slideOutRight{0%{transform:translate3d(0,var(--y),0)}to{visibility:hidden;transform:translate3d(110%,var(--y),0)}}@keyframes Toastify__slideOutLeft{0%{transform:translate3d(0,var(--y),0)}to{visibility:hidden;transform:translate3d(-110%,var(--y),0)}}@keyframes Toastify__slideOutDown{0%{transform:translate3d(0,var(--y),0)}to{visibility:hidden;transform:translate3d(0,500px,0)}}@keyframes Toastify__slideOutUp{0%{transform:translate3d(0,var(--y),0)}to{visibility:hidden;transform:translate3d(0,-500px,0)}}.Toastify__slide-enter--top-left,.Toastify__slide-enter--bottom-left{animation-name:Toastify__slideInLeft}.Toastify__slide-enter--top-right,.Toastify__slide-enter--bottom-right{animation-name:Toastify__slideInRight}.Toastify__slide-enter--top-center{animation-name:Toastify__slideInDown}.Toastify__slide-enter--bottom-center{animation-name:Toastify__slideInUp}.Toastify__slide-exit--top-left,.Toastify__slide-exit--bottom-left{animation-name:Toastify__slideOutLeft;animation-timing-function:ease-in;animation-duration:.3s}.Toastify__slide-exit--top-right,.Toastify__slide-exit--bottom-right{animation-name:Toastify__slideOutRight;animation-timing-function:ease-in;animation-duration:.3s}.Toastify__slide-exit--top-center{animation-name:Toastify__slideOutUp;animation-timing-function:ease-in;animation-duration:.3s}.Toastify__slide-exit--bottom-center{animation-name:Toastify__slideOutDown;animation-timing-function:ease-in;animation-duration:.3s}@keyframes Toastify__spin{0%{transform:rotate(0)}to{transform:rotate(360deg)}}\n`);var L=t=>typeof t==\"number\"&&!isNaN(t),N=t=>typeof t==\"string\",P=t=>typeof t==\"function\",mt=t=>N(t)||L(t),B=t=>N(t)||P(t)?t:null,pt=(t,o)=>t===!1||L(t)&&t>0?t:o,z=t=>(0,react__WEBPACK_IMPORTED_MODULE_0__.isValidElement)(t)||N(t)||P(t)||L(t);function Z(t,o,e=300){let{scrollHeight:r,style:s}=t;requestAnimationFrame(()=>{s.minHeight=\"initial\",s.height=r+\"px\",s.transition=`all ${e}ms`,requestAnimationFrame(()=>{s.height=\"0\",s.padding=\"0\",s.margin=\"0\",setTimeout(o,e)})})}function $({enter:t,exit:o,appendPosition:e=!1,collapse:r=!0,collapseDuration:s=300}){return function({children:a,position:d,preventExitTransition:c,done:T,nodeRef:g,isIn:v,playToast:x}){let C=e?`${t}--${d}`:t,S=e?`${o}--${d}`:o,E=(0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(0);return (0,react__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect)(()=>{let f=g.current,p=C.split(\" \"),b=n=>{n.target===g.current&&(x(),f.removeEventListener(\"animationend\",b),f.removeEventListener(\"animationcancel\",b),E.current===0&&n.type!==\"animationcancel\"&&f.classList.remove(...p))};(()=>{f.classList.add(...p),f.addEventListener(\"animationend\",b),f.addEventListener(\"animationcancel\",b)})()},[]),(0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{let f=g.current,p=()=>{f.removeEventListener(\"animationend\",p),r?Z(f,T,s):T()};v||(c?p():(()=>{E.current=1,f.className+=` ${S}`,f.addEventListener(\"animationend\",p)})())},[v]),react__WEBPACK_IMPORTED_MODULE_0__.createElement(react__WEBPACK_IMPORTED_MODULE_0__.Fragment,null,a)}}function J(t,o){return{content:tt(t.content,t.props),containerId:t.props.containerId,id:t.props.toastId,theme:t.props.theme,type:t.props.type,data:t.props.data||{},isLoading:t.props.isLoading,icon:t.props.icon,reason:t.removalReason,status:o}}function tt(t,o,e=!1){return (0,react__WEBPACK_IMPORTED_MODULE_0__.isValidElement)(t)&&!N(t.type)?(0,react__WEBPACK_IMPORTED_MODULE_0__.cloneElement)(t,{closeToast:o.closeToast,toastProps:o,data:o.data,isPaused:e}):P(t)?t({closeToast:o.closeToast,toastProps:o,data:o.data,isPaused:e}):t}function yt({closeToast:t,theme:o,ariaLabel:e=\"close\"}){return react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"button\",{className:`Toastify__close-button Toastify__close-button--${o}`,type:\"button\",onClick:r=>{r.stopPropagation(),t(!0)},\"aria-label\":e},react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"svg\",{\"aria-hidden\":\"true\",viewBox:\"0 0 14 16\"},react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"path\",{fillRule:\"evenodd\",d:\"M7.71 8.23l3.75 3.75-1.48 1.48-3.75-3.75-3.75 3.75L1 11.98l3.75-3.75L1 4.48 2.48 3l3.75 3.75L9.98 3l1.48 1.48-3.75 3.75z\"})))}function gt({delay:t,isRunning:o,closeToast:e,type:r=\"default\",hide:s,className:l,controlledProgress:a,progress:d,rtl:c,isIn:T,theme:g}){let v=s||a&&d===0,x={animationDuration:`${t}ms`,animationPlayState:o?\"running\":\"paused\"};a&&(x.transform=`scaleX(${d})`);let C=(0,clsx__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(\"Toastify__progress-bar\",a?\"Toastify__progress-bar--controlled\":\"Toastify__progress-bar--animated\",`Toastify__progress-bar-theme--${g}`,`Toastify__progress-bar--${r}`,{[\"Toastify__progress-bar--rtl\"]:c}),S=P(l)?l({rtl:c,type:r,defaultClassName:C}):(0,clsx__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(C,l),E={[a&&d>=1?\"onTransitionEnd\":\"onAnimationEnd\"]:a&&d<1?null:()=>{T&&e()}};return react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\",{className:\"Toastify__progress-bar--wrp\",\"data-hidden\":v},react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\",{className:`Toastify__progress-bar--bg Toastify__progress-bar-theme--${g} Toastify__progress-bar--${r}`}),react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\",{role:\"progressbar\",\"aria-hidden\":v?\"true\":\"false\",\"aria-label\":\"notification timer\",className:S,style:x,...E}))}var Xt=1,at=()=>`${Xt++}`;function _t(t,o,e){let r=1,s=0,l=[],a=[],d=o,c=new Map,T=new Set,g=i=>(T.add(i),()=>T.delete(i)),v=()=>{a=Array.from(c.values()),T.forEach(i=>i())},x=({containerId:i,toastId:n,updateId:u})=>{let h=i?i!==t:t!==1,m=c.has(n)&&u==null;return h||m},C=(i,n)=>{c.forEach(u=>{var h;(n==null||n===u.props.toastId)&&((h=u.toggle)==null||h.call(u,i))})},S=i=>{var n,u;(u=(n=i.props)==null?void 0:n.onClose)==null||u.call(n,i.removalReason),i.isActive=!1},E=i=>{if(i==null)c.forEach(S);else{let n=c.get(i);n&&S(n)}v()},f=()=>{s-=l.length,l=[]},p=i=>{var m,_;let{toastId:n,updateId:u}=i.props,h=u==null;i.staleId&&c.delete(i.staleId),i.isActive=!0,c.set(n,i),v(),e(J(i,h?\"added\":\"updated\")),h&&((_=(m=i.props).onOpen)==null||_.call(m))};return{id:t,props:d,observe:g,toggle:C,removeToast:E,toasts:c,clearQueue:f,buildToast:(i,n)=>{if(x(n))return;let{toastId:u,updateId:h,data:m,staleId:_,delay:k}=n,M=h==null;M&&s++;let A={...d,style:d.toastStyle,key:r++,...Object.fromEntries(Object.entries(n).filter(([D,Y])=>Y!=null)),toastId:u,updateId:h,data:m,isIn:!1,className:B(n.className||d.toastClassName),progressClassName:B(n.progressClassName||d.progressClassName),autoClose:n.isLoading?!1:pt(n.autoClose,d.autoClose),closeToast(D){c.get(u).removalReason=D,E(u)},deleteToast(){let D=c.get(u);if(D!=null){if(e(J(D,\"removed\")),c.delete(u),s--,s<0&&(s=0),l.length>0){p(l.shift());return}v()}}};A.closeButton=d.closeButton,n.closeButton===!1||z(n.closeButton)?A.closeButton=n.closeButton:n.closeButton===!0&&(A.closeButton=z(d.closeButton)?d.closeButton:!0);let R={content:i,props:A,staleId:_};d.limit&&d.limit>0&&s>d.limit&&M?l.push(R):L(k)?setTimeout(()=>{p(R)},k):p(R)},setProps(i){d=i},setToggle:(i,n)=>{let u=c.get(i);u&&(u.toggle=n)},isToastActive:i=>{var n;return(n=c.get(i))==null?void 0:n.isActive},getSnapshot:()=>a}}var I=new Map,F=[],st=new Set,Vt=t=>st.forEach(o=>o(t)),bt=()=>I.size>0;function Qt(){F.forEach(t=>nt(t.content,t.options)),F=[]}var vt=(t,{containerId:o})=>{var e;return(e=I.get(o||1))==null?void 0:e.toasts.get(t)};function X(t,o){var r;if(o)return!!((r=I.get(o))!=null&&r.isToastActive(t));let e=!1;return I.forEach(s=>{s.isToastActive(t)&&(e=!0)}),e}function ht(t){if(!bt()){F=F.filter(o=>t!=null&&o.options.toastId!==t);return}if(t==null||mt(t))I.forEach(o=>{o.removeToast(t)});else if(t&&(\"containerId\"in t||\"id\"in t)){let o=I.get(t.containerId);o?o.removeToast(t.id):I.forEach(e=>{e.removeToast(t.id)})}}var Ct=(t={})=>{I.forEach(o=>{o.props.limit&&(!t.containerId||o.id===t.containerId)&&o.clearQueue()})};function nt(t,o){z(t)&&(bt()||F.push({content:t,options:o}),I.forEach(e=>{e.buildToast(t,o)}))}function xt(t){var o;(o=I.get(t.containerId||1))==null||o.setToggle(t.id,t.fn)}function rt(t,o){I.forEach(e=>{(o==null||!(o!=null&&o.containerId)||(o==null?void 0:o.containerId)===e.id)&&e.toggle(t,o==null?void 0:o.id)})}function Et(t){let o=t.containerId||1;return{subscribe(e){let r=_t(o,t,Vt);I.set(o,r);let s=r.observe(e);return Qt(),()=>{s(),I.delete(o)}},setProps(e){var r;(r=I.get(o))==null||r.setProps(e)},getSnapshot(){var e;return(e=I.get(o))==null?void 0:e.getSnapshot()}}}function Pt(t){return st.add(t),()=>{st.delete(t)}}function Wt(t){return t&&(N(t.toastId)||L(t.toastId))?t.toastId:at()}function U(t,o){return nt(t,o),o.toastId}function V(t,o){return{...o,type:o&&o.type||t,toastId:Wt(o)}}function Q(t){return(o,e)=>U(o,V(t,e))}function y(t,o){return U(t,V(\"default\",o))}y.loading=(t,o)=>U(t,V(\"default\",{isLoading:!0,autoClose:!1,closeOnClick:!1,closeButton:!1,draggable:!1,...o}));function Gt(t,{pending:o,error:e,success:r},s){let l;o&&(l=N(o)?y.loading(o,s):y.loading(o.render,{...s,...o}));let a={isLoading:null,autoClose:null,closeOnClick:null,closeButton:null,draggable:null},d=(T,g,v)=>{if(g==null){y.dismiss(l);return}let x={type:T,...a,...s,data:v},C=N(g)?{render:g}:g;return l?y.update(l,{...x,...C}):y(C.render,{...x,...C}),v},c=P(t)?t():t;return c.then(T=>d(\"success\",r,T)).catch(T=>d(\"error\",e,T)),c}y.promise=Gt;y.success=Q(\"success\");y.info=Q(\"info\");y.error=Q(\"error\");y.warning=Q(\"warning\");y.warn=y.warning;y.dark=(t,o)=>U(t,V(\"default\",{theme:\"dark\",...o}));function qt(t){ht(t)}y.dismiss=qt;y.clearWaitingQueue=Ct;y.isActive=X;y.update=(t,o={})=>{let e=vt(t,o);if(e){let{props:r,content:s}=e,l={delay:100,...r,...o,toastId:o.toastId||t,updateId:at()};l.toastId!==t&&(l.staleId=t);let a=l.render||s;delete l.render,U(a,l)}};y.done=t=>{y.update(t,{progress:1})};y.onChange=Pt;y.play=t=>rt(!0,t);y.pause=t=>rt(!1,t);function It(t){var a;let{subscribe:o,getSnapshot:e,setProps:r}=(0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(Et(t)).current;r(t);let s=(a=(0,react__WEBPACK_IMPORTED_MODULE_0__.useSyncExternalStore)(o,e,e))==null?void 0:a.slice();function l(d){if(!s)return[];let c=new Map;return t.newestOnTop&&s.reverse(),s.forEach(T=>{let{position:g}=T.props;c.has(g)||c.set(g,[]),c.get(g).push(T)}),Array.from(c,T=>d(T[0],T[1]))}return{getToastToRender:l,isToastActive:X,count:s==null?void 0:s.length}}function At(t){let[o,e]=(0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(!1),[r,s]=(0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(!1),l=(0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null),a=(0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)({start:0,delta:0,removalDistance:0,canCloseOnClick:!0,canDrag:!1,didMove:!1}).current,{autoClose:d,pauseOnHover:c,closeToast:T,onClick:g,closeOnClick:v}=t;xt({id:t.toastId,containerId:t.containerId,fn:e}),(0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{if(t.pauseOnFocusLoss)return x(),()=>{C()}},[t.pauseOnFocusLoss]);function x(){document.hasFocus()||p(),window.addEventListener(\"focus\",f),window.addEventListener(\"blur\",p)}function C(){window.removeEventListener(\"focus\",f),window.removeEventListener(\"blur\",p)}function S(m){if(t.draggable===!0||t.draggable===m.pointerType){b();let _=l.current;a.canCloseOnClick=!0,a.canDrag=!0,_.style.transition=\"none\",t.draggableDirection===\"x\"?(a.start=m.clientX,a.removalDistance=_.offsetWidth*(t.draggablePercent/100)):(a.start=m.clientY,a.removalDistance=_.offsetHeight*(t.draggablePercent===80?t.draggablePercent*1.5:t.draggablePercent)/100)}}function E(m){let{top:_,bottom:k,left:M,right:A}=l.current.getBoundingClientRect();m.nativeEvent.type!==\"touchend\"&&t.pauseOnHover&&m.clientX>=M&&m.clientX<=A&&m.clientY>=_&&m.clientY<=k?p():f()}function f(){e(!0)}function p(){e(!1)}function b(){a.didMove=!1,document.addEventListener(\"pointermove\",n),document.addEventListener(\"pointerup\",u)}function i(){document.removeEventListener(\"pointermove\",n),document.removeEventListener(\"pointerup\",u)}function n(m){let _=l.current;if(a.canDrag&&_){a.didMove=!0,o&&p(),t.draggableDirection===\"x\"?a.delta=m.clientX-a.start:a.delta=m.clientY-a.start,a.start!==m.clientX&&(a.canCloseOnClick=!1);let k=t.draggableDirection===\"x\"?`${a.delta}px, var(--y)`:`0, calc(${a.delta}px + var(--y))`;_.style.transform=`translate3d(${k},0)`,_.style.opacity=`${1-Math.abs(a.delta/a.removalDistance)}`}}function u(){i();let m=l.current;if(a.canDrag&&a.didMove&&m){if(a.canDrag=!1,Math.abs(a.delta)>a.removalDistance){s(!0),t.closeToast(!0),t.collapseAll();return}m.style.transition=\"transform 0.2s, opacity 0.2s\",m.style.removeProperty(\"transform\"),m.style.removeProperty(\"opacity\")}}let h={onPointerDown:S,onPointerUp:E};return d&&c&&(h.onMouseEnter=p,t.stacked||(h.onMouseLeave=f)),v&&(h.onClick=m=>{g&&g(m),a.canCloseOnClick&&T(!0)}),{playToast:f,pauseToast:p,isRunning:o,preventExitTransition:r,toastRef:l,eventHandlers:h}}var Ot=typeof window!=\"undefined\"?react__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect:react__WEBPACK_IMPORTED_MODULE_0__.useEffect;var G=({theme:t,type:o,isLoading:e,...r})=>react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"svg\",{viewBox:\"0 0 24 24\",width:\"100%\",height:\"100%\",fill:t===\"colored\"?\"currentColor\":`var(--toastify-icon-color-${o})`,...r});function ao(t){return react__WEBPACK_IMPORTED_MODULE_0__.createElement(G,{...t},react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"path\",{d:\"M23.32 17.191L15.438 2.184C14.728.833 13.416 0 11.996 0c-1.42 0-2.733.833-3.443 2.184L.533 17.448a4.744 4.744 0 000 4.368C1.243 23.167 2.555 24 3.975 24h16.05C22.22 24 24 22.044 24 19.632c0-.904-.251-1.746-.68-2.44zm-9.622 1.46c0 1.033-.724 1.823-1.698 1.823s-1.698-.79-1.698-1.822v-.043c0-1.028.724-1.822 1.698-1.822s1.698.79 1.698 1.822v.043zm.039-12.285l-.84 8.06c-.057.581-.408.943-.897.943-.49 0-.84-.367-.896-.942l-.84-8.065c-.057-.624.25-1.095.779-1.095h1.91c.528.005.84.476.784 1.1z\"}))}function so(t){return react__WEBPACK_IMPORTED_MODULE_0__.createElement(G,{...t},react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"path\",{d:\"M12 0a12 12 0 1012 12A12.013 12.013 0 0012 0zm.25 5a1.5 1.5 0 11-1.5 1.5 1.5 1.5 0 011.5-1.5zm2.25 13.5h-4a1 1 0 010-2h.75a.25.25 0 00.25-.25v-4.5a.25.25 0 00-.25-.25h-.75a1 1 0 010-2h1a2 2 0 012 2v4.75a.25.25 0 00.25.25h.75a1 1 0 110 2z\"}))}function no(t){return react__WEBPACK_IMPORTED_MODULE_0__.createElement(G,{...t},react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"path\",{d:\"M12 0a12 12 0 1012 12A12.014 12.014 0 0012 0zm6.927 8.2l-6.845 9.289a1.011 1.011 0 01-1.43.188l-4.888-3.908a1 1 0 111.25-1.562l4.076 3.261 6.227-8.451a1 1 0 111.61 1.183z\"}))}function ro(t){return react__WEBPACK_IMPORTED_MODULE_0__.createElement(G,{...t},react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"path\",{d:\"M11.983 0a12.206 12.206 0 00-8.51 3.653A11.8 11.8 0 000 12.207 11.779 11.779 0 0011.8 24h.214A12.111 12.111 0 0024 11.791 11.766 11.766 0 0011.983 0zM10.5 16.542a1.476 1.476 0 011.449-1.53h.027a1.527 1.527 0 011.523 1.47 1.475 1.475 0 01-1.449 1.53h-.027a1.529 1.529 0 01-1.523-1.47zM11 12.5v-6a1 1 0 012 0v6a1 1 0 11-2 0z\"}))}function io(){return react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\",{className:\"Toastify__spinner\"})}var W={info:so,warning:ao,success:no,error:ro,spinner:io},lo=t=>t in W;function Nt({theme:t,type:o,isLoading:e,icon:r}){let s=null,l={theme:t,type:o};return r===!1||(P(r)?s=r({...l,isLoading:e}):(0,react__WEBPACK_IMPORTED_MODULE_0__.isValidElement)(r)?s=(0,react__WEBPACK_IMPORTED_MODULE_0__.cloneElement)(r,l):e?s=W.spinner():lo(o)&&(s=W[o](l))),s}var wt=t=>{let{isRunning:o,preventExitTransition:e,toastRef:r,eventHandlers:s,playToast:l}=At(t),{closeButton:a,children:d,autoClose:c,onClick:T,type:g,hideProgressBar:v,closeToast:x,transition:C,position:S,className:E,style:f,progressClassName:p,updateId:b,role:i,progress:n,rtl:u,toastId:h,deleteToast:m,isIn:_,isLoading:k,closeOnClick:M,theme:A,ariaLabel:R}=t,D=(0,clsx__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(\"Toastify__toast\",`Toastify__toast-theme--${A}`,`Toastify__toast--${g}`,{[\"Toastify__toast--rtl\"]:u},{[\"Toastify__toast--close-on-click\"]:M}),Y=P(E)?E({rtl:u,position:S,type:g,defaultClassName:D}):(0,clsx__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(D,E),ft=Nt(t),dt=!!n||!c,j={closeToast:x,type:g,theme:A},H=null;return a===!1||(P(a)?H=a(j):(0,react__WEBPACK_IMPORTED_MODULE_0__.isValidElement)(a)?H=(0,react__WEBPACK_IMPORTED_MODULE_0__.cloneElement)(a,j):H=yt(j)),react__WEBPACK_IMPORTED_MODULE_0__.createElement(C,{isIn:_,done:m,position:S,preventExitTransition:e,nodeRef:r,playToast:l},react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\",{id:h,tabIndex:0,onClick:T,\"data-in\":_,className:Y,...s,style:f,ref:r,..._&&{role:i,\"aria-label\":R}},ft!=null&&react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\",{className:(0,clsx__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(\"Toastify__toast-icon\",{[\"Toastify--animate-icon Toastify__zoom-enter\"]:!k})},ft),tt(d,t,!o),H,!t.customProgressBar&&react__WEBPACK_IMPORTED_MODULE_0__.createElement(gt,{...b&&!dt?{key:`p-${b}`}:{},rtl:u,theme:A,delay:c,isRunning:o,isIn:_,closeToast:x,hide:v,type:g,className:p,controlledProgress:dt,progress:n||0})))};var K=(t,o=!1)=>({enter:`Toastify--animate Toastify__${t}-enter`,exit:`Toastify--animate Toastify__${t}-exit`,appendPosition:o}),lt=$(K(\"bounce\",!0)),mo=$(K(\"slide\",!0)),po=$(K(\"zoom\")),uo=$(K(\"flip\"));var _o={position:\"top-right\",transition:lt,autoClose:5e3,closeButton:!0,pauseOnHover:!0,pauseOnFocusLoss:!0,draggable:\"touch\",draggablePercent:80,draggableDirection:\"x\",role:\"alert\",theme:\"light\",\"aria-label\":\"Notifications Alt+T\",hotKeys:t=>t.altKey&&t.code===\"KeyT\"};function Lt(t){let o={..._o,...t},e=t.stacked,[r,s]=(0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(!0),l=(0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null),{getToastToRender:a,isToastActive:d,count:c}=It(o),{className:T,style:g,rtl:v,containerId:x,hotKeys:C}=o;function S(f){let p=(0,clsx__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(\"Toastify__toast-container\",`Toastify__toast-container--${f}`,{[\"Toastify__toast-container--rtl\"]:v});return P(T)?T({position:f,rtl:v,defaultClassName:p}):(0,clsx__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(p,B(T))}function E(){e&&(s(!0),y.play())}return Ot(()=>{var f;if(e){let p=l.current.querySelectorAll('[data-in=\"true\"]'),b=12,i=(f=o.position)==null?void 0:f.includes(\"top\"),n=0,u=0;Array.from(p).reverse().forEach((h,m)=>{let _=h;_.classList.add(\"Toastify__toast--stacked\"),m>0&&(_.dataset.collapsed=`${r}`),_.dataset.pos||(_.dataset.pos=i?\"top\":\"bot\");let k=n*(r?.2:1)+(r?0:b*m);_.style.setProperty(\"--y\",`${i?k:k*-1}px`),_.style.setProperty(\"--g\",`${b}`),_.style.setProperty(\"--s\",`${1-(r?u:0)}`),n+=_.offsetHeight,u+=.025})}},[r,c,e]),(0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{function f(p){var i;let b=l.current;C(p)&&((i=b.querySelector('[tabIndex=\"0\"]'))==null||i.focus(),s(!1),y.pause()),p.key===\"Escape\"&&(document.activeElement===b||b!=null&&b.contains(document.activeElement))&&(s(!0),y.play())}return document.addEventListener(\"keydown\",f),()=>{document.removeEventListener(\"keydown\",f)}},[C]),react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"section\",{ref:l,className:\"Toastify\",id:x,onMouseEnter:()=>{e&&(s(!1),y.pause())},onMouseLeave:E,\"aria-live\":\"polite\",\"aria-atomic\":\"false\",\"aria-relevant\":\"additions text\",\"aria-label\":o[\"aria-label\"]},a((f,p)=>{let b=p.length?{...g}:{...g,pointerEvents:\"none\"};return react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\",{tabIndex:-1,className:S(f),\"data-stacked\":e,style:b,key:`c-${f}`},p.map(({content:i,props:n})=>react__WEBPACK_IMPORTED_MODULE_0__.createElement(wt,{...n,stacked:e,collapseAll:E,isIn:d(n.toastId,n.containerId),key:`t-${n.key}`},i)))}))}\n//# sourceMappingURL=index.mjs.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcmVhY3QtdG9hc3RpZnkvZGlzdC9pbmRleC5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUNBLGVBQWUsMkNBQTJDLGdHQUFnRyw2SkFBNkosVUFBVSw2QkFBNkIsK0JBQStCLCtCQUErQixrQ0FBa0Msa0NBQWtDLHlDQUF5QyxzREFBc0QsdURBQXVELDZEQUE2RCw2REFBNkQseURBQXlELHdDQUF3Qyw4QkFBOEIsOEJBQThCLGtGQUFrRixzRkFBc0Ysb0ZBQW9GLHdGQUF3RixrQ0FBa0MsK0JBQStCLGtDQUFrQyxtQ0FBbUMsZ0NBQWdDLHdEQUF3RCxtQ0FBbUMseUJBQXlCLHFDQUFxQyxpQ0FBaUMsaUNBQWlDLG9DQUFvQyxvQ0FBb0Msa0NBQWtDLGtDQUFrQyw2Q0FBNkMsaUhBQWlILHdDQUF3QywyREFBMkQsaUVBQWlFLGlFQUFpRSw2REFBNkQsa0NBQWtDLDJCQUEyQixnQ0FBZ0MsMkRBQTJELGVBQWUsc0NBQXNDLHNCQUFzQixXQUFXLGFBQWEsc0JBQXNCLHFDQUFxQyw4QkFBOEIsZ0NBQWdDLHVDQUF1Qyw4QkFBOEIsU0FBUywwQkFBMEIsbUJBQW1CLHNDQUFzQyw4QkFBOEIsa0NBQWtDLGdCQUFnQix3Q0FBd0Msb0NBQW9DLGdDQUFnQywwQ0FBMEMsb0NBQW9DLFNBQVMsMEJBQTBCLG1CQUFtQix5Q0FBeUMsb0NBQW9DLGtDQUFrQyxnQkFBZ0IsaUJBQWlCLE9BQU8sa0JBQWtCLGtCQUFrQixrQ0FBa0MsNENBQTRDLHNCQUFzQixtQkFBbUIsc0NBQXNDLDhDQUE4Qyx3Q0FBd0MsNENBQTRDLHdDQUF3QyxVQUFVLGFBQWEsWUFBWSxtQkFBbUIsc0JBQXNCLDBDQUEwQywyQkFBMkIsWUFBWSwrQkFBK0IsU0FBUyxrSEFBa0gsNkJBQTZCLHVCQUF1QiwySEFBMkgsbUNBQW1DLHVCQUF1QixnQ0FBZ0MsaUNBQWlDLGFBQWEsaUJBQWlCLDZCQUE2QixnQkFBZ0IsaUJBQWlCLDhDQUE4QyxrQ0FBa0MsMEJBQTBC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QUcsMkJBQTJCLEVBQUUsc0NBQXNDLFlBQVksMkNBQTJDLEVBQUUsZ0RBQUUsNkJBQTZCLDRCQUE0QixRQUFRLDRCQUE0QixxREFBRSxNQUFNLG1EQUFFLGVBQWUsZ0RBQWUsSUFBSSx1RUFBdUUsQ0FBQyxnREFBZSxRQUFRLDRFQUE0RSx1QkFBdUIsV0FBVyxnREFBZSxRQUFRLFVBQVUsZ0RBQUUseUJBQXlCLG1EQUFtRCxFQUFFLHdDQUF3QyxnREFBZSxLQUFLLFdBQVcsU0FBUyxFQUFFLEVBQUUsR0FBRyxxSEFBcUgsS0FBSyxrQkFBa0IscUNBQXFDLEVBQUUsNENBQTRDLEVBQUUsd0JBQXdCLDJFQUEyRSxRQUFRLHFRQUFxUSxlQUFlLE9BQU8sV0FBVyxtQkFBbUIsK0NBQUUsT0FBTyw2Q0FBRSxRQUFRLDJDQUEyQyxRQUFRLGtEQUFrRCxHQUFHLGNBQWMsTUFBTSxnREFBRSwyREFBMkQsRUFBRSxHQUFHLHFDQUFxQyxFQUFFLGVBQWUsb0NBQW9DLEVBQUUsZ0RBQUUsU0FBUyxhQUFhLG9CQUFvQixlQUFlLE1BQU0sTUFBTSxrSEFBa0gsd0NBQXdDLFFBQVEseUVBQXlFLEVBQUUsZ0RBQWdELDJCQUEyQiw2QkFBNkIsU0FBUyxrQ0FBa0MsRUFBRSxnQ0FBZ0MsVUFBVSw2QkFBNkIsR0FBRyxVQUFVLGdEQUFFLE1BQU0sY0FBYyxNQUFNLGdCQUFnQiw2TEFBNkwsbURBQW1ELDJDQUEyQyxNQUFNLGdEQUFnQixZQUFZLGtEQUFrRCxxQkFBcUIseUhBQXlILFdBQVcsZ0JBQWdCLEtBQUssRUFBRSwyQkFBMkIsT0FBTyxnREFBZ0IsUUFBUSw2REFBNkQsRUFBRSxFQUFFLFNBQVMsa0JBQWtCLEdBQUcsZ0RBQWdCLEtBQUssc0VBQXNFLE1BQU0sRUFBRSxNQUFNLEdBQTJJO0FBQ2pwZ0IiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL3JlYWN0LXRvYXN0aWZ5L2Rpc3QvaW5kZXgubWpzPzE1OGIiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2UgY2xpZW50XCI7XG5mdW5jdGlvbiBNdCh0KXtpZighdHx8dHlwZW9mIGRvY3VtZW50PT1cInVuZGVmaW5lZFwiKXJldHVybjtsZXQgbz1kb2N1bWVudC5oZWFkfHxkb2N1bWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZShcImhlYWRcIilbMF0sZT1kb2N1bWVudC5jcmVhdGVFbGVtZW50KFwic3R5bGVcIik7ZS50eXBlPVwidGV4dC9jc3NcIixvLmZpcnN0Q2hpbGQ/by5pbnNlcnRCZWZvcmUoZSxvLmZpcnN0Q2hpbGQpOm8uYXBwZW5kQ2hpbGQoZSksZS5zdHlsZVNoZWV0P2Uuc3R5bGVTaGVldC5jc3NUZXh0PXQ6ZS5hcHBlbmRDaGlsZChkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSh0KSl9TXQoYDpyb290ey0tdG9hc3RpZnktY29sb3ItbGlnaHQ6ICNmZmY7LS10b2FzdGlmeS1jb2xvci1kYXJrOiAjMTIxMjEyOy0tdG9hc3RpZnktY29sb3ItaW5mbzogIzM0OThkYjstLXRvYXN0aWZ5LWNvbG9yLXN1Y2Nlc3M6ICMwN2JjMGM7LS10b2FzdGlmeS1jb2xvci13YXJuaW5nOiAjZjFjNDBmOy0tdG9hc3RpZnktY29sb3ItZXJyb3I6IGhzbCg2LCA3OCUsIDU3JSk7LS10b2FzdGlmeS1jb2xvci10cmFuc3BhcmVudDogcmdiYSgyNTUsIDI1NSwgMjU1LCAuNyk7LS10b2FzdGlmeS1pY29uLWNvbG9yLWluZm86IHZhcigtLXRvYXN0aWZ5LWNvbG9yLWluZm8pOy0tdG9hc3RpZnktaWNvbi1jb2xvci1zdWNjZXNzOiB2YXIoLS10b2FzdGlmeS1jb2xvci1zdWNjZXNzKTstLXRvYXN0aWZ5LWljb24tY29sb3Itd2FybmluZzogdmFyKC0tdG9hc3RpZnktY29sb3Itd2FybmluZyk7LS10b2FzdGlmeS1pY29uLWNvbG9yLWVycm9yOiB2YXIoLS10b2FzdGlmeS1jb2xvci1lcnJvcik7LS10b2FzdGlmeS1jb250YWluZXItd2lkdGg6IGZpdC1jb250ZW50Oy0tdG9hc3RpZnktdG9hc3Qtd2lkdGg6IDMyMHB4Oy0tdG9hc3RpZnktdG9hc3Qtb2Zmc2V0OiAxNnB4Oy0tdG9hc3RpZnktdG9hc3QtdG9wOiBtYXgodmFyKC0tdG9hc3RpZnktdG9hc3Qtb2Zmc2V0KSwgZW52KHNhZmUtYXJlYS1pbnNldC10b3ApKTstLXRvYXN0aWZ5LXRvYXN0LXJpZ2h0OiBtYXgodmFyKC0tdG9hc3RpZnktdG9hc3Qtb2Zmc2V0KSwgZW52KHNhZmUtYXJlYS1pbnNldC1yaWdodCkpOy0tdG9hc3RpZnktdG9hc3QtbGVmdDogbWF4KHZhcigtLXRvYXN0aWZ5LXRvYXN0LW9mZnNldCksIGVudihzYWZlLWFyZWEtaW5zZXQtbGVmdCkpOy0tdG9hc3RpZnktdG9hc3QtYm90dG9tOiBtYXgodmFyKC0tdG9hc3RpZnktdG9hc3Qtb2Zmc2V0KSwgZW52KHNhZmUtYXJlYS1pbnNldC1ib3R0b20pKTstLXRvYXN0aWZ5LXRvYXN0LWJhY2tncm91bmQ6ICNmZmY7LS10b2FzdGlmeS10b2FzdC1wYWRkaW5nOiAxNHB4Oy0tdG9hc3RpZnktdG9hc3QtbWluLWhlaWdodDogNjRweDstLXRvYXN0aWZ5LXRvYXN0LW1heC1oZWlnaHQ6IDgwMHB4Oy0tdG9hc3RpZnktdG9hc3QtYmQtcmFkaXVzOiA2cHg7LS10b2FzdGlmeS10b2FzdC1zaGFkb3c6IDBweCA0cHggMTJweCByZ2JhKDAsIDAsIDAsIC4xKTstLXRvYXN0aWZ5LWZvbnQtZmFtaWx5OiBzYW5zLXNlcmlmOy0tdG9hc3RpZnktei1pbmRleDogOTk5OTstLXRvYXN0aWZ5LXRleHQtY29sb3ItbGlnaHQ6ICM3NTc1NzU7LS10b2FzdGlmeS10ZXh0LWNvbG9yLWRhcms6ICNmZmY7LS10b2FzdGlmeS10ZXh0LWNvbG9yLWluZm86ICNmZmY7LS10b2FzdGlmeS10ZXh0LWNvbG9yLXN1Y2Nlc3M6ICNmZmY7LS10b2FzdGlmeS10ZXh0LWNvbG9yLXdhcm5pbmc6ICNmZmY7LS10b2FzdGlmeS10ZXh0LWNvbG9yLWVycm9yOiAjZmZmOy0tdG9hc3RpZnktc3Bpbm5lci1jb2xvcjogIzYxNjE2MTstLXRvYXN0aWZ5LXNwaW5uZXItY29sb3ItZW1wdHktYXJlYTogI2UwZTBlMDstLXRvYXN0aWZ5LWNvbG9yLXByb2dyZXNzLWxpZ2h0OiBsaW5lYXItZ3JhZGllbnQodG8gcmlnaHQsICM0Y2Q5NjQsICM1YWM4ZmEsICMwMDdhZmYsICMzNGFhZGMsICM1ODU2ZDYsICNmZjJkNTUpOy0tdG9hc3RpZnktY29sb3ItcHJvZ3Jlc3MtZGFyazogI2JiODZmYzstLXRvYXN0aWZ5LWNvbG9yLXByb2dyZXNzLWluZm86IHZhcigtLXRvYXN0aWZ5LWNvbG9yLWluZm8pOy0tdG9hc3RpZnktY29sb3ItcHJvZ3Jlc3Mtc3VjY2VzczogdmFyKC0tdG9hc3RpZnktY29sb3Itc3VjY2Vzcyk7LS10b2FzdGlmeS1jb2xvci1wcm9ncmVzcy13YXJuaW5nOiB2YXIoLS10b2FzdGlmeS1jb2xvci13YXJuaW5nKTstLXRvYXN0aWZ5LWNvbG9yLXByb2dyZXNzLWVycm9yOiB2YXIoLS10b2FzdGlmeS1jb2xvci1lcnJvcik7LS10b2FzdGlmeS1jb2xvci1wcm9ncmVzcy1iZ286IC4yfS5Ub2FzdGlmeV9fdG9hc3QtY29udGFpbmVye3otaW5kZXg6dmFyKC0tdG9hc3RpZnktei1pbmRleCk7LXdlYmtpdC10cmFuc2Zvcm06dHJhbnNsYXRlM2QoMCwwLHZhcigtLXRvYXN0aWZ5LXotaW5kZXgpKTtwb3NpdGlvbjpmaXhlZDt3aWR0aDp2YXIoLS10b2FzdGlmeS1jb250YWluZXItd2lkdGgpO2JveC1zaXppbmc6Ym9yZGVyLWJveDtjb2xvcjojZmZmO2Rpc3BsYXk6ZmxleDtmbGV4LWRpcmVjdGlvbjpjb2x1bW59LlRvYXN0aWZ5X190b2FzdC1jb250YWluZXItLXRvcC1sZWZ0e3RvcDp2YXIoLS10b2FzdGlmeS10b2FzdC10b3ApO2xlZnQ6dmFyKC0tdG9hc3RpZnktdG9hc3QtbGVmdCl9LlRvYXN0aWZ5X190b2FzdC1jb250YWluZXItLXRvcC1jZW50ZXJ7dG9wOnZhcigtLXRvYXN0aWZ5LXRvYXN0LXRvcCk7bGVmdDo1MCU7dHJhbnNmb3JtOnRyYW5zbGF0ZSgtNTAlKTthbGlnbi1pdGVtczpjZW50ZXJ9LlRvYXN0aWZ5X190b2FzdC1jb250YWluZXItLXRvcC1yaWdodHt0b3A6dmFyKC0tdG9hc3RpZnktdG9hc3QtdG9wKTtyaWdodDp2YXIoLS10b2FzdGlmeS10b2FzdC1yaWdodCk7YWxpZ24taXRlbXM6ZW5kfS5Ub2FzdGlmeV9fdG9hc3QtY29udGFpbmVyLS1ib3R0b20tbGVmdHtib3R0b206dmFyKC0tdG9hc3RpZnktdG9hc3QtYm90dG9tKTtsZWZ0OnZhcigtLXRvYXN0aWZ5LXRvYXN0LWxlZnQpfS5Ub2FzdGlmeV9fdG9hc3QtY29udGFpbmVyLS1ib3R0b20tY2VudGVye2JvdHRvbTp2YXIoLS10b2FzdGlmeS10b2FzdC1ib3R0b20pO2xlZnQ6NTAlO3RyYW5zZm9ybTp0cmFuc2xhdGUoLTUwJSk7YWxpZ24taXRlbXM6Y2VudGVyfS5Ub2FzdGlmeV9fdG9hc3QtY29udGFpbmVyLS1ib3R0b20tcmlnaHR7Ym90dG9tOnZhcigtLXRvYXN0aWZ5LXRvYXN0LWJvdHRvbSk7cmlnaHQ6dmFyKC0tdG9hc3RpZnktdG9hc3QtcmlnaHQpO2FsaWduLWl0ZW1zOmVuZH0uVG9hc3RpZnlfX3RvYXN0ey0teTogMDtwb3NpdGlvbjpyZWxhdGl2ZTt0b3VjaC1hY3Rpb246bm9uZTt3aWR0aDp2YXIoLS10b2FzdGlmeS10b2FzdC13aWR0aCk7bWluLWhlaWdodDp2YXIoLS10b2FzdGlmeS10b2FzdC1taW4taGVpZ2h0KTtib3gtc2l6aW5nOmJvcmRlci1ib3g7bWFyZ2luLWJvdHRvbToxcmVtO3BhZGRpbmc6dmFyKC0tdG9hc3RpZnktdG9hc3QtcGFkZGluZyk7Ym9yZGVyLXJhZGl1czp2YXIoLS10b2FzdGlmeS10b2FzdC1iZC1yYWRpdXMpO2JveC1zaGFkb3c6dmFyKC0tdG9hc3RpZnktdG9hc3Qtc2hhZG93KTttYXgtaGVpZ2h0OnZhcigtLXRvYXN0aWZ5LXRvYXN0LW1heC1oZWlnaHQpO2ZvbnQtZmFtaWx5OnZhcigtLXRvYXN0aWZ5LWZvbnQtZmFtaWx5KTt6LWluZGV4OjA7ZGlzcGxheTpmbGV4O2ZsZXg6MSBhdXRvO2FsaWduLWl0ZW1zOmNlbnRlcjt3b3JkLWJyZWFrOmJyZWFrLXdvcmR9QG1lZGlhIG9ubHkgc2NyZWVuIGFuZCAobWF4LXdpZHRoOiA0ODBweCl7LlRvYXN0aWZ5X190b2FzdC1jb250YWluZXJ7d2lkdGg6MTAwdnc7bGVmdDplbnYoc2FmZS1hcmVhLWluc2V0LWxlZnQpO21hcmdpbjowfS5Ub2FzdGlmeV9fdG9hc3QtY29udGFpbmVyLS10b3AtbGVmdCwuVG9hc3RpZnlfX3RvYXN0LWNvbnRhaW5lci0tdG9wLWNlbnRlciwuVG9hc3RpZnlfX3RvYXN0LWNvbnRhaW5lci0tdG9wLXJpZ2h0e3RvcDplbnYoc2FmZS1hcmVhLWluc2V0LXRvcCk7dHJhbnNmb3JtOnRyYW5zbGF0ZSgwKX0uVG9hc3RpZnlfX3RvYXN0LWNvbnRhaW5lci0tYm90dG9tLWxlZnQsLlRvYXN0aWZ5X190b2FzdC1jb250YWluZXItLWJvdHRvbS1jZW50ZXIsLlRvYXN0aWZ5X190b2FzdC1jb250YWluZXItLWJvdHRvbS1yaWdodHtib3R0b206ZW52KHNhZmUtYXJlYS1pbnNldC1ib3R0b20pO3RyYW5zZm9ybTp0cmFuc2xhdGUoMCl9LlRvYXN0aWZ5X190b2FzdC1jb250YWluZXItLXJ0bHtyaWdodDplbnYoc2FmZS1hcmVhLWluc2V0LXJpZ2h0KTtsZWZ0OmluaXRpYWx9LlRvYXN0aWZ5X190b2FzdHstLXRvYXN0aWZ5LXRvYXN0LXdpZHRoOiAxMDAlO21hcmdpbi1ib3R0b206MDtib3JkZXItcmFkaXVzOjB9fS5Ub2FzdGlmeV9fdG9hc3QtY29udGFpbmVyW2RhdGEtc3RhY2tlZD10cnVlXXt3aWR0aDp2YXIoLS10b2FzdGlmeS10b2FzdC13aWR0aCl9LlRvYXN0aWZ5X190b2FzdC0tc3RhY2tlZHtwb3NpdGlvbjphYnNvbHV0ZTt3aWR0aDoxMDAlO3RyYW5zZm9ybTp0cmFuc2xhdGUzZCgwLHZhcigtLXkpLDApIHNjYWxlKHZhcigtLXMpKTt0cmFuc2l0aW9uOnRyYW5zZm9ybSAuM3N9LlRvYXN0aWZ5X190b2FzdC0tc3RhY2tlZFtkYXRhLWNvbGxhcHNlZF0gLlRvYXN0aWZ5X190b2FzdC1ib2R5LC5Ub2FzdGlmeV9fdG9hc3QtLXN0YWNrZWRbZGF0YS1jb2xsYXBzZWRdIC5Ub2FzdGlmeV9fY2xvc2UtYnV0dG9ue3RyYW5zaXRpb246b3BhY2l0eSAuMXN9LlRvYXN0aWZ5X190b2FzdC0tc3RhY2tlZFtkYXRhLWNvbGxhcHNlZD1mYWxzZV17b3ZlcmZsb3c6dmlzaWJsZX0uVG9hc3RpZnlfX3RvYXN0LS1zdGFja2VkW2RhdGEtY29sbGFwc2VkPXRydWVdOm5vdCg6bGFzdC1jaGlsZCk+KntvcGFjaXR5OjB9LlRvYXN0aWZ5X190b2FzdC0tc3RhY2tlZDphZnRlcntjb250ZW50OlwiXCI7cG9zaXRpb246YWJzb2x1dGU7bGVmdDowO3JpZ2h0OjA7aGVpZ2h0OmNhbGModmFyKC0tZykgKiAxcHgpO2JvdHRvbToxMDAlfS5Ub2FzdGlmeV9fdG9hc3QtLXN0YWNrZWRbZGF0YS1wb3M9dG9wXXt0b3A6MH0uVG9hc3RpZnlfX3RvYXN0LS1zdGFja2VkW2RhdGEtcG9zPWJvdF17Ym90dG9tOjB9LlRvYXN0aWZ5X190b2FzdC0tc3RhY2tlZFtkYXRhLXBvcz1ib3RdLlRvYXN0aWZ5X190b2FzdC0tc3RhY2tlZDpiZWZvcmV7dHJhbnNmb3JtLW9yaWdpbjp0b3B9LlRvYXN0aWZ5X190b2FzdC0tc3RhY2tlZFtkYXRhLXBvcz10b3BdLlRvYXN0aWZ5X190b2FzdC0tc3RhY2tlZDpiZWZvcmV7dHJhbnNmb3JtLW9yaWdpbjpib3R0b219LlRvYXN0aWZ5X190b2FzdC0tc3RhY2tlZDpiZWZvcmV7Y29udGVudDpcIlwiO3Bvc2l0aW9uOmFic29sdXRlO2xlZnQ6MDtyaWdodDowO2JvdHRvbTowO2hlaWdodDoxMDAlO3RyYW5zZm9ybTpzY2FsZVkoMyk7ei1pbmRleDotMX0uVG9hc3RpZnlfX3RvYXN0LS1ydGx7ZGlyZWN0aW9uOnJ0bH0uVG9hc3RpZnlfX3RvYXN0LS1jbG9zZS1vbi1jbGlja3tjdXJzb3I6cG9pbnRlcn0uVG9hc3RpZnlfX3RvYXN0LWljb257bWFyZ2luLWlubGluZS1lbmQ6MTBweDt3aWR0aDoyMnB4O2ZsZXgtc2hyaW5rOjA7ZGlzcGxheTpmbGV4fS5Ub2FzdGlmeS0tYW5pbWF0ZXthbmltYXRpb24tZmlsbC1tb2RlOmJvdGg7YW5pbWF0aW9uLWR1cmF0aW9uOi41c30uVG9hc3RpZnktLWFuaW1hdGUtaWNvbnthbmltYXRpb24tZmlsbC1tb2RlOmJvdGg7YW5pbWF0aW9uLWR1cmF0aW9uOi4zc30uVG9hc3RpZnlfX3RvYXN0LXRoZW1lLS1kYXJre2JhY2tncm91bmQ6dmFyKC0tdG9hc3RpZnktY29sb3ItZGFyayk7Y29sb3I6dmFyKC0tdG9hc3RpZnktdGV4dC1jb2xvci1kYXJrKX0uVG9hc3RpZnlfX3RvYXN0LXRoZW1lLS1saWdodCwuVG9hc3RpZnlfX3RvYXN0LXRoZW1lLS1jb2xvcmVkLlRvYXN0aWZ5X190b2FzdC0tZGVmYXVsdHtiYWNrZ3JvdW5kOnZhcigtLXRvYXN0aWZ5LWNvbG9yLWxpZ2h0KTtjb2xvcjp2YXIoLS10b2FzdGlmeS10ZXh0LWNvbG9yLWxpZ2h0KX0uVG9hc3RpZnlfX3RvYXN0LXRoZW1lLS1jb2xvcmVkLlRvYXN0aWZ5X190b2FzdC0taW5mb3tjb2xvcjp2YXIoLS10b2FzdGlmeS10ZXh0LWNvbG9yLWluZm8pO2JhY2tncm91bmQ6dmFyKC0tdG9hc3RpZnktY29sb3ItaW5mbyl9LlRvYXN0aWZ5X190b2FzdC10aGVtZS0tY29sb3JlZC5Ub2FzdGlmeV9fdG9hc3QtLXN1Y2Nlc3N7Y29sb3I6dmFyKC0tdG9hc3RpZnktdGV4dC1jb2xvci1zdWNjZXNzKTtiYWNrZ3JvdW5kOnZhcigtLXRvYXN0aWZ5LWNvbG9yLXN1Y2Nlc3MpfS5Ub2FzdGlmeV9fdG9hc3QtdGhlbWUtLWNvbG9yZWQuVG9hc3RpZnlfX3RvYXN0LS13YXJuaW5ne2NvbG9yOnZhcigtLXRvYXN0aWZ5LXRleHQtY29sb3Itd2FybmluZyk7YmFja2dyb3VuZDp2YXIoLS10b2FzdGlmeS1jb2xvci13YXJuaW5nKX0uVG9hc3RpZnlfX3RvYXN0LXRoZW1lLS1jb2xvcmVkLlRvYXN0aWZ5X190b2FzdC0tZXJyb3J7Y29sb3I6dmFyKC0tdG9hc3RpZnktdGV4dC1jb2xvci1lcnJvcik7YmFja2dyb3VuZDp2YXIoLS10b2FzdGlmeS1jb2xvci1lcnJvcil9LlRvYXN0aWZ5X19wcm9ncmVzcy1iYXItdGhlbWUtLWxpZ2h0e2JhY2tncm91bmQ6dmFyKC0tdG9hc3RpZnktY29sb3ItcHJvZ3Jlc3MtbGlnaHQpfS5Ub2FzdGlmeV9fcHJvZ3Jlc3MtYmFyLXRoZW1lLS1kYXJre2JhY2tncm91bmQ6dmFyKC0tdG9hc3RpZnktY29sb3ItcHJvZ3Jlc3MtZGFyayl9LlRvYXN0aWZ5X19wcm9ncmVzcy1iYXItLWluZm97YmFja2dyb3VuZDp2YXIoLS10b2FzdGlmeS1jb2xvci1wcm9ncmVzcy1pbmZvKX0uVG9hc3RpZnlfX3Byb2dyZXNzLWJhci0tc3VjY2Vzc3tiYWNrZ3JvdW5kOnZhcigtLXRvYXN0aWZ5LWNvbG9yLXByb2dyZXNzLXN1Y2Nlc3MpfS5Ub2FzdGlmeV9fcHJvZ3Jlc3MtYmFyLS13YXJuaW5ne2JhY2tncm91bmQ6dmFyKC0tdG9hc3RpZnktY29sb3ItcHJvZ3Jlc3Mtd2FybmluZyl9LlRvYXN0aWZ5X19wcm9ncmVzcy1iYXItLWVycm9ye2JhY2tncm91bmQ6dmFyKC0tdG9hc3RpZnktY29sb3ItcHJvZ3Jlc3MtZXJyb3IpfS5Ub2FzdGlmeV9fcHJvZ3Jlc3MtYmFyLXRoZW1lLS1jb2xvcmVkLlRvYXN0aWZ5X19wcm9ncmVzcy1iYXItLWluZm8sLlRvYXN0aWZ5X19wcm9ncmVzcy1iYXItdGhlbWUtLWNvbG9yZWQuVG9hc3RpZnlfX3Byb2dyZXNzLWJhci0tc3VjY2VzcywuVG9hc3RpZnlfX3Byb2dyZXNzLWJhci10aGVtZS0tY29sb3JlZC5Ub2FzdGlmeV9fcHJvZ3Jlc3MtYmFyLS13YXJuaW5nLC5Ub2FzdGlmeV9fcHJvZ3Jlc3MtYmFyLXRoZW1lLS1jb2xvcmVkLlRvYXN0aWZ5X19wcm9ncmVzcy1iYXItLWVycm9ye2JhY2tncm91bmQ6dmFyKC0tdG9hc3RpZnktY29sb3ItdHJhbnNwYXJlbnQpfS5Ub2FzdGlmeV9fY2xvc2UtYnV0dG9ue2NvbG9yOiNmZmY7cG9zaXRpb246YWJzb2x1dGU7dG9wOjZweDtyaWdodDo2cHg7YmFja2dyb3VuZDp0cmFuc3BhcmVudDtvdXRsaW5lOm5vbmU7Ym9yZGVyOm5vbmU7cGFkZGluZzowO2N1cnNvcjpwb2ludGVyO29wYWNpdHk6Ljc7dHJhbnNpdGlvbjouM3MgZWFzZTt6LWluZGV4OjF9LlRvYXN0aWZ5X190b2FzdC0tcnRsIC5Ub2FzdGlmeV9fY2xvc2UtYnV0dG9ue2xlZnQ6NnB4O3JpZ2h0OnVuc2V0fS5Ub2FzdGlmeV9fY2xvc2UtYnV0dG9uLS1saWdodHtjb2xvcjojMDAwO29wYWNpdHk6LjN9LlRvYXN0aWZ5X19jbG9zZS1idXR0b24+c3Zne2ZpbGw6Y3VycmVudENvbG9yO2hlaWdodDoxNnB4O3dpZHRoOjE0cHh9LlRvYXN0aWZ5X19jbG9zZS1idXR0b246aG92ZXIsLlRvYXN0aWZ5X19jbG9zZS1idXR0b246Zm9jdXN7b3BhY2l0eToxfUBrZXlmcmFtZXMgVG9hc3RpZnlfX3RyYWNrUHJvZ3Jlc3N7MCV7dHJhbnNmb3JtOnNjYWxlWCgxKX10b3t0cmFuc2Zvcm06c2NhbGVYKDApfX0uVG9hc3RpZnlfX3Byb2dyZXNzLWJhcntwb3NpdGlvbjphYnNvbHV0ZTtib3R0b206MDtsZWZ0OjA7d2lkdGg6MTAwJTtoZWlnaHQ6MTAwJTt6LWluZGV4OjE7b3BhY2l0eTouNzt0cmFuc2Zvcm0tb3JpZ2luOmxlZnR9LlRvYXN0aWZ5X19wcm9ncmVzcy1iYXItLWFuaW1hdGVke2FuaW1hdGlvbjpUb2FzdGlmeV9fdHJhY2tQcm9ncmVzcyBsaW5lYXIgMSBmb3J3YXJkc30uVG9hc3RpZnlfX3Byb2dyZXNzLWJhci0tY29udHJvbGxlZHt0cmFuc2l0aW9uOnRyYW5zZm9ybSAuMnN9LlRvYXN0aWZ5X19wcm9ncmVzcy1iYXItLXJ0bHtyaWdodDowO2xlZnQ6aW5pdGlhbDt0cmFuc2Zvcm0tb3JpZ2luOnJpZ2h0O2JvcmRlci1ib3R0b20tbGVmdC1yYWRpdXM6aW5pdGlhbH0uVG9hc3RpZnlfX3Byb2dyZXNzLWJhci0td3Jwe3Bvc2l0aW9uOmFic29sdXRlO292ZXJmbG93OmhpZGRlbjtib3R0b206MDtsZWZ0OjA7d2lkdGg6MTAwJTtoZWlnaHQ6NXB4O2JvcmRlci1ib3R0b20tbGVmdC1yYWRpdXM6dmFyKC0tdG9hc3RpZnktdG9hc3QtYmQtcmFkaXVzKTtib3JkZXItYm90dG9tLXJpZ2h0LXJhZGl1czp2YXIoLS10b2FzdGlmeS10b2FzdC1iZC1yYWRpdXMpfS5Ub2FzdGlmeV9fcHJvZ3Jlc3MtYmFyLS13cnBbZGF0YS1oaWRkZW49dHJ1ZV17b3BhY2l0eTowfS5Ub2FzdGlmeV9fcHJvZ3Jlc3MtYmFyLS1iZ3tvcGFjaXR5OnZhcigtLXRvYXN0aWZ5LWNvbG9yLXByb2dyZXNzLWJnbyk7d2lkdGg6MTAwJTtoZWlnaHQ6MTAwJX0uVG9hc3RpZnlfX3NwaW5uZXJ7d2lkdGg6MjBweDtoZWlnaHQ6MjBweDtib3gtc2l6aW5nOmJvcmRlci1ib3g7Ym9yZGVyOjJweCBzb2xpZDtib3JkZXItcmFkaXVzOjEwMCU7Ym9yZGVyLWNvbG9yOnZhcigtLXRvYXN0aWZ5LXNwaW5uZXItY29sb3ItZW1wdHktYXJlYSk7Ym9yZGVyLXJpZ2h0LWNvbG9yOnZhcigtLXRvYXN0aWZ5LXNwaW5uZXItY29sb3IpO2FuaW1hdGlvbjpUb2FzdGlmeV9fc3BpbiAuNjVzIGxpbmVhciBpbmZpbml0ZX1Aa2V5ZnJhbWVzIFRvYXN0aWZ5X19ib3VuY2VJblJpZ2h0ezAlLDYwJSw3NSUsOTAlLHRve2FuaW1hdGlvbi10aW1pbmctZnVuY3Rpb246Y3ViaWMtYmV6aWVyKC4yMTUsLjYxLC4zNTUsMSl9MCV7b3BhY2l0eTowO3RyYW5zZm9ybTp0cmFuc2xhdGUzZCgzMDAwcHgsMCwwKX02MCV7b3BhY2l0eToxO3RyYW5zZm9ybTp0cmFuc2xhdGUzZCgtMjVweCwwLDApfTc1JXt0cmFuc2Zvcm06dHJhbnNsYXRlM2QoMTBweCwwLDApfTkwJXt0cmFuc2Zvcm06dHJhbnNsYXRlM2QoLTVweCwwLDApfXRve3RyYW5zZm9ybTpub25lfX1Aa2V5ZnJhbWVzIFRvYXN0aWZ5X19ib3VuY2VPdXRSaWdodHsyMCV7b3BhY2l0eToxO3RyYW5zZm9ybTp0cmFuc2xhdGUzZCgtMjBweCx2YXIoLS15KSwwKX10b3tvcGFjaXR5OjA7dHJhbnNmb3JtOnRyYW5zbGF0ZTNkKDIwMDBweCx2YXIoLS15KSwwKX19QGtleWZyYW1lcyBUb2FzdGlmeV9fYm91bmNlSW5MZWZ0ezAlLDYwJSw3NSUsOTAlLHRve2FuaW1hdGlvbi10aW1pbmctZnVuY3Rpb246Y3ViaWMtYmV6aWVyKC4yMTUsLjYxLC4zNTUsMSl9MCV7b3BhY2l0eTowO3RyYW5zZm9ybTp0cmFuc2xhdGUzZCgtMzAwMHB4LDAsMCl9NjAle29wYWNpdHk6MTt0cmFuc2Zvcm06dHJhbnNsYXRlM2QoMjVweCwwLDApfTc1JXt0cmFuc2Zvcm06dHJhbnNsYXRlM2QoLTEwcHgsMCwwKX05MCV7dHJhbnNmb3JtOnRyYW5zbGF0ZTNkKDVweCwwLDApfXRve3RyYW5zZm9ybTpub25lfX1Aa2V5ZnJhbWVzIFRvYXN0aWZ5X19ib3VuY2VPdXRMZWZ0ezIwJXtvcGFjaXR5OjE7dHJhbnNmb3JtOnRyYW5zbGF0ZTNkKDIwcHgsdmFyKC0teSksMCl9dG97b3BhY2l0eTowO3RyYW5zZm9ybTp0cmFuc2xhdGUzZCgtMjAwMHB4LHZhcigtLXkpLDApfX1Aa2V5ZnJhbWVzIFRvYXN0aWZ5X19ib3VuY2VJblVwezAlLDYwJSw3NSUsOTAlLHRve2FuaW1hdGlvbi10aW1pbmctZnVuY3Rpb246Y3ViaWMtYmV6aWVyKC4yMTUsLjYxLC4zNTUsMSl9MCV7b3BhY2l0eTowO3RyYW5zZm9ybTp0cmFuc2xhdGUzZCgwLDMwMDBweCwwKX02MCV7b3BhY2l0eToxO3RyYW5zZm9ybTp0cmFuc2xhdGUzZCgwLC0yMHB4LDApfTc1JXt0cmFuc2Zvcm06dHJhbnNsYXRlM2QoMCwxMHB4LDApfTkwJXt0cmFuc2Zvcm06dHJhbnNsYXRlM2QoMCwtNXB4LDApfXRve3RyYW5zZm9ybTp0cmFuc2xhdGVaKDApfX1Aa2V5ZnJhbWVzIFRvYXN0aWZ5X19ib3VuY2VPdXRVcHsyMCV7dHJhbnNmb3JtOnRyYW5zbGF0ZTNkKDAsY2FsYyh2YXIoLS15KSAtIDEwcHgpLDApfTQwJSw0NSV7b3BhY2l0eToxO3RyYW5zZm9ybTp0cmFuc2xhdGUzZCgwLGNhbGModmFyKC0teSkgKyAyMHB4KSwwKX10b3tvcGFjaXR5OjA7dHJhbnNmb3JtOnRyYW5zbGF0ZTNkKDAsLTIwMDBweCwwKX19QGtleWZyYW1lcyBUb2FzdGlmeV9fYm91bmNlSW5Eb3duezAlLDYwJSw3NSUsOTAlLHRve2FuaW1hdGlvbi10aW1pbmctZnVuY3Rpb246Y3ViaWMtYmV6aWVyKC4yMTUsLjYxLC4zNTUsMSl9MCV7b3BhY2l0eTowO3RyYW5zZm9ybTp0cmFuc2xhdGUzZCgwLC0zMDAwcHgsMCl9NjAle29wYWNpdHk6MTt0cmFuc2Zvcm06dHJhbnNsYXRlM2QoMCwyNXB4LDApfTc1JXt0cmFuc2Zvcm06dHJhbnNsYXRlM2QoMCwtMTBweCwwKX05MCV7dHJhbnNmb3JtOnRyYW5zbGF0ZTNkKDAsNXB4LDApfXRve3RyYW5zZm9ybTpub25lfX1Aa2V5ZnJhbWVzIFRvYXN0aWZ5X19ib3VuY2VPdXREb3duezIwJXt0cmFuc2Zvcm06dHJhbnNsYXRlM2QoMCxjYWxjKHZhcigtLXkpIC0gMTBweCksMCl9NDAlLDQ1JXtvcGFjaXR5OjE7dHJhbnNmb3JtOnRyYW5zbGF0ZTNkKDAsY2FsYyh2YXIoLS15KSArIDIwcHgpLDApfXRve29wYWNpdHk6MDt0cmFuc2Zvcm06dHJhbnNsYXRlM2QoMCwyMDAwcHgsMCl9fS5Ub2FzdGlmeV9fYm91bmNlLWVudGVyLS10b3AtbGVmdCwuVG9hc3RpZnlfX2JvdW5jZS1lbnRlci0tYm90dG9tLWxlZnR7YW5pbWF0aW9uLW5hbWU6VG9hc3RpZnlfX2JvdW5jZUluTGVmdH0uVG9hc3RpZnlfX2JvdW5jZS1lbnRlci0tdG9wLXJpZ2h0LC5Ub2FzdGlmeV9fYm91bmNlLWVudGVyLS1ib3R0b20tcmlnaHR7YW5pbWF0aW9uLW5hbWU6VG9hc3RpZnlfX2JvdW5jZUluUmlnaHR9LlRvYXN0aWZ5X19ib3VuY2UtZW50ZXItLXRvcC1jZW50ZXJ7YW5pbWF0aW9uLW5hbWU6VG9hc3RpZnlfX2JvdW5jZUluRG93bn0uVG9hc3RpZnlfX2JvdW5jZS1lbnRlci0tYm90dG9tLWNlbnRlcnthbmltYXRpb24tbmFtZTpUb2FzdGlmeV9fYm91bmNlSW5VcH0uVG9hc3RpZnlfX2JvdW5jZS1leGl0LS10b3AtbGVmdCwuVG9hc3RpZnlfX2JvdW5jZS1leGl0LS1ib3R0b20tbGVmdHthbmltYXRpb24tbmFtZTpUb2FzdGlmeV9fYm91bmNlT3V0TGVmdH0uVG9hc3RpZnlfX2JvdW5jZS1leGl0LS10b3AtcmlnaHQsLlRvYXN0aWZ5X19ib3VuY2UtZXhpdC0tYm90dG9tLXJpZ2h0e2FuaW1hdGlvbi1uYW1lOlRvYXN0aWZ5X19ib3VuY2VPdXRSaWdodH0uVG9hc3RpZnlfX2JvdW5jZS1leGl0LS10b3AtY2VudGVye2FuaW1hdGlvbi1uYW1lOlRvYXN0aWZ5X19ib3VuY2VPdXRVcH0uVG9hc3RpZnlfX2JvdW5jZS1leGl0LS1ib3R0b20tY2VudGVye2FuaW1hdGlvbi1uYW1lOlRvYXN0aWZ5X19ib3VuY2VPdXREb3dufUBrZXlmcmFtZXMgVG9hc3RpZnlfX3pvb21JbnswJXtvcGFjaXR5OjA7dHJhbnNmb3JtOnNjYWxlM2QoLjMsLjMsLjMpfTUwJXtvcGFjaXR5OjF9fUBrZXlmcmFtZXMgVG9hc3RpZnlfX3pvb21PdXR7MCV7b3BhY2l0eToxfTUwJXtvcGFjaXR5OjA7dHJhbnNmb3JtOnRyYW5zbGF0ZTNkKDAsdmFyKC0teSksMCkgc2NhbGUzZCguMywuMywuMyl9dG97b3BhY2l0eTowfX0uVG9hc3RpZnlfX3pvb20tZW50ZXJ7YW5pbWF0aW9uLW5hbWU6VG9hc3RpZnlfX3pvb21Jbn0uVG9hc3RpZnlfX3pvb20tZXhpdHthbmltYXRpb24tbmFtZTpUb2FzdGlmeV9fem9vbU91dH1Aa2V5ZnJhbWVzIFRvYXN0aWZ5X19mbGlwSW57MCV7dHJhbnNmb3JtOnBlcnNwZWN0aXZlKDQwMHB4KSByb3RhdGVYKDkwZGVnKTthbmltYXRpb24tdGltaW5nLWZ1bmN0aW9uOmVhc2UtaW47b3BhY2l0eTowfTQwJXt0cmFuc2Zvcm06cGVyc3BlY3RpdmUoNDAwcHgpIHJvdGF0ZVgoLTIwZGVnKTthbmltYXRpb24tdGltaW5nLWZ1bmN0aW9uOmVhc2UtaW59NjAle3RyYW5zZm9ybTpwZXJzcGVjdGl2ZSg0MDBweCkgcm90YXRlWCgxMGRlZyk7b3BhY2l0eToxfTgwJXt0cmFuc2Zvcm06cGVyc3BlY3RpdmUoNDAwcHgpIHJvdGF0ZVgoLTVkZWcpfXRve3RyYW5zZm9ybTpwZXJzcGVjdGl2ZSg0MDBweCl9fUBrZXlmcmFtZXMgVG9hc3RpZnlfX2ZsaXBPdXR7MCV7dHJhbnNmb3JtOnRyYW5zbGF0ZTNkKDAsdmFyKC0teSksMCkgcGVyc3BlY3RpdmUoNDAwcHgpfTMwJXt0cmFuc2Zvcm06dHJhbnNsYXRlM2QoMCx2YXIoLS15KSwwKSBwZXJzcGVjdGl2ZSg0MDBweCkgcm90YXRlWCgtMjBkZWcpO29wYWNpdHk6MX10b3t0cmFuc2Zvcm06dHJhbnNsYXRlM2QoMCx2YXIoLS15KSwwKSBwZXJzcGVjdGl2ZSg0MDBweCkgcm90YXRlWCg5MGRlZyk7b3BhY2l0eTowfX0uVG9hc3RpZnlfX2ZsaXAtZW50ZXJ7YW5pbWF0aW9uLW5hbWU6VG9hc3RpZnlfX2ZsaXBJbn0uVG9hc3RpZnlfX2ZsaXAtZXhpdHthbmltYXRpb24tbmFtZTpUb2FzdGlmeV9fZmxpcE91dH1Aa2V5ZnJhbWVzIFRvYXN0aWZ5X19zbGlkZUluUmlnaHR7MCV7dHJhbnNmb3JtOnRyYW5zbGF0ZTNkKDExMCUsMCwwKTt2aXNpYmlsaXR5OnZpc2libGV9dG97dHJhbnNmb3JtOnRyYW5zbGF0ZTNkKDAsdmFyKC0teSksMCl9fUBrZXlmcmFtZXMgVG9hc3RpZnlfX3NsaWRlSW5MZWZ0ezAle3RyYW5zZm9ybTp0cmFuc2xhdGUzZCgtMTEwJSwwLDApO3Zpc2liaWxpdHk6dmlzaWJsZX10b3t0cmFuc2Zvcm06dHJhbnNsYXRlM2QoMCx2YXIoLS15KSwwKX19QGtleWZyYW1lcyBUb2FzdGlmeV9fc2xpZGVJblVwezAle3RyYW5zZm9ybTp0cmFuc2xhdGUzZCgwLDExMCUsMCk7dmlzaWJpbGl0eTp2aXNpYmxlfXRve3RyYW5zZm9ybTp0cmFuc2xhdGUzZCgwLHZhcigtLXkpLDApfX1Aa2V5ZnJhbWVzIFRvYXN0aWZ5X19zbGlkZUluRG93bnswJXt0cmFuc2Zvcm06dHJhbnNsYXRlM2QoMCwtMTEwJSwwKTt2aXNpYmlsaXR5OnZpc2libGV9dG97dHJhbnNmb3JtOnRyYW5zbGF0ZTNkKDAsdmFyKC0teSksMCl9fUBrZXlmcmFtZXMgVG9hc3RpZnlfX3NsaWRlT3V0UmlnaHR7MCV7dHJhbnNmb3JtOnRyYW5zbGF0ZTNkKDAsdmFyKC0teSksMCl9dG97dmlzaWJpbGl0eTpoaWRkZW47dHJhbnNmb3JtOnRyYW5zbGF0ZTNkKDExMCUsdmFyKC0teSksMCl9fUBrZXlmcmFtZXMgVG9hc3RpZnlfX3NsaWRlT3V0TGVmdHswJXt0cmFuc2Zvcm06dHJhbnNsYXRlM2QoMCx2YXIoLS15KSwwKX10b3t2aXNpYmlsaXR5OmhpZGRlbjt0cmFuc2Zvcm06dHJhbnNsYXRlM2QoLTExMCUsdmFyKC0teSksMCl9fUBrZXlmcmFtZXMgVG9hc3RpZnlfX3NsaWRlT3V0RG93bnswJXt0cmFuc2Zvcm06dHJhbnNsYXRlM2QoMCx2YXIoLS15KSwwKX10b3t2aXNpYmlsaXR5OmhpZGRlbjt0cmFuc2Zvcm06dHJhbnNsYXRlM2QoMCw1MDBweCwwKX19QGtleWZyYW1lcyBUb2FzdGlmeV9fc2xpZGVPdXRVcHswJXt0cmFuc2Zvcm06dHJhbnNsYXRlM2QoMCx2YXIoLS15KSwwKX10b3t2aXNpYmlsaXR5OmhpZGRlbjt0cmFuc2Zvcm06dHJhbnNsYXRlM2QoMCwtNTAwcHgsMCl9fS5Ub2FzdGlmeV9fc2xpZGUtZW50ZXItLXRvcC1sZWZ0LC5Ub2FzdGlmeV9fc2xpZGUtZW50ZXItLWJvdHRvbS1sZWZ0e2FuaW1hdGlvbi1uYW1lOlRvYXN0aWZ5X19zbGlkZUluTGVmdH0uVG9hc3RpZnlfX3NsaWRlLWVudGVyLS10b3AtcmlnaHQsLlRvYXN0aWZ5X19zbGlkZS1lbnRlci0tYm90dG9tLXJpZ2h0e2FuaW1hdGlvbi1uYW1lOlRvYXN0aWZ5X19zbGlkZUluUmlnaHR9LlRvYXN0aWZ5X19zbGlkZS1lbnRlci0tdG9wLWNlbnRlcnthbmltYXRpb24tbmFtZTpUb2FzdGlmeV9fc2xpZGVJbkRvd259LlRvYXN0aWZ5X19zbGlkZS1lbnRlci0tYm90dG9tLWNlbnRlcnthbmltYXRpb24tbmFtZTpUb2FzdGlmeV9fc2xpZGVJblVwfS5Ub2FzdGlmeV9fc2xpZGUtZXhpdC0tdG9wLWxlZnQsLlRvYXN0aWZ5X19zbGlkZS1leGl0LS1ib3R0b20tbGVmdHthbmltYXRpb24tbmFtZTpUb2FzdGlmeV9fc2xpZGVPdXRMZWZ0O2FuaW1hdGlvbi10aW1pbmctZnVuY3Rpb246ZWFzZS1pbjthbmltYXRpb24tZHVyYXRpb246LjNzfS5Ub2FzdGlmeV9fc2xpZGUtZXhpdC0tdG9wLXJpZ2h0LC5Ub2FzdGlmeV9fc2xpZGUtZXhpdC0tYm90dG9tLXJpZ2h0e2FuaW1hdGlvbi1uYW1lOlRvYXN0aWZ5X19zbGlkZU91dFJpZ2h0O2FuaW1hdGlvbi10aW1pbmctZnVuY3Rpb246ZWFzZS1pbjthbmltYXRpb24tZHVyYXRpb246LjNzfS5Ub2FzdGlmeV9fc2xpZGUtZXhpdC0tdG9wLWNlbnRlcnthbmltYXRpb24tbmFtZTpUb2FzdGlmeV9fc2xpZGVPdXRVcDthbmltYXRpb24tdGltaW5nLWZ1bmN0aW9uOmVhc2UtaW47YW5pbWF0aW9uLWR1cmF0aW9uOi4zc30uVG9hc3RpZnlfX3NsaWRlLWV4aXQtLWJvdHRvbS1jZW50ZXJ7YW5pbWF0aW9uLW5hbWU6VG9hc3RpZnlfX3NsaWRlT3V0RG93bjthbmltYXRpb24tdGltaW5nLWZ1bmN0aW9uOmVhc2UtaW47YW5pbWF0aW9uLWR1cmF0aW9uOi4zc31Aa2V5ZnJhbWVzIFRvYXN0aWZ5X19zcGluezAle3RyYW5zZm9ybTpyb3RhdGUoMCl9dG97dHJhbnNmb3JtOnJvdGF0ZSgzNjBkZWcpfX1cbmApO2ltcG9ydHtpc1ZhbGlkRWxlbWVudCBhcyAkdH1mcm9tXCJyZWFjdFwiO3ZhciBMPXQ9PnR5cGVvZiB0PT1cIm51bWJlclwiJiYhaXNOYU4odCksTj10PT50eXBlb2YgdD09XCJzdHJpbmdcIixQPXQ9PnR5cGVvZiB0PT1cImZ1bmN0aW9uXCIsbXQ9dD0+Tih0KXx8TCh0KSxCPXQ9Pk4odCl8fFAodCk/dDpudWxsLHB0PSh0LG8pPT50PT09ITF8fEwodCkmJnQ+MD90Om8sej10PT4kdCh0KXx8Tih0KXx8UCh0KXx8TCh0KTtpbXBvcnQgdXQse3VzZUVmZmVjdCBhcyBSdCx1c2VMYXlvdXRFZmZlY3QgYXMgQnQsdXNlUmVmIGFzIHp0fWZyb21cInJlYWN0XCI7ZnVuY3Rpb24gWih0LG8sZT0zMDApe2xldHtzY3JvbGxIZWlnaHQ6cixzdHlsZTpzfT10O3JlcXVlc3RBbmltYXRpb25GcmFtZSgoKT0+e3MubWluSGVpZ2h0PVwiaW5pdGlhbFwiLHMuaGVpZ2h0PXIrXCJweFwiLHMudHJhbnNpdGlvbj1gYWxsICR7ZX1tc2AscmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpPT57cy5oZWlnaHQ9XCIwXCIscy5wYWRkaW5nPVwiMFwiLHMubWFyZ2luPVwiMFwiLHNldFRpbWVvdXQobyxlKX0pfSl9ZnVuY3Rpb24gJCh7ZW50ZXI6dCxleGl0Om8sYXBwZW5kUG9zaXRpb246ZT0hMSxjb2xsYXBzZTpyPSEwLGNvbGxhcHNlRHVyYXRpb246cz0zMDB9KXtyZXR1cm4gZnVuY3Rpb24oe2NoaWxkcmVuOmEscG9zaXRpb246ZCxwcmV2ZW50RXhpdFRyYW5zaXRpb246Yyxkb25lOlQsbm9kZVJlZjpnLGlzSW46dixwbGF5VG9hc3Q6eH0pe2xldCBDPWU/YCR7dH0tLSR7ZH1gOnQsUz1lP2Ake299LS0ke2R9YDpvLEU9enQoMCk7cmV0dXJuIEJ0KCgpPT57bGV0IGY9Zy5jdXJyZW50LHA9Qy5zcGxpdChcIiBcIiksYj1uPT57bi50YXJnZXQ9PT1nLmN1cnJlbnQmJih4KCksZi5yZW1vdmVFdmVudExpc3RlbmVyKFwiYW5pbWF0aW9uZW5kXCIsYiksZi5yZW1vdmVFdmVudExpc3RlbmVyKFwiYW5pbWF0aW9uY2FuY2VsXCIsYiksRS5jdXJyZW50PT09MCYmbi50eXBlIT09XCJhbmltYXRpb25jYW5jZWxcIiYmZi5jbGFzc0xpc3QucmVtb3ZlKC4uLnApKX07KCgpPT57Zi5jbGFzc0xpc3QuYWRkKC4uLnApLGYuYWRkRXZlbnRMaXN0ZW5lcihcImFuaW1hdGlvbmVuZFwiLGIpLGYuYWRkRXZlbnRMaXN0ZW5lcihcImFuaW1hdGlvbmNhbmNlbFwiLGIpfSkoKX0sW10pLFJ0KCgpPT57bGV0IGY9Zy5jdXJyZW50LHA9KCk9PntmLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJhbmltYXRpb25lbmRcIixwKSxyP1ooZixULHMpOlQoKX07dnx8KGM/cCgpOigoKT0+e0UuY3VycmVudD0xLGYuY2xhc3NOYW1lKz1gICR7U31gLGYuYWRkRXZlbnRMaXN0ZW5lcihcImFuaW1hdGlvbmVuZFwiLHApfSkoKSl9LFt2XSksdXQuY3JlYXRlRWxlbWVudCh1dC5GcmFnbWVudCxudWxsLGEpfX1pbXBvcnR7Y2xvbmVFbGVtZW50IGFzIEZ0LGlzVmFsaWRFbGVtZW50IGFzIFV0fWZyb21cInJlYWN0XCI7ZnVuY3Rpb24gSih0LG8pe3JldHVybntjb250ZW50OnR0KHQuY29udGVudCx0LnByb3BzKSxjb250YWluZXJJZDp0LnByb3BzLmNvbnRhaW5lcklkLGlkOnQucHJvcHMudG9hc3RJZCx0aGVtZTp0LnByb3BzLnRoZW1lLHR5cGU6dC5wcm9wcy50eXBlLGRhdGE6dC5wcm9wcy5kYXRhfHx7fSxpc0xvYWRpbmc6dC5wcm9wcy5pc0xvYWRpbmcsaWNvbjp0LnByb3BzLmljb24scmVhc29uOnQucmVtb3ZhbFJlYXNvbixzdGF0dXM6b319ZnVuY3Rpb24gdHQodCxvLGU9ITEpe3JldHVybiBVdCh0KSYmIU4odC50eXBlKT9GdCh0LHtjbG9zZVRvYXN0Om8uY2xvc2VUb2FzdCx0b2FzdFByb3BzOm8sZGF0YTpvLmRhdGEsaXNQYXVzZWQ6ZX0pOlAodCk/dCh7Y2xvc2VUb2FzdDpvLmNsb3NlVG9hc3QsdG9hc3RQcm9wczpvLGRhdGE6by5kYXRhLGlzUGF1c2VkOmV9KTp0fWltcG9ydCBvdCBmcm9tXCJyZWFjdFwiO2Z1bmN0aW9uIHl0KHtjbG9zZVRvYXN0OnQsdGhlbWU6byxhcmlhTGFiZWw6ZT1cImNsb3NlXCJ9KXtyZXR1cm4gb3QuY3JlYXRlRWxlbWVudChcImJ1dHRvblwiLHtjbGFzc05hbWU6YFRvYXN0aWZ5X19jbG9zZS1idXR0b24gVG9hc3RpZnlfX2Nsb3NlLWJ1dHRvbi0tJHtvfWAsdHlwZTpcImJ1dHRvblwiLG9uQ2xpY2s6cj0+e3Iuc3RvcFByb3BhZ2F0aW9uKCksdCghMCl9LFwiYXJpYS1sYWJlbFwiOmV9LG90LmNyZWF0ZUVsZW1lbnQoXCJzdmdcIix7XCJhcmlhLWhpZGRlblwiOlwidHJ1ZVwiLHZpZXdCb3g6XCIwIDAgMTQgMTZcIn0sb3QuY3JlYXRlRWxlbWVudChcInBhdGhcIix7ZmlsbFJ1bGU6XCJldmVub2RkXCIsZDpcIk03LjcxIDguMjNsMy43NSAzLjc1LTEuNDggMS40OC0zLjc1LTMuNzUtMy43NSAzLjc1TDEgMTEuOThsMy43NS0zLjc1TDEgNC40OCAyLjQ4IDNsMy43NSAzLjc1TDkuOTggM2wxLjQ4IDEuNDgtMy43NSAzLjc1elwifSkpKX1pbXBvcnQgZXQgZnJvbVwicmVhY3RcIjtpbXBvcnQgVHQgZnJvbVwiY2xzeFwiO2Z1bmN0aW9uIGd0KHtkZWxheTp0LGlzUnVubmluZzpvLGNsb3NlVG9hc3Q6ZSx0eXBlOnI9XCJkZWZhdWx0XCIsaGlkZTpzLGNsYXNzTmFtZTpsLGNvbnRyb2xsZWRQcm9ncmVzczphLHByb2dyZXNzOmQscnRsOmMsaXNJbjpULHRoZW1lOmd9KXtsZXQgdj1zfHxhJiZkPT09MCx4PXthbmltYXRpb25EdXJhdGlvbjpgJHt0fW1zYCxhbmltYXRpb25QbGF5U3RhdGU6bz9cInJ1bm5pbmdcIjpcInBhdXNlZFwifTthJiYoeC50cmFuc2Zvcm09YHNjYWxlWCgke2R9KWApO2xldCBDPVR0KFwiVG9hc3RpZnlfX3Byb2dyZXNzLWJhclwiLGE/XCJUb2FzdGlmeV9fcHJvZ3Jlc3MtYmFyLS1jb250cm9sbGVkXCI6XCJUb2FzdGlmeV9fcHJvZ3Jlc3MtYmFyLS1hbmltYXRlZFwiLGBUb2FzdGlmeV9fcHJvZ3Jlc3MtYmFyLXRoZW1lLS0ke2d9YCxgVG9hc3RpZnlfX3Byb2dyZXNzLWJhci0tJHtyfWAse1tcIlRvYXN0aWZ5X19wcm9ncmVzcy1iYXItLXJ0bFwiXTpjfSksUz1QKGwpP2woe3J0bDpjLHR5cGU6cixkZWZhdWx0Q2xhc3NOYW1lOkN9KTpUdChDLGwpLEU9e1thJiZkPj0xP1wib25UcmFuc2l0aW9uRW5kXCI6XCJvbkFuaW1hdGlvbkVuZFwiXTphJiZkPDE/bnVsbDooKT0+e1QmJmUoKX19O3JldHVybiBldC5jcmVhdGVFbGVtZW50KFwiZGl2XCIse2NsYXNzTmFtZTpcIlRvYXN0aWZ5X19wcm9ncmVzcy1iYXItLXdycFwiLFwiZGF0YS1oaWRkZW5cIjp2fSxldC5jcmVhdGVFbGVtZW50KFwiZGl2XCIse2NsYXNzTmFtZTpgVG9hc3RpZnlfX3Byb2dyZXNzLWJhci0tYmcgVG9hc3RpZnlfX3Byb2dyZXNzLWJhci10aGVtZS0tJHtnfSBUb2FzdGlmeV9fcHJvZ3Jlc3MtYmFyLS0ke3J9YH0pLGV0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIix7cm9sZTpcInByb2dyZXNzYmFyXCIsXCJhcmlhLWhpZGRlblwiOnY/XCJ0cnVlXCI6XCJmYWxzZVwiLFwiYXJpYS1sYWJlbFwiOlwibm90aWZpY2F0aW9uIHRpbWVyXCIsY2xhc3NOYW1lOlMsc3R5bGU6eCwuLi5FfSkpfWltcG9ydCBEdCBmcm9tXCJjbHN4XCI7aW1wb3J0IGN0LHt1c2VFZmZlY3QgYXMgeW8sdXNlUmVmIGFzIFRvLHVzZVN0YXRlIGFzIGdvfWZyb21cInJlYWN0XCI7dmFyIFh0PTEsYXQ9KCk9PmAke1h0Kyt9YDtmdW5jdGlvbiBfdCh0LG8sZSl7bGV0IHI9MSxzPTAsbD1bXSxhPVtdLGQ9byxjPW5ldyBNYXAsVD1uZXcgU2V0LGc9aT0+KFQuYWRkKGkpLCgpPT5ULmRlbGV0ZShpKSksdj0oKT0+e2E9QXJyYXkuZnJvbShjLnZhbHVlcygpKSxULmZvckVhY2goaT0+aSgpKX0seD0oe2NvbnRhaW5lcklkOmksdG9hc3RJZDpuLHVwZGF0ZUlkOnV9KT0+e2xldCBoPWk/aSE9PXQ6dCE9PTEsbT1jLmhhcyhuKSYmdT09bnVsbDtyZXR1cm4gaHx8bX0sQz0oaSxuKT0+e2MuZm9yRWFjaCh1PT57dmFyIGg7KG49PW51bGx8fG49PT11LnByb3BzLnRvYXN0SWQpJiYoKGg9dS50b2dnbGUpPT1udWxsfHxoLmNhbGwodSxpKSl9KX0sUz1pPT57dmFyIG4sdTsodT0obj1pLnByb3BzKT09bnVsbD92b2lkIDA6bi5vbkNsb3NlKT09bnVsbHx8dS5jYWxsKG4saS5yZW1vdmFsUmVhc29uKSxpLmlzQWN0aXZlPSExfSxFPWk9PntpZihpPT1udWxsKWMuZm9yRWFjaChTKTtlbHNle2xldCBuPWMuZ2V0KGkpO24mJlMobil9digpfSxmPSgpPT57cy09bC5sZW5ndGgsbD1bXX0scD1pPT57dmFyIG0sXztsZXR7dG9hc3RJZDpuLHVwZGF0ZUlkOnV9PWkucHJvcHMsaD11PT1udWxsO2kuc3RhbGVJZCYmYy5kZWxldGUoaS5zdGFsZUlkKSxpLmlzQWN0aXZlPSEwLGMuc2V0KG4saSksdigpLGUoSihpLGg/XCJhZGRlZFwiOlwidXBkYXRlZFwiKSksaCYmKChfPShtPWkucHJvcHMpLm9uT3Blbik9PW51bGx8fF8uY2FsbChtKSl9O3JldHVybntpZDp0LHByb3BzOmQsb2JzZXJ2ZTpnLHRvZ2dsZTpDLHJlbW92ZVRvYXN0OkUsdG9hc3RzOmMsY2xlYXJRdWV1ZTpmLGJ1aWxkVG9hc3Q6KGksbik9PntpZih4KG4pKXJldHVybjtsZXR7dG9hc3RJZDp1LHVwZGF0ZUlkOmgsZGF0YTptLHN0YWxlSWQ6XyxkZWxheTprfT1uLE09aD09bnVsbDtNJiZzKys7bGV0IEE9ey4uLmQsc3R5bGU6ZC50b2FzdFN0eWxlLGtleTpyKyssLi4uT2JqZWN0LmZyb21FbnRyaWVzKE9iamVjdC5lbnRyaWVzKG4pLmZpbHRlcigoW0QsWV0pPT5ZIT1udWxsKSksdG9hc3RJZDp1LHVwZGF0ZUlkOmgsZGF0YTptLGlzSW46ITEsY2xhc3NOYW1lOkIobi5jbGFzc05hbWV8fGQudG9hc3RDbGFzc05hbWUpLHByb2dyZXNzQ2xhc3NOYW1lOkIobi5wcm9ncmVzc0NsYXNzTmFtZXx8ZC5wcm9ncmVzc0NsYXNzTmFtZSksYXV0b0Nsb3NlOm4uaXNMb2FkaW5nPyExOnB0KG4uYXV0b0Nsb3NlLGQuYXV0b0Nsb3NlKSxjbG9zZVRvYXN0KEQpe2MuZ2V0KHUpLnJlbW92YWxSZWFzb249RCxFKHUpfSxkZWxldGVUb2FzdCgpe2xldCBEPWMuZ2V0KHUpO2lmKEQhPW51bGwpe2lmKGUoSihELFwicmVtb3ZlZFwiKSksYy5kZWxldGUodSkscy0tLHM8MCYmKHM9MCksbC5sZW5ndGg+MCl7cChsLnNoaWZ0KCkpO3JldHVybn12KCl9fX07QS5jbG9zZUJ1dHRvbj1kLmNsb3NlQnV0dG9uLG4uY2xvc2VCdXR0b249PT0hMXx8eihuLmNsb3NlQnV0dG9uKT9BLmNsb3NlQnV0dG9uPW4uY2xvc2VCdXR0b246bi5jbG9zZUJ1dHRvbj09PSEwJiYoQS5jbG9zZUJ1dHRvbj16KGQuY2xvc2VCdXR0b24pP2QuY2xvc2VCdXR0b246ITApO2xldCBSPXtjb250ZW50OmkscHJvcHM6QSxzdGFsZUlkOl99O2QubGltaXQmJmQubGltaXQ+MCYmcz5kLmxpbWl0JiZNP2wucHVzaChSKTpMKGspP3NldFRpbWVvdXQoKCk9PntwKFIpfSxrKTpwKFIpfSxzZXRQcm9wcyhpKXtkPWl9LHNldFRvZ2dsZTooaSxuKT0+e2xldCB1PWMuZ2V0KGkpO3UmJih1LnRvZ2dsZT1uKX0saXNUb2FzdEFjdGl2ZTppPT57dmFyIG47cmV0dXJuKG49Yy5nZXQoaSkpPT1udWxsP3ZvaWQgMDpuLmlzQWN0aXZlfSxnZXRTbmFwc2hvdDooKT0+YX19dmFyIEk9bmV3IE1hcCxGPVtdLHN0PW5ldyBTZXQsVnQ9dD0+c3QuZm9yRWFjaChvPT5vKHQpKSxidD0oKT0+SS5zaXplPjA7ZnVuY3Rpb24gUXQoKXtGLmZvckVhY2godD0+bnQodC5jb250ZW50LHQub3B0aW9ucykpLEY9W119dmFyIHZ0PSh0LHtjb250YWluZXJJZDpvfSk9Pnt2YXIgZTtyZXR1cm4oZT1JLmdldChvfHwxKSk9PW51bGw/dm9pZCAwOmUudG9hc3RzLmdldCh0KX07ZnVuY3Rpb24gWCh0LG8pe3ZhciByO2lmKG8pcmV0dXJuISEoKHI9SS5nZXQobykpIT1udWxsJiZyLmlzVG9hc3RBY3RpdmUodCkpO2xldCBlPSExO3JldHVybiBJLmZvckVhY2gocz0+e3MuaXNUb2FzdEFjdGl2ZSh0KSYmKGU9ITApfSksZX1mdW5jdGlvbiBodCh0KXtpZighYnQoKSl7Rj1GLmZpbHRlcihvPT50IT1udWxsJiZvLm9wdGlvbnMudG9hc3RJZCE9PXQpO3JldHVybn1pZih0PT1udWxsfHxtdCh0KSlJLmZvckVhY2gobz0+e28ucmVtb3ZlVG9hc3QodCl9KTtlbHNlIGlmKHQmJihcImNvbnRhaW5lcklkXCJpbiB0fHxcImlkXCJpbiB0KSl7bGV0IG89SS5nZXQodC5jb250YWluZXJJZCk7bz9vLnJlbW92ZVRvYXN0KHQuaWQpOkkuZm9yRWFjaChlPT57ZS5yZW1vdmVUb2FzdCh0LmlkKX0pfX12YXIgQ3Q9KHQ9e30pPT57SS5mb3JFYWNoKG89PntvLnByb3BzLmxpbWl0JiYoIXQuY29udGFpbmVySWR8fG8uaWQ9PT10LmNvbnRhaW5lcklkKSYmby5jbGVhclF1ZXVlKCl9KX07ZnVuY3Rpb24gbnQodCxvKXt6KHQpJiYoYnQoKXx8Ri5wdXNoKHtjb250ZW50OnQsb3B0aW9uczpvfSksSS5mb3JFYWNoKGU9PntlLmJ1aWxkVG9hc3QodCxvKX0pKX1mdW5jdGlvbiB4dCh0KXt2YXIgbzsobz1JLmdldCh0LmNvbnRhaW5lcklkfHwxKSk9PW51bGx8fG8uc2V0VG9nZ2xlKHQuaWQsdC5mbil9ZnVuY3Rpb24gcnQodCxvKXtJLmZvckVhY2goZT0+eyhvPT1udWxsfHwhKG8hPW51bGwmJm8uY29udGFpbmVySWQpfHwobz09bnVsbD92b2lkIDA6by5jb250YWluZXJJZCk9PT1lLmlkKSYmZS50b2dnbGUodCxvPT1udWxsP3ZvaWQgMDpvLmlkKX0pfWZ1bmN0aW9uIEV0KHQpe2xldCBvPXQuY29udGFpbmVySWR8fDE7cmV0dXJue3N1YnNjcmliZShlKXtsZXQgcj1fdChvLHQsVnQpO0kuc2V0KG8scik7bGV0IHM9ci5vYnNlcnZlKGUpO3JldHVybiBRdCgpLCgpPT57cygpLEkuZGVsZXRlKG8pfX0sc2V0UHJvcHMoZSl7dmFyIHI7KHI9SS5nZXQobykpPT1udWxsfHxyLnNldFByb3BzKGUpfSxnZXRTbmFwc2hvdCgpe3ZhciBlO3JldHVybihlPUkuZ2V0KG8pKT09bnVsbD92b2lkIDA6ZS5nZXRTbmFwc2hvdCgpfX19ZnVuY3Rpb24gUHQodCl7cmV0dXJuIHN0LmFkZCh0KSwoKT0+e3N0LmRlbGV0ZSh0KX19ZnVuY3Rpb24gV3QodCl7cmV0dXJuIHQmJihOKHQudG9hc3RJZCl8fEwodC50b2FzdElkKSk/dC50b2FzdElkOmF0KCl9ZnVuY3Rpb24gVSh0LG8pe3JldHVybiBudCh0LG8pLG8udG9hc3RJZH1mdW5jdGlvbiBWKHQsbyl7cmV0dXJuey4uLm8sdHlwZTpvJiZvLnR5cGV8fHQsdG9hc3RJZDpXdChvKX19ZnVuY3Rpb24gUSh0KXtyZXR1cm4obyxlKT0+VShvLFYodCxlKSl9ZnVuY3Rpb24geSh0LG8pe3JldHVybiBVKHQsVihcImRlZmF1bHRcIixvKSl9eS5sb2FkaW5nPSh0LG8pPT5VKHQsVihcImRlZmF1bHRcIix7aXNMb2FkaW5nOiEwLGF1dG9DbG9zZTohMSxjbG9zZU9uQ2xpY2s6ITEsY2xvc2VCdXR0b246ITEsZHJhZ2dhYmxlOiExLC4uLm99KSk7ZnVuY3Rpb24gR3QodCx7cGVuZGluZzpvLGVycm9yOmUsc3VjY2VzczpyfSxzKXtsZXQgbDtvJiYobD1OKG8pP3kubG9hZGluZyhvLHMpOnkubG9hZGluZyhvLnJlbmRlcix7Li4ucywuLi5vfSkpO2xldCBhPXtpc0xvYWRpbmc6bnVsbCxhdXRvQ2xvc2U6bnVsbCxjbG9zZU9uQ2xpY2s6bnVsbCxjbG9zZUJ1dHRvbjpudWxsLGRyYWdnYWJsZTpudWxsfSxkPShULGcsdik9PntpZihnPT1udWxsKXt5LmRpc21pc3MobCk7cmV0dXJufWxldCB4PXt0eXBlOlQsLi4uYSwuLi5zLGRhdGE6dn0sQz1OKGcpP3tyZW5kZXI6Z306ZztyZXR1cm4gbD95LnVwZGF0ZShsLHsuLi54LC4uLkN9KTp5KEMucmVuZGVyLHsuLi54LC4uLkN9KSx2fSxjPVAodCk/dCgpOnQ7cmV0dXJuIGMudGhlbihUPT5kKFwic3VjY2Vzc1wiLHIsVCkpLmNhdGNoKFQ9PmQoXCJlcnJvclwiLGUsVCkpLGN9eS5wcm9taXNlPUd0O3kuc3VjY2Vzcz1RKFwic3VjY2Vzc1wiKTt5LmluZm89UShcImluZm9cIik7eS5lcnJvcj1RKFwiZXJyb3JcIik7eS53YXJuaW5nPVEoXCJ3YXJuaW5nXCIpO3kud2Fybj15Lndhcm5pbmc7eS5kYXJrPSh0LG8pPT5VKHQsVihcImRlZmF1bHRcIix7dGhlbWU6XCJkYXJrXCIsLi4ub30pKTtmdW5jdGlvbiBxdCh0KXtodCh0KX15LmRpc21pc3M9cXQ7eS5jbGVhcldhaXRpbmdRdWV1ZT1DdDt5LmlzQWN0aXZlPVg7eS51cGRhdGU9KHQsbz17fSk9PntsZXQgZT12dCh0LG8pO2lmKGUpe2xldHtwcm9wczpyLGNvbnRlbnQ6c309ZSxsPXtkZWxheToxMDAsLi4uciwuLi5vLHRvYXN0SWQ6by50b2FzdElkfHx0LHVwZGF0ZUlkOmF0KCl9O2wudG9hc3RJZCE9PXQmJihsLnN0YWxlSWQ9dCk7bGV0IGE9bC5yZW5kZXJ8fHM7ZGVsZXRlIGwucmVuZGVyLFUoYSxsKX19O3kuZG9uZT10PT57eS51cGRhdGUodCx7cHJvZ3Jlc3M6MX0pfTt5Lm9uQ2hhbmdlPVB0O3kucGxheT10PT5ydCghMCx0KTt5LnBhdXNlPXQ9PnJ0KCExLHQpO2ltcG9ydHt1c2VSZWYgYXMgS3QsdXNlU3luY0V4dGVybmFsU3RvcmUgYXMgWXR9ZnJvbVwicmVhY3RcIjtmdW5jdGlvbiBJdCh0KXt2YXIgYTtsZXR7c3Vic2NyaWJlOm8sZ2V0U25hcHNob3Q6ZSxzZXRQcm9wczpyfT1LdChFdCh0KSkuY3VycmVudDtyKHQpO2xldCBzPShhPVl0KG8sZSxlKSk9PW51bGw/dm9pZCAwOmEuc2xpY2UoKTtmdW5jdGlvbiBsKGQpe2lmKCFzKXJldHVybltdO2xldCBjPW5ldyBNYXA7cmV0dXJuIHQubmV3ZXN0T25Ub3AmJnMucmV2ZXJzZSgpLHMuZm9yRWFjaChUPT57bGV0e3Bvc2l0aW9uOmd9PVQucHJvcHM7Yy5oYXMoZyl8fGMuc2V0KGcsW10pLGMuZ2V0KGcpLnB1c2goVCl9KSxBcnJheS5mcm9tKGMsVD0+ZChUWzBdLFRbMV0pKX1yZXR1cm57Z2V0VG9hc3RUb1JlbmRlcjpsLGlzVG9hc3RBY3RpdmU6WCxjb3VudDpzPT1udWxsP3ZvaWQgMDpzLmxlbmd0aH19aW1wb3J0e3VzZUVmZmVjdCBhcyBadCx1c2VSZWYgYXMgU3QsdXNlU3RhdGUgYXMga3R9ZnJvbVwicmVhY3RcIjtmdW5jdGlvbiBBdCh0KXtsZXRbbyxlXT1rdCghMSksW3Isc109a3QoITEpLGw9U3QobnVsbCksYT1TdCh7c3RhcnQ6MCxkZWx0YTowLHJlbW92YWxEaXN0YW5jZTowLGNhbkNsb3NlT25DbGljazohMCxjYW5EcmFnOiExLGRpZE1vdmU6ITF9KS5jdXJyZW50LHthdXRvQ2xvc2U6ZCxwYXVzZU9uSG92ZXI6YyxjbG9zZVRvYXN0OlQsb25DbGljazpnLGNsb3NlT25DbGljazp2fT10O3h0KHtpZDp0LnRvYXN0SWQsY29udGFpbmVySWQ6dC5jb250YWluZXJJZCxmbjplfSksWnQoKCk9PntpZih0LnBhdXNlT25Gb2N1c0xvc3MpcmV0dXJuIHgoKSwoKT0+e0MoKX19LFt0LnBhdXNlT25Gb2N1c0xvc3NdKTtmdW5jdGlvbiB4KCl7ZG9jdW1lbnQuaGFzRm9jdXMoKXx8cCgpLHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwiZm9jdXNcIixmKSx3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcImJsdXJcIixwKX1mdW5jdGlvbiBDKCl7d2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJmb2N1c1wiLGYpLHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKFwiYmx1clwiLHApfWZ1bmN0aW9uIFMobSl7aWYodC5kcmFnZ2FibGU9PT0hMHx8dC5kcmFnZ2FibGU9PT1tLnBvaW50ZXJUeXBlKXtiKCk7bGV0IF89bC5jdXJyZW50O2EuY2FuQ2xvc2VPbkNsaWNrPSEwLGEuY2FuRHJhZz0hMCxfLnN0eWxlLnRyYW5zaXRpb249XCJub25lXCIsdC5kcmFnZ2FibGVEaXJlY3Rpb249PT1cInhcIj8oYS5zdGFydD1tLmNsaWVudFgsYS5yZW1vdmFsRGlzdGFuY2U9Xy5vZmZzZXRXaWR0aCoodC5kcmFnZ2FibGVQZXJjZW50LzEwMCkpOihhLnN0YXJ0PW0uY2xpZW50WSxhLnJlbW92YWxEaXN0YW5jZT1fLm9mZnNldEhlaWdodCoodC5kcmFnZ2FibGVQZXJjZW50PT09ODA/dC5kcmFnZ2FibGVQZXJjZW50KjEuNTp0LmRyYWdnYWJsZVBlcmNlbnQpLzEwMCl9fWZ1bmN0aW9uIEUobSl7bGV0e3RvcDpfLGJvdHRvbTprLGxlZnQ6TSxyaWdodDpBfT1sLmN1cnJlbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7bS5uYXRpdmVFdmVudC50eXBlIT09XCJ0b3VjaGVuZFwiJiZ0LnBhdXNlT25Ib3ZlciYmbS5jbGllbnRYPj1NJiZtLmNsaWVudFg8PUEmJm0uY2xpZW50WT49XyYmbS5jbGllbnRZPD1rP3AoKTpmKCl9ZnVuY3Rpb24gZigpe2UoITApfWZ1bmN0aW9uIHAoKXtlKCExKX1mdW5jdGlvbiBiKCl7YS5kaWRNb3ZlPSExLGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJwb2ludGVybW92ZVwiLG4pLGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJwb2ludGVydXBcIix1KX1mdW5jdGlvbiBpKCl7ZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInBvaW50ZXJtb3ZlXCIsbiksZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInBvaW50ZXJ1cFwiLHUpfWZ1bmN0aW9uIG4obSl7bGV0IF89bC5jdXJyZW50O2lmKGEuY2FuRHJhZyYmXyl7YS5kaWRNb3ZlPSEwLG8mJnAoKSx0LmRyYWdnYWJsZURpcmVjdGlvbj09PVwieFwiP2EuZGVsdGE9bS5jbGllbnRYLWEuc3RhcnQ6YS5kZWx0YT1tLmNsaWVudFktYS5zdGFydCxhLnN0YXJ0IT09bS5jbGllbnRYJiYoYS5jYW5DbG9zZU9uQ2xpY2s9ITEpO2xldCBrPXQuZHJhZ2dhYmxlRGlyZWN0aW9uPT09XCJ4XCI/YCR7YS5kZWx0YX1weCwgdmFyKC0teSlgOmAwLCBjYWxjKCR7YS5kZWx0YX1weCArIHZhcigtLXkpKWA7Xy5zdHlsZS50cmFuc2Zvcm09YHRyYW5zbGF0ZTNkKCR7a30sMClgLF8uc3R5bGUub3BhY2l0eT1gJHsxLU1hdGguYWJzKGEuZGVsdGEvYS5yZW1vdmFsRGlzdGFuY2UpfWB9fWZ1bmN0aW9uIHUoKXtpKCk7bGV0IG09bC5jdXJyZW50O2lmKGEuY2FuRHJhZyYmYS5kaWRNb3ZlJiZtKXtpZihhLmNhbkRyYWc9ITEsTWF0aC5hYnMoYS5kZWx0YSk+YS5yZW1vdmFsRGlzdGFuY2Upe3MoITApLHQuY2xvc2VUb2FzdCghMCksdC5jb2xsYXBzZUFsbCgpO3JldHVybn1tLnN0eWxlLnRyYW5zaXRpb249XCJ0cmFuc2Zvcm0gMC4ycywgb3BhY2l0eSAwLjJzXCIsbS5zdHlsZS5yZW1vdmVQcm9wZXJ0eShcInRyYW5zZm9ybVwiKSxtLnN0eWxlLnJlbW92ZVByb3BlcnR5KFwib3BhY2l0eVwiKX19bGV0IGg9e29uUG9pbnRlckRvd246UyxvblBvaW50ZXJVcDpFfTtyZXR1cm4gZCYmYyYmKGgub25Nb3VzZUVudGVyPXAsdC5zdGFja2VkfHwoaC5vbk1vdXNlTGVhdmU9ZikpLHYmJihoLm9uQ2xpY2s9bT0+e2cmJmcobSksYS5jYW5DbG9zZU9uQ2xpY2smJlQoITApfSkse3BsYXlUb2FzdDpmLHBhdXNlVG9hc3Q6cCxpc1J1bm5pbmc6byxwcmV2ZW50RXhpdFRyYW5zaXRpb246cix0b2FzdFJlZjpsLGV2ZW50SGFuZGxlcnM6aH19aW1wb3J0e3VzZUVmZmVjdCBhcyBKdCx1c2VMYXlvdXRFZmZlY3QgYXMgdG99ZnJvbVwicmVhY3RcIjt2YXIgT3Q9dHlwZW9mIHdpbmRvdyE9XCJ1bmRlZmluZWRcIj90bzpKdDtpbXBvcnQgaXQgZnJvbVwiY2xzeFwiO2ltcG9ydCBxLHtjbG9uZUVsZW1lbnQgYXMgY28saXNWYWxpZEVsZW1lbnQgYXMgZm99ZnJvbVwicmVhY3RcIjtpbXBvcnQgTyx7Y2xvbmVFbGVtZW50IGFzIG9vLGlzVmFsaWRFbGVtZW50IGFzIGVvfWZyb21cInJlYWN0XCI7dmFyIEc9KHt0aGVtZTp0LHR5cGU6byxpc0xvYWRpbmc6ZSwuLi5yfSk9Pk8uY3JlYXRlRWxlbWVudChcInN2Z1wiLHt2aWV3Qm94OlwiMCAwIDI0IDI0XCIsd2lkdGg6XCIxMDAlXCIsaGVpZ2h0OlwiMTAwJVwiLGZpbGw6dD09PVwiY29sb3JlZFwiP1wiY3VycmVudENvbG9yXCI6YHZhcigtLXRvYXN0aWZ5LWljb24tY29sb3ItJHtvfSlgLC4uLnJ9KTtmdW5jdGlvbiBhbyh0KXtyZXR1cm4gTy5jcmVhdGVFbGVtZW50KEcsey4uLnR9LE8uY3JlYXRlRWxlbWVudChcInBhdGhcIix7ZDpcIk0yMy4zMiAxNy4xOTFMMTUuNDM4IDIuMTg0QzE0LjcyOC44MzMgMTMuNDE2IDAgMTEuOTk2IDBjLTEuNDIgMC0yLjczMy44MzMtMy40NDMgMi4xODRMLjUzMyAxNy40NDhhNC43NDQgNC43NDQgMCAwMDAgNC4zNjhDMS4yNDMgMjMuMTY3IDIuNTU1IDI0IDMuOTc1IDI0aDE2LjA1QzIyLjIyIDI0IDI0IDIyLjA0NCAyNCAxOS42MzJjMC0uOTA0LS4yNTEtMS43NDYtLjY4LTIuNDR6bS05LjYyMiAxLjQ2YzAgMS4wMzMtLjcyNCAxLjgyMy0xLjY5OCAxLjgyM3MtMS42OTgtLjc5LTEuNjk4LTEuODIydi0uMDQzYzAtMS4wMjguNzI0LTEuODIyIDEuNjk4LTEuODIyczEuNjk4Ljc5IDEuNjk4IDEuODIydi4wNDN6bS4wMzktMTIuMjg1bC0uODQgOC4wNmMtLjA1Ny41ODEtLjQwOC45NDMtLjg5Ny45NDMtLjQ5IDAtLjg0LS4zNjctLjg5Ni0uOTQybC0uODQtOC4wNjVjLS4wNTctLjYyNC4yNS0xLjA5NS43NzktMS4wOTVoMS45MWMuNTI4LjAwNS44NC40NzYuNzg0IDEuMXpcIn0pKX1mdW5jdGlvbiBzbyh0KXtyZXR1cm4gTy5jcmVhdGVFbGVtZW50KEcsey4uLnR9LE8uY3JlYXRlRWxlbWVudChcInBhdGhcIix7ZDpcIk0xMiAwYTEyIDEyIDAgMTAxMiAxMkExMi4wMTMgMTIuMDEzIDAgMDAxMiAwem0uMjUgNWExLjUgMS41IDAgMTEtMS41IDEuNSAxLjUgMS41IDAgMDExLjUtMS41em0yLjI1IDEzLjVoLTRhMSAxIDAgMDEwLTJoLjc1YS4yNS4yNSAwIDAwLjI1LS4yNXYtNC41YS4yNS4yNSAwIDAwLS4yNS0uMjVoLS43NWExIDEgMCAwMTAtMmgxYTIgMiAwIDAxMiAydjQuNzVhLjI1LjI1IDAgMDAuMjUuMjVoLjc1YTEgMSAwIDExMCAyelwifSkpfWZ1bmN0aW9uIG5vKHQpe3JldHVybiBPLmNyZWF0ZUVsZW1lbnQoRyx7Li4udH0sTy5jcmVhdGVFbGVtZW50KFwicGF0aFwiLHtkOlwiTTEyIDBhMTIgMTIgMCAxMDEyIDEyQTEyLjAxNCAxMi4wMTQgMCAwMDEyIDB6bTYuOTI3IDguMmwtNi44NDUgOS4yODlhMS4wMTEgMS4wMTEgMCAwMS0xLjQzLjE4OGwtNC44ODgtMy45MDhhMSAxIDAgMTExLjI1LTEuNTYybDQuMDc2IDMuMjYxIDYuMjI3LTguNDUxYTEgMSAwIDExMS42MSAxLjE4M3pcIn0pKX1mdW5jdGlvbiBybyh0KXtyZXR1cm4gTy5jcmVhdGVFbGVtZW50KEcsey4uLnR9LE8uY3JlYXRlRWxlbWVudChcInBhdGhcIix7ZDpcIk0xMS45ODMgMGExMi4yMDYgMTIuMjA2IDAgMDAtOC41MSAzLjY1M0ExMS44IDExLjggMCAwMDAgMTIuMjA3IDExLjc3OSAxMS43NzkgMCAwMDExLjggMjRoLjIxNEExMi4xMTEgMTIuMTExIDAgMDAyNCAxMS43OTEgMTEuNzY2IDExLjc2NiAwIDAwMTEuOTgzIDB6TTEwLjUgMTYuNTQyYTEuNDc2IDEuNDc2IDAgMDExLjQ0OS0xLjUzaC4wMjdhMS41MjcgMS41MjcgMCAwMTEuNTIzIDEuNDcgMS40NzUgMS40NzUgMCAwMS0xLjQ0OSAxLjUzaC0uMDI3YTEuNTI5IDEuNTI5IDAgMDEtMS41MjMtMS40N3pNMTEgMTIuNXYtNmExIDEgMCAwMTIgMHY2YTEgMSAwIDExLTIgMHpcIn0pKX1mdW5jdGlvbiBpbygpe3JldHVybiBPLmNyZWF0ZUVsZW1lbnQoXCJkaXZcIix7Y2xhc3NOYW1lOlwiVG9hc3RpZnlfX3NwaW5uZXJcIn0pfXZhciBXPXtpbmZvOnNvLHdhcm5pbmc6YW8sc3VjY2VzczpubyxlcnJvcjpybyxzcGlubmVyOmlvfSxsbz10PT50IGluIFc7ZnVuY3Rpb24gTnQoe3RoZW1lOnQsdHlwZTpvLGlzTG9hZGluZzplLGljb246cn0pe2xldCBzPW51bGwsbD17dGhlbWU6dCx0eXBlOm99O3JldHVybiByPT09ITF8fChQKHIpP3M9cih7Li4ubCxpc0xvYWRpbmc6ZX0pOmVvKHIpP3M9b28ocixsKTplP3M9Vy5zcGlubmVyKCk6bG8obykmJihzPVdbb10obCkpKSxzfXZhciB3dD10PT57bGV0e2lzUnVubmluZzpvLHByZXZlbnRFeGl0VHJhbnNpdGlvbjplLHRvYXN0UmVmOnIsZXZlbnRIYW5kbGVyczpzLHBsYXlUb2FzdDpsfT1BdCh0KSx7Y2xvc2VCdXR0b246YSxjaGlsZHJlbjpkLGF1dG9DbG9zZTpjLG9uQ2xpY2s6VCx0eXBlOmcsaGlkZVByb2dyZXNzQmFyOnYsY2xvc2VUb2FzdDp4LHRyYW5zaXRpb246Qyxwb3NpdGlvbjpTLGNsYXNzTmFtZTpFLHN0eWxlOmYscHJvZ3Jlc3NDbGFzc05hbWU6cCx1cGRhdGVJZDpiLHJvbGU6aSxwcm9ncmVzczpuLHJ0bDp1LHRvYXN0SWQ6aCxkZWxldGVUb2FzdDptLGlzSW46Xyxpc0xvYWRpbmc6ayxjbG9zZU9uQ2xpY2s6TSx0aGVtZTpBLGFyaWFMYWJlbDpSfT10LEQ9aXQoXCJUb2FzdGlmeV9fdG9hc3RcIixgVG9hc3RpZnlfX3RvYXN0LXRoZW1lLS0ke0F9YCxgVG9hc3RpZnlfX3RvYXN0LS0ke2d9YCx7W1wiVG9hc3RpZnlfX3RvYXN0LS1ydGxcIl06dX0se1tcIlRvYXN0aWZ5X190b2FzdC0tY2xvc2Utb24tY2xpY2tcIl06TX0pLFk9UChFKT9FKHtydGw6dSxwb3NpdGlvbjpTLHR5cGU6ZyxkZWZhdWx0Q2xhc3NOYW1lOkR9KTppdChELEUpLGZ0PU50KHQpLGR0PSEhbnx8IWMsaj17Y2xvc2VUb2FzdDp4LHR5cGU6Zyx0aGVtZTpBfSxIPW51bGw7cmV0dXJuIGE9PT0hMXx8KFAoYSk/SD1hKGopOmZvKGEpP0g9Y28oYSxqKTpIPXl0KGopKSxxLmNyZWF0ZUVsZW1lbnQoQyx7aXNJbjpfLGRvbmU6bSxwb3NpdGlvbjpTLHByZXZlbnRFeGl0VHJhbnNpdGlvbjplLG5vZGVSZWY6cixwbGF5VG9hc3Q6bH0scS5jcmVhdGVFbGVtZW50KFwiZGl2XCIse2lkOmgsdGFiSW5kZXg6MCxvbkNsaWNrOlQsXCJkYXRhLWluXCI6XyxjbGFzc05hbWU6WSwuLi5zLHN0eWxlOmYscmVmOnIsLi4uXyYme3JvbGU6aSxcImFyaWEtbGFiZWxcIjpSfX0sZnQhPW51bGwmJnEuY3JlYXRlRWxlbWVudChcImRpdlwiLHtjbGFzc05hbWU6aXQoXCJUb2FzdGlmeV9fdG9hc3QtaWNvblwiLHtbXCJUb2FzdGlmeS0tYW5pbWF0ZS1pY29uIFRvYXN0aWZ5X196b29tLWVudGVyXCJdOiFrfSl9LGZ0KSx0dChkLHQsIW8pLEgsIXQuY3VzdG9tUHJvZ3Jlc3NCYXImJnEuY3JlYXRlRWxlbWVudChndCx7Li4uYiYmIWR0P3trZXk6YHAtJHtifWB9Ont9LHJ0bDp1LHRoZW1lOkEsZGVsYXk6Yyxpc1J1bm5pbmc6byxpc0luOl8sY2xvc2VUb2FzdDp4LGhpZGU6dix0eXBlOmcsY2xhc3NOYW1lOnAsY29udHJvbGxlZFByb2dyZXNzOmR0LHByb2dyZXNzOm58fDB9KSkpfTt2YXIgSz0odCxvPSExKT0+KHtlbnRlcjpgVG9hc3RpZnktLWFuaW1hdGUgVG9hc3RpZnlfXyR7dH0tZW50ZXJgLGV4aXQ6YFRvYXN0aWZ5LS1hbmltYXRlIFRvYXN0aWZ5X18ke3R9LWV4aXRgLGFwcGVuZFBvc2l0aW9uOm99KSxsdD0kKEsoXCJib3VuY2VcIiwhMCkpLG1vPSQoSyhcInNsaWRlXCIsITApKSxwbz0kKEsoXCJ6b29tXCIpKSx1bz0kKEsoXCJmbGlwXCIpKTt2YXIgX289e3Bvc2l0aW9uOlwidG9wLXJpZ2h0XCIsdHJhbnNpdGlvbjpsdCxhdXRvQ2xvc2U6NWUzLGNsb3NlQnV0dG9uOiEwLHBhdXNlT25Ib3ZlcjohMCxwYXVzZU9uRm9jdXNMb3NzOiEwLGRyYWdnYWJsZTpcInRvdWNoXCIsZHJhZ2dhYmxlUGVyY2VudDo4MCxkcmFnZ2FibGVEaXJlY3Rpb246XCJ4XCIscm9sZTpcImFsZXJ0XCIsdGhlbWU6XCJsaWdodFwiLFwiYXJpYS1sYWJlbFwiOlwiTm90aWZpY2F0aW9ucyBBbHQrVFwiLGhvdEtleXM6dD0+dC5hbHRLZXkmJnQuY29kZT09PVwiS2V5VFwifTtmdW5jdGlvbiBMdCh0KXtsZXQgbz17Li4uX28sLi4udH0sZT10LnN0YWNrZWQsW3Isc109Z28oITApLGw9VG8obnVsbCkse2dldFRvYXN0VG9SZW5kZXI6YSxpc1RvYXN0QWN0aXZlOmQsY291bnQ6Y309SXQobykse2NsYXNzTmFtZTpULHN0eWxlOmcscnRsOnYsY29udGFpbmVySWQ6eCxob3RLZXlzOkN9PW87ZnVuY3Rpb24gUyhmKXtsZXQgcD1EdChcIlRvYXN0aWZ5X190b2FzdC1jb250YWluZXJcIixgVG9hc3RpZnlfX3RvYXN0LWNvbnRhaW5lci0tJHtmfWAse1tcIlRvYXN0aWZ5X190b2FzdC1jb250YWluZXItLXJ0bFwiXTp2fSk7cmV0dXJuIFAoVCk/VCh7cG9zaXRpb246ZixydGw6dixkZWZhdWx0Q2xhc3NOYW1lOnB9KTpEdChwLEIoVCkpfWZ1bmN0aW9uIEUoKXtlJiYocyghMCkseS5wbGF5KCkpfXJldHVybiBPdCgoKT0+e3ZhciBmO2lmKGUpe2xldCBwPWwuY3VycmVudC5xdWVyeVNlbGVjdG9yQWxsKCdbZGF0YS1pbj1cInRydWVcIl0nKSxiPTEyLGk9KGY9by5wb3NpdGlvbik9PW51bGw/dm9pZCAwOmYuaW5jbHVkZXMoXCJ0b3BcIiksbj0wLHU9MDtBcnJheS5mcm9tKHApLnJldmVyc2UoKS5mb3JFYWNoKChoLG0pPT57bGV0IF89aDtfLmNsYXNzTGlzdC5hZGQoXCJUb2FzdGlmeV9fdG9hc3QtLXN0YWNrZWRcIiksbT4wJiYoXy5kYXRhc2V0LmNvbGxhcHNlZD1gJHtyfWApLF8uZGF0YXNldC5wb3N8fChfLmRhdGFzZXQucG9zPWk/XCJ0b3BcIjpcImJvdFwiKTtsZXQgaz1uKihyPy4yOjEpKyhyPzA6YiptKTtfLnN0eWxlLnNldFByb3BlcnR5KFwiLS15XCIsYCR7aT9rOmsqLTF9cHhgKSxfLnN0eWxlLnNldFByb3BlcnR5KFwiLS1nXCIsYCR7Yn1gKSxfLnN0eWxlLnNldFByb3BlcnR5KFwiLS1zXCIsYCR7MS0ocj91OjApfWApLG4rPV8ub2Zmc2V0SGVpZ2h0LHUrPS4wMjV9KX19LFtyLGMsZV0pLHlvKCgpPT57ZnVuY3Rpb24gZihwKXt2YXIgaTtsZXQgYj1sLmN1cnJlbnQ7QyhwKSYmKChpPWIucXVlcnlTZWxlY3RvcignW3RhYkluZGV4PVwiMFwiXScpKT09bnVsbHx8aS5mb2N1cygpLHMoITEpLHkucGF1c2UoKSkscC5rZXk9PT1cIkVzY2FwZVwiJiYoZG9jdW1lbnQuYWN0aXZlRWxlbWVudD09PWJ8fGIhPW51bGwmJmIuY29udGFpbnMoZG9jdW1lbnQuYWN0aXZlRWxlbWVudCkpJiYocyghMCkseS5wbGF5KCkpfXJldHVybiBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKFwia2V5ZG93blwiLGYpLCgpPT57ZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImtleWRvd25cIixmKX19LFtDXSksY3QuY3JlYXRlRWxlbWVudChcInNlY3Rpb25cIix7cmVmOmwsY2xhc3NOYW1lOlwiVG9hc3RpZnlcIixpZDp4LG9uTW91c2VFbnRlcjooKT0+e2UmJihzKCExKSx5LnBhdXNlKCkpfSxvbk1vdXNlTGVhdmU6RSxcImFyaWEtbGl2ZVwiOlwicG9saXRlXCIsXCJhcmlhLWF0b21pY1wiOlwiZmFsc2VcIixcImFyaWEtcmVsZXZhbnRcIjpcImFkZGl0aW9ucyB0ZXh0XCIsXCJhcmlhLWxhYmVsXCI6b1tcImFyaWEtbGFiZWxcIl19LGEoKGYscCk9PntsZXQgYj1wLmxlbmd0aD97Li4uZ306ey4uLmcscG9pbnRlckV2ZW50czpcIm5vbmVcIn07cmV0dXJuIGN0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIix7dGFiSW5kZXg6LTEsY2xhc3NOYW1lOlMoZiksXCJkYXRhLXN0YWNrZWRcIjplLHN0eWxlOmIsa2V5OmBjLSR7Zn1gfSxwLm1hcCgoe2NvbnRlbnQ6aSxwcm9wczpufSk9PmN0LmNyZWF0ZUVsZW1lbnQod3Qsey4uLm4sc3RhY2tlZDplLGNvbGxhcHNlQWxsOkUsaXNJbjpkKG4udG9hc3RJZCxuLmNvbnRhaW5lcklkKSxrZXk6YHQtJHtuLmtleX1gfSxpKSkpfSkpfWV4cG9ydHtsdCBhcyBCb3VuY2UsdW8gYXMgRmxpcCxXIGFzIEljb25zLG1vIGFzIFNsaWRlLEx0IGFzIFRvYXN0Q29udGFpbmVyLHBvIGFzIFpvb20sWiBhcyBjb2xsYXBzZVRvYXN0LCQgYXMgY3NzVHJhbnNpdGlvbix5IGFzIHRvYXN0fTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4Lm1qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/react-toastify/dist/index.mjs\n"));

/***/ }),

/***/ "./node_modules/woff2-encoder/dist/decompress.js":
/*!*******************************************************!*\
  !*** ./node_modules/woff2-encoder/dist/decompress.js ***!
  \*******************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ B; }\n/* harmony export */ });\nvar A,I=(A=\"file:///build/woff2-decompress-wasm.js\",function(I={}){I.ready=new Promise((A,I)=>{C=A,g=I});var C,g,B,Q,G,Z,l,Y,b,c,W,d,E,m,h,N,R,i,a,V,k,F,y,X,u=Object.assign({},I),o=\"\";\"undefined\"!=typeof document&&document.currentScript&&(o=document.currentScript.src),A&&(o=A),o=0!==o.indexOf(\"blob:\")?o.substr(0,o.replace(/[?#].*/,\"\").lastIndexOf(\"/\")+1):\"\",I.print||console.log.bind(console);var J=I.printErr||console.error.bind(console);Object.assign(I,u),u=null,I.arguments&&I.arguments,I.thisProgram&&I.thisProgram,I.quit&&I.quit,I.wasmBinary&&(Q=I.wasmBinary),I.noExitRuntime,\"object\"!=typeof WebAssembly&&L(\"no native wasm support detected\");var w=!1;function v(){var A=G.buffer;I.HEAP8=Z=new Int8Array(A),I.HEAP16=Y=new Int16Array(A),I.HEAPU8=l=new Uint8Array(A),I.HEAPU16=b=new Uint16Array(A),I.HEAP32=c=new Int32Array(A),I.HEAPU32=W=new Uint32Array(A),I.HEAPF32=d=new Float32Array(A),I.HEAPF64=E=new Float64Array(A)}var D=[],p=[],n=[],H=0,s=null,t=null;function L(A){I.onAbort&&I.onAbort(A),J(A=\"Aborted(\"+A+\")\"),w=!0,A+=\". Build with -sASSERTIONS for more info.\";var C=new WebAssembly.RuntimeError(A);throw g(C),C}var S=\"data:application/octet-stream;base64,\";function z(A){return A.startsWith(S)}z(m=\"data:application/octet-stream;base64,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IgAgACgCACACR0ECdGogATYCACABIAI2AgAgAiABNgIIIAEoAggiAygCACECCyABQQE6AAwgA0EAOgAMIAMgAigCBCIANgIAIAAEQCAAIAM2AggLIAIgAygCCDYCCCADKAIIIgAgACgCACADR0ECdGogAjYCACACIAM2AgQgAyACNgIIDwsCQCAERQ0AIAQtAAwNAAwBCwJAIAEgAigCAEcEQCACIQEMAQsgAiABKAIEIgA2AgAgASAABH8gACACNgIIIAIoAggFIAMLNgIIIAIoAggiACAAKAIAIAJHQQJ0aiABNgIAIAEgAjYCBCACIAE2AgggASgCCCEDCyABQQE6AAwgA0EAOgAMIAMgAygCBCIAKAIAIgE2AgQgAQRAIAEgAzYCCAsgACADKAIINgIIIAMoAggiASABKAIAIANHQQJ0aiAANgIAIAAgAzYCACADIAA2AggMAgsgBEEMaiEFIAJBAToADCADIAAgA0Y6AAwgBUEBOgAAIAMiASAARw0ACwsLNAAgAC0AC0EHdgRAIAAgATYCBA8LIAAgAC0AC0GAAXEgAXI6AAsgACAALQALQf8AcToACwsIAEGfCRA8AAtgAQF/IAAoAiAgBEECdCIFIAJBH2pBBHZB/v///wBxQaCYCGovAQBBAWpsIAAoAhgRAgAhACABIAQ7AQwgASADOwEKIAEgAjsBCCABIAA2AgAgASAAIAVqNgIEIABBAEcL0AEBBX8CQCAAKAIEIgFBIEcEQCABQQhrIQIgACgCCCEBDAELIAAoAgwiAUUEQEEADwsgACAAKAIAQQh2IgI2AgAgACgCCCIDLQAAIQQgACABQQFrNgIMIABBGDYCBCAAIANBAWoiATYCCCAAIARBGHQgAnI2AgBBECECCwJAIAFBAXFFDQAgACgCDCIDRQ0AIAAgACgCAEEIdiIENgIAIAEtAAAhBSAAIANBAWs2AgwgACACNgIEIAAgAUEBajYCCCAAIAVBGHQgBHI2AgALQQELBAAgAAsdACABBEAgACABKAIAECsgACABKAIEECsgARARCwuxMgEQfyMAQSBrIgUkAANAIAFBIGshCQNAIAAhBANAAkACQAJAAkACQAJAAkACQCABIARrIgBBBXUiBw4GBwcAAQQCAwsgAUEgayIAKAIAIAQoAgBPDQYgBSAEKQIYNwMYIAUgBCkCEDcD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AhggBCAAKQIQNwIQIAQgACkCCDcCCCAEIAApAgA3AgAgACAFKQMYNwIYIAAgBSkDEDcCECAAIAUpAwg3AgggACAFKQMANwIAIApBBGohCgwBCyAJKAIAIQACQCAGKAIAIgcgBCgCAE8EQEEAIQogACAHTw0CIAUgBikCGDcDGCAFIAYpAhA3AxAgBSAGKQIINwMIIAUgBikCADcDACAGIAkpAhg3AhggBiAJKQIQNwIQIAYgCSkCCDcCCCAGIAkpAgA3AgAgCSAFKQMYNwIYIAkgBSkDEDcCECAJIAUpAwg3AgggCSAFKQMANwIAQQEhCiAGKAIAIAQoAgBPDQIgBSAEKQIYNwMYIAUgBCkCEDcDECAFIAQpAgg3AwggBSAEKQIANwMAIAQgBikCGDcCGCAEIAYpAhA3AhAgBCAGKQIINwIIIAQgBikCADcCACAGIAUpAxg3AhggBiAFKQMQNwIQIAYgBSkDCDcCCCAGIAUpAwA3AgAMAQsgACAHSQRAIAUgBCkCGDcDGCAFIAQpAhA3AxAgBSAEKQIINwMIIAUgBCkCADcDACAEIAkpAhg3AhggBCAJKQIQNwIQIAQgCSkCCDcCCCAEIAkpAgA3AgAgCSAFKQMYNwIYIAkgBSkDEDcCECAJIAUpAwg3AgggCSAFKQMANwIAQQEhCgwCCyAFIAQpAhg3AxggBSAEKQIQNwMQIAUgBCkCCDcDCCAFIAQpAgA3AwAgBCAGKQIYNwIYIAQgBikCEDcCECAEIAYpAgg3AgggBCAGKQIANwIAIAYgBSkDGDcCGCAGIAUpAxA3AhAgBiAFKQMINwIIIAYgBSkDADcCAEEBIQogCSgCACAGKAIATw0BIAUgBikCGDcDGCAFIAYpAhA3AxAgBSAGKQIINwMIIAUgBikCADcDACAGIAkpAhg3AhggBiAJKQIQNwIQIAYgCSkCCDcCCCAGIAkpAgA3AgAgCSAFKQMYNwIYIAkgBSkDEDcCECAJIAUpAwg3AgggCSAFKQMANwIAC0ECIQoLIANBAWshAyAJIQAgBCgCACIIIAYoAgAiB08EQANAIABBIGsiACAERgRAIARBIGohByAIIAkoAgBJDQUgByAJRg0GA0AgBygCACAISwRAIAUgBykCGDcDGCAFIAcpAhA3AxAgBSAHKQIINwMIIAUgBykCADcDACAHIAkpAhg3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BCADQQhrKAIAIQMgAkIANwIgIAJCADcCKCACQgA3AjAgAkIANwA3IAJCADcCGCACQQA2AhQgAkGYnwg2AhAgAiAANgIMIAIgATYCCCAAIANqIQBBACEDAkAgBCABQQAQFgRAIAJBATYCOCAEIAJBCGogACAAQQFBACAEKAIAKAIUEQoAIABBACACKAIgQQFGGyEDDAELIAQgAkEIaiAAQQFBACAEKAIAKAIYEQkAAkACQCACKAIsDgIAAQILIAIoAhxBACACKAIoQQFGG0EAIAIoAiRBAUYbQQAgAigCMEEBRhshAwwBCyACKAIgQQFHBEAgAigCMA0BIAIoAiRBAUcNASACKAIoQQFHDQELIAIoAhghAwsgAkFAayQAIAMLDgAgAEHQAGoQHUHQAGoLAgALFgAgAhASIQEgACACNgIEIAAgATYCAAv9AgEFfyMAQRBrIggkACACIAFBf3NB7////wdqTQRAAn8gAC0AC0EHdgRAIAAoAgAMAQsgAAshCiAIQQRqIgkgACABQef///8DSQR/IAggAUEBdDYCDCAIIAEgAmo2AgQjAEEQayICJAAgCSgCACAIQQxqIgsoAgBJIQwgAkEQaiQAIAsgCSAMGygCACICQQtPBH8gAkEQakFwcSICIAJBAWsiAiACQQtGGwVBCgtBAWoFQe////8HCxA5IAgoAgQhAiAIKAIIGiAEBEAgAiAKIAQQGwsgBgRAIAIgBGogByAGEBsLIAMgBCAFaiIJayEHIAMgCUcEQCACIARqIAZqIAQgCmogBWogBxAbCyABQQpHBEAgChARCyAAIAI2AgAgACAAKAIIQYCAgIB4cSAIKAIIQf////8HcXI2AgggACAAKAIIQYCAgIB4cjYCCCAAIAQgBmogB2oiADYCBCAIQQA6AAwgACACaiAILQAMOgAAIAhBEGokAA8LECcACy4BAX8jAEEQayIDJAAgACACECYgA0EAOgAPIAEgAmogAy0ADzoAACADQRBqJAALYQEDf0EIEDciAUHsowg2AgAgAUHcpAg2AgAgABA9IgJBDWoQEiIDQQA2AgggAyACNgIEIAMgAjYCACABIANBDGogACACQQFqEBM2AgQgAUGMpQg2AgAgAUGspQhBAxAFAAt6AQN/AkACQCAAIgFBA3FFDQAgAS0AAEUEQEEADwsDQCABQQFqIgFBA3FF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IAIgACkCODcDGCACIAApAjA3AxAgAiAAKQIoNwMIIAIgACkCIDcDACAAIAEpAhg3AjggACABKQIQNwIwIAAgASkCCDcCKCAAIAEpAgA3AiAgASACKQMYNwIYIAEgAikDEDcCECABIAIpAwg3AgggASACKQMANwIAIAAoAiAgACgCAE8NBCACIAApAhg3AxggAiAAKQIQNwMQIAIgACkCCDcDCCACIAApAgA3AwAgACAAKQI4NwIYIAAgACkCMDcCECAAIAApAig3AgggACAAKQIgNwIAIAAgAikDGDcCOCAAIAIpAxA3AjAgACACKQMINwIoIAAgAikDADcCIAwECyADIARJBEAgAiAAKQIYNwMYIAIgACkCEDcDECACIAApAgg3AwggAiAAKQIANwMAIAAgASkCGDcCGCAAIAEpAhA3AhAgACABKQIINwIIIAAgASkCADcCACABIAIpAxg3AhggASACKQMQNwIQIAEgAikDCDcCCCABIAIpAwA3AgAMBAsgAiAAKQIYNwMYIAIgACkCEDcDECACIAApAgg3AwggAiAAKQIANwMAIAAgACkCODcCGCAAIAApAjA3AhAgACAAKQIoNwIIIAAgACkCIDcCACAAIAIpAxg3AjggACACKQMQNwIwIAAgAikDCDcCKCAAIAIpAwA3AiAgASgCACAAKAIgTw0DIAIgACkCODcDGCACIAApAjA3AxAgAiAAKQIoNwMIIAIgACkCIDcDACAAIAEpAhg3AjggACABKQIQNwIwIAAgASkCCDcCKCAAIAEpAgA3AiAgASACKQMYNwIYIAEgAikDEDcCECABIAIpAwg3AgggASACKQMANwIADAMLIAAgAEEgaiAAQUBrIAFBIGsQHxoMAgsgACAAQSBqIABBQGsiAyAAQeAAahAfGiABQSBrIgEoAgAgACgCYE8NASACIAApAng3AxggAiAAKQJwNwMQIAIgACkCaDcDCCACIAApAmA3AwAgACABKQIYNwJ4IAAgASkCEDcCcCAAIAEpAgg3AmggACABKQIANwJgIAEgAikDGDcCGCABIAIpAxA3AhAgASACKQMINwIIIAEgAikDADcCACAAKAJgIAMoAgBPDQEgAiADKQIYNwMYIAIgAykCEDcDECACIAMpAgg3AwggAiADKQIANwMAIAMgACkCeDcCGCADIAApAnA3AhAgAyAAKQJoNwIIIAMgACkCYDcCACAAIAIpAxg3AnggACACKQMQNwJwIAAgAikDCDcCaCAAIAIpAwA3AmAgAygCACAAKAIgTw0BIAIgACkCODcDGCACIAApAjA3AxAgAiAAKQIoNwMIIAIgACkCIDcDACAAIAMpAhg3AjggACADKQIQNwIwIAAgAykCCDcCKCAAIAMpAgA3AiAgAyACKQMYNwIYIAMgAikDEDcCECADIAIpAwg3AgggAyACKQMANwIAIAAoAiAgACgCAE8NASACIAApAhg3AxggAiAAKQIQNwMQIAIgACkCCDcDCCACIAApAgA3AwAgACAAKQI4NwIYIAAgACkCMDcCECAAIAApAig3AgggACAAKQIgNwIAIAAgAikDGDcCOCAAIAIpAxA3AjAgACACKQMINwIoIAAgAikDADcCIAwBCyAAQUBrIQMgACgCQCEEAkAgACgCICIGIAAoAgAiB08EQCAEIAZPDQEgAiAAKQI4NwMYIAIgACkCMDcDECACIAApAig3AwggAiAAKQIgNwMAIAAgAykCGDcCOCAAIAMpAhA3AjAgACADKQIINwIoIAAgAykCADcCICADIAIpAxg3AhggAyACKQMQNwIQIAMgAikDCDcCCCADIAIpAwA3AgAgACgCICAHTw0BIAIgACkCGDcDGCACIAApAhA3AxAgAiAAKQIINwMIIAIgACkCADcDACAAIAApAjg3AhggACAAKQIwNwIQIAAgACkCKDcCCCAAIAApAiA3AgAgACACKQMYNwI4IAAgAikDEDcCMCAAIAIpAwg3AiggACACKQMANwIgDAELIAQgBkkEQCACIAApAhg3AxggAiAAKQIQNwMQIAIgACkCCDcDCCACIAApAgA3AwAgACADKQIYNwIYIAAgAykCEDcCECAAIAMpAgg3AgggACADKQIANwIAIAMgAikDGDcCGCADIAIpAxA3AhAgAyACKQMINwIIIAMgAikDADcCAAwBCyACIAApAhg3AxggAiAAKQIQNwMQIAIgACkCCDcDCCACIAApAgA3AwAgACAAKQI4NwIYIAAgACkCMDcCECAAIAApAig3AgggACAAKQIgNwIAIAAgAikDGDcCOCAAIAIpAxA3AjAgACACKQMINwIoIAAgAikDADcCICAEIAAoAiBPDQAgAiAAKQI4NwMYIAIgACkCMDcD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IAEtADRFDQEMAwsgAUEENgIsCyABIAI2AhQgASABKAIoQQFqNgIoIAEoAiRBAUcNASABKAIYQQJHDQEgAUEBOgA2DwsgACgCCCIAIAEgAiADIAQgACgCACgCGBEJAAsLMQAgACABKAIIQQAQFgRAIAEgAiADEDUPCyAAKAIIIgAgASACIAMgACgCACgCHBEHAAsYACAAIAEoAghBABAWBEAgASACIAMQNQsLmwEBAn8jAEFAaiIDJAACf0EBIAAgAUEAEBYNABpBACABRQ0AGkEAIAFByJ8IEDYiAUUNABogA0EMakE0EBQaIANBATYCOCADQX82AhQgAyAANgIQIAMgATYCCCABIANBCGogAigCAEEBIAEoAgAoAhwRBwAgAygCICIAQQFGBEAgAiADKAIYNgIACyAAQQFGCyEEIANBQGskACAECwoAIAAgAUEAEBYLJAEBf0HcpwgoAgAiAARAA0AgACgCABEFACAAKAIEIgANAAsLCyQBAn8gACgCBCIAED1BAWoiARAdIgIEfyACIAAgARATBUEACwsGACABEB0LBgAgARARC64BAQR/IwBBEGsiAiQAIAEoAgAiA0Hw////B0kEQAJAIANBCk0EQCACIAM6AAsgAiEEDAELIANBD3JBAWoiBRASIQQgAiAFQYCAgIB4cjYCCCACIAQ2AgAgAiADNgIECyAEIAFBBGogAxATIANqQQA6AAAgAkEMaiACIAARAQAgAigCDBALIAIoAgwiABAKIAIsAAtBAEgEQCACKAIAEBELIAJBEGokACAADwsQJwALBwAgACgCDAv5CQENfyAAKAIIIgQgAk8gBCACayADT3EiEARAAkAgAiAAKAIEIgQoAgQgBC0ACyIKIgUgBcBBAEgbIgVGBEAjAEEQayIJJAACQCADIApBB3YEfyAEKAIIQf////8HcUEBawVBCgsiBQJ/IAQtAAtBB3YEQCAEKAIEDAELIAQtAAtB/wBxCyIHa00EQCADRQ0BAn8gBC0AC0EHdgRAIAQoAgAMAQsgBAsiBSAHaiABIAMQGyAEIAMgB2oiARAmIAlBADoADyABIAVqIAktAA86AAAMAQsgBCAFIAMgBWsgB2ogByAHQQAgAyABEDoLIAlBEGokACACIANqIQ4MAQsgBSACIANqIg5JBEAjAEEQayIIJAAgDiAFayIJBEAgCSAE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Z25lZCBpbnQAZmxvYXQAdWludDY0X3QAZGVjb21wcmVzcwB2ZWN0b3IAdW5zaWduZWQgY2hhcgBzdGQ6OmV4Y2VwdGlvbgBib29sAGVtc2NyaXB0ZW46OnZhbABiYWRfYXJyYXlfbmV3X2xlbmd0aAB1bnNpZ25lZCBsb25nAHN0ZDo6d3N0cmluZwBiYXNpY19zdHJpbmcAc3RkOjpzdHJpbmcAc3RkOjp1MTZzdHJpbmcAc3RkOjp1MzJzdHJpbmcAZG91YmxlAHZvaWQAc3RkOjpiYWRfYWxsb2MAZW1zY3JpcHRlbjo6bWVtb3J5X3ZpZXc8c2hvcnQ+AGVtc2NyaXB0ZW46Om1lbW9yeV92aWV3PHVuc2lnbmVkIHNob3J0PgBlbXNjcmlwdGVuOjptZW1vcnlfdmlldzxpbnQ+AGVtc2NyaXB0ZW46Om1lbW9yeV92aWV3PHVuc2lnbmVkIGludD4AZW1zY3JpcHRlbjo6bWVtb3J5X3ZpZXc8ZmxvYXQ+AGVtc2NyaXB0ZW46Om1lbW9yeV92aWV3PHVpbnQ4X3Q+AGVtc2NyaXB0ZW46Om1lbW9yeV92aWV3PGludDhfdD4AZW1zY3JpcHRlbjo6bWVtb3J5X3ZpZXc8dWludDE2X3Q+AGVtc2NyaXB0ZW46Om1lbW9yeV92aWV3PGludDE2X3Q+AGVtc2NyaXB0ZW46Om1lbW9yeV92aWV3PHVpbnQ2NF90PgBlbXNjcmlwdGVuOjptZW1vcnlfdmlldzxpbnQ2NF90PgBlbXNjcmlwdGVuOjptZW1vcnlfdmlldzx1aW50MzJfdD4AZW1zY3JpcHRlbjo6bWVtb3J5X3ZpZXc8aW50MzJfdD4AZW1zY3JpcHRlbjo6bWVtb3J5X3ZpZXc8Y2hhcj4AZW1zY3JpcHRlbjo6bWVtb3J5X3ZpZXc8dW5zaWduZWQgY2hhcj4Ac3RkOjpiYXNpY19zdHJpbmc8dW5zaWduZWQgY2hhcj4AZW1zY3JpcHRlbjo6bWVtb3J5X3ZpZXc8c2lnbmVkIGNoYXI+AGVtc2NyaXB0ZW46Om1lbW9yeV92aWV3PGxvbmc+AGVtc2NyaXB0ZW46Om1lbW9yeV92aWV3PHVuc2lnbmVkIGxvbmc+AGVtc2NyaXB0ZW46Om1lbW9yeV92aWV3PGRvdWJsZT4AsAcA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AwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBgYGBgYGBgYGBgYGBgYGBwAAAAAAAAIAAAAAAQAAAwAAAAACAAAEAAAAAAMAAAUAAAAAAwAABgAAAAADAAAHAAAAAAMAAAgAAAAAAwAACQAAAAAAAQACAAAAAAEBAAMAAAAAAgEABAAAAAADAQAFAAAAAAMBAAYAAAAAAwEABwAAAAADAQAIAAAAAAMBAAkAAAAAAAIAAgAAAAABAgADAAAAAAICAAQAAAAAAwIABQAAAAADAgAGAAAAAAMCAAcAAAAAAwIACAAAAAADAgAJAAAAAAADAAIAAAAAAQMAAwAAAAACAwAEAAAAAAMDAAUAAAAAAwMABgAAAAADAwAHAAAAAAMDAAgAAAAAAwMACQAAAAAABAACAAAAAAEEAAMAAAAAAgQABAAAAAADBAAFAAAAAAMEAAYAAAAAAwQABwAAAAADBAAIAAAAAAMEAAkAAAAAAAUAAgAAAAABBQADAAAAAAIFAAQAAAAAAwUABQAAAAADBQAGAAAAAAMFAAcAAAAAAwUACAAAAAADBQAJAAEAAAAGAAIAAQAAAQYAAwABAAACBgAEAAEAAAMGAAUAAQAAAwYABgABAAADBgAHAAEAAAMGAAgAAQAAAwYACQABAAAACAACAAEAAAEIAAMAAQAAAggABAABAAADCAAFAAEAAAMIAAYAAQAAAwgABwABAAADCAAIAAEAAAMIAAkAAAEAAwAACgAAAQADAAAMAAACAAMAAA4AAAIAAwAAEgAAAwADAAAWAAADAAMAAB4AAAQAAwAAJgAABAADAAA2AAABAAMBAAoAAAEAAwEADAAAAgADAQAOAAACAAMBABIAAAMAAwEAFgAAAwADAQAeAAAEAAMBACYAAAQAAwEANgAAAQADAgAKAAABAAMCAAwAAAIAAwIADgAAAgADAgASAAADAAMCABYAAAMAAwIAHgAABAADAgAmAAAEAAMCADYAAAEAAwMACgAAAQADAwAMAAACAAMDAA4AAAIAAwMAEgAAAwADAwAWAAADAAMDAB4AAAQAAwMAJgAABAADAwA2AAABAAMEAAoAAAEAAwQADAAAAgADBAAOAAACAAMEABIAAAMAAwQAFgAAAwADBAAeAAAEAAMEACYAAAQAAwQANgAAAQADBQAKAAABAAMFAAwAAAIAAwUADgAAAgADBQASAAADAAMFABYAAAMAAwUAHgAABAADBQAmAAAEAAMFADYAAQEAAwYACgABAQADBgAMAAECAAMGAA4AAQIAAwYAEgABAwADBgAWAAEDAAMGAB4AAQQAAwYAJgABBAADBgA2AAEBAAMIAAoAAQEAAwgADAABAgADCAAOAAECAAMIABIAAQMAAwgAFgABAwADCAAeAAEEAAMIACYAAQQAAwgANgAAAP8AAAACAAAA/wEAAAMAAAD/AgAABAAAAP8DAAAFAAAA/wMAAAYAAAD/AwAABwAAAP8DAAAIAAAA/wMAAAkAAAD/AAEAAgAAAP8BAQADAAAA/wIBAAQAAAD/AwEABQAAAP8DAQAGAAAA/wMBAAcAAAD/AwEACAAAAP8DAQAJAAAA/wACAAIAAAD/AQIAAwAAAP8CAgAEAAAA/wMCAAUAAAD/AwIABgAAAP8DAgAHAAAA/wMCAAgAAAD/AwIACQAAAP8AAwACAAAA/wEDAAMAAAD/AgMABAAAAP8DAwAFAAAA/wMDAAYAAAD/AwMABwAAAP8DAwAIAAAA/wMDAAkAAAD/AAQAAgAAAP8BBAADAAAA/wIEAAQAAAD/AwQABQAAAP8DBAAGAAAA/wMEAAcAAAD/AwQACAAAAP8DBAAJAAAA/wAFAAIAAAD/AQUAAwAAAP8CBQAEAAAA/wMFAAUAAAD/AwUABgAAAP8DBQAHAAAA/wMFAAgAAAD/AwUACQABAP8ABgACAAEA/wEGAAMAAQD/AgYABAABAP8DBgAFAAEA/wMGAAYAAQD/AwYABwABAP8DBgAIAAEA/wMGAAkAAQD/AAgAAgABAP8BCAADAAEA/wIIAAQAAQD/AwgABQABAP8DCAAGAAEA/wMIAAcAAQD/AwgACAABAP8DCAAJAAAB/wMAAAoAAAH/AwAADAAAAv8DAAAOAAAC/wMAABIAAAP/AwAAFgAAA/8DAAAeAAAE/wMAACYAAAT/AwAANgAAAf8DAQAKAAAB/wMB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c2VkbWFkZWhhbmRoZXJld2hhdG5hbWVMaW5rYmxvZ3NpemViYXNlaGVsZG1ha2VtYWludXNlcicpICtob2xkZW5kc3dpdGhOZXdzcmVhZHdlcmVzaWdudGFrZWhhdmVnYW1lc2VlbmNhbGxwYXRod2VsbHBsdXNtZW51ZmlsbXBhcnRqb2ludGhpc2xpc3Rnb29kbmVlZHdheXN3ZXN0am9ic21pbmRhbHNvbG9nb3JpY2h1c2VzbGFzdHRlYW1hcm15Zm9vZGtpbmd3aWxsZWFzdHdhcmRiZXN0ZmlyZVBhZ2Vrbm93YXdheS5wbmdtb3ZldGhhbmxvYWRnaXZlc2VsZm5vdGVtdWNoZmVlZG1hbnlyb2NraWNvbm9uY2Vsb29raGlkZWRpZWRIb21lcnVsZWhvc3RhamF4aW5mb2NsdWJsYXdzbGVzc2hhbGZzb21lc3VjaHpvbmUxMDAlb25lc2NhcmVUaW1lcmFjZWJsdWVmb3Vyd2Vla2ZhY2Vob3BlZ2F2ZWhhcmRsb3N0d2hlbnBhcmtrZXB0cGFzc3NoaXByb29tSFRNTHBsYW5UeXBlZG9uZXNhdmVrZWVwZmxhZ2xpbmtzb2xkZml2ZXRvb2tyYXRldG93bmp1bXB0aHVzZGFya2NhcmRmaWxlZmVhcnN0YXlraWxsdGhhdGZhbGxhdXRvZXZlci5jb210YWxrc2hvcHZvdGVkZWVwbW9kZXJlc3R0dXJuYm9ybmJhbmRmZWxscm9zZXVybChza2lucm9sZWNvbWVhY3RzYWdlc21lZXRnb2xkLmpwZ2l0ZW12YXJ5ZmVsdHRoZW5zZW5kZHJvcFZpZXdjb3B5MS4wIjwvYT5zdG9wZWxzZWxpZXN0b3VycGFjay5naWZwYXN0Y3NzP2dyYXltZWFuJmd0O3JpZGVzaG90bGF0ZXNhaWRyb2FkdmFyIGZlZWxqb2hucmlja3BvcnRmYXN0J1VBLWRlYWQ8L2I+cG9vcmJpbGx0eXBlVS5TLndvb2RtdXN0MnB4O0luZm9yYW5rd2lkZXdhbnR3YWxsbGVhZFswXTtwYXVsd2F2ZXN1cmUkKCcjd2FpdG1hc3Nhcm1zZ29lc2dhaW5sYW5ncGFpZCEtLSBsb2NrdW5pdHJvb3R3YWxrZmlybXdpZmV4bWwic29uZ3Rlc3QyMHB4a2luZHJvd3N0b29sZm9udG1haWxzYWZlc3Rhcm1hcHNjb3JlcmFpbmZsb3diYWJ5c3BhbnNheXM0cHg7NnB4O2FydHNmb290cmVhbHdpa2loZWF0c3RlcHRyaXBvcmcvbGFrZXdlYWt0b2xkRm9ybWNhc3RmYW5zYmFua3ZlcnlydW5zanVseXRhc2sxcHg7Z29hbGdyZXdzbG93ZWRnZWlkPSJzZXRzNXB4Oy5qcz80MHB4aWYgKHNvb25zZWF0bm9uZXR1YmV6ZXJvc2VudHJlZWRmYWN0aW50b2dpZnRoYXJtMThweGNhbWVoaWxsYm9sZHpvb212b2lkZWFzeXJpbmdmaWxscGVha2luaXRjb3N0M3B4O2phY2t0YWdzYml0c3JvbGxlZGl0a25ld25lYXI8IS0tZ3Jvd0pTT05kdXR5TmFtZXNhbGV5b3UgbG90c3BhaW5qYXp6Y29sZGV5ZXNmaXNod3d3LnJpc2t0YWJzcHJldjEwcHhyaXNlMjVweEJsdWVkaW5nMzAwLGJhbGxmb3JkZWFybndpbGRib3guZmFpcmxhY2t2ZXJzcGFpcmp1bmV0ZWNoaWYoIXBpY2tldmlsJCgiI3dhcm1sb3JkZG9lc3B1bGwsMDAwaWRlYWRyYXdodWdlc3BvdGZ1bmRidXJuaHJlZmNlbGxrZXlzdGlja2hvdXJsb3NzZnVlbDEycHhzdWl0ZGVhbFJTUyJhZ2VkZ3JleUdFVCJlYXNlYWltc2dpcmxhaWRzOHB4O25hdnlncmlkdGlwcyM5OTl3YXJzbGFkeWNhcnMpOyB9cGhwP2hlbGx0YWxsd2hvbXpoOuUqLw0KIDEwMGhhbGwuCgpBN3B4O3B1c2hjaGF0MHB4O2NyZXcqLzwvaGFzaDc1cHhmbGF0cmFyZSAmJiB0ZWxsY2FtcG9udG9sYWlkbWlzc3NraXB0ZW50ZmluZW1hbGVnZXRzcGxvdDQwMCwNCg0KY29vbGZlZXQucGhwPGJyPmVyaWNtb3N0Z3VpZGJlbGxkZXNjaGFpcm1hdGhhdG9tL2ltZyYjODJsdWNrY2VudDAwMDt0aW55Z29uZWh0bWxzZWxsZHJ1Z0ZSRUVub2Rlbmljaz9pZD1sb3NlbnVsbHZhc3R3aW5kUlNTIHdlYXJyZWx5YmVlbnNhbWVkdWtlbmFzYWNhcGV3aXNoZ3VsZlQyMzpoaXRzc2xvdGdhdGVraWNrYmx1cnRoZXkxNXB4JycpOyk7Ij5tc2lld2luc2JpcmRzb3J0YmV0YXNlZWtUMTg6b3Jkc3RyZWVtYWxsNjBweGZhcm3igJlzYm95c1swXS4nKTsiUE9TVGJlYXJraWRzKTt9fW1hcnl0ZW5kKFVLKXF1YWR6aDrmLXNpei0tLS1wcm9wJyk7DWxpZnRUMTk6dmljZWFuZHlkZWJ0PlJTU3Bvb2xuZWNrYmxvd1QxNjpkb29yZXZhbFQxNzpsZXRzZmFpbG9yYWxwb2xsbm92YWNvbHNnZW5lIOKAlHNvZnRyb21ldGlsbHJvc3M8aDM+cG91cmZhZGVwaW5rPHRyPm1pbmkpfCEobWluZXpoOuhiYXJzaGVhcjAwKTttaWxrIC0tPmlyb25mcmVkZGlza3dlbnRzb2lscHV0cy9qcy9ob2x5VDIyOklTQk5UMjA6YWRhbXNlZXM8aDI+anNvbicsICdjb250VDIxOiBSU1Nsb29wYXNpYW1vb248L3A+c291bExJTkVmb3J0Y2FydFQxNDo8aDE+ODBweCEtLTw5cHg7VDA0Om1pa2U6NDZabmljZWluY2hZb3JrcmljZXpoOuQnKSk7cHVyZW1hZ2VwYXJhdG9uZWJvbmQ6MzdaX29mXyddKTswMDAsemg653Rhbmt5YXJkYm93bGJ1c2g6NTZaSmF2YTMwcHgKfH0KJUMzJTozNFpqZWZmRVhQSWNhc2h2aXNhZ29sZnNub3d6aDrpcXVlci5jc3NzaWNrbWVhdG1pbi5iaW5kZGVsbGhpcmVwaWNzcmVudDozNlpIVFRQLTIwMWZvdG93b2xmRU5EIHhib3g6NTRaQk9EWWRpY2s7Cn0KZXhpdDozNVp2YXJzYmVhdCd9KTtkaWV0OTk5O2FubmV9fTwvW2ldLkxhbmdrbcKyd2lyZXRveXNhZGRzc2VhbGFsZXg7Cgl9ZWNob25pbmUub3JnMDA1KXRvbnlqZXdzc2FuZGxlZ3Nyb29mMDAwKSAyMDB3aW5lZ2VhcmRvZ3Nib290Z2FyeWN1dHN0eWxldGVtcHRpb24ueG1sY29ja2dhbmckKCcuNTBweFBoLkRtaXNjYWxhbmxvYW5kZXNrbWlsZXJ5YW51bml4ZGlzYyk7fQpkdXN0Y2xpcCkuCgo3MHB4LTIwMERWRHM3XT48dGFwZWRlbW9pKyspd2FnZWV1cm9waGlsb3B0c2hvbGVGQVFzYXNpbi0yNlRsYWJzcGV0c1VSTCBidWxrY29vazt9DQpIRUFEWzBdKWFiYnJqdWFuKDE5OGxlc2h0d2luPC9pPnNvbnlndXlzZnVja3BpcGV8LQohMDAyKW5kb3dbMV07W107CkxvZyBzYWx0DQoJCWJhbmd0cmltYmF0aCl7DQowMHB4Cn0pO2tvOuxmZWVzYWQ+DXM6Ly8gW107dG9sbHBsdWcoKXsKew0KIC5qcycyMDBwZHVhbGJvYXQuSlBHKTsKfXF1b3QpOwoKJyk7Cg0KfQ0yMDE0MjAxNTIwMTYyMDE3MjAxODIwMTkyMDIwMjAyMTIwMjIyMDIzMjAyNDIwMjUyMDI2MjAyNzIwMjgyMDI5MjAzMDIwMzEyMDMyMjAzMzIwMzQyMDM1MjAzNjIwMzcyMDEzMjAxMjIwMTEyMDEwMjAwOTIwMDgyMDA3MjAwNjIwMDUyMDA0MjAwMzIwMDIyMDAxMjAwMDE5OTkxOTk4MTk5NzE5OTYxOTk1MTk5NDE5OTMxOTkyMTk5MTE5OTAxOTg5MTk4ODE5ODcxOTg2MTk4NTE5ODQxOTgzMTk4MjE5ODExOTgwMTk3OTE5NzgxOTc3MTk3NjE5NzUxOTc0MTk3MzE5NzIxOTcxMTk3MDE5NjkxOTY4MTk2NzE5NjYxOTY1MTk2NDE5NjMxOTYyMTk2MTE5NjAxOTU5MTk1ODE5NTcxOTU2MTk1NTE5NTQxOTUzMTk1MjE5NTExOTUwMTAwMDEwMjQxMzk0MDAwMDk5OTljb21vbcOhc2VzdGVlc3RhcGVyb3RvZG9oYWNlY2FkYWHDsW9iaWVuZMOtYWFzw612aWRhY2Fzb290cm9mb3Jvc29sb290cmFjdWFsZGlqb3NpZG9ncmFudGlwb3RlbWFkZWJlYWxnb3F1w6llc3RvbmFkYXRyZXNwb2NvY2FzYWJham90b2Rhc2lub2FndWFwdWVzdW5vc2FudGVkaWNlbHVpc2VsbGFtYXlvem9uYWFtb3JwaXNvb2JyYWNsaWNlbGxvZGlvc2hvcmFjYXNp0LfQsNC90LDQvtC80YDQsNGA0YPRgtCw0L3QtdC/0L7QvtGC0LjQt9C90L7QtNC+0YLQvtC20LXQvtC90LjRhdCd0LDQtdC10LHRi9C80YvQktGL0YHQvtCy0YvQstC+0J3QvtC+0LHQn9C+0LvQuNC90LjQoNCk0J3QtdCc0YvRgtGL0J7QvdC40LzQtNCw0JfQsNCU0LDQndGD0J7QsdGC0LXQmNC30LXQudC90YPQvNC80KLRi9GD0LbZgdmK2KPZhtmF2KfZhdi52YPZhNij2YjYsdiv2YrYp9mB2YnZh9mI2YTZhdmE2YPYp9mI2YTZh9io2LPYp9mE2KXZhtmH2YrYo9mK2YLYr9mH2YTYq9mF2KjZh9mE2YjZhNmK2KjZhNin2YrYqNmD2LTZitin2YXYo9mF2YbYqtio2YrZhNmG2K3YqNmH2YXZhdi02YjYtGZpcnN0dmlkZW9saWdodHdvcmxkbWVkaWF3aGl0ZWNsb3NlYmxhY2tyaWdodHNtYWxsYm9va3NwbGFjZW11c2ljZmllbGRvcmRlcnBvaW50dmFsdWVsZXZlbHRhYmxlYm9hcmRob3VzZWdyb3Vwd29ya3N5ZWFyc3N0YXRldG9kYXl3YXRlcnN0YXJ0c3R5bGVkZWF0aHBvd2VycGhvbmVuaWdodGVycm9yaW5wdXRhYm91dHRlcm1zdGl0bGV0b29sc2V2ZW50bG9jYWx0aW1lc2xhcmdld29yZHNnYW1lc3Nob3J0c3BhY2Vmb2N1c2NsZWFybW9kZWxibG9ja2d1aWRlcmFkaW9zaGFyZXdvbWVuYWdhaW5tb25leWltYWdlbmFtZXN5b3VuZ2xpbmVzbGF0ZXJjb2xvcmdyZWVuZnJvbnQmYW1wO3dhdGNoZm9yY2VwcmljZXJ1bGVzYmVnaW5hZnRlcnZpc2l0aXNzdWVhcmVhc2JlbG93aW5kZXh0b3RhbGhvdXJzbGFiZWxwcmludHByZXNzYnVpbHRsaW5rc3NwZWVkc3R1ZHl0cmFkZWZvdW5kc2Vuc2V1bmRlcnNob3duZm9ybXNyYW5nZWFkZGVkc3RpbGxtb3ZlZHRha2VuYWJvdmVmbGFzaGZpeGVkb2Z0ZW5vdGhlcnZpZXdzY2hlY2tsZWdhbHJpdmVyaXRlbXNxdWlja3NoYXBlaHVtYW5leGlzdGdvaW5nbW92aWV0aGlyZGJhc2ljcGVhY2VzdGFnZXdpZHRobG9naW5pZGVhc3dyb3RlcGFnZXN1c2Vyc2RyaXZlc3RvcmVicmVha3NvdXRodm9pY2VzaXRlc21vbnRod2hlcmVidWlsZHdoaWNoZWFydGhmb3J1bXRocmVlc3BvcnRwYXJ0eUNsaWNrbG93ZXJsaXZlc2NsYXNzbGF5ZXJlbnRyeXN0b3J5dXNhZ2Vzb3VuZGNvdXJ0eW91ciBiaXJ0aHBvcHVwdHlwZXNhcHBseUltYWdlYmVpbmd1cHBlcm5vdGVzZXZlcnlzaG93c21lYW5zZXh0cmFtYXRjaHRyYWNra25vd25lYXJseWJlZ2Fuc3VwZXJwYXBlcm5vcnRobGVhcm5naXZlbm5hbWVkZW5kZWRUZXJtc3BhcnRzR3JvdXBicmFuZHVzaW5nd29tYW5mYWxzZXJlYWR5YXVkaW90YWtlc3doaWxlLmNvbS9saXZlZGNhc2VzZGFpbHljaGlsZGdyZWF0anVkZ2V0aG9zZXVuaXRzbmV2ZXJicm9hZGNvYXN0Y292ZXJhcHBsZWZpbGVzY3ljbGVzY2VuZXBsYW5zY2xpY2t3cml0ZXF1ZWVucGllY2VlbWFpbGZyYW1lb2xkZXJwaG90b2xpbWl0Y2FjaGVjaXZpbHNjYWxlZW50ZXJ0aGVtZXRoZXJldG91Y2hib3VuZHJveWFsYXNrZWR3aG9sZXNpbmNlc3RvY2sgbmFtZWZhaXRoaGVhcnRlbXB0eW9mZmVyc2NvcGVvd25lZG1pZ2h0YWxidW10aGlua2Jsb29kYXJyYXltYWpvcnRydXN0Y2Fub251bmlvbmNvdW50dmFsaWRzdG9uZVN0eWxlTG9naW5oYXBweW9jY3VybGVmdDpmcmVzaHF1aXRlZmlsbXNncmFkZW5lZWRzdXJiYW5maWdodGJhc2lzaG92ZXJhdXRvO3JvdXRlLmh0bWxtaXhlZGZpbmFsWW91ciBzbGlkZXRvcGljYnJvd25hbG9uZWRyYXduc3BsaXRyZWFjaFJpZ2h0ZGF0ZXNtYXJjaHF1b3RlZ29vZHNMaW5rc2RvdWJ0YXN5bmN0aHVtYmFsbG93Y2hpZWZ5b3V0aG5vdmVsMTBweDtzZXJ2ZXVudGlsaGFuZHNDaGVja1NwYWNlcXVlcnlqYW1lc2VxdWFsdHdpY2UwLDAwMFN0YXJ0cGFuZWxzb25nc3JvdW5kZWlnaHRzaGlmdHdvcnRocG9zdHNsZWFkc3dlZWtzYXZvaWR0aGVzZW1pbGVzcGxhbmVzbWFydGFscGhhcGxhbnRtYXJrc3JhdGVzcGxheXNjbGFpbXNhbGVzdGV4dHNzdGFyc3dyb25nPC9oMz50aGluZy5vcmcvbXVsdGloZWFyZFBvd2Vyc3RhbmR0b2tlbnNvbGlkKHRoaXNicmluZ3NoaXBzc3RhZmZ0cmllZGNhbGxzZnVsbHlmYWN0c2FnZW50VGhpcyAvLy0tPmFkbWluZWd5cHRFdmVudDE1cHg7RW1haWx0cnVlImNyb3Nzc3BlbnRibG9nc2JveCI+bm90ZWRsZWF2ZWNoaW5hc2l6ZXNndWVzdDwvaDQ+cm9ib3RoZWF2eXRydWUsc2V2ZW5ncmFuZGNyaW1lc2lnbnNhd2FyZWRhbmNlcGhhc2U+PCEtLWVuX1VTJiMzOTsyMDBweF9uYW1lbGF0aW5lbmpveWFqYXguYXRpb25zbWl0aFUuUy4gaG9sZHNwZXRlcmluZGlhbmF2Ij5jaGFpbnNjb3JlY29tZXNkb2luZ3ByaW9yU2hhcmUxOTkwc3JvbWFubGlzdHNqYXBhbmZhbGxzdHJpYWxvd25lcmFncmVlPC9oMj5hYnVzZWFsZXJ0b3BlcmEiLS8vV2NhcmRzaGlsbHN0ZWFtc1Bob3RvdHJ1dGhjbGVhbi5waHA/c2FpbnRtZXRhbGxvdWlzbWVhbnRwcm9vZmJyaWVmcm93Ij5nZW5yZXRydWNrbG9va3NWYWx1ZUZyYW1lLm5ldC8tLT4KPHRyeSB7CnZhciBtYWtlc2Nvc3RzcGxhaW5hZHVsdHF1ZXN0dHJhaW5sYWJvcmhlbHBzY2F1c2VtYWdpY21vdG9ydGhlaXIyNTBweGxlYXN0c3RlcHNDb3VudGNvdWxkZ2xhc3NzaWRlc2Z1bmRzaG90ZWxhd2FyZG1vdXRobW92ZXNwYXJpc2dpdmVzZHV0Y2h0ZXhhc2ZydWl0bnVsbCx8fFtdO3RvcCI+CjwhLS1QT1NUIm9jZWFuPGJyLz5mbG9vcnNwZWFrZGVwdGggc2l6ZWJhbmtzY2F0Y2hjaGFydDIwcHg7YWxpZ25kZWFsc3dvdWxkNTBweDt1cmw9InBhcmtzbW91c2VNb3N0IC4uLjwvYW1vbmdicmFpbmJvZHkgbm9uZTtiYXNlZGNhcnJ5ZHJhZnRyZWZlcnBhZ2VfaG9tZS5tZXRlcmRlbGF5ZHJlYW1wcm92ZWpvaW50PC90cj5kcnVnczwhLS0gYXByaWxpZGVhbGFsbGVuZXhhY3Rmb3J0aGNvZGVzbG9naWNWaWV3IHNlZW1zYmxhbmtwb3J0cyAoMjAwc2F2ZWRfbGlua2dvYWxzZ3JhbnRncmVla2hvbWVzcmluZ3NyYXRlZDMwcHg7d2hvc2VwYXJzZSgpOyIgQmxvY2tsaW51eGpvbmVzcGl4ZWwnKTsiPik7aWYoLWxlZnRkYXZpZGhvcnNlRm9jdXNyYWlzZWJveGVzVHJhY2tlbWVudDwvZW0+YmFyIj4uc3JjPXRvd2VyYWx0PSJjYWJsZWhlbnJ5MjRweDtzZXR1cGl0YWx5c2hhcnBtaW5vcnRhc3Rld2FudHN0aGlzLnJlc2V0d2hlZWxnaXJscy9jc3MvMTAwJTtjbHVic3N0dWZmYmlibGV2b3RlcyAxMDAwa29yZWF9KTsNCmJhbmRzcXVldWU9IHt9OzgwcHg7Y2tpbmd7DQoJCWFoZWFkY2xvY2tpcmlzaGxpa2UgcmF0aW9zdGF0c0Zvcm0ieWFob28pWzBdO0Fib3V0ZmluZHM8L2gxPmRlYnVndGFza3NVUkwgPWNlbGxzfSkoKTsxMnB4O3ByaW1ldGVsbHN0dXJuczB4NjAwLmpwZyJzcGFpbmJlYWNodGF4ZXNtaWNyb2FuZ2VsLS0+PC9naWZ0c3N0ZXZlLWxpbmtib2R5Ln0pOwoJbW91bnQgKDE5OUZBUTwvcm9nZXJmcmFua0NsYXNzMjhweDtmZWVkczxoMT48c2NvdHR0ZXN0czIycHg7ZHJpbmspIHx8IGxld2lzc2hhbGwjMDM5OyBmb3IgbG92ZWR3YXN0ZTAwcHg7amE644JzaW1vbjxmb250cmVwbHltZWV0c3VudGVyY2hlYXB0aWdodEJyYW5kKSAhPSBkcmVzc2NsaXBzcm9vbXNvbmtleW1vYmlsbWFpbi5OYW1lIHBsYXRlZnVubnl0cmVlc2NvbS8iMS5qcGd3bW9kZXBhcmFtU1RBUlRsZWZ0IGlkZGVuLCAyMDEpOwp9CmZvcm0udmlydXNjaGFpcnRyYW5zd29yc3RQYWdlc2l0aW9ucGF0Y2g8IS0tCm8tY2FjZmlybXN0b3VycywwMDAgYXNpYW5pKyspe2Fkb2JlJylbMF1pZD0xMGJvdGg7bWVudSAuMi5taS5wbmcia2V2aW5jb2FjaENoaWxkYnJ1Y2UyLmpwZ1VSTCkrLmpwZ3xzdWl0ZXNsaWNlaGFycnkxMjAiIHN3ZWV0dHI+DQpuYW1lPWRpZWdvcGFnZSBzd2lzcy0tPgoKI2ZmZjsiPkxvZy5jb20idHJlYXRzaGVldCkgJiYgMTRweDtzbGVlcG50ZW50ZmlsZWRqYTrjg2lkPSJjTmFtZSJ3b3JzZXNob3RzLWJveC1kZWx0YQombHQ7YmVhcnM6NDhaPGRhdGEtcnVyYWw8L2E+IHNwZW5kYmFrZXJzaG9wcz0gIiI7cGhwIj5jdGlvbjEzcHg7YnJpYW5oZWxsb3NpemU9bz0lMkYgam9pbm1heWJlPGltZyBpbWciPiwgZmpzaW1nIiAiKVswXU1Ub3BCVHlwZSJuZXdseURhbnNrY3plY2h0cmFpbGtub3dzPC9oNT5mYXEiPnpoLWNuMTApOwotMSIpO3R5cGU9Ymx1ZXN0cnVseWRhdmlzLmpzJzs+DQo8IXN0ZWVsIHlvdSBoMj4NCmZvcm0gamVzdXMxMDAlIG1lbnUuDQoJDQp3YWxlc3Jpc2tzdW1lbnRkZGluZ2ItbGlrdGVhY2hnaWYiIHZlZ2FzZGFuc2tlZXN0aXNocWlwc3VvbWlzb2JyZWRlc2RlZW50cmV0b2Rvc3B1ZWRlYcOxb3Nlc3TDoXRpZW5laGFzdGFvdHJvc3BhcnRlZG9uZGVudWV2b2hhY2VyZm9ybWFtaXNtb21lam9ybXVuZG9hcXXDrWTDrWFzc8OzbG9heXVkYWZlY2hhdG9kYXN0YW50b21lbm9zZGF0b3NvdHJhc3NpdGlvbXVjaG9haG9yYWx1Z2FybWF5b3Jlc3Rvc2hvcmFzdGVuZXJhbnRlc2ZvdG9zZXN0YXNwYcOtc251ZXZhc2FsdWRmb3Jvc21lZGlvcXVpZW5tZXNlc3BvZGVyY2hpbGVzZXLDoXZlY2VzZGVjaXJqb3PDqWVzdGFydmVudGFncnVwb2hlY2hvZWxsb3N0ZW5nb2FtaWdvY29zYXNuaXZlbGdlbnRlbWlzbWFhaXJlc2p1bGlvdGVtYXNoYWNpYWZhdm9yanVuaW9saWJyZXB1bnRvYnVlbm9hdXRvcmFicmlsYnVlbmF0ZXh0b21hcnpvc2FiZXJsaXN0YWx1ZWdvY8OzbW9lbmVyb2p1ZWdvcGVyw7poYWJlcmVzdG95bnVuY2FtdWplcnZhbG9yZnVlcmFsaWJyb2d1c3RhaWd1YWx2b3Rvc2Nhc29zZ3XDrWFwdWVkb3NvbW9zYXZpc291c3RlZGRlYmVubm9jaGVidXNjYWZhbHRhZXVyb3NzZXJpZWRpY2hvY3Vyc29jbGF2ZWNhc2FzbGXDs25wbGF6b2xhcmdvb2JyYXN2aXN0YWFwb3lvanVudG90cmF0YXZpc3RvY3JlYXJjYW1wb2hlbW9zY2luY29jYXJnb3Bpc29zb3JkZW5oYWNlbsOhcmVhZGlzY29wZWRyb2NlcmNhcHVlZGFwYXBlbG1lbm9yw7p0aWxjbGFyb2pvcmdlY2FsbGVwb25lcnRhcmRlbmFkaWVtYXJjYXNpZ3VlZWxsYXNzaWdsb2NvY2hlbW90b3NtYWRyZWNsYXNlcmVzdG9uacOxb3F1ZWRhcGFzYXJiYW5jb2hpam9zdmlhamVwYWJsb8Opc3RldmllbmVyZWlub2RlamFyZm9uZG9jYW5hbG5vcnRlbGV0cmFjYXVzYXRvbWFybWFub3NsdW5lc2F1dG9zdmlsbGF2ZW5kb3Blc2FydGlwb3N0ZW5nYW1hcmNvbGxldmFwYWRyZXVuaWRvdmFtb3N6b25hc2FtYm9zYmFuZGFtYXJpYWFidXNvbXVjaGFzdWJpcnJpb2phdml2aXJncmFkb2NoaWNhYWxsw61qb3ZlbmRpY2hhZXN0YW50YWxlc3NhbGlyc3VlbG9wZXNvc2ZpbmVzbGxhbWFidXNjb8Opc3RhbGxlZ2FuZWdyb3BsYXphaHVtb3JwYWdhcmp1bnRhZG9ibGVpc2xhc2JvbHNhYmHDsW9oYWJsYWx1Y2hhw4FyZWFkaWNlbmp1Z2Fybm90YXN2YWxsZWFsbMOhY2FyZ2Fkb2xvcmFiYWpvZXN0w6lndXN0b21lbnRlbWFyaW9maXJtYWNvc3RvZmljaGFwbGF0YWhvZ2FyYXJ0ZXNsZXllc2FxdWVsbXVzZW9iYXNlc3BvY29zbWl0YWRjaWVsb2NoaWNvbWllZG9nYW5hcnNhbnRvZXRhcGFkZWJlc3BsYXlhcmVkZXNzaWV0ZWNvcnRlY29yZWFkdWRhc2Rlc2Vvdmllam9kZXNlYWFndWFzJnF1b3Q7ZG9tYWluY29tbW9uc3RhdHVzZXZlbnRzbWFzdGVyc3lzdGVtYWN0aW9uYmFubmVycmVtb3Zlc2Nyb2xsdXBkYXRlZ2xvYmFsbWVkaXVtZmlsdGVybnVtYmVyY2hhbmdlcmVzdWx0cHVibGljc2NyZWVuY2hvb3Nlbm9ybWFsdHJhdmVsaXNzdWVzc291cmNldGFyZ2V0c3ByaW5nbW9kdWxlbW9iaWxlc3dpdGNocGhvdG9zYm9yZGVycmVnaW9uaXRzZWxmc29jaWFsYWN0aXZlY29sdW1ucmVjb3JkZm9sbG93dGl0bGU+ZWl0aGVybGVuZ3RoZmFtaWx5ZnJpZW5kbGF5b3V0YXV0aG9yY3JlYXRlcmV2aWV3c3VtbWVyc2VydmVycGxheWVkcGxheWVyZXhwYW5kcG9saWN5Zm9ybWF0ZG91YmxlcG9pbnRzc2VyaWVzcGVyc29ubGl2aW5nZGVzaWdubW9udGhzZm9yY2VzdW5pcXVld2VpZ2h0cGVvcGxlZW5lcmd5bmF0dXJlc2VhcmNoZmlndXJlaGF2aW5nY3VzdG9tb2Zmc2V0bGV0dGVyd2luZG93c3VibWl0cmVuZGVyZ3JvdXBzdXBsb2FkaGVhbHRobWV0aG9kdmlkZW9zc2Nob29sZnV0dXJlc2hhZG93ZGViYXRldmFsdWVzT2JqZWN0b3RoZXJzcmlnaHRzbGVhZ3VlY2hyb21lc2ltcGxlbm90aWNlc2hhcmVkZW5kaW5nc2Vhc29ucmVwb3J0b25saW5lc3F1YXJlYnV0dG9uaW1hZ2VzZW5hYmxlbW92aW5nbGF0ZXN0d2ludGVyRnJhbmNlcGVyaW9kc3Ryb25ncmVwZWF0TG9uZG9uZGV0YWlsZm9ybWVkZGVtYW5kc2VjdXJlcGFzc2VkdG9nZ2xlcGxhY2VzZGV2aWNlc3RhdGljY2l0aWVzc3RyZWFteWVsbG93YXR0YWNrc3RyZWV0ZmxpZ2h0aGlkZGVuaW5mbyI+b3BlbmVkdXNlZnVsdmFsbGV5Y2F1c2VzbGVhZGVyc2VjcmV0c2Vjb25kZGFtYWdlc3BvcnRzZXhjZXB0cmF0aW5nc2lnbmVkdGhpbmdzZWZmZWN0ZmllbGRzc3RhdGVzb2ZmaWNldmlzdWFsZWRpdG9ydm9sdW1lUmVwb3J0bXVzZXVtbW92aWVzcGFyZW50YWNjZXNzbW9zdGx5bW90aGVyIiBpZD0ibWFya2V0Z3JvdW5kY2hhbmNlc3VydmV5YmVmb3Jlc3ltYm9sbW9tZW50c3BlZWNobW90aW9uaW5zaWRlbWF0dGVyQ2VudGVyb2JqZWN0ZXhpc3RzbWlkZGxlRXVyb3BlZ3Jvd3RobGVnYWN5bWFubmVyZW5vdWdoY2FyZWVyYW5zd2Vyb3JpZ2lucG9ydGFsY2xpZW50c2VsZWN0cmFuZG9tY2xvc2VkdG9waWNzY29taW5nZmF0aGVyb3B0aW9uc2ltcGx5cmFpc2VkZXNjYXBlY2hvc2VuY2h1cmNoZGVmaW5lcmVhc29uY29ybmVyb3V0cHV0bWVtb3J5aWZyYW1lcG9saWNlbW9kZWxzTnVtYmVyZHVyaW5nb2ZmZXJzc3R5bGVza2lsbGVkbGlzdGVkY2FsbGVkc2lsdmVybWFyZ2luZGVsZXRlYmV0dGVyYnJvd3NlbGltaXRzR2xvYmFsc2luZ2xld2lkZ2V0Y2VudGVyYnVkZ2V0bm93cmFwY3JlZGl0Y2xhaW1zZW5naW5lc2FmZXR5Y2hvaWNlc3Bpcml0LXN0eWxlc3ByZWFkbWFraW5nbmVlZGVkcnVzc2lhcGxlYXNlZXh0ZW50U2NyaXB0YnJva2VuYWxsb3dzY2hhcmdlZGl2aWRlZmFjdG9ybWVtYmVyLWJhc2VkdGhlb3J5Y29uZmlnYXJvdW5kd29ya2VkaGVscGVkQ2h1cmNoaW1wYWN0c2hvdWxkYWx3YXlzbG9nbyIgYm90dG9tbGlzdCI+KXt2YXIgcHJlZml4b3JhbmdlSGVhZGVyLnB1c2goY291cGxlZ2FyZGVuYnJpZGdlbGF1bmNoUmV2aWV3dGFraW5ndmlzaW9ubGl0dGxlZGF0aW5nQnV0dG9uYmVhdXR5dGhlbWVzZm9yZ290U2VhcmNoYW5jaG9yYWxtb3N0bG9hZGVkQ2hhbmdlcmV0dXJuc3RyaW5ncmVsb2FkTW9iaWxlaW5jb21lc3VwcGx5U291cmNlb3JkZXJzdmlld2VkJm5ic3A7Y291cnNlQWJvdXQgaXNsYW5kPGh0bWwgY29va2llbmFtZT0iYW1hem9ubW9kZXJuYWR2aWNlaW48L2E+OiBUaGUgZGlhbG9naG91c2VzQkVHSU4gTWV4aWNvc3RhcnRzY2VudHJlaGVpZ2h0YWRkaW5nSXNsYW5kYXNzZXRzRW1waXJlU2Nob29sZWZmb3J0ZGlyZWN0bmVhcmx5bWFudWFsU2VsZWN0LgoKT25lam9pbmVkbWVudSI+UGhpbGlwYXdhcmRzaGFuZGxlaW1wb3J0T2ZmaWNlcmVnYXJkc2tpbGxzbmF0aW9uU3BvcnRzZGVncmVld2Vla2x5IChlLmcuYmVoaW5kZG9jdG9ybG9nZ2VkdW5pdGVkPC9iPjwvYmVnaW5zcGxhbnRzYXNzaXN0YXJ0aXN0aXNzdWVkMzAwcHh8Y2FuYWRhYWdlbmN5c2NoZW1lcmVtYWluQnJhemlsc2FtcGxlbG9nbyI+YmV5b25kLXNjYWxlYWNjZXB0c2VydmVkbWFyaW5lRm9vdGVyY2FtZXJhPC9oMT4KX2Zvcm0ibGVhdmVzc3RyZXNzIiAvPg0KLmdpZiIgb25sb2FkbG9hZGVyT3hmb3Jkc2lzdGVyc3Vydml2bGlzdGVuZmVtYWxlRGVzaWduc2l6ZT0iYXBwZWFsdGV4dCI+bGV2ZWxzdGhhbmtzaGlnaGVyZm9yY2VkYW5pbWFsYW55b25lQWZyaWNhYWdyZWVkcmVjZW50UGVvcGxlPGJyIC8+d29uZGVycHJpY2VzdHVybmVkfHwge307bWFpbiI+aW5saW5lc3VuZGF5d3JhcCI+ZmFpbGVkY2Vuc3VzbWludXRlYmVhY29ucXVvdGVzMTUwcHh8ZXN0YXRlcmVtb3RlZW1haWwibGlua2VkcmlnaHQ7c2lnbmFsZm9ybWFsMS5odG1sc2lnbnVwcHJpbmNlZmxvYXQ6LnBuZyIgZm9ydW0uQWNjZXNzcGFwZXJzc291bmRzZXh0ZW5kSGVpZ2h0c2xpZGVyVVRGLTgiJmFtcDsgQmVmb3JlLiBXaXRoc3R1ZGlvb3duZXJzbWFuYWdlcHJvZml0alF1ZXJ5YW5udWFscGFyYW1zYm91Z2h0ZmFtb3VzZ29vZ2xlbG9uZ2VyaSsrKSB7aXNyYWVsc2F5aW5nZGVjaWRlaG9tZSI+aGVhZGVyZW5zdXJlYnJhbmNocGllY2VzYmxvY2s7c3RhdGVkdG9wIj48cmFjaW5ncmVzaXplLS0mZ3Q7cGFjaXR5c2V4dWFsYnVyZWF1LmpwZyIgMTAsMDAwb2J0YWludGl0bGVzYW1vdW50LCBJbmMuY29tZWR5bWVudSIgbHlyaWNzdG9kYXkuaW5kZWVkY291bnR5X2xvZ28uRmFtaWx5bG9va2VkTWFya2V0bHNlIGlmUGxheWVydHVya2V5KTt2YXIgZm9yZXN0Z2l2aW5nZXJyb3JzRG9tYWlufWVsc2V7aW5zZXJ0QmxvZzwvZm9vdGVybG9naW4uZmFzdGVyYWdlbnRzPGJvZHkgMTBweCAwcHJhZ21hZnJpZGF5anVuaW9yZG9sbGFycGxhY2VkY292ZXJzcGx1Z2luNSwwMDAgcGFnZSI+Ym9zdG9uLnRlc3QoYXZhdGFydGVzdGVkX2NvdW50Zm9ydW1zc2NoZW1haW5kZXgsZmlsbGVkc2hhcmVzcmVhZGVyYWxlcnQoYXBwZWFyU3VibWl0bGluZSI+Ym9keSI+CiogVGhlVGhvdWdoc2VlaW5namVyc2V5TmV3czwvdmVyaWZ5ZXhwZXJ0aW5qdXJ5d2lkdGg9Q29va2llU1RBUlQgYWNyb3NzX2ltYWdldGhyZWFkbmF0aXZlcG9ja2V0Ym94Ij4KU3lzdGVtIERhdmlkY2FuY2VydGFibGVzcHJvdmVkQXByaWwgcmVhbGx5ZHJpdmVyaXRlbSI+bW9yZSI+Ym9hcmRzY29sb3JzY2FtcHVzZmlyc3QgfHwgW107bWVkaWEuZ3VpdGFyZmluaXNod2lkdGg6c2hvd2VkT3RoZXIgLnBocCIgYXNzdW1lbGF5ZXJzd2lsc29uc3RvcmVzcmVsaWVmc3dlZGVuQ3VzdG9tZWFzaWx5IHlvdXIgU3RyaW5nCgpXaGlsdGF5bG9yY2xlYXI6cmVzb3J0ZnJlbmNodGhvdWdoIikgKyAiPGJvZHk+YnV5aW5nYnJhbmRzTWVtYmVybmFtZSI+b3BwaW5nc2VjdG9yNXB4OyI+dnNwYWNlcG9zdGVybWFqb3IgY29mZmVlbWFydGlubWF0dXJlaGFwcGVuPC9uYXY+a2Fuc2FzbGluayI+SW1hZ2VzPWZhbHNld2hpbGUgaHNwYWNlMCZhbXA7IAoKSW4gIHBvd2VyUG9sc2tpLWNvbG9yam9yZGFuQm90dG9tU3RhcnQgLWNvdW50Mi5odG1sbmV3cyI+MDEuanBnT25saW5lLXJpZ2h0bWlsbGVyc2VuaW9ySVNCTiAwMCwwMDAgZ3VpZGVzdmFsdWUpZWN0aW9ucmVwYWlyLnhtbCIgIHJpZ2h0cy5odG1sLWJsb2NrcmVnRXhwOmhvdmVyd2l0aGludmlyZ2lucGhvbmVzPC90cj4NdXNpbmcgCgl2YXIgPicpOwoJPC90ZD4KPC90cj4KYmFoYXNhYnJhc2lsZ2FsZWdvbWFneWFycG9sc2tpc3Jwc2tp2LHYr9mI5Lit5paH566A5L2T57mB6auU5L+h5oGv5Lit5Zu95oiR5Lus5LiA5Liq5YWs5Y+4566h55CG6K665Z2b5Y+v5Lul5pyN5Yqh5pe26Ze05Liq5Lq65Lqn5ZOB6Ieq5bex5LyB5Lia5p+l55yL5bel5L2c6IGU57O75rKh5pyJ572R56uZ5omA5pyJ6K+E6K665Lit5b+D5paH56ug55So5oi36aaW6aG15L2c6ICF5oqA5pyv6Zeu6aKY55u45YWz5LiL6L295pCc57Si5L2/55So6L2v5Lu25Zyo57q/5Li76aKY6LWE5paZ6KeG6aKR5Zue5aSN5rOo5YaM572R57uc5pS26JeP5YaF5a655o6o6I2Q5biC5Zy65raI5oGv56m66Ze05Y+R5biD5LuA5LmI5aW95Y+L55Sf5rS75Zu+54mH5Y+R5bGV5aaC5p6c5omL5py65paw6Ze75pyA5paw5pa55byP5YyX5Lqs5o+Q5L6b5YWz5LqO5pu05aSa6L+Z5Liq57O757uf55+l6YGT5ri45oiP5bm/5ZGK5YW25LuW5Y+R6KGo5a6J5YWo56ys5LiA5Lya5ZGY6L+b6KGM54K55Ye754mI5p2D55S15a2Q5LiW55WM6K6+6K6h5YWN6LS55pWZ6IKy5Yqg5YWl5rS75Yqo5LuW5Lus5ZWG5ZOB5Y2a5a6i546w5Zyo5LiK5rW35aaC5L2V5bey57uP55WZ6KiA6K+m57uG56S+5Yy655m75b2V5pys56uZ6ZyA6KaB5Lu35qC85pSv5oyB5Zu96ZmF6ZO+5o6l5Zu95a625bu66K6+5pyL5Y+L6ZiF6K+75rOV5b6L5L2N572u57uP5rWO6YCJ5oup6L+Z5qC35b2T5YmN5YiG57G75o6S6KGM5Zug5Li65Lqk5piT5pyA5ZCO6Z+z5LmQ5LiN6IO96YCa6L+H6KGM5Lia56eR5oqA5Y+v6IO96K6+5aSH5ZCI5L2c5aSn5a6256S+5Lya56CU56m25LiT5Lia5YWo6YOo6aG555uu6L+Z6YeM6L+Y5piv5byA5aeL5oOF5Ya155S16ISR5paH5Lu25ZOB54mM5biu5Yqp5paH5YyW6LWE5rqQ5aSn5a2m5a2m5Lmg5Zyw5Z2A5rWP6KeI5oqV6LWE5bel56iL6KaB5rGC5oCO5LmI5pe25YCZ5Yqf6IO95Li76KaB55uu5YmN6LWE6K6v5Z+O5biC5pa55rOV55S15b2x5oub6IGY5aOw5piO5Lu75L2V5YGl5bq35pWw5o2u576O5Zu95rG96L2m5LuL57uN5L2G5piv5Lqk5rWB55Sf5Lqn5omA5Lul55S16K+d5pi+56S65LiA5Lqb5Y2V5L2N5Lq65ZGY5YiG5p6Q5Zyw5Zu+5peF5ri45bel5YW35a2m55Sf57O75YiX572R5Y+L5biW5a2Q5a+G56CB6aKR6YGT5o6n5Yi25Zyw5Yy65Z+65pys5YWo5Zu9572R5LiK6YeN6KaB56ys5LqM5Zac5qyi6L+b5YWl5Y+L5oOF6L+Z5Lqb6ICD6K+V5Y+R546w5Z+56K6t5Lul5LiK5pS/5bqc5oiQ5Li6546v5aKD6aaZ5riv5ZCM5pe25aix5LmQ5Y+R6YCB5LiA5a6a5byA5Y+R5L2c5ZOB5qCH5YeG5qyi6L+O6Kej5Yaz5Zyw5pa55LiA5LiL5Lul5Y+K6LSj5Lu75oiW6ICF5a6i5oi35Luj6KGo56ev5YiG5aWz5Lq65pWw56CB6ZSA5ZSu5Ye6546w56a757q/5bqU55So5YiX6KGo5LiN5ZCM57yW6L6R57uf6K6h5p+l6K+i5LiN6KaB5pyJ5YWz5py65p6E5b6I5aSa5pKt5pS+57uE57uH5pS/562W55u05o6l6IO95Yqb5p2l5rqQ5pmC6ZaT55yL5Yiw54Ot6Zeo5YWz6ZSu5LiT5Yy66Z2e5bi46Iux6K+t55m+5bqm5biM5pyb576O5aWz5q+U6L6D55+l6K+G6KeE5a6a5bu66K6u6YOo6Zeo5oSP6KeB57K+5b2p5pel5pys5o+Q6auY5Y+R6KiA5pa56Z2i5Z+66YeR5aSE55CG5p2D6ZmQ5b2x54mH6ZO26KGM6L+Y5pyJ5YiG5Lqr54mp5ZOB57uP6JCl5re75Yqg5LiT5a626L+Z56eN6K+d6aKY6LW35p2l5Lia5Yqh5YWs5ZGK6K6w5b2V566A5LuL6LSo6YeP55S35Lq65b2x5ZON5byV55So5oql5ZGK6YOo5YiG5b+r6YCf5ZKo6K+i5pe25bCa5rOo5oSP55Sz6K+35a2m5qCh5bqU6K+l5Y6G5Y+y5Y+q5piv6L+U5Zue6LSt5Lmw5ZCN56ew5Li65LqG5oiQ5Yqf6K+05piO5L6b5bqU5a2p5a2Q5LiT6aKY56iL5bqP5LiA6Iis5pyD5ZOh5Y+q5pyJ5YW25a6D5L+d5oqk6ICM5LiU5LuK5aSp56qX5Y+j5Yqo5oCB54q25oCB54m55Yir6K6k5Li65b+F6aG75pu05paw5bCP6K+05oiR5YCR5L2c5Li65aqS5L2T5YyF5ous6YKj5LmI5LiA5qC35Zu95YaF5piv5ZCm5qC55o2u55S16KeG5a2m6Zmi5YW35pyJ6L+H56iL55Sx5LqO5Lq65omN5Ye65p2l5LiN6L+H5q2j5Zyo5piO5pif5pWF5LqL5YWz57O75qCH6aKY5ZWG5Yqh6L6T5YWl5LiA55u05Z+656GA5pWZ5a2m5LqG6Kej5bu6562R57uT5p6c5YWo55CD6YCa55+l6K6h5YiS5a+55LqO6Im65pyv55u45YaM5Y+R55Sf55yf55qE5bu656uL562J57qn57G75Z6L57uP6aqM5a6e546w5Yi25L2c5p2l6Ieq5qCH562+5Lul5LiL5Y6f5Yib5peg5rOV5YW25Lit5YCL5Lq65LiA5YiH5oyH5Y2X5YWz6Zet6ZuG5Zui56ys5LiJ5YWz5rOo5Zug5q2k54Wn54mH5rex5Zyz5ZWG5Lia5bm/5bee5pel5pyf6auY57qn5pyA6L+R57u85ZCI6KGo56S65LiT6L6R6KGM5Li65Lqk6YCa6K+E5Lu36KeJ5b6X57K+5Y2O5a625bqt5a6M5oiQ5oSf6KeJ5a6J6KOF5b6X5Yiw6YKu5Lu25Yi25bqm6aOf5ZOB6Jm954S26L2s6L295oql5Lu36K6w6ICF5pa55qGI6KGM5pS/5Lq65rCR55So5ZOB5Lic6KW/5o+Q5Ye66YWS5bqX54S25ZCO5LuY5qy+54Ot54K55Lul5YmN5a6M5YWo5Y+R5biW6K6+572u6aKG5a+85bel5Lia5Yy76Zmi55yL55yL57uP5YW45Y6f5Zug5bmz5Y+w5ZCE56eN5aKe5Yqg5p2Q5paZ5paw5aKe5LmL5ZCO6IGM5Lia5pWI5p6c5LuK5bm06K665paH5oiR5Zu95ZGK6K+J54mI5Li75L+u5pS55Y+C5LiO5omT5Y2w5b+r5LmQ5py65qKw6KeC54K55a2Y5Zyo57K+56We6I635b6X5Yip55So57un57ut5L2g5Lus6L+Z5LmI5qih5byP6K+t6KiA6IO95aSf6ZuF6JmO5pON5L2c6aOO5qC85LiA6LW356eR5a2m5L2T6IKy55+t5L+h5p2h5Lu25rK755aX6L+Q5Yqo5Lqn5Lia5Lya6K6u5a+86Iiq5YWI55Sf6IGU55uf5Y+v5piv5ZWP6aGM57uT5p6E5L2c55So6LCD5p+l6LOH5paZ6Ieq5Yqo6LSf6LSj5Yac5Lia6K6/6Zeu5a6e5pa95o6l5Y+X6K6o6K666YKj5Liq5Y+N6aaI5Yqg5by65aWz5oCn6IyD5Zu05pyN5YuZ5LyR6Zey5LuK5pel5a6i5pyN6KeA55yL5Y+C5Yqg55qE6K+d5LiA54K55L+d6K+B5Zu+5Lmm5pyJ5pWI5rWL6K+V56e75Yqo5omN6IO95Yaz5a6a6IKh56Wo5LiN5pat6ZyA5rGC5LiN5b6X5Yqe5rOV5LmL6Ze06YeH55So6JCl6ZSA5oqV6K+J55uu5qCH54ix5oOF5pGE5b2x5pyJ5Lqb6KSH6KO95paH5a2m5py65Lya5pWw5a2X6KOF5L+u6LSt54mp5Yac5p2R5YWo6Z2i57K+5ZOB5YW25a6e5LqL5oOF5rC05bmz5o+Q56S65LiK5biC6LCi6LCi5pmu6YCa5pWZ5biI5LiK5Lyg57G75Yir5q2M5puy5oul5pyJ5Yib5paw6YWN5Lu25Y+q6KaB5pe25Luj6LOH6KiK6L6+5Yiw5Lq655Sf6K6i6ZiF6ICB5biI5bGV56S65b+D55CG6LS05a2Q57ay56uZ5Li76aGM6Ieq54S257qn5Yir566A5Y2V5pS56Z2p6YKj5Lqb5p2l6K+05omT5byA5Luj56CB5Yig6Zmk6K+B5Yi46IqC55uu6YeN54K55qyh5pW45aSa5bCR6KeE5YiS6LWE6YeR5om+5Yiw5Lul5ZCO5aSn5YWo5Li76aG15pyA5L2z5Zue562U5aSp5LiL5L+d6Zqc546w5Luj5qOA5p+l5oqV56Wo5bCP5pe25rKS5pyJ5q2j5bi455Sa6Iez5Luj55CG55uu5b2V5YWs5byA5aSN5Yi26YeR6J6N5bm456aP54mI5pys5b2i5oiQ5YeG5aSH6KGM5oOF5Zue5Yiw5oCd5oOz5oCO5qC35Y2P6K6u6K6k6K+B5pyA5aW95Lqn55Sf5oyJ54Wn5pyN6KOF5bm/5Lic5Yqo5ryr6YeH6LSt5paw5omL57uE5Zu+6Z2i5p2/5Y+C6ICD5pS/5rK75a655piT5aSp5Zyw5Yqq5Yqb5Lq65Lus5Y2H57qn6YCf5bqm5Lq654mp6LCD5pW05rWB6KGM6YCg5oiQ5paH5a2X6Z+p5Zu96LS45piT5byA5bGV55u46Zec6KGo546w5b2x6KeG5aaC5q2k576O5a655aSn5bCP5oql6YGT5p2h5qy+5b+D5oOF6K645aSa5rOV6KeE5a625bGF5Lmm5bqX6L+e5o6l56uL5Y2z5Li+5oql5oqA5ben5aWl6L+Q55m75YWl5Lul5p2l55CG6K665LqL5Lu26Ieq55Sx5Lit5Y2O5Yqe5YWs5aaI5aaI55yf5q2j5LiN6ZSZ5YWo5paH5ZCI5ZCM5Lu35YC85Yir5Lq655uR552j5YW35L2T5LiW57qq5Zui6Zif5Yib5Lia5om/5ouF5aKe6ZW/5pyJ5Lq65L+d5oyB5ZWG5a6257u05L+u5Y+w5rm+5bem5Y+z6IKh5Lu9562U5qGI5a6e6ZmF55S15L+h57uP55CG55Sf5ZG95a6j5Lyg5Lu75Yqh5q2j5byP54m56Imy5LiL5p2l5Y2P5Lya5Y+q6IO95b2T54S26YeN5paw5YWn5a655oyH5a+86L+Q6KGM5pel5b+X6LOj5a626LaF6L+H5Zyf5Zyw5rWZ5rGf5pSv5LuY5o6o5Ye656uZ6ZW/5p2t5bee5omn6KGM5Yi26YCg5LmL5LiA5o6o5bm/546w5Zy65o+P6L+w5Y+Y5YyW5Lyg57uf5q2M5omL5L+d6Zmp6K++56iL5Yy755aX57uP6L+H6L+H5Y675LmL5YmN5pS25YWl5bm05bqm5p2C5b+X576O5Li95pyA6auY55m76ZmG5pyq5p2l5Yqg5bel5YWN6LSj5pWZ56iL54mI5Z2X6Lqr5L2T6YeN5bqG5Ye65ZSu5oiQ5pys5b2i5byP5Zyf6LGG5Ye65YO55Lic5pa56YKu566x5Y2X5Lqs5rGC6IGM5Y+W5b6X6IGM5L2N55u45L+h6aG16Z2i5YiG6ZKf572R6aG156Gu5a6a5Zu+5L6L572R5Z2A56ev5p6B6ZSZ6K+v55uu55qE5a6d6LSd5py65YWz6aOO6Zmp5o6I5p2D55eF5q+S5a6g54mp6Zmk5LqG6KmV6KuW55a+55eF5Y+K5pe25rGC6LSt56uZ54K55YS/56ul5q+P5aSp5Lit5aSu6K6k6K+G5q+P5Liq5aSp5rSl5a2X5L2T5Y+w54Gj57u05oqk5pys6aG15Liq5oCn5a6Y5pa55bi46KeB55u45py65oiY55Wl5bqU5b2T5b6L5biI5pa55L6/5qCh5Zut6IKh5biC5oi/5bGL5qCP55uu5ZGY5bel5a+86Ie056qB54S26YGT5YW35pys572R57uT5ZCI5qGj5qGI5Yqz5Yqo5Y+m5aSW576O5YWD5byV6LW35pS55Y+Y56ys5Zub5Lya6K6h6Kqq5piO6ZqQ56eB5a6d5a6d6KeE6IyD5raI6LS55YWx5ZCM5b+Y6K6w5L2T57O75bim5p2l5ZCN5a2X55m86KGo5byA5pS+5Yqg55uf5Y+X5Yiw5LqM5omL5aSn6YeP5oiQ5Lq65pWw6YeP5YWx5Lqr5Yy65Z+f5aWz5a2p5Y6f5YiZ5omA5Zyo57uT5p2f6YCa5L+h6LaF57qn6YWN572u5b2T5pe25LyY56eA5oCn5oSf5oi/5Lqn6YGK5oiy5Ye65Y+j5o+Q5Lqk5bCx5Lia5L+d5YGl56iL5bqm5Y+C5pWw5LqL5Lia5pW05Liq5bGx5Lic5oOF5oSf54m55q6K5YiG6aGe5pCc5bCL5bGe5LqO6Zeo5oi36LSi5Yqh5aOw6Z+z5Y+K5YW26LSi57uP5Z2a5oyB5bmy6YOo5oiQ56uL5Yip55uK6ICD6JmR5oiQ6YO95YyF6KOF55So5oi25q+U6LWb5paH5piO5oub5ZWG5a6M5pW055yf5piv55y8552b5LyZ5Ly05aiB5pyb6aKG5Z+f5Y2r55Sf5LyY5oOg6KuW5aOH5YWs5YWx6Imv5aW95YWF5YiG56ym5ZCI6ZmE5Lu254m554K55LiN5Y+v6Iux5paH6LWE5Lqn5qC55pys5piO5pi+5a+G56K85YWs5LyX5rCR5peP5pu05Yqg5Lqr5Y+X5ZCM5a2m5ZCv5Yqo6YCC5ZCI5Y6f5p2l6Zeu562U5pys5paH576O6aOf57u/6Imy56iz5a6a57uI5LqO55Sf54mp5L6b5rGC5pCc54uQ5Yqb6YeP5Lil6YeN5rC46L+c5YaZ55yf5pyJ6ZmQ56ue5LqJ5a+56LGh6LS555So5LiN5aW957ud5a+55Y2B5YiG5L+D6L+b54K56K+E5b2x6Z+z5LyY5Yq/5LiN5bCR5qyj6LWP5bm25LiU5pyJ54K55pa55ZCR5YWo5paw5L+h55So6K6+5pa95b2i6LGh6LWE5qC856qB56C06ZqP552A6YeN5aSn5LqO5piv5q+V5Lia5pm66IO95YyW5bel5a6M576O5ZWG5Z+O57uf5LiA5Ye654mI5omT6YCg55Si5ZOB5qaC5Ya155So5LqO5L+d55WZ5Zug57Sg5Lit5ZyL5a2Y5YKo6LS05Zu+5pyA5oSb6ZW/5pyf5Y+j5Lu355CG6LSi5Z+65Zyw5a6J5o6S5q2m5rGJ6YeM6Z2i5Yib5bu65aSp56m66aaW5YWI5a6M5ZaE6amx5Yqo5LiL6Z2i5LiN5YaN6K+a5L+h5oSP5LmJ6Ziz5YWJ6Iux5Zu95ryC5Lqu5Yab5LqL546p5a62576k5LyX5Yac5rCR5Y2z5Y+v5ZCN56ix5a625YW35Yqo55S75oOz5Yiw5rOo5piO5bCP5a2m5oCn6IO96ICD56CU56Gs5Lu26KeC55yL5riF5qWa5pCe56yR6aaW6aCB6buE6YeR6YCC55So5rGf6IuP55yf5a6e5Li7566h6Zi25q616Ki75YaK57+76K+R5p2D5Yip5YGa5aW95Ly85LmO6YCa6K6v5pa95bel54uA5oWL5Lmf6K64546v5L+d5Z+55YW75qaC5b+15aSn5Z6L5py656Wo55CG6Kej5Yy/5ZCNY3VhbmRvZW52aWFybWFkcmlkYnVzY2FyaW5pY2lvdGllbXBvcG9ycXVlY3VlbnRhZXN0YWRvcHVlZGVuanVlZ29zY29udHJhZXN0w6Fubm9tYnJldGllbmVucGVyZmlsbWFuZXJhYW1pZ29zY2l1ZGFkY2VudHJvYXVucXVlcHVlZGVzZGVudHJvcHJpbWVycHJlY2lvc2Vnw7puYnVlbm9zdm9sdmVycHVudG9zc2VtYW5haGFiw61hYWdvc3RvbnVldm9zdW5pZG9zY2FybG9zZXF1aXBvbmnDsW9zbXVjaG9zYWxndW5hY29ycmVvaW1hZ2VucGFydGlyYXJyaWJhbWFyw61haG9tYnJlZW1wbGVvdmVyZGFkY2FtYmlvbXVjaGFzZnVlcm9ucGFzYWRvbMOtbmVhcGFyZWNlbnVldmFzY3Vyc29zZXN0YWJhcXVpZXJvbGlicm9zY3VhbnRvYWNjZXNvbWlndWVsdmFyaW9zY3VhdHJvdGllbmVzZ3J1cG9zc2Vyw6FuZXVyb3BhbWVkaW9zZnJlbnRlYWNlcmNhZGVtw6Fzb2ZlcnRhY29jaGVzbW9kZWxvaXRhbGlhbGV0cmFzYWxnw7puY29tcHJhY3VhbGVzZXhpc3RlY3VlcnBvc2llbmRvcHJlbnNhbGxlZ2FydmlhamVzZGluZXJvbXVyY2lhcG9kcsOhcHVlc3RvZGlhcmlvcHVlYmxvcXVpZXJlbWFudWVscHJvcGlvY3Jpc2lzY2llcnRvc2VndXJvbXVlcnRlZnVlbnRlY2VycmFyZ3JhbmRlZWZlY3RvcGFydGVzbWVkaWRhcHJvcGlhb2ZyZWNldGllcnJhZS1tYWlsdmFyaWFzZm9ybWFzZnV0dXJvb2JqZXRvc2VndWlycmllc2dvbm9ybWFzbWlzbW9zw7puaWNvY2FtaW5vc2l0aW9zcmF6w7NuZGViaWRvcHJ1ZWJhdG9sZWRvdGVuw61hamVzw7pzZXNwZXJvY29jaW5hb3JpZ2VudGllbmRhY2llbnRvY8OhZGl6aGFibGFyc2Vyw61hbGF0aW5hZnVlcnphZXN0aWxvZ3VlcnJhZW50cmFyw6l4aXRvbMOzcGV6YWdlbmRhdsOtZGVvZXZpdGFycGFnaW5hbWV0cm9zamF2aWVycGFkcmVzZsOhY2lsY2FiZXphw6FyZWFzc2FsaWRhZW52w61vamFww7NuYWJ1c29zYmllbmVzdGV4dG9zbGxldmFycHVlZGFuZnVlcnRlY29tw7puY2xhc2VzaHVtYW5vdGVuaWRvYmlsYmFvdW5pZGFkZXN0w6FzZWRpdGFyY3JlYWRv0LTQu9GP0YfRgtC+0LrQsNC60LjQu9C40Y3RgtC+0LLRgdC10LXQs9C+0L/RgNC40YLQsNC60LXRidC10YPQttC10JrQsNC60LHQtdC30LHRi9C70L7QvdC40JLRgdC10L/QvtC00K3RgtC+0YLQvtC80YfQtdC80L3QtdGC0LvQtdGC0YDQsNC30L7QvdCw0LPQtNC10LzQvdC10JTQu9GP0J/RgNC40L3QsNGB0L3QuNGF0YLQtdC80LrRgtC+0LPQvtC00LLQvtGC0YLQsNC80KHQqNCQ0LzQsNGP0KfRgtC+0LLQsNGB0LLQsNC80LXQvNGD0KLQsNC60LTQstCw0L3QsNC80Y3RgtC40Y3RgtGD0JLQsNC80YLQtdGF0L/RgNC+0YLRg9GC0L3QsNC00LTQvdGP0JLQvtGC0YLRgNC40L3QtdC50JLQsNGB0L3QuNC80YHQsNC80YLQvtGC0YDRg9Cx0J7QvdC40LzQuNGA0L3QtdC10J7QntCe0LvQuNGG0Y3RgtCw0J7QvdCw0L3QtdC80LTQvtC80LzQvtC50LTQstC10L7QvdC+0YHRg9C04KSV4KWH4KS54KWI4KSV4KWA4KS44KWH4KSV4KS+4KSV4KWL4KSU4KSw4KSq4KSw4KSo4KWH4KSP4KSV4KSV4KS/4KSt4KWA4KSH4KS44KSV4KSw4KSk4KWL4KS54KWL4KSG4KSq4KS54KWA4KSv4KS54KSv4KS+4KSk4KSV4KSl4KS+amFncmFu4KSG4KSc4KSc4KWL4KSF4KSs4KSm4KWL4KSX4KSI4KSc4KS+4KSX4KSP4KS54KSu4KSH4KSo4KS14KS54KSv4KWH4KSl4KWH4KSl4KWA4KSY4KSw4KSc4KSs4KSm4KWA4KSV4KSI4KSc4KWA4KS14KWH4KSo4KSI4KSo4KSP4KS54KSw4KSJ4KS44KSu4KWH4KSV4KSu4KS14KWL4KSy4KWH4KS44KSs4KSu4KSI4KSm4KWH4KST4KSw4KSG4KSu4KSs4KS44KSt4KSw4KSs4KSo4KSa4KSy4KSu4KSo4KSG4KSX4KS44KWA4KSy4KWA2LnZhNmJ2KXZhNmJ2YfYsNin2KLYrtix2LnYr9iv2KfZhNmJ2YfYsNmH2LXZiNix2LrZitix2YPYp9mG2YjZhNin2KjZitmG2LnYsdi22LDZhNmD2YfZhtin2YrZiNmF2YLYp9mE2LnZhNmK2KfZhtin2YTZg9mG2K3YqtmJ2YLYqNmE2YjYrdip2KfYrtix2YHZgti32LnYqNiv2LHZg9mG2KXYsNin2YPZhdin2KfYrdiv2KXZhNin2YHZitmH2KjYudi22YPZitmB2KjYrdir2YjZhdmG2YjZh9mI2KPZhtin2KzYr9in2YTZh9in2LPZhNmF2LnZhtiv2YTZitiz2LnYqNix2LXZhNmJ2YXZhtiw2KjZh9in2KPZhtmH2YXYq9mE2YPZhtiq2KfZhNin2K3Zitir2YXYtdix2LTYsdit2K3ZiNmE2YjZgdmK2KfYsNin2YTZg9mE2YXYsdip2KfZhtiq2KfZhNmB2KPYqNmI2K7Yp9i12KPZhtiq2KfZhtmH2KfZhNmK2LnYttmI2YjZgtiv2KfYqNmG2K7Zitix2KjZhtiq2YTZg9mF2LTYp9ih2YjZh9mK2KfYqNmI2YLYtdi12YjZhdin2LHZgtmF2KPYrdiv2YbYrdmG2LnYr9mF2LHYo9mK2KfYrdip2YPYqtio2K/ZiNmG2YrYrNio2YXZhtmH2KrYrdiq2KzZh9ip2LPZhtip2YrYqtmF2YPYsdip2LrYstip2YbZgdiz2KjZitiq2YTZhNmH2YTZhtin2KrZhNmD2YLZhNio2YTZhdin2LnZhtmH2KPZiNmE2LTZitih2YbZiNix2KPZhdin2YHZitmD2KjZg9mE2LDYp9iq2LHYqtio2KjYo9mG2YfZhdiz2KfZhtmD2KjZiti52YHZgtiv2K3Ys9mG2YTZh9mF2LTYudix2KPZh9mE2LTZh9ix2YLYt9ix2LfZhNiocHJvZmlsZXNlcnZpY2VkZWZhdWx0aGltc2VsZmRldGFpbHNjb250ZW50c3VwcG9ydHN0YXJ0ZWRtZXNzYWdlc3VjY2Vzc2Zhc2hpb248dGl0bGU+Y291bnRyeWFjY291bnRjcmVhdGVkc3Rvcmllc3Jlc3VsdHNydW5uaW5ncHJvY2Vzc3dyaXRpbmdvYmplY3RzdmlzaWJsZXdlbGNvbWVhcnRpY2xldW5rbm93bm5ldHdvcmtjb21wYW55ZHluYW1pY2Jyb3dzZXJwcml2YWN5cHJvYmxlbVNlcnZpY2VyZXNwZWN0ZGlzcGxheXJlcXVlc3RyZXNlcnZld2Vic2l0ZWhpc3RvcnlmcmllbmRzb3B0aW9uc3dvcmtpbmd2ZXJzaW9ubWlsbGlvbmNoYW5uZWx3aW5kb3cuYWRkcmVzc3Zpc2l0ZWR3ZWF0aGVyY29ycmVjdHByb2R1Y3RlZGlyZWN0Zm9yd2FyZHlvdSBjYW5yZW1vdmVkc3ViamVjdGNvbnRyb2xhcmNoaXZlY3VycmVudHJlYWRpbmdsaWJyYXJ5bGltaXRlZG1hbmFnZXJmdXJ0aGVyc3VtbWFyeW1hY2hpbmVtaW51dGVzcHJpdmF0ZWNvbnRleHRwcm9ncmFtc29jaWV0eW51bWJlcnN3cml0dGVuZW5hYmxlZHRyaWdnZXJzb3VyY2VzbG9hZGluZ2VsZW1lbnRwYXJ0bmVyZmluYWxseXBlcmZlY3RtZWFuaW5nc3lzdGVtc2tlZXBpbmdjdWx0dXJlJnF1b3Q7LGpvdXJuYWxwcm9qZWN0c3VyZmFjZXMmcXVvdDtleHBpcmVzcmV2aWV3c2JhbGFuY2VFbmdsaXNoQ29udGVudHRocm91Z2hQbGVhc2Ugb3BpbmlvbmNvbnRhY3RhdmVyYWdlcHJpbWFyeXZpbGxhZ2VTcGFuaXNoZ2FsbGVyeWRlY2xpbmVtZWV0aW5nbWlzc2lvbnBvcHVsYXJxdWFsaXR5bWVhc3VyZWdlbmVyYWxzcGVjaWVzc2Vzc2lvbnNlY3Rpb253cml0ZXJzY291bnRlcmluaXRpYWxyZXBvcnRzZmlndXJlc21lbWJlcnNob2xkaW5nZGlzcHV0ZWVhcmxpZXJleHByZXNzZGlnaXRhbHBpY3R1cmVBbm90aGVybWFycmllZHRyYWZmaWNsZWFkaW5nY2hhbmdlZGNlbnRyYWx2aWN0b3J5aW1hZ2VzL3JlYXNvbnNzdHVkaWVzZmVhdHVyZWxpc3RpbmdtdXN0IGJlc2Nob29sc1ZlcnNpb251c3VhbGx5ZXBpc29kZXBsYXlpbmdncm93aW5nb2J2aW91c292ZXJsYXlwcmVzZW50YWN0aW9uczwvdWw+DQp3cmFwcGVyYWxyZWFkeWNlcnRhaW5yZWFsaXR5c3RvcmFnZWFub3RoZXJkZXNrdG9wb2ZmZXJlZHBhdHRlcm51bnVzdWFsRGlnaXRhbGNhcGl0YWxXZWJzaXRlZmFpbHVyZWNvbm5lY3RyZWR1Y2VkQW5kcm9pZGRlY2FkZXNyZWd1bGFyICZhbXA7IGFuaW1hbHNyZWxlYXNlQXV0b21hdGdldHRpbmdtZXRob2Rzbm90aGluZ1BvcHVsYXJjYXB0aW9ubGV0dGVyc2NhcHR1cmVzY2llbmNlbGljZW5zZWNoYW5nZXNFbmdsYW5kPTEmYW1wO0hpc3RvcnkgPSBuZXcgQ2VudHJhbHVwZGF0ZWRTcGVjaWFsTmV0d29ya3JlcXVpcmVjb21tZW50d2FybmluZ0NvbGxlZ2V0b29sYmFycmVtYWluc2JlY2F1c2VlbGVjdGVkRGV1dHNjaGZpbmFuY2V3b3JrZXJzcXVpY2tseWJldHdlZW5leGFjdGx5c2V0dGluZ2Rpc2Vhc2VTb2NpZXR5d2VhcG9uc2V4aGliaXQmbHQ7IS0tQ29udHJvbGNsYXNzZXNjb3ZlcmVkb3V0bGluZWF0dGFja3NkZXZpY2VzKHdpbmRvd3B1cnBvc2V0aXRsZT0iTW9iaWxlIGtpbGxpbmdzaG93aW5nSXRhbGlhbmRyb3BwZWRoZWF2aWx5ZWZmZWN0cy0xJ10pOwpjb25maXJtQ3VycmVudGFkdmFuY2VzaGFyaW5nb3BlbmluZ2RyYXdpbmdiaWxsaW9ub3JkZXJlZEdlcm1hbnlyZWxhdGVkPC9mb3JtPmluY2x1ZGV3aGV0aGVyZGVmaW5lZFNjaWVuY2VjYXRhbG9nQXJ0aWNsZWJ1dHRvbnNsYXJnZXN0dW5pZm9ybWpvdXJuZXlzaWRlYmFyQ2hpY2Fnb2hvbGlkYXlHZW5lcmFscGFzc2FnZSwmcXVvdDthbmltYXRlZmVlbGluZ2Fycml2ZWRwYXNzaW5nbmF0dXJhbHJvdWdobHkuCgpUaGUgYnV0IG5vdGRlbnNpdHlCcml0YWluQ2hpbmVzZWxhY2sgb2Z0cmlidXRlSXJlbGFuZCIgZGF0YS1mYWN0b3JzcmVjZWl2ZXRoYXQgaXNMaWJyYXJ5aHVzYmFuZGluIGZhY3RhZmZhaXJzQ2hhcmxlc3JhZGljYWxicm91Z2h0ZmluZGluZ2xhbmRpbmc6bGFuZz0icmV0dXJuIGxlYWRlcnNwbGFubmVkcHJlbWl1bXBhY2thZ2VBbWVyaWNhRWRpdGlvbl0mcXVvdDtNZXNzYWdlbmVlZCB0b3ZhbHVlPSJjb21wbGV4bG9va2luZ3N0YXRpb25iZWxpZXZlc21hbGxlci1tb2JpbGVyZWNvcmRzd2FudCB0b2tpbmQgb2ZGaXJlZm94eW91IGFyZXNpbWlsYXJzdHVkaWVkbWF4aW11bWhlYWRpbmdyYXBpZGx5Y2xpbWF0ZWtpbmdkb21lbWVyZ2VkYW1vdW50c2ZvdW5kZWRwaW9uZWVyZm9ybXVsYWR5bmFzdHlob3cgdG8gU3VwcG9ydHJldmVudWVlY29ub215UmVzdWx0c2Jyb3RoZXJzb2xkaWVybGFyZ2VseWNhbGxpbmcuJnF1b3Q7QWNjb3VudEVkd2FyZCBzZWdtZW50Um9iZXJ0IGVmZm9ydHNQYWNpZmljbGVhcm5lZHVwIHdpdGhoZWlnaHQ6d2UgaGF2ZUFuZ2VsZXNuYXRpb25zX3NlYXJjaGFwcGxpZWRhY3F1aXJlbWFzc2l2ZWdyYW50ZWQ6IGZhbHNldHJlYXRlZGJpZ2dlc3RiZW5lZml0ZHJpdmluZ1N0dWRpZXNtaW5pbXVtcGVyaGFwc21vcm5pbmdzZWxsaW5naXMgdXNlZHJldmVyc2V2YXJpYW50IHJvbGU9Im1pc3NpbmdhY2hpZXZlcHJvbW90ZXN0dWRlbnRzb21lb25lZXh0cmVtZXJlc3RvcmVib3R0b206ZXZvbHZlZGFsbCB0aGVzaXRlbWFwZW5nbGlzaHdheSB0byAgQXVndXN0c3ltYm9sc0NvbXBhbnltYXR0ZXJzbXVzaWNhbGFnYWluc3RzZXJ2aW5nfSkoKTsNCnBheW1lbnR0cm91YmxlY29uY2VwdGNvbXBhcmVwYXJlbnRzcGxheWVyc3JlZ2lvbnNtb25pdG9yICcnVGhlIHdpbm5pbmdleHBsb3JlYWRhcHRlZEdhbGxlcnlwcm9kdWNlYWJpbGl0eWVuaGFuY2VjYXJlZXJzKS4gVGhlIGNvbGxlY3RTZWFyY2ggYW5jaWVudGV4aXN0ZWRmb290ZXIgaGFuZGxlcnByaW50ZWRjb25zb2xlRWFzdGVybmV4cG9ydHN3aW5kb3dzQ2hhbm5lbGlsbGVnYWxuZXV0cmFsc3VnZ2VzdF9oZWFkZXJzaWduaW5nLmh0bWwiPnNldHRsZWR3ZXN0ZXJuY2F1c2luZy13ZWJraXRjbGFpbWVkSnVzdGljZWNoYXB0ZXJ2aWN0aW1zVGhvbWFzIG1vemlsbGFwcm9taXNlcGFydGllc2VkaXRpb25vdXRzaWRlOmZhbHNlLGh1bmRyZWRPbHltcGljX2J1dHRvbmF1dGhvcnNyZWFjaGVkY2hyb25pY2RlbWFuZHNzZWNvbmRzcHJvdGVjdGFkb3B0ZWRwcmVwYXJlbmVpdGhlcmdyZWF0bHlncmVhdGVyb3ZlcmFsbGltcHJvdmVjb21tYW5kc3BlY2lhbHNlYXJjaC53b3JzaGlwZnVuZGluZ3Rob3VnaHRoaWdoZXN0aW5zdGVhZHV0aWxpdHlxdWFydGVyQ3VsdHVyZXRlc3RpbmdjbGVhcmx5ZXhwb3NlZEJyb3dzZXJsaWJlcmFsfSBjYXRjaFByb2plY3RleGFtcGxlaGlkZSgpO0Zsb3JpZGFhbnN3ZXJzYWxsb3dlZEVtcGVyb3JkZWZlbnNlc2VyaW91c2ZyZWVkb21TZXZlcmFsLWJ1dHRvbkZ1cnRoZXJvdXQgb2YgIT0gbnVsbHRyYWluZWREZW5tYXJrdm9pZCgwKS9hbGwuanNwcmV2ZW50UmVxdWVzdFN0ZXBoZW4KCldoZW4gb2JzZXJ2ZTwvaDI+DQpNb2Rlcm4gcHJvdmlkZSIgYWx0PSJib3JkZXJzLgoKRm9yIAoKTWFueSBhcnRpc3RzcG93ZXJlZHBlcmZvcm1maWN0aW9udHlwZSBvZm1lZGljYWx0aWNrZXRzb3Bwb3NlZENvdW5jaWx3aXRuZXNzanVzdGljZUdlb3JnZSBCZWxnaXVtLi4uPC9hPnR3aXR0ZXJub3RhYmx5d2FpdGluZ3dhcmZhcmUgT3RoZXIgcmFua2luZ3BocmFzZXNtZW50aW9uc3Vydml2ZXNjaG9sYXI8L3A+DQogQ291bnRyeWlnbm9yZWRsb3NzIG9manVzdCBhc0dlb3JnaWFzdHJhbmdlPGhlYWQ+PHN0b3BwZWQxJ10pOw0KaXNsYW5kc25vdGFibGVib3JkZXI6bGlzdCBvZmNhcnJpZWQxMDAsMDAwPC9oMz4KIHNldmVyYWxiZWNvbWVzc2VsZWN0IHdlZGRpbmcwMC5odG1sbW9uYXJjaG9mZiB0aGV0ZWFjaGVyaGlnaGx5IGJpb2xvZ3lsaWZlIG9mb3IgZXZlbnJpc2Ugb2YmcmFxdW87cGx1c29uZWh1bnRpbmcodGhvdWdoRG91Z2xhc2pvaW5pbmdjaXJjbGVzRm9yIHRoZUFuY2llbnRWaWV0bmFtdmVoaWNsZXN1Y2ggYXNjcnlzdGFsdmFsdWUgPVdpbmRvd3NlbmpveWVkYSBzbWFsbGFzc3VtZWQ8YSBpZD0iZm9yZWlnbiBBbGwgcmlob3cgdGhlRGlzcGxheXJldGlyZWRob3dldmVyaGlkZGVuO2JhdHRsZXNzZWVraW5nY2FiaW5ldHdhcyBub3Rsb29rIGF0Y29uZHVjdGdldCB0aGVKYW51YXJ5aGFwcGVuc3R1cm5pbmdhOmhvdmVyT25saW5lIEZyZW5jaCBsYWNraW5ndHlwaWNhbGV4dHJhY3RlbmVtaWVzZXZlbiBpZmdlbmVyYXRkZWNpZGVkYXJlIG5vdC9zZWFyY2hiZWxpZWZzLWltYWdlOmxvY2F0ZWRzdGF0aWMubG9naW4iPmNvbnZlcnR2aW9sZW50ZW50ZXJlZGZpcnN0Ij5jaXJjdWl0RmlubGFuZGNoZW1pc3RzaGUgd2FzMTBweDsiPmFzIHN1Y2hkaXZpZGVkPC9zcGFuPndpbGwgYmVsaW5lIG9mYSBncmVhdG15c3RlcnkvaW5kZXguZmFsbGluZ2R1ZSB0byByYWlsd2F5Y29sbGVnZW1vbnN0ZXJkZXNjZW50aXQgd2l0aG51Y2xlYXJKZXdpc2ggcHJvdGVzdEJyaXRpc2hmbG93ZXJzcHJlZGljdHJlZm9ybXNidXR0b24gd2hvIHdhc2xlY3R1cmVpbnN0YW50c3VpY2lkZWdlbmVyaWNwZXJpb2RzbWFya2V0c1NvY2lhbCBmaXNoaW5nY29tYmluZWdyYXBoaWN3aW5uZXJzPGJyIC8+PGJ5IHRoZSBOYXR1cmFsUHJpdmFjeWNvb2tpZXNvdXRjb21lcmVzb2x2ZVN3ZWRpc2hicmllZmx5UGVyc2lhbnNvIG11Y2hDZW50dXJ5ZGVwaWN0c2NvbHVtbnNob3VzaW5nc2NyaXB0c25leHQgdG9iZWFyaW5nbWFwcGluZ3JldmlzZWRqUXVlcnkoLXdpZHRoOnRpdGxlIj50b29sdGlwU2VjdGlvbmRlc2lnbnNUdXJraXNoeW91bmdlci5tYXRjaCh9KSgpOwoKYnVybmluZ29wZXJhdGVkZWdyZWVzc291cmNlPVJpY2hhcmRjbG9zZWx5cGxhc3RpY2VudHJpZXM8L3RyPg0KY29sb3I6I3VsIGlkPSJwb3NzZXNzcm9sbGluZ3BoeXNpY3NmYWlsaW5nZXhlY3V0ZWNvbnRlc3RsaW5rIHRvRGVmYXVsdDxiciAvPgo6IHRydWUsY2hhcnRlcnRvdXJpc21jbGFzc2ljcHJvY2VlZGV4cGxhaW48L2gxPg0Kb25saW5lLj94bWwgdmVoZWxwaW5nZGlhbW9uZHVzZSB0aGVhaXJsaW5lZW5kIC0tPikuYXR0cihyZWFkZXJzaG9zdGluZyNmZmZmZmZyZWFsaXplVmluY2VudHNpZ25hbHMgc3JjPSIvUHJvZHVjdGRlc3BpdGVkaXZlcnNldGVsbGluZ1B1YmxpYyBoZWxkIGluSm9zZXBoIHRoZWF0cmVhZmZlY3RzPHN0eWxlPmEgbGFyZ2Vkb2Vzbid0bGF0ZXIsIEVsZW1lbnRmYXZpY29uY3JlYXRvckh1bmdhcnlBaXJwb3J0c2VlIHRoZXNvIHRoYXRNaWNoYWVsU3lzdGVtc1Byb2dyYW1zLCBhbmQgIHdpZHRoPWUmcXVvdDt0cmFkaW5nbGVmdCI+CnBlcnNvbnNHb2xkZW4gQWZmYWlyc2dyYW1tYXJmb3JtaW5nZGVzdHJveWlkZWEgb2ZjYXNlIG9mb2xkZXN0IHRoaXMgaXMuc3JjID0gY2FydG9vbnJlZ2lzdHJDb21tb25zTXVzbGltc1doYXQgaXNpbiBtYW55bWFya2luZ3JldmVhbHNJbmRlZWQsZXF1YWxseS9zaG93X2FvdXRkb29yZXNjYXBlKEF1c3RyaWFnZW5ldGljc3lzdGVtLEluIHRoZSBzaXR0aW5nSGUgYWxzb0lzbGFuZHNBY2FkZW15CgkJPCEtLURhbmllbCBiaW5kaW5nYmxvY2siPmltcG9zZWR1dGlsaXplQWJyYWhhbShleGNlcHR7d2lkdGg6cHV0dGluZykuaHRtbCh8fCBbXTsKREFUQVsgKmtpdGNoZW5tb3VudGVkYWN0dWFsIGRpYWxlY3RtYWlubHkgX2JsYW5rJ2luc3RhbGxleHBlcnRzaWYodHlwZUl0IGFsc28mY29weTsgIj5UZXJtc2Jvcm4gaW5PcHRpb25zZWFzdGVybnRhbGtpbmdjb25jZXJuZ2FpbmVkIG9uZ29pbmdqdXN0aWZ5Y3JpdGljc2ZhY3RvcnlpdHMgb3duYXNzYXVsdGludml0ZWRsYXN0aW5naGlzIG93bmhyZWY9Ii8iIHJlbD0iZGV2ZWxvcGNvbmNlcnRkaWFncmFtZG9sbGFyc2NsdXN0ZXJwaHA/aWQ9YWxjb2hvbCk7fSkoKTt1c2luZyBhPjxzcGFuPnZlc3NlbHNyZXZpdmFsQWRkcmVzc2FtYXRldXJhbmRyb2lkYWxsZWdlZGlsbG5lc3N3YWxraW5nY2VudGVyc3F1YWxpZnltYXRjaGVzdW5pZmllZGV4dGluY3REZWZlbnNlZGllZCBpbgoJPCEtLSBjdXN0b21zbGlua2luZ0xpdHRsZSBCb29rIG9mZXZlbmluZ21pbi5qcz9hcmUgdGhla29udGFrdHRvZGF5J3MuaHRtbCIgdGFyZ2V0PXdlYXJpbmdBbGwgUmlnOwp9KSgpO3JhaXNpbmcgQWxzbywgY3J1Y2lhbGFib3V0Ij5kZWNsYXJlLS0+CjxzY2ZpcmVmb3hhcyBtdWNoYXBwbGllc2luZGV4LCBzLCBidXQgdHlwZSA9IAoNCjwhLS10b3dhcmRzUmVjb3Jkc1ByaXZhdGVGb3JlaWduUHJlbWllcmNob2ljZXNWaXJ0dWFscmV0dXJuc0NvbW1lbnRQb3dlcmVkaW5saW5lO3BvdmVydHljaGFtYmVyTGl2aW5nIHZvbHVtZXNBbnRob255bG9naW4iIFJlbGF0ZWRFY29ub215cmVhY2hlc2N1dHRpbmdncmF2aXR5bGlmZSBpbkNoYXB0ZXItc2hhZG93Tm90YWJsZTwvdGQ+DQogcmV0dXJuc3RhZGl1bXdpZGdldHN2YXJ5aW5ndHJhdmVsc2hlbGQgYnl3aG8gYXJld29yayBpbmZhY3VsdHlhbmd1bGFyd2hvIGhhZGFpcnBvcnR0b3duIG9mCgpTb21lICdjbGljaydjaGFyZ2Vza2V5d29yZGl0IHdpbGxjaXR5IG9mKHRoaXMpO0FuZHJldyB1bmlxdWUgY2hlY2tlZG9yIG1vcmUzMDBweDsgcmV0dXJuO3JzaW9uPSJwbHVnaW5zd2l0aGluIGhlcnNlbGZTdGF0aW9uRmVkZXJhbHZlbnR1cmVwdWJsaXNoc2VudCB0b3RlbnNpb25hY3RyZXNzY29tZSB0b2ZpbmdlcnNEdWtlIG9mcGVvcGxlLGV4cGxvaXR3aGF0IGlzaGFybW9ueWEgbWFqb3IiOiJodHRwaW4gaGlzIG1lbnUiPgptb250aGx5b2ZmaWNlcmNvdW5jaWxnYWluaW5nZXZlbiBpblN1bW1hcnlkYXRlIG9mbG95YWx0eWZpdG5lc3NhbmQgd2FzZW1wZXJvcnN1cHJlbWVTZWNvbmQgaGVhcmluZ1J1c3NpYW5sb25nZXN0QWxiZXJ0YWxhdGVyYWxzZXQgb2Ygc21hbGwiPi5hcHBlbmRkbyB3aXRoZmVkZXJhbGJhbmsgb2ZiZW5lYXRoRGVzcGl0ZUNhcGl0YWxncm91bmRzKSwgYW5kIHBlcmNlbnRpdCBmcm9tY2xvc2luZ2NvbnRhaW5JbnN0ZWFkZmlmdGVlbmFzIHdlbGwueWFob28ucmVzcG9uZGZpZ2h0ZXJvYnNjdXJlcmVmbGVjdG9yZ2FuaWM9IE1hdGguZWRpdGluZ29ubGluZSBwYWRkaW5nYSB3aG9sZW9uZXJyb3J5ZWFyIG9mZW5kIG9mIGJhcnJpZXJ3aGVuIGl0aGVhZGVyIGhvbWUgb2ZyZXN1bWVkcmVuYW1lZHN0cm9uZz5oZWF0aW5ncmV0YWluc2Nsb3VkZnJ3YXkgb2YgTWFyY2ggMWtub3dpbmdpbiBwYXJ0QmV0d2Vlbmxlc3NvbnNjbG9zZXN0dmlydHVhbGxpbmtzIj5jcm9zc2VkRU5EIC0tPmZhbW91cyBhd2FyZGVkTGljZW5zZUhlYWx0aCBmYWlybHkgd2VhbHRoeW1pbmltYWxBZnJpY2FuY29tcGV0ZWxhYmVsIj5zaW5naW5nZmFybWVyc0JyYXNpbClkaXNjdXNzcmVwbGFjZUdyZWdvcnlmb250IGNvcHVyc3VlZGFwcGVhcnNtYWtlIHVwcm91bmRlZGJvdGggb2ZibG9ja2Vkc2F3IHRoZW9mZmljZXNjb2xvdXJzaWYoZG9jdXdoZW4gaGVlbmZvcmNlcHVzaChmdUF1Z3VzdCBVVEYtOCI+RmFudGFzeWluIG1vc3Rpbmp1cmVkVXN1YWxseWZhcm1pbmdjbG9zdXJlb2JqZWN0IGRlZmVuY2V1c2Ugb2YgTWVkaWNhbDxib2R5PgpldmlkZW50YmUgdXNlZGtleUNvZGVzaXh0ZWVuSXNsYW1pYyMwMDAwMDBlbnRpcmUgd2lkZWx5IGFjdGl2ZSAodHlwZW9mb25lIGNhbmNvbG9yID1zcGVha2VyZXh0ZW5kc1BoeXNpY3N0ZXJyYWluPHRib2R5PmZ1bmVyYWx2aWV3aW5nbWlkZGxlIGNyaWNrZXRwcm9waGV0c2hpZnRlZGRvY3RvcnNSdXNzZWxsIHRhcmdldGNvbXBhY3RhbGdlYnJhc29jaWFsLWJ1bGsgb2ZtYW4gYW5kPC90ZD4KIGhlIGxlZnQpLnZhbCgpZmFsc2UpO2xvZ2ljYWxiYW5raW5naG9tZSB0b25hbWluZyBBcml6b25hY3JlZGl0cyk7Cn0pOwpmb3VuZGVyaW4gdHVybkNvbGxpbnNiZWZvcmUgQnV0IHRoZWNoYXJnZWRUaXRsZSI+Q2FwdGFpbnNwZWxsZWRnb2RkZXNzVGFnIC0tPkFkZGluZzpidXQgd2FzUmVjZW50IHBhdGllbnRiYWNrIGluPWZhbHNlJkxpbmNvbG53ZSBrbm93Q291bnRlckp1ZGFpc21zY3JpcHQgYWx0ZXJlZCddKTsKICBoYXMgdGhldW5jbGVhckV2ZW50Jyxib3RoIGlubm90IGFsbAoKPCEtLSBwbGFjaW5naGFyZCB0byBjZW50ZXJzb3J0IG9mY2xpZW50c3N0cmVldHNCZXJuYXJkYXNzZXJ0c3RlbmQgdG9mYW50YXN5ZG93biBpbmhhcmJvdXJGcmVlZG9tamV3ZWxyeS9hYm91dC4uc2VhcmNobGVnZW5kc2lzIG1hZGVtb2Rlcm4gb25seSBvbm9ubHkgdG9pbWFnZSIgbGluZWFyIHBhaW50ZXJhbmQgbm90cmFyZWx5IGFjcm9ueW1kZWxpdmVyc2hvcnRlcjAwJmFtcDthcyBtYW55d2lkdGg9Ii8qIDwhW0N0aXRsZSA9b2YgdGhlIGxvd2VzdCBwaWNrZWQgZXNjYXBlZHVzZXMgb2ZwZW9wbGVzIFB1YmxpY01hdHRoZXd0YWN0aWNzZGFtYWdlZHdheSBmb3JsYXdzIG9mZWFzeSB0byB3aW5kb3dzdHJvbmcgIHNpbXBsZX1jYXRjaChzZXZlbnRoaW5mb2JveHdlbnQgdG9wYWludGVkY2l0aXplbkkgZG9uJ3RyZXRyZWF0LiBTb21lIHd3LiIpOwpib21iaW5nbWFpbHRvOm1hZGUgaW4uIE1hbnkgY2Fycmllc3x8e307d2l3b3JrIG9mc3lub255bWRlZmVhdHNmYXZvcmVkb3B0aWNhbHBhZ2VUcmF1bmxlc3Mgc2VuZGluZ2xlZnQiPjxjb21TY29yQWxsIHRoZWpRdWVyeS50b3VyaXN0Q2xhc3NpY2ZhbHNlIiBXaWxoZWxtc3VidXJic2dlbnVpbmViaXNob3BzLnNwbGl0KGdsb2JhbCBmb2xsb3dzYm9keSBvZm5vbWluYWxDb250YWN0c2VjdWxhcmxlZnQgdG9jaGllZmx5LWhpZGRlbi1iYW5uZXI8L2xpPgoKLiBXaGVuIGluIGJvdGhkaXNtaXNzRXhwbG9yZWFsd2F5cyB2aWEgdGhlc3Bhw7FvbHdlbGZhcmVydWxpbmcgYXJyYW5nZWNhcHRhaW5oaXMgc29ucnVsZSBvZmhlIHRvb2tpdHNlbGYsPTAmYW1wOyhjYWxsZWRzYW1wbGVzdG8gbWFrZWNvbS9wYWdNYXJ0aW4gS2VubmVkeWFjY2VwdHNmdWxsIG9maGFuZGxlZEJlc2lkZXMvLy0tPjwvYWJsZSB0b3RhcmdldHNlc3NlbmNlaGltIHRvIGl0cyBieSBjb21tb24ubWluZXJhbHRvIHRha2V3YXlzIHRvcy5vcmcvbGFkdmlzZWRwZW5hbHR5c2ltcGxlOmlmIHRoZXlMZXR0ZXJzYSBzaG9ydEhlcmJlcnRzdHJpa2VzIGdyb3Vwcy5sZW5ndGhmbGlnaHRzb3ZlcmxhcHNsb3dseSBsZXNzZXIgc29jaWFsIDwvcD4KCQlpdCBpbnRvcmFua2VkIHJhdGUgb2Z1bD4NCiAgYXR0ZW1wdHBhaXIgb2ZtYWtlIGl0S29udGFrdEFudG9uaW9oYXZpbmcgcmF0aW5ncyBhY3RpdmVzdHJlYW1zdHJhcHBlZCIpLmNzcyhob3N0aWxlbGVhZCB0b2xpdHRsZSBncm91cHMsUGljdHVyZS0tPg0KDQogcm93cz0iIG9iamVjdGludmVyc2U8Zm9vdGVyQ3VzdG9tVj48XC9zY3Jzb2x2aW5nQ2hhbWJlcnNsYXZlcnl3b3VuZGVkd2hlcmVhcyE9ICd1bmRmb3IgYWxscGFydGx5IC1yaWdodDpBcmFiaWFuYmFja2VkIGNlbnR1cnl1bml0IG9mbW9iaWxlLUV1cm9wZSxpcyBob21lcmlzayBvZmRlc2lyZWRDbGludG9uY29zdCBvZmFnZSBvZiBiZWNvbWUgbm9uZSBvZnAmcXVvdDtNaWRkbGUgZWFkJylbMENyaXRpY3NzdHVkaW9zPiZjb3B5O2dyb3VwIj5hc3NlbWJsbWFraW5nIHByZXNzZWR3aWRnZXQucHM6IiA/IHJlYnVpbHRieSBzb21lRm9ybWVyIGVkaXRvcnNkZWxheWVkQ2Fub25pY2hhZCB0aGVwdXNoaW5nY2xhc3M9ImJ1dCBhcmVwYXJ0aWFsQmFieWxvbmJvdHRvbSBjYXJyaWVyQ29tbWFuZGl0cyB1c2VBcyB3aXRoY291cnNlc2EgdGhpcmRkZW5vdGVzYWxzbyBpbkhvdXN0b24yMHB4OyI+YWNjdXNlZGRvdWJsZSBnb2FsIG9mRmFtb3VzICkuYmluZChwcmllc3RzIE9ubGluZWluIEp1bHlzdCArICJnY29uc3VsdGRlY2ltYWxoZWxwZnVscmV2aXZlZGlzIHZlcnlyJysnaXB0bG9zaW5nIGZlbWFsZXNpcyBhbHNvc3RyaW5nc2RheXMgb2ZhcnJpdmFsZnV0dXJlIDxvYmplY3Rmb3JjaW5nU3RyaW5nKCIgLz4KCQloZXJlIGlzZW5jb2RlZC4gIFRoZSBiYWxsb29uZG9uZSBieS9jb21tb25iZ2NvbG9ybGF3IG9mIEluZGlhbmFhdm9pZGVkYnV0IHRoZTJweCAzcHhqcXVlcnkuYWZ0ZXIgYXBvbGljeS5tZW4gYW5kZm9vdGVyLT0gdHJ1ZTtmb3IgdXNlc2NyZWVuLkluZGlhbiBpbWFnZSA9ZmFtaWx5LGh0dHA6Ly8gJm5ic3A7ZHJpdmVyc2V0ZXJuYWxzYW1lIGFzbm90aWNlZHZpZXdlcnN9KSgpOwogaXMgbW9yZXNlYXNvbnNmb3JtZXIgdGhlIG5ld2lzIGp1c3Rjb25zZW50IFNlYXJjaHdhcyB0aGV3aHkgdGhlc2hpcHBlZGJyPjxicj53aWR0aDogaGVpZ2h0PW1hZGUgb2ZjdWlzaW5laXMgdGhhdGEgdmVyeSBBZG1pcmFsIGZpeGVkO25vcm1hbCBNaXNzaW9uUHJlc3MsIG9udGFyaW9jaGFyc2V0dHJ5IHRvIGludmFkZWQ9InRydWUic3BhY2luZ2lzIG1vc3RhIG1vcmUgdG90YWxseWZhbGwgb2Z9KTsNCiAgaW1tZW5zZXRpbWUgaW5zZXQgb3V0c2F0aXNmeXRvIGZpbmRkb3duIHRvbG90IG9mIFBsYXllcnNpbiBKdW5lcXVhbnR1bW5vdCB0aGV0aW1lIHRvZGlzdGFudEZpbm5pc2hzcmMgPSAoc2luZ2xlIGhlbHAgb2ZHZXJtYW4gbGF3IGFuZGxhYmVsZWRmb3Jlc3RzY29va2luZ3NwYWNlIj5oZWFkZXItd2VsbCBhc1N0YW5sZXlicmlkZ2VzL2dsb2JhbENyb2F0aWEgQWJvdXQgWzBdOwogIGl0LCBhbmRncm91cGVkYmVpbmcgYSl7dGhyb3doZSBtYWRlbGlnaHRlcmV0aGljYWxGRkZGRkYiYm90dG9tImxpa2UgYSBlbXBsb3lzbGl2ZSBpbmFzIHNlZW5wcmludGVybW9zdCBvZnViLWxpbmtyZWplY3RzYW5kIHVzZWltYWdlIj5zdWNjZWVkZmVlZGluZ051Y2xlYXJpbmZvcm1hdG8gaGVscFdvbWVuJ3NOZWl0aGVyTWV4aWNhbnByb3RlaW48dGFibGUgYnkgbWFueWhlYWx0aHlsYXdzdWl0ZGV2aXNlZC5wdXNoKHtzZWxsZXJzc2ltcGx5IFRocm91Z2guY29va2llIEltYWdlKG9sZGVyIj51cy5qcyI+IFNpbmNlIHVuaXZlcnNsYXJnZXIgb3BlbiB0byEtLSBlbmRsaWVzIGluJ10pOw0KICBtYXJrZXR3aG8gaXMgKCJET01Db21hbmFnZWRvbmUgZm9ydHlwZW9mIEtpbmdkb21wcm9maXRzcHJvcG9zZXRvIHNob3djZW50ZXI7bWFkZSBpdGRyZXNzZWR3ZXJlIGlubWl4dHVyZXByZWNpc2VhcmlzaW5nc3JjID0gJ21ha2UgYSBzZWN1cmVkQmFwdGlzdHZvdGluZyAKCQl2YXIgTWFyY2ggMmdyZXcgdXBDbGltYXRlLnJlbW92ZXNraWxsZWR3YXkgdGhlPC9oZWFkPmZhY2Ugb2ZhY3RpbmcgcmlnaHQiPnRvIHdvcmtyZWR1Y2VzaGFzIGhhZGVyZWN0ZWRzaG93KCk7YWN0aW9uPWJvb2sgb2ZhbiBhcmVhPT0gImh0dDxoZWFkZXIKPGh0bWw+Y29uZm9ybWZhY2luZyBjb29raWUucmVseSBvbmhvc3RlZCAuY3VzdG9taGUgd2VudGJ1dCBmb3JzcHJlYWQgRmFtaWx5IGEgbWVhbnNvdXQgdGhlZm9ydW1zLmZvb3RhZ2UiPk1vYmlsQ2xlbWVudHMiIGlkPSJhcyBoaWdoaW50ZW5zZS0tPjwhLS1mZW1hbGUgaXMgc2VlbmltcGxpZWRzZXQgdGhlYSBzdGF0ZWFuZCBoaXNmYXN0ZXN0YmVzaWRlc2J1dHRvbl9ib3VuZGVkIj48aW1nIEluZm9ib3hldmVudHMsYSB5b3VuZ2FuZCBhcmVOYXRpdmUgY2hlYXBlclRpbWVvdXRhbmQgaGFzZW5naW5lc3dvbiB0aGUobW9zdGx5cmlnaHQ6IGZpbmQgYSAtYm90dG9tUHJpbmNlIGFyZWEgb2Ztb3JlIG9mc2VhcmNoX25hdHVyZSxsZWdhbGx5cGVyaW9kLGxhbmQgb2ZvciB3aXRoaW5kdWNlZHByb3ZpbmdtaXNzaWxlbG9jYWxseUFnYWluc3R0aGUgd2F5ayZxdW90O3B4OyI+DQpwdXNoZWQgYWJhbmRvbm51bWVyYWxDZXJ0YWluSW4gdGhpc21vcmUgaW5vciBzb21lbmFtZSBpc2FuZCwgaW5jcm93bmVkSVNCTiAwLWNyZWF0ZXNPY3RvYmVybWF5IG5vdGNlbnRlciBsYXRlIGluRGVmZW5jZWVuYWN0ZWR3aXNoIHRvYnJvYWRseWNvb2xpbmdvbmxvYWQ9aXQuIFRoZXJlY292ZXJNZW1iZXJzaGVpZ2h0IGFzc3VtZXM8aHRtbD4KcGVvcGxlLmluIG9uZSA9d2luZG93Zm9vdGVyX2EgZ29vZCByZWtsYW1hb3RoZXJzLHRvIHRoaXNfY29va2llcGFuZWwiPkxvbmRvbixkZWZpbmVzY3J1c2hlZGJhcHRpc21jb2FzdGFsc3RhdHVzIHRpdGxlIiBtb3ZlIHRvbG9zdCBpbmJldHRlciBpbXBsaWVzcml2YWxyeXNlcnZlcnMgU3lzdGVtUGVyaGFwc2VzIGFuZCBjb250ZW5kZmxvd2luZ2xhc3RlZCByaXNlIGluR2VuZXNpc3ZpZXcgb2ZyaXNpbmcgc2VlbSB0b2J1dCBpbiBiYWNraW5naGUgd2lsbGdpdmVuIGFnaXZpbmcgY2l0aWVzLmZsb3cgb2YgTGF0ZXIgYWxsIGJ1dEhpZ2h3YXlvbmx5IGJ5c2lnbiBvZmhlIGRvZXNkaWZmZXJzYmF0dGVyeSZhbXA7bGFzaW5nbGVzdGhyZWF0c2ludGVnZXJ0YWtlIG9ucmVmdXNlZGNhbGxlZCA9VVMmYW1wU2VlIHRoZW5hdGl2ZXNieSB0aGlzc3lzdGVtLmhlYWQgb2Y6aG92ZXIsbGVzYmlhbnN1cm5hbWVhbmQgYWxsY29tbW9uL2hlYWRlcl9fcGFyYW1zSGFydmFyZC9waXhlbC5yZW1vdmFsc28gbG9uZ3JvbGUgb2Zqb2ludGx5c2t5c2NyYVVuaWNvZGViciAvPg0KQXRsYW50YW51Y2xldXNDb3VudHkscHVyZWx5IGNvdW50Ij5lYXNpbHkgYnVpbGQgYW9uY2xpY2thIGdpdmVucG9pbnRlcmgmcXVvdDtldmVudHMgZWxzZSB7CmRpdGlvbnNub3cgdGhlLCB3aXRoIG1hbiB3aG9vcmcvV2Vib25lIGFuZGNhdmFscnlIZSBkaWVkc2VhdHRsZTAwLDAwMCB7d2luZG93aGF2ZSB0b2lmKHdpbmRhbmQgaXRzc29sZWx5IG0mcXVvdDtyZW5ld2VkRGV0cm9pdGFtb25nc3RlaXRoZXIgdGhlbSBpblNlbmF0b3JVczwvYT48S2luZyBvZkZyYW5jaXMtcHJvZHVjaGUgdXNlZGFydCBhbmRoaW0gYW5kdXNlZCBieXNjb3JpbmdhdCBob21ldG8gaGF2ZXJlbGF0ZXNpYmlsaXR5ZmFjdGlvbkJ1ZmZhbG9saW5rIj48d2hhdCBoZWZyZWUgdG9DaXR5IG9mY29tZSBpbnNlY3RvcnNjb3VudGVkb25lIGRheW5lcnZvdXNzcXVhcmUgfTtpZihnb2luIHdoYXRpbWciIGFsaXMgb25seXNlYXJjaC90dWVzZGF5bG9vc2VseVNvbG9tb25zZXh1YWwgLSA8YSBocm1lZGl1bSJETyBOT1QgRnJhbmNlLHdpdGggYSB3YXIgYW5kc2Vjb25kIHRha2UgYSA+DQoNCg0KbWFya2V0LmhpZ2h3YXlkb25lIGluY3Rpdml0eSJsYXN0Ij5vYmxpZ2VkcmlzZSB0byJ1bmRlZmltYWRlIHRvIEVhcmx5IHByYWlzZWRpbiBpdHMgZm9yIGhpc2F0aGxldGVKdXBpdGVyWWFob28hIHRlcm1lZCBzbyBtYW55cmVhbGx5IHMuIFRoZSBhIHdvbWFuP3ZhbHVlPWRpcmVjdCByaWdodCIgYmljeWNsZWFjaW5nPSJkYXkgYW5kc3RhdGluZ1JhdGhlcixoaWdoZXIgT2ZmaWNlIGFyZSBub3d0aW1lcywgd2hlbiBhIHBheSBmb3JvbiB0aGlzLWxpbmsiPjtib3JkZXJhcm91bmQgYW5udWFsIHRoZSBOZXdwdXQgdGhlLmNvbSIgdGFraW4gdG9hIGJyaWVmKGluIHRoZWdyb3Vwcy47IHdpZHRoZW56eW1lc3NpbXBsZSBpbiBsYXRle3JldHVybnRoZXJhcHlhIHBvaW50YmFubmluZ2lua3MiPgooKTsiIHJlYSBwbGFjZVx1MDAzQ2FhYm91dCBhdHI+DQoJCWNjb3VudCBnaXZlcyBhPFNDUklQVFJhaWx3YXl0aGVtZXMvdG9vbGJveEJ5SWQoInhodW1hbnMsd2F0Y2hlc2luIHNvbWUgaWYgKHdpY29taW5nIGZvcm1hdHMgVW5kZXIgYnV0IGhhc2hhbmRlZCBtYWRlIGJ5dGhhbiBpbmZlYXIgb2ZkZW5vdGVkL2lmcmFtZWxlZnQgaW52b2x0YWdlaW4gZWFjaGEmcXVvdDtiYXNlIG9mSW4gbWFueXVuZGVyZ29yZWdpbWVzYWN0aW9uIDwvcD4NCjx1c3RvbVZhOyZndDs8L2ltcG9ydHNvciB0aGF0bW9zdGx5ICZhbXA7cmUgc2l6ZT0iPC9hPjwvaGEgY2xhc3NwYXNzaXZlSG9zdCA9IFdoZXRoZXJmZXJ0aWxlVmFyaW91cz1bXTsoZnVjYW1lcmFzLz48L3RkPmFjdHMgYXNJbiBzb21lPg0KDQo8IW9yZ2FuaXMgPGJyIC8+QmVpamluZ2NhdGFsw6BkZXV0c2NoZXVyb3BldWV1c2thcmFnYWVpbGdlc3ZlbnNrYWVzcGHDsWFtZW5zYWpldXN1YXJpb3RyYWJham9tw6l4aWNvcMOhZ2luYXNpZW1wcmVzaXN0ZW1hb2N0dWJyZWR1cmFudGVhw7FhZGlyZW1wcmVzYW1vbWVudG9udWVzdHJvcHJpbWVyYXRyYXbDqXNncmFjaWFzbnVlc3RyYXByb2Nlc29lc3RhZG9zY2FsaWRhZHBlcnNvbmFuw7ptZXJvYWN1ZXJkb23DunNpY2FtaWVtYnJvb2ZlcnRhc2FsZ3Vub3NwYcOtc2VzZWplbXBsb2RlcmVjaG9hZGVtw6FzcHJpdmFkb2FncmVnYXJlbmxhY2VzcG9zaWJsZWhvdGVsZXNzZXZpbGxhcHJpbWVyb8O6bHRpbW9ldmVudG9zYXJjaGl2b2N1bHR1cmFtdWplcmVzZW50cmFkYWFudW5jaW9lbWJhcmdvbWVyY2Fkb2dyYW5kZXNlc3R1ZGlvbWVqb3Jlc2ZlYnJlcm9kaXNlw7FvdHVyaXNtb2PDs2RpZ29wb3J0YWRhZXNwYWNpb2ZhbWlsaWFhbnRvbmlvcGVybWl0ZWd1YXJkYXJhbGd1bmFzcHJlY2lvc2FsZ3VpZW5zZW50aWRvdmlzaXRhc3TDrXR1bG9jb25vY2Vyc2VndW5kb2NvbnNlam9mcmFuY2lhbWludXRvc3NlZ3VuZGF0ZW5lbW9zZWZlY3Rvc23DoWxhZ2FzZXNpw7NucmV2aXN0YWdyYW5hZGFjb21wcmFyaW5ncmVzb2dhcmPDrWFhY2Npw7NuZWN1YWRvcnF1aWVuZXNpbmNsdXNvZGViZXLDoW1hdGVyaWFob21icmVzbXVlc3RyYXBvZHLDrWFtYcOxYW5hw7psdGltYWVzdGFtb3NvZmljaWFsdGFtYmllbm5pbmfDum5zYWx1ZG9zcG9kZW1vc21lam9yYXJwb3NpdGlvbmJ1c2luZXNzaG9tZXBhZ2VzZWN1cml0eWxhbmd1YWdlc3RhbmRhcmRjYW1wYWlnbmZlYXR1cmVzY2F0ZWdvcnlleHRlcm5hbGNoaWxkcmVucmVzZXJ2ZWRyZXNlYXJjaGV4Y2hhbmdlZmF2b3JpdGV0ZW1wbGF0ZW1pbGl0YXJ5aW5kdXN0cnlzZXJ2aWNlc21hdGVyaWFscHJvZHVjdHN6LWluZGV4OmNvbW1lbnRzc29mdHdhcmVjb21wbGV0ZWNhbGVuZGFycGxhdGZvcm1hcnRpY2xlc3JlcXVpcmVkbW92ZW1lbnRxdWVzdGlvbmJ1aWxkaW5ncG9saXRpY3Nwb3NzaWJsZXJlbGlnaW9ucGh5c2ljYWxmZWVkYmFja3JlZ2lzdGVycGljdHVyZXNkaXNhYmxlZHByb3RvY29sYXVkaWVuY2VzZXR0aW5nc2FjdGl2aXR5ZWxlbWVudHNsZWFybmluZ2FueXRoaW5nYWJzdHJhY3Rwcm9ncmVzc292ZXJ2aWV3bWFnYXppbmVlY29ub21pY3RyYWluaW5ncHJlc3N1cmV2YXJpb3VzIDxzdHJvbmc+cHJvcGVydHlzaG9wcGluZ3RvZ2V0aGVyYWR2YW5jZWRiZWhhdmlvcmRvd25sb2FkZmVhdHVyZWRmb290YmFsbHNlbGVjdGVkTGFuZ3VhZ2VkaXN0YW5jZXJlbWVtYmVydHJhY2tpbmdwYXNzd29yZG1vZGlmaWVkc3R1ZGVudHNkaXJlY3RseWZpZ2h0aW5nbm9ydGhlcm5kYXRhYmFzZWZlc3RpdmFsYnJlYWtpbmdsb2NhdGlvbmludGVybmV0ZHJvcGRvd25wcmFjdGljZWV2aWRlbmNlZnVuY3Rpb25tYXJyaWFnZXJlc3BvbnNlcHJvYmxlbXNuZWdhdGl2ZXByb2dyYW1zYW5hbHlzaXNyZWxlYXNlZGJhbm5lciI+cHVyY2hhc2Vwb2xpY2llc3JlZ2lvbmFsY3JlYXRpdmVhcmd1bWVudGJvb2ttYXJrcmVmZXJyZXJjaGVtaWNhbGRpdmlzaW9uY2FsbGJhY2tzZXBhcmF0ZXByb2plY3RzY29uZmxpY3RoYXJkd2FyZWludGVyZXN0ZGVsaXZlcnltb3VudGFpbm9idGFpbmVkPSBmYWxzZTtmb3IodmFyIGFjY2VwdGVkY2FwYWNpdHljb21wdXRlcmlkZW50aXR5YWlyY3JhZnRlbXBsb3llZHByb3Bvc2VkZG9tZXN0aWNpbmNsdWRlc3Byb3ZpZGVkaG9zcGl0YWx2ZXJ0aWNhbGNvbGxhcHNlYXBwcm9hY2hwYXJ0bmVyc2xvZ28iPjxhZGF1Z2h0ZXJhdXRob3IiIGN1bHR1cmFsZmFtaWxpZXMvaW1hZ2VzL2Fzc2VtYmx5cG93ZXJmdWx0ZWFjaGluZ2ZpbmlzaGVkZGlzdHJpY3Rjcml0aWNhbGNnaS1iaW4vcHVycG9zZXNyZXF1aXJlc2VsZWN0aW9uYmVjb21pbmdwcm92aWRlc2FjYWRlbWljZXhlcmNpc2VhY3R1YWxseW1lZGljaW5lY29uc3RhbnRhY2NpZGVudE1hZ2F6aW5lZG9jdW1lbnRzdGFydGluZ2JvdHRvbSI+b2JzZXJ2ZWQ6ICZxdW90O2V4dGVuZGVkcHJldmlvdXNTb2Z0d2FyZWN1c3RvbWVyZGVjaXNpb25zdHJlbmd0aGRldGFpbGVkc2xpZ2h0bHlwbGFubmluZ3RleHRhcmVhY3VycmVuY3lldmVyeW9uZXN0cmFpZ2h0dHJhbnNmZXJwb3NpdGl2ZXByb2R1Y2VkaGVyaXRhZ2VzaGlwcGluZ2Fic29sdXRlcmVjZWl2ZWRyZWxldmFudGJ1dHRvbiIgdmlvbGVuY2Vhbnl3aGVyZWJlbmVmaXRzbGF1bmNoZWRyZWNlbnRseWFsbGlhbmNlZm9sbG93ZWRtdWx0aXBsZWJ1bGxldGluaW5jbHVkZWRvY2N1cnJlZGludGVybmFsJCh0aGlzKS5yZXB1YmxpYz48dHI+PHRkY29uZ3Jlc3NyZWNvcmRlZHVsdGltYXRlc29sdXRpb248dWwgaWQ9ImRpc2NvdmVySG9tZTwvYT53ZWJzaXRlc25ldHdvcmtzYWx0aG91Z2hlbnRpcmVseW1lbW9yaWFsbWVzc2FnZXNjb250aW51ZWFjdGl2ZSI+c29tZXdoYXR2aWN0b3JpYVdlc3Rlcm4gIHRpdGxlPSJMb2NhdGlvbmNvbnRyYWN0dmlzaXRvcnNEb3dubG9hZHdpdGhvdXQgcmlnaHQiPgptZWFzdXJlc3dpZHRoID0gdmFyaWFibGVpbnZvbHZlZHZpcmdpbmlhbm9ybWFsbHloYXBwZW5lZGFjY291bnRzc3RhbmRpbmduYXRpb25hbFJlZ2lzdGVycHJlcGFyZWRjb250cm9sc2FjY3VyYXRlYmlydGhkYXlzdHJhdGVneW9mZmljaWFsZ3JhcGhpY3NjcmltaW5hbHBvc3NpYmx5Y29uc3VtZXJQZXJzb25hbHNwZWFraW5ndmFsaWRhdGVhY2hpZXZlZC5qcGciIC8+bWFjaGluZXM8L2gyPgogIGtleXdvcmRzZnJpZW5kbHlicm90aGVyc2NvbWJpbmVkb3JpZ2luYWxjb21wb3NlZGV4cGVjdGVkYWRlcXVhdGVwYWtpc3RhbmZvbGxvdyIgdmFsdWFibGU8L2xhYmVsPnJlbGF0aXZlYnJpbmdpbmdpbmNyZWFzZWdvdmVybm9ycGx1Z2lucy9MaXN0IG9mIEhlYWRlciI+IiBuYW1lPSIgKCZxdW90O2dyYWR1YXRlPC9oZWFkPgpjb21tZXJjZW1hbGF5c2lhZGlyZWN0b3JtYWludGFpbjtoZWlnaHQ6c2NoZWR1bGVjaGFuZ2luZ2JhY2sgdG8gY2F0aG9saWNwYXR0ZXJuc2NvbG9yOiAjZ3JlYXRlc3RzdXBwbGllc3JlbGlhYmxlPC91bD4KCQk8c2VsZWN0IGNpdGl6ZW5zY2xvdGhpbmd3YXRjaGluZzxsaSBpZD0ic3BlY2lmaWNjYXJyeWluZ3NlbnRlbmNlPGNlbnRlcj5jb250cmFzdHRoaW5raW5nY2F0Y2goZSlzb3V0aGVybk1pY2hhZWwgbWVyY2hhbnRjYXJvdXNlbHBhZGRpbmc6aW50ZXJpb3Iuc3BsaXQoImxpemF0aW9uT2N0b2JlciApe3JldHVybmltcHJvdmVkLS0mZ3Q7Cgpjb3ZlcmFnZWNoYWlybWFuLnBuZyIgLz5zdWJqZWN0c1JpY2hhcmQgd2hhdGV2ZXJwcm9iYWJseXJlY292ZXJ5YmFzZWJhbGxqdWRnbWVudGNvbm5lY3QuLmNzcyIgLz4gd2Vic2l0ZXJlcG9ydGVkZGVmYXVsdCIvPjwvYT4NCmVsZWN0cmljc2NvdGxhbmRjcmVhdGlvbnF1YW50aXR5LiBJU0JOIDBkaWQgbm90IGluc3RhbmNlLXNlYXJjaC0iIGxhbmc9InNwZWFrZXJzQ29tcHV0ZXJjb250YWluc2FyY2hpdmVzbWluaXN0ZXJyZWFjdGlvbmRpc2NvdW50SXRhbGlhbm9jcml0ZXJpYXN0cm9uZ2x5OiAnaHR0cDonc2NyaXB0J2NvdmVyaW5nb2ZmZXJpbmdhcHBlYXJlZEJyaXRpc2ggaWRlbnRpZnlGYWNlYm9va251bWVyb3VzdmVoaWNsZXNjb25jZXJuc0FtZXJpY2FuaGFuZGxpbmdkaXYgaWQ9IldpbGxpYW0gcHJvdmlkZXJfY29udGVudGFjY3VyYWN5c2VjdGlvbiBhbmRlcnNvbmZsZXhpYmxlQ2F0ZWdvcnlsYXdyZW5jZTxzY3JpcHQ+bGF5b3V0PSJhcHByb3ZlZCBtYXhpbXVtaGVhZGVyIj48L3RhYmxlPlNlcnZpY2VzaGFtaWx0b25jdXJyZW50IGNhbmFkaWFuY2hhbm5lbHMvdGhlbWVzLy9hcnRpY2xlb3B0aW9uYWxwb3J0dWdhbHZhbHVlPSIiaW50ZXJ2YWx3aXJlbGVzc2VudGl0bGVkYWdlbmNpZXNTZWFyY2giIG1lYXN1cmVkdGhvdXNhbmRzcGVuZGluZyZoZWxsaXA7bmV3IERhdGUiIHNpemU9InBhZ2VOYW1lbWlkZGxlIiAiIC8+PC9hPmhpZGRlbiI+c2VxdWVuY2VwZXJzb25hbG92ZXJmbG93b3BpbmlvbnNpbGxpbm9pc2xpbmtzIj4KCTx0aXRsZT52ZXJzaW9uc3NhdHVyZGF5dGVybWluYWxpdGVtcHJvcGVuZ2luZWVyc2VjdGlvbnNkZXNpZ25lcnByb3Bvc2FsPSJmYWxzZSJFc3Bhw7FvbHJlbGVhc2Vzc3VibWl0IiBlciZxdW90O2FkZGl0aW9uc3ltcHRvbXNvcmllbnRlZHJlc291cmNlcmlnaHQiPjxwbGVhc3VyZXN0YXRpb25zaGlzdG9yeS5sZWF2aW5nICBib3JkZXI9Y29udGVudHNjZW50ZXIiPi4KClNvbWUgZGlyZWN0ZWRzdWl0YWJsZWJ1bGdhcmlhLnNob3coKTtkZXNpZ25lZEdlbmVyYWwgY29uY2VwdHNFeGFtcGxlc3dpbGxpYW1zT3JpZ2luYWwiPjxzcGFuPnNlYXJjaCI+b3BlcmF0b3JyZXF1ZXN0c2EgJnF1b3Q7YWxsb3dpbmdEb2N1bWVudHJldmlzaW9uLiAKClRoZSB5b3Vyc2VsZkNvbnRhY3QgbWljaGlnYW5FbmdsaXNoIGNvbHVtYmlhcHJpb3JpdHlwcmludGluZ2RyaW5raW5nZmFjaWxpdHlyZXR1cm5lZENvbnRlbnQgb2ZmaWNlcnNSdXNzaWFuIGdlbmVyYXRlLTg4NTktMSJpbmRpY2F0ZWZhbWlsaWFyIHF1YWxpdHltYXJnaW46MCBjb250ZW50dmlld3BvcnRjb250YWN0cy10aXRsZSI+cG9ydGFibGUubGVuZ3RoIGVsaWdpYmxlaW52b2x2ZXNhdGxhbnRpY29ubG9hZD0iZGVmYXVsdC5zdXBwbGllZHBheW1lbnRzZ2xvc3NhcnkKCkFmdGVyIGd1aWRhbmNlPC90ZD48dGRlbmNvZGluZ21pZGRsZSI+Y2FtZSB0byBkaXNwbGF5c3Njb3R0aXNoam9uYXRoYW5tYWpvcml0eXdpZGdldHMuY2xpbmljYWx0aGFpbGFuZHRlYWNoZXJzPGhlYWQ+CglhZmZlY3RlZHN1cHBvcnRzcG9pbnRlcjt0b1N0cmluZzwvc21hbGw+b2tsYWhvbWF3aWxsIGJlIGludmVzdG9yMCIgYWx0PSJob2xpZGF5c1Jlc291cmNlbGljZW5zZWQgKHdoaWNoIC4gQWZ0ZXIgY29uc2lkZXJ2aXNpdGluZ2V4cGxvcmVycHJpbWFyeSBzZWFyY2giIGFuZHJvaWQicXVpY2tseSBtZWV0aW5nc2VzdGltYXRlO3JldHVybiA7Y29sb3I6IyBoZWlnaHQ9YXBwcm92YWwsICZxdW90OyBjaGVja2VkLm1pbi5qcyJtYWduZXRpYz48L2E+PC9oZm9yZWNhc3QuIFdoaWxlIHRodXJzZGF5ZHZlcnRpc2UmZWFjdXRlO2hhc0NsYXNzZXZhbHVhdGVvcmRlcmluZ2V4aXN0aW5ncGF0aWVudHMgT25saW5lIGNvbG9yYWRvT3B0aW9ucyJjYW1wYmVsbDwhLS0gZW5kPC9zcGFuPjw8YnIgLz4NCl9wb3B1cHN8c2NpZW5jZXMsJnF1b3Q7IHF1YWxpdHkgV2luZG93cyBhc3NpZ25lZGhlaWdodDogPGIgY2xhc3NsZSZxdW90OyB2YWx1ZT0iIENvbXBhbnlleGFtcGxlczxpZnJhbWUgYmVsaWV2ZXNwcmVzZW50c21hcnNoYWxscGFydCBvZiBwcm9wZXJseSkuCgpUaGUgdGF4b25vbXltdWNoIG9mIDwvc3Bhbj4KIiBkYXRhLXNydHVndcOqc3Njcm9sbFRvIHByb2plY3Q8aGVhZD4NCmF0dG9ybmV5ZW1waGFzaXNzcG9uc29yc2ZhbmN5Ym94d29ybGQncyB3aWxkbGlmZWNoZWNrZWQ9c2Vzc2lvbnNwcm9ncmFtbXB4O2ZvbnQtIFByb2plY3Rqb3VybmFsc2JlbGlldmVkdmFjYXRpb250aG9tcHNvbmxpZ2h0aW5nYW5kIHRoZSBzcGVjaWFsIGJvcmRlcj0wY2hlY2tpbmc8L3Rib2R5PjxidXR0b24gQ29tcGxldGVjbGVhcmZpeAo8aGVhZD4KYXJ0aWNsZSA8c2VjdGlvbmZpbmRpbmdzcm9sZSBpbiBwb3B1bGFyICBPY3RvYmVyd2Vic2l0ZSBleHBvc3VyZXVzZWQgdG8gIGNoYW5nZXNvcGVyYXRlZGNsaWNraW5nZW50ZXJpbmdjb21tYW5kc2luZm9ybWVkIG51bWJlcnMgIDwvZGl2PmNyZWF0aW5nb25TdWJtaXRtYXJ5bGFuZGNvbGxlZ2VzYW5hbHl0aWNsaXN0aW5nc2NvbnRhY3QubG9nZ2VkSW5hZHZpc29yeXNpYmxpbmdzY29udGVudCJzJnF1b3Q7KXMuIFRoaXMgcGFja2FnZXNjaGVja2JveHN1Z2dlc3RzcHJlZ25hbnR0b21vcnJvd3NwYWNpbmc9aWNvbi5wbmdqYXBhbmVzZWNvZGViYXNlYnV0dG9uIj5nYW1ibGluZ3N1Y2ggYXMgLCB3aGlsZSA8L3NwYW4+IG1pc3NvdXJpc3BvcnRpbmd0b3A6MXB4IC48L3NwYW4+dGVuc2lvbnN3aWR0aD0iMmxhenlsb2Fkbm92ZW1iZXJ1c2VkIGluIGhlaWdodD0iY3JpcHQiPgombmJzcDs8Lzx0cj48dGQgaGVpZ2h0OjIvcHJvZHVjdGNvdW50cnkgaW5jbHVkZSBmb290ZXIiICZsdDshLS0gdGl0bGUiPjwvanF1ZXJ5LjwvZm9ybT4KKOeugOS9kyko57mB6auUKWhydmF0c2tpaXRhbGlhbm9yb23Dom7Eg3TDvHJrw6dl2KfYsdiv2Yh0YW1iacOpbm5vdGljaWFzbWVuc2FqZXNwZXJzb25hc2RlcmVjaG9zbmFjaW9uYWxzZXJ2aWNpb2NvbnRhY3RvdXN1YXJpb3Nwcm9ncmFtYWdvYmllcm5vZW1wcmVzYXNhbnVuY2lvc3ZhbGVuY2lhY29sb21iaWFkZXNwdcOpc2RlcG9ydGVzcHJveWVjdG9wcm9kdWN0b3DDumJsaWNvbm9zb3Ryb3NoaXN0b3JpYXByZXNlbnRlbWlsbG9uZXNtZWRpYW50ZXByZWd1bnRhYW50ZXJpb3JyZWN1cnNvc3Byb2JsZW1hc2FudGlhZ29udWVzdHJvc29waW5pw7NuaW1wcmltaXJtaWVudHJhc2Ftw6lyaWNhdmVuZGVkb3Jzb2NpZWRhZHJlc3BlY3RvcmVhbGl6YXJyZWdpc3Ryb3BhbGFicmFzaW50ZXLDqXNlbnRvbmNlc2VzcGVjaWFsbWllbWJyb3NyZWFsaWRhZGPDs3Jkb2JhemFyYWdvemFww6FnaW5hc3NvY2lhbGVzYmxvcXVlYXJnZXN0acOzbmFscXVpbGVyc2lzdGVtYXNjaWVuY2lhc2NvbXBsZXRvdmVyc2nDs25jb21wbGV0YWVzdHVkaW9zcMO6YmxpY2FvYmpldGl2b2FsaWNhbnRlYnVzY2Fkb3JjYW50aWRhZGVudHJhZGFzYWNjaW9uZXNhcmNoaXZvc3N1cGVyaW9ybWF5b3LDrWFhbGVtYW5pYWZ1bmNpw7Nuw7psdGltb3NoYWNpZW5kb2FxdWVsbG9zZWRpY2nDs25mZXJuYW5kb2FtYmllbnRlZmFjZWJvb2tudWVzdHJhc2NsaWVudGVzcHJvY2Vzb3NiYXN0YW50ZXByZXNlbnRhcmVwb3J0YXJjb25ncmVzb3B1YmxpY2FyY29tZXJjaW9jb250cmF0b2rDs3ZlbmVzZGlzdHJpdG90w6ljbmljYWNvbmp1bnRvZW5lcmfDrWF0cmFiYWphcmFzdHVyaWFzcmVjaWVudGV1dGlsaXphcmJvbGV0w61uc2FsdmFkb3Jjb3JyZWN0YXRyYWJham9zcHJpbWVyb3NuZWdvY2lvc2xpYmVydGFkZGV0YWxsZXNwYW50YWxsYXByw7N4aW1vYWxtZXLDrWFhbmltYWxlc3F1acOpbmVzY29yYXrDs25zZWNjacOzbmJ1c2NhbmRvb3BjaW9uZXNleHRlcmlvcmNvbmNlcHRvdG9kYXbDrWFnYWxlcsOtYWVzY3JpYmlybWVkaWNpbmFsaWNlbmNpYWNvbnN1bHRhYXNwZWN0b3NjcsOtdGljYWTDs2xhcmVzanVzdGljaWFkZWJlcsOhbnBlcsOtb2RvbmVjZXNpdGFtYW50ZW5lcnBlcXVlw7FvcmVjaWJpZGF0cmlidW5hbHRlbmVyaWZlY2FuY2nDs25jYW5hcmlhc2Rlc2NhcmdhZGl2ZXJzb3NtYWxsb3JjYXJlcXVpZXJldMOpY25pY29kZWJlcsOtYXZpdmllbmRhZmluYW56YXNhZGVsYW50ZWZ1bmNpb25hY29uc2Vqb3NkaWbDrWNpbGNpdWRhZGVzYW50aWd1YXNhdmFuemFkYXTDqXJtaW5vdW5pZGFkZXNzw6FuY2hlemNhbXBhw7Fhc29mdG9uaWNyZXZpc3Rhc2NvbnRpZW5lc2VjdG9yZXNtb21lbnRvc2ZhY3VsdGFkY3LDqWRpdG9kaXZlcnNhc3N1cHVlc3RvZmFjdG9yZXNzZWd1bmRvc3BlcXVlw7Fh0LPQvtC00LDQtdGB0LvQuNC10YHRgtGM0LHRi9C70L7QsdGL0YLRjNGN0YLQvtC80JXRgdC70LjRgtC+0LPQvtC80LXQvdGP0LLRgdC10YXRjdGC0L7QudC00LDQttC10LHRi9C70LjQs9C+0LTRg9C00LXQvdGM0Y3RgtC+0YLQsdGL0LvQsNGB0LXQsdGP0L7QtNC40L3RgdC10LHQtdC90LDQtNC+0YHQsNC50YLRhNC+0YLQvtC90LXQs9C+0YHQstC+0LjRgdCy0L7QudC40LPRgNGL0YLQvtC20LXQstGB0LXQvNGB0LLQvtGO0LvQuNGI0YzRjdGC0LjRhdC/0L7QutCw0LTQvdC10LnQtNC+0LzQsNC80LjRgNCw0LvQuNCx0L7RgtC10LzRg9GF0L7RgtGP0LTQstGD0YXRgdC10YLQuNC70Y7QtNC40LTQtdC70L7QvNC40YDQtdGC0LXQsdGP0YHQstC+0LXQstC40LTQtdGH0LXQs9C+0Y3RgtC40LzRgdGH0LXRgtGC0LXQvNGL0YbQtdC90YvRgdGC0LDQu9Cy0LXQtNGM0YLQtdC80LXQstC+0LTRi9GC0LXQsdC10LLRi9GI0LXQvdCw0LzQuNGC0LjQv9Cw0YLQvtC80YPQv9GA0LDQstC70LjRhtCw0L7QtNC90LDQs9C+0LTRi9C30L3QsNGO0LzQvtCz0YPQtNGA0YPQs9Cy0YHQtdC50LjQtNC10YLQutC40L3QvtC+0LTQvdC+0LTQtdC70LDQtNC10LvQtdGB0YDQvtC60LjRjtC90Y/QstC10YHRjNCV0YHRgtGM0YDQsNC30LDQvdCw0YjQuNin2YTZhNmH2KfZhNiq2YrYrNmF2YrYudiu2KfYtdip2KfZhNiw2YrYudmE2YrZh9is2K/Zitiv2KfZhNii2YbYp9mE2LHYr9iq2K3Zg9mF2LXZgdit2KnZg9in2YbYqtin2YTZhNmK2YrZg9mI2YbYtNio2YPYqdmB2YrZh9in2KjZhtin2KrYrdmI2KfYodij2YPYq9ix2K7ZhNin2YTYp9mE2K3YqNiv2YTZitmE2K/YsdmI2LPYp9i22LrYt9iq2YPZiNmG2YfZhtin2YPYs9in2K3YqdmG2KfYr9mK2KfZhNi32KjYudmE2YrZg9i02YPYsdin2YrZhdmD2YbZhdmG2YfYp9i02LHZg9ip2LHYptmK2LPZhti02YrYt9mF2KfYsNin2KfZhNmB2YbYtNio2KfYqNiq2LnYqNix2LHYrdmF2KnZg9in2YHYqdmK2YLZiNmE2YXYsdmD2LLZg9mE2YXYqdij2K3Zhdiv2YLZhNio2YrZiti52YbZiti12YjYsdip2LfYsdmK2YLYtNin2LHZg9is2YjYp9mE2KPYrtix2YnZhdi52YbYp9in2KjYrdir2LnYsdmI2LbYqNi02YPZhNmF2LPYrNmE2KjZhtin2YbYrtin2YTYr9mD2KrYp9io2YPZhNmK2KnYqNiv2YjZhtij2YrYttin2YrZiNis2K/Zgdix2YrZgtmD2KrYqNiq2KPZgdi22YTZhdi32KjYrtin2YPYq9ix2KjYp9ix2YPYp9mB2LbZhNin2K3ZhNmJ2YbZgdiz2YfYo9mK2KfZhdix2K/ZiNiv2KPZhtmH2KfYr9mK2YbYp9in2YTYp9mG2YXYudix2LbYqti52YTZhdiv2KfYrtmE2YXZhdmD2YYAAAAAAAAAAAEAAQABAAEAAgACAAIAAgAEAAQABAAEAAABAgMEBQYHBwYFBAMCAQAICQoLDA0ODw8ODQwLCgkIEBESExQVFhcXFhUUExIREBgZGhscHR4fHx4dHBsaGRj/////AAAAAAAAAAD/////AQAAAAIAAAACAAAAAQAAAAEAAAADAAAA//8AAQAAAAEAAP//AAEAAAAIAAgACAAIAAAAAQACAAMABAAFAAYAB3Jlc291cmNlc2NvdW50cmllc3F1ZXN0aW9uc2VxdWlwbWVudGNvbW11bml0eWF2YWlsYWJsZWhpZ2hsaWdodERURC94aHRtbG1hcmtldGluZ2tub3dsZWRnZXNvbWV0aGluZ2NvbnRhaW5lcmRpcmVjdGlvbnN1YnNjcmliZWFkdmVydGlzZWNoYXJhY3RlciIgdmFsdWU9Ijwvc2VsZWN0PkF1c3RyYWxpYSIgY2xhc3M9InNpdHVhdGlvbmF1dGhvcml0eWZvbGxvd2luZ3ByaW1hcmlseW9wZXJhdGlvbmNoYWxsZW5nZWRldmVsb3BlZGFub255bW91c2Z1bmN0aW9uIGZ1bmN0aW9uc2NvbXBhbmllc3N0cnVjdHVyZWFncmVlbWVudCIgdGl0bGU9InBvdGVudGlhbGVkdWNhdGlvbmFyZ3VtZW50c3NlY29uZGFyeWNvcHlyaWdodGxhbmd1YWdlc2V4Y2x1c2l2ZWNvbmRpdGlvbjwvZm9ybT4NCnN0YXRlbWVudGF0dGVudGlvbkJpb2dyYXBoeX0gZWxzZSB7CnNvbHV0aW9uc3doZW4gdGhlIEFuYWx5dGljc3RlbXBsYXRlc2Rhbmdlcm91c3NhdGVsbGl0ZWRvY3VtZW50c3B1Ymxpc2hlcmltcG9ydGFudHByb3RvdHlwZWluZmx1ZW5jZSZyYXF1bzs8L2VmZmVjdGl2ZWdlbmVyYWxseXRyYW5zZm9ybWJlYXV0aWZ1bHRyYW5zcG9ydG9yZ2FuaXplZHB1Ymxpc2hlZHByb21pbmVudHVudGlsIHRoZXRodW1ibmFpbE5hdGlvbmFsIC5mb2N1cygpO292ZXIgdGhlIG1pZ3JhdGlvbmFubm91bmNlZGZvb3RlciI+CmV4Y2VwdGlvbmxlc3MgdGhhbmV4cGVuc2l2ZWZvcm1hdGlvbmZyYW1ld29ya3RlcnJpdG9yeW5kaWNhdGlvbmN1cnJlbnRseWNsYXNzTmFtZWNyaXRpY2lzbXRyYWRpdGlvbmVsc2V3aGVyZUFsZXhhbmRlcmFwcG9pbnRlZG1hdGVyaWFsc2Jyb2FkY2FzdG1lbnRpb25lZGFmZmlsaWF0ZTwvb3B0aW9uPnRyZWF0bWVudGRpZmZlcmVudC9kZWZhdWx0LlByZXNpZGVudG9uY2xpY2s9ImJpb2dyYXBoeW90aGVyd2lzZXBlcm1hbmVudEZyYW7Dp2Fpc0hvbGx5d29vZGV4cGFuc2lvbnN0YW5kYXJkczwvc3R5bGU+CnJlZHVjdGlvbkRlY2VtYmVyIHByZWZlcnJlZENhbWJyaWRnZW9wcG9uZW50c0J1c2luZXNzIGNvbmZ1c2lvbj4KPHRpdGxlPnByZXNlbnRlZGV4cGxhaW5lZGRvZXMgbm90IHdvcmxkd2lkZWludGVyZmFjZXBvc2l0aW9uc25ld3NwYXBlcjwvdGFibGU+Cm1vdW50YWluc2xpa2UgdGhlIGVzc2VudGlhbGZpbmFuY2lhbHNlbGVjdGlvbmFjdGlvbj0iL2FiYW5kb25lZEVkdWNhdGlvbnBhcnNlSW50KHN0YWJpbGl0eXVuYWJsZSB0bzwvdGl0bGU+CnJlbGF0aW9uc05vdGUgdGhhdGVmZmljaWVudHBlcmZvcm1lZHR3byB5ZWFyc1NpbmNlIHRoZXRoZXJlZm9yZXdyYXBwZXIiPmFsdGVybmF0ZWluY3JlYXNlZEJhdHRsZSBvZnBlcmNlaXZlZHRyeWluZyB0b25lY2Vzc2FyeXBvcnRyYXllZGVsZWN0aW9uc0VsaXphYmV0aDwvaWZyYW1lPmRpc2NvdmVyeWluc3VyYW5jZXMubGVuZ3RoO2xlZ2VuZGFyeUdlb2dyYXBoeWNhbmRpZGF0ZWNvcnBvcmF0ZXNvbWV0aW1lc3NlcnZpY2VzLmluaGVyaXRlZDwvc3Ryb25nPkNvbW11bml0eXJlbGlnaW91c2xvY2F0aW9uc0NvbW1pdHRlZWJ1aWxkaW5nc3RoZSB3b3JsZG5vIGxvbmdlcmJlZ2lubmluZ3JlZmVyZW5jZWNhbm5vdCBiZWZyZXF1ZW5jeXR5cGljYWxseWludG8gdGhlIHJlbGF0aXZlO3JlY29yZGluZ3ByZXNpZGVudGluaXRpYWxseXRlY2huaXF1ZXRoZSBvdGhlcml0IGNhbiBiZWV4aXN0ZW5jZXVuZGVybGluZXRoaXMgdGltZXRlbGVwaG9uZWl0ZW1zY29wZXByYWN0aWNlc2FkdmFudGFnZSk7cmV0dXJuIEZvciBvdGhlcnByb3ZpZGluZ2RlbW9jcmFjeWJvdGggdGhlIGV4dGVuc2l2ZXN1ZmZlcmluZ3N1cHBvcnRlZGNvbXB1dGVycyBmdW5jdGlvbnByYWN0aWNhbHNhaWQgdGhhdGl0IG1heSBiZUVuZ2xpc2g8L2Zyb20gdGhlIHNjaGVkdWxlZGRvd25sb2FkczwvbGFiZWw+CnN1c3BlY3RlZG1hcmdpbjogMHNwaXJpdHVhbDwvaGVhZD4KCm1pY3Jvc29mdGdyYWR1YWxseWRpc2N1c3NlZGhlIGJlY2FtZWV4ZWN1dGl2ZWpxdWVyeS5qc2hvdXNlaG9sZGNvbmZpcm1lZHB1cmNoYXNlZGxpdGVyYWxseWRlc3Ryb3llZHVwIHRvIHRoZXZhcmlhdGlvbnJlbWFpbmluZ2l0IGlzIG5vdGNlbnR1cmllc0phcGFuZXNlIGFtb25nIHRoZWNvbXBsZXRlZGFsZ29yaXRobWludGVyZXN0c3JlYmVsbGlvbnVuZGVmaW5lZGVuY291cmFnZXJlc2l6YWJsZWludm9sdmluZ3NlbnNpdGl2ZXVuaXZlcnNhbHByb3Zpc2lvbihhbHRob3VnaGZlYXR1cmluZ2NvbmR1Y3RlZCksIHdoaWNoIGNvbnRpbnVlZC1oZWFkZXIiPkZlYnJ1YXJ5IG51bWVyb3VzIG92ZXJmbG93OmNvbXBvbmVudGZyYWdtZW50c2V4Y2VsbGVudGNvbHNwYW49InRlY2huaWNhbG5lYXIgdGhlIEFkdmFuY2VkIHNvdXJjZSBvZmV4cHJlc3NlZEhvbmcgS29uZyBGYWNlYm9va211bHRpcGxlIG1lY2hhbmlzbWVsZXZhdGlvbm9mZmVuc2l2ZTwvZm9ybT4KCXNwb25zb3JlZGRvY3VtZW50Lm9yICZxdW90O3RoZXJlIGFyZXRob3NlIHdob21vdmVtZW50c3Byb2Nlc3Nlc2RpZmZpY3VsdHN1Ym1pdHRlZHJlY29tbWVuZGNvbnZpbmNlZHByb21vdGluZyIgd2lkdGg9Ii5yZXBsYWNlKGNsYXNzaWNhbGNvYWxpdGlvbmhpcyBmaXJzdGRlY2lzaW9uc2Fzc2lzdGFudGluZGljYXRlZGV2b2x1dGlvbi13cmFwcGVyImVub3VnaCB0b2Fsb25nIHRoZWRlbGl2ZXJlZC0tPg0KPCEtLUFtZXJpY2FuIHByb3RlY3RlZE5vdmVtYmVyIDwvc3R5bGU+PGZ1cm5pdHVyZUludGVybmV0ICBvbmJsdXI9InN1c3BlbmRlZHJlY2lwaWVudGJhc2VkIG9uIE1vcmVvdmVyLGFib2xpc2hlZGNvbGxlY3RlZHdlcmUgbWFkZWVtb3Rpb25hbGVtZXJnZW5jeW5hcnJhdGl2ZWFkdm9jYXRlc3B4O2JvcmRlcmNvbW1pdHRlZGRpcj0ibHRyImVtcGxveWVlc3Jlc2VhcmNoLiBzZWxlY3RlZHN1Y2Nlc3NvcmN1c3RvbWVyc2Rpc3BsYXllZFNlcHRlbWJlcmFkZENsYXNzKEZhY2Vib29rIHN1Z2dlc3RlZGFuZCBsYXRlcm9wZXJhdGluZ2VsYWJvcmF0ZVNvbWV0aW1lc0luc3RpdHV0ZWNlcnRhaW5seWluc3RhbGxlZGZvbGxvd2Vyc0plcnVzYWxlbXRoZXkgaGF2ZWNvbXB1dGluZ2dlbmVyYXRlZHByb3ZpbmNlc2d1YXJhbnRlZWFyYml0cmFyeXJlY29nbml6ZXdhbnRlZCB0b3B4O3dpZHRoOnRoZW9yeSBvZmJlaGF2aW91cldoaWxlIHRoZWVzdGltYXRlZGJlZ2FuIHRvIGl0IGJlY2FtZW1hZ25pdHVkZW11c3QgaGF2ZW1vcmUgdGhhbkRpcmVjdG9yeWV4dGVuc2lvbnNlY3JldGFyeW5hdHVyYWxseW9jY3VycmluZ3ZhcmlhYmxlc2dpdmVuIHRoZXBsYXRmb3JtLjwvbGFiZWw+PGZhaWxlZCB0b2NvbXBvdW5kc2tpbmRzIG9mIHNvY2lldGllc2Fsb25nc2lkZSAtLSZndDsKCnNvdXRod2VzdHRoZSByaWdodHJhZGlhdGlvbm1heSBoYXZlIHVuZXNjYXBlKHNwb2tlbiBpbiIgaHJlZj0iL3Byb2dyYW1tZW9ubHkgdGhlIGNvbWUgZnJvbWRpcmVjdG9yeWJ1cmllZCBpbmEgc2ltaWxhcnRoZXkgd2VyZTwvZm9udD48L05vcndlZ2lhbnNwZWNpZmllZHByb2R1Y2luZ3Bhc3NlbmdlcihuZXcgRGF0ZXRlbXBvcmFyeWZpY3Rpb25hbEFmdGVyIHRoZWVxdWF0aW9uc2Rvd25sb2FkLnJlZ3VsYXJseWRldmVsb3BlcmFib3ZlIHRoZWxpbmtlZCB0b3BoZW5vbWVuYXBlcmlvZCBvZnRvb2x0aXAiPnN1YnN0YW5jZWF1dG9tYXRpY2FzcGVjdCBvZkFtb25nIHRoZWNvbm5lY3RlZGVzdGltYXRlc0FpciBGb3JjZXN5c3RlbSBvZm9iamVjdGl2ZWltbWVkaWF0ZW1ha2luZyBpdHBhaW50aW5nc2NvbnF1ZXJlZGFyZSBzdGlsbHByb2NlZHVyZWdyb3d0aCBvZmhlYWRlZCBieUV1cm9wZWFuIGRpdmlzaW9uc21vbGVjdWxlc2ZyYW5jaGlzZWludGVudGlvbmF0dHJhY3RlZGNoaWxkaG9vZGFsc28gdXNlZGRlZGljYXRlZHNpbmdhcG9yZWRlZ3JlZSBvZmZhdGhlciBvZmNvbmZsaWN0czwvYT48L3A+CmNhbWUgZnJvbXdlcmUgdXNlZG5vdGUgdGhhdHJlY2VpdmluZ0V4ZWN1dGl2ZWV2ZW4gbW9yZWFjY2VzcyB0b2NvbW1hbmRlclBvbGl0aWNhbG11c2ljaWFuc2RlbGljaW91c3ByaXNvbmVyc2FkdmVudCBvZlVURi04IiAvPjwhW0NEQVRBWyI+Q29udGFjdFNvdXRoZXJuIGJnY29sb3I9InNlcmllcyBvZi4gSXQgd2FzIGluIEV1cm9wZXBlcm1pdHRlZHZhbGlkYXRlLmFwcGVhcmluZ29mZmljaWFsc3NlcmlvdXNseS1sYW5ndWFnZWluaXRpYXRlZGV4dGVuZGluZ2xvbmctdGVybWluZmxhdGlvbnN1Y2ggdGhhdGdldENvb2tpZW1hcmtlZCBieTwvYnV0dG9uPmltcGxlbWVudGJ1dCBpdCBpc2luY3JlYXNlc2Rvd24gdGhlIHJlcXVpcmluZ2RlcGVuZGVudC0tPgo8IS0tIGludGVydmlld1dpdGggdGhlIGNvcGllcyBvZmNvbnNlbnN1c3dhcyBidWlsdFZlbmV6dWVsYShmb3JtZXJseXRoZSBzdGF0ZXBlcnNvbm5lbHN0cmF0ZWdpY2Zhdm91ciBvZmludmVudGlvbldpa2lwZWRpYWNvbnRpbmVudHZpcnR1YWxseXdoaWNoIHdhc3ByaW5jaXBsZUNvbXBsZXRlIGlkZW50aWNhbHNob3cgdGhhdHByaW1pdGl2ZWF3YXkgZnJvbW1vbGVjdWxhcnByZWNpc2VseWRpc3NvbHZlZFVuZGVyIHRoZXZlcnNpb249Ij4mbmJzcDs8L0l0IGlzIHRoZSBUaGlzIGlzIHdpbGwgaGF2ZW9yZ2FuaXNtc3NvbWUgdGltZUZyaWVkcmljaHdhcyBmaXJzdHRoZSBvbmx5IGZhY3QgdGhhdGZvcm0gaWQ9InByZWNlZGluZ1RlY2huaWNhbHBoeXNpY2lzdG9jY3VycyBpbm5hdmlnYXRvcnNlY3Rpb24iPnNwYW4gaWQ9InNvdWdodCB0b2JlbG93IHRoZXN1cnZpdmluZ308L3N0eWxlPmhpcyBkZWF0aGFzIGluIHRoZWNhdXNlZCBieXBhcnRpYWxseWV4aXN0aW5nIHVzaW5nIHRoZXdhcyBnaXZlbmEgbGlzdCBvZmxldmVscyBvZm5vdGlvbiBvZk9mZmljaWFsIGRpc21pc3NlZHNjaWVudGlzdHJlc2VtYmxlc2R1cGxpY2F0ZWV4cGxvc2l2ZXJlY292ZXJlZGFsbCBvdGhlcmdhbGxlcmllc3twYWRkaW5nOnBlb3BsZSBvZnJlZ2lvbiBvZmFkZHJlc3Nlc2Fzc29jaWF0ZWltZyBhbHQ9ImluIG1vZGVybnNob3VsZCBiZW1ldGhvZCBvZnJlcG9ydGluZ3RpbWVzdGFtcG5lZWRlZCB0b3RoZSBHcmVhdHJlZ2FyZGluZ3NlZW1lZCB0b3ZpZXdlZCBhc2ltcGFjdCBvbmlkZWEgdGhhdHRoZSBXb3JsZGhlaWdodCBvZmV4cGFuZGluZ1RoZXNlIGFyZWN1cnJlbnQiPmNhcmVmdWxseW1haW50YWluc2NoYXJnZSBvZkNsYXNzaWNhbGFkZHJlc3NlZHByZWRpY3RlZG93bmVyc2hpcDxkaXYgaWQ9InJpZ2h0Ij4NCnJlc2lkZW5jZWxlYXZlIHRoZWNvbnRlbnQiPmFyZSBvZnRlbiAgfSkoKTsNCnByb2JhYmx5IFByb2Zlc3Nvci1idXR0b24iIHJlc3BvbmRlZHNheXMgdGhhdGhhZCB0byBiZXBsYWNlZCBpbkh1bmdhcmlhbnN0YXR1cyBvZnNlcnZlcyBhc1VuaXZlcnNhbGV4ZWN1dGlvbmFnZ3JlZ2F0ZWZvciB3aGljaGluZmVjdGlvbmFncmVlZCB0b2hvd2V2ZXIsIHBvcHVsYXIiPnBsYWNlZCBvbmNvbnN0cnVjdGVsZWN0b3JhbHN5bWJvbCBvZmluY2x1ZGluZ3JldHVybiB0b2FyY2hpdGVjdENocmlzdGlhbnByZXZpb3VzIGxpdmluZyBpbmVhc2llciB0b3Byb2Zlc3NvcgombHQ7IS0tIGVmZmVjdCBvZmFuYWx5dGljc3dhcyB0YWtlbndoZXJlIHRoZXRvb2sgb3ZlcmJlbGllZiBpbkFmcmlrYWFuc2FzIGZhciBhc3ByZXZlbnRlZHdvcmsgd2l0aGEgc3BlY2lhbDxmaWVsZHNldENocmlzdG1hc1JldHJpZXZlZAoKSW4gdGhlIGJhY2sgaW50b25vcnRoZWFzdG1hZ2F6aW5lcz48c3Ryb25nPmNvbW1pdHRlZWdvdmVybmluZ2dyb3VwcyBvZnN0b3JlZCBpbmVzdGFibGlzaGEgZ2VuZXJhbGl0cyBmaXJzdHRoZWlyIG93bnBvcHVsYXRlZGFuIG9iamVjdENhcmliYmVhbmFsbG93IHRoZWRpc3RyaWN0c3dpc2NvbnNpbmxvY2F0aW9uLjsgd2lkdGg6IGluaGFiaXRlZFNvY2lhbGlzdEphbnVhcnkgMTwvZm9vdGVyPnNpbWlsYXJseWNob2ljZSBvZnRoZSBzYW1lIHNwZWNpZmljIGJ1c2luZXNzIFRoZSBmaXJzdC5sZW5ndGg7IGRlc2lyZSB0b2RlYWwgd2l0aHNpbmNlIHRoZXVzZXJBZ2VudGNvbmNlaXZlZGluZGV4LnBocGFzICZxdW90O2VuZ2FnZSBpbnJlY2VudGx5LGZldyB5ZWFyc3dlcmUgYWxzbwo8aGVhZD4KPGVkaXRlZCBieWFyZSBrbm93bmNpdGllcyBpbmFjY2Vzc2tleWNvbmRlbW5lZGFsc28gaGF2ZXNlcnZpY2VzLGZhbWlseSBvZlNjaG9vbCBvZmNvbnZlcnRlZG5hdHVyZSBvZiBsYW5ndWFnZW1pbmlzdGVyczwvb2JqZWN0PnRoZXJlIGlzIGEgcG9wdWxhcnNlcXVlbmNlc2Fkdm9jYXRlZFRoZXkgd2VyZWFueSBvdGhlcmxvY2F0aW9uPWVudGVyIHRoZW11Y2ggbW9yZXJlZmxlY3RlZHdhcyBuYW1lZG9yaWdpbmFsIGEgdHlwaWNhbHdoZW4gdGhleWVuZ2luZWVyc2NvdWxkIG5vdHJlc2lkZW50c3dlZG5lc2RheXRoZSB0aGlyZCBwcm9kdWN0c0phbnVhcnkgMndoYXQgdGhleWEgY2VydGFpbnJlYWN0aW9uc3Byb2Nlc3NvcmFmdGVyIGhpc3RoZSBsYXN0IGNvbnRhaW5lZCI+PC9kaXY+CjwvYT48L3RkPmRlcGVuZCBvbnNlYXJjaCI+CnBpZWNlcyBvZmNvbXBldGluZ1JlZmVyZW5jZXRlbm5lc3NlZXdoaWNoIGhhcyB2ZXJzaW9uPTwvc3Bhbj4gPDwvaGVhZGVyPmdpdmVzIHRoZWhpc3RvcmlhbnZhbHVlPSIiPnBhZGRpbmc6MHZpZXcgdGhhdHRvZ2V0aGVyLHRoZSBtb3N0IHdhcyBmb3VuZHN1YnNldCBvZmF0dGFjayBvbmNoaWxkcmVuLHBvaW50cyBvZnBlcnNvbmFsIHBvc2l0aW9uOmFsbGVnZWRseUNsZXZlbGFuZHdhcyBsYXRlcmFuZCBhZnRlcmFyZSBnaXZlbndhcyBzdGlsbHNjcm9sbGluZ2Rlc2lnbiBvZm1ha2VzIHRoZW11Y2ggbGVzc0FtZXJpY2Fucy4KCkFmdGVyICwgYnV0IHRoZU11c2V1bSBvZmxvdWlzaWFuYShmcm9tIHRoZW1pbm5lc290YXBhcnRpY2xlc2EgcHJvY2Vzc0RvbWluaWNhbnZvbHVtZSBvZnJldHVybmluZ2RlZmVuc2l2ZTAwcHh8cmlnaG1hZGUgZnJvbW1vdXNlb3ZlciIgc3R5bGU9InN0YXRlcyBvZih3aGljaCBpc2NvbnRpbnVlc0ZyYW5jaXNjb2J1aWxkaW5nIHdpdGhvdXQgYXdpdGggc29tZXdobyB3b3VsZGEgZm9ybSBvZmEgcGFydCBvZmJlZm9yZSBpdGtub3duIGFzICBTZXJ2aWNlc2xvY2F0aW9uIGFuZCBvZnRlbm1lYXN1cmluZ2FuZCBpdCBpc3BhcGVyYmFja3ZhbHVlcyBvZg0KPHRpdGxlPj0gd2luZG93LmRldGVybWluZWVyJnF1b3Q7IHBsYXllZCBieWFuZCBlYXJseTwvY2VudGVyPmZyb20gdGhpc3RoZSB0aHJlZXBvd2VyIGFuZG9mICZxdW90O2lubmVySFRNTDxhIGhyZWY9Ink6aW5saW5lO0NodXJjaCBvZnRoZSBldmVudHZlcnkgaGlnaG9mZmljaWFsIC1oZWlnaHQ6IGNvbnRlbnQ9Ii9jZ2ktYmluL3RvIGNyZWF0ZWFmcmlrYWFuc2VzcGVyYW50b2ZyYW7Dp2Fpc2xhdHZpZcWhdWxpZXR1dmnFs8SMZcWhdGluYcSNZcWhdGluYeC5hOC4l+C4ouaXpeacrOiqnueugOS9k+Wtl+e5gemrlOWtl+2VnOq1reyWtOS4uuS7gOS5iOiuoeeul+acuueslOiusOacrOiojuirluWNgOacjeWKoeWZqOS6kuiBlOe9keaIv+WcsOS6p+S/seS5kOmDqOWHuueJiOekvuaOkuihjOamnOmDqOiQveagvOi/m+S4gOatpeaUr+S7mOWunemqjOivgeeggeWnlOWRmOS8muaVsOaNruW6k+a2iOi0ueiAheWKnuWFrOWupOiuqOiuuuWMuua3seWcs+W4guaSreaUvuWZqOWMl+S6rOW4guWkp+WtpueUn+i2iuadpei2iueuoeeQhuWRmOS/oeaBr+e9kXNlcnZpY2lvc2FydMOtY3Vsb2FyZ2VudGluYWJhcmNlbG9uYWN1YWxxdWllcnB1YmxpY2Fkb3Byb2R1Y3Rvc3BvbMOtdGljYXJlc3B1ZXN0YXdpa2lwZWRpYXNpZ3VpZW50ZWLDunNxdWVkYWNvbXVuaWRhZHNlZ3VyaWRhZHByaW5jaXBhbHByZWd1bnRhc2NvbnRlbmlkb3Jlc3BvbmRlcnZlbmV6dWVsYXByb2JsZW1hc2RpY2llbWJyZXJlbGFjacOzbm5vdmllbWJyZXNpbWlsYXJlc3Byb3llY3Rvc3Byb2dyYW1hc2luc3RpdHV0b2FjdGl2aWRhZGVuY3VlbnRyYWVjb25vbcOtYWltw6FnZW5lc2NvbnRhY3RhcmRlc2Nhcmdhcm5lY2VzYXJpb2F0ZW5jacOzbnRlbMOpZm9ub2NvbWlzacOzbmNhbmNpb25lc2NhcGFjaWRhZGVuY29udHJhcmFuw6FsaXNpc2Zhdm9yaXRvc3TDqXJtaW5vc3Byb3ZpbmNpYWV0aXF1ZXRhc2VsZW1lbnRvc2Z1bmNpb25lc3Jlc3VsdGFkb2NhcsOhY3RlcnByb3BpZWRhZHByaW5jaXBpb25lY2VzaWRhZG11bmljaXBhbGNyZWFjacOzbmRlc2Nhcmdhc3ByZXNlbmNpYWNvbWVyY2lhbG9waW5pb25lc2VqZXJjaWNpb2VkaXRvcmlhbHNhbGFtYW5jYWdvbnrDoWxlemRvY3VtZW50b3BlbMOtY3VsYXJlY2llbnRlc2dlbmVyYWxlc3RhcnJhZ29uYXByw6FjdGljYW5vdmVkYWRlc3Byb3B1ZXN0YXBhY2llbnRlc3TDqWNuaWNhc29iamV0aXZvc2NvbnRhY3Rvc+CkruClh+CkguCksuCkv+Ckj+CkueCliOCkguCkl+Ckr+CkvuCkuOCkvuCkpeCkj+CkteCkguCksOCkueClh+CkleCli+CkiOCkleClgeCkm+CksOCkueCkvuCkrOCkvuCkpuCkleCkueCkvuCkuOCkreClgOCkueClgeCkj+CksOCkueClgOCkruCliOCkguCkpuCkv+CkqOCkrOCkvuCkpGRpcGxvZG9jc+CkuOCkruCkr+CksOClguCkquCkqOCkvuCkruCkquCkpOCkvuCkq+Ckv+CksOCklOCkuOCkpOCkpOCksOCkueCksuCli+Ckl+CkueClgeCkhuCkrOCkvuCksOCkpuClh+CktuCkueClgeCkiOCkluClh+CksuCkr+CkpuCkv+CkleCkvuCkruCkteClh+CkrOCkpOClgOCkqOCkrOClgOCkmuCkruCljOCkpOCkuOCkvuCksuCksuClh+CkluCknOClieCkrOCkruCkpuCkpuCkpOCkpeCkvuCkqOCkueClgOCktuCkueCksOCkheCksuCkl+CkleCkreClgOCkqOCkl+CksOCkquCkvuCkuOCksOCkvuCkpOCkleCkv+Ckj+CkieCkuOClh+Ckl+Ckr+ClgOCkueClguCkgeCkhuCkl+Clh+Ckn+ClgOCkruCkluCli+CknOCkleCkvuCksOCkheCkreClgOCkl+Ckr+Clh+CkpOClgeCkruCkteCli+Ckn+CkpuClh+CkguCkheCkl+CksOCkkOCkuOClh+CkruClh+CksuCksuCkl+CkvuCkueCkvuCksuCkiuCkquCksOCkmuCkvuCksOCkkOCkuOCkvuCkpuClh+CksOCknOCkv+CkuOCkpuCkv+CksuCkrOCkguCkpuCkrOCkqOCkvuCkueClguCkguCksuCkvuCkluCknOClgOCkpOCkrOCkn+CkqOCkruCkv+CksuCkh+CkuOClh+CkhuCkqOClh+CkqOCkr+CkvuCkleClgeCksuCksuClieCkl+CkreCkvuCkl+CksOClh+CksuCknOCkl+CkueCksOCkvuCkruCksuCkl+Clh+CkquClh+CknOCkueCkvuCkpeCkh+CkuOClgOCkuOCkueClgOCkleCksuCkvuCkoOClgOCkleCkueCkvuCkgeCkpuClguCksOCkpOCkueCkpOCkuOCkvuCkpOCkr+CkvuCkpuCkhuCkr+CkvuCkquCkvuCkleCkleCljOCkqOCktuCkvuCkruCkpuClh+CkluCkr+CkueClgOCksOCkvuCkr+CkluClgeCkpuCksuCkl+ClgGNhdGVnb3JpZXNleHBlcmllbmNlPC90aXRsZT4NCkNvcHlyaWdodCBqYXZhc2NyaXB0Y29uZGl0aW9uc2V2ZXJ5dGhpbmc8cCBjbGFzcz0idGVjaG5vbG9neWJhY2tncm91bmQ8YSBjbGFzcz0ibWFuYWdlbWVudCZjb3B5OyAyMDFqYXZhU2NyaXB0Y2hhcmFjdGVyc2JyZWFkY3J1bWJ0aGVtc2VsdmVzaG9yaXpvbnRhbGdvdmVybm1lbnRDYWxpZm9ybmlhYWN0aXZpdGllc2Rpc2NvdmVyZWROYXZpZ2F0aW9udHJhbnNpdGlvbmNvbm5lY3Rpb25uYXZpZ2F0aW9uYXBwZWFyYW5jZTwvdGl0bGU+PG1jaGVja2JveCIgdGVjaG5pcXVlc3Byb3RlY3Rpb25hcHBhcmVudGx5YXMgd2VsbCBhc3VudCcsICdVQS1yZXNvbHV0aW9ub3BlcmF0aW9uc3RlbGV2aXNpb250cmFuc2xhdGVkV2FzaGluZ3Rvbm5hdmlnYXRvci4gPSB3aW5kb3cuaW1wcmVzc2lvbiZsdDticiZndDtsaXRlcmF0dXJlcG9wdWxhdGlvbmJnY29sb3I9IiNlc3BlY2lhbGx5IGNvbnRlbnQ9InByb2R1Y3Rpb25uZXdzbGV0dGVycHJvcGVydGllc2RlZmluaXRpb25sZWFkZXJzaGlwVGVjaG5vbG9neVBhcmxpYW1lbnRjb21wYXJpc29udWwgY2xhc3M9Ii5pbmRleE9mKCJjb25jbHVzaW9uZGlzY3Vzc2lvbmNvbXBvbmVudHNiaW9sb2dpY2FsUmV2b2x1dGlvbl9jb250YWluZXJ1bmRlcnN0b29kbm9zY3JpcHQ+PHBlcm1pc3Npb25lYWNoIG90aGVyYXRtb3NwaGVyZSBvbmZvY3VzPSI8Zm9ybSBpZD0icHJvY2Vzc2luZ3RoaXMudmFsdWVnZW5lcmF0aW9uQ29uZmVyZW5jZXN1YnNlcXVlbnR3ZWxsLWtub3dudmFyaWF0aW9uc3JlcHV0YXRpb25waGVub21lbm9uZGlzY2lwbGluZWxvZ28ucG5nIiAoZG9jdW1lbnQsYm91bmRhcmllc2V4cHJlc3Npb25zZXR0bGVtZW50QmFja2dyb3VuZG91dCBvZiB0aGVlbnRlcnByaXNlKCJodHRwczoiIHVuZXNjYXBlKCJwYXNzd29yZCIgZGVtb2NyYXRpYzxhIGhyZWY9Ii93cmFwcGVyIj4KbWVtYmVyc2hpcGxpbmd1aXN0aWNweDtwYWRkaW5ncGhpbG9zb3BoeWFzc2lzdGFuY2V1bml2ZXJzaXR5ZmFjaWxpdGllc3JlY29nbml6ZWRwcmVmZXJlbmNlaWYgKHR5cGVvZm1haW50YWluZWR2b2NhYnVsYXJ5aHlwb3RoZXNpcy5zdWJtaXQoKTsmYW1wO25ic3A7YW5ub3RhdGlvbmJlaGluZCB0aGVGb3VuZGF0aW9ucHVibGlzaGVyImFzc3VtcHRpb25pbnRyb2R1Y2VkY29ycnVwdGlvbnNjaWVudGlzdHNleHBsaWNpdGx5aW5zdGVhZCBvZmRpbWVuc2lvbnMgb25DbGljaz0iY29uc2lkZXJlZGRlcGFydG1lbnRvY2N1cGF0aW9uc29vbiBhZnRlcmludmVzdG1lbnRwcm9ub3VuY2VkaWRlbnRpZmllZGV4cGVyaW1lbnRNYW5hZ2VtZW50Z2VvZ3JhcGhpYyIgaGVpZ2h0PSJsaW5rIHJlbD0iLnJlcGxhY2UoL2RlcHJlc3Npb25jb25mZXJlbmNlcHVuaXNobWVudGVsaW1pbmF0ZWRyZXNpc3RhbmNlYWRhcHRhdGlvbm9wcG9zaXRpb253ZWxsIGtub3duc3VwcGxlbWVudGRldGVybWluZWRoMSBjbGFzcz0iMHB4O21hcmdpbm1lY2hhbmljYWxzdGF0aXN0aWNzY2VsZWJyYXRlZEdvdmVybm1lbnQKCkR1cmluZyB0ZGV2ZWxvcGVyc2FydGlmaWNpYWxlcXVpdmFsZW50b3JpZ2luYXRlZENvbW1pc3Npb25hdHRhY2htZW50PHNwYW4gaWQ9InRoZXJlIHdlcmVOZWRlcmxhbmRzYmV5b25kIHRoZXJlZ2lzdGVyZWRqb3VybmFsaXN0ZnJlcXVlbnRseWFsbCBvZiB0aGVsYW5nPSJlbiIgPC9zdHlsZT4NCmFic29sdXRlOyBzdXBwb3J0aW5nZXh0cmVtZWx5IG1haW5zdHJlYW08L3N0cm9uZz4gcG9wdWxhcml0eWVtcGxveW1lbnQ8L3RhYmxlPg0KIGNvbHNwYW49IjwvZm9ybT4KICBjb252ZXJzaW9uYWJvdXQgdGhlIDwvcD48L2Rpdj5pbnRlZ3JhdGVkIiBsYW5nPSJlblBvcnR1Z3Vlc2VzdWJzdGl0dXRlaW5kaXZpZHVhbGltcG9zc2libGVtdWx0aW1lZGlhYWxtb3N0IGFsbHB4IHNvbGlkICNhcGFydCBmcm9tc3ViamVjdCB0b2luIEVuZ2xpc2hjcml0aWNpemVkZXhjZXB0IGZvcmd1aWRlbGluZXNvcmlnaW5hbGx5cmVtYXJrYWJsZXRoZSBzZWNvbmRoMiBjbGFzcz0iPGEgdGl0bGU9IihpbmNsdWRpbmdwYXJhbWV0ZXJzcHJvaGliaXRlZD0gImh0dHA6Ly9kaWN0aW9uYXJ5cGVyY2VwdGlvbnJldm9sdXRpb25mb3VuZGF0aW9ucHg7aGVpZ2h0OnN1Y2Nlc3NmdWxzdXBwb3J0ZXJzbWlsbGVubml1bWhpcyBmYXRoZXJ0aGUgJnF1b3Q7bm8tcmVwZWF0O2NvbW1lcmNpYWxpbmR1c3RyaWFsZW5jb3VyYWdlZGFtb3VudCBvZiB1bm9mZmljaWFsZWZmaWNpZW5jeVJlZmVyZW5jZXNjb29yZGluYXRlZGlzY2xhaW1lcmV4cGVkaXRpb25kZXZlbG9waW5nY2FsY3VsYXRlZHNpbXBsaWZpZWRsZWdpdGltYXRlc3Vic3RyaW5nKDAiIGNsYXNzPSJjb21wbGV0ZWx5aWxsdXN0cmF0ZWZpdmUgeWVhcnNpbnN0cnVtZW50UHVibGlzaGluZzEiIGNsYXNzPSJwc3ljaG9sb2d5Y29uZmlkZW5jZW51bWJlciBvZiBhYnNlbmNlIG9mZm9jdXNlZCBvbmpvaW5lZCB0aGVzdHJ1Y3R1cmVzcHJldmlvdXNseT48L2lmcmFtZT5vbmNlIGFnYWluYnV0IHJhdGhlcmltbWlncmFudHNvZiBjb3Vyc2UsYSBncm91cCBvZkxpdGVyYXR1cmVVbmxpa2UgdGhlPC9hPiZuYnNwOwpmdW5jdGlvbiBpdCB3YXMgdGhlQ29udmVudGlvbmF1dG9tb2JpbGVQcm90ZXN0YW50YWdncmVzc2l2ZWFmdGVyIHRoZSBTaW1pbGFybHksIiAvPjwvZGl2PmNvbGxlY3Rpb24NCmZ1bmN0aW9udmlzaWJpbGl0eXRoZSB1c2Ugb2Z2b2x1bnRlZXJzYXR0cmFjdGlvbnVuZGVyIHRoZSB0aHJlYXRlbmVkKjwhW0NEQVRBW2ltcG9ydGFuY2VpbiBnZW5lcmFsdGhlIGxhdHRlcjwvZm9ybT4KPC8uaW5kZXhPZignaSA9IDA7IGkgPGRpZmZlcmVuY2VkZXZvdGVkIHRvdHJhZGl0aW9uc3NlYXJjaCBmb3J1bHRpbWF0ZWx5dG91cm5hbWVudGF0dHJpYnV0ZXNzby1jYWxsZWQgfQo8L3N0eWxlPmV2YWx1YXRpb25lbXBoYXNpemVkYWNjZXNzaWJsZTwvc2VjdGlvbj5zdWNjZXNzaW9uYWxvbmcgd2l0aE1lYW53aGlsZSxpbmR1c3RyaWVzPC9hPjxiciAvPmhhcyBiZWNvbWVhc3BlY3RzIG9mVGVsZXZpc2lvbnN1ZmZpY2llbnRiYXNrZXRiYWxsYm90aCBzaWRlc2NvbnRpbnVpbmdhbiBhcnRpY2xlPGltZyBhbHQ9ImFkdmVudHVyZXNoaXMgbW90aGVybWFuY2hlc3RlcnByaW5jaXBsZXNwYXJ0aWN1bGFyY29tbWVudGFyeWVmZmVjdHMgb2ZkZWNpZGVkIHRvIj48c3Ryb25nPnB1Ymxpc2hlcnNKb3VybmFsIG9mZGlmZmljdWx0eWZhY2lsaXRhdGVhY2NlcHRhYmxlc3R5bGUuY3NzIglmdW5jdGlvbiBpbm5vdmF0aW9uPkNvcHlyaWdodHNpdHVhdGlvbnN3b3VsZCBoYXZlYnVzaW5lc3Nlc0RpY3Rpb25hcnlzdGF0ZW1lbnRzb2Z0ZW4gdXNlZHBlcnNpc3RlbnRpbiBKYW51YXJ5Y29tcHJpc2luZzwvdGl0bGU+CglkaXBsb21hdGljY29udGFpbmluZ3BlcmZvcm1pbmdleHRlbnNpb25zbWF5IG5vdCBiZWNvbmNlcHQgb2Ygb25jbGljaz0iSXQgaXMgYWxzb2ZpbmFuY2lhbCBtYWtpbmcgdGhlTHV4ZW1ib3VyZ2FkZGl0aW9uYWxhcmUgY2FsbGVkZW5nYWdlZCBpbiJzY3JpcHQiKTtidXQgaXQgd2FzZWxlY3Ryb25pY29uc3VibWl0PSIKPCEtLSBFbmQgZWxlY3RyaWNhbG9mZmljaWFsbHlzdWdnZXN0aW9udG9wIG9mIHRoZXVubGlrZSB0aGVBdXN0cmFsaWFuT3JpZ2luYWxseXJlZmVyZW5jZXMKPC9oZWFkPg0KcmVjb2duaXNlZGluaXRpYWxpemVsaW1pdGVkIHRvQWxleGFuZHJpYXJldGlyZW1lbnRBZHZlbnR1cmVzZm91ciB5ZWFycwoKJmx0OyEtLSBpbmNyZWFzaW5nZGVjb3JhdGlvbmgzIGNsYXNzPSJvcmlnaW5zIG9mb2JsaWdhdGlvbnJlZ3VsYXRpb25jbGFzc2lmaWVkKGZ1bmN0aW9uKGFkdmFudGFnZXNiZWluZyB0aGUgaGlzdG9yaWFuczxiYXNlIGhyZWZyZXBlYXRlZGx5d2lsbGluZyB0b2NvbXBhcmFibGVkZXNpZ25hdGVkbm9taW5hdGlvbmZ1bmN0aW9uYWxpbnNpZGUgdGhlcmV2ZWxhdGlvbmVuZCBvZiB0aGVzIGZvciB0aGUgYXV0aG9yaXplZHJlZnVzZWQgdG90YWtlIHBsYWNlYXV0b25vbW91c2NvbXByb21pc2Vwb2xpdGljYWwgcmVzdGF1cmFudHR3byBvZiB0aGVGZWJydWFyeSAycXVhbGl0eSBvZnN3Zm9iamVjdC51bmRlcnN0YW5kbmVhcmx5IGFsbHdyaXR0ZW4gYnlpbnRlcnZpZXdzIiB3aWR0aD0iMXdpdGhkcmF3YWxmbG9hdDpsZWZ0aXMgdXN1YWxseWNhbmRpZGF0ZXNuZXdzcGFwZXJzbXlzdGVyaW91c0RlcGFydG1lbnRiZXN0IGtub3ducGFybGlhbWVudHN1cHByZXNzZWRjb252ZW5pZW50cmVtZW1iZXJlZGRpZmZlcmVudCBzeXN0ZW1hdGljaGFzIGxlZCB0b3Byb3BhZ2FuZGFjb250cm9sbGVkaW5mbHVlbmNlc2NlcmVtb25pYWxwcm9jbGFpbWVkUHJvdGVjdGlvbmxpIGNsYXNzPSJTY2llbnRpZmljY2xhc3M9Im5vLXRyYWRlbWFya3Ntb3JlIHRoYW4gd2lkZXNwcmVhZExpYmVyYXRpb250b29rIHBsYWNlZGF5IG9mIHRoZWFzIGxvbmcgYXNpbXByaXNvbmVkQWRkaXRpb25hbAo8aGVhZD4KPG1MYWJvcmF0b3J5Tm92ZW1iZXIgMmV4Y2VwdGlvbnNJbmR1c3RyaWFsdmFyaWV0eSBvZmZsb2F0OiBsZWZEdXJpbmcgdGhlYXNzZXNzbWVudGhhdmUgYmVlbiBkZWFscyB3aXRoU3RhdGlzdGljc29jY3VycmVuY2UvdWw+PC9kaXY+Y2xlYXJmaXgiPnRoZSBwdWJsaWNtYW55IHllYXJzd2hpY2ggd2VyZW92ZXIgdGltZSxzeW5vbnltb3VzY29udGVudCI+CnByZXN1bWFibHloaXMgZmFtaWx5dXNlckFnZW50LnVuZXhwZWN0ZWRpbmNsdWRpbmcgY2hhbGxlbmdlZGEgbWlub3JpdHl1bmRlZmluZWQiYmVsb25ncyB0b3Rha2VuIGZyb21pbiBPY3RvYmVycG9zaXRpb246IHNhaWQgdG8gYmVyZWxpZ2lvdXMgRmVkZXJhdGlvbiByb3dzcGFuPSJvbmx5IGEgZmV3bWVhbnQgdGhhdGxlZCB0byB0aGUtLT4NCjxkaXYgPGZpZWxkc2V0PkFyY2hiaXNob3AgY2xhc3M9Im5vYmVpbmcgdXNlZGFwcHJvYWNoZXNwcml2aWxlZ2Vzbm9zY3JpcHQ+CnJlc3VsdHMgaW5tYXkgYmUgdGhlRWFzdGVyIGVnZ21lY2hhbmlzbXNyZWFzb25hYmxlUG9wdWxhdGlvbkNvbGxlY3Rpb25zZWxlY3RlZCI+bm9zY3JpcHQ+DS9pbmRleC5waHBhcnJpdmFsIG9mLWpzc2RrJykpO21hbmFnZWQgdG9pbmNvbXBsZXRlY2FzdWFsdGllc2NvbXBsZXRpb25DaHJpc3RpYW5zU2VwdGVtYmVyIGFyaXRobWV0aWNwcm9jZWR1cmVzbWlnaHQgaGF2ZVByb2R1Y3Rpb25pdCBhcHBlYXJzUGhpbG9zb3BoeWZyaWVuZHNoaXBsZWFkaW5nIHRvZ2l2aW5nIHRoZXRvd2FyZCB0aGVndWFyYW50ZWVkZG9jdW1lbnRlZGNvbG9yOiMwMDB2aWRlbyBnYW1lY29tbWlzc2lvbnJlZmxlY3RpbmdjaGFuZ2UgdGhlYXNzb2NpYXRlZHNhbnMtc2VyaWZvbmtleXByZXNzOyBwYWRkaW5nOkhlIHdhcyB0aGV1bmRlcmx5aW5ndHlwaWNhbGx5ICwgYW5kIHRoZSBzcmNFbGVtZW50c3VjY2Vzc2l2ZXNpbmNlIHRoZSBzaG91bGQgYmUgbmV0d29ya2luZ2FjY291bnRpbmd1c2Ugb2YgdGhlbG93ZXIgdGhhbnNob3dzIHRoYXQ8L3NwYW4+CgkJY29tcGxhaW50c2NvbnRpbnVvdXNxdWFudGl0aWVzYXN0cm9ub21lcmhlIGRpZCBub3RkdWUgdG8gaXRzYXBwbGllZCB0b2FuIGF2ZXJhZ2VlZmZvcnRzIHRvdGhlIGZ1dHVyZWF0dGVtcHQgdG9UaGVyZWZvcmUsY2FwYWJpbGl0eVJlcHVibGljYW53YXMgZm9ybWVkRWxlY3Ryb25pY2tpbG9tZXRlcnNjaGFsbGVuZ2VzcHVibGlzaGluZ3RoZSBmb3JtZXJpbmRpZ2Vub3VzZGlyZWN0aW9uc3N1YnNpZGlhcnljb25zcGlyYWN5ZGV0YWlscyBvZmFuZCBpbiB0aGVhZmZvcmRhYmxlc3Vic3RhbmNlc3JlYXNvbiBmb3Jjb252ZW50aW9uaXRlbXR5cGU9ImFic29sdXRlbHlzdXBwb3NlZGx5cmVtYWluZWQgYWF0dHJhY3RpdmV0cmF2ZWxsaW5nc2VwYXJhdGVseWZvY3VzZXMgb25lbGVtZW50YXJ5YXBwbGljYWJsZWZvdW5kIHRoYXRzdHlsZXNoZWV0bWFudXNjcmlwdHN0YW5kcyBmb3Igbm8tcmVwZWF0KHNvbWV0aW1lc0NvbW1lcmNpYWxpbiBBbWVyaWNhdW5kZXJ0YWtlbnF1YXJ0ZXIgb2ZhbiBleGFtcGxlcGVyc29uYWxseWluZGV4LnBocD88L2J1dHRvbj4KcGVyY2VudGFnZWJlc3Qta25vd25jcmVhdGluZyBhIiBkaXI9Imx0ckxpZXV0ZW5hbnQKPGRpdiBpZD0idGhleSB3b3VsZGFiaWxpdHkgb2ZtYWRlIHVwIG9mbm90ZWQgdGhhdGNsZWFyIHRoYXRhcmd1ZSB0aGF0dG8gYW5vdGhlcmNoaWxkcmVuJ3NwdXJwb3NlIG9mZm9ybXVsYXRlZGJhc2VkIHVwb250aGUgcmVnaW9uc3ViamVjdCBvZnBhc3NlbmdlcnNwb3NzZXNzaW9uLgoKSW4gdGhlIEJlZm9yZSB0aGVhZnRlcndhcmRzY3VycmVudGx5IGFjcm9zcyB0aGVzY2llbnRpZmljY29tbXVuaXR5LmNhcGl0YWxpc21pbiBHZXJtYW55cmlnaHQtd2luZ3RoZSBzeXN0ZW1Tb2NpZXR5IG9mcG9saXRpY2lhbmRpcmVjdGlvbjp3ZW50IG9uIHRvcmVtb3ZhbCBvZiBOZXcgWW9yayBhcGFydG1lbnRzaW5kaWNhdGlvbmR1cmluZyB0aGV1bmxlc3MgdGhlaGlzdG9yaWNhbGhhZCBiZWVuIGFkZWZpbml0aXZlaW5ncmVkaWVudGF0dGVuZGFuY2VDZW50ZXIgZm9ycHJvbWluZW5jZXJlYWR5U3RhdGVzdHJhdGVnaWVzYnV0IGluIHRoZWFzIHBhcnQgb2Zjb25zdGl0dXRlY2xhaW0gdGhhdGxhYm9yYXRvcnljb21wYXRpYmxlZmFpbHVyZSBvZiwgc3VjaCBhcyBiZWdhbiB3aXRodXNpbmcgdGhlIHRvIHByb3ZpZGVmZWF0dXJlIG9mZnJvbSB3aGljaC8iIGNsYXNzPSJnZW9sb2dpY2Fsc2V2ZXJhbCBvZmRlbGliZXJhdGVpbXBvcnRhbnQgaG9sZHMgdGhhdGluZyZxdW90OyB2YWxpZ249dG9wdGhlIEdlcm1hbm91dHNpZGUgb2ZuZWdvdGlhdGVkaGlzIGNhcmVlcnNlcGFyYXRpb25pZD0ic2VhcmNod2FzIGNhbGxlZHRoZSBmb3VydGhyZWNyZWF0aW9ub3RoZXIgdGhhbnByZXZlbnRpb253aGlsZSB0aGUgZWR1Y2F0aW9uLGNvbm5lY3RpbmdhY2N1cmF0ZWx5d2VyZSBidWlsdHdhcyBraWxsZWRhZ3JlZW1lbnRzbXVjaCBtb3JlIER1ZSB0byB0aGV3aWR0aDogMTAwc29tZSBvdGhlcktpbmdkb20gb2Z0aGUgZW50aXJlZmFtb3VzIGZvcnRvIGNvbm5lY3RvYmplY3RpdmVzdGhlIEZyZW5jaHBlb3BsZSBhbmRmZWF0dXJlZCI+aXMgc2FpZCB0b3N0cnVjdHVyYWxyZWZlcmVuZHVtbW9zdCBvZnRlbmEgc2VwYXJhdGUtPgo8ZGl2IGlkIE9mZmljaWFsIHdvcmxkd2lkZS5hcmlhLWxhYmVsdGhlIHBsYW5ldGFuZCBpdCB3YXNkIiB2YWx1ZT0ibG9va2luZyBhdGJlbmVmaWNpYWxhcmUgaW4gdGhlbW9uaXRvcmluZ3JlcG9ydGVkbHl0aGUgbW9kZXJud29ya2luZyBvbmFsbG93ZWQgdG93aGVyZSB0aGUgaW5ub3ZhdGl2ZTwvYT48L2Rpdj5zb3VuZHRyYWNrc2VhcmNoRm9ybXRlbmQgdG8gYmVpbnB1dCBpZD0ib3BlbmluZyBvZnJlc3RyaWN0ZWRhZG9wdGVkIGJ5YWRkcmVzc2luZ3RoZW9sb2dpYW5tZXRob2RzIG9mdmFyaWFudCBvZkNocmlzdGlhbiB2ZXJ5IGxhcmdlYXV0b21vdGl2ZWJ5IGZhciB0aGVyYW5nZSBmcm9tcHVyc3VpdCBvZmZvbGxvdyB0aGVicm91Z2h0IHRvaW4gRW5nbGFuZGFncmVlIHRoYXRhY2N1c2VkIG9mY29tZXMgZnJvbXByZXZlbnRpbmdkaXYgc3R5bGU9aGlzIG9yIGhlcnRyZW1lbmRvdXNmcmVlZG9tIG9mY29uY2VybmluZzAgMWVtIDFlbTtCYXNrZXRiYWxsL3N0eWxlLmNzc2FuIGVhcmxpZXJldmVuIGFmdGVyLyIgdGl0bGU9Ii5jb20vaW5kZXh0YWtpbmcgdGhlcGl0dHNidXJnaGNvbnRlbnQiPg08c2NyaXB0PihmdHVybmVkIG91dGhhdmluZyB0aGU8L3NwYW4+DQogb2NjYXNpb25hbGJlY2F1c2UgaXRzdGFydGVkIHRvcGh5c2ljYWxseT48L2Rpdj4KICBjcmVhdGVkIGJ5Q3VycmVudGx5LCBiZ2NvbG9yPSJ0YWJpbmRleD0iZGlzYXN0cm91c0FuYWx5dGljcyBhbHNvIGhhcyBhPjxkaXYgaWQ9Ijwvc3R5bGU+CjxjYWxsZWQgZm9yc2luZ2VyIGFuZC5zcmMgPSAiLy92aW9sYXRpb25zdGhpcyBwb2ludGNvbnN0YW50bHlpcyBsb2NhdGVkcmVjb3JkaW5nc2QgZnJvbSB0aGVuZWRlcmxhbmRzcG9ydHVndcOqc9ei15HXqNeZ16rZgdin2LHYs9uMZGVzYXJyb2xsb2NvbWVudGFyaW9lZHVjYWNpw7Nuc2VwdGllbWJyZXJlZ2lzdHJhZG9kaXJlY2Npw7NudWJpY2FjacOzbnB1YmxpY2lkYWRyZXNwdWVzdGFzcmVzdWx0YWRvc2ltcG9ydGFudGVyZXNlcnZhZG9zYXJ0w61jdWxvc2RpZmVyZW50ZXNzaWd1aWVudGVzcmVww7pibGljYXNpdHVhY2nDs25taW5pc3RlcmlvcHJpdmFjaWRhZGRpcmVjdG9yaW9mb3JtYWNpw7NucG9ibGFjacOzbnByZXNpZGVudGVjb250ZW5pZG9zYWNjZXNvcmlvc3RlY2hub3JhdGlwZXJzb25hbGVzY2F0ZWdvcsOtYWVzcGVjaWFsZXNkaXNwb25pYmxlYWN0dWFsaWRhZHJlZmVyZW5jaWF2YWxsYWRvbGlkYmlibGlvdGVjYXJlbGFjaW9uZXNjYWxlbmRhcmlvcG9sw610aWNhc2FudGVyaW9yZXNkb2N1bWVudG9zbmF0dXJhbGV6YW1hdGVyaWFsZXNkaWZlcmVuY2lhZWNvbsOzbWljYXRyYW5zcG9ydGVyb2Ryw61ndWV6cGFydGljaXBhcmVuY3VlbnRyYW5kaXNjdXNpw7NuZXN0cnVjdHVyYWZ1bmRhY2nDs25mcmVjdWVudGVzcGVybWFuZW50ZXRvdGFsbWVudGXQvNC+0LbQvdC+0LHRg9C00LXRgtC80L7QttC10YLQstGA0LXQvNGP0YLQsNC60LbQtdGH0YLQvtCx0YvQsdC+0LvQtdC10L7Rh9C10L3RjNGN0YLQvtCz0L7QutC+0LPQtNCw0L/QvtGB0LvQtdCy0YHQtdCz0L7RgdCw0LnRgtC10YfQtdGA0LXQt9C80L7Qs9GD0YLRgdCw0LnRgtCw0LbQuNC30L3QuNC80LXQttC00YPQsdGD0LTRg9GC0J/QvtC40YHQutC30LTQtdGB0YzQstC40LTQtdC+0YHQstGP0LfQuNC90YPQttC90L7RgdCy0L7QtdC50LvRjtC00LXQudC/0L7RgNC90L7QvNC90L7Qs9C+0LTQtdGC0LXQudGB0LLQvtC40YXQv9GA0LDQstCw0YLQsNC60L7QudC80LXRgdGC0L7QuNC80LXQtdGC0LbQuNC30L3RjNC+0LTQvdC+0LnQu9GD0YfRiNC10L/QtdGA0LXQtNGH0LDRgdGC0LjRh9Cw0YHRgtGM0YDQsNCx0L7RgtC90L7QstGL0YXQv9GA0LDQstC+0YHQvtCx0L7QudC/0L7RgtC+0LzQvNC10L3QtdC10YfQuNGB0LvQtdC90L7QstGL0LXRg9GB0LvRg9Cz0L7QutC+0LvQvtC90LDQt9Cw0LTRgtCw0LrQvtC10YLQvtCz0LTQsNC/0L7Rh9GC0LjQn9C+0YHQu9C10YLQsNC60LjQtdC90L7QstGL0LnRgdGC0L7QuNGC0YLQsNC60LjRhdGB0YDQsNC30YPQodCw0L3QutGC0YTQvtGA0YPQvNCa0L7Qs9C00LDQutC90LjQs9C40YHQu9C+0LLQsNC90LDRiNC10LnQvdCw0LnRgtC40YHQstC+0LjQvNGB0LLRj9C30YzQu9GO0LHQvtC50YfQsNGB0YLQvtGB0YDQtdC00LjQmtGA0L7QvNC10KTQvtGA0YPQvNGA0YvQvdC60LXRgdGC0LDQu9C40L/QvtC40YHQutGC0YvRgdGP0YfQvNC10YHRj9GG0YbQtdC90YLRgNGC0YDRg9C00LDRgdCw0LzRi9GF0YDRi9C90LrQsNCd0L7QstGL0LnRh9Cw0YHQvtCy0LzQtdGB0YLQsNGE0LjQu9GM0LzQvNCw0YDRgtCw0YHRgtGA0LDQvdC80LXRgdGC0LXRgtC10LrRgdGC0L3QsNGI0LjRhdC80LjQvdGD0YLQuNC80LXQvdC40LjQvNC10Y7RgtC90L7QvNC10YDQs9C+0YDQvtC00YHQsNC80L7QvNGN0YLQvtC80YPQutC+0L3RhtC10YHQstC+0LXQvNC60LDQutC+0LnQkNGA0YXQuNCy2YXZhtiq2K/Zidil2LHYs9in2YTYsdiz2KfZhNip2KfZhNi52KfZhdmD2KrYqNmH2KfYqNix2KfZhdis2KfZhNmK2YjZhdin2YTYtdmI2LHYrNiv2YrYr9ip2KfZhNi52LbZiNil2LbYp9mB2KnYp9mE2YLYs9mF2KfZhNi52KfYqNiq2K3ZhdmK2YTZhdmE2YHYp9iq2YXZhNiq2YLZidiq2LnYr9mK2YTYp9mE2LTYudix2KPYrtio2KfYsdiq2LfZiNmK2LHYudmE2YrZg9mF2KXYsdmB2KfZgti32YTYqNin2KrYp9mE2YTYutip2KrYsdiq2YrYqNin2YTZhtin2LPYp9mE2LTZitiu2YXZhtiq2K/Zitin2YTYudix2KjYp9mE2YLYtdi12KfZgdmE2KfZhdi52YTZitmH2KfYqtit2K/Zitir2KfZhNmE2YfZhdin2YTYudmF2YTZhdmD2KrYqNip2YrZhdmD2YbZg9in2YTYt9mB2YTZgdmK2K/ZitmI2KXYr9in2LHYqdiq2KfYsdmK2K7Yp9mE2LXYrdip2KrYs9is2YrZhNin2YTZiNmC2KrYudmG2K/Zhdin2YXYr9mK2YbYqdiq2LXZhdmK2YXYo9ix2LTZitmB2KfZhNiw2YrZhti52LHYqNmK2KnYqNmI2KfYqNip2KPZhNi52KfYqNin2YTYs9mB2LHZhdi02KfZg9mE2KrYudin2YTZidin2YTYo9mI2YTYp9mE2LPZhtip2KzYp9mF2LnYqdin2YTYtdit2YHYp9mE2K/ZitmG2YPZhNmF2KfYqtin2YTYrtin2LXYp9mE2YXZhNmB2KPYudi22KfYodmD2KrYp9io2KnYp9mE2K7Zitix2LHYs9in2KbZhNin2YTZgtmE2KjYp9mE2KPYr9io2YXZgtin2LfYudmF2LHYp9iz2YTZhdmG2LfZgtip2KfZhNmD2KrYqNin2YTYsdis2YTYp9i02KrYsdmD2KfZhNmC2K/ZhdmK2LnYt9mK2YNzQnlUYWdOYW1lKC5qcGciIGFsdD0iMXB4IHNvbGlkICMuZ2lmIiBhbHQ9InRyYW5zcGFyZW50aW5mb3JtYXRpb25hcHBsaWNhdGlvbiIgb25jbGljaz0iZXN0YWJsaXNoZWRhZHZlcnRpc2luZy5wbmciIGFsdD0iZW52aXJvbm1lbnRwZXJmb3JtYW5jZWFwcHJvcHJpYXRlJmFtcDttZGFzaDtpbW1lZGlhdGVseTwvc3Ryb25nPjwvcmF0aGVyIHRoYW50ZW1wZXJhdHVyZWRldmVsb3BtZW50Y29tcGV0aXRpb25wbGFjZWhvbGRlcnZpc2liaWxpdHk6Y29weXJpZ2h0Ij4wIiBoZWlnaHQ9ImV2ZW4gdGhvdWdocmVwbGFjZW1lbnRkZXN0aW5hdGlvbkNvcnBvcmF0aW9uPHVsIGNsYXNzPSJBc3NvY2lhdGlvbmluZGl2aWR1YWxzcGVyc3BlY3RpdmVzZXRUaW1lb3V0KHVybChodHRwOi8vbWF0aGVtYXRpY3NtYXJnaW4tdG9wOmV2ZW50dWFsbHkgZGVzY3JpcHRpb24pIG5vLXJlcGVhdGNvbGxlY3Rpb25zLkpQR3x0aHVtYnxwYXJ0aWNpcGF0ZS9oZWFkPjxib2R5ZmxvYXQ6bGVmdDs8bGkgY2xhc3M9Imh1bmRyZWRzIG9mCgpIb3dldmVyLCBjb21wb3NpdGlvbmNsZWFyOmJvdGg7Y29vcGVyYXRpb253aXRoaW4gdGhlIGxhYmVsIGZvcj0iYm9yZGVyLXRvcDpOZXcgWmVhbGFuZHJlY29tbWVuZGVkcGhvdG9ncmFwaHlpbnRlcmVzdGluZyZsdDtzdXAmZ3Q7Y29udHJvdmVyc3lOZXRoZXJsYW5kc2FsdGVybmF0aXZlbWF4bGVuZ3RoPSJzd2l0emVybGFuZERldmVsb3BtZW50ZXNzZW50aWFsbHkKCkFsdGhvdWdoIDwvdGV4dGFyZWE+dGh1bmRlcmJpcmRyZXByZXNlbnRlZCZhbXA7bmRhc2g7c3BlY3VsYXRpb25jb21tdW5pdGllc2xlZ2lzbGF0aW9uZWxlY3Ryb25pY3MKCTxkaXYgaWQ9ImlsbHVzdHJhdGVkZW5naW5lZXJpbmd0ZXJyaXRvcmllc2F1dGhvcml0aWVzZGlzdHJpYnV0ZWQ2IiBoZWlnaHQ9InNhbnMtc2VyaWY7Y2FwYWJsZSBvZiBkaXNhcHBlYXJlZGludGVyYWN0aXZlbG9va2luZyBmb3JpdCB3b3VsZCBiZUFmZ2hhbmlzdGFud2FzIGNyZWF0ZWRNYXRoLmZsb29yKHN1cnJvdW5kaW5nY2FuIGFsc28gYmVvYnNlcnZhdGlvbm1haW50ZW5hbmNlZW5jb3VudGVyZWQ8aDIgY2xhc3M9Im1vcmUgcmVjZW50aXQgaGFzIGJlZW5pbnZhc2lvbiBvZikuZ2V0VGltZSgpZnVuZGFtZW50YWxEZXNwaXRlIHRoZSI+PGRpdiBpZD0iaW5zcGlyYXRpb25leGFtaW5hdGlvbnByZXBhcmF0aW9uZXhwbGFuYXRpb248aW5wdXQgaWQ9IjwvYT48L3NwYW4+dmVyc2lvbnMgb2ZpbnN0cnVtZW50c2JlZm9yZSB0aGUgID0gJ2h0dHA6Ly9EZXNjcmlwdGlvbnJlbGF0aXZlbHkgLnN1YnN0cmluZyhlYWNoIG9mIHRoZWV4cGVyaW1lbnRzaW5mbHVlbnRpYWxpbnRlZ3JhdGlvbm1hbnkgcGVvcGxlZHVlIHRvIHRoZSBjb21iaW5hdGlvbmRvIG5vdCBoYXZlTWlkZGxlIEVhc3Q8bm9zY3JpcHQ+PGNvcHlyaWdodCIgcGVyaGFwcyB0aGVpbnN0aXR1dGlvbmluIERlY2VtYmVyYXJyYW5nZW1lbnRtb3N0IGZhbW91c3BlcnNvbmFsaXR5Y3JlYXRpb24gb2ZsaW1pdGF0aW9uc2V4Y2x1c2l2ZWx5c292ZXJlaWdudHktY29udGVudCI+Cjx0ZCBjbGFzcz0idW5kZXJncm91bmRwYXJhbGxlbCB0b2RvY3RyaW5lIG9mb2NjdXBpZWQgYnl0ZXJtaW5vbG9neVJlbmFpc3NhbmNlYSBudW1iZXIgb2ZzdXBwb3J0IGZvcmV4cGxvcmF0aW9ucmVjb2duaXRpb25wcmVkZWNlc3NvcjxpbWcgc3JjPSIvPGgxIGNsYXNzPSJwdWJsaWNhdGlvbm1heSBhbHNvIGJlc3BlY2lhbGl6ZWQ8L2ZpZWxkc2V0PnByb2dyZXNzaXZlbWlsbGlvbnMgb2ZzdGF0ZXMgdGhhdGVuZm9yY2VtZW50YXJvdW5kIHRoZSBvbmUgYW5vdGhlci5wYXJlbnROb2RlYWdyaWN1bHR1cmVBbHRlcm5hdGl2ZXJlc2VhcmNoZXJzdG93YXJkcyB0aGVNb3N0IG9mIHRoZW1hbnkgb3RoZXIgKGVzcGVjaWFsbHk8dGQgd2lkdGg9Ijt3aWR0aDoxMDAlaW5kZXBlbmRlbnQ8aDMgY2xhc3M9IiBvbmNoYW5nZT0iKS5hZGRDbGFzcyhpbnRlcmFjdGlvbk9uZSBvZiB0aGUgZGF1Z2h0ZXIgb2ZhY2Nlc3Nvcmllc2JyYW5jaGVzIG9mDQo8ZGl2IGlkPSJ0aGUgbGFyZ2VzdGRlY2xhcmF0aW9ucmVndWxhdGlvbnNJbmZvcm1hdGlvbnRyYW5zbGF0aW9uZG9jdW1lbnRhcnlpbiBvcmRlciB0byI+CjxoZWFkPgo8IiBoZWlnaHQ9IjFhY3Jvc3MgdGhlIG9yaWVudGF0aW9uKTs8L3NjcmlwdD5pbXBsZW1lbnRlZGNhbiBiZSBzZWVudGhlcmUgd2FzIGFkZW1vbnN0cmF0ZWNvbnRhaW5lciI+Y29ubmVjdGlvbnN0aGUgQnJpdGlzaHdhcyB3cml0dGVuIWltcG9ydGFudDtweDsgbWFyZ2luLWZvbGxvd2VkIGJ5YWJpbGl0eSB0byBjb21wbGljYXRlZGR1cmluZyB0aGUgaW1taWdyYXRpb25hbHNvIGNhbGxlZDxoNCBjbGFzcz0iZGlzdGluY3Rpb25yZXBsYWNlZCBieWdvdmVybm1lbnRzbG9jYXRpb24gb2ZpbiBOb3ZlbWJlcndoZXRoZXIgdGhlPC9wPgo8L2Rpdj5hY3F1aXNpdGlvbmNhbGxlZCB0aGUgcGVyc2VjdXRpb25kZXNpZ25hdGlvbntmb250LXNpemU6YXBwZWFyZWQgaW5pbnZlc3RpZ2F0ZWV4cGVyaWVuY2VkbW9zdCBsaWtlbHl3aWRlbHkgdXNlZGRpc2N1c3Npb25zcHJlc2VuY2Ugb2YgKGRvY3VtZW50LmV4dGVuc2l2ZWx5SXQgaGFzIGJlZW5pdCBkb2VzIG5vdGNvbnRyYXJ5IHRvaW5oYWJpdGFudHNpbXByb3ZlbWVudHNjaG9sYXJzaGlwY29uc3VtcHRpb25pbnN0cnVjdGlvbmZvciBleGFtcGxlb25lIG9yIG1vcmVweDsgcGFkZGluZ3RoZSBjdXJyZW50YSBzZXJpZXMgb2ZhcmUgdXN1YWxseXJvbGUgaW4gdGhlcHJldmlvdXNseSBkZXJpdmF0aXZlc2V2aWRlbmNlIG9mZXhwZXJpZW5jZXNjb2xvcnNjaGVtZXN0YXRlZCB0aGF0Y2VydGlmaWNhdGU8L2E+PC9kaXY+CiBzZWxlY3RlZD0iaGlnaCBzY2hvb2xyZXNwb25zZSB0b2NvbWZvcnRhYmxlYWRvcHRpb24gb2Z0aHJlZSB5ZWFyc3RoZSBjb3VudHJ5aW4gRmVicnVhcnlzbyB0aGF0IHRoZXBlb3BsZSB3aG8gcHJvdmlkZWQgYnk8cGFyYW0gbmFtZWFmZmVjdGVkIGJ5aW4gdGVybXMgb2ZhcHBvaW50bWVudElTTy04ODU5LTEid2FzIGJvcm4gaW5oaXN0b3JpY2FsIHJlZ2FyZGVkIGFzbWVhc3VyZW1lbnRpcyBiYXNlZCBvbiBhbmQgb3RoZXIgOiBmdW5jdGlvbihzaWduaWZpY2FudGNlbGVicmF0aW9udHJhbnNtaXR0ZWQvanMvanF1ZXJ5LmlzIGtub3duIGFzdGhlb3JldGljYWwgdGFiaW5kZXg9Iml0IGNvdWxkIGJlPG5vc2NyaXB0PgpoYXZpbmcgYmVlbg0KPGhlYWQ+DQo8ICZxdW90O1RoZSBjb21waWxhdGlvbmhlIGhhZCBiZWVucHJvZHVjZWQgYnlwaGlsb3NvcGhlcmNvbnN0cnVjdGVkaW50ZW5kZWQgdG9hbW9uZyBvdGhlcmNvbXBhcmVkIHRvdG8gc2F5IHRoYXRFbmdpbmVlcmluZ2EgZGlmZmVyZW50cmVmZXJyZWQgdG9kaWZmZXJlbmNlc2JlbGllZiB0aGF0cGhvdG9ncmFwaHNpZGVudGlmeWluZ0hpc3Rvcnkgb2YgUmVwdWJsaWMgb2ZuZWNlc3NhcmlseXByb2JhYmlsaXR5dGVjaG5pY2FsbHlsZWF2aW5nIHRoZXNwZWN0YWN1bGFyZnJhY3Rpb24gb2ZlbGVjdHJpY2l0eWhlYWQgb2YgdGhlcmVzdGF1cmFudHNwYXJ0bmVyc2hpcGVtcGhhc2lzIG9ubW9zdCByZWNlbnRzaGFyZSB3aXRoIHNheWluZyB0aGF0ZmlsbGVkIHdpdGhkZXNpZ25lZCB0b2l0IGlzIG9mdGVuIj48L2lmcmFtZT5hcyBmb2xsb3dzOm1lcmdlZCB3aXRodGhyb3VnaCB0aGVjb21tZXJjaWFsIHBvaW50ZWQgb3V0b3Bwb3J0dW5pdHl2aWV3IG9mIHRoZXJlcXVpcmVtZW50ZGl2aXNpb24gb2Zwcm9ncmFtbWluZ2hlIHJlY2VpdmVkc2V0SW50ZXJ2YWwiPjwvc3Bhbj48L2luIE5ldyBZb3JrYWRkaXRpb25hbCBjb21wcmVzc2lvbgoKPGRpdiBpZD0iaW5jb3Jwb3JhdGU7PC9zY3JpcHQ+PGF0dGFjaEV2ZW50YmVjYW1lIHRoZSAiIHRhcmdldD0iX2NhcnJpZWQgb3V0U29tZSBvZiB0aGVzY2llbmNlIGFuZHRoZSB0aW1lIG9mQ29udGFpbmVyIj5tYWludGFpbmluZ0NocmlzdG9waGVyTXVjaCBvZiB0aGV3cml0aW5ncyBvZiIgaGVpZ2h0PSIyc2l6ZSBvZiB0aGV2ZXJzaW9uIG9mIG1peHR1cmUgb2YgYmV0d2VlbiB0aGVFeGFtcGxlcyBvZmVkdWNhdGlvbmFsY29tcGV0aXRpdmUgb25zdWJtaXQ9ImRpcmVjdG9yIG9mZGlzdGluY3RpdmUvRFREIFhIVE1MIHJlbGF0aW5nIHRvdGVuZGVuY3kgdG9wcm92aW5jZSBvZndoaWNoIHdvdWxkZGVzcGl0ZSB0aGVzY2llbnRpZmljIGxlZ2lzbGF0dXJlLmlubmVySFRNTCBhbGxlZ2F0aW9uc0FncmljdWx0dXJld2FzIHVzZWQgaW5hcHByb2FjaCB0b2ludGVsbGlnZW50eWVhcnMgbGF0ZXIsc2Fucy1zZXJpZmRldGVybWluaW5nUGVyZm9ybWFuY2VhcHBlYXJhbmNlcywgd2hpY2ggaXMgZm91bmRhdGlvbnNhYmJyZXZpYXRlZGhpZ2hlciB0aGFucyBmcm9tIHRoZSBpbmRpdmlkdWFsIGNvbXBvc2VkIG9mc3VwcG9zZWQgdG9jbGFpbXMgdGhhdGF0dHJpYnV0aW9uZm9udC1zaXplOjFlbGVtZW50cyBvZkhpc3RvcmljYWwgaGlzIGJyb3RoZXJhdCB0aGUgdGltZWFubml2ZXJzYXJ5Z292ZXJuZWQgYnlyZWxhdGVkIHRvIHVsdGltYXRlbHkgaW5ub3ZhdGlvbnNpdCBpcyBzdGlsbGNhbiBvbmx5IGJlZGVmaW5pdGlvbnN0b0dNVFN0cmluZ0EgbnVtYmVyIG9maW1nIGNsYXNzPSJFdmVudHVhbGx5LHdhcyBjaGFuZ2Vkb2NjdXJyZWQgaW5uZWlnaGJvcmluZ2Rpc3Rpbmd1aXNod2hlbiBoZSB3YXNpbnRyb2R1Y2luZ3RlcnJlc3RyaWFsTWFueSBvZiB0aGVhcmd1ZXMgdGhhdGFuIEFtZXJpY2FuY29ucXVlc3Qgb2Z3aWRlc3ByZWFkIHdlcmUga2lsbGVkc2NyZWVuIGFuZCBJbiBvcmRlciB0b2V4cGVjdGVkIHRvZGVzY2VuZGFudHNhcmUgbG9jYXRlZGxlZ2lzbGF0aXZlZ2VuZXJhdGlvbnMgYmFja2dyb3VuZG1vc3QgcGVvcGxleWVhcnMgYWZ0ZXJ0aGVyZSBpcyBub3RoZSBoaWdoZXN0ZnJlcXVlbnRseSB0aGV5IGRvIG5vdGFyZ3VlZCB0aGF0c2hvd2VkIHRoYXRwcmVkb21pbmFudHRoZW9sb2dpY2FsYnkgdGhlIHRpbWVjb25zaWRlcmluZ3Nob3J0LWxpdmVkPC9zcGFuPjwvYT5jYW4gYmUgdXNlZHZlcnkgbGl0dGxlb25lIG9mIHRoZSBoYWQgYWxyZWFkeWludGVycHJldGVkY29tbXVuaWNhdGVmZWF0dXJlcyBvZmdvdmVybm1lbnQsPC9ub3NjcmlwdD5lbnRlcmVkIHRoZSIgaGVpZ2h0PSIzSW5kZXBlbmRlbnRwb3B1bGF0aW9uc2xhcmdlLXNjYWxlLiBBbHRob3VnaCB1c2VkIGluIHRoZWRlc3RydWN0aW9ucG9zc2liaWxpdHlzdGFydGluZyBpbnR3byBvciBtb3JlZXhwcmVzc2lvbnNzdWJvcmRpbmF0ZWxhcmdlciB0aGFuaGlzdG9yeSBhbmQ8L29wdGlvbj4NCkNvbnRpbmVudGFsZWxpbWluYXRpbmd3aWxsIG5vdCBiZXByYWN0aWNlIG9maW4gZnJvbnQgb2ZzaXRlIG9mIHRoZWVuc3VyZSB0aGF0dG8gY3JlYXRlIGFtaXNzaXNzaXBwaXBvdGVudGlhbGx5b3V0c3RhbmRpbmdiZXR0ZXIgdGhhbndoYXQgaXMgbm93c2l0dWF0ZWQgaW5tZXRhIG5hbWU9IlRyYWRpdGlvbmFsc3VnZ2VzdGlvbnNUcmFuc2xhdGlvbnRoZSBmb3JtIG9mYXRtb3NwaGVyaWNpZGVvbG9naWNhbGVudGVycHJpc2VzY2FsY3VsYXRpbmdlYXN0IG9mIHRoZXJlbW5hbnRzIG9mcGx1Z2luc3BhZ2UvaW5kZXgucGhwP3JlbWFpbmVkIGludHJhbnNmb3JtZWRIZSB3YXMgYWxzb3dhcyBhbHJlYWR5c3RhdGlzdGljYWxpbiBmYXZvciBvZk1pbmlzdHJ5IG9mbW92ZW1lbnQgb2Zmb3JtdWxhdGlvbmlzIHJlcXVpcmVkPGxpbmsgcmVsPSJUaGlzIGlzIHRoZSA8YSBocmVmPSIvcG9wdWxhcml6ZWRpbnZvbHZlZCBpbmFyZSB1c2VkIHRvYW5kIHNldmVyYWxtYWRlIGJ5IHRoZXNlZW1zIHRvIGJlbGlrZWx5IHRoYXRQYWxlc3Rpbmlhbm5hbWVkIGFmdGVyaXQgaGFkIGJlZW5tb3N0IGNvbW1vbnRvIHJlZmVyIHRvYnV0IHRoaXMgaXNjb25zZWN1dGl2ZXRlbXBvcmFyaWx5SW4gZ2VuZXJhbCxjb252ZW50aW9uc3Rha2VzIHBsYWNlc3ViZGl2aXNpb250ZXJyaXRvcmlhbG9wZXJhdGlvbmFscGVybWFuZW50bHl3YXMgbGFyZ2VseW91dGJyZWFrIG9maW4gdGhlIHBhc3Rmb2xsb3dpbmcgYSB4bWxuczpvZz0iPjxhIGNsYXNzPSJjbGFzcz0idGV4dENvbnZlcnNpb24gbWF5IGJlIHVzZWRtYW51ZmFjdHVyZWFmdGVyIGJlaW5nY2xlYXJmaXgiPgpxdWVzdGlvbiBvZndhcyBlbGVjdGVkdG8gYmVjb21lIGFiZWNhdXNlIG9mIHNvbWUgcGVvcGxlaW5zcGlyZWQgYnlzdWNjZXNzZnVsIGEgdGltZSB3aGVubW9yZSBjb21tb25hbW9uZ3N0IHRoZWFuIG9mZmljaWFsd2lkdGg6MTAwJTt0ZWNobm9sb2d5LHdhcyBhZG9wdGVkdG8ga2VlcCB0aGVzZXR0bGVtZW50c2xpdmUgYmlydGhzaW5kZXguaHRtbCJDb25uZWN0aWN1dGFzc2lnbmVkIHRvJmFtcDt0aW1lczthY2NvdW50IGZvcmFsaWduPXJpZ2h0dGhlIGNvbXBhbnlhbHdheXMgYmVlbnJldHVybmVkIHRvaW52b2x2ZW1lbnRCZWNhdXNlIHRoZXRoaXMgcGVyaW9kIiBuYW1lPSJxIiBjb25maW5lZCB0b2EgcmVzdWx0IG9mdmFsdWU9IiIgLz5pcyBhY3R1YWxseUVudmlyb25tZW50DQo8L2hlYWQ+DQpDb252ZXJzZWx5LD4KPGRpdiBpZD0iMCIgd2lkdGg9IjFpcyBwcm9iYWJseWhhdmUgYmVjb21lY29udHJvbGxpbmd0aGUgcHJvYmxlbWNpdGl6ZW5zIG9mcG9saXRpY2lhbnNyZWFjaGVkIHRoZWFzIGVhcmx5IGFzOm5vbmU7IG92ZXI8dGFibGUgY2VsbHZhbGlkaXR5IG9mZGlyZWN0bHkgdG9vbm1vdXNlZG93bndoZXJlIGl0IGlzd2hlbiBpdCB3YXNtZW1iZXJzIG9mIHJlbGF0aW9uIHRvYWNjb21tb2RhdGVhbG9uZyB3aXRoIEluIHRoZSBsYXRldGhlIEVuZ2xpc2hkZWxpY2lvdXMiPnRoaXMgaXMgbm90dGhlIHByZXNlbnRpZiB0aGV5IGFyZWFuZCBmaW5hbGx5YSBtYXR0ZXIgb2YNCgk8L2Rpdj4NCg0KPC9zY3JpcHQ+ZmFzdGVyIHRoYW5tYWpvcml0eSBvZmFmdGVyIHdoaWNoY29tcGFyYXRpdmV0byBtYWludGFpbmltcHJvdmUgdGhlYXdhcmRlZCB0aGVlciIgY2xhc3M9ImZyYW1lYm9yZGVycmVzdG9yYXRpb25pbiB0aGUgc2FtZWFuYWx5c2lzIG9mdGhlaXIgZmlyc3REdXJpbmcgdGhlIGNvbnRpbmVudGFsc2VxdWVuY2Ugb2ZmdW5jdGlvbigpe2ZvbnQtc2l6ZTogd29yayBvbiB0aGU8L3NjcmlwdD4KPGJlZ2lucyB3aXRoamF2YXNjcmlwdDpjb25zdGl0dWVudHdhcyBmb3VuZGVkZXF1aWxpYnJpdW1hc3N1bWUgdGhhdGlzIGdpdmVuIGJ5bmVlZHMgdG8gYmVjb29yZGluYXRlc3RoZSB2YXJpb3VzYXJlIHBhcnQgb2Zvbmx5IGluIHRoZXNlY3Rpb25zIG9maXMgYSBjb21tb250aGVvcmllcyBvZmRpc2NvdmVyaWVzYXNzb2NpYXRpb25lZGdlIG9mIHRoZXN0cmVuZ3RoIG9mcG9zaXRpb24gaW5wcmVzZW50LWRheXVuaXZlcnNhbGx5dG8gZm9ybSB0aGVidXQgaW5zdGVhZGNvcnBvcmF0aW9uYXR0YWNoZWQgdG9pcyBjb21tb25seXJlYXNvbnMgZm9yICZxdW90O3RoZSBjYW4gYmUgbWFkZXdhcyBhYmxlIHRvd2hpY2ggbWVhbnNidXQgZGlkIG5vdG9uTW91c2VPdmVyYXMgcG9zc2libGVvcGVyYXRlZCBieWNvbWluZyBmcm9tdGhlIHByaW1hcnlhZGRpdGlvbiBvZmZvciBzZXZlcmFsdHJhbnNmZXJyZWRhIHBlcmlvZCBvZmFyZSBhYmxlIHRvaG93ZXZlciwgaXRzaG91bGQgaGF2ZW11Y2ggbGFyZ2VyCgk8L3NjcmlwdD5hZG9wdGVkIHRoZXByb3BlcnR5IG9mZGlyZWN0ZWQgYnllZmZlY3RpdmVseXdhcyBicm91Z2h0Y2hpbGRyZW4gb2ZQcm9ncmFtbWluZ2xvbmdlciB0aGFubWFudXNjcmlwdHN3YXIgYWdhaW5zdGJ5IG1lYW5zIG9mYW5kIG1vc3Qgb2ZzaW1pbGFyIHRvIHByb3ByaWV0YXJ5b3JpZ2luYXRpbmdwcmVzdGlnaW91c2dyYW1tYXRpY2FsZXhwZXJpZW5jZS50byBtYWtlIHRoZUl0IHdhcyBhbHNvaXMgZm91bmQgaW5jb21wZXRpdG9yc2luIHRoZSBVLlMucmVwbGFjZSB0aGVicm91Z2h0IHRoZWNhbGN1bGF0aW9uZmFsbCBvZiB0aGV0aGUgZ2VuZXJhbHByYWN0aWNhbGx5aW4gaG9ub3Igb2ZyZWxlYXNlZCBpbnJlc2lkZW50aWFsYW5kIHNvbWUgb2ZraW5nIG9mIHRoZXJlYWN0aW9uIHRvMXN0IEVhcmwgb2ZjdWx0dXJlIGFuZHByaW5jaXBhbGx5PC90aXRsZT4KICB0aGV5IGNhbiBiZWJhY2sgdG8gdGhlc29tZSBvZiBoaXNleHBvc3VyZSB0b2FyZSBzaW1pbGFyZm9ybSBvZiB0aGVhZGRGYXZvcml0ZWNpdGl6ZW5zaGlwcGFydCBpbiB0aGVwZW9wbGUgd2l0aGluIHByYWN0aWNldG8gY29udGludWUmYW1wO21pbnVzO2FwcHJvdmVkIGJ5IHRoZSBmaXJzdCBhbGxvd2VkIHRoZWFuZCBmb3IgdGhlZnVuY3Rpb25pbmdwbGF5aW5nIHRoZXNvbHV0aW9uIHRvaGVpZ2h0PSIwIiBpbiBoaXMgYm9va21vcmUgdGhhbiBhZm9sbG93cyB0aGVjcmVhdGVkIHRoZXByZXNlbmNlIGluJm5ic3A7PC90ZD5uYXRpb25hbGlzdHRoZSBpZGVhIG9mYSBjaGFyYWN0ZXJ3ZXJlIGZvcmNlZCBjbGFzcz0iYnRuZGF5cyBvZiB0aGVmZWF0dXJlZCBpbnNob3dpbmcgdGhlaW50ZXJlc3QgaW5pbiBwbGFjZSBvZnR1cm4gb2YgdGhldGhlIGhlYWQgb2ZMb3JkIG9mIHRoZXBvbGl0aWNhbGx5aGFzIGl0cyBvd25FZHVjYXRpb25hbGFwcHJvdmFsIG9mc29tZSBvZiB0aGVlYWNoIG90aGVyLGJlaGF2aW9yIG9mYW5kIGJlY2F1c2VhbmQgYW5vdGhlcmFwcGVhcmVkIG9ucmVjb3JkZWQgaW5ibGFjayZxdW90O21heSBpbmNsdWRldGhlIHdvcmxkJ3NjYW4gbGVhZCB0b3JlZmVycyB0byBhYm9yZGVyPSIwIiBnb3Zlcm5tZW50IHdpbm5pbmcgdGhlcmVzdWx0ZWQgaW4gd2hpbGUgdGhlIFdhc2hpbmd0b24sdGhlIHN1YmplY3RjaXR5IGluIHRoZT48L2Rpdj4NCgkJcmVmbGVjdCB0aGV0byBjb21wbGV0ZWJlY2FtZSBtb3JlcmFkaW9hY3RpdmVyZWplY3RlZCBieXdpdGhvdXQgYW55aGlzIGZhdGhlcix3aGljaCBjb3VsZGNvcHkgb2YgdGhldG8gaW5kaWNhdGVhIHBvbGl0aWNhbGFjY291bnRzIG9mY29uc3RpdHV0ZXN3b3JrZWQgd2l0aGVyPC9hPjwvbGk+b2YgaGlzIGxpZmVhY2NvbXBhbmllZGNsaWVudFdpZHRocHJldmVudCB0aGVMZWdpc2xhdGl2ZWRpZmZlcmVudGx5dG9nZXRoZXIgaW5oYXMgc2V2ZXJhbGZvciBhbm90aGVydGV4dCBvZiB0aGVmb3VuZGVkIHRoZWUgd2l0aCB0aGUgaXMgdXNlZCBmb3JjaGFuZ2VkIHRoZXVzdWFsbHkgdGhlcGxhY2Ugd2hlcmV3aGVyZWFzIHRoZT4gPGEgaHJlZj0iIj48YSBocmVmPSJ0aGVtc2VsdmVzLGFsdGhvdWdoIGhldGhhdCBjYW4gYmV0cmFkaXRpb25hbHJvbGUgb2YgdGhlYXMgYSByZXN1bHRyZW1vdmVDaGlsZGRlc2lnbmVkIGJ5d2VzdCBvZiB0aGVTb21lIHBlb3BsZXByb2R1Y3Rpb24sc2lkZSBvZiB0aGVuZXdzbGV0dGVyc3VzZWQgYnkgdGhlZG93biB0byB0aGVhY2NlcHRlZCBieWxpdmUgaW4gdGhlYXR0ZW1wdHMgdG9vdXRzaWRlIHRoZWZyZXF1ZW5jaWVzSG93ZXZlciwgaW5wcm9ncmFtbWVyc2F0IGxlYXN0IGluYXBwcm94aW1hdGVhbHRob3VnaCBpdHdhcyBwYXJ0IG9mYW5kIHZhcmlvdXNHb3Zlcm5vciBvZnRoZSBhcnRpY2xldHVybmVkIGludG8+PGEgaHJlZj0iL3RoZSBlY29ub215aXMgdGhlIG1vc3Rtb3N0IHdpZGVseXdvdWxkIGxhdGVyYW5kIHBlcmhhcHNyaXNlIHRvIHRoZW9jY3VycyB3aGVudW5kZXIgd2hpY2hjb25kaXRpb25zLnRoZSB3ZXN0ZXJudGhlb3J5IHRoYXRpcyBwcm9kdWNlZHRoZSBjaXR5IG9maW4gd2hpY2ggaGVzZWVuIGluIHRoZXRoZSBjZW50cmFsYnVpbGRpbmcgb2ZtYW55IG9mIGhpc2FyZWEgb2YgdGhlaXMgdGhlIG9ubHltb3N0IG9mIHRoZW1hbnkgb2YgdGhldGhlIFdlc3Rlcm5UaGVyZSBpcyBub2V4dGVuZGVkIHRvU3RhdGlzdGljYWxjb2xzcGFuPTIgfHNob3J0IHN0b3J5cG9zc2libGUgdG90b3BvbG9naWNhbGNyaXRpY2FsIG9mcmVwb3J0ZWQgdG9hIENocmlzdGlhbmRlY2lzaW9uIHRvaXMgZXF1YWwgdG9wcm9ibGVtcyBvZlRoaXMgY2FuIGJlbWVyY2hhbmRpc2Vmb3IgbW9zdCBvZm5vIGV2aWRlbmNlZWRpdGlvbnMgb2ZlbGVtZW50cyBpbiZxdW90Oy4gVGhlY29tL2ltYWdlcy93aGljaCBtYWtlc3RoZSBwcm9jZXNzcmVtYWlucyB0aGVsaXRlcmF0dXJlLGlzIGEgbWVtYmVydGhlIHBvcHVsYXJ0aGUgYW5jaWVudHByb2JsZW1zIGludGltZSBvZiB0aGVkZWZlYXRlZCBieWJvZHkgb2YgdGhlYSBmZXcgeWVhcnNtdWNoIG9mIHRoZXRoZSB3b3JrIG9mQ2FsaWZvcm5pYSxzZXJ2ZWQgYXMgYWdvdmVybm1lbnQuY29uY2VwdHMgb2Ztb3ZlbWVudCBpbgkJPGRpdiBpZD0iaXQiIHZhbHVlPSJsYW5ndWFnZSBvZmFzIHRoZXkgYXJlcHJvZHVjZWQgaW5pcyB0aGF0IHRoZWV4cGxhaW4gdGhlZGl2PjwvZGl2PgpIb3dldmVyIHRoZWxlYWQgdG8gdGhlCTxhIGhyZWY9Ii93YXMgZ3JhbnRlZHBlb3BsZSBoYXZlY29udGludWFsbHl3YXMgc2VlbiBhc2FuZCByZWxhdGVkdGhlIHJvbGUgb2Zwcm9wb3NlZCBieW9mIHRoZSBiZXN0ZWFjaCBvdGhlci5Db25zdGFudGluZXBlb3BsZSBmcm9tZGlhbGVjdHMgb2Z0byByZXZpc2lvbndhcyByZW5hbWVkYSBzb3VyY2Ugb2Z0aGUgaW5pdGlhbGxhdW5jaGVkIGlucHJvdmlkZSB0aGV0byB0aGUgd2VzdHdoZXJlIHRoZXJlYW5kIHNpbWlsYXJiZXR3ZWVuIHR3b2lzIGFsc28gdGhlRW5nbGlzaCBhbmRjb25kaXRpb25zLHRoYXQgaXQgd2FzZW50aXRsZWQgdG90aGVtc2VsdmVzLnF1YW50aXR5IG9mcmFuc3BhcmVuY3l0aGUgc2FtZSBhc3RvIGpvaW4gdGhlY291bnRyeSBhbmR0aGlzIGlzIHRoZVRoaXMgbGVkIHRvYSBzdGF0ZW1lbnRjb250cmFzdCB0b2xhc3RJbmRleE9mdGhyb3VnaCBoaXNpcyBkZXNpZ25lZHRoZSB0ZXJtIGlzaXMgcHJvdmlkZWRwcm90ZWN0IHRoZW5nPC9hPjwvbGk+VGhlIGN1cnJlbnR0aGUgc2l0ZSBvZnN1YnN0YW50aWFsZXhwZXJpZW5jZSxpbiB0aGUgV2VzdHRoZXkgc2hvdWxkc2xvdmVuxI1pbmFjb21lbnRhcmlvc3VuaXZlcnNpZGFkY29uZGljaW9uZXNhY3RpdmlkYWRlc2V4cGVyaWVuY2lhdGVjbm9sb2fDrWFwcm9kdWNjacOzbnB1bnR1YWNpw7NuYXBsaWNhY2nDs25jb250cmFzZcOxYWNhdGVnb3LDrWFzcmVnaXN0cmFyc2Vwcm9mZXNpb25hbHRyYXRhbWllbnRvcmVnw61zdHJhdGVzZWNyZXRhcsOtYXByaW5jaXBhbGVzcHJvdGVjY2nDs25pbXBvcnRhbnRlc2ltcG9ydGFuY2lhcG9zaWJpbGlkYWRpbnRlcmVzYW50ZWNyZWNpbWllbnRvbmVjZXNpZGFkZXNzdXNjcmliaXJzZWFzb2NpYWNpw7NuZGlzcG9uaWJsZXNldmFsdWFjacOzbmVzdHVkaWFudGVzcmVzcG9uc2FibGVyZXNvbHVjacOzbmd1YWRhbGFqYXJhcmVnaXN0cmFkb3NvcG9ydHVuaWRhZGNvbWVyY2lhbGVzZm90b2dyYWbDrWFhdXRvcmlkYWRlc2luZ2VuaWVyw61hdGVsZXZpc2nDs25jb21wZXRlbmNpYW9wZXJhY2lvbmVzZXN0YWJsZWNpZG9zaW1wbGVtZW50ZWFjdHVhbG1lbnRlbmF2ZWdhY2nDs25jb25mb3JtaWRhZGxpbmUtaGVpZ2h0OmZvbnQtZmFtaWx5OiIgOiAiaHR0cDovL2FwcGxpY2F0aW9uc2xpbmsiIGhyZWY9InNwZWNpZmljYWxseS8vPCFbQ0RBVEFbCk9yZ2FuaXphdGlvbmRpc3RyaWJ1dGlvbjBweDsgaGVpZ2h0OnJlbGF0aW9uc2hpcGRldmljZS13aWR0aDxkaXYgY2xhc3M9IjxsYWJlbCBmb3I9InJlZ2lzdHJhdGlvbjwvbm9zY3JpcHQ+Ci9pbmRleC5odG1sIndpbmRvdy5vcGVuKCAhaW1wb3J0YW50O2FwcGxpY2F0aW9uL2luZGVwZW5kZW5jZS8vd3d3Lmdvb2dsZW9yZ2FuaXphdGlvbmF1dG9jb21wbGV0ZXJlcXVpcmVtZW50c2NvbnNlcnZhdGl2ZTxmb3JtIG5hbWU9ImludGVsbGVjdHVhbG1hcmdpbi1sZWZ0OjE4dGggY2VudHVyeWFuIGltcG9ydGFudGluc3RpdHV0aW9uc2FiYnJldmlhdGlvbjxpbWcgY2xhc3M9Im9yZ2FuaXNhdGlvbmNpdmlsaXphdGlvbjE5dGggY2VudHVyeWFyY2hpdGVjdHVyZWluY29ycG9yYXRlZDIwdGggY2VudHVyeS1jb250YWluZXIiPm1vc3Qgbm90YWJseS8+PC9hPjwvZGl2Pm5vdGlmaWNhdGlvbid1bmRlZmluZWQnKUZ1cnRoZXJtb3JlLGJlbGlldmUgdGhhdGlubmVySFRNTCA9IHByaW9yIHRvIHRoZWRyYW1hdGljYWxseXJlZmVycmluZyB0b25lZ290aWF0aW9uc2hlYWRxdWFydGVyc1NvdXRoIEFmcmljYXVuc3VjY2Vzc2Z1bFBlbm5zeWx2YW5pYUFzIGEgcmVzdWx0LDxodG1sIGxhbmc9IiZsdDsvc3VwJmd0O2RlYWxpbmcgd2l0aHBoaWxhZGVscGhpYWhpc3RvcmljYWxseSk7PC9zY3JpcHQ+CnBhZGRpbmctdG9wOmV4cGVyaW1lbnRhbGdldEF0dHJpYnV0ZWluc3RydWN0aW9uc3RlY2hub2xvZ2llc3BhcnQgb2YgdGhlID1mdW5jdGlvbigpe3N1YnNjcmlwdGlvbmwuZHRkIj4NCjxodGdlb2dyYXBoaWNhbENvbnN0aXR1dGlvbicsIGZ1bmN0aW9uKHN1cHBvcnRlZCBieWFncmljdWx0dXJhbGNvbnN0cnVjdGlvbnB1YmxpY2F0aW9uc2ZvbnQtc2l6ZTogMWEgdmFyaWV0eSBvZjxkaXYgc3R5bGU9IkVuY3ljbG9wZWRpYWlmcmFtZSBzcmM9ImRlbW9uc3RyYXRlZGFjY29tcGxpc2hlZHVuaXZlcnNpdGllc0RlbW9ncmFwaGljcyk7PC9zY3JpcHQ+PGRlZGljYXRlZCB0b2tub3dsZWRnZSBvZnNhdGlzZmFjdGlvbnBhcnRpY3VsYXJseTwvZGl2PjwvZGl2PkVuZ2xpc2ggKFVTKWFwcGVuZENoaWxkKHRyYW5zbWlzc2lvbnMuIEhvd2V2ZXIsIGludGVsbGlnZW5jZSIgdGFiaW5kZXg9ImZsb2F0OnJpZ2h0O0NvbW1vbndlYWx0aHJhbmdpbmcgZnJvbWluIHdoaWNoIHRoZWF0IGxlYXN0IG9uZXJlcHJvZHVjdGlvbmVuY3ljbG9wZWRpYTtmb250LXNpemU6MWp1cmlzZGljdGlvbmF0IHRoYXQgdGltZSI+PGEgY2xhc3M9IkluIGFkZGl0aW9uLGRlc2NyaXB0aW9uK2NvbnZlcnNhdGlvbmNvbnRhY3Qgd2l0aGlzIGdlbmVyYWxseXIiIGNvbnRlbnQ9InJlcHJlc2VudGluZyZsdDttYXRoJmd0O3ByZXNlbnRhdGlvbm9jY2FzaW9uYWxseTxpbWcgd2lkdGg9Im5hdmlnYXRpb24iPmNvbXBlbnNhdGlvbmNoYW1waW9uc2hpcG1lZGlhPSJhbGwiIHZpb2xhdGlvbiBvZnJlZmVyZW5jZSB0b3JldHVybiB0cnVlO1N0cmljdC8vRU4iIHRyYW5zYWN0aW9uc2ludGVydmVudGlvbnZlcmlmaWNhdGlvbkluZm9ybWF0aW9uIGRpZmZpY3VsdGllc0NoYW1waW9uc2hpcGNhcGFiaWxpdGllczwhW2VuZGlmXS0tPn0KPC9zY3JpcHQ+CkNocmlzdGlhbml0eWZvciBleGFtcGxlLFByb2Zlc3Npb25hbHJlc3RyaWN0aW9uc3N1Z2dlc3QgdGhhdHdhcyByZWxlYXNlZChzdWNoIGFzIHRoZXJlbW92ZUNsYXNzKHVuZW1wbG95bWVudHRoZSBBbWVyaWNhbnN0cnVjdHVyZSBvZi9pbmRleC5odG1sIHB1Ymxpc2hlZCBpbnNwYW4gY2xhc3M9IiI+PGEgaHJlZj0iL2ludHJvZHVjdGlvbmJlbG9uZ2luZyB0b2NsYWltZWQgdGhhdGNvbnNlcXVlbmNlczxtZXRhIG5hbWU9Ikd1aWRlIHRvIHRoZW92ZXJ3aGVsbWluZ2FnYWluc3QgdGhlIGNvbmNlbnRyYXRlZCwKLm5vbnRvdWNoIG9ic2VydmF0aW9uczwvYT4KPC9kaXY+CmYgKGRvY3VtZW50LmJvcmRlcjogMXB4IHtmb250LXNpemU6MXRyZWF0bWVudCBvZjAiIGhlaWdodD0iMW1vZGlmaWNhdGlvbkluZGVwZW5kZW5jZWRpdmlkZWQgaW50b2dyZWF0ZXIgdGhhbmFjaGlldmVtZW50c2VzdGFibGlzaGluZ0phdmFTY3JpcHQiIG5ldmVydGhlbGVzc3NpZ25pZmljYW5jZUJyb2FkY2FzdGluZz4mbmJzcDs8L3RkPmNvbnRhaW5lciI+CnN1Y2ggYXMgdGhlIGluZmx1ZW5jZSBvZmEgcGFydGljdWxhcnNyYz0naHR0cDovL25hdmlnYXRpb24iIGhhbGYgb2YgdGhlIHN1YnN0YW50aWFsICZuYnNwOzwvZGl2PmFkdmFudGFnZSBvZmRpc2NvdmVyeSBvZmZ1bmRhbWVudGFsIG1ldHJvcG9saXRhbnRoZSBvcHBvc2l0ZSIgeG1sOmxhbmc9ImRlbGliZXJhdGVseWFsaWduPWNlbnRlcmV2b2x1dGlvbiBvZnByZXNlcnZhdGlvbmltcHJvdmVtZW50c2JlZ2lubmluZyBpbkplc3VzIENocmlzdFB1YmxpY2F0aW9uc2Rpc2FncmVlbWVudHRleHQtYWxpZ246ciwgZnVuY3Rpb24oKXNpbWlsYXJpdGllc2JvZHk+PC9odG1sPmlzIGN1cnJlbnRseWFscGhhYmV0aWNhbGlzIHNvbWV0aW1lc3R5cGU9ImltYWdlL21hbnkgb2YgdGhlIGZsb3c6aGlkZGVuO2F2YWlsYWJsZSBpbmRlc2NyaWJlIHRoZWV4aXN0ZW5jZSBvZmFsbCBvdmVyIHRoZXRoZSBJbnRlcm5ldAk8dWwgY2xhc3M9Imluc3RhbGxhdGlvbm5laWdoYm9yaG9vZGFybWVkIGZvcmNlc3JlZHVjaW5nIHRoZWNvbnRpbnVlcyB0b05vbmV0aGVsZXNzLHRlbXBlcmF0dXJlcwoJCTxhIGhyZWY9ImNsb3NlIHRvIHRoZWV4YW1wbGVzIG9mIGlzIGFib3V0IHRoZShzZWUgYmVsb3cpLiIgaWQ9InNlYXJjaHByb2Zlc3Npb25hbGlzIGF2YWlsYWJsZXRoZSBvZmZpY2lhbAkJPC9zY3JpcHQ+CgoJCTxkaXYgaWQ9ImFjY2VsZXJhdGlvbnRocm91Z2ggdGhlIEhhbGwgb2YgRmFtZWRlc2NyaXB0aW9uc3RyYW5zbGF0aW9uc2ludGVyZmVyZW5jZSB0eXBlPSd0ZXh0L3JlY2VudCB5ZWFyc2luIHRoZSB3b3JsZHZlcnkgcG9wdWxhcntiYWNrZ3JvdW5kOnRyYWRpdGlvbmFsIHNvbWUgb2YgdGhlIGNvbm5lY3RlZCB0b2V4cGxvaXRhdGlvbmVtZXJnZW5jZSBvZmNvbnN0aXR1dGlvbkEgSGlzdG9yeSBvZnNpZ25pZmljYW50IG1hbnVmYWN0dXJlZGV4cGVjdGF0aW9ucz48bm9zY3JpcHQ+PGNhbiBiZSBmb3VuZGJlY2F1c2UgdGhlIGhhcyBub3QgYmVlbm5laWdoYm91cmluZ3dpdGhvdXQgdGhlIGFkZGVkIHRvIHRoZQk8bGkgY2xhc3M9Imluc3RydW1lbnRhbFNvdmlldCBVbmlvbmFja25vd2xlZGdlZHdoaWNoIGNhbiBiZW5hbWUgZm9yIHRoZWF0dGVudGlvbiB0b2F0dGVtcHRzIHRvIGRldmVsb3BtZW50c0luIGZhY3QsIHRoZTxsaSBjbGFzcz0iYWltcGxpY2F0aW9uc3N1aXRhYmxlIGZvcm11Y2ggb2YgdGhlIGNvbG9uaXphdGlvbnByZXNpZGVudGlhbGNhbmNlbEJ1YmJsZSBJbmZvcm1hdGlvbm1vc3Qgb2YgdGhlIGlzIGRlc2NyaWJlZHJlc3Qgb2YgdGhlIG1vcmUgb3IgbGVzc2luIFNlcHRlbWJlckludGVsbGlnZW5jZXNyYz0iaHR0cDovL3B4OyBoZWlnaHQ6IGF2YWlsYWJsZSB0b21hbnVmYWN0dXJlcmh1bWFuIHJpZ2h0c2xpbmsgaHJlZj0iL2F2YWlsYWJpbGl0eXByb3BvcnRpb25hbG91dHNpZGUgdGhlIGFzdHJvbm9taWNhbGh1bWFuIGJlaW5nc25hbWUgb2YgdGhlIGFyZSBmb3VuZCBpbmFyZSBiYXNlZCBvbnNtYWxsZXIgdGhhbmEgcGVyc29uIHdob2V4cGFuc2lvbiBvZmFyZ3VpbmcgdGhhdG5vdyBrbm93biBhc0luIHRoZSBlYXJseWludGVybWVkaWF0ZWRlcml2ZWQgZnJvbVNjYW5kaW5hdmlhbjwvYT48L2Rpdj4NCmNvbnNpZGVyIHRoZWFuIGVzdGltYXRlZHRoZSBOYXRpb25hbDxkaXYgaWQ9InBhZ3Jlc3VsdGluZyBpbmNvbW1pc3Npb25lZGFuYWxvZ291cyB0b2FyZSByZXF1aXJlZC91bD4KPC9kaXY+CndhcyBiYXNlZCBvbmFuZCBiZWNhbWUgYSZuYnNwOyZuYnNwO3QiIHZhbHVlPSIiIHdhcyBjYXB0dXJlZG5vIG1vcmUgdGhhbnJlc3BlY3RpdmVseWNvbnRpbnVlIHRvID4NCjxoZWFkPg0KPHdlcmUgY3JlYXRlZG1vcmUgZ2VuZXJhbGluZm9ybWF0aW9uIHVzZWQgZm9yIHRoZWluZGVwZW5kZW50IHRoZSBJbXBlcmlhbGNvbXBvbmVudCBvZnRvIHRoZSBub3J0aGluY2x1ZGUgdGhlIENvbnN0cnVjdGlvbnNpZGUgb2YgdGhlIHdvdWxkIG5vdCBiZWZvciBpbnN0YW5jZWludmVudGlvbiBvZm1vcmUgY29tcGxleGNvbGxlY3RpdmVseWJhY2tncm91bmQ6IHRleHQtYWxpZ246IGl0cyBvcmlnaW5hbGludG8gYWNjb3VudHRoaXMgcHJvY2Vzc2FuIGV4dGVuc2l2ZWhvd2V2ZXIsIHRoZXRoZXkgYXJlIG5vdHJlamVjdGVkIHRoZWNyaXRpY2lzbSBvZmR1cmluZyB3aGljaHByb2JhYmx5IHRoZXRoaXMgYXJ0aWNsZShmdW5jdGlvbigpe0l0IHNob3VsZCBiZWFuIGFncmVlbWVudGFjY2lkZW50YWxseWRpZmZlcnMgZnJvbUFyY2hpdGVjdHVyZWJldHRlciBrbm93bmFycmFuZ2VtZW50c2luZmx1ZW5jZSBvbmF0dGVuZGVkIHRoZWlkZW50aWNhbCB0b3NvdXRoIG9mIHRoZXBhc3MgdGhyb3VnaHhtbCIgdGl0bGU9IndlaWdodDpib2xkO2NyZWF0aW5nIHRoZWRpc3BsYXk6bm9uZXJlcGxhY2VkIHRoZTxpbWcgc3JjPSIvaWh0dHBzOi8vd3d3LldvcmxkIFdhciBJSXRlc3RpbW9uaWFsc2ZvdW5kIGluIHRoZXJlcXVpcmVkIHRvIGFuZCB0aGF0IHRoZWJldHdlZW4gdGhlIHdhcyBkZXNpZ25lZGNvbnNpc3RzIG9mIGNvbnNpZGVyYWJseXB1Ymxpc2hlZCBieXRoZSBsYW5ndWFnZUNvbnNlcnZhdGlvbmNvbnNpc3RlZCBvZnJlZmVyIHRvIHRoZWJhY2sgdG8gdGhlIGNzcyIgbWVkaWE9IlBlb3BsZSBmcm9tIGF2YWlsYWJsZSBvbnByb3ZlZCB0byBiZXN1Z2dlc3Rpb25zIndhcyBrbm93biBhc3ZhcmlldGllcyBvZmxpa2VseSB0byBiZWNvbXByaXNlZCBvZnN1cHBvcnQgdGhlIGhhbmRzIG9mIHRoZWNvdXBsZWQgd2l0aGNvbm5lY3QgYW5kIGJvcmRlcjpub25lO3BlcmZvcm1hbmNlc2JlZm9yZSBiZWluZ2xhdGVyIGJlY2FtZWNhbGN1bGF0aW9uc29mdGVuIGNhbGxlZHJlc2lkZW50cyBvZm1lYW5pbmcgdGhhdD48bGkgY2xhc3M9ImV2aWRlbmNlIGZvcmV4cGxhbmF0aW9uc2Vudmlyb25tZW50cyI+PC9hPjwvZGl2PndoaWNoIGFsbG93c0ludHJvZHVjdGlvbmRldmVsb3BlZCBieWEgd2lkZSByYW5nZW9uIGJlaGFsZiBvZnZhbGlnbj0idG9wInByaW5jaXBsZSBvZmF0IHRoZSB0aW1lLDwvbm9zY3JpcHQ+DXNhaWQgdG8gaGF2ZWluIHRoZSBmaXJzdHdoaWxlIG90aGVyc2h5cG90aGV0aWNhbHBoaWxvc29waGVyc3Bvd2VyIG9mIHRoZWNvbnRhaW5lZCBpbnBlcmZvcm1lZCBieWluYWJpbGl0eSB0b3dlcmUgd3JpdHRlbnNwYW4gc3R5bGU9ImlucHV0IG5hbWU9InRoZSBxdWVzdGlvbmludGVuZGVkIGZvcnJlamVjdGlvbiBvZmltcGxpZXMgdGhhdGludmVudGVkIHRoZXRoZSBzdGFuZGFyZHdhcyBwcm9iYWJseWxpbmsgYmV0d2VlbnByb2Zlc3NvciBvZmludGVyYWN0aW9uc2NoYW5naW5nIHRoZUluZGlhbiBPY2VhbiBjbGFzcz0ibGFzdHdvcmtpbmcgd2l0aCdodHRwOi8vd3d3LnllYXJzIGJlZm9yZVRoaXMgd2FzIHRoZXJlY3JlYXRpb25hbGVudGVyaW5nIHRoZW1lYXN1cmVtZW50c2FuIGV4dHJlbWVseXZhbHVlIG9mIHRoZXN0YXJ0IG9mIHRoZQo8L3NjcmlwdD4KCmFuIGVmZm9ydCB0b2luY3JlYXNlIHRoZXRvIHRoZSBzb3V0aHNwYWNpbmc9IjAiPnN1ZmZpY2llbnRseXRoZSBFdXJvcGVhbmNvbnZlcnRlZCB0b2NsZWFyVGltZW91dGRpZCBub3QgaGF2ZWNvbnNlcXVlbnRseWZvciB0aGUgbmV4dGV4dGVuc2lvbiBvZmVjb25vbWljIGFuZGFsdGhvdWdoIHRoZWFyZSBwcm9kdWNlZGFuZCB3aXRoIHRoZWluc3VmZmljaWVudGdpdmVuIGJ5IHRoZXN0YXRpbmcgdGhhdGV4cGVuZGl0dXJlczwvc3Bhbj48L2E+CnRob3VnaHQgdGhhdG9uIHRoZSBiYXNpc2NlbGxwYWRkaW5nPWltYWdlIG9mIHRoZXJldHVybmluZyB0b2luZm9ybWF0aW9uLHNlcGFyYXRlZCBieWFzc2Fzc2luYXRlZHMiIGNvbnRlbnQ9ImF1dGhvcml0eSBvZm5vcnRod2VzdGVybjwvZGl2Pgo8ZGl2ICI+PC9kaXY+DQogIGNvbnN1bHRhdGlvbmNvbW11bml0eSBvZnRoZSBuYXRpb25hbGl0IHNob3VsZCBiZXBhcnRpY2lwYW50cyBhbGlnbj0ibGVmdHRoZSBncmVhdGVzdHNlbGVjdGlvbiBvZnN1cGVybmF0dXJhbGRlcGVuZGVudCBvbmlzIG1lbnRpb25lZGFsbG93aW5nIHRoZXdhcyBpbnZlbnRlZGFjY29tcGFueWluZ2hpcyBwZXJzb25hbGF2YWlsYWJsZSBhdHN0dWR5IG9mIHRoZW9uIHRoZSBvdGhlcmV4ZWN1dGlvbiBvZkh1bWFuIFJpZ2h0c3Rlcm1zIG9mIHRoZWFzc29jaWF0aW9uc3Jlc2VhcmNoIGFuZHN1Y2NlZWRlZCBieWRlZmVhdGVkIHRoZWFuZCBmcm9tIHRoZWJ1dCB0aGV5IGFyZWNvbW1hbmRlciBvZnN0YXRlIG9mIHRoZXllYXJzIG9mIGFnZXRoZSBzdHVkeSBvZjx1bCBjbGFzcz0ic3BsYWNlIGluIHRoZXdoZXJlIGhlIHdhczxsaSBjbGFzcz0iZnRoZXJlIGFyZSBub3doaWNoIGJlY2FtZWhlIHB1Ymxpc2hlZGV4cHJlc3NlZCBpbnRvIHdoaWNoIHRoZWNvbW1pc3Npb25lcmZvbnQtd2VpZ2h0OnRlcnJpdG9yeSBvZmV4dGVuc2lvbnMiPlJvbWFuIEVtcGlyZWVxdWFsIHRvIHRoZUluIGNvbnRyYXN0LGhvd2V2ZXIsIGFuZGlzIHR5cGljYWxseWFuZCBoaXMgd2lmZShhbHNvIGNhbGxlZD48dWwgY2xhc3M9ImVmZmVjdGl2ZWx5IGV2b2x2ZWQgaW50b3NlZW0gdG8gaGF2ZXdoaWNoIGlzIHRoZXRoZXJlIHdhcyBub2FuIGV4Y2VsbGVudGFsbCBvZiB0aGVzZWRlc2NyaWJlZCBieUluIHByYWN0aWNlLGJyb2FkY2FzdGluZ2NoYXJnZWQgd2l0aHJlZmxlY3RlZCBpbnN1YmplY3RlZCB0b21pbGl0YXJ5IGFuZHRvIHRoZSBwb2ludGVjb25vbWljYWxseXNldFRhcmdldGluZ2FyZSBhY3R1YWxseXZpY3Rvcnkgb3ZlcigpOzwvc2NyaXB0PmNvbnRpbnVvdXNseXJlcXVpcmVkIGZvcmV2b2x1dGlvbmFyeWFuIGVmZmVjdGl2ZW5vcnRoIG9mIHRoZSwgd2hpY2ggd2FzIGZyb250IG9mIHRoZW9yIG90aGVyd2lzZXNvbWUgZm9ybSBvZmhhZCBub3QgYmVlbmdlbmVyYXRlZCBieWluZm9ybWF0aW9uLnBlcm1pdHRlZCB0b2luY2x1ZGVzIHRoZWRldmVsb3BtZW50LGVudGVyZWQgaW50b3RoZSBwcmV2aW91c2NvbnNpc3RlbnRseWFyZSBrbm93biBhc3RoZSBmaWVsZCBvZnRoaXMgdHlwZSBvZmdpdmVuIHRvIHRoZXRoZSB0aXRsZSBvZmNvbnRhaW5zIHRoZWluc3RhbmNlcyBvZmluIHRoZSBub3J0aGR1ZSB0byB0aGVpcmFyZSBkZXNpZ25lZGNvcnBvcmF0aW9uc3dhcyB0aGF0IHRoZW9uZSBvZiB0aGVzZW1vcmUgcG9wdWxhcnN1Y2NlZWRlZCBpbnN1cHBvcnQgZnJvbWluIGRpZmZlcmVudGRvbWluYXRlZCBieWRlc2lnbmVkIGZvcm93bmVyc2hpcCBvZmFuZCBwb3NzaWJseXN0YW5kYXJkaXplZHJlc3BvbnNlVGV4dHdhcyBpbnRlbmRlZHJlY2VpdmVkIHRoZWFzc3VtZWQgdGhhdGFyZWFzIG9mIHRoZXByaW1hcmlseSBpbnRoZSBiYXNpcyBvZmluIHRoZSBzZW5zZWFjY291bnRzIGZvcmRlc3Ryb3llZCBieWF0IGxlYXN0IHR3b3dhcyBkZWNsYXJlZGNvdWxkIG5vdCBiZVNlY3JldGFyeSBvZmFwcGVhciB0byBiZW1hcmdpbi10b3A6MS9eXHMrfFxzKyQvZ2Upe3Rocm93IGV9O3RoZSBzdGFydCBvZnR3byBzZXBhcmF0ZWxhbmd1YWdlIGFuZHdobyBoYWQgYmVlbm9wZXJhdGlvbiBvZmRlYXRoIG9mIHRoZXJlYWwgbnVtYmVycwk8bGluayByZWw9InByb3ZpZGVkIHRoZXRoZSBzdG9yeSBvZmNvbXBldGl0aW9uc2VuZ2xpc2ggKFVLKWVuZ2xpc2ggKFVTKdCc0L7QvdCz0L7Qu9Ch0YDQv9GB0LrQuNGB0YDQv9GB0LrQuNGB0YDQv9GB0LrQvtmE2LnYsdio2YrYqeato+mrlOS4reaWh+eugOS9k+S4reaWh+e5geS9k+S4reaWh+aciemZkOWFrOWPuOS6uuawkeaUv+W6nOmYv+mHjOW3tOW3tOekvuS8muS4u+S5ieaTjeS9nOezu+e7n+aUv+etluazleinhGluZm9ybWFjacOzbmhlcnJhbWllbnRhc2VsZWN0csOzbmljb2Rlc2NyaXBjacOzbmNsYXNpZmljYWRvc2Nvbm9jaW1pZW50b3B1YmxpY2FjacOzbnJlbGFjaW9uYWRhc2luZm9ybcOhdGljYXJlbGFjaW9uYWRvc2RlcGFydGFtZW50b3RyYWJhamFkb3Jlc2RpcmVjdGFtZW50ZWF5dW50YW1pZW50b21lcmNhZG9MaWJyZWNvbnTDoWN0ZW5vc2hhYml0YWNpb25lc2N1bXBsaW1pZW50b3Jlc3RhdXJhbnRlc2Rpc3Bvc2ljacOzbmNvbnNlY3VlbmNpYWVsZWN0csOzbmljYWFwbGljYWNpb25lc2Rlc2NvbmVjdGFkb2luc3RhbGFjacOzbnJlYWxpemFjacOzbnV0aWxpemFjacOzbmVuY2ljbG9wZWRpYWVuZmVybWVkYWRlc2luc3RydW1lbnRvc2V4cGVyaWVuY2lhc2luc3RpdHVjacOzbnBhcnRpY3VsYXJlc3N1YmNhdGVnb3JpYdGC0L7Qu9GM0LrQvtCg0L7RgdGB0LjQuNGA0LDQsdC+0YLRi9Cx0L7Qu9GM0YjQtdC/0YDQvtGB0YLQvtC80L7QttC10YLQtdC00YDRg9Cz0LjRhdGB0LvRg9GH0LDQtdGB0LXQudGH0LDRgdCy0YHQtdCz0LTQsNCg0L7RgdGB0LjRj9Cc0L7RgdC60LLQtdC00YDRg9Cz0LjQtdCz0L7RgNC+0LTQsNCy0L7Qv9GA0L7RgdC00LDQvdC90YvRhdC00L7Qu9C20L3Ri9C40LzQtdC90L3QvtCc0L7RgdC60LLRi9GA0YPQsdC70LXQudCc0L7RgdC60LLQsNGB0YLRgNCw0L3Ri9C90LjRh9C10LPQvtGA0LDQsdC+0YLQtdC00L7Qu9C20LXQvdGD0YHQu9GD0LPQuNGC0LXQv9C10YDRjNCe0LTQvdCw0LrQvtC/0L7RgtC+0LzRg9GA0LDQsdC+0YLRg9Cw0L/RgNC10LvRj9Cy0L7QvtCx0YnQtdC+0LTQvdC+0LPQvtGB0LLQvtC10LPQvtGB0YLQsNGC0YzQuNC00YDRg9Cz0L7QudGE0L7RgNGD0LzQtdGF0L7RgNC+0YjQvtC/0YDQvtGC0LjQstGB0YHRi9C70LrQsNC60LDQttC00YvQudCy0LvQsNGB0YLQuNCz0YDRg9C/0L/Ri9Cy0LzQtdGB0YLQtdGA0LDQsdC+0YLQsNGB0LrQsNC30LDQu9C/0LXRgNCy0YvQudC00LXQu9Cw0YLRjNC00LXQvdGM0LPQuNC/0LXRgNC40L7QtNCx0LjQt9C90LXRgdC+0YHQvdC+0LLQtdC80L7QvNC10L3RgtC60YPQv9C40YLRjNC00L7Qu9C20L3QsNGA0LDQvNC60LDRhdC90LDRh9Cw0LvQvtCg0LDQsdC+0YLQsNCi0L7Qu9GM0LrQvtGB0L7QstGB0LXQvNCy0YLQvtGA0L7QudC90LDRh9Cw0LvQsNGB0L/QuNGB0L7QutGB0LvRg9C20LHRi9GB0LjRgdGC0LXQvNC/0LXRh9Cw0YLQuNC90L7QstC+0LPQvtC/0L7QvNC+0YnQuNGB0LDQudGC0L7QstC/0L7Rh9C10LzRg9C/0L7QvNC+0YnRjNC00L7Qu9C20L3QvtGB0YHRi9C70LrQuNCx0YvRgdGC0YDQvtC00LDQvdC90YvQtdC80L3QvtCz0LjQtdC/0YDQvtC10LrRgtCh0LXQudGH0LDRgdC80L7QtNC10LvQuNGC0LDQutC+0LPQvtC+0L3Qu9Cw0LnQvdCz0L7RgNC+0LTQtdCy0LXRgNGB0LjRj9GB0YLRgNCw0L3QtdGE0LjQu9GM0LzRi9GD0YDQvtCy0L3Rj9GA0LDQt9C90YvRhdC40YHQutCw0YLRjNC90LXQtNC10LvRjtGP0L3QstCw0YDRj9C80LXQvdGM0YjQtdC80L3QvtCz0LjRhdC00LDQvdC90L7QudC30L3QsNGH0LjRgtC90LXQu9GM0LfRj9GE0L7RgNGD0LzQsNCi0LXQv9C10YDRjNC80LXRgdGP0YbQsNC30LDRidC40YLRi9Cb0YPRh9GI0LjQteCkqOCkueClgOCkguCkleCksOCkqOClh+CkheCkquCkqOClh+CkleCkv+Ckr+CkvuCkleCksOClh+CkguCkheCkqOCljeCkr+CkleCljeCkr+CkvuCkl+CkvuCkh+CkoeCkrOCkvuCksOClh+CkleCkv+CkuOClgOCkpuCkv+Ckr+CkvuCkquCkueCksuClh+CkuOCkv+CkguCkueCkreCkvuCksOCkpOCkheCkquCkqOClgOCkteCkvuCksuClh+CkuOClh+CkteCkvuCkleCksOCkpOClh+CkruClh+CksOClh+CkueCli+CkqOClh+CkuOCkleCkpOClh+CkrOCkueClgeCkpOCkuOCkvuCkh+Ckn+CkueCli+Ckl+CkvuCknOCkvuCkqOClh+CkruCkv+CkqOCkn+CkleCksOCkpOCkvuCkleCksOCkqOCkvuCkieCkqOCkleClh+Ckr+CkueCkvuCkgeCkuOCkrOCkuOClh+CkreCkvuCkt+CkvuCkhuCkquCkleClh+CksuCkv+Ckr+Clh+CktuClgeCksOClguCkh+CkuOCkleClh+CkmOCkguCkn+Clh+CkruClh+CksOClgOCkuOCkleCkpOCkvuCkruClh+CksOCkvuCksuClh+CkleCksOCkheCkp+Ckv+CkleCkheCkquCkqOCkvuCkuOCkruCkvuCknOCkruClgeCkneClh+CkleCkvuCksOCko+CkueCli+CkpOCkvuCkleCkoeCkvOClgOCkr+CkueCkvuCkguCkueCli+Ckn+CksuCktuCkrOCljeCkpuCksuCkv+Ckr+CkvuCknOClgOCkteCkqOCknOCkvuCkpOCkvuCkleCliOCkuOClh+CkhuCkquCkleCkvuCkteCkvuCksuClgOCkpuClh+CkqOClh+CkquClguCksOClgOCkquCkvuCkqOClgOCkieCkuOCkleClh+CkueCli+Ckl+ClgOCkrOCliOCkoOCkleCkhuCkquCkleClgOCkteCksOCljeCkt+Ckl+CkvuCkguCkteCkhuCkquCkleCli+CknOCkv+CksuCkvuCknOCkvuCkqOCkvuCkuOCkueCkruCkpOCkueCkruClh+CkguCkieCkqOCkleClgOCkr+CkvuCkueClguCkpuCksOCljeCknOCkuOClguCkmuClgOCkquCkuOCkguCkpuCkuOCkteCkvuCksuCkueCli+CkqOCkvuCkueCli+CkpOClgOCknOCliOCkuOClh+CkteCkvuCkquCkuOCknOCkqOCkpOCkvuCkqOClh+CkpOCkvuCknOCkvuCksOClgOCkmOCkvuCkr+CksuCknOCkv+CksuClh+CkqOClgOCkmuClh+CknOCkvuCkguCkmuCkquCkpOCljeCksOCkl+ClguCkl+CksuCknOCkvuCkpOClh+CkrOCkvuCkueCksOCkhuCkquCkqOClh+CkteCkvuCkueCkqOCkh+CkuOCkleCkvuCkuOClgeCkrOCkueCksOCkueCkqOClh+Ckh+CkuOCkuOClh+CkuOCkueCkv+CkpOCkrOCkoeCkvOClh+CkmOCkn+CkqOCkvuCkpOCksuCkvuCktuCkquCkvuCkguCkmuCktuCljeCksOClgOCkrOCkoeCkvOClgOCkueCli+CkpOClh+CkuOCkvuCkiOCkn+CktuCkvuCkr+CkpuCkuOCkleCkpOClgOCknOCkvuCkpOClgOCkteCkvuCksuCkvuCkueCknOCkvuCksOCkquCkn+CkqOCkvuCksOCkluCkqOClh+CkuOCkoeCkvOCkleCkruCkv+CksuCkvuCkieCkuOCkleClgOCkleClh+CkteCksuCksuCkl+CkpOCkvuCkluCkvuCkqOCkvuCkheCksOCljeCkpeCknOCkueCkvuCkguCkpuClh+CkluCkvuCkquCkueCksuClgOCkqOCkv+Ckr+CkruCkrOCkv+CkqOCkvuCkrOCliOCkguCkleCkleCkueClgOCkguCkleCkueCkqOCkvuCkpuClh+CkpOCkvuCkueCkruCksuClh+CkleCkvuCkq+ClgOCknOCkrOCkleCkv+CkpOClgeCksOCkpOCkruCkvuCkguCkl+CkteCkueClgOCkguCksOCli+CknOCkvOCkruCkv+CksuClgOCkhuCksOCli+CkquCkuOClh+CkqOCkvuCkr+CkvuCkpuCkteCksuClh+CkqOClh+CkluCkvuCkpOCkvuCkleCksOClgOCkrOCkieCkqOCkleCkvuCknOCkteCkvuCkrOCkquClguCksOCkvuCkrOCkoeCkvOCkvuCkuOCljOCkpuCkvuCktuClh+Ckr+CksOCkleCkv+Ckr+Clh+CkleCkueCkvuCkguCkheCkleCkuOCksOCkrOCkqOCkvuCkj+CkteCkueCkvuCkguCkuOCljeCkpeCksuCkruCkv+CksuClh+CksuClh+CkluCkleCkteCkv+Ckt+Ckr+CkleCljeCksOCkguCkuOCkruClguCkueCkpeCkvuCkqOCkvtiq2LPYqti32YrYudmF2LTYp9ix2YPYqdio2YjYp9iz2LfYqdin2YTYtdmB2K3YqdmF2YjYp9i22YrYudin2YTYrtin2LXYqdin2YTZhdiy2YrYr9in2YTYudin2YXYqdin2YTZg9in2KrYqNin2YTYsdiv2YjYr9io2LHZhtin2YXYrNin2YTYr9mI2YTYqdin2YTYudin2YTZhdin2YTZhdmI2YLYudin2YTYudix2KjZitin2YTYs9ix2YrYudin2YTYrNmI2KfZhNin2YTYsNmH2KfYqNin2YTYrdmK2KfYqdin2YTYrdmC2YjZgtin2YTZg9ix2YrZhdin2YTYudix2KfZgtmF2K3ZgdmI2LjYqdin2YTYq9in2YbZitmF2LTYp9mH2K/Yqdin2YTZhdix2KPYqdin2YTZgtix2KLZhtin2YTYtNio2KfYqNin2YTYrdmI2KfYsdin2YTYrNiv2YrYr9in2YTYo9iz2LHYqdin2YTYudmE2YjZhdmF2KzZhdmI2LnYqdin2YTYsdit2YXZhtin2YTZhtmC2KfYt9mB2YTYs9i32YrZhtin2YTZg9mI2YrYqtin2YTYr9mG2YrYp9io2LHZg9in2KrZh9in2YTYsdmK2KfYttiq2K3Zitin2KrZitio2KrZiNmC2YrYqtin2YTYo9mI2YTZidin2YTYqNix2YrYr9in2YTZg9mE2KfZhdin2YTYsdin2KjYt9in2YTYtNiu2LXZitiz2YrYp9ix2KfYqtin2YTYq9in2YTYq9in2YTYtdmE2KfYqdin2YTYrdiv2YrYq9in2YTYstmI2KfYsdin2YTYrtmE2YrYrNin2YTYrNmF2YrYudin2YTYudin2YXZh9in2YTYrNmF2KfZhNin2YTYs9in2LnYqdmF2LTYp9mH2K/Zh9in2YTYsdim2YrYs9in2YTYr9iu2YjZhNin2YTZgdmG2YrYqdin2YTZg9iq2KfYqNin2YTYr9mI2LHZitin2YTYr9ix2YjYs9in2LPYqti62LHZgtiq2LXYp9mF2YrZhdin2YTYqNmG2KfYqtin2YTYudi42YrZhWVudGVydGFpbm1lbnR1bmRlcnN0YW5kaW5nID0gZnVuY3Rpb24oKS5qcGciIHdpZHRoPSJjb25maWd1cmF0aW9uLnBuZyIgd2lkdGg9Ijxib2R5IGNsYXNzPSJNYXRoLnJhbmRvbSgpY29udGVtcG9yYXJ5IFVuaXRlZCBTdGF0ZXNjaXJjdW1zdGFuY2VzLmFwcGVuZENoaWxkKG9yZ2FuaXphdGlvbnM8c3BhbiBjbGFzcz0iIj48aW1nIHNyYz0iL2Rpc3Rpbmd1aXNoZWR0aG91c2FuZHMgb2YgY29tbXVuaWNhdGlvbmNsZWFyIj48L2Rpdj5pbnZlc3RpZ2F0aW9uZmF2aWNvbi5pY28iIG1hcmdpbi1yaWdodDpiYXNlZCBvbiB0aGUgTWFzc2FjaHVzZXR0c3RhYmxlIGJvcmRlcj1pbnRlcm5hdGlvbmFsYWxzbyBrbm93biBhc3Byb251bmNpYXRpb25iYWNrZ3JvdW5kOiNmcGFkZGluZy1sZWZ0OkZvciBleGFtcGxlLCBtaXNjZWxsYW5lb3VzJmx0Oy9tYXRoJmd0O3BzeWNob2xvZ2ljYWxpbiBwYXJ0aWN1bGFyZWFyY2giIHR5cGU9ImZvcm0gbWV0aG9kPSJhcyBvcHBvc2VkIHRvU3VwcmVtZSBDb3VydG9jY2FzaW9uYWxseSBBZGRpdGlvbmFsbHksTm9ydGggQW1lcmljYXB4O2JhY2tncm91bmRvcHBvcnR1bml0aWVzRW50ZXJ0YWlubWVudC50b0xvd2VyQ2FzZShtYW51ZmFjdHVyaW5ncHJvZmVzc2lvbmFsIGNvbWJpbmVkIHdpdGhGb3IgaW5zdGFuY2UsY29uc2lzdGluZyBvZiIgbWF4bGVuZ3RoPSJyZXR1cm4gZmFsc2U7Y29uc2Npb3VzbmVzc01lZGl0ZXJyYW5lYW5leHRyYW9yZGluYXJ5YXNzYXNzaW5hdGlvbnN1YnNlcXVlbnRseSBidXR0b24gdHlwZT0idGhlIG51bWJlciBvZnRoZSBvcmlnaW5hbCBjb21wcmVoZW5zaXZlcmVmZXJzIHRvIHRoZTwvdWw+CjwvZGl2PgpwaGlsb3NvcGhpY2FsbG9jYXRpb24uaHJlZndhcyBwdWJsaXNoZWRTYW4gRnJhbmNpc2NvKGZ1bmN0aW9uKCl7CjxkaXYgaWQ9Im1haW5zb3BoaXN0aWNhdGVkbWF0aGVtYXRpY2FsIC9oZWFkPg0KPGJvZHlzdWdnZXN0cyB0aGF0ZG9jdW1lbnRhdGlvbmNvbmNlbnRyYXRpb25yZWxhdGlvbnNoaXBzbWF5IGhhdmUgYmVlbihmb3IgZXhhbXBsZSxUaGlzIGFydGljbGUgaW4gc29tZSBjYXNlc3BhcnRzIG9mIHRoZSBkZWZpbml0aW9uIG9mR3JlYXQgQnJpdGFpbiBjZWxscGFkZGluZz1lcXVpdmFsZW50IHRvcGxhY2Vob2xkZXI9IjsgZm9udC1zaXplOiBqdXN0aWZpY2F0aW9uYmVsaWV2ZWQgdGhhdHN1ZmZlcmVkIGZyb21hdHRlbXB0ZWQgdG8gbGVhZGVyIG9mIHRoZWNyaXB0IiBzcmM9Ii8oZnVuY3Rpb24oKSB7YXJlIGF2YWlsYWJsZQoJPGxpbmsgcmVsPSIgc3JjPSdodHRwOi8vaW50ZXJlc3RlZCBpbmNvbnZlbnRpb25hbCAiIGFsdD0iIiAvPjwvYXJlIGdlbmVyYWxseWhhcyBhbHNvIGJlZW5tb3N0IHBvcHVsYXIgY29ycmVzcG9uZGluZ2NyZWRpdGVkIHdpdGh0eWxlPSJib3JkZXI6PC9hPjwvc3Bhbj48Ly5naWYiIHdpZHRoPSI8aWZyYW1lIHNyYz0idGFibGUgY2xhc3M9ImlubGluZS1ibG9jazthY2NvcmRpbmcgdG8gdG9nZXRoZXIgd2l0aGFwcHJveGltYXRlbHlwYXJsaWFtZW50YXJ5bW9yZSBhbmQgbW9yZWRpc3BsYXk6bm9uZTt0cmFkaXRpb25hbGx5cHJlZG9taW5hbnRseSZuYnNwO3wmbmJzcDsmbmJzcDs8L3NwYW4+IGNlbGxzcGFjaW5nPTxpbnB1dCBuYW1lPSJvciIgY29udGVudD0iY29udHJvdmVyc2lhbHByb3BlcnR5PSJvZzoveC1zaG9ja3dhdmUtZGVtb25zdHJhdGlvbnN1cnJvdW5kZWQgYnlOZXZlcnRoZWxlc3Msd2FzIHRoZSBmaXJzdGNvbnNpZGVyYWJsZSBBbHRob3VnaCB0aGUgY29sbGFib3JhdGlvbnNob3VsZCBub3QgYmVwcm9wb3J0aW9uIG9mPHNwYW4gc3R5bGU9Imtub3duIGFzIHRoZSBzaG9ydGx5IGFmdGVyZm9yIGluc3RhbmNlLGRlc2NyaWJlZCBhcyAvaGVhZD4KPGJvZHkgc3RhcnRpbmcgd2l0aGluY3JlYXNpbmdseSB0aGUgZmFjdCB0aGF0ZGlzY3Vzc2lvbiBvZm1pZGRsZSBvZiB0aGVhbiBpbmRpdmlkdWFsZGlmZmljdWx0IHRvIHBvaW50IG9mIHZpZXdob21vc2V4dWFsaXR5YWNjZXB0YW5jZSBvZjwvc3Bhbj48L2Rpdj5tYW51ZmFjdHVyZXJzb3JpZ2luIG9mIHRoZWNvbW1vbmx5IHVzZWRpbXBvcnRhbmNlIG9mZGVub21pbmF0aW9uc2JhY2tncm91bmQ6ICNsZW5ndGggb2YgdGhlZGV0ZXJtaW5hdGlvbmEgc2lnbmlmaWNhbnQiIGJvcmRlcj0iMCI+cmV2b2x1dGlvbmFyeXByaW5jaXBsZXMgb2ZpcyBjb25zaWRlcmVkd2FzIGRldmVsb3BlZEluZG8tRXVyb3BlYW52dWxuZXJhYmxlIHRvcHJvcG9uZW50cyBvZmFyZSBzb21ldGltZXNjbG9zZXIgdG8gdGhlTmV3IFlvcmsgQ2l0eSBuYW1lPSJzZWFyY2hhdHRyaWJ1dGVkIHRvY291cnNlIG9mIHRoZW1hdGhlbWF0aWNpYW5ieSB0aGUgZW5kIG9mYXQgdGhlIGVuZCBvZiIgYm9yZGVyPSIwIiB0ZWNobm9sb2dpY2FsLnJlbW92ZUNsYXNzKGJyYW5jaCBvZiB0aGVldmlkZW5jZSB0aGF0IVtlbmRpZl0tLT4NCkluc3RpdHV0ZSBvZiBpbnRvIGEgc2luZ2xlcmVzcGVjdGl2ZWx5LmFuZCB0aGVyZWZvcmVwcm9wZXJ0aWVzIG9maXMgbG9jYXRlZCBpbnNvbWUgb2Ygd2hpY2hUaGVyZSBpcyBhbHNvY29udGludWVkIHRvIGFwcGVhcmFuY2Ugb2YgJmFtcDtuZGFzaDsgZGVzY3JpYmVzIHRoZWNvbnNpZGVyYXRpb25hdXRob3Igb2YgdGhlaW5kZXBlbmRlbnRseWVxdWlwcGVkIHdpdGhkb2VzIG5vdCBoYXZlPC9hPjxhIGhyZWY9ImNvbmZ1c2VkIHdpdGg8bGluayBocmVmPSIvYXQgdGhlIGFnZSBvZmFwcGVhciBpbiB0aGVUaGVzZSBpbmNsdWRlcmVnYXJkbGVzcyBvZmNvdWxkIGJlIHVzZWQgc3R5bGU9JnF1b3Q7c2V2ZXJhbCB0aW1lc3JlcHJlc2VudCB0aGVib2R5Pgo8L2h0bWw+dGhvdWdodCB0byBiZXBvcHVsYXRpb24gb2Zwb3NzaWJpbGl0aWVzcGVyY2VudGFnZSBvZmFjY2VzcyB0byB0aGVhbiBhdHRlbXB0IHRvcHJvZHVjdGlvbiBvZmpxdWVyeS9qcXVlcnl0d28gZGlmZmVyZW50YmVsb25nIHRvIHRoZWVzdGFibGlzaG1lbnRyZXBsYWNpbmcgdGhlZGVzY3JpcHRpb24iIGRldGVybWluZSB0aGVhdmFpbGFibGUgZm9yQWNjb3JkaW5nIHRvIHdpZGUgcmFuZ2Ugb2YJPGRpdiBjbGFzcz0ibW9yZSBjb21tb25seW9yZ2FuaXNhdGlvbnNmdW5jdGlvbmFsaXR5d2FzIGNvbXBsZXRlZCAmYW1wO21kYXNoOyBwYXJ0aWNpcGF0aW9udGhlIGNoYXJhY3RlcmFuIGFkZGl0aW9uYWxhcHBlYXJzIHRvIGJlZmFjdCB0aGF0IHRoZWFuIGV4YW1wbGUgb2ZzaWduaWZpY2FudGx5b25tb3VzZW92ZXI9ImJlY2F1c2UgdGhleSBhc3luYyA9IHRydWU7cHJvYmxlbXMgd2l0aHNlZW1zIHRvIGhhdmV0aGUgcmVzdWx0IG9mIHNyYz0iaHR0cDovL2ZhbWlsaWFyIHdpdGhwb3NzZXNzaW9uIG9mZnVuY3Rpb24gKCkge3Rvb2sgcGxhY2UgaW5hbmQgc29tZXRpbWVzc3Vic3RhbnRpYWxseTxzcGFuPjwvc3Bhbj5pcyBvZnRlbiB1c2VkaW4gYW4gYXR0ZW1wdGdyZWF0IGRlYWwgb2ZFbnZpcm9ubWVudGFsc3VjY2Vzc2Z1bGx5IHZpcnR1YWxseSBhbGwyMHRoIGNlbnR1cnkscHJvZmVzc2lvbmFsc25lY2Vzc2FyeSB0byBkZXRlcm1pbmVkIGJ5Y29tcGF0aWJpbGl0eWJlY2F1c2UgaXQgaXNEaWN0aW9uYXJ5IG9mbW9kaWZpY2F0aW9uc1RoZSBmb2xsb3dpbmdtYXkgcmVmZXIgdG86Q29uc2VxdWVudGx5LEludGVybmF0aW9uYWxhbHRob3VnaCBzb21ldGhhdCB3b3VsZCBiZXdvcmxkJ3MgZmlyc3RjbGFzc2lmaWVkIGFzYm90dG9tIG9mIHRoZShwYXJ0aWN1bGFybHlhbGlnbj0ibGVmdCIgbW9zdCBjb21tb25seWJhc2lzIGZvciB0aGVmb3VuZGF0aW9uIG9mY29udHJpYnV0aW9uc3BvcHVsYXJpdHkgb2ZjZW50ZXIgb2YgdGhldG8gcmVkdWNlIHRoZWp1cmlzZGljdGlvbnNhcHByb3hpbWF0aW9uIG9ubW91c2VvdXQ9Ik5ldyBUZXN0YW1lbnRjb2xsZWN0aW9uIG9mPC9zcGFuPjwvYT48L2luIHRoZSBVbml0ZWRmaWxtIGRpcmVjdG9yLXN0cmljdC5kdGQiPmhhcyBiZWVuIHVzZWRyZXR1cm4gdG8gdGhlYWx0aG91Z2ggdGhpc2NoYW5nZSBpbiB0aGVzZXZlcmFsIG90aGVyYnV0IHRoZXJlIGFyZXVucHJlY2VkZW50ZWRpcyBzaW1pbGFyIHRvZXNwZWNpYWxseSBpbndlaWdodDogYm9sZDtpcyBjYWxsZWQgdGhlY29tcHV0YXRpb25hbGluZGljYXRlIHRoYXRyZXN0cmljdGVkIHRvCTxtZXRhIG5hbWU9ImFyZSB0eXBpY2FsbHljb25mbGljdCB3aXRoSG93ZXZlciwgdGhlIEFuIGV4YW1wbGUgb2Zjb21wYXJlZCB3aXRocXVhbnRpdGllcyBvZnJhdGhlciB0aGFuIGFjb25zdGVsbGF0aW9ubmVjZXNzYXJ5IGZvcnJlcG9ydGVkIHRoYXRzcGVjaWZpY2F0aW9ucG9saXRpY2FsIGFuZCZuYnNwOyZuYnNwOzxyZWZlcmVuY2VzIHRvdGhlIHNhbWUgeWVhckdvdmVybm1lbnQgb2ZnZW5lcmF0aW9uIG9maGF2ZSBub3QgYmVlbnNldmVyYWwgeWVhcnNjb21taXRtZW50IHRvCQk8dWwgY2xhc3M9InZpc3VhbGl6YXRpb24xOXRoIGNlbnR1cnkscHJhY3RpdGlvbmVyc3RoYXQgaGUgd291bGRhbmQgY29udGludWVkb2NjdXBhdGlvbiBvZmlzIGRlZmluZWQgYXNjZW50cmUgb2YgdGhldGhlIGFtb3VudCBvZj48ZGl2IHN0eWxlPSJlcXVpdmFsZW50IG9mZGlmZmVyZW50aWF0ZWJyb3VnaHQgYWJvdXRtYXJnaW4tbGVmdDogYXV0b21hdGljYWxseXRob3VnaHQgb2YgYXNTb21lIG9mIHRoZXNlCjxkaXYgY2xhc3M9ImlucHV0IGNsYXNzPSJyZXBsYWNlZCB3aXRoaXMgb25lIG9mIHRoZWVkdWNhdGlvbiBhbmRpbmZsdWVuY2VkIGJ5cmVwdXRhdGlvbiBhcwo8bWV0YSBuYW1lPSJhY2NvbW1vZGF0aW9uPC9kaXY+CjwvZGl2PmxhcmdlIHBhcnQgb2ZJbnN0aXR1dGUgZm9ydGhlIHNvLWNhbGxlZCBhZ2FpbnN0IHRoZSBJbiB0aGlzIGNhc2Usd2FzIGFwcG9pbnRlZGNsYWltZWQgdG8gYmVIb3dldmVyLCB0aGlzRGVwYXJ0bWVudCBvZnRoZSByZW1haW5pbmdlZmZlY3Qgb24gdGhlcGFydGljdWxhcmx5IGRlYWwgd2l0aCB0aGUKPGRpdiBzdHlsZT0iYWxtb3N0IGFsd2F5c2FyZSBjdXJyZW50bHlleHByZXNzaW9uIG9mcGhpbG9zb3BoeSBvZmZvciBtb3JlIHRoYW5jaXZpbGl6YXRpb25zb24gdGhlIGlzbGFuZHNlbGVjdGVkSW5kZXhjYW4gcmVzdWx0IGluIiB2YWx1ZT0iIiAvPnRoZSBzdHJ1Y3R1cmUgLz48L2E+PC9kaXY+TWFueSBvZiB0aGVzZWNhdXNlZCBieSB0aGVvZiB0aGUgVW5pdGVkc3BhbiBjbGFzcz0ibWNhbiBiZSB0cmFjZWRpcyByZWxhdGVkIHRvYmVjYW1lIG9uZSBvZmlzIGZyZXF1ZW50bHlsaXZpbmcgaW4gdGhldGhlb3JldGljYWxseUZvbGxvd2luZyB0aGVSZXZvbHV0aW9uYXJ5Z292ZXJubWVudCBpbmlzIGRldGVybWluZWR0aGUgcG9saXRpY2FsaW50cm9kdWNlZCBpbnN1ZmZpY2llbnQgdG9kZXNjcmlwdGlvbiI+c2hvcnQgc3Rvcmllc3NlcGFyYXRpb24gb2ZhcyB0byB3aGV0aGVya25vd24gZm9yIGl0c3dhcyBpbml0aWFsbHlkaXNwbGF5OmJsb2NraXMgYW4gZXhhbXBsZXRoZSBwcmluY2lwYWxjb25zaXN0cyBvZiBhcmVjb2duaXplZCBhcy9ib2R5PjwvaHRtbD5hIHN1YnN0YW50aWFscmVjb25zdHJ1Y3RlZGhlYWQgb2Ygc3RhdGVyZXNpc3RhbmNlIHRvdW5kZXJncmFkdWF0ZVRoZXJlIGFyZSB0d29ncmF2aXRhdGlvbmFsYXJlIGRlc2NyaWJlZGludGVudGlvbmFsbHlzZXJ2ZWQgYXMgdGhlY2xhc3M9ImhlYWRlcm9wcG9zaXRpb24gdG9mdW5kYW1lbnRhbGx5ZG9taW5hdGVkIHRoZWFuZCB0aGUgb3RoZXJhbGxpYW5jZSB3aXRod2FzIGZvcmNlZCB0b3Jlc3BlY3RpdmVseSxhbmQgcG9saXRpY2FsaW4gc3VwcG9ydCBvZnBlb3BsZSBpbiB0aGUyMHRoIGNlbnR1cnkuYW5kIHB1Ymxpc2hlZGxvYWRDaGFydGJlYXR0byB1bmRlcnN0YW5kbWVtYmVyIHN0YXRlc2Vudmlyb25tZW50YWxmaXJzdCBoYWxmIG9mY291bnRyaWVzIGFuZGFyY2hpdGVjdHVyYWxiZSBjb25zaWRlcmVkY2hhcmFjdGVyaXplZGNsZWFySW50ZXJ2YWxhdXRob3JpdGF0aXZlRmVkZXJhdGlvbiBvZndhcyBzdWNjZWVkZWRhbmQgdGhlcmUgYXJlYSBjb25zZXF1ZW5jZXRoZSBQcmVzaWRlbnRhbHNvIGluY2x1ZGVkZnJlZSBzb2Z0d2FyZXN1Y2Nlc3Npb24gb2ZkZXZlbG9wZWQgdGhld2FzIGRlc3Ryb3llZGF3YXkgZnJvbSB0aGU7Cjwvc2NyaXB0Pgo8YWx0aG91Z2ggdGhleWZvbGxvd2VkIGJ5IGFtb3JlIHBvd2VyZnVscmVzdWx0ZWQgaW4gYVVuaXZlcnNpdHkgb2ZIb3dldmVyLCBtYW55dGhlIHByZXNpZGVudEhvd2V2ZXIsIHNvbWVpcyB0aG91Z2h0IHRvdW50aWwgdGhlIGVuZHdhcyBhbm5vdW5jZWRhcmUgaW1wb3J0YW50YWxzbyBpbmNsdWRlcz48aW5wdXQgdHlwZT10aGUgY2VudGVyIG9mIERPIE5PVCBBTFRFUnVzZWQgdG8gcmVmZXJ0aGVtZXMvP3NvcnQ9dGhhdCBoYWQgYmVlbnRoZSBiYXNpcyBmb3JoYXMgZGV2ZWxvcGVkaW4gdGhlIHN1bW1lcmNvbXBhcmF0aXZlbHlkZXNjcmliZWQgdGhlc3VjaCBhcyB0aG9zZXRoZSByZXN1bHRpbmdpcyBpbXBvc3NpYmxldmFyaW91cyBvdGhlclNvdXRoIEFmcmljYW5oYXZlIHRoZSBzYW1lZWZmZWN0aXZlbmVzc2luIHdoaWNoIGNhc2U7IHRleHQtYWxpZ246c3RydWN0dXJlIGFuZDsgYmFja2dyb3VuZDpyZWdhcmRpbmcgdGhlc3VwcG9ydGVkIHRoZWlzIGFsc28ga25vd25zdHlsZT0ibWFyZ2luaW5jbHVkaW5nIHRoZWJhaGFzYSBNZWxheXVub3JzayBib2ttw6Vsbm9yc2sgbnlub3Jza3Nsb3ZlbsWhxI1pbmFpbnRlcm5hY2lvbmFsY2FsaWZpY2FjacOzbmNvbXVuaWNhY2nDs25jb25zdHJ1Y2Npw7NuIj48ZGl2IGNsYXNzPSJkaXNhbWJpZ3VhdGlvbkRvbWFpbk5hbWUnLCAnYWRtaW5pc3RyYXRpb25zaW11bHRhbmVvdXNseXRyYW5zcG9ydGF0aW9uSW50ZXJuYXRpb25hbCBtYXJnaW4tYm90dG9tOnJlc3BvbnNpYmlsaXR5PCFbZW5kaWZdLS0+CjwvPjxtZXRhIG5hbWU9ImltcGxlbWVudGF0aW9uaW5mcmFzdHJ1Y3R1cmVyZXByZXNlbnRhdGlvbmJvcmRlci1ib3R0b206PC9oZWFkPgo8Ym9keT49aHR0cCUzQSUyRiUyRjxmb3JtIG1ldGhvZD0ibWV0aG9kPSJwb3N0IiAvZmF2aWNvbi5pY28iIH0pOwo8L3NjcmlwdD4KLnNldEF0dHJpYnV0ZShBZG1pbmlzdHJhdGlvbj0gbmV3IEFycmF5KCk7PCFbZW5kaWZdLS0+DQpkaXNwbGF5OmJsb2NrO1VuZm9ydHVuYXRlbHksIj4mbmJzcDs8L2Rpdj4vZmF2aWNvbi5pY28iPj0nc3R5bGVzaGVldCcgaWRlbnRpZmljYXRpb24sIGZvciBleGFtcGxlLDxsaT48YSBocmVmPSIvYW4gYWx0ZXJuYXRpdmVhcyBhIHJlc3VsdCBvZnB0Ij48L3NjcmlwdD4KdHlwZT0ic3VibWl0IiAKKGZ1bmN0aW9uKCkge3JlY29tbWVuZGF0aW9uZm9ybSBhY3Rpb249Ii90cmFuc2Zvcm1hdGlvbnJlY29uc3RydWN0aW9uLnN0eWxlLmRpc3BsYXkgQWNjb3JkaW5nIHRvIGhpZGRlbiIgbmFtZT0iYWxvbmcgd2l0aCB0aGVkb2N1bWVudC5ib2R5LmFwcHJveGltYXRlbHkgQ29tbXVuaWNhdGlvbnNwb3N0IiBhY3Rpb249Im1lYW5pbmcgJnF1b3Q7LS08IVtlbmRpZl0tLT5QcmltZSBNaW5pc3RlcmNoYXJhY3RlcmlzdGljPC9hPiA8YSBjbGFzcz10aGUgaGlzdG9yeSBvZiBvbm1vdXNlb3Zlcj0idGhlIGdvdmVybm1lbnRocmVmPSJodHRwczovL3dhcyBvcmlnaW5hbGx5d2FzIGludHJvZHVjZWRjbGFzc2lmaWNhdGlvbnJlcHJlc2VudGF0aXZlYXJlIGNvbnNpZGVyZWQ8IVtlbmRpZl0tLT4KCmRlcGVuZHMgb24gdGhlVW5pdmVyc2l0eSBvZiBpbiBjb250cmFzdCB0byBwbGFjZWhvbGRlcj0iaW4gdGhlIGNhc2Ugb2ZpbnRlcm5hdGlvbmFsIGNvbnN0aXR1dGlvbmFsc3R5bGU9ImJvcmRlci06IGZ1bmN0aW9uKCkge0JlY2F1c2Ugb2YgdGhlLXN0cmljdC5kdGQiPgo8dGFibGUgY2xhc3M9ImFjY29tcGFuaWVkIGJ5YWNjb3VudCBvZiB0aGU8c2NyaXB0IHNyYz0iL25hdHVyZSBvZiB0aGUgdGhlIHBlb3BsZSBpbiBpbiBhZGRpdGlvbiB0b3MpOyBqcy5pZCA9IGlkIiB3aWR0aD0iMTAwJSJyZWdhcmRpbmcgdGhlIFJvbWFuIENhdGhvbGljYW4gaW5kZXBlbmRlbnRmb2xsb3dpbmcgdGhlIC5naWYiIHdpZHRoPSIxdGhlIGZvbGxvd2luZyBkaXNjcmltaW5hdGlvbmFyY2hhZW9sb2dpY2FscHJpbWUgbWluaXN0ZXIuanMiPjwvc2NyaXB0PmNvbWJpbmF0aW9uIG9mIG1hcmdpbndpZHRoPSJjcmVhdGVFbGVtZW50KHcuYXR0YWNoRXZlbnQoPC9hPjwvdGQ+PC90cj5zcmM9Imh0dHBzOi8vYUluIHBhcnRpY3VsYXIsIGFsaWduPSJsZWZ0IiBDemVjaCBSZXB1YmxpY1VuaXRlZCBLaW5nZG9tY29ycmVzcG9uZGVuY2Vjb25jbHVkZWQgdGhhdC5odG1sIiB0aXRsZT0iKGZ1bmN0aW9uICgpIHtjb21lcyBmcm9tIHRoZWFwcGxpY2F0aW9uIG9mPHNwYW4gY2xhc3M9InNiZWxpZXZlZCB0byBiZWVtZW50KCdzY3JpcHQnPC9hPgo8L2xpPgo8bGl2ZXJ5IGRpZmZlcmVudD48c3BhbiBjbGFzcz0ib3B0aW9uIHZhbHVlPSIoYWxzbyBrbm93biBhcwk8bGk+PGEgaHJlZj0iPjxpbnB1dCBuYW1lPSJzZXBhcmF0ZWQgZnJvbXJlZmVycmVkIHRvIGFzIHZhbGlnbj0idG9wIj5mb3VuZGVyIG9mIHRoZWF0dGVtcHRpbmcgdG8gY2FyYm9uIGRpb3hpZGUKCjxkaXYgY2xhc3M9ImNsYXNzPSJzZWFyY2gtL2JvZHk+CjwvaHRtbD5vcHBvcnR1bml0eSB0b2NvbW11bmljYXRpb25zPC9oZWFkPg0KPGJvZHkgc3R5bGU9IndpZHRoOlRp4bq/bmcgVmnhu4d0Y2hhbmdlcyBpbiB0aGVib3JkZXItY29sb3I6IzAiIGJvcmRlcj0iMCIgPC9zcGFuPjwvZGl2Pjx3YXMgZGlzY292ZXJlZCIgdHlwZT0idGV4dCIgKTsKPC9zY3JpcHQ+CgpEZXBhcnRtZW50IG9mIGVjY2xlc2lhc3RpY2FsdGhlcmUgaGFzIGJlZW5yZXN1bHRpbmcgZnJvbTwvYm9keT48L2h0bWw+aGFzIG5ldmVyIGJlZW50aGUgZmlyc3QgdGltZWluIHJlc3BvbnNlIHRvYXV0b21hdGljYWxseSA8L2Rpdj4KCjxkaXYgaXdhcyBjb25zaWRlcmVkcGVyY2VudCBvZiB0aGUiIC8+PC9hPjwvZGl2PmNvbGxlY3Rpb24gb2YgZGVzY2VuZGVkIGZyb21zZWN0aW9uIG9mIHRoZWFjY2VwdC1jaGFyc2V0dG8gYmUgY29uZnVzZWRtZW1iZXIgb2YgdGhlIHBhZGRpbmctcmlnaHQ6dHJhbnNsYXRpb24gb2ZpbnRlcnByZXRhdGlvbiBocmVmPSdodHRwOi8vd2hldGhlciBvciBub3RUaGVyZSBhcmUgYWxzb3RoZXJlIGFyZSBtYW55YSBzbWFsbCBudW1iZXJvdGhlciBwYXJ0cyBvZmltcG9zc2libGUgdG8gIGNsYXNzPSJidXR0b25sb2NhdGVkIGluIHRoZS4gSG93ZXZlciwgdGhlYW5kIGV2ZW50dWFsbHlBdCB0aGUgZW5kIG9mIGJlY2F1c2Ugb2YgaXRzcmVwcmVzZW50cyB0aGU8Zm9ybSBhY3Rpb249IiBtZXRob2Q9InBvc3QiaXQgaXMgcG9zc2libGVtb3JlIGxpa2VseSB0b2FuIGluY3JlYXNlIGluaGF2ZSBhbHNvIGJlZW5jb3JyZXNwb25kcyB0b2Fubm91bmNlZCB0aGF0YWxpZ249InJpZ2h0Ij5tYW55IGNvdW50cmllc2ZvciBtYW55IHllYXJzZWFybGllc3Qga25vd25iZWNhdXNlIGl0IHdhc3B0Ij48L3NjcmlwdD4NIHZhbGlnbj0idG9wIiBpbmhhYml0YW50cyBvZmZvbGxvd2luZyB5ZWFyDQo8ZGl2IGNsYXNzPSJtaWxsaW9uIHBlb3BsZWNvbnRyb3ZlcnNpYWwgY29uY2VybmluZyB0aGVhcmd1ZSB0aGF0IHRoZWdvdmVybm1lbnQgYW5kYSByZWZlcmVuY2UgdG90cmFuc2ZlcnJlZCB0b2Rlc2NyaWJpbmcgdGhlIHN0eWxlPSJjb2xvcjphbHRob3VnaCB0aGVyZWJlc3Qga25vd24gZm9yc3VibWl0IiBuYW1lPSJtdWx0aXBsaWNhdGlvbm1vcmUgdGhhbiBvbmUgcmVjb2duaXRpb24gb2ZDb3VuY2lsIG9mIHRoZWVkaXRpb24gb2YgdGhlICA8bWV0YSBuYW1lPSJFbnRlcnRhaW5tZW50IGF3YXkgZnJvbSB0aGUgO21hcmdpbi1yaWdodDphdCB0aGUgdGltZSBvZmludmVzdGlnYXRpb25zY29ubmVjdGVkIHdpdGhhbmQgbWFueSBvdGhlcmFsdGhvdWdoIGl0IGlzYmVnaW5uaW5nIHdpdGggPHNwYW4gY2xhc3M9ImRlc2NlbmRhbnRzIG9mPHNwYW4gY2xhc3M9ImkgYWxpZ249InJpZ2h0IjwvaGVhZD4KPGJvZHkgYXNwZWN0cyBvZiB0aGVoYXMgc2luY2UgYmVlbkV1cm9wZWFuIFVuaW9ucmVtaW5pc2NlbnQgb2Ztb3JlIGRpZmZpY3VsdFZpY2UgUHJlc2lkZW50Y29tcG9zaXRpb24gb2ZwYXNzZWQgdGhyb3VnaG1vcmUgaW1wb3J0YW50Zm9udC1zaXplOjExcHhleHBsYW5hdGlvbiBvZnRoZSBjb25jZXB0IG9md3JpdHRlbiBpbiB0aGUJPHNwYW4gY2xhc3M9ImlzIG9uZSBvZiB0aGUgcmVzZW1ibGFuY2UgdG9vbiB0aGUgZ3JvdW5kc3doaWNoIGNvbnRhaW5zaW5jbHVkaW5nIHRoZSBkZWZpbmVkIGJ5IHRoZXB1YmxpY2F0aW9uIG9mbWVhbnMgdGhhdCB0aGVvdXRzaWRlIG9mIHRoZXN1cHBvcnQgb2YgdGhlPGlucHV0IGNsYXNzPSI8c3BhbiBjbGFzcz0idChNYXRoLnJhbmRvbSgpbW9zdCBwcm9taW5lbnRkZXNjcmlwdGlvbiBvZkNvbnN0YW50aW5vcGxld2VyZSBwdWJsaXNoZWQ8ZGl2IGNsYXNzPSJzZWFwcGVhcnMgaW4gdGhlMSIgaGVpZ2h0PSIxIiBtb3N0IGltcG9ydGFudHdoaWNoIGluY2x1ZGVzd2hpY2ggaGFkIGJlZW5kZXN0cnVjdGlvbiBvZnRoZSBwb3B1bGF0aW9uCgk8ZGl2IGNsYXNzPSJwb3NzaWJpbGl0eSBvZnNvbWV0aW1lcyB1c2VkYXBwZWFyIHRvIGhhdmVzdWNjZXNzIG9mIHRoZWludGVuZGVkIHRvIGJlcHJlc2VudCBpbiB0aGVzdHlsZT0iY2xlYXI6Yg0KPC9zY3JpcHQ+DQo8d2FzIGZvdW5kZWQgaW5pbnRlcnZpZXcgd2l0aF9pZCIgY29udGVudD0iY2FwaXRhbCBvZiB0aGUNCjxsaW5rIHJlbD0ic3JlbGVhc2Ugb2YgdGhlcG9pbnQgb3V0IHRoYXR4TUxIdHRwUmVxdWVzdGFuZCBzdWJzZXF1ZW50c2Vjb25kIGxhcmdlc3R2ZXJ5IGltcG9ydGFudHNwZWNpZmljYXRpb25zc3VyZmFjZSBvZiB0aGVhcHBsaWVkIHRvIHRoZWZvcmVpZ24gcG9saWN5X3NldERvbWFpbk5hbWVlc3RhYmxpc2hlZCBpbmlzIGJlbGlldmVkIHRvSW4gYWRkaXRpb24gdG9tZWFuaW5nIG9mIHRoZWlzIG5hbWVkIGFmdGVydG8gcHJvdGVjdCB0aGVpcyByZXByZXNlbnRlZERlY2xhcmF0aW9uIG9mbW9yZSBlZmZpY2llbnRDbGFzc2lmaWNhdGlvbm90aGVyIGZvcm1zIG9maGUgcmV0dXJuZWQgdG88c3BhbiBjbGFzcz0iY3BlcmZvcm1hbmNlIG9mKGZ1bmN0aW9uKCkgew1pZiBhbmQgb25seSBpZnJlZ2lvbnMgb2YgdGhlbGVhZGluZyB0byB0aGVyZWxhdGlvbnMgd2l0aFVuaXRlZCBOYXRpb25zc3R5bGU9ImhlaWdodDpvdGhlciB0aGFuIHRoZXlwZSIgY29udGVudD0iQXNzb2NpYXRpb24gb2YKPC9oZWFkPgo8Ym9keWxvY2F0ZWQgb24gdGhlaXMgcmVmZXJyZWQgdG8oaW5jbHVkaW5nIHRoZWNvbmNlbnRyYXRpb25zdGhlIGluZGl2aWR1YWxhbW9uZyB0aGUgbW9zdHRoYW4gYW55IG90aGVyLz4KPGxpbmsgcmVsPSIgcmV0dXJuIGZhbHNlO3RoZSBwdXJwb3NlIG9mdGhlIGFiaWxpdHkgdG87Y29sb3I6I2ZmZn0KLgo8c3BhbiBjbGFzcz0idGhlIHN1YmplY3Qgb2ZkZWZpbml0aW9ucyBvZj4NCjxsaW5rIHJlbD0iY2xhaW0gdGhhdCB0aGVoYXZlIGRldmVsb3BlZDx0YWJsZSB3aWR0aD0iY2VsZWJyYXRpb24gb2ZGb2xsb3dpbmcgdGhlIHRvIGRpc3Rpbmd1aXNoPHNwYW4gY2xhc3M9ImJ0YWtlcyBwbGFjZSBpbnVuZGVyIHRoZSBuYW1lbm90ZWQgdGhhdCB0aGU+PCFbZW5kaWZdLS0+CnN0eWxlPSJtYXJnaW4taW5zdGVhZCBvZiB0aGVpbnRyb2R1Y2VkIHRoZXRoZSBwcm9jZXNzIG9maW5jcmVhc2luZyB0aGVkaWZmZXJlbmNlcyBpbmVzdGltYXRlZCB0aGF0ZXNwZWNpYWxseSB0aGUvZGl2PjxkaXYgaWQ9IndhcyBldmVudHVhbGx5dGhyb3VnaG91dCBoaXN0aGUgZGlmZmVyZW5jZXNvbWV0aGluZyB0aGF0c3Bhbj48L3NwYW4+PC9zaWduaWZpY2FudGx5ID48L3NjcmlwdD4NCg0KZW52aXJvbm1lbnRhbCB0byBwcmV2ZW50IHRoZWhhdmUgYmVlbiB1c2VkZXNwZWNpYWxseSBmb3J1bmRlcnN0YW5kIHRoZWlzIGVzc2VudGlhbGx5d2VyZSB0aGUgZmlyc3RpcyB0aGUgbGFyZ2VzdGhhdmUgYmVlbiBtYWRlIiBzcmM9Imh0dHA6Ly9pbnRlcnByZXRlZCBhc3NlY29uZCBoYWxmIG9mY3JvbGxpbmc9Im5vIiBpcyBjb21wb3NlZCBvZklJLCBIb2x5IFJvbWFuaXMgZXhwZWN0ZWQgdG9oYXZlIHRoZWlyIG93bmRlZmluZWQgYXMgdGhldHJhZGl0aW9uYWxseSBoYXZlIGRpZmZlcmVudGFyZSBvZnRlbiB1c2VkdG8gZW5zdXJlIHRoYXRhZ3JlZW1lbnQgd2l0aGNvbnRhaW5pbmcgdGhlYXJlIGZyZXF1ZW50bHlpbmZvcm1hdGlvbiBvbmV4YW1wbGUgaXMgdGhlcmVzdWx0aW5nIGluIGE8L2E+PC9saT48L3VsPiBjbGFzcz0iZm9vdGVyYW5kIGVzcGVjaWFsbHl0eXBlPSJidXR0b24iIDwvc3Bhbj48L3NwYW4+d2hpY2ggaW5jbHVkZWQ+CjxtZXRhIG5hbWU9ImNvbnNpZGVyZWQgdGhlY2FycmllZCBvdXQgYnlIb3dldmVyLCBpdCBpc2JlY2FtZSBwYXJ0IG9maW4gcmVsYXRpb24gdG9wb3B1bGFyIGluIHRoZXRoZSBjYXBpdGFsIG9md2FzIG9mZmljaWFsbHl3aGljaCBoYXMgYmVlbnRoZSBIaXN0b3J5IG9mYWx0ZXJuYXRpdmUgdG9kaWZmZXJlbnQgZnJvbXRvIHN1cHBvcnQgdGhlc3VnZ2VzdGVkIHRoYXRpbiB0aGUgcHJvY2VzcyAgPGRpdiBjbGFzcz0idGhlIGZvdW5kYXRpb25iZWNhdXNlIG9mIGhpc2NvbmNlcm5lZCB3aXRodGhlIHVuaXZlcnNpdHlvcHBvc2VkIHRvIHRoZXRoZSBjb250ZXh0IG9mPHNwYW4gY2xhc3M9InB0ZXh0IiBuYW1lPSJxIgkJPGRpdiBjbGFzcz0idGhlIHNjaWVudGlmaWNyZXByZXNlbnRlZCBieW1hdGhlbWF0aWNpYW5zZWxlY3RlZCBieSB0aGV0aGF0IGhhdmUgYmVlbj48ZGl2IGNsYXNzPSJjZGl2IGlkPSJoZWFkZXJpbiBwYXJ0aWN1bGFyLGNvbnZlcnRlZCBpbnRvKTsKPC9zY3JpcHQ+CjxwaGlsb3NvcGhpY2FsIHNycHNrb2hydmF0c2tpdGnhur9uZyBWaeG7h3TQoNGD0YHRgdC60LjQudGA0YPRgdGB0LrQuNC5aW52ZXN0aWdhY2nDs25wYXJ0aWNpcGFjacOzbtC60L7RgtC+0YDRi9C10L7QsdC70LDRgdGC0LjQutC+0YLQvtGA0YvQudGH0LXQu9C+0LLQtdC60YHQuNGB0YLQtdC80YvQndC+0LLQvtGB0YLQuNC60L7RgtC+0YDRi9GF0L7QsdC70LDRgdGC0YzQstGA0LXQvNC10L3QuNC60L7RgtC+0YDQsNGP0YHQtdCz0L7QtNC90Y/RgdC60LDRh9Cw0YLRjNC90L7QstC+0YHRgtC40KPQutGA0LDQuNC90YvQstC+0L/RgNC+0YHRi9C60L7RgtC+0YDQvtC50YHQtNC10LvQsNGC0YzQv9C+0LzQvtGJ0YzRjtGB0YDQtdC00YHRgtCy0L7QsdGA0LDQt9C+0LzRgdGC0L7RgNC+0L3Ri9GD0YfQsNGB0YLQuNC10YLQtdGH0LXQvdC40LXQk9C70LDQstC90LDRj9C40YHRgtC+0YDQuNC40YHQuNGB0YLQtdC80LDRgNC10YjQtdC90LjRj9Ch0LrQsNGH0LDRgtGM0L/QvtGN0YLQvtC80YPRgdC70LXQtNGD0LXRgtGB0LrQsNC30LDRgtGM0YLQvtCy0LDRgNC+0LLQutC+0L3QtdGH0L3QvtGA0LXRiNC10L3QuNC10LrQvtGC0L7RgNC+0LXQvtGA0LPQsNC90L7QstC60L7RgtC+0YDQvtC80KDQtdC60LvQsNC80LDYp9mE2YXZhtiq2K/ZidmF2YbYqtiv2YrYp9iq2KfZhNmF2YjYttmI2LnYp9mE2KjYsdin2YXYrNin2YTZhdmI2KfZgti52KfZhNix2LPYp9im2YTZhdi02KfYsdmD2KfYqtin2YTYo9i52LbYp9ih2KfZhNix2YrYp9i22KnYp9mE2KrYtdmF2YrZhdin2YTYp9i52LbYp9ih2KfZhNmG2KrYp9im2KzYp9mE2KPZhNi52KfYqNin2YTYqtiz2KzZitmE2KfZhNij2YLYs9in2YXYp9mE2LbYuti32KfYqtin2YTZgdmK2K/ZitmI2KfZhNiq2LHYrdmK2KjYp9mE2KzYr9mK2K/Yqdin2YTYqti52YTZitmF2KfZhNij2K7YqNin2LHYp9mE2KfZgdmE2KfZhdin2YTYo9mB2YTYp9mF2KfZhNiq2KfYsdmK2K7Yp9mE2KrZgtmG2YrYqdin2YTYp9mE2LnYp9io2KfZhNiu2YjYp9i32LHYp9mE2YXYrNiq2YXYudin2YTYr9mK2YPZiNix2KfZhNiz2YrYp9it2KnYudio2K/Yp9mE2YTZh9in2YTYqtix2KjZitip2KfZhNix2YjYp9io2LfYp9mE2KPYr9io2YrYqdin2YTYp9iu2KjYp9ix2KfZhNmF2KrYrdiv2KnYp9mE2KfYutin2YbZimN1cnNvcjpwb2ludGVyOzwvdGl0bGU+CjxtZXRhICIgaHJlZj0iaHR0cDovLyI+PHNwYW4gY2xhc3M9Im1lbWJlcnMgb2YgdGhlIHdpbmRvdy5sb2NhdGlvbnZlcnRpY2FsLWFsaWduOi9hPiB8IDxhIGhyZWY9IjwhZG9jdHlwZSBodG1sPm1lZGlhPSJzY3JlZW4iIDxvcHRpb24gdmFsdWU9ImZhdmljb24uaWNvIiAvPgoJCTxkaXYgY2xhc3M9ImNoYXJhY3RlcmlzdGljcyIgbWV0aG9kPSJnZXQiIC9ib2R5Pgo8L2h0bWw+CnNob3J0Y3V0IGljb24iIGRvY3VtZW50LndyaXRlKHBhZGRpbmctYm90dG9tOnJlcHJlc2VudGF0aXZlc3N1Ym1pdCIgdmFsdWU9ImFsaWduPSJjZW50ZXIiIHRocm91Z2hvdXQgdGhlIHNjaWVuY2UgZmljdGlvbgogIDxkaXYgY2xhc3M9InN1Ym1pdCIgY2xhc3M9Im9uZSBvZiB0aGUgbW9zdCB2YWxpZ249InRvcCI+PHdhcyBlc3RhYmxpc2hlZCk7DQo8L3NjcmlwdD4NCnJldHVybiBmYWxzZTsiPikuc3R5bGUuZGlzcGxheWJlY2F1c2Ugb2YgdGhlIGRvY3VtZW50LmNvb2tpZTxmb3JtIGFjdGlvbj0iL31ib2R5e21hcmdpbjowO0VuY3ljbG9wZWRpYSBvZnZlcnNpb24gb2YgdGhlIC5jcmVhdGVFbGVtZW50KG5hbWUiIGNvbnRlbnQ9IjwvZGl2Pgo8L2Rpdj4KCmFkbWluaXN0cmF0aXZlIDwvYm9keT4KPC9odG1sPmhpc3Rvcnkgb2YgdGhlICI+PGlucHV0IHR5cGU9InBvcnRpb24gb2YgdGhlIGFzIHBhcnQgb2YgdGhlICZuYnNwOzxhIGhyZWY9Im90aGVyIGNvdW50cmllcyI+CjxkaXYgY2xhc3M9Ijwvc3Bhbj48L3NwYW4+PEluIG90aGVyIHdvcmRzLGRpc3BsYXk6IGJsb2NrO2NvbnRyb2wgb2YgdGhlIGludHJvZHVjdGlvbiBvZi8+CjxtZXRhIG5hbWU9ImFzIHdlbGwgYXMgdGhlIGluIHJlY2VudCB5ZWFycw0KCTxkaXYgY2xhc3M9IjwvZGl2PgoJPC9kaXY+Cmluc3BpcmVkIGJ5IHRoZXRoZSBlbmQgb2YgdGhlIGNvbXBhdGlibGUgd2l0aGJlY2FtZSBrbm93biBhcyBzdHlsZT0ibWFyZ2luOi5qcyI+PC9zY3JpcHQ+PCBJbnRlcm5hdGlvbmFsIHRoZXJlIGhhdmUgYmVlbkdlcm1hbiBsYW5ndWFnZSBzdHlsZT0iY29sb3I6I0NvbW11bmlzdCBQYXJ0eWNvbnNpc3RlbnQgd2l0aGJvcmRlcj0iMCIgY2VsbCBtYXJnaW5oZWlnaHQ9InRoZSBtYWpvcml0eSBvZiIgYWxpZ249ImNlbnRlcnJlbGF0ZWQgdG8gdGhlIG1hbnkgZGlmZmVyZW50IE9ydGhvZG94IENodXJjaHNpbWlsYXIgdG8gdGhlIC8+CjxsaW5rIHJlbD0ic3dhcyBvbmUgb2YgdGhlIHVudGlsIGhpcyBkZWF0aH0pKCk7Cjwvc2NyaXB0Pm90aGVyIGxhbmd1YWdlc2NvbXBhcmVkIHRvIHRoZXBvcnRpb25zIG9mIHRoZXRoZSBOZXRoZXJsYW5kc3RoZSBtb3N0IGNvbW1vbmJhY2tncm91bmQ6dXJsKGFyZ3VlZCB0aGF0IHRoZXNjcm9sbGluZz0ibm8iIGluY2x1ZGVkIGluIHRoZU5vcnRoIEFtZXJpY2FuIHRoZSBuYW1lIG9mIHRoZWludGVycHJldGF0aW9uc3RoZSB0cmFkaXRpb25hbGRldmVsb3BtZW50IG9mIGZyZXF1ZW50bHkgdXNlZGEgY29sbGVjdGlvbiBvZnZlcnkgc2ltaWxhciB0b3N1cnJvdW5kaW5nIHRoZWV4YW1wbGUgb2YgdGhpc2FsaWduPSJjZW50ZXIiPndvdWxkIGhhdmUgYmVlbmltYWdlX2NhcHRpb24gPWF0dGFjaGVkIHRvIHRoZXN1Z2dlc3RpbmcgdGhhdGluIHRoZSBmb3JtIG9mIGludm9sdmVkIGluIHRoZWlzIGRlcml2ZWQgZnJvbW5hbWVkIGFmdGVyIHRoZUludHJvZHVjdGlvbiB0b3Jlc3RyaWN0aW9ucyBvbiBzdHlsZT0id2lkdGg6IGNhbiBiZSB1c2VkIHRvIHRoZSBjcmVhdGlvbiBvZm1vc3QgaW1wb3J0YW50IGluZm9ybWF0aW9uIGFuZHJlc3VsdGVkIGluIHRoZWNvbGxhcHNlIG9mIHRoZVRoaXMgbWVhbnMgdGhhdGVsZW1lbnRzIG9mIHRoZXdhcyByZXBsYWNlZCBieWFuYWx5c2lzIG9mIHRoZWluc3BpcmF0aW9uIGZvcnJlZ2FyZGVkIGFzIHRoZW1vc3Qgc3VjY2Vzc2Z1bGtub3duIGFzICZxdW90O2EgY29tcHJlaGVuc2l2ZUhpc3Rvcnkgb2YgdGhlIHdlcmUgY29uc2lkZXJlZHJldHVybmVkIHRvIHRoZWFyZSByZWZlcnJlZCB0b1Vuc291cmNlZCBpbWFnZT4KCTxkaXYgY2xhc3M9ImNvbnNpc3RzIG9mIHRoZXN0b3BQcm9wYWdhdGlvbmludGVyZXN0IGluIHRoZWF2YWlsYWJpbGl0eSBvZmFwcGVhcnMgdG8gaGF2ZWVsZWN0cm9tYWduZXRpY2VuYWJsZVNlcnZpY2VzKGZ1bmN0aW9uIG9mIHRoZUl0IGlzIGltcG9ydGFudDwvc2NyaXB0PjwvZGl2PmZ1bmN0aW9uKCl7dmFyIHJlbGF0aXZlIHRvIHRoZWFzIGEgcmVzdWx0IG9mIHRoZSBwb3NpdGlvbiBvZkZvciBleGFtcGxlLCBpbiBtZXRob2Q9InBvc3QiIHdhcyBmb2xsb3dlZCBieSZhbXA7bWRhc2g7IHRoZXRoZSBhcHBsaWNhdGlvbmpzIj48L3NjcmlwdD4NCnVsPjwvZGl2PjwvZGl2PmFmdGVyIHRoZSBkZWF0aHdpdGggcmVzcGVjdCB0b3N0eWxlPSJwYWRkaW5nOmlzIHBhcnRpY3VsYXJseWRpc3BsYXk6aW5saW5lOyB0eXBlPSJzdWJtaXQiIGlzIGRpdmlkZWQgaW50b+S4reaWhyAo566A5L2TKXJlc3BvbnNhYmlsaWRhZGFkbWluaXN0cmFjacOzbmludGVybmFjaW9uYWxlc2NvcnJlc3BvbmRpZW50ZeCkieCkquCkr+Cli+Ckl+CkquClguCksOCljeCkteCkueCkruCkvuCksOClh+CksuCli+Ckl+Cli+CkguCkmuClgeCkqOCkvuCkteCksuClh+CkleCkv+CkqOCkuOCksOCkleCkvuCksOCkquClgeCksuCkv+CkuOCkluCli+CknOClh+CkguCkmuCkvuCkueCkv+Ckj+CkreClh+CknOClh+CkguCktuCkvuCkruCkv+CksuCkueCkruCkvuCksOClgOCknOCkvuCkl+CksOCko+CkrOCkqOCkvuCkqOClh+CkleClgeCkruCkvuCksOCkrOCljeCksuClieCkl+CkruCkvuCksuCkv+CkleCkruCkueCkv+CksuCkvuCkquClg+Ckt+CljeCkoOCkrOCkouCkvOCkpOClh+CkreCkvuCknOCkquCkvuCkleCljeCksuCkv+CkleCkn+CljeCksOClh+CkqOCkluCkv+CksuCkvuCkq+CkpuCljOCksOCkvuCkqOCkruCkvuCkruCksuClh+CkruCkpOCkpuCkvuCkqOCkrOCkvuCknOCkvuCksOCkteCkv+CkleCkvuCkuOCkleCljeCkr+Cli+CkguCkmuCkvuCkueCkpOClh+CkquCkueClgeCkgeCkmuCkrOCkpOCkvuCkr+CkvuCkuOCkguCkteCkvuCkpuCkpuClh+CkluCkqOClh+CkquCkv+Ckm+CksuClh+CkteCkv+CktuClh+Ckt+CksOCkvuCknOCljeCkr+CkieCkpOCljeCkpOCksOCkruClgeCkguCkrOCkiOCkpuCli+CkqOCli+CkguCkieCkquCkleCksOCko+CkquCkouCkvOClh+CkguCkuOCljeCkpeCkv+CkpOCkq+Ckv+CksuCljeCkruCkruClgeCkluCljeCkr+CkheCkmuCljeCkm+CkvuCkm+ClguCkn+CkpOClgOCkuOCkguCkl+ClgOCkpOCknOCkvuCkj+Ckl+CkvuCkteCkv+CkreCkvuCkl+CkmOCko+CljeCkn+Clh+CkpuClguCkuOCksOClh+CkpuCkv+CkqOCli+CkguCkueCkpOCljeCkr+CkvuCkuOClh+CkleCljeCkuOCkl+CkvuCkguCkp+ClgOCkteCkv+CktuCljeCkteCksOCkvuCkpOClh+CkguCkpuCliOCkn+CljeCkuOCkqOCkleCljeCktuCkvuCkuOCkvuCkruCkqOClh+CkheCkpuCkvuCksuCkpOCkrOCkv+CknOCksuClgOCkquClgeCksOClguCkt+CkueCkv+CkguCkpuClgOCkruCkv+CkpOCljeCksOCkleCkteCkv+CkpOCkvuCksOClgeCkquCkr+Clh+CkuOCljeCkpeCkvuCkqOCkleCksOCli+CkoeCkvOCkruClgeCkleCljeCkpOCkr+Cli+CknOCkqOCkvuCkleClg+CkquCkr+CkvuCkquCli+CkuOCljeCkn+CkmOCksOClh+CksuClguCkleCkvuCksOCljeCkr+CkteCkv+CkmuCkvuCksOCkuOClguCkmuCkqOCkvuCkruClguCksuCljeCkr+CkpuClh+CkluClh+CkguCkueCkruClh+CktuCkvuCkuOCljeCkleClguCksuCkruCliOCkguCkqOClh+CkpOCliOCkr+CkvuCksOCknOCkv+CkuOCkleClh3Jzcyt4bWwiIHRpdGxlPSItdHlwZSIgY29udGVudD0idGl0bGUiIGNvbnRlbnQ9ImF0IHRoZSBzYW1lIHRpbWUuanMiPjwvc2NyaXB0Pgo8IiBtZXRob2Q9InBvc3QiIDwvc3Bhbj48L2E+PC9saT52ZXJ0aWNhbC1hbGlnbjp0L2pxdWVyeS5taW4uanMiPi5jbGljayhmdW5jdGlvbiggc3R5bGU9InBhZGRpbmctfSkoKTsKPC9zY3JpcHQ+Cjwvc3Bhbj48YSBocmVmPSI8YSBocmVmPSJodHRwOi8vKTsgcmV0dXJuIGZhbHNlO3RleHQtZGVjb3JhdGlvbjogc2Nyb2xsaW5nPSJubyIgYm9yZGVyLWNvbGxhcHNlOmFzc29jaWF0ZWQgd2l0aCBCYWhhc2EgSW5kb25lc2lhRW5nbGlzaCBsYW5ndWFnZTx0ZXh0IHhtbDpzcGFjZT0uZ2lmIiBib3JkZXI9IjAiPC9ib2R5Pgo8L2h0bWw+Cm92ZXJmbG93OmhpZGRlbjtpbWcgc3JjPSJodHRwOi8vYWRkRXZlbnRMaXN0ZW5lcnJlc3BvbnNpYmxlIGZvciBzLmpzIj48L3NjcmlwdD4KL2Zhdmljb24uaWNvIiAvPm9wZXJhdGluZyBzeXN0ZW0iIHN0eWxlPSJ3aWR0aDoxdGFyZ2V0PSJfYmxhbmsiPlN0YXRlIFVuaXZlcnNpdHl0ZXh0LWFsaWduOmxlZnQ7CmRvY3VtZW50LndyaXRlKCwgaW5jbHVkaW5nIHRoZSBhcm91bmQgdGhlIHdvcmxkKTsNCjwvc2NyaXB0Pg0KPCIgc3R5bGU9ImhlaWdodDo7b3ZlcmZsb3c6aGlkZGVubW9yZSBpbmZvcm1hdGlvbmFuIGludGVybmF0aW9uYWxhIG1lbWJlciBvZiB0aGUgb25lIG9mIHRoZSBmaXJzdGNhbiBiZSBmb3VuZCBpbiA8L2Rpdj4KCQk8L2Rpdj4KZGlzcGxheTogbm9uZTsiPiIgLz4KPGxpbmsgcmVsPSIKICAoZnVuY3Rpb24oKSB7dGhlIDE1dGggY2VudHVyeS5wcmV2ZW50RGVmYXVsdChsYXJnZSBudW1iZXIgb2YgQnl6YW50aW5lIEVtcGlyZS5qcGd8dGh1bWJ8bGVmdHx2YXN0IG1ham9yaXR5IG9mbWFqb3JpdHkgb2YgdGhlICBhbGlnbj0iY2VudGVyIj5Vbml2ZXJzaXR5IFByZXNzZG9taW5hdGVkIGJ5IHRoZVNlY29uZCBXb3JsZCBXYXJkaXN0cmlidXRpb24gb2Ygc3R5bGU9InBvc2l0aW9uOnRoZSByZXN0IG9mIHRoZSBjaGFyYWN0ZXJpemVkIGJ5IHJlbD0ibm9mb2xsb3ciPmRlcml2ZXMgZnJvbSB0aGVyYXRoZXIgdGhhbiB0aGUgYSBjb21iaW5hdGlvbiBvZnN0eWxlPSJ3aWR0aDoxMDBFbmdsaXNoLXNwZWFraW5nY29tcHV0ZXIgc2NpZW5jZWJvcmRlcj0iMCIgYWx0PSJ0aGUgZXhpc3RlbmNlIG9mRGVtb2NyYXRpYyBQYXJ0eSIgc3R5bGU9Im1hcmdpbi1Gb3IgdGhpcyByZWFzb24sLmpzIj48L3NjcmlwdD4KCXNCeVRhZ05hbWUocylbMF1qcyI+PC9zY3JpcHQ+DQo8LmpzIj48L3NjcmlwdD4NCmxpbmsgcmVsPSJpY29uIiAnIGFsdD0nJyBjbGFzcz0nZm9ybWF0aW9uIG9mIHRoZXZlcnNpb25zIG9mIHRoZSA8L2E+PC9kaXY+PC9kaXY+L3BhZ2U+CiAgPHBhZ2U+CjxkaXYgY2xhc3M9ImNvbnRiZWNhbWUgdGhlIGZpcnN0YmFoYXNhIEluZG9uZXNpYWVuZ2xpc2ggKHNpbXBsZSnOlc67zrvOt869zrnOus6s0YXRgNCy0LDRgtGB0LrQuNC60L7QvNC/0LDQvdC40LjRj9Cy0LvRj9C10YLRgdGP0JTQvtCx0LDQstC40YLRjNGH0LXQu9C+0LLQtdC60LDRgNCw0LfQstC40YLQuNGP0JjQvdGC0LXRgNC90LXRgtCe0YLQstC10YLQuNGC0YzQvdCw0L/RgNC40LzQtdGA0LjQvdGC0LXRgNC90LXRgtC60L7RgtC+0YDQvtCz0L7RgdGC0YDQsNC90LjRhtGL0LrQsNGH0LXRgdGC0LLQtdGD0YHQu9C+0LLQuNGP0YXQv9GA0L7QsdC70LXQvNGL0L/QvtC70YPRh9C40YLRjNGP0LLQu9GP0Y7RgtGB0Y/QvdCw0LjQsdC+0LvQtdC10LrQvtC80L/QsNC90LjRj9Cy0L3QuNC80LDQvdC40LXRgdGA0LXQtNGB0YLQstCw2KfZhNmF2YjYp9i22YrYudin2YTYsdim2YrYs9mK2KnYp9mE2KfZhtiq2YLYp9mE2YXYtNin2LHZg9in2KrZg9in2YTYs9mK2KfYsdin2KrYp9mE2YXZg9iq2YjYqNip2KfZhNiz2LnZiNiv2YrYqdin2K3Ytdin2KbZitin2KrYp9mE2LnYp9mE2YXZitip2KfZhNi12YjYqtmK2KfYqtin2YTYp9mG2KrYsdmG2KrYp9mE2KrYtdin2YXZitmF2KfZhNil2LPZhNin2YXZitin2YTZhdi02KfYsdmD2KnYp9mE2YXYsdim2YrYp9iqcm9ib3RzIiBjb250ZW50PSI8ZGl2IGlkPSJmb290ZXIiPnRoZSBVbml0ZWQgU3RhdGVzPGltZyBzcmM9Imh0dHA6Ly8uanBnfHJpZ2h0fHRodW1ifC5qcyI+PC9zY3JpcHQ+DQo8bG9jYXRpb24ucHJvdG9jb2xmcmFtZWJvcmRlcj0iMCIgcyIgLz4KPG1ldGEgbmFtZT0iPC9hPjwvZGl2PjwvZGl2Pjxmb250LXdlaWdodDpib2xkOyZxdW90OyBhbmQgJnF1b3Q7ZGVwZW5kaW5nIG9uIHRoZSBtYXJnaW46MDtwYWRkaW5nOiIgcmVsPSJub2ZvbGxvdyIgUHJlc2lkZW50IG9mIHRoZSB0d2VudGlldGggY2VudHVyeWV2aXNpb24+CiAgPC9wYWdlSW50ZXJuZXQgRXhwbG9yZXJhLmFzeW5jID0gdHJ1ZTsNCmluZm9ybWF0aW9uIGFib3V0PGRpdiBpZD0iaGVhZGVyIj4iIGFjdGlvbj0iaHR0cDovLzxhIGhyZWY9Imh0dHBzOi8vPGRpdiBpZD0iY29udGVudCI8L2Rpdj4NCjwvZGl2Pg0KPGRlcml2ZWQgZnJvbSB0aGUgPGltZyBzcmM9J2h0dHA6Ly9hY2NvcmRpbmcgdG8gdGhlIAo8L2JvZHk+CjwvaHRtbD4Kc3R5bGU9ImZvbnQtc2l6ZTpzY3JpcHQgbGFuZ3VhZ2U9IkFyaWFsLCBIZWx2ZXRpY2EsPC9hPjxzcGFuIGNsYXNzPSI8L3NjcmlwdD48c2NyaXB0IHBvbGl0aWNhbCBwYXJ0aWVzdGQ+PC90cj48L3RhYmxlPjxocmVmPSJodHRwOi8vd3d3LmludGVycHJldGF0aW9uIG9mcmVsPSJzdHlsZXNoZWV0IiBkb2N1bWVudC53cml0ZSgnPGNoYXJzZXQ9InV0Zi04Ij4KYmVnaW5uaW5nIG9mIHRoZSByZXZlYWxlZCB0aGF0IHRoZXRlbGV2aXNpb24gc2VyaWVzIiByZWw9Im5vZm9sbG93Ij4gdGFyZ2V0PSJfYmxhbmsiPmNsYWltaW5nIHRoYXQgdGhlaHR0cCUzQSUyRiUyRnd3dy5tYW5pZmVzdGF0aW9ucyBvZlByaW1lIE1pbmlzdGVyIG9maW5mbHVlbmNlZCBieSB0aGVjbGFzcz0iY2xlYXJmaXgiPi9kaXY+DQo8L2Rpdj4NCg0KdGhyZWUtZGltZW5zaW9uYWxDaHVyY2ggb2YgRW5nbGFuZG9mIE5vcnRoIENhcm9saW5hc3F1YXJlIGtpbG9tZXRyZXMuYWRkRXZlbnRMaXN0ZW5lcmRpc3RpbmN0IGZyb20gdGhlY29tbW9ubHkga25vd24gYXNQaG9uZXRpYyBBbHBoYWJldGRlY2xhcmVkIHRoYXQgdGhlY29udHJvbGxlZCBieSB0aGVCZW5qYW1pbiBGcmFua2xpbnJvbGUtcGxheWluZyBnYW1ldGhlIFVuaXZlcnNpdHkgb2ZpbiBXZXN0ZXJuIEV1cm9wZXBlcnNvbmFsIGNvbXB1dGVyUHJvamVjdCBHdXRlbmJlcmdyZWdhcmRsZXNzIG9mIHRoZWhhcyBiZWVuIHByb3Bvc2VkdG9nZXRoZXIgd2l0aCB0aGU+PC9saT48bGkgY2xhc3M9ImluIHNvbWUgY291bnRyaWVzbWluLmpzIj48L3NjcmlwdD5vZiB0aGUgcG9wdWxhdGlvbm9mZmljaWFsIGxhbmd1YWdlPGltZyBzcmM9ImltYWdlcy9pZGVudGlmaWVkIGJ5IHRoZW5hdHVyYWwgcmVzb3VyY2VzY2xhc3NpZmljYXRpb24gb2ZjYW4gYmUgY29uc2lkZXJlZHF1YW50dW0gbWVjaGFuaWNzTmV2ZXJ0aGVsZXNzLCB0aGVtaWxsaW9uIHllYXJzIGFnbzwvYm9keT4NCjwvaHRtbD4NzpXOu867zrfOvc65zrrOrAp0YWtlIGFkdmFudGFnZSBvZmFuZCwgYWNjb3JkaW5nIHRvYXR0cmlidXRlZCB0byB0aGVNaWNyb3NvZnQgV2luZG93c3RoZSBmaXJzdCBjZW50dXJ5dW5kZXIgdGhlIGNvbnRyb2xkaXYgY2xhc3M9ImhlYWRlcnNob3J0bHkgYWZ0ZXIgdGhlbm90YWJsZSBleGNlcHRpb250ZW5zIG9mIHRob3VzYW5kc3NldmVyYWwgZGlmZmVyZW50YXJvdW5kIHRoZSB3b3JsZC5yZWFjaGluZyBtaWxpdGFyeWlzb2xhdGVkIGZyb20gdGhlb3Bwb3NpdGlvbiB0byB0aGV0aGUgT2xkIFRlc3RhbWVudEFmcmljYW4gQW1lcmljYW5zaW5zZXJ0ZWQgaW50byB0aGVzZXBhcmF0ZSBmcm9tIHRoZW1ldHJvcG9saXRhbiBhcmVhbWFrZXMgaXQgcG9zc2libGVhY2tub3dsZWRnZWQgdGhhdGFyZ3VhYmx5IHRoZSBtb3N0dHlwZT0idGV4dC9jc3MiPgp0aGUgSW50ZXJuYXRpb25hbEFjY29yZGluZyB0byB0aGUgcGU9InRleHQvY3NzIiAvPgpjb2luY2lkZSB3aXRoIHRoZXR3by10aGlyZHMgb2YgdGhlRHVyaW5nIHRoaXMgdGltZSxkdXJpbmcgdGhlIHBlcmlvZGFubm91bmNlZCB0aGF0IGhldGhlIGludGVybmF0aW9uYWxhbmQgbW9yZSByZWNlbnRseWJlbGlldmVkIHRoYXQgdGhlY29uc2Npb3VzbmVzcyBhbmRmb3JtZXJseSBrbm93biBhc3N1cnJvdW5kZWQgYnkgdGhlZmlyc3QgYXBwZWFyZWQgaW5vY2Nhc2lvbmFsbHkgdXNlZHBvc2l0aW9uOmFic29sdXRlOyIgdGFyZ2V0PSJfYmxhbmsiIHBvc2l0aW9uOnJlbGF0aXZlO3RleHQtYWxpZ246Y2VudGVyO2pheC9saWJzL2pxdWVyeS8xLmJhY2tncm91bmQtY29sb3I6I3R5cGU9ImFwcGxpY2F0aW9uL2FuZ3VhZ2UiIGNvbnRlbnQ9IjxtZXRhIGh0dHAtZXF1aXY9IlByaXZhY3kgUG9saWN5PC9hPmUoIiUzQ3NjcmlwdCBzcmM9JyIgdGFyZ2V0PSJfYmxhbmsiPk9uIHRoZSBvdGhlciBoYW5kLC5qcGd8dGh1bWJ8cmlnaHR8MjwvZGl2PjxkaXYgY2xhc3M9IjxkaXYgc3R5bGU9ImZsb2F0Om5pbmV0ZWVudGggY2VudHVyeTwvYm9keT4NCjwvaHRtbD4NCjxpbWcgc3JjPSJodHRwOi8vczt0ZXh0LWFsaWduOmNlbnRlcmZvbnQtd2VpZ2h0OiBib2xkOyBBY2NvcmRpbmcgdG8gdGhlIGRpZmZlcmVuY2UgYmV0d2VlbiIgZnJhbWVib3JkZXI9IjAiICIgc3R5bGU9InBvc2l0aW9uOmxpbmsgaHJlZj0iaHR0cDovL2h0bWw0L2xvb3NlLmR0ZCI+CmR1cmluZyB0aGlzIHBlcmlvZDwvdGQ+PC90cj48L3RhYmxlPmNsb3NlbHkgcmVsYXRlZCB0b2ZvciB0aGUgZmlyc3QgdGltZTtmb250LXdlaWdodDpib2xkO2lucHV0IHR5cGU9InRleHQiIDxzcGFuIHN0eWxlPSJmb250LW9ucmVhZHlzdGF0ZWNoYW5nZQk8ZGl2IGNsYXNzPSJjbGVhcmRvY3VtZW50LmxvY2F0aW9uLiBGb3IgZXhhbXBsZSwgdGhlIGEgd2lkZSB2YXJpZXR5IG9mIDwhRE9DVFlQRSBodG1sPg0KPCZuYnNwOyZuYnNwOyZuYnNwOyI+PGEgaHJlZj0iaHR0cDovL3N0eWxlPSJmbG9hdDpsZWZ0O2NvbmNlcm5lZCB3aXRoIHRoZT1odHRwJTNBJTJGJTJGd3d3LmluIHBvcHVsYXIgY3VsdHVyZXR5cGU9InRleHQvY3NzIiAvPml0IGlzIHBvc3NpYmxlIHRvIEhhcnZhcmQgVW5pdmVyc2l0eXR5bGVzaGVldCIgaHJlZj0iL3RoZSBtYWluIGNoYXJhY3Rlck94Zm9yZCBVbml2ZXJzaXR5ICBuYW1lPSJrZXl3b3JkcyIgY3N0eWxlPSJ0ZXh0LWFsaWduOnRoZSBVbml0ZWQgS2luZ2RvbWZlZGVyYWwgZ292ZXJubWVudDxkaXYgc3R5bGU9Im1hcmdpbiBkZXBlbmRpbmcgb24gdGhlIGRlc2NyaXB0aW9uIG9mIHRoZTxkaXYgY2xhc3M9ImhlYWRlci5taW4uanMiPjwvc2NyaXB0PmRlc3RydWN0aW9uIG9mIHRoZXNsaWdodGx5IGRpZmZlcmVudGluIGFjY29yZGFuY2Ugd2l0aHRlbGVjb21tdW5pY2F0aW9uc2luZGljYXRlcyB0aGF0IHRoZXNob3J0bHkgdGhlcmVhZnRlcmVzcGVjaWFsbHkgaW4gdGhlIEV1cm9wZWFuIGNvdW50cmllc0hvd2V2ZXIsIHRoZXJlIGFyZXNyYz0iaHR0cDovL3N0YXRpY3N1Z2dlc3RlZCB0aGF0IHRoZSIgc3JjPSJodHRwOi8vd3d3LmEgbGFyZ2UgbnVtYmVyIG9mIFRlbGVjb21tdW5pY2F0aW9ucyIgcmVsPSJub2ZvbGxvdyIgdEhvbHkgUm9tYW4gRW1wZXJvcmFsbW9zdCBleGNsdXNpdmVseSIgYm9yZGVyPSIwIiBhbHQ9IlNlY3JldGFyeSBvZiBTdGF0ZWN1bG1pbmF0aW5nIGluIHRoZUNJQSBXb3JsZCBGYWN0Ym9va3RoZSBtb3N0IGltcG9ydGFudGFubml2ZXJzYXJ5IG9mIHRoZXN0eWxlPSJiYWNrZ3JvdW5kLTxsaT48ZW0+PGEgaHJlZj0iL3RoZSBBdGxhbnRpYyBPY2VhbnN0cmljdGx5IHNwZWFraW5nLHNob3J0bHkgYmVmb3JlIHRoZWRpZmZlcmVudCB0eXBlcyBvZnRoZSBPdHRvbWFuIEVtcGlyZT48aW1nIHNyYz0iaHR0cDovL0FuIEludHJvZHVjdGlvbiB0b2NvbnNlcXVlbmNlIG9mIHRoZWRlcGFydHVyZSBmcm9tIHRoZUNvbmZlZGVyYXRlIFN0YXRlc2luZGlnZW5vdXMgcGVvcGxlc1Byb2NlZWRpbmdzIG9mIHRoZWluZm9ybWF0aW9uIG9uIHRoZXRoZW9yaWVzIGhhdmUgYmVlbmludm9sdmVtZW50IGluIHRoZWRpdmlkZWQgaW50byB0aHJlZWFkamFjZW50IGNvdW50cmllc2lzIHJlc3BvbnNpYmxlIGZvcmRpc3NvbHV0aW9uIG9mIHRoZWNvbGxhYm9yYXRpb24gd2l0aHdpZGVseSByZWdhcmRlZCBhc2hpcyBjb250ZW1wb3Jhcmllc2ZvdW5kaW5nIG1lbWJlciBvZkRvbWluaWNhbiBSZXB1YmxpY2dlbmVyYWxseSBhY2NlcHRlZHRoZSBwb3NzaWJpbGl0eSBvZmFyZSBhbHNvIGF2YWlsYWJsZXVuZGVyIGNvbnN0cnVjdGlvbnJlc3RvcmF0aW9uIG9mIHRoZXRoZSBnZW5lcmFsIHB1YmxpY2lzIGFsbW9zdCBlbnRpcmVseXBhc3NlcyB0aHJvdWdoIHRoZWhhcyBiZWVuIHN1Z2dlc3RlZGNvbXB1dGVyIGFuZCB2aWRlb0dlcm1hbmljIGxhbmd1YWdlcyBhY2NvcmRpbmcgdG8gdGhlIGRpZmZlcmVudCBmcm9tIHRoZXNob3J0bHkgYWZ0ZXJ3YXJkc2hyZWY9Imh0dHBzOi8vd3d3LnJlY2VudCBkZXZlbG9wbWVudEJvYXJkIG9mIERpcmVjdG9yczxkaXYgY2xhc3M9InNlYXJjaHwgPGEgaHJlZj0iaHR0cDovL0luIHBhcnRpY3VsYXIsIHRoZU11bHRpcGxlIGZvb3Rub3Rlc29yIG90aGVyIHN1YnN0YW5jZXRob3VzYW5kcyBvZiB5ZWFyc3RyYW5zbGF0aW9uIG9mIHRoZTwvZGl2Pg0KPC9kaXY+DQoNCjxhIGhyZWY9ImluZGV4LnBocHdhcyBlc3RhYmxpc2hlZCBpbm1pbi5qcyI+PC9zY3JpcHQ+CnBhcnRpY2lwYXRlIGluIHRoZWEgc3Ryb25nIGluZmx1ZW5jZXN0eWxlPSJtYXJnaW4tdG9wOnJlcHJlc2VudGVkIGJ5IHRoZWdyYWR1YXRlZCBmcm9tIHRoZVRyYWRpdGlvbmFsbHksIHRoZUVsZW1lbnQoInNjcmlwdCIpO0hvd2V2ZXIsIHNpbmNlIHRoZS9kaXY+CjwvZGl2Pgo8ZGl2IGxlZnQ7IG1hcmdpbi1sZWZ0OnByb3RlY3Rpb24gYWdhaW5zdDA7IHZlcnRpY2FsLWFsaWduOlVuZm9ydHVuYXRlbHksIHRoZXR5cGU9ImltYWdlL3gtaWNvbi9kaXY+CjxkaXYgY2xhc3M9IiBjbGFzcz0iY2xlYXJmaXgiPjxkaXYgY2xhc3M9ImZvb3RlcgkJPC9kaXY+CgkJPC9kaXY+CnRoZSBtb3Rpb24gcGljdHVyZdCR0YrQu9Cz0LDRgNGB0LrQuNCx0YrQu9Cz0LDRgNGB0LrQuNCk0LXQtNC10YDQsNGG0LjQuNC90LXRgdC60L7Qu9GM0LrQvtGB0L7QvtCx0YnQtdC90LjQtdGB0L7QvtCx0YnQtdC90LjRj9C/0YDQvtCz0YDQsNC80LzRi9Ce0YLQv9GA0LDQstC40YLRjNCx0LXRgdC/0LvQsNGC0L3QvtC80LDRgtC10YDQuNCw0LvRi9C/0L7Qt9Cy0L7Qu9GP0LXRgtC/0L7RgdC70LXQtNC90LjQtdGA0LDQt9C70LjRh9C90YvRhdC/0YDQvtC00YPQutGG0LjQuNC/0YDQvtCz0YDQsNC80LzQsNC/0L7Qu9C90L7RgdGC0YzRjtC90LDRhdC+0LTQuNGC0YHRj9C40LfQsdGA0LDQvdC90L7QtdC90LDRgdC10LvQtdC90LjRj9C40LfQvNC10L3QtdC90LjRj9C60LDRgtC10LPQvtGA0LjQuNCQ0LvQtdC60YHQsNC90LTRgOCkpuCljeCkteCkvuCksOCkvuCkruCliOCkqOClgeCkheCksuCkquCljeCksOCkpuCkvuCkqOCkreCkvuCksOCkpOClgOCkr+CkheCkqOClgeCkpuClh+CktuCkueCkv+CkqOCljeCkpuClgOCkh+CkguCkoeCkv+Ckr+CkvuCkpuCkv+CksuCljeCksuClgOCkheCkp+Ckv+CkleCkvuCksOCkteClgOCkoeCkv+Ckr+Cli+CkmuCkv+Ckn+CljeCkoOClh+CkuOCkruCkvuCkmuCkvuCksOCknOCkguCkleCljeCktuCkqOCkpuClgeCkqOCkv+Ckr+CkvuCkquCljeCksOCkr+Cli+Ckl+CkheCkqOClgeCkuOCkvuCksOCkkeCkqOCksuCkvuCkh+CkqOCkquCkvuCksOCljeCkn+ClgOCktuCksOCljeCkpOCli+CkguCksuCli+CkleCkuOCkreCkvuCkq+CkvOCljeCksuCliOCktuCktuCksOCljeCkpOClh+CkguCkquCljeCksOCkpuClh+CktuCkquCljeCksuClh+Ckr+CksOCkleClh+CkguCkpuCljeCksOCkuOCljeCkpeCkv+CkpOCkv+CkieCkpOCljeCkquCkvuCkpuCkieCkqOCljeCkueClh+CkguCkmuCkv+Ckn+CljeCkoOCkvuCkr+CkvuCkpOCljeCksOCkvuCknOCljeCkr+CkvuCkpuCkvuCkquClgeCksOCkvuCkqOClh+CknOCli+CkoeCkvOClh+CkguCkheCkqOClgeCkteCkvuCkpuCktuCljeCksOClh+Cko+ClgOCktuCkv+CkleCljeCkt+CkvuCkuOCksOCkleCkvuCksOClgOCkuOCkguCkl+CljeCksOCkueCkquCksOCkv+Cko+CkvuCkruCkrOCljeCksOCkvuCkguCkoeCkrOCkmuCljeCkmuCli+CkguCkieCkquCksuCkrOCljeCkp+CkruCkguCkpOCljeCksOClgOCkuOCkguCkquCksOCljeCkleCkieCkruCljeCkruClgOCkpuCkruCkvuCkp+CljeCkr+CkruCkuOCkueCkvuCkr+CkpOCkvuCktuCkrOCljeCkpuCli+CkguCkruClgOCkoeCkv+Ckr+CkvuCkhuCkiOCkquClgOCkj+CksuCkruCli+CkrOCkvuCkh+CksuCkuOCkguCkluCljeCkr+CkvuCkhuCkquCksOClh+CktuCkqOCkheCkqOClgeCkrOCkguCkp+CkrOCkvuCknOCkvOCkvuCksOCkqOCkteClgOCkqOCkpOCkruCkquCljeCksOCkruClgeCkluCkquCljeCksOCktuCljeCkqOCkquCksOCkv+CkteCkvuCksOCkqOClgeCkleCkuOCkvuCkqOCkuOCkruCksOCljeCkpeCkqOCkhuCkr+Cli+CknOCkv+CkpOCkuOCli+CkruCkteCkvuCksNin2YTZhdi02KfYsdmD2KfYqtin2YTZhdmG2KrYr9mK2KfYqtin2YTZg9mF2KjZitmI2KrYsdin2YTZhdi02KfZh9iv2KfYqti52K/Yr9in2YTYstmI2KfYsdi52K/Yr9in2YTYsdiv2YjYr9in2YTYpdiz2YTYp9mF2YrYqdin2YTZgdmI2KrZiNi02YjYqNin2YTZhdiz2KfYqNmC2KfYqtin2YTZhdi52YTZiNmF2KfYqtin2YTZhdiz2YTYs9mE2KfYqtin2YTYrNix2KfZgdmK2YPYs9in2YTYp9iz2YTYp9mF2YrYqdin2YTYp9iq2LXYp9mE2KfYqmtleXdvcmRzIiBjb250ZW50PSJ3My5vcmcvMTk5OS94aHRtbCI+PGEgdGFyZ2V0PSJfYmxhbmsiIHRleHQvaHRtbDsgY2hhcnNldD0iIHRhcmdldD0iX2JsYW5rIj48dGFibGUgY2VsbHBhZGRpbmc9ImF1dG9jb21wbGV0ZT0ib2ZmIiB0ZXh0LWFsaWduOiBjZW50ZXI7dG8gbGFzdCB2ZXJzaW9uIGJ5IGJhY2tncm91bmQtY29sb3I6ICMiIGhyZWY9Imh0dHA6Ly93d3cuL2Rpdj48L2Rpdj48ZGl2IGlkPTxhIGhyZWY9IiMiIGNsYXNzPSIiPjxpbWcgc3JjPSJodHRwOi8vY3JpcHQiIHNyYz0iaHR0cDovLwo8c2NyaXB0IGxhbmd1YWdlPSIvL0VOIiAiaHR0cDovL3d3dy53ZW5jb2RlVVJJQ29tcG9uZW50KCIgaHJlZj0iamF2YXNjcmlwdDo8ZGl2IGNsYXNzPSJjb250ZW50ZG9jdW1lbnQud3JpdGUoJzxzY3Bvc2l0aW9uOiBhYnNvbHV0ZTtzY3JpcHQgc3JjPSJodHRwOi8vIHN0eWxlPSJtYXJnaW4tdG9wOi5taW4uanMiPjwvc2NyaXB0Pgo8L2Rpdj4KPGRpdiBjbGFzcz0idzMub3JnLzE5OTkveGh0bWwiIAoNCjwvYm9keT4NCjwvaHRtbD5kaXN0aW5jdGlvbiBiZXR3ZWVuLyIgdGFyZ2V0PSJfYmxhbmsiPjxsaW5rIGhyZWY9Imh0dHA6Ly9lbmNvZGluZz0idXRmLTgiPz4Kdy5hZGRFdmVudExpc3RlbmVyP2FjdGlvbj0iaHR0cDovL3d3dy5pY29uIiBocmVmPSJodHRwOi8vIHN0eWxlPSJiYWNrZ3JvdW5kOnR5cGU9InRleHQvY3NzIiAvPgptZXRhIHByb3BlcnR5PSJvZzp0PGlucHV0IHR5cGU9InRleHQiICBzdHlsZT0idGV4dC1hbGlnbjp0aGUgZGV2ZWxvcG1lbnQgb2YgdHlsZXNoZWV0IiB0eXBlPSJ0ZWh0bWw7IGNoYXJzZXQ9dXRmLThpcyBjb25zaWRlcmVkIHRvIGJldGFibGUgd2lkdGg9IjEwMCUiIEluIGFkZGl0aW9uIHRvIHRoZSBjb250cmlidXRlZCB0byB0aGUgZGlmZmVyZW5jZXMgYmV0d2VlbmRldmVsb3BtZW50IG9mIHRoZSBJdCBpcyBpbXBvcnRhbnQgdG8gPC9zY3JpcHQ+Cgo8c2NyaXB0ICBzdHlsZT0iZm9udC1zaXplOjE+PC9zcGFuPjxzcGFuIGlkPWdiTGlicmFyeSBvZiBDb25ncmVzczxpbWcgc3JjPSJodHRwOi8vaW1FbmdsaXNoIHRyYW5zbGF0aW9uQWNhZGVteSBvZiBTY2llbmNlc2RpdiBzdHlsZT0iZGlzcGxheTpjb25zdHJ1Y3Rpb24gb2YgdGhlLmdldEVsZW1lbnRCeUlkKGlkKWluIGNvbmp1bmN0aW9uIHdpdGhFbGVtZW50KCdzY3JpcHQnKTsgPG1ldGEgcHJvcGVydHk9Im9nOtCR0YrQu9Cz0LDRgNGB0LrQuAogdHlwZT0idGV4dCIgbmFtZT0iPlByaXZhY3kgUG9saWN5PC9hPmFkbWluaXN0ZXJlZCBieSB0aGVlbmFibGVTaW5nbGVSZXF1ZXN0c3R5bGU9JnF1b3Q7bWFyZ2luOjwvZGl2PjwvZGl2PjwvZGl2Pjw+PGltZyBzcmM9Imh0dHA6Ly9pIHN0eWxlPSZxdW90O2Zsb2F0OnJlZmVycmVkIHRvIGFzIHRoZSB0b3RhbCBwb3B1bGF0aW9uIG9maW4gV2FzaGluZ3RvbiwgRC5DLiBzdHlsZT0iYmFja2dyb3VuZC1hbW9uZyBvdGhlciB0aGluZ3Msb3JnYW5pemF0aW9uIG9mIHRoZXBhcnRpY2lwYXRlZCBpbiB0aGV0aGUgaW50cm9kdWN0aW9uIG9maWRlbnRpZmllZCB3aXRoIHRoZWZpY3Rpb25hbCBjaGFyYWN0ZXIgT3hmb3JkIFVuaXZlcnNpdHkgbWlzdW5kZXJzdGFuZGluZyBvZlRoZXJlIGFyZSwgaG93ZXZlcixzdHlsZXNoZWV0IiBocmVmPSIvQ29sdW1iaWEgVW5pdmVyc2l0eWV4cGFuZGVkIHRvIGluY2x1ZGV1c3VhbGx5IHJlZmVycmVkIHRvaW5kaWNhdGluZyB0aGF0IHRoZWhhdmUgc3VnZ2VzdGVkIHRoYXRhZmZpbGlhdGVkIHdpdGggdGhlY29ycmVsYXRpb24gYmV0d2Vlbm51bWJlciBvZiBkaWZmZXJlbnQ+PC90ZD48L3RyPjwvdGFibGU+UmVwdWJsaWMgb2YgSXJlbGFuZAo8L3NjcmlwdD4KPHNjcmlwdCB1bmRlciB0aGUgaW5mbHVlbmNlY29udHJpYnV0aW9uIHRvIHRoZU9mZmljaWFsIHdlYnNpdGUgb2ZoZWFkcXVhcnRlcnMgb2YgdGhlY2VudGVyZWQgYXJvdW5kIHRoZWltcGxpY2F0aW9ucyBvZiB0aGVoYXZlIGJlZW4gZGV2ZWxvcGVkRmVkZXJhbCBSZXB1YmxpYyBvZmJlY2FtZSBpbmNyZWFzaW5nbHljb250aW51YXRpb24gb2YgdGhlTm90ZSwgaG93ZXZlciwgdGhhdHNpbWlsYXIgdG8gdGhhdCBvZiBjYXBhYmlsaXRpZXMgb2YgdGhlYWNjb3JkYW5jZSB3aXRoIHRoZXBhcnRpY2lwYW50cyBpbiB0aGVmdXJ0aGVyIGRldmVsb3BtZW50dW5kZXIgdGhlIGRpcmVjdGlvbmlzIG9mdGVuIGNvbnNpZGVyZWRoaXMgeW91bmdlciBicm90aGVyPC90ZD48L3RyPjwvdGFibGU+PGEgaHR0cC1lcXVpdj0iWC1VQS1waHlzaWNhbCBwcm9wZXJ0aWVzb2YgQnJpdGlzaCBDb2x1bWJpYWhhcyBiZWVuIGNyaXRpY2l6ZWQod2l0aCB0aGUgZXhjZXB0aW9ucXVlc3Rpb25zIGFib3V0IHRoZXBhc3NpbmcgdGhyb3VnaCB0aGUwIiBjZWxscGFkZGluZz0iMCIgdGhvdXNhbmRzIG9mIHBlb3BsZXJlZGlyZWN0cyBoZXJlLiBGb3JoYXZlIGNoaWxkcmVuIHVuZGVyJTNFJTNDL3NjcmlwdCUzRSIpKTs8YSBocmVmPSJodHRwOi8vd3d3LjxsaT48YSBocmVmPSJodHRwOi8vc2l0ZV9uYW1lIiBjb250ZW50PSJ0ZXh0LWRlY29yYXRpb246bm9uZXN0eWxlPSJkaXNwbGF5OiBub25lPG1ldGEgaHR0cC1lcXVpdj0iWC1uZXcgRGF0ZSgpLmdldFRpbWUoKSB0eXBlPSJpbWFnZS94LWljb24iPC9zcGFuPjxzcGFuIGNsYXNzPSJsYW5ndWFnZT0iamF2YXNjcmlwdHdpbmRvdy5sb2NhdGlvbi5ocmVmPGEgaHJlZj0iamF2YXNjcmlwdDotLT4NCjxzY3JpcHQgdHlwZT0idDxhIGhyZWY9J2h0dHA6Ly93d3cuaG9ydGN1dCBpY29uIiBocmVmPSI8L2Rpdj4NCjxkaXYgY2xhc3M9IjxzY3JpcHQgc3JjPSJodHRwOi8vIiByZWw9InN0eWxlc2hlZXQiIHQ8L2Rpdj4KPHNjcmlwdCB0eXBlPS9hPiA8YSBocmVmPSJodHRwOi8vIGFsbG93VHJhbnNwYXJlbmN5PSJYLVVBLUNvbXBhdGlibGUiIGNvbnJlbGF0aW9uc2hpcCBiZXR3ZWVuCjwvc2NyaXB0Pg0KPHNjcmlwdCA8L2E+PC9saT48L3VsPjwvZGl2PmFzc29jaWF0ZWQgd2l0aCB0aGUgcHJvZ3JhbW1pbmcgbGFuZ3VhZ2U8L2E+PGEgaHJlZj0iaHR0cDovLzwvYT48L2xpPjxsaSBjbGFzcz0iZm9ybSBhY3Rpb249Imh0dHA6Ly88ZGl2IHN0eWxlPSJkaXNwbGF5OnR5cGU9InRleHQiIG5hbWU9InEiPHRhYmxlIHdpZHRoPSIxMDAlIiBiYWNrZ3JvdW5kLXBvc2l0aW9uOiIgYm9yZGVyPSIwIiB3aWR0aD0icmVsPSJzaG9ydGN1dCBpY29uIiBoNj48dWw+PGxpPjxhIGhyZWY9IiAgPG1ldGEgaHR0cC1lcXVpdj0iY3NzIiBtZWRpYT0ic2NyZWVuIiByZXNwb25zaWJsZSBmb3IgdGhlICIgdHlwZT0iYXBwbGljYXRpb24vIiBzdHlsZT0iYmFja2dyb3VuZC1odG1sOyBjaGFyc2V0PXV0Zi04IiBhbGxvd3RyYW5zcGFyZW5jeT0ic3R5bGVzaGVldCIgdHlwZT0idGUNCjxtZXRhIGh0dHAtZXF1aXY9Ij48L3NwYW4+PHNwYW4gY2xhc3M9IjAiIGNlbGxzcGFjaW5nPSIwIj47Cjwvc2NyaXB0Pgo8c2NyaXB0IHNvbWV0aW1lcyBjYWxsZWQgdGhlZG9lcyBub3QgbmVjZXNzYXJpbHlGb3IgbW9yZSBpbmZvcm1hdGlvbmF0IHRoZSBiZWdpbm5pbmcgb2YgPCFET0NUWVBFIGh0bWw+PGh0bWxwYXJ0aWN1bGFybHkgaW4gdGhlIHR5cGU9ImhpZGRlbiIgbmFtZT0iamF2YXNjcmlwdDp2b2lkKDApOyJlZmZlY3RpdmVuZXNzIG9mIHRoZSBhdXRvY29tcGxldGU9Im9mZiIgZ2VuZXJhbGx5IGNvbnNpZGVyZWQ+PGlucHV0IHR5cGU9InRleHQiICI+PC9zY3JpcHQ+DQo8c2NyaXB0dGhyb3VnaG91dCB0aGUgd29ybGRjb21tb24gbWlzY29uY2VwdGlvbmFzc29jaWF0aW9uIHdpdGggdGhlPC9kaXY+CjwvZGl2Pgo8ZGl2IGNkdXJpbmcgaGlzIGxpZmV0aW1lLGNvcnJlc3BvbmRpbmcgdG8gdGhldHlwZT0iaW1hZ2UveC1pY29uIiBhbiBpbmNyZWFzaW5nIG51bWJlcmRpcGxvbWF0aWMgcmVsYXRpb25zYXJlIG9mdGVuIGNvbnNpZGVyZWRtZXRhIGNoYXJzZXQ9InV0Zi04IiA8aW5wdXQgdHlwZT0idGV4dCIgZXhhbXBsZXMgaW5jbHVkZSB0aGUiPjxpbWcgc3JjPSJodHRwOi8vaXBhcnRpY2lwYXRpb24gaW4gdGhldGhlIGVzdGFibGlzaG1lbnQgb2YKPC9kaXY+CjxkaXYgY2xhc3M9IiZhbXA7bmJzcDsmYW1wO25ic3A7dG8gZGV0ZXJtaW5lIHdoZXRoZXJxdWl0ZSBkaWZmZXJlbnQgZnJvbW1hcmtlZCB0aGUgYmVnaW5uaW5nZGlzdGFuY2UgYmV0d2VlbiB0aGVjb250cmlidXRpb25zIHRvIHRoZWNvbmZsaWN0IGJldHdlZW4gdGhld2lkZWx5IGNvbnNpZGVyZWQgdG93YXMgb25lIG9mIHRoZSBmaXJzdHdpdGggdmFyeWluZyBkZWdyZWVzaGF2ZSBzcGVjdWxhdGVkIHRoYXQoZG9jdW1lbnQuZ2V0RWxlbWVudHBhcnRpY2lwYXRpbmcgaW4gdGhlb3JpZ2luYWxseSBkZXZlbG9wZWRldGEgY2hhcnNldD0idXRmLTgiPiB0eXBlPSJ0ZXh0L2NzcyIgLz4KaW50ZXJjaGFuZ2VhYmx5IHdpdGhtb3JlIGNsb3NlbHkgcmVsYXRlZHNvY2lhbCBhbmQgcG9saXRpY2FsdGhhdCB3b3VsZCBvdGhlcndpc2VwZXJwZW5kaWN1bGFyIHRvIHRoZXN0eWxlIHR5cGU9InRleHQvY3NzdHlwZT0ic3VibWl0IiBuYW1lPSJmYW1pbGllcyByZXNpZGluZyBpbmRldmVsb3BpbmcgY291bnRyaWVzY29tcHV0ZXIgcHJvZ3JhbW1pbmdlY29ub21pYyBkZXZlbG9wbWVudGRldGVybWluYXRpb24gb2YgdGhlZm9yIG1vcmUgaW5mb3JtYXRpb25vbiBzZXZlcmFsIG9jY2FzaW9uc3BvcnR1Z3XDqnMgKEV1cm9wZXUp0KPQutGA0LDRl9C90YHRjNC60LDRg9C60YDQsNGX0L3RgdGM0LrQsNCg0L7RgdGB0LjQudGB0LrQvtC50LzQsNGC0LXRgNC40LDQu9C+0LLQuNC90YTQvtGA0LzQsNGG0LjQuNGD0L/RgNCw0LLQu9C10L3QuNGP0L3QtdC+0LHRhdC+0LTQuNC80L7QuNC90YTQvtGA0LzQsNGG0LjRj9CY0L3RhNC+0YDQvNCw0YbQuNGP0KDQtdGB0L/Rg9Cx0LvQuNC60LjQutC+0LvQuNGH0LXRgdGC0LLQvtC40L3RhNC+0YDQvNCw0YbQuNGO0YLQtdGA0YDQuNGC0L7RgNC40LjQtNC+0YHRgtCw0YLQvtGH0L3Qvtin2YTZhdiq2YjYp9is2K/ZiNmG2KfZhNin2LTYqtix2KfZg9in2KrYp9mE2KfZgtiq2LHYp9it2KfYqmh0bWw7IGNoYXJzZXQ9VVRGLTgiIHNldFRpbWVvdXQoZnVuY3Rpb24oKWRpc3BsYXk6aW5saW5lLWJsb2NrOzxpbnB1dCB0eXBlPSJzdWJtaXQiIHR5cGUgPSAndGV4dC9qYXZhc2NyaTxpbWcgc3JjPSJodHRwOi8vd3d3LiIgImh0dHA6Ly93d3cudzMub3JnL3Nob3J0Y3V0IGljb24iIGhyZWY9IiIgYXV0b2NvbXBsZXRlPSJvZmYiIDwvYT48L2Rpdj48ZGl2IGNsYXNzPTwvYT48L2xpPgo8bGkgY2xhc3M9ImNzcyIgdHlwZT0idGV4dC9jc3MiIDxmb3JtIGFjdGlvbj0iaHR0cDovL3h0L2NzcyIgaHJlZj0iaHR0cDovL2xpbmsgcmVsPSJhbHRlcm5hdGUiIA0KPHNjcmlwdCB0eXBlPSJ0ZXh0LyBvbmNsaWNrPSJqYXZhc2NyaXB0OihuZXcgRGF0ZSkuZ2V0VGltZSgpfWhlaWdodD0iMSIgd2lkdGg9IjEiIFBlb3BsZSdzIFJlcHVibGljIG9mICA8YSBocmVmPSJodHRwOi8vd3d3LnRleHQtZGVjb3JhdGlvbjp1bmRlcnRoZSBiZWdpbm5pbmcgb2YgdGhlIDwvZGl2Pgo8L2Rpdj4KPC9kaXY+CmVzdGFibGlzaG1lbnQgb2YgdGhlIDwvZGl2PjwvZGl2PjwvZGl2PjwvZCN2aWV3cG9ydHttaW4taGVpZ2h0Ogo8c2NyaXB0IHNyYz0iaHR0cDovL29wdGlvbj48b3B0aW9uIHZhbHVlPW9mdGVuIHJlZmVycmVkIHRvIGFzIC9vcHRpb24+CjxvcHRpb24gdmFsdTwhRE9DVFlQRSBodG1sPgo8IS0tW0ludGVybmF0aW9uYWwgQWlycG9ydD4KPGEgaHJlZj0iaHR0cDovL3d3dzwvYT48YSBocmVmPSJodHRwOi8vd+C4oOC4suC4qeC4suC5hOC4l+C4ouGDpeGDkOGDoOGDl+GDo+GDmuGDmOato+mrlOS4reaWhyAo57mB6auUKeCkqOCkv+CksOCljeCkpuClh+CktuCkoeCkvuCkieCkqOCksuCli+CkoeCkleCljeCkt+Clh+CkpOCljeCksOCknOCkvuCkqOCkleCkvuCksOClgOCkuOCkguCkrOCkguCkp+Ckv+CkpOCkuOCljeCkpeCkvuCkquCkqOCkvuCkuOCljeCkteClgOCkleCkvuCksOCkuOCkguCkuOCljeCkleCksOCko+CkuOCkvuCkruCkl+CljeCksOClgOCkmuCkv+Ckn+CljeCkoOCli+CkguCkteCkv+CknOCljeCknuCkvuCkqOCkheCkruClh+CksOCkv+CkleCkvuCkteCkv+CkreCkv+CkqOCljeCkqOCkl+CkvuCkoeCkv+Ckr+CkvuCkgeCkleCljeCkr+Cli+CkguCkleCkv+CkuOClgeCksOCkleCljeCkt+CkvuCkquCkueClgeCkgeCkmuCkpOClgOCkquCljeCksOCkrOCkguCkp+CkqOCkn+Ckv+CkquCljeCkquCko+ClgOCkleCljeCksOCkv+CkleClh+Ckn+CkquCljeCksOCkvuCksOCkguCkreCkquCljeCksOCkvuCkquCljeCkpOCkruCkvuCksuCkv+CkleCli+CkguCksOCkq+CkvOCljeCkpOCkvuCksOCkqOCkv+CksOCljeCkruCkvuCko+CksuCkv+CkruCkv+Ckn+Clh+CkoWRlc2NyaXB0aW9uIiBjb250ZW50PSJkb2N1bWVudC5sb2NhdGlvbi5wcm90LmdldEVsZW1lbnRzQnlUYWdOYW1lKDwhRE9DVFlQRSBodG1sPgo8aHRtbCA8bWV0YSBjaGFyc2V0PSJ1dGYtOCI+OnVybCIgY29udGVudD0iaHR0cDovLy5jc3MiIHJlbD0ic3R5bGVzaGVldCJzdHlsZSB0eXBlPSJ0ZXh0L2NzcyI+dHlwZT0idGV4dC9jc3MiIGhyZWY9InczLm9yZy8xOTk5L3hodG1sIiB4bWx0eXBlPSJ0ZXh0L2phdmFzY3JpcHQiIG1ldGhvZD0iZ2V0IiBhY3Rpb249ImxpbmsgcmVsPSJzdHlsZXNoZWV0IiAgPSBkb2N1bWVudC5nZXRFbGVtZW50dHlwZT0iaW1hZ2UveC1pY29uIiAvPmNlbGxwYWRkaW5nPSIwIiBjZWxsc3AuY3NzIiB0eXBlPSJ0ZXh0L2NzcyIgPC9hPjwvbGk+PGxpPjxhIGhyZWY9IiIgd2lkdGg9IjEiIGhlaWdodD0iMSIiPjxhIGhyZWY9Imh0dHA6Ly93d3cuc3R5bGU9ImRpc3BsYXk6bm9uZTsiPmFsdGVybmF0ZSIgdHlwZT0iYXBwbGktLy9XM0MvL0RURCBYSFRNTCAxLjAgZWxsc3BhY2luZz0iMCIgY2VsbHBhZCB0eXBlPSJoaWRkZW4iIHZhbHVlPSIvYT4mbmJzcDs8c3BhbiByb2xlPSJzCjxpbnB1dCB0eXBlPSJoaWRkZW4iIGxhbmd1YWdlPSJKYXZhU2NyaXB0IiAgZG9jdW1lbnQuZ2V0RWxlbWVudHNCZz0iMCIgY2VsbHNwYWNpbmc9IjAiIHlwZT0idGV4dC9jc3MiIG1lZGlhPSJ0eXBlPSd0ZXh0L2phdmFzY3JpcHQnd2l0aCB0aGUgZXhjZXB0aW9uIG9mIHlwZT0idGV4dC9jc3MiIHJlbD0ic3QgaGVpZ2h0PSIxIiB3aWR0aD0iMSIgPScrZW5jb2RlVVJJQ29tcG9uZW50KDxsaW5rIHJlbD0iYWx0ZXJuYXRlIiAKYm9keSwgdHIsIGlucHV0LCB0ZXh0bWV0YSBuYW1lPSJyb2JvdHMiIGNvbm1ldGhvZD0icG9zdCIgYWN0aW9uPSI+CjxhIGhyZWY9Imh0dHA6Ly93d3cuY3NzIiByZWw9InN0eWxlc2hlZXQiIDwvZGl2PjwvZGl2PjxkaXYgY2xhc3NsYW5ndWFnZT0iamF2YXNjcmlwdCI+YXJpYS1oaWRkZW49InRydWUiPsK3PHJpcHQiIHR5cGU9InRleHQvamF2YXNsPTA7fSkoKTsKKGZ1bmN0aW9uKCl7YmFja2dyb3VuZC1pbWFnZTogdXJsKC9hPjwvbGk+PGxpPjxhIGhyZWY9ImgJCTxsaT48YSBocmVmPSJodHRwOi8vYXRvciIgYXJpYS1oaWRkZW49InRydT4gPGEgaHJlZj0iaHR0cDovL3d3dy5sYW5ndWFnZT0iamF2YXNjcmlwdCIgL29wdGlvbj4KPG9wdGlvbiB2YWx1ZS9kaXY+PC9kaXY+PGRpdiBjbGFzcz1yYXRvciIgYXJpYS1oaWRkZW49InRyZT0obmV3IERhdGUpLmdldFRpbWUoKXBvcnR1Z3XDqnMgKGRvIEJyYXNpbCnQvtGA0LPQsNC90LjQt9Cw0YbQuNC40LLQvtC30LzQvtC20L3QvtGB0YLRjNC+0LHRgNCw0LfQvtCy0LDQvdC40Y/RgNC10LPQuNGB0YLRgNCw0YbQuNC40LLQvtC30LzQvtC20L3QvtGB0YLQuNC+0LHRj9C30LDRgtC10LvRjNC90LA8IURPQ1RZUEUgaHRtbCBQVUJMSUMgIm50LVR5cGUiIGNvbnRlbnQ9InRleHQvPG1ldGEgaHR0cC1lcXVpdj0iQ29udGVyYW5zaXRpb25hbC8vRU4iICJodHRwOjxodG1sIHhtbG5zPSJodHRwOi8vd3d3LS8vVzNDLy9EVEQgWEhUTUwgMS4wIFREVEQveGh0bWwxLXRyYW5zaXRpb25hbC8vd3d3LnczLm9yZy9UUi94aHRtbDEvcGUgPSAndGV4dC9qYXZhc2NyaXB0Jzs8bWV0YSBuYW1lPSJkZXNjcmlwdGlvbnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlPGlucHV0IHR5cGU9ImhpZGRlbiIgbmFqcyIgdHlwZT0idGV4dC9qYXZhc2NyaShkb2N1bWVudCkucmVhZHkoZnVuY3Rpc2NyaXB0IHR5cGU9InRleHQvamF2YXNpbWFnZSIgY29udGVudD0iaHR0cDovL1VBLUNvbXBhdGlibGUiIGNvbnRlbnQ9dG1sOyBjaGFyc2V0PXV0Zi04IiAvPgpsaW5rIHJlbD0ic2hvcnRjdXQgaWNvbjxsaW5rIHJlbD0ic3R5bGVzaGVldCIgPC9zY3JpcHQ+CjxzY3JpcHQgdHlwZT09IGRvY3VtZW50LmNyZWF0ZUVsZW1lbjxhIHRhcmdldD0iX2JsYW5rIiBocmVmPSBkb2N1bWVudC5nZXRFbGVtZW50c0JpbnB1dCB0eXBlPSJ0ZXh0IiBuYW1lPWEudHlwZSA9ICd0ZXh0L2phdmFzY3JpbnB1dCB0eXBlPSJoaWRkZW4iIG5hbWVodG1sOyBjaGFyc2V0PXV0Zi04IiAvPmR0ZCI+CjxodG1sIHhtbG5zPSJodHRwLS8vVzNDLy9EVEQgSFRNTCA0LjAxIFRlbnRzQnlUYWdOYW1lKCdzY3JpcHQnKWlucHV0IHR5cGU9ImhpZGRlbiIgbmFtPHNjcmlwdCB0eXBlPSJ0ZXh0L2phdmFzIiBzdHlsZT0iZGlzcGxheTpub25lOyI+ZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJyB0eXBlPSd0ZXh0L2phdmFzY3JpcHQnaW5wdXQgdHlwZT0idGV4dCIgbmFtZT0iZC5nZXRFbGVtZW50c0J5VGFnTmFtZShzbmljYWwiIGhyZWY9Imh0dHA6Ly93d3cuQy8vRFREIEhUTUwgNC4wMSBUcmFuc2l0PHN0eWxlIHR5cGU9InRleHQvY3NzIj4KCjxzdHlsZSB0eXBlPSJ0ZXh0L2NzcyI+aW9uYWwuZHRkIj4KPGh0bWwgeG1sbnM9aHR0cC1lcXVpdj0iQ29udGVudC1UeXBlZGluZz0iMCIgY2VsbHNwYWNpbmc9IjAiaHRtbDsgY2hhcnNldD11dGYtOCIgLz4KIHN0eWxlPSJkaXNwbGF5Om5vbmU7Ij48PGxpPjxhIGhyZWY9Imh0dHA6Ly93d3cuIHR5cGU9J3RleHQvamF2YXNjcmlwdCc+0LTQtdGP0YLQtdC70YzQvdC+0YHRgtC40YHQvtC+0YLQstC10YLRgdGC0LLQuNC40L/RgNC+0LjQt9Cy0L7QtNGB0YLQstCw0LHQtdC30L7Qv9Cw0YHQvdC+0YHRgtC44KSq4KWB4KS44KWN4KSk4KS/4KSV4KS+4KSV4KS+4KSC4KSX4KWN4KSw4KWH4KS44KSJ4KSo4KWN4KS54KWL4KSC4KSo4KWH4KS14KS/4KSn4KS+4KSo4KS44KSt4KS+4KSr4KS/4KSV4KWN4KS44KS/4KSC4KSX4KS44KWB4KSw4KSV4KWN4KS34KS/4KSk4KSV4KWJ4KSq4KWA4KSw4KS+4KSH4KSf4KS14KS/4KSc4KWN4KSe4KS+4KSq4KSo4KSV4KS+4KSw4KWN4KSw4KS14KS+4KSI4KS44KSV4KWN4KSw4KS/4KSv4KSk4KS+AAGSAbQB1AH0ARYCNgJWAnYClgK2AtYC9gIWAzYDVgN2A5gDuAPYA/gDGAQ4BFgEeASYBLgE2AT4BBgFOAVYBXgFmAW4BdgF+AVOU3QzX18yMTJiYXNpY19zdHJpbmdJaE5TXzExY2hhcl90cmFpdHNJaEVFTlNfOWFsbG9jYXRvckloRUVFRQAAAABAEQIAagwCAE5TdDNfXzIxMmJhc2ljX3N0cmluZ0l3TlNfMTFjaGFyX3RyYWl0c0l3RUVOU185YWxsb2NhdG9ySXdFRUVFAABAEQIAtAwCAE5TdDNfXzIxMmJhc2ljX3N0cmluZ0lEc05TXzExY2hhcl90cmFpdHNJRHNFRU5TXzlhbGxvY2F0b3JJRHNFRUVFAAAAQBECAPwMAgBOU3QzX18yMTJiYXNpY19zdHJpbmdJRGlOU18xMWNoYXJfdHJhaXRzSURpRUVOU185YWxsb2NhdG9ySURpRUVFRQAAAEARAgBIDQIATjEwZW1zY3JpcHRlbjExbWVtb3J5X3ZpZXdJY0VFAABAEQIAlA0CAE4xMGVtc2NyaXB0ZW4xMW1lbW9yeV92aWV3SWFFRQAAQBECALwNAgBOMTBlbXNjcmlwdGVuMTFtZW1vcnlfdmlld0lzRUUAAEARAgDkDQIATjEwZW1zY3JpcHRlbjExbWVtb3J5X3ZpZXdJdEVFAABAEQIADA4CAE4xMGVtc2NyaXB0ZW4xMW1lbW9yeV92aWV3SWlFRQAAQBECADQOAgBOMTBlbXNjcmlwdGVuMTFtZW1vcnlfdmlld0lqRUUAAEARAgBcDgIATjEwZW1zY3JpcHRlbjExbWVtb3J5X3ZpZXdJbEVFAABAEQIAhA4CAE4xMGVtc2NyaXB0ZW4xMW1lbW9yeV92aWV3SW1FRQAAQBECAKwOAgBOMTBlbXNjcmlwdGVuMTFtZW1vcnlfdmlld0l4RUUAAEARAgDUDgIATjEwZW1zY3JpcHRlbjExbWVtb3J5X3ZpZXdJeUVFAABAEQIA/A4CAE4xMGVtc2NyaXB0ZW4xMW1lbW9yeV92aWV3SWZFRQAAQBECACQPAgBOMTBlbXNjcmlwdGVuMTFtZW1vcnlfdmlld0lkRUUAAEARAgBMDwIATjEwX19jeHhhYml2MTE2X19zaGltX3R5cGVfaW5mb0UAAAAAaBECAHQPAgDIEgIATjEwX19jeHhhYml2MTE3X19jbGFzc190eXBlX2luZm9FAAAAaBECAKQPAgCYDwIATjEwX19jeHhhYml2MTE3X19wYmFzZV90eXBlX2luZm9FAAAAaBECANQPAgCYDwIATjEwX19jeHhhYml2MTE5X19wb2ludGVyX3R5cGVfaW5mb0UAaBECAAQQAgD4DwIAAAAAAHgQAgAOAAAADwAAABAAAAARAAAAEgAAAE4xMF9fY3h4YWJpdjEyM19fZnVuZGFtZW50YWxfdHlwZV9pbmZvRQBoEQIAUBACAJgPAgB2AAAAPBACAIQQAgBiAAAAPBACAJAQAgBjAAAAPBACAJwQAgBoAAAAPBACAKgQAgBhAAAAPBACALQQAgBzAAAAPBACAMAQAgB0AAAAPBACAMwQAgBpAAAAPBACANgQAgBqAAAAPBACAOQQAgBsAAAAPBACAPAQAgBtAAAAPBACAPwQAgB4AAAAPBACAAgRAgB5AAAAPBACABQRAgBmAAAAPBACACARAgBkAAAAPBACACwRAgAAAAAAyA8CAA4AAAATAAAAEAAAABEAAAAUAAAAFQAAABYAAAAXAAAAAAAAALARAgAOAAAAGAAAABAAAAARAAAAFAAAABkAAAAaAAAAGwAAAE4xMF9fY3h4YWJpdjEyMF9fc2lfY2xhc3NfdHlwZV9pbmZvRQAAAABoEQIAiBECAMgPAgAAAAAAIBICAAUAAAAcAAAAHQAAAAAAAABIEgIABQAAAB4AAAAfAAAAAAAAAAgSAgAFAAAAIAAAACEAAABTdDlleGNlcHRpb24AAAAAQBECAPgRAgBTdDliYWRfYWxsb2MAAAAAaBECABASAgAIEgIAU3QyMGJhZF9hcnJheV9uZXdfbGVuZ3RoAAAAAGgRAgAsEgIAIBICAAAAAAB4EgIAAwAAACIAAAAjAAAAU3QxMWxvZ2ljX2Vycm9yAGgRAgBoEgIACBICAAAAAACsEgIAAwAAACQAAAAjAAAAU3QxMmxlbmd0aF9lcnJvcgAAAABoEQIAmBICAHgSAgBTdDl0eXBlX2luZm8AAAAAQBECALgSAgBB1KUIC230EgIABgAAAAcAAAAIAAAACQAAAAoAAABAEQIARQkAAGgRAgAsCQAA7BICANkAAABgCQAAQAoAAHkAAACwCgAAAAAMABsAFwAqAD8AOAAwADsAQAAAAAAACgoLCwoKCgoKCQkIBwcIBwcGBgUFAEHdpggLdhAAAAAkAAAAVAAAAIwAAACsAAAA0AAAAPgAAAAkAQAAVAEAAG4BAACKAQAAmQEAAKEBAICpAQCAuwEAAMUBAADPAQBA1AEAwNkBAKDcAQCg3wEAoN8BAKDfAQCg3wEAoN8BAKDfAQCg3wEAoN8BAIAsAADgFQM=\")||(k=m,m=I.locateFile?I.locateFile(k,o):o+k);var K=A=>{for(;A.length>0;)A.shift()(I)};function j(A){this.excPtr=A,this.ptr=A-24,this.set_type=function(A){W[this.ptr+4>>2]=A},this.get_type=function(){return W[this.ptr+4>>2]},this.set_destructor=function(A){W[this.ptr+8>>2]=A},this.get_destructor=function(){return W[this.ptr+8>>2]},this.set_caught=function(A){A=A?1:0,Z[this.ptr+12>>0]=A},this.get_caught=function(){return 0!=Z[this.ptr+12>>0]},this.set_rethrown=function(A){A=A?1:0,Z[this.ptr+13>>0]=A},this.get_rethrown=function(){return 0!=Z[this.ptr+13>>0]},this.init=function(A,I){this.set_adjusted_ptr(0),this.set_type(A),this.set_destructor(I)},this.set_adjusted_ptr=function(A){W[this.ptr+16>>2]=A},this.get_adjusted_ptr=function(){return W[this.ptr+16>>2]},this.get_exception_ptr=function(){if(Ax(this.get_type()))return W[this.excPtr>>2];var A=this.get_adjusted_ptr();return 0!==A?A:this.excPtr}}var x=0,M=0,e=A=>{for(var I=\"\",C=A;l[C];)I+=h[l[C++]];return I},r={},U={},O={},P=A=>{throw new N(A)},q=A=>{throw new R(A)},T=(A,I,C)=>{function g(I){var g=C(I);g.length!==A.length&&q(\"Mismatched type converter count\");for(var B=0;B<A.length;++B)f(A[B],g[B])}A.forEach(function(A){O[A]=I});var B=Array(I.length),Q=[],G=0;I.forEach((A,I)=>{U.hasOwnProperty(A)?B[I]=U[A]:(Q.push(A),r.hasOwnProperty(A)||(r[A]=[]),r[A].push(()=>{B[I]=U[A],++G===Q.length&&g(B)}))}),0===Q.length&&g(B)};function f(A,I,C={}){if(!(\"argPackAdvance\"in I))throw TypeError(\"registerType registeredInstance requires argPackAdvance\");return function(A,I,C={}){var g=I.name;if(A||P(`type \"${g}\" must have a positive integer typeid pointer`),U.hasOwnProperty(A)){if(C.ignoreDuplicateRegistrations)return;P(`Cannot register type '${g}' twice`)}if(U[A]=I,delete O[A],r.hasOwnProperty(A)){var B=r[A];delete r[A],B.forEach(A=>A())}}(A,I,C)}function _(){this.allocated=[void 0],this.freelist=[]}var $=new _,AA=A=>{A>=$.reserved&&0==--$.get(A).refcount&&$.free(A)},AI={toValue:A=>(A||P(\"Cannot use deleted val. handle = \"+A),$.get(A).value),toHandle:A=>{switch(A){case void 0:return 1;case null:return 2;case!0:return 3;case!1:return 4;default:return $.allocate({refcount:1,value:A})}}};function AC(A){return this.fromWireType(c[A>>2])}var Ag=(A,I)=>{switch(I){case 4:return function(A){return this.fromWireType(d[A>>2])};case 8:return function(A){return this.fromWireType(E[A>>3])};default:throw TypeError(`invalid float width (${I}): ${A}`)}},AB=A=>{if(void 0===A)return\"_unknown\";var I=(A=A.replace(/[^a-zA-Z0-9_]/g,\"$\")).charCodeAt(0);return I>=48&&I<=57?`_${A}`:A},AQ=A=>{for(;A.length;){var I=A.pop();A.pop()(I)}};function AG(A,I){return({[A=AB(A)]:function(){return I.apply(this,arguments)}})[A]}var AZ=(A,I,C)=>{if(void 0===A[I].overloadTable){var g=A[I];A[I]=function(){return A[I].overloadTable.hasOwnProperty(arguments.length)||P(`Function '${C}' called with an invalid number of arguments (${arguments.length}) - expects one of (${A[I].overloadTable})!`),A[I].overloadTable[arguments.length].apply(this,arguments)},A[I].overloadTable=[],A[I].overloadTable[g.argCount]=g}},Al=(A,C,g)=>{I.hasOwnProperty(A)?((void 0===g||void 0!==I[A].overloadTable&&void 0!==I[A].overloadTable[g])&&P(`Cannot register public name '${A}' twice`),AZ(I,A,A),I.hasOwnProperty(g)&&P(`Cannot register multiple overloads of a function with the same number of arguments (${g})!`),I[A].overloadTable[g]=C):(I[A]=C,void 0!==g&&(I[A].numArguments=g))},AY=(A,I)=>{for(var C=[],g=0;g<A;g++)C.push(W[I+4*g>>2]);return C},Ab=(A,C,g)=>{I.hasOwnProperty(A)||q(\"Replacing nonexistant public symbol\"),void 0!==I[A].overloadTable&&void 0!==g?I[A].overloadTable[g]=C:(I[A]=C,I[A].argCount=g)},Ac=(A,C,g)=>{var B=I[\"dynCall_\"+A];return g&&g.length?B.apply(null,[C].concat(g)):B.call(null,C)},AW=[],Ad=A=>{var I=AW[A];return I||(A>=AW.length&&(AW.length=A+1),AW[A]=I=i.get(A)),I},AE=(A,I,C)=>A.includes(\"j\")?Ac(A,I,C):Ad(I).apply(null,C),Am=(A,I)=>{var C=[];return function(){return C.length=0,Object.assign(C,arguments),AE(A,I,C)}},Ah=(A,I)=>{var C=(A=e(A)).includes(\"j\")?Am(A,I):Ad(I);return\"function\"!=typeof C&&P(`unknown function pointer with signature ${A}: ${I}`),C},AN=A=>{var I=Aj(A),C=e(I);return AK(I),C},AR=(A,I)=>{var C=[],g={};throw I.forEach(function A(I){if(!g[I]&&!U[I]){if(O[I]){O[I].forEach(A);return}C.push(I),g[I]=!0}}),new a(`${A}: `+C.map(AN).join([\", \"]))},Ai=(A,I,C)=>{switch(I){case 1:return C?A=>Z[A>>0]:A=>l[A>>0];case 2:return C?A=>Y[A>>1]:A=>b[A>>1];case 4:return C?A=>c[A>>2]:A=>W[A>>2];default:throw TypeError(`invalid integer width (${I}): ${A}`)}};function Aa(A){return this.fromWireType(W[A>>2])}var AV=(A,I,C,g)=>{if(!(g>0))return 0;for(var B=C,Q=C+g-1,G=0;G<A.length;++G){var Z=A.charCodeAt(G);if(Z>=55296&&Z<=57343&&(Z=65536+((1023&Z)<<10)|1023&A.charCodeAt(++G)),Z<=127){if(C>=Q)break;I[C++]=Z}else if(Z<=2047){if(C+1>=Q)break;I[C++]=192|Z>>6,I[C++]=128|63&Z}else if(Z<=65535){if(C+2>=Q)break;I[C++]=224|Z>>12,I[C++]=128|Z>>6&63,I[C++]=128|63&Z}else{if(C+3>=Q)break;I[C++]=240|Z>>18,I[C++]=128|Z>>12&63,I[C++]=128|Z>>6&63,I[C++]=128|63&Z}}return I[C]=0,C-B},Ak=(A,I,C)=>AV(A,l,I,C),AF=A=>{for(var I=0,C=0;C<A.length;++C){var g=A.charCodeAt(C);g<=127?I++:g<=2047?I+=2:g>=55296&&g<=57343?(I+=4,++C):I+=3}return I},Ay=\"undefined\"!=typeof TextDecoder?new TextDecoder(\"utf8\"):void 0,AX=(A,I,C)=>{for(var g=I+C,B=I;A[B]&&!(B>=g);)++B;if(B-I>16&&A.buffer&&Ay)return Ay.decode(A.subarray(I,B));for(var Q=\"\";I<B;){var G=A[I++];if(!(128&G)){Q+=String.fromCharCode(G);continue}var Z=63&A[I++];if((224&G)==192){Q+=String.fromCharCode((31&G)<<6|Z);continue}var l=63&A[I++];if((G=(240&G)==224?(15&G)<<12|Z<<6|l:(7&G)<<18|Z<<12|l<<6|63&A[I++])<65536)Q+=String.fromCharCode(G);else{var Y=G-65536;Q+=String.fromCharCode(55296|Y>>10,56320|1023&Y)}}return Q},Au=(A,I)=>A?AX(l,A,I):\"\",Ao=\"undefined\"!=typeof TextDecoder?new TextDecoder(\"utf-16le\"):void 0,AJ=(A,I)=>{for(var C=A,g=C>>1,B=g+I/2;!(g>=B)&&b[g];)++g;if((C=g<<1)-A>32&&Ao)return Ao.decode(l.subarray(A,C));for(var Q=\"\",G=0;!(G>=I/2);++G){var Z=Y[A+2*G>>1];if(0==Z)break;Q+=String.fromCharCode(Z)}return Q},Aw=(A,I,C)=>{if(void 0===C&&(C=2147483647),C<2)return 0;for(var g=I,B=(C-=2)<2*A.length?C/2:A.length,Q=0;Q<B;++Q){var G=A.charCodeAt(Q);Y[I>>1]=G,I+=2}return Y[I>>1]=0,I-g},Av=A=>2*A.length,AD=(A,I)=>{for(var C=0,g=\"\";!(C>=I/4);){var B=c[A+4*C>>2];if(0==B)break;if(++C,B>=65536){var Q=B-65536;g+=String.fromCharCode(55296|Q>>10,56320|1023&Q)}else g+=String.fromCharCode(B)}return g},Ap=(A,I,C)=>{if(void 0===C&&(C=2147483647),C<4)return 0;for(var g=I,B=g+C-4,Q=0;Q<A.length;++Q){var G=A.charCodeAt(Q);if(G>=55296&&G<=57343&&(G=65536+((1023&G)<<10)|1023&A.charCodeAt(++Q)),c[I>>2]=G,(I+=4)+4>B)break}return c[I>>2]=0,I-g},An=A=>{for(var I=0,C=0;C<A.length;++C){var g=A.charCodeAt(C);g>=55296&&g<=57343&&++C,I+=4}return I},AH=(A,I)=>{var C=U[A];return void 0===C&&P(I+\" has unknown type \"+AN(A)),C},As=()=>2147483648,At=A=>{var I=(A-G.buffer.byteLength+65535)/65536;try{return G.grow(I),v(),1}catch(A){}};(()=>{for(var A=Array(256),I=0;I<256;++I)A[I]=String.fromCharCode(I);h=A})(),N=I.BindingError=class extends Error{constructor(A){super(A),this.name=\"BindingError\"}},R=I.InternalError=class extends Error{constructor(A){super(A),this.name=\"InternalError\"}},Object.assign(_.prototype,{get(A){return this.allocated[A]},has(A){return void 0!==this.allocated[A]},allocate(A){var I=this.freelist.pop()||this.allocated.length;return this.allocated[I]=A,I},free(A){this.allocated[A]=void 0,this.freelist.push(A)}}),$.allocated.push({value:void 0},{value:null},{value:!0},{value:!1}),$.reserved=$.allocated.length,I.count_emval_handles=()=>{for(var A=0,I=$.reserved;I<$.allocated.length;++I)void 0!==$.allocated[I]&&++A;return A},a=I.UnboundTypeError=(F=Error,(X=AG(y=\"UnboundTypeError\",function(A){this.name=y,this.message=A;var I=Error(A).stack;void 0!==I&&(this.stack=this.toString()+\"\\n\"+I.replace(/^Error(:[^\\n]*)?\\n/,\"\"))})).prototype=Object.create(F.prototype),X.prototype.constructor=X,X.prototype.toString=function(){return void 0===this.message?this.name:`${this.name}: ${this.message}`},X);var AL={f:(A,I,C)=>{throw new j(A).init(I,C),x=A,M++,x},m:(A,I,C,g,B)=>{},i:(A,I,C,g)=>{f(A,{name:I=e(I),fromWireType:function(A){return!!A},toWireType:function(A,I){return I?C:g},argPackAdvance:8,readValueFromPointer:function(A){return this.fromWireType(l[A])},destructorFunction:null})},p:(A,I)=>{f(A,{name:I=e(I),fromWireType:A=>{var I=AI.toValue(A);return AA(A),I},toWireType:(A,I)=>AI.toHandle(I),argPackAdvance:8,readValueFromPointer:AC,destructorFunction:null})},e:(A,I,C)=>{f(A,{name:I=e(I),fromWireType:A=>A,toWireType:(A,I)=>I,argPackAdvance:8,readValueFromPointer:Ag(I,C),destructorFunction:null})},h:(A,I,C,g,B,Q,G)=>{var Z=AY(I,C);A=e(A),B=Ah(g,B),Al(A,function(){AR(`Cannot call ${A} due to unbound types`,Z)},I-1),T([],Z,function(C){return Ab(A,function(A,I,C,g,B,Q){var G=I.length;G<2&&P(\"argTypes array size mismatch! Must at least get return value and 'this' types!\");for(var Z=null!==I[1]&&!1,l=!1,Y=1;Y<I.length;++Y)if(null!==I[Y]&&void 0===I[Y].destructorFunction){l=!0;break}for(var b=\"void\"!==I[0].name,c=\"\",W=\"\",Y=0;Y<G-2;++Y)c+=(0!==Y?\", \":\"\")+\"arg\"+Y,W+=(0!==Y?\", \":\"\")+\"arg\"+Y+\"Wired\";var d=`\n        return function ${AB(A)}(${c}) {\n        if (arguments.length !== ${G-2}) {\n          throwBindingError('function ${A} called with ' + arguments.length + ' arguments, expected ${G-2}');\n        }`;l&&(d+=\"var destructors = [];\\n\");var E=l?\"destructors\":\"null\",m=[\"throwBindingError\",\"invoker\",\"fn\",\"runDestructors\",\"retType\",\"classParam\"],h=[P,g,B,AQ,I[0],I[1]];Z&&(d+=\"var thisWired = classParam.toWireType(\"+E+\", this);\\n\");for(var Y=0;Y<G-2;++Y)d+=\"var arg\"+Y+\"Wired = argType\"+Y+\".toWireType(\"+E+\", arg\"+Y+\"); // \"+I[Y+2].name+\"\\n\",m.push(\"argType\"+Y),h.push(I[Y+2]);if(Z&&(W=\"thisWired\"+(W.length>0?\", \":\"\")+W),d+=(b||Q?\"var rv = \":\"\")+\"invoker(fn\"+(W.length>0?\", \":\"\")+W+\");\\n\",l)d+=\"runDestructors(destructors);\\n\";else for(var Y=Z?1:2;Y<I.length;++Y){var N=1===Y?\"thisWired\":\"arg\"+(Y-2)+\"Wired\";null!==I[Y].destructorFunction&&(d+=N+\"_dtor(\"+N+\"); // \"+I[Y].name+\"\\n\",m.push(N+\"_dtor\"),h.push(I[Y].destructorFunction))}return b&&(d+=\"var ret = retType.fromWireType(rv);\\nreturn ret;\\n\"),d+=\"}\\n\",m.push(d),(function(A,I){if(!(A instanceof Function))throw TypeError(`new_ called with constructor type ${typeof A} which is not a function`);var C=AG(A.name||\"unknownFunctionName\",function(){});C.prototype=A.prototype;var g=new C,B=A.apply(g,I);return B instanceof Object?B:g})(Function,m).apply(null,h)}(A,[C[0],null].concat(C.slice(1)),0,B,Q,G),I-1),[]})},b:(A,I,C,g,B)=>{I=e(I),-1===B&&(B=4294967295);var Q=A=>A;if(0===g){var G=32-8*C;Q=A=>A<<G>>>G}var Z=I.includes(\"unsigned\"),l=(A,I)=>{};f(A,{name:I,fromWireType:Q,toWireType:Z?function(A,I){return l(I,this.name),I>>>0}:function(A,I){return l(I,this.name),I},argPackAdvance:8,readValueFromPointer:Ai(I,C,0!==g),destructorFunction:null})},a:(A,I,C)=>{var g=[Int8Array,Uint8Array,Int16Array,Uint16Array,Int32Array,Uint32Array,Float32Array,Float64Array][I];function B(A){var I=W[A>>2],C=W[A+4>>2];return new g(Z.buffer,C,I)}f(A,{name:C=e(C),fromWireType:B,argPackAdvance:8,readValueFromPointer:B},{ignoreDuplicateRegistrations:!0})},d:(A,I)=>{var C=\"std::string\"===(I=e(I));f(A,{name:I,fromWireType(A){var I,g=W[A>>2],B=A+4;if(C)for(var Q=B,G=0;G<=g;++G){var Z=B+G;if(G==g||0==l[Z]){var Y=Z-Q,b=Au(Q,Y);void 0===I?I=b:I+=\"\\x00\"+b,Q=Z+1}}else{for(var c=Array(g),G=0;G<g;++G)c[G]=String.fromCharCode(l[B+G]);I=c.join(\"\")}return AK(A),I},toWireType(A,I){I instanceof ArrayBuffer&&(I=new Uint8Array(I));var g,B=\"string\"==typeof I;B||I instanceof Uint8Array||I instanceof Uint8ClampedArray||I instanceof Int8Array||P(\"Cannot pass non-string to std::string\"),g=C&&B?AF(I):I.length;var Q=Az(4+g+1),G=Q+4;if(W[Q>>2]=g,C&&B)Ak(I,G,g+1);else if(B)for(var Z=0;Z<g;++Z){var Y=I.charCodeAt(Z);Y>255&&(AK(G),P(\"String has UTF-16 code units that do not fit in 8 bits\")),l[G+Z]=Y}else for(var Z=0;Z<g;++Z)l[G+Z]=I[Z];return null!==A&&A.push(AK,Q),Q},argPackAdvance:8,readValueFromPointer:Aa,destructorFunction(A){AK(A)}})},c:(A,I,C)=>{var g,B,Q,G,Z;C=e(C),2===I?(g=AJ,B=Aw,G=Av,Q=()=>b,Z=1):4===I&&(g=AD,B=Ap,G=An,Q=()=>W,Z=2),f(A,{name:C,fromWireType:A=>{for(var C,B=W[A>>2],G=Q(),l=A+4,Y=0;Y<=B;++Y){var b=A+4+Y*I;if(Y==B||0==G[b>>Z]){var c=b-l,d=g(l,c);void 0===C?C=d:C+=\"\\x00\"+d,l=b+I}}return AK(A),C},toWireType:(A,g)=>{\"string\"!=typeof g&&P(`Cannot pass non-string to C++ string type ${C}`);var Q=G(g),l=Az(4+Q+I);return W[l>>2]=Q>>Z,B(g,l+4,Q+I),null!==A&&A.push(AK,l),l},argPackAdvance:8,readValueFromPointer:AC,destructorFunction(A){AK(A)}})},j:(A,I)=>{f(A,{isVoid:!0,name:I=e(I),argPackAdvance:0,fromWireType:()=>void 0,toWireType:(A,I)=>void 0})},k:AA,l:A=>{A>4&&($.get(A).refcount+=1)},q:(A,I)=>{var C=(A=AH(A,\"_emval_take_value\")).readValueFromPointer(I);return AI.toHandle(C)},g:()=>{L(\"\")},o:(A,I,C)=>l.copyWithin(A,I,I+C),n:A=>{var I=l.length;A>>>=0;var C=As();if(A>C)return!1;for(var g=(A,I)=>A+(I-A%I)%I,B=1;B<=4;B*=2){var Q=I*(1+.2/B);if(Q=Math.min(Q,A+100663296),At(Math.min(C,g(Math.max(A,Q),65536))))return!0}return!1}},AS=function(){var A,C={a:AL};function Z(A,C){var g;return G=(AS=A.exports).r,v(),i=AS.t,g=AS.s,p.unshift(g),function(A){if(H--,I.monitorRunDependencies&&I.monitorRunDependencies(H),0==H&&(null!==s&&(clearInterval(s),s=null),t)){var C=t;t=null,C()}}(0),AS}if(H++,I.monitorRunDependencies&&I.monitorRunDependencies(H),I.instantiateWasm)try{return I.instantiateWasm(C,Z)}catch(A){J(`Module.instantiateWasm callback failed with error: ${A}`),g(A)}return(A=m,Promise.resolve().then(()=>(function(A){if(A==m&&Q)return new Uint8Array(Q);var I=function(A){if(z(A))return function(A){try{for(var I=atob(A),C=new Uint8Array(I.length),g=0;g<I.length;++g)C[g]=I.charCodeAt(g);return C}catch(A){throw Error(\"Converting base64 string to bytes failed.\")}}(A.slice(S.length))}(A);if(I)return I;if(B)return B(A);throw\"both async and sync fetching of the wasm failed\"})(A)).then(A=>WebAssembly.instantiate(A,C)).then(A=>A).then(function(A){Z(A.instance)},A=>{J(`failed to asynchronously prepare wasm: ${A}`),L(A)})).catch(g),{}}(),Az=A=>(Az=AS.u)(A),AK=A=>(AK=AS.v)(A),Aj=A=>(Aj=AS.w)(A),Ax=(I.__embind_initialize_bindings=()=>(I.__embind_initialize_bindings=AS.x)(),A=>(Ax=AS.y)(A));function AM(){!(H>0)&&(function(){if(I.preRun)for(\"function\"==typeof I.preRun&&(I.preRun=[I.preRun]);I.preRun.length;){var A;A=I.preRun.shift(),D.unshift(A)}K(D)}(),H>0||(I.setStatus?(I.setStatus(\"Running...\"),setTimeout(function(){setTimeout(function(){I.setStatus(\"\")},1),A()},1)):A()));function A(){!V&&(V=!0,I.calledRun=!0,w||(K(p),C(I),I.onRuntimeInitialized&&I.onRuntimeInitialized(),function(){if(I.postRun)for(\"function\"==typeof I.postRun&&(I.postRun=[I.postRun]);I.postRun.length;){var A;A=I.postRun.shift(),n.unshift(A)}K(n)}()))}}if(t=function A(){V||AM(),V||(t=A)},I.preInit)for(\"function\"==typeof I.preInit&&(I.preInit=[I.preInit]);I.preInit.length>0;)I.preInit.pop()();return AM(),I.ready});let C=new Promise(A=>{I({onRuntimeInitialized(){A(this)}})});/**\n * Asynchronously loads the WOFF2 module.\n *\n * @returns A promise resolving to the WOFF2 module.\n * @internal\n */async function g(){let A=await C;return new Promise(I=>{setTimeout(()=>{I(A)},0)})}async function B(A){let I=await g(),C=await I.decompress(A);if(!C)throw Error(\"Failed to decompress the font data.\");return Uint8Array.from(C)}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvd29mZjItZW5jb2Rlci9kaXN0L2RlY29tcHJlc3MuanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFBLGlFQUFpRSxFQUFFLDRCQUE0QixRQUFRLEVBQUUsc0VBQXNFLFNBQVMsbU5BQW1OLDhDQUE4QyxpTkFBaU4sU0FBUyxhQUFhLGVBQWUsZ1BBQWdQLHFDQUFxQyxjQUFjLGlHQUFpRyxzQ0FBc0MsYUFBYSxxQ0FBcUMsU0FBUyxjQUFjLHVCQUF1QixtQ0FBbUMsczFnUkFBczFnUixVQUFVLEtBQUssV0FBVyxlQUFlLGNBQWMsc0RBQXNELG1CQUFtQiwwQkFBMEIsd0JBQXdCLGlDQUFpQyxtQkFBbUIsZ0NBQWdDLHdCQUF3Qiw2QkFBNkIsNEJBQTRCLDRCQUE0Qiw0QkFBNEIsK0JBQStCLDRCQUE0Qiw4QkFBOEIsNEJBQTRCLHlCQUF5QixpRUFBaUUsbUNBQW1DLG9CQUFvQixrQ0FBa0MseUJBQXlCLG1DQUFtQyxnREFBZ0QsOEJBQThCLDRCQUE0QixrQkFBa0IsaUJBQWlCLEtBQUssY0FBYyxTQUFTLEtBQUssS0FBSyxLQUFLLE9BQU8sZUFBZSxPQUFPLGVBQWUsYUFBYSxjQUFjLFdBQVcsMERBQTBELFlBQVksV0FBVyxpQkFBaUIsc0JBQXNCLE9BQU8sRUFBRSwrQkFBK0Isa0JBQWtCLHVGQUF1RiwrQkFBK0IsR0FBRyxzQkFBc0IsbUJBQW1CLEVBQUUsc0dBQXNHLHdCQUF3QixFQUFFLGFBQWEsaUJBQWlCLEVBQUUscUVBQXFFLHlDQUF5QywyQkFBMkIsRUFBRSxVQUFVLDJDQUEyQyxXQUFXLCtCQUErQixRQUFRLGFBQWEseUNBQXlDLG1CQUFtQixpREFBaUQsS0FBSyxxRkFBcUYsVUFBVSxxQkFBcUIsbUJBQW1CLGdCQUFnQixnQkFBZ0IsMkJBQTJCLG1CQUFtQixLQUFLLGVBQWUsa0NBQWtDLGVBQWUsVUFBVSwwQkFBMEIsbUNBQW1DLDBCQUEwQixtQ0FBbUMsZ0RBQWdELEVBQUUsS0FBSyxFQUFFLElBQUksUUFBUSwrQkFBK0Isd0RB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V0FBVyx5QkFBeUIsU0FBUyxTQUFTLDBEQUEwRCxvQkFBb0IsSUFBSSxjQUFjLGlCQUFpQix1REFBdUQsd0VBQXdFLGNBQWMsS0FBSyw0Q0FBNEMsRUFBRSxRQUFRLGVBQWUsNEpBQTRKLGNBQWMsb0JBQW9CLG1FQUFtRSxnQkFBZ0IsRUFBRSxNQUFNLGdDQUFnQyxLQUFLLHNFQUFzRSxzQkFBc0IsZ0JBQWdCLFFBQVEsV0FBVyxhQUFhLG1HQUFtRyx1RUFBdUUsaUJBQWlCLEVBQUUsTUFBTSxpQ0FBaUMsS0FBSyxNQUFNLGtCQUFrQixpQkFBaUIscUVBQXFFLG1CQUFtQixtQkFBbUIsb0JBQW9CLEVBQUUsc0JBQXNCLEdBQUcsdUJBQXVCLFNBQVMsRUFBRSxFQUFFO0FBQzkvSztBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixjQUFjLHVCQUF1QixnQkFBZ0IsS0FBSyxJQUFJLEVBQUUsb0JBQW9CLHdDQUF3Qyx5REFBeUQiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL3dvZmYyLWVuY29kZXIvZGlzdC9kZWNvbXByZXNzLmpzP2M0MjMiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIEEsST0oQT1cImZpbGU6Ly8vYnVpbGQvd29mZjItZGVjb21wcmVzcy13YXNtLmpzXCIsZnVuY3Rpb24oST17fSl7SS5yZWFkeT1uZXcgUHJvbWlzZSgoQSxJKT0+e0M9QSxnPUl9KTt2YXIgQyxnLEIsUSxHLFosbCxZLGIsYyxXLGQsRSxtLGgsTixSLGksYSxWLGssRix5LFgsdT1PYmplY3QuYXNzaWduKHt9LEkpLG89XCJcIjtcInVuZGVmaW5lZFwiIT10eXBlb2YgZG9jdW1lbnQmJmRvY3VtZW50LmN1cnJlbnRTY3JpcHQmJihvPWRvY3VtZW50LmN1cnJlbnRTY3JpcHQuc3JjKSxBJiYobz1BKSxvPTAhPT1vLmluZGV4T2YoXCJibG9iOlwiKT9vLnN1YnN0cigwLG8ucmVwbGFjZSgvWz8jXS4qLyxcIlwiKS5sYXN0SW5kZXhPZihcIi9cIikrMSk6XCJcIixJLnByaW50fHxjb25zb2xlLmxvZy5iaW5kKGNvbnNvbGUpO3ZhciBKPUkucHJpbnRFcnJ8fGNvbnNvbGUuZXJyb3IuYmluZChjb25zb2xlKTtPYmplY3QuYXNzaWduKEksdSksdT1udWxsLEkuYXJndW1lbnRzJiZJLmFyZ3VtZW50cyxJLnRoaXNQcm9ncmFtJiZJLnRoaXNQcm9ncmFtLEkucXVpdCYmSS5xdWl0LEkud2FzbUJpbmFyeSYmKFE9SS53YXNtQmluYXJ5KSxJLm5vRXhpdFJ1bnRpbWUsXCJvYmplY3RcIiE9dHlwZW9mIFdlYkFzc2VtYmx5JiZMKFwibm8gbmF0aXZlIHdhc20gc3VwcG9ydCBkZXRlY3RlZFwiKTt2YXIgdz0hMTtmdW5jdGlvbiB2KCl7dmFyIEE9Ry5idWZmZXI7SS5IRUFQOD1aPW5ldyBJbnQ4QXJyYXkoQSksSS5IRUFQMTY9WT1uZXcgSW50MTZBcnJheShBKSxJLkhFQVBVOD1sPW5ldyBVaW50OEFycmF5KEEpLEkuSEVBUFUxNj1iPW5ldyBVaW50MTZBcnJheShBKSxJLkhFQVAzMj1jPW5ldyBJbnQzMkFycmF5KEEpLEkuSEVBUFUzMj1XPW5ldyBVaW50MzJBcnJheShBKSxJLkhFQVBGMzI9ZD1uZXcgRmxvYXQzMkFycmF5KEEpLEkuSEVBUEY2ND1FPW5ldyBGbG9hdDY0QXJyYXkoQSl9dmFyIEQ9W10scD1bXSxuPVtdLEg9MCxzPW51bGwsdD1udWxsO2Z1bmN0aW9uIEwoQSl7SS5vbkFib3J0JiZJLm9uQWJvcnQoQSksSihBPVwiQWJvcnRlZChcIitBK1wiKVwiKSx3PSEwLEErPVwiLiBCdWlsZCB3aXRoIC1zQVNTRVJUSU9OUyBmb3IgbW9yZSBpbmZvLlwiO3ZhciBDPW5ldyBXZWJBc3NlbWJseS5SdW50aW1lRXJyb3IoQSk7dGhyb3cgZyhDKSxDfXZhciBTPVwiZGF0YTphcHBsaWNhdGlvbi9vY3RldC1zdHJlYW07YmFzZTY0LFwiO2Z1bmN0aW9uIHooQSl7cmV0dXJuIEEuc3RhcnRzV2l0aChTKX16KG09XCJkYXRhOmFwcGxpY2F0aW9uL29jdGV0LXN0cmVhbTtiYXNlNjQsQUdGemJRRUFBQUFCYWc5Z0FYOEJmMkFDZjM4QVlBSi9md0YvWUFOL2YzOEJmMkFEZjM5L0FHQUFBR0FCZndCZ0JIOS9mMzhBWUFSL2YzOS9BWDlnQlg5L2YzOS9BR0FHZjM5L2YzOS9BR0FGZjM5L2YzOEJmMkFIZjM5L2YzOS9md0JnQkg5L2ZuNEFZQWgvZjM5L2YzOS9md0FDWnhFQllRRmhBQVFCWVFGaUFBa0JZUUZqQUFRQllRRmtBQUVCWVFGbEFBUUJZUUZtQUFRQllRRm5BQVVCWVFGb0FBd0JZUUZwQUFjQllRRnFBQUVCWVFGckFBWUJZUUZzQUFZQllRRnRBQXdCWVFGdUFBQUJZUUZ2QUFRQllRRndBQUVCWVFGeEFBSURUMDRHQUFNQ0F3TUNCZ0lBQkFRQUF3Z0JCUXNMQlFFQkJRc0FBQUVIQVFVQ0RRWUFBZ2NFQWdBR0JBNEVCZ0FGQUFZQUNBTUxBZ0VCQUFBQUFBQUtDZ2tKQndjREF3VUFBZ0VDQUFnREJRRUVCUUZ3QVNVbEJRY0JBWUFDZ0lBQ0JnZ0Jmd0ZCNEtzTUN3Y2hDQUZ5QWdBQmN3QXVBWFFCQUFGMUFCMEJkZ0FSQVhjQVZnRjRBRlVCZVFCTUNTb0JBRUVCQ3lSWlhqSmRLaW9ZWEZ0YVdGYytLaGc0T0ZRWVUwMVBVaGhPVUZFWVNoaEpHRXN4U0RFS2tzUUVUdlVMQVFkL0FrQWdBRVVOQUNBQVFRaHJJZ0lnQUVFRWF5Z0NBQ0lCUVhoeElnQnFJUVVDUUNBQlFRRnhEUUFnQVVFRGNVVU5BU0FDSUFJb0FnQWlBV3NpQWtIOHB3Z29BZ0JKRFFFZ0FDQUJhaUVBQWtBQ1FFR0FxQWdvQWdBZ0FrY0VRQ0FCUWY4QlRRUkFJQUZCQTNZaEJDQUNLQUlNSWdFZ0FpZ0NDQ0lEUmdSQVFleW5DRUhzcHdnb0FnQkJmaUFFZDNFMkFnQU1CUXNnQXlBQk5nSU1JQUVnQXpZQ0NBd0VDeUFDS0FJWUlRWWdBaUFDS0FJTUlnRkhCRUFnQWlnQ0NDSURJQUUyQWd3Z0FTQUROZ0lJREFNTElBSkJGR29pQkNnQ0FDSURSUVJBSUFJb0FoQWlBMFVOQWlBQ1FSQnFJUVFMQTBBZ0JDRUhJQU1pQVVFVWFpSUVLQUlBSWdNTkFDQUJRUkJxSVFRZ0FTZ0NFQ0lERFFBTElBZEJBRFlDQUF3Q0N5QUZLQUlFSWdGQkEzRkJBMGNOQWtIMHB3Z2dBRFlDQUNBRklBRkJmbkUyQWdRZ0FpQUFRUUZ5TmdJRUlBVWdBRFlDQUE4TFFRQWhBUXNnQmtVTkFBSkFJQUlvQWh3aUEwRUNkRUdjcWdocUlnUW9BZ0FnQWtZRVFDQUVJQUUyQWdBZ0FRMEJRZkNuQ0VId3B3Z29BZ0JCZmlBRGQzRTJBZ0FNQWdzZ0JrRVFRUlFnQmlnQ0VDQUNSaHRxSUFFMkFnQWdBVVVOQVFzZ0FTQUdOZ0lZSUFJb0FoQWlBd1JBSUFFZ0F6WUNFQ0FESUFFMkFoZ0xJQUlvQWhRaUEwVU5BQ0FCSUFNMkFoUWdBeUFCTmdJWUN5QUNJQVZQRFFBZ0JTZ0NCQ0lCUVFGeFJRMEFBa0FDUUFKQUFrQWdBVUVDY1VVRVFFR0VxQWdvQWdBZ0JVWUVRRUdFcUFnZ0FqWUNBRUg0cHdoQitLY0lLQUlBSUFCcUlnQTJBZ0FnQWlBQVFRRnlOZ0lFSUFKQmdLZ0lLQUlBUncwR1FmU25DRUVBTmdJQVFZQ29DRUVBTmdJQUR3dEJnS2dJS0FJQUlBVkdCRUJCZ0tnSUlBSTJBZ0JCOUtjSVFmU25DQ2dDQUNBQWFpSUFOZ0lBSUFJZ0FFRUJjallDQkNBQUlBSnFJQUEyQWdBUEN5QUJRWGh4SUFCcUlRQWdBVUgvQVUwRVFDQUJRUU4ySVFRZ0JTZ0NEQ0lCSUFVb0FnZ2lBMFlFUUVIc3B3aEI3S2NJS0FJQVFYNGdCSGR4TmdJQURBVUxJQU1nQVRZQ0RDQUJJQU0yQWdnTUJBc2dCU2dDR0NFR0lBVWdCU2dDRENJQlJ3UkFRZnluQ0NnQ0FCb2dCU2dDQ0NJRElBRTJBZ3dnQVNBRE5nSUlEQU1MSUFWQkZHb2lCQ2dDQUNJRFJRUkFJQVVvQWhBaUEwVU5BaUFGUVJCcUlRUUxBMEFnQkNFSElBTWlBVUVVYWlJRUtBSUFJZ01OQUNBQlFSQnFJUVFnQVNnQ0VDSUREUUFMSUFkQkFEWUNBQXdDQ3lBRklBRkJmbkUyQWdRZ0FpQUFRUUZ5TmdJRUlBQWdBbW9nQURZQ0FBd0RDMEVBSVFFTElBWkZEUUFDUUNBRktBSWNJZ05CQW5SQm5Lb0lhaUlFS0FJQUlBVkdCRUFnQkNBQk5nSUFJQUVOQVVId3B3aEI4S2NJS0FJQVFYNGdBM2R4TmdJQURBSUxJQVpCRUVFVUlBWW9BaEFnQlVZYmFpQUJOZ0lBSUFGRkRRRUxJQUVnQmpZQ0dDQUZLQUlRSWdNRVFDQUJJQU0yQWhBZ0F5QUJOZ0lZQ3lBRktBSVVJZ05GRFFBZ0FTQUROZ0lVSUFNZ0FUWUNHQXNnQWlBQVFRRnlOZ0lFSUFBZ0Ftb2dBRFlDQUNBQ1FZQ29DQ2dDQUVjTkFFSDBwd2dnQURZQ0FBOExJQUJCL3dGTkJFQWdBRUY0Y1VHVXFBaHFJUUVDZjBIc3B3Z29BZ0FpQTBFQklBQkJBM1owSWdCeFJRUkFRZXluQ0NBQUlBTnlOZ0lBSUFFTUFRc2dBU2dDQ0FzaEFDQUJJQUkyQWdnZ0FDQUNOZ0lNSUFJZ0FUWUNEQ0FDSUFBMkFnZ1BDMEVmSVFNZ0FFSC8vLzhIVFFSQUlBQkJKaUFBUVFoMlp5SUJhM1pCQVhFZ0FVRUJkR3RCUG1vaEF3c2dBaUFETmdJY0lBSkNBRGNDRUNBRFFRSjBRWnlxQ0dvaEFRSkFBa0FDUUVId3B3Z29BZ0FpQkVFQklBTjBJZ2R4UlFSQVFmQ25DQ0FFSUFkeU5nSUFJQUVnQWpZQ0FDQUNJQUUyQWhnTUFRc2dBRUVaSUFOQkFYWnJRUUFnQTBFZlJ4dDBJUU1nQVNnQ0FDRUJBMEFnQVNJRUtBSUVRWGh4SUFCR0RRSWdBMEVkZGlFQklBTkJBWFFoQXlBRUlBRkJCSEZxSWdkQkVHb29BZ0FpQVEwQUN5QUhJQUkyQWhBZ0FpQUVOZ0lZQ3lBQ0lBSTJBZ3dnQWlBQ05nSUlEQUVMSUFRb0FnZ2lBQ0FDTmdJTUlBUWdBallDQ0NBQ1FRQTJBaGdnQWlBRU5nSU1JQUlnQURZQ0NBdEJqS2dJUVl5b0NDZ0NBRUVCYXlJQVFYOGdBQnMyQWdBTEN6WUJBWDlCQVNBQUlBQkJBVTBiSVFBQ1FBTkFJQUFRSFNJQkRRRkIzS3NJS0FJQUlnRUVRQ0FCRVFVQURBRUxDeEFHQUFzZ0FRdUFCQUVEZnlBQ1FZQUVUd1JBSUFBZ0FTQUNFQTRnQUE4TElBQWdBbW9oQXdKQUlBQWdBWE5CQTNGRkJFQUNRQ0FBUVFOeFJRUkFJQUFoQWd3QkN5QUNSUVJBSUFBaEFnd0JDeUFBSVFJRFFDQUNJQUV0QUFBNkFBQWdBVUVCYWlFQklBSkJBV29pQWtFRGNVVU5BU0FDSUFOSkRRQUxDd0pBSUFOQmZIRWlCRUhBQUVrTkFDQUNJQVJCUUdvaUJVc05BQU5BSUFJZ0FTZ0NBRFlDQUNBQ0lBRW9BZ1EyQWdRZ0FpQUJLQUlJTmdJSUlBSWdBU2dDRERZQ0RDQUNJQUVvQWhBMkFoQWdBaUFCS0FJVU5nSVVJQUlnQVNnQ0dEWUNHQ0FDSUFFb0FodzJBaHdnQWlBQktBSWdOZ0lnSUFJZ0FTZ0NKRFlDSkNBQ0lBRW9BaWcyQWlnZ0FpQUJLQUlzTmdJc0lBSWdBU2dDTURZQ01DQUNJQUVvQWpRMkFqUWdBaUFCS0FJNE5nSTRJQUlnQVNnQ1BEWUNQQ0FCUVVCcklRRWdBa0ZBYXlJQ0lBVk5EUUFMQ3lBQ0lBUlBEUUVEUUNBQ0lBRW9BZ0EyQWdBZ0FVRUVhaUVCSUFKQkJHb2lBaUFFU1EwQUN3d0JDeUFEUVFSSkJFQWdBQ0VDREFFTElBQWdBMEVFYXlJRVN3UkFJQUFoQWd3QkN5QUFJUUlEUUNBQ0lBRXRBQUE2QUFBZ0FpQUJMUUFCT2dBQklBSWdBUzBBQWpvQUFpQUNJQUV0QUFNNkFBTWdBVUVFYWlFQklBSkJCR29pQWlBRVRRMEFDd3NnQWlBRFNRUkFBMEFnQWlBQkxRQUFPZ0FBSUFGQkFXb2hBU0FDUVFGcUlnSWdBMGNOQUFzTElBQUwyQUlCQW44Q1FDQUJSUTBBSUFCQkFEb0FBQ0FBSUFGcUlnSkJBV3RCQURvQUFDQUJRUU5KRFFBZ0FFRUFPZ0FDSUFCQkFEb0FBU0FDUVFOclFRQTZBQUFnQWtFQ2EwRUFPZ0FBSUFGQkIwa05BQ0FBUVFBNkFBTWdBa0VFYTBFQU9nQUFJQUZCQ1VrTkFDQUFRUUFnQUd0QkEzRWlBMm9pQWtFQU5nSUFJQUlnQVNBRGEwRjhjU0lEYWlJQlFRUnJRUUEyQWdBZ0EwRUpTUTBBSUFKQkFEWUNDQ0FDUVFBMkFnUWdBVUVJYTBFQU5nSUFJQUZCREd0QkFEWUNBQ0FEUVJsSkRRQWdBa0VBTmdJWUlBSkJBRFlDRkNBQ1FRQTJBaEFnQWtFQU5nSU1JQUZCRUd0QkFEWUNBQ0FCUVJSclFRQTJBZ0FnQVVFWWEwRUFOZ0lBSUFGQkhHdEJBRFlDQUNBRElBSkJCSEZCR0hJaUEyc2lBVUVnU1EwQUlBSWdBMm9oQWdOQUlBSkNBRGNER0NBQ1FnQTNBeEFnQWtJQU53TUlJQUpDQURjREFDQUNRU0JxSVFJZ0FVRWdheUlCUVI5TERRQUxDeUFBQzhjQkFRWi9Ba0FnQWdKL0lBRW9BZ1FpQWtFZ1JnUkFJQUF0QUFBTkFpQUFRUUpxREFFTFFTQWdBbXNoQlNBQUlBRW9BZ0FnQW5ZaUIwSC9BWEVpQmtFQ2RHb2lDQzBBQUNJRFFRaE5CRUFnQXlBRlN3MENJQUVnQWlBRGFqWUNCQ0FBSUFaQkFuUnFRUUpxREFFTElBVkJDVWtOQVNBSUlBQWdCa0VDZEdvdkFRSWdBMEVDZEVIUUdXb29BZ0FnQjNGQkNIWnFRUUowYWlJQUxRQUFJZ05CR0NBQ2Ewc05BU0FCSUFJZ0EycEJDR28yQWdRZ0FFRUNhZ3N2QVFBMkFnQkJBU0VFQ3lBRUMzUUJBWDhnQWtVRVFDQUFLQUlFSUFFb0FnUkdEd3NnQUNBQlJnUkFRUUVQQ3lBQktBSUVJZ0l0QUFBaEFRSkFJQUFvQWdRaUF5MEFBQ0lBUlEwQUlBQWdBVWNOQUFOQUlBSXRBQUVoQVNBRExRQUJJZ0JGRFFFZ0FrRUJhaUVDSUFOQkFXb2hBeUFBSUFGR0RRQUxDeUFBSUFGR0M0d0JBUVIvSUFGQmZIRWlBZ1JBQTBBZ0FDQURRUU55YWkwQUFDQUFJQU5CQVhKcUxRQUFRUkIwSUFBZ0Eyb3RBQUJCR0hSeUlBQWdBMEVDY21vdEFBQkJDSFJ5Y2lBRWFpRUVJQU5CQkdvaUF5QUNTUTBBQ3dzZ0FTQUNSd1IvQTBBZ0FDQUNhaTBBQUNBQ1FYOXpRUU4wZENBRmNpRUZJQUpCQVdvaUFpQUJTUTBBQ3lBRUlBVnFCU0FFQ3dzR0FDQUFFQkVMMHdFQkNIOENRQ0FBS0FJSUlnTkJBV29pQkNBQUtBSUVJZ1ZMRFFBZ0FDZ0NBQ0lHSUFOcUxRQUFJUUlnQUNBRU5nSUlBa0FDUUFKQUFrQWdBa0g5QVdzT0F3QUNBUU1MSUFOQkEyb2lBeUFGU3cwRElBUWdCbW92QUFBaUFrRUlkQ0FDUVFoMmNrSC8vd054SVFJZ0FDQUROZ0lJREFJTElBTkJBbW9pQWlBRlN3MENJQVFnQm1vdEFBQWhDQ0FBSUFJMkFnZ2dDRUg5QVdvaEFnd0JDeUFEUVFKcUlnSWdCVXNOQVNBRUlBWnFMUUFBSVFrZ0FDQUNOZ0lJSUFsQitnTnFJUUlMSUFFZ0FqWUNBRUVCSVFjTElBY0xVZ0VDZjBIUXB3Z29BZ0FpQVNBQVFRZHFRWGh4SWdKcUlRQUNRQ0FDUVFBZ0FDQUJUUnNOQUNBQVB3QkJFSFJMQkVBZ0FCQU5SUTBCQzBIUXB3Z2dBRFlDQUNBQkR3dEI2S2NJUVRBMkFnQkJmd3ZoQVFFRWZ5TUFRUkJySWdVa0FDTUFRU0JySWdNa0FDTUFRUkJySWdRa0FDQUVJQUUyQWd3Z0JDQUJJQUpxTmdJSUlBTWdCQ2dDRERZQ0dDQURJQVFvQWdnMkFod2dCRUVRYWlRQUlBTW9BaGdoQkNBREtBSWNJUVlqQUVFUWF5SUNKQUFnQWlBR05nSU1JQUlnQUNBRUlBWWdCR3NpQkJBZUlBUnFOZ0lJSUFNZ0FpZ0NERFlDRUNBRElBSW9BZ2cyQWhRZ0FrRVFhaVFBSUFNZ0FTQURLQUlRSUFGcmFqWUNEQ0FESUFBZ0F5Z0NGQ0FBYTJvMkFnZ2dCU0FES0FJTU5nSUlJQVVnQXlnQ0NEWUNEQ0FEUVNCcUpBQWdCU2dDREJvZ0JVRVFhaVFBQ3dzQUlBQWdBU0FDRUI0YUM4Z29BUXgvSXdCQkVHc2lDaVFBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUNBQVFmUUJUUVJBUWV5bkNDZ0NBQ0lHUVJBZ0FFRUxha0Y0Y1NBQVFRdEpHeUlGUVFOMklnQjJJZ0ZCQTNFRVFBSkFJQUZCZjNOQkFYRWdBR29pQWtFRGRDSUJRWlNvQ0dvaUFDQUJRWnlvQ0dvb0FnQWlBU2dDQ0NJRVJnUkFRZXluQ0NBR1FYNGdBbmR4TmdJQURBRUxJQVFnQURZQ0RDQUFJQVEyQWdnTElBRkJDR29oQUNBQklBSkJBM1FpQWtFRGNqWUNCQ0FCSUFKcUlnRWdBU2dDQkVFQmNqWUNCQXdQQ3lBRlFmU25DQ2dDQUNJSFRRMEJJQUVFUUFKQVFRSWdBSFFpQWtFQUlBSnJjaUFCSUFCMGNXZ2lBVUVEZENJQVFaU29DR29pQWlBQVFaeW9DR29vQWdBaUFDZ0NDQ0lFUmdSQVFleW5DQ0FHUVg0Z0FYZHhJZ1kyQWdBTUFRc2dCQ0FDTmdJTUlBSWdCRFlDQ0FzZ0FDQUZRUU55TmdJRUlBQWdCV29pQ0NBQlFRTjBJZ0VnQldzaUJFRUJjallDQkNBQUlBRnFJQVEyQWdBZ0J3UkFJQWRCZUhGQmxLZ0lhaUVCUVlDb0NDZ0NBQ0VDQW44Z0JrRUJJQWRCQTNaMElnTnhSUVJBUWV5bkNDQURJQVp5TmdJQUlBRU1BUXNnQVNnQ0NBc2hBeUFCSUFJMkFnZ2dBeUFDTmdJTUlBSWdBVFlDRENBQ0lBTTJBZ2dMSUFCQkNHb2hBRUdBcUFnZ0NEWUNBRUgwcHdnZ0JEWUNBQXdQQzBId3B3Z29BZ0FpQzBVTkFTQUxhRUVDZEVHY3FnaHFLQUlBSWdJb0FnUkJlSEVnQldzaEF5QUNJUUVEUUFKQUlBRW9BaEFpQUVVRVFDQUJLQUlVSWdCRkRRRUxJQUFvQWdSQmVIRWdCV3NpQVNBRElBRWdBMGtpQVJzaEF5QUFJQUlnQVJzaEFpQUFJUUVNQVFzTElBSW9BaGdoQ1NBQ0lBSW9BZ3dpQkVjRVFFSDhwd2dvQWdBYUlBSW9BZ2dpQUNBRU5nSU1JQVFnQURZQ0NBd09DeUFDUVJScUlnRW9BZ0FpQUVVRVFDQUNLQUlRSWdCRkRRTWdBa0VRYWlFQkN3TkFJQUVoQ0NBQUlnUkJGR29pQVNnQ0FDSUFEUUFnQkVFUWFpRUJJQVFvQWhBaUFBMEFDeUFJUVFBMkFnQU1EUXRCZnlFRklBQkJ2MzlMRFFBZ0FFRUxhaUlBUVhoeElRVkI4S2NJS0FJQUlnaEZEUUJCQUNBRmF5RURBa0FDUUFKQUFuOUJBQ0FGUVlBQ1NRMEFHa0VmSUFWQi8vLy9CMHNOQUJvZ0JVRW1JQUJCQ0habklnQnJka0VCY1NBQVFRRjBhMEUrYWdzaUIwRUNkRUdjcWdocUtBSUFJZ0ZGQkVCQkFDRUFEQUVMUVFBaEFDQUZRUmtnQjBFQmRtdEJBQ0FIUVI5SEczUWhBZ05BQWtBZ0FTZ0NCRUY0Y1NBRmF5SUdJQU5QRFFBZ0FTRUVJQVlpQXcwQVFRQWhBeUFCSVFBTUF3c2dBQ0FCS0FJVUlnWWdCaUFCSUFKQkhYWkJCSEZxS0FJUUlnRkdHeUFBSUFZYklRQWdBa0VCZENFQ0lBRU5BQXNMSUFBZ0JISkZCRUJCQUNFRVFRSWdCM1FpQUVFQUlBQnJjaUFJY1NJQVJRMERJQUJvUVFKMFFaeXFDR29vQWdBaEFBc2dBRVVOQVFzRFFDQUFLQUlFUVhoeElBVnJJZ0lnQTBraEFTQUNJQU1nQVJzaEF5QUFJQVFnQVJzaEJDQUFLQUlRSWdFRWZ5QUJCU0FBS0FJVUN5SUFEUUFMQ3lBRVJRMEFJQU5COUtjSUtBSUFJQVZyVHcwQUlBUW9BaGdoQnlBRUlBUW9BZ3dpQWtjRVFFSDhwd2dvQWdBYUlBUW9BZ2dpQUNBQ05nSU1JQUlnQURZQ0NBd01DeUFFUVJScUlnRW9BZ0FpQUVVRVFDQUVLQUlRSWdCRkRRTWdCRUVRYWlFQkN3TkFJQUVoQmlBQUlnSkJGR29pQVNnQ0FDSUFEUUFnQWtFUWFpRUJJQUlvQWhBaUFBMEFDeUFHUVFBMkFnQU1Dd3NnQlVIMHB3Z29BZ0FpQkUwRVFFR0FxQWdvQWdBaEFBSkFJQVFnQldzaUFVRVFUd1JBSUFBZ0JXb2lBaUFCUVFGeU5nSUVJQUFnQkdvZ0FUWUNBQ0FBSUFWQkEzSTJBZ1FNQVFzZ0FDQUVRUU55TmdJRUlBQWdCR29pQVNBQktBSUVRUUZ5TmdJRVFRQWhBa0VBSVFFTFFmU25DQ0FCTmdJQVFZQ29DQ0FDTmdJQUlBQkJDR29oQUF3TkN5QUZRZmluQ0NnQ0FDSUNTUVJBUWZpbkNDQUNJQVZySWdFMkFnQkJoS2dJUVlTb0NDZ0NBQ0lBSUFWcUlnSTJBZ0FnQWlBQlFRRnlOZ0lFSUFBZ0JVRURjallDQkNBQVFRaHFJUUFNRFF0QkFDRUFJQVZCTDJvaUF3Si9RY1NyQ0NnQ0FBUkFRY3lyQ0NnQ0FBd0JDMEhRcXdoQ2Z6Y0NBRUhJcXdoQ2dLQ0FnSUNBQkRjQ0FFSEVxd2dnQ2tFTWFrRndjVUhZcXRXcUJYTTJBZ0JCMktzSVFRQTJBZ0JCcUtzSVFRQTJBZ0JCZ0NBTElnRnFJZ1pCQUNBQmF5SUljU0lCSUFWTkRReEJwS3NJS0FJQUlnUUVRRUdjcXdnb0FnQWlCeUFCYWlJSklBZE5EUTBnQkNBSlNRME5Dd0pBUWFpckNDMEFBRUVFY1VVRVFBSkFBa0FDUUFKQVFZU29DQ2dDQUNJRUJFQkJyS3NJSVFBRFFDQUVJQUFvQWdBaUIwOEVRQ0FISUFBb0FnUnFJQVJMRFFNTElBQW9BZ2dpQUEwQUN3dEJBQkFhSWdKQmYwWU5BeUFCSVFaQnlLc0lLQUlBSWdCQkFXc2lCQ0FDY1FSQUlBRWdBbXNnQWlBRWFrRUFJQUJyY1dvaEJnc2dCU0FHVHcwRFFhU3JDQ2dDQUNJQUJFQkJuS3NJS0FJQUlnUWdCbW9pQ0NBRVRRMEVJQUFnQ0VrTkJBc2dCaEFhSWdBZ0FrY05BUXdGQ3lBR0lBSnJJQWh4SWdZUUdpSUNJQUFvQWdBZ0FDZ0NCR3BHRFFFZ0FpRUFDeUFBUVg5R0RRRWdCVUV3YWlBR1RRUkFJQUFoQWd3RUMwSE1xd2dvQWdBaUFpQURJQVpyYWtFQUlBSnJjU0lDRUJwQmYwWU5BU0FDSUFacUlRWWdBQ0VDREFNTElBSkJmMGNOQWd0QnFLc0lRYWlyQ0NnQ0FFRUVjallDQUFzZ0FSQWFJUUpCQUJBYUlRQWdBa0YvUmcwRklBQkJmMFlOQlNBQUlBSk5EUVVnQUNBQ2F5SUdJQVZCS0dwTkRRVUxRWnlyQ0VHY3F3Z29BZ0FnQm1vaUFEWUNBRUdncXdnb0FnQWdBRWtFUUVHZ3F3Z2dBRFlDQUFzQ1FFR0VxQWdvQWdBaUF3UkFRYXlyQ0NFQUEwQWdBaUFBS0FJQUlnRWdBQ2dDQkNJRWFrWU5BaUFBS0FJSUlnQU5BQXNNQkF0Qi9LY0lLQUlBSWdCQkFDQUFJQUpORzBVRVFFSDhwd2dnQWpZQ0FBdEJBQ0VBUWJDckNDQUdOZ0lBUWF5ckNDQUNOZ0lBUVl5b0NFRi9OZ0lBUVpDb0NFSEVxd2dvQWdBMkFnQkJ1S3NJUVFBMkFnQURRQ0FBUVFOMElnRkJuS2dJYWlBQlFaU29DR29pQkRZQ0FDQUJRYUNvQ0dvZ0JEWUNBQ0FBUVFGcUlnQkJJRWNOQUF0QitLY0lJQVpCS0dzaUFFRjRJQUpyUVFkeElnRnJJZ1EyQWdCQmhLZ0lJQUVnQW1vaUFUWUNBQ0FCSUFSQkFYSTJBZ1FnQUNBQ2FrRW9OZ0lFUVlpb0NFSFVxd2dvQWdBMkFnQU1CQXNnQWlBRFRRMENJQUVnQTBzTkFpQUFLQUlNUVFoeERRSWdBQ0FFSUFacU5nSUVRWVNvQ0NBRFFYZ2dBMnRCQjNFaUFHb2lBVFlDQUVINHB3aEIrS2NJS0FJQUlBWnFJZ0lnQUdzaUFEWUNBQ0FCSUFCQkFYSTJBZ1FnQWlBRGFrRW9OZ0lFUVlpb0NFSFVxd2dvQWdBMkFnQU1Bd3RCQUNFRURBb0xRUUFoQWd3SUMwSDhwd2dvQWdBZ0Frc0VRRUg4cHdnZ0FqWUNBQXNnQWlBR2FpRUJRYXlyQ0NFQUFrQUNRQUpBQTBBZ0FTQUFLQUlBUndSQUlBQW9BZ2dpQUEwQkRBSUxDeUFBTFFBTVFRaHhSUTBCQzBHc3F3Z2hBQU5BSUFNZ0FDZ0NBQ0lCVHdSQUlBRWdBQ2dDQkdvaUJDQURTdzBEQ3lBQUtBSUlJUUFNQUFzQUN5QUFJQUkyQWdBZ0FDQUFLQUlFSUFacU5nSUVJQUpCZUNBQ2EwRUhjV29pQnlBRlFRTnlOZ0lFSUFGQmVDQUJhMEVIY1dvaUJpQUZJQWRxSWdWcklRQWdBeUFHUmdSQVFZU29DQ0FGTmdJQVFmaW5DRUg0cHdnb0FnQWdBR29pQURZQ0FDQUZJQUJCQVhJMkFnUU1DQXRCZ0tnSUtBSUFJQVpHQkVCQmdLZ0lJQVUyQWdCQjlLY0lRZlNuQ0NnQ0FDQUFhaUlBTmdJQUlBVWdBRUVCY2pZQ0JDQUFJQVZxSUFBMkFnQU1DQXNnQmlnQ0JDSURRUU54UVFGSERRWWdBMEY0Y1NFSklBTkIvd0ZOQkVBZ0JpZ0NEQ0lCSUFZb0FnZ2lBa1lFUUVIc3B3aEI3S2NJS0FJQVFYNGdBMEVEZG5keE5nSUFEQWNMSUFJZ0FUWUNEQ0FCSUFJMkFnZ01CZ3NnQmlnQ0dDRUlJQVlnQmlnQ0RDSUNSd1JBSUFZb0FnZ2lBU0FDTmdJTUlBSWdBVFlDQ0F3RkN5QUdRUlJxSWdFb0FnQWlBMFVFUUNBR0tBSVFJZ05GRFFRZ0JrRVFhaUVCQ3dOQUlBRWhCQ0FESWdKQkZHb2lBU2dDQUNJRERRQWdBa0VRYWlFQklBSW9BaEFpQXcwQUN5QUVRUUEyQWdBTUJBdEIrS2NJSUFaQktHc2lBRUY0SUFKclFRZHhJZ0ZySWdnMkFnQkJoS2dJSUFFZ0Ftb2lBVFlDQUNBQklBaEJBWEkyQWdRZ0FDQUNha0VvTmdJRVFZaW9DRUhVcXdnb0FnQTJBZ0FnQXlBRVFTY2dCR3RCQjNGcVFTOXJJZ0FnQUNBRFFSQnFTUnNpQVVFYk5nSUVJQUZCdEtzSUtRSUFOd0lRSUFGQnJLc0lLUUlBTndJSVFiU3JDQ0FCUVFocU5nSUFRYkNyQ0NBR05nSUFRYXlyQ0NBQ05nSUFRYmlyQ0VFQU5nSUFJQUZCR0dvaEFBTkFJQUJCQnpZQ0JDQUFRUWhxSVF3Z0FFRUVhaUVBSUF3Z0JFa05BQXNnQVNBRFJnMEFJQUVnQVNnQ0JFRitjVFlDQkNBRElBRWdBMnNpQWtFQmNqWUNCQ0FCSUFJMkFnQWdBa0gvQVUwRVFDQUNRWGh4UVpTb0NHb2hBQUovUWV5bkNDZ0NBQ0lCUVFFZ0FrRURkblFpQW5GRkJFQkI3S2NJSUFFZ0FuSTJBZ0FnQUF3QkN5QUFLQUlJQ3lFQklBQWdBellDQ0NBQklBTTJBZ3dnQXlBQU5nSU1JQU1nQVRZQ0NBd0JDMEVmSVFBZ0FrSC8vLzhIVFFSQUlBSkJKaUFDUVFoMlp5SUFhM1pCQVhFZ0FFRUJkR3RCUG1vaEFBc2dBeUFBTmdJY0lBTkNBRGNDRUNBQVFRSjBRWnlxQ0dvaEFRSkFBa0JCOEtjSUtBSUFJZ1JCQVNBQWRDSUdjVVVFUUVId3B3Z2dCQ0FHY2pZQ0FDQUJJQU0yQWdBTUFRc2dBa0VaSUFCQkFYWnJRUUFnQUVFZlJ4dDBJUUFnQVNnQ0FDRUVBMEFnQkNJQktBSUVRWGh4SUFKR0RRSWdBRUVkZGlFRUlBQkJBWFFoQUNBQklBUkJCSEZxSWdZb0FoQWlCQTBBQ3lBR0lBTTJBaEFMSUFNZ0FUWUNHQ0FESUFNMkFnd2dBeUFETmdJSURBRUxJQUVvQWdnaUFDQUROZ0lNSUFFZ0F6WUNDQ0FEUVFBMkFoZ2dBeUFCTmdJTUlBTWdBRFlDQ0F0QitLY0lLQUlBSWdBZ0JVME5BRUg0cHdnZ0FDQUZheUlCTmdJQVFZU29DRUdFcUFnb0FnQWlBQ0FGYWlJQ05nSUFJQUlnQVVFQmNqWUNCQ0FBSUFWQkEzSTJBZ1FnQUVFSWFpRUFEQWdMUWVpbkNFRXdOZ0lBUVFBaEFBd0hDMEVBSVFJTElBaEZEUUFDUUNBR0tBSWNJZ0ZCQW5SQm5Lb0lhaUlFS0FJQUlBWkdCRUFnQkNBQ05nSUFJQUlOQVVId3B3aEI4S2NJS0FJQVFYNGdBWGR4TmdJQURBSUxJQWhCRUVFVUlBZ29BaEFnQmtZYmFpQUNOZ0lBSUFKRkRRRUxJQUlnQ0RZQ0dDQUdLQUlRSWdFRVFDQUNJQUUyQWhBZ0FTQUNOZ0lZQ3lBR0tBSVVJZ0ZGRFFBZ0FpQUJOZ0lVSUFFZ0FqWUNHQXNnQUNBSmFpRUFJQVlnQ1dvaUJpZ0NCQ0VEQ3lBR0lBTkJmbkUyQWdRZ0JTQUFRUUZ5TmdJRUlBQWdCV29nQURZQ0FDQUFRZjhCVFFSQUlBQkJlSEZCbEtnSWFpRUJBbjlCN0tjSUtBSUFJZ0pCQVNBQVFRTjJkQ0lBY1VVRVFFSHNwd2dnQUNBQ2NqWUNBQ0FCREFFTElBRW9BZ2dMSVFBZ0FTQUZOZ0lJSUFBZ0JUWUNEQ0FGSUFFMkFnd2dCU0FBTmdJSURBRUxRUjhoQXlBQVFmLy8vd2ROQkVBZ0FFRW1JQUJCQ0habklnRnJka0VCY1NBQlFRRjBhMEUrYWlFREN5QUZJQU0yQWh3Z0JVSUFOd0lRSUFOQkFuUkJuS29JYWlFQkFrQUNRRUh3cHdnb0FnQWlBa0VCSUFOMElnUnhSUVJBUWZDbkNDQUNJQVJ5TmdJQUlBRWdCVFlDQUF3QkN5QUFRUmtnQTBFQmRtdEJBQ0FEUVI5SEczUWhBeUFCS0FJQUlRSURRQ0FDSWdFb0FnUkJlSEVnQUVZTkFpQURRUjEySVFJZ0EwRUJkQ0VESUFFZ0FrRUVjV29pQkNnQ0VDSUNEUUFMSUFRZ0JUWUNFQXNnQlNBQk5nSVlJQVVnQlRZQ0RDQUZJQVUyQWdnTUFRc2dBU2dDQ0NJQUlBVTJBZ3dnQVNBRk5nSUlJQVZCQURZQ0dDQUZJQUUyQWd3Z0JTQUFOZ0lJQ3lBSFFRaHFJUUFNQWdzQ1FDQUhSUTBBQWtBZ0JDZ0NIQ0lBUVFKMFFaeXFDR29pQVNnQ0FDQUVSZ1JBSUFFZ0FqWUNBQ0FDRFFGQjhLY0lJQWhCZmlBQWQzRWlDRFlDQUF3Q0N5QUhRUkJCRkNBSEtBSVFJQVJHRzJvZ0FqWUNBQ0FDUlEwQkN5QUNJQWMyQWhnZ0JDZ0NFQ0lBQkVBZ0FpQUFOZ0lRSUFBZ0FqWUNHQXNnQkNnQ0ZDSUFSUTBBSUFJZ0FEWUNGQ0FBSUFJMkFoZ0xBa0FnQTBFUFRRUkFJQVFnQXlBRmFpSUFRUU55TmdJRUlBQWdCR29pQUNBQUtBSUVRUUZ5TmdJRURBRUxJQVFnQlVFRGNqWUNCQ0FFSUFWcUlnSWdBMEVCY2pZQ0JDQUNJQU5xSUFNMkFnQWdBMEgvQVUwRVFDQURRWGh4UVpTb0NHb2hBQUovUWV5bkNDZ0NBQ0lCUVFFZ0EwRURkblFpQTNGRkJFQkI3S2NJSUFFZ0EzSTJBZ0FnQUF3QkN5QUFLQUlJQ3lFQklBQWdBallDQ0NBQklBSTJBZ3dnQWlBQU5nSU1JQUlnQVRZQ0NBd0JDMEVmSVFBZ0EwSC8vLzhIVFFSQUlBTkJKaUFEUVFoMlp5SUFhM1pCQVhFZ0FFRUJkR3RCUG1vaEFBc2dBaUFBTmdJY0lBSkNBRGNDRUNBQVFRSjBRWnlxQ0dvaEFRSkFBa0FnQ0VFQklBQjBJZ1p4UlFSQVFmQ25DQ0FHSUFoeU5nSUFJQUVnQWpZQ0FBd0JDeUFEUVJrZ0FFRUJkbXRCQUNBQVFSOUhHM1FoQUNBQktBSUFJUVVEUUNBRklnRW9BZ1JCZUhFZ0EwWU5BaUFBUVIxMklRWWdBRUVCZENFQUlBRWdCa0VFY1dvaUJpZ0NFQ0lGRFFBTElBWWdBallDRUFzZ0FpQUJOZ0lZSUFJZ0FqWUNEQ0FDSUFJMkFnZ01BUXNnQVNnQ0NDSUFJQUkyQWd3Z0FTQUNOZ0lJSUFKQkFEWUNHQ0FDSUFFMkFnd2dBaUFBTmdJSUN5QUVRUWhxSVFBTUFRc0NRQ0FKUlEwQUFrQWdBaWdDSENJQVFRSjBRWnlxQ0dvaUFTZ0NBQ0FDUmdSQUlBRWdCRFlDQUNBRURRRkI4S2NJSUF0QmZpQUFkM0UyQWdBTUFnc2dDVUVRUVJRZ0NTZ0NFQ0FDUmh0cUlBUTJBZ0FnQkVVTkFRc2dCQ0FKTmdJWUlBSW9BaEFpQUFSQUlBUWdBRFlDRUNBQUlBUTJBaGdMSUFJb0FoUWlBRVVOQUNBRUlBQTJBaFFnQUNBRU5nSVlDd0pBSUFOQkQwMEVRQ0FDSUFNZ0JXb2lBRUVEY2pZQ0JDQUFJQUpxSWdBZ0FDZ0NCRUVCY2pZQ0JBd0JDeUFDSUFWQkEzSTJBZ1FnQWlBRmFpSUVJQU5CQVhJMkFnUWdBeUFFYWlBRE5nSUFJQWNFUUNBSFFYaHhRWlNvQ0dvaEFFR0FxQWdvQWdBaEFRSi9RUUVnQjBFRGRuUWlCU0FHY1VVRVFFSHNwd2dnQlNBR2NqWUNBQ0FBREFFTElBQW9BZ2dMSVFZZ0FDQUJOZ0lJSUFZZ0FUWUNEQ0FCSUFBMkFnd2dBU0FHTmdJSUMwR0FxQWdnQkRZQ0FFSDBwd2dnQXpZQ0FBc2dBa0VJYWlFQUN5QUtRUkJxSkFBZ0FBdm9BZ0VDZndKQUlBQWdBVVlOQUNBQklBQWdBbW9pQkd0QkFDQUNRUUYwYTAwRVFDQUFJQUVnQWhBVER3c2dBQ0FCYzBFRGNTRURBa0FDUUNBQUlBRkpCRUFnQXdSQUlBQWhBd3dEQ3lBQVFRTnhSUVJBSUFBaEF3d0NDeUFBSVFNRFFDQUNSUTBFSUFNZ0FTMEFBRG9BQUNBQlFRRnFJUUVnQWtFQmF5RUNJQU5CQVdvaUEwRURjUTBBQ3d3QkN3SkFJQU1OQUNBRVFRTnhCRUFEUUNBQ1JRMEZJQUFnQWtFQmF5SUNhaUlESUFFZ0Ftb3RBQUE2QUFBZ0EwRURjUTBBQ3dzZ0FrRURUUTBBQTBBZ0FDQUNRUVJySWdKcUlBRWdBbW9vQWdBMkFnQWdBa0VEU3cwQUN3c2dBa1VOQWdOQUlBQWdBa0VCYXlJQ2FpQUJJQUpxTFFBQU9nQUFJQUlOQUFzTUFnc2dBa0VEVFEwQUEwQWdBeUFCS0FJQU5nSUFJQUZCQkdvaEFTQURRUVJxSVFNZ0FrRUVheUlDUVFOTERRQUxDeUFDUlEwQUEwQWdBeUFCTFFBQU9nQUFJQU5CQVdvaEF5QUJRUUZxSVFFZ0FrRUJheUlDRFFBTEN5QUFDK0lJQVFOL0l3QkJJR3NoQkNBQ0tBSUFJUVVDZndKQUlBRW9BZ0FpQmlBQUtBSUFUd1JBUVFBZ0JTQUdUdzBDR2lBRUlBRXBBaGczQXhnZ0JDQUJLUUlRTndNUUlBUWdBU2tDQ0RjRENDQUVJQUVwQWdBM0F3QWdBU0FDS1FJWU53SVlJQUVnQWlrQ0VEY0NFQ0FCSUFJcEFnZzNBZ2dnQVNBQ0tRSUFOd0lBSUFJZ0JDa0RHRGNDR0NBQ0lBUXBBeEEzQWhBZ0FpQUVLUU1JTndJSUlBSWdCQ2tEQURjQ0FFRUJJQUVvQWdBZ0FDZ0NBRThOQWhvZ0JDQUFLUUlZTndNWUlBUWdBQ2tDRURjREVDQUVJQUFwQWdnM0F3Z2dCQ0FBS1FJQU53TUFJQUFnQVNrQ0dEY0NHQ0FBSUFFcEFoQTNBaEFnQUNBQktRSUlOd0lJSUFBZ0FTa0NBRGNDQUNBQklBUXBBeGczQWhnZ0FTQUVLUU1RTndJUUlBRWdCQ2tEQ0RjQ0NDQUJJQVFwQXdBM0FnQU1BUXNnQlNBR1NRUkFJQVFnQUNrQ0dEY0RHQ0FFSUFBcEFoQTNBeEFnQkNBQUtRSUlOd01JSUFRZ0FDa0NBRGNEQUNBQUlBSXBBaGczQWhnZ0FDQUNLUUlRTndJUUlBQWdBaWtDQ0RjQ0NDQUFJQUlwQWdBM0FnQWdBaUFFS1FNWU53SVlJQUlnQkNrREVEY0NFQ0FDSUFRcEF3ZzNBZ2dnQWlBRUtRTUFOd0lBUVFFTUFnc2dCQ0FBS1FJWU53TVlJQVFnQUNrQ0VEY0RFQ0FFSUFBcEFnZzNBd2dnQkNBQUtRSUFOd01BSUFBZ0FTa0NHRGNDR0NBQUlBRXBBaEEzQWhBZ0FDQUJLUUlJTndJSUlBQWdBU2tDQURjQ0FDQUJJQVFwQXhnM0FoZ2dBU0FFS1FNUU53SVFJQUVnQkNrRENEY0NDQ0FCSUFRcEF3QTNBZ0JCQVNBQ0tBSUFJQUVvQWdCUERRRWFJQVFnQVNrQ0dEY0RHQ0FFSUFFcEFoQTNBeEFnQkNBQktRSUlOd01JSUFRZ0FTa0NBRGNEQUNBQklBSXBBaGczQWhnZ0FTQUNLUUlRTndJUUlBRWdBaWtDQ0RjQ0NDQUJJQUlwQWdBM0FnQWdBaUFFS1FNWU53SVlJQUlnQkNrREVEY0NFQ0FDSUFRcEF3ZzNBZ2dnQWlBRUtRTUFOd0lBQzBFQ0N5RUZJQU1vQWdBZ0FpZ0NBRWtFZnlBRUlBSXBBaGczQXhnZ0JDQUNLUUlRTndNUUlBUWdBaWtDQ0RjRENDQUVJQUlwQWdBM0F3QWdBaUFES1FJWU53SVlJQUlnQXlrQ0VEY0NFQ0FDSUFNcEFnZzNBZ2dnQWlBREtRSUFOd0lBSUFNZ0JDa0RHRGNDR0NBRElBUXBBeEEzQWhBZ0F5QUVLUU1JTndJSUlBTWdCQ2tEQURjQ0FDQUNLQUlBSUFFb0FnQlBCRUFnQlVFQmFnOExJQVFnQVNrQ0dEY0RHQ0FFSUFFcEFoQTNBeEFnQkNBQktRSUlOd01JSUFRZ0FTa0NBRGNEQUNBQklBSXBBaGczQWhnZ0FTQUNLUUlRTndJUUlBRWdBaWtDQ0RjQ0NDQUJJQUlwQWdBM0FnQWdBaUFFS1FNWU53SVlJQUlnQkNrREVEY0NFQ0FDSUFRcEF3ZzNBZ2dnQWlBRUtRTUFOd0lBSUFFb0FnQWdBQ2dDQUU4RVFDQUZRUUpxRHdzZ0JDQUFLUUlZTndNWUlBUWdBQ2tDRURjREVDQUVJQUFwQWdnM0F3Z2dCQ0FBS1FJQU53TUFJQUFnQVNrQ0dEY0NHQ0FBSUFFcEFoQTNBaEFnQUNBQktRSUlOd0lJSUFBZ0FTa0NBRGNDQUNBQklBUXBBeGczQWhnZ0FTQUVLUU1RTndJUUlBRWdCQ2tEQ0RjQ0NDQUJJQVFwQXdBM0FnQWdCVUVEYWdVZ0JRc0xIUUFnQVFSQUlBQWdBU2dDQUJBZ0lBQWdBU2dDQkJBZ0lBRVFFUXNMQ0FCQnRnZ1FQQUFMa1QwQkZuOGdCRUhZRDJvaEJpQUVRZW9QYWlFT0lBUkJDR29oRUVGaElRVUNRQUovQWtBQ1FBSkFBbjhDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQWdCQ2dDMENZT0JnRUFBd1FHQ3hFTElBUW9BZ3doQlF3QkMwRUNJUVVDUUNBRUtBSU1JZ3BCSDJ0QkFrOEVRQ0FRS0FJQUlRY01BUXNnQkNnQ0ZDSUpSUTBRSUFRZ0JDZ0NDRUVJZGlJTE5nSUlJQVFvQWhBaUJ5MEFBQ0VGSUFRZ0NVRUJhellDRkNBRUlBZEJBV28yQWhBZ0JDQUZRUmgwSUF0eUlnYzJBZ2dnQ2tFSWF5RUtDeUFFSUFwQkFtb2lCVFlDRENBRUlBY2dDblpCQTNFaUJ6WUNZQ0FIUVFGSERRTUxBa0FnQlVFZmEwRUNUd1JBSUJBb0FnQWhDZ3dCQ3lBRUtBSVVJZzVGRFFnZ0JDQUVLQUlJUVFoMklnczJBZ2dnQkNnQ0VDSUdMUUFBSVFjZ0JDQU9RUUZyTmdJVUlBUWdCa0VCYWpZQ0VDQUVJQWRCR0hRZ0MzSWlDallDQ0NBRlFRaHJJUVVMSUFSQkFEWUNZQ0FFSUFWQkFtbzJBZ3dnQkNBS0lBVjJRUU54TmdLb0FndEJBQ0VLSUFCQi93OXhRUUZySWdVRVFBTkFJQXBCQVdvaENpQUZRUUZMSVJjZ0JVRUJkaUVGSUJjTkFBc0xJQVFvQW1BaUVpQUVLQUtvQWlJSFN3MEpJQXBCQW5SQjBCbHFJUTBnQkNnQ0RDRUZBMEFDUUNBS1FTQWdCV3ROQkVBZ0VDZ0NBQ0VNSUFVaEFBd0JDeUFFS0FJVUlnaEZEUWNnQkNBRUtBSUlRUWgySWdrMkFnZ2dCQ2dDRUNJT0xRQUFJUXNnQkNBSVFRRnJJZ1kyQWhRZ0JDQUZRUWhySWdBMkFnd2dCQ0FPUVFGcU5nSVFJQVFnQzBFWWRDQUpjaUlNTmdJSVFTZ2dCV3NnQ2s4TkFDQUdSUTBISUFRZ0JDZ0NDRUVJZGlJSk5nSUlJQVFvQWhBaURpMEFBQ0VMSUFRZ0NFRUNheUlHTmdJVUlBUWdCVUVRYXlJQU5nSU1JQVFnRGtFQmFqWUNFQ0FFSUF0QkdIUWdDWElpRERZQ0NFRXdJQVZySUFwUERRQWdCa1VOQnlBRUlBUW9BZ2hCQ0hZaUNUWUNDQ0FFS0FJUUlnNHRBQUFoQ3lBRUlBaEJBMnNpQmpZQ0ZDQUVJQVZCR0dzaUFEWUNEQ0FFSUE1QkFXbzJBaEFnQkNBTFFSaDBJQWx5SWd3MkFnaEJPQ0FGYXlBS1R3MEFJQVpGRFFjZ0JDQUVLQUlJUVFoMklnazJBZ2dnQkNnQ0VDSU9MUUFBSVFzZ0JDQUlRUVJySWdZMkFoUWdCQ0FGUVNCcklnQTJBZ3dnQkNBT1FRRnFOZ0lRSUFRZ0MwRVlkQ0FKY2lJTU5nSUlRY0FBSUFWcklBcFBEUUFnQmtVTkJ5QUVJQVFvQWdoQkNIWWlDVFlDQ0NBRUtBSVFJZzR0QUFBaEN5QUVJQWhCQldzaUJqWUNGQ0FFSUFWQktHc2lBRFlDRENBRUlBNUJBV28yQWhBZ0JDQUxRUmgwSUFseUlndzJBZ2hCeUFBZ0JXc2dDazhOQUNBR1JRMEhJQVFnQkNnQ0NFRUlkaUlPTmdJSUlBUW9BaEFpQ3kwQUFDRUdJQVFnQ0VFR2F6WUNGQ0FFSUFWQk1Hc2lBRFlDRENBRUlBdEJBV28yQWhBZ0JDQUdRUmgwSUE1eUlndzJBZ2dMSUFRZ0FDQUthaUlGTmdJTUlBRWdEU2dDQUNBTUlBQjJjU0lBU3dSQUlBUWdFa0VCZEdvZ0FEc0J1QU1nRWtFQmFpSVNJQWRMRFFzTUFRc0xRWHdQQ3lBRUtBS29BaUVIREFrTElBUkNnSUNBZ0lBRU53S3NBaUFHUWdBM0FSWWdCa0lBTndNUUlBWkNBRGNEQ0NBR1FnQTNBd0FnQkVFRU5nTFFKa0VnSVFzTUFRc2dCQ2dDc0FJaEN5QUVLQUtzQWlFTUlBUW9BbUFpQjBFUlN3MEJDeUFFS0FJTUlRVURRQ0FIUWFBWWFpMEFBQ0VSQWtBQ1FBSkFJQVZCSFd0QkJFOEVRQ0FRS0FJQUlRb01BUXNnQkNnQ0ZDSUlSUTBCSUFRZ0JDZ0NDRUVJZGlJTk5nSUlJQVFvQWhBaUNTMEFBQ0VBSUFRZ0NFRUJhellDRkNBRUlBbEJBV28yQWhBZ0JDQUFRUmgwSUExeUlnbzJBZ2dnQlVFSWF5RUZDeUFLSUFWMlFROXhJZ3BCd0JocUxRQUFJUklNQVF0QkFDRUtJQVZCSUVjRVFDQVFLQUlBSUFWMklRb0xJQXBCd0JocUxRQUFJaEpCSUNBRmEwME5BQ0FFUVFRMkF0QW1JQVFnQ3pZQ3NBSWdCQ0FNTmdLc0FpQUVJQWMyQW1CQkFnOExJQVFnQlNBU2FpSUZOZ0lNSUFRZ0VXcEIyQTlxSUFwQjBCaHFMUUFBSWdrNkFBQkJrU0lnQ25aQkFYRkZCRUFnQkNBSlFRRjBha0hxRDJvaUFDQUFMd0VBUVFGcU93RUFJQXhCQVdvaERDQUxRU0FnQ1hacklndEJJV3RCWUVrTkFnc2dCMEVCYWlJSFFSSkhEUUFMQ3lBTVFRRkhCRUJCZWlFRklBc05DUXNnQkVHMEFtb2hEVUVBSVF3akFFSHdBR3NpQ0NBT0x3RUNRUUZySWdBMkFnUWdDQ0FBSUE0dkFRUnFJZ0EyQWdnZ0NDQUFJQTR2QVFacUlnQTJBZ3dnQ0NBQUlBNHZBUWhxSWdVMkFoQWdEaThCQ2lFQUlBaEJFVFlDQUNBSUlBQWdCV28yQWhRZ0NDQUdMUUFSUVFKMGFpSUFJQUFvQWdBaUFFRUJhellDQUNBSVFTQnFJZ1VnQUVFQ2RHcEJFVFlDQUNBSUlBWXRBQkJCQW5ScUlnQWdBQ2dDQUNJQVFRRnJOZ0lBSUFCQkFuUWdCV3BCRURZQ0FDQUlJQVl0QUE5QkFuUnFJZ0FnQUNnQ0FDSUFRUUZyTmdJQUlBaEJJR29nQUVFQ2RHcEJEellDQUNBSUlBWXRBQTVCQW5ScUlnQWdBQ2dDQUNJQVFRRnJOZ0lBSUFoQklHb2dBRUVDZEdwQkRqWUNBQ0FJSUFZdEFBMUJBblJxSWdBZ0FDZ0NBQ0lBUVFGck5nSUFJQWhCSUdvZ0FFRUNkR3BCRFRZQ0FDQUlJQVl0QUF4QkFuUnFJZ0FnQUNnQ0FDSUFRUUZyTmdJQUlBaEJJR29nQUVFQ2RHcEJERFlDQUNBSUlBWXRBQXRCQW5ScUlnQWdBQ2dDQUNJQVFRRnJOZ0lBSUFoQklHb2dBRUVDZEdwQkN6WUNBQ0FJSUFZdEFBcEJBblJxSWdBZ0FDZ0NBQ0lBUVFGck5nSUFJQWhCSUdvZ0FFRUNkR3BCQ2pZQ0FDQUlJQVl0QUFsQkFuUnFJZ0FnQUNnQ0FDSUFRUUZyTmdJQUlBaEJJR29nQUVFQ2RHcEJDVFlDQUNBSUlBWXRBQWhCQW5ScUlnQWdBQ2dDQUNJQVFRRnJOZ0lBSUFoQklHb2dBRUVDZEdwQkNEWUNBQ0FJSUFZdEFBZEJBblJxSWdBZ0FDZ0NBQ0lBUVFGck5nSUFJQWhCSUdvZ0FFRUNkR3BCQnpZQ0FDQUlJQVl0QUFaQkFuUnFJZ0FnQUNnQ0FDSUFRUUZyTmdJQUlBaEJJR29nQUVFQ2RHcEJCallDQUNBSUlBWXRBQVZCQW5ScUlnQWdBQ2dDQUNJQVFRRnJOZ0lBSUFoQklHb2dBRUVDZEdwQkJUWUNBQ0FJSUFZdEFBUkJBblJxSWdBZ0FDZ0NBQ0lBUVFGck5nSUFJQWhCSUdvZ0FFRUNkR3BCQkRZQ0FDQUlJQVl0QUFOQkFuUnFJZ0FnQUNnQ0FDSUFRUUZyTmdJQUlBaEJJR29nQUVFQ2RHcEJBellDQUNBSUlBWXRBQUpCQW5ScUlnQWdBQ2dDQUNJQVFRRnJOZ0lBSUFoQklHb2dBRUVDZEdwQkFqWUNBQ0FJSUFZdEFBRkJBblJxSWdBZ0FDZ0NBQ0lBUVFGck5nSUFJQWhCSUdvZ0FFRUNkR3BCQVRZQ0FDQUlJQVl0QUFCQkFuUnFJZ0FnQUNnQ0FDSUFRUUZyTmdJQVFRQWhDU0FBUVFKMElBVnFRUUEyQWdBQ1FDQUlLQUlBQkVBZ0RpOEJBaUlBQkVBRFFDQU5JQWxCZ05jQWFpMEFBRUVDZEdvaUJ5QUlRU0JxSUF4QkFuUnFLQUlBUVJCMFFRRnlJZ1UyQVhBZ0J5QUZOZ0Y0SUFjZ0JUWUJhQ0FISUFVMkFXQWdCeUFGTmdGWUlBY2dCVFlCVUNBSElBVTJBVWdnQnlBRk5nRkFJQWNnQlRZQk9DQUhJQVUyQVRBZ0J5QUZOZ0VvSUFjZ0JUWUJJQ0FISUFVMkFSZ2dCeUFGTmdFUUlBY2dCVFlCQ0NBSElBVTJBUUFnQ1VHQUFXb2hDU0FNUVFGcUlRd2dBRUVCYXlJQURRQUxDeUFPTHdFRUlnQUVRQU5BSUEwZ0NVR0Exd0JxTFFBQVFRSjBhaUlISUFoQklHb2dERUVDZEdvb0FnQkJFSFJCQW5JaUJUWUJZQ0FISUFVMkFYQWdCeUFGTmdGUUlBY2dCVFlCUUNBSElBVTJBVEFnQnlBRk5nRWdJQWNnQlRZQkVDQUhJQVUyQVFBZ0NVRkFheUVKSUF4QkFXb2hEQ0FBUVFGcklnQU5BQXNMQWtBZ0RpOEJCaUlGUlEwQUlBVkJBWEVFZnlBTklBbEJnTmNBYWkwQUFFRUNkR29pQnlBSVFTQnFJQXhCQW5ScUtBSUFRUkIwUVFOeUlnQTJBVUFnQnlBQU5nRmdJQWNnQURZQklDQUhJQUEyQVFBZ0NVRWdhaUVKSUF4QkFXb2hEQ0FGUVFGckJTQUZDeUVBSUFWQkFVWU5BQU5BSUEwZ0NVR0Exd0JxSWdjdEFBQkJBblJxSWdzZ0NFRWdhaUFNUVFKMGFpSUZLQUlBUVJCMFFRTnlJZ1kyQVVBZ0N5QUdOZ0ZnSUFzZ0JqWUJJQ0FMSUFZMkFRQWdEU0FITFFBZ1FRSjBhaUlISUFVb0FnUkJFSFJCQTNJaUJUWUJRQ0FISUFVMkFXQWdCeUFGTmdFZ0lBY2dCVFlCQUNBSlFVQnJJUWtnREVFQ2FpRU1JQUJCQW1zaUFBMEFDd3NDUUNBT0x3RUlJZ1ZGRFFBZ0JVRUJjUVIvSUEwZ0NVR0Exd0JxTFFBQVFRSjBhaUlISUFoQklHb2dERUVDZEdvb0FnQkJFSFJCQkhJaUFEWUJBQ0FISUFBMkFVQWdDVUVRYWlFSklBeEJBV29oRENBRlFRRnJCU0FGQ3lFQUlBVkJBVVlOQUFOQUlBMGdDVUdBMXdCcUlnc3RBQUJCQW5ScUlnY2dDRUVnYWlBTVFRSjBhaUlHS0FJQVFSQjBRUVJ5SWdVMkFRQWdCeUFGTmdGQUlBMGdDeTBBRUVFQ2RHb2lCeUFHS0FJRVFSQjBRUVJ5SWdVMkFRQWdCeUFGTmdGQUlBbEJJR29oQ1NBTVFRSnFJUXdnQUVFQ2F5SUFEUUFMQ3dKQUlBNHZBUW9pQlVVTkFDQUZRUUZ4Qkg4Z0RTQUpRWURYQUdvdEFBQkJBblJxSUFoQklHb2dERUVDZEdvb0FnQkJFSFJCQlhJMkFRQWdDVUVJYWlFSklBeEJBV29oRENBRlFRRnJCU0FGQ3lFQUlBVkJBVVlOQUFOQUlBMGdDVUdBMXdCcUlnY3RBQUJCQW5ScUlBaEJJR29nREVFQ2RHb2lCU2dDQUVFUWRFRUZjallCQUNBTklBY3RBQWhCQW5ScUlBVW9BZ1JCRUhSQkJYSTJBUUFnQ1VFUWFpRUpJQXhCQW1vaERDQUFRUUpySWdBTkFBc0xEQUVMSUEwZ0NDZ0NJRUVRZENJQU5nRjhJQTBnQURZQmVDQU5JQUEyQVhRZ0RTQUFOZ0Z3SUEwZ0FEWUJiQ0FOSUFBMkFXZ2dEU0FBTmdGa0lBMGdBRFlCWUNBTklBQTJBVndnRFNBQU5nRllJQTBnQURZQlZDQU5JQUEyQVZBZ0RTQUFOZ0ZNSUEwZ0FEWUJTQ0FOSUFBMkFVUWdEU0FBTmdGQUlBMGdBRFlCUENBTklBQTJBVGdnRFNBQU5nRTBJQTBnQURZQk1DQU5JQUEyQVN3Z0RTQUFOZ0VvSUEwZ0FEWUJKQ0FOSUFBMkFTQWdEU0FBTmdFY0lBMGdBRFlCR0NBTklBQTJBUlFnRFNBQU5nRVFJQTBnQURZQkRDQU5JQUEyQVFnZ0RTQUFOZ0VFSUEwZ0FEWUJBQXNnRGtJQU53RVlJQTVDQURjQkVFRUlJUWtnRGtJQU53RUlJQTVDQURjQkFDQUVRWEEyQXRnT0lBUW9BclFESWdwQklHdEIvLzhET3dFQUlBUkIzQTVxUVhFMkFnQWdDa0VlYTBILy93TTdBUUFnQkVIZ0RtcEJjallDQUNBS1FSeHJRZi8vQXpzQkFDQUVRZVFPYWtGek5nSUFJQXBCR210Qi8vOERPd0VBSUFSQjZBNXFRWFEyQWdBZ0NrRVlhMEgvL3dNN0FRQWdCRUhzRG1wQmRUWUNBQ0FLUVJaclFmLy9BenNCQUNBRVFmQU9ha0YyTmdJQUlBcEJGR3RCLy84RE93RUFJQVJCOUE1cVFYYzJBZ0FnQ2tFU2EwSC8vd003QVFBZ0JFSDREbXBCZURZQ0FDQUtRUkJyUWYvL0F6c0JBQ0FFUWZ3T2FrRjVOZ0lBSUFwQkRtdEIvLzhET3dFQUlBUkJnQTlxUVhvMkFnQWdDa0VNYTBILy93TTdBUUFnQkVHRUQycEJlellDQUNBS1FRcHJRZi8vQXpzQkFDQUVRWWdQYWtGOE5nSUFJQXBCQ0d0Qi8vOERPd0VBSUFSQmpBOXFRWDAyQWdBZ0NrRUdhMEgvL3dNN0FRQWdCRUdRRDJwQmZqWUNBQ0FLUVFSclFmLy9BenNCQUNBRVFaUVBha0YvTmdJQUlBcEJBbXRCLy84RE93RUFJQVJDQURjRHFBSWdCRUVGTmdMUUprR0FnQUloRHlBRVFZQ0FBallDc0FJZ0JFS0FnSUNBZ0FFM0E1QUNRUUFoQzBFQURBTUxJQVJCQWpZQzBDWWdCQ0FTTmdKZ1FRSVBDeUFFUVFFMkF0QW1RUUlQQ3lBRUtBSzBBeUVLSUFRb0FwQUNJUXNnQkNnQ2xBSWhDU0FFS0FLd0FpRVBJQVFvQXF3Q0lSTWdCQ2dDcUFJTElRVWdCRUhZRG1vaEZBSkFBa0FDUUNBUUVDbEZCRUFnQkNnQ3NBSWhEeUFFS0FLb0FpRUZEQUVMQWtBZ0FTQUZUUTBBSUE5RkRRQWdCRUcwQW1vaEVTQUVLQUlVSVJVRFFBSkFBbjhDUUNBVlFRSlBCRUFnQkNnQ0NDRUFJQVFvQWd3aUIwRVFUd1JBSUFRZ0IwRVFjeUlITmdJTUlBUWdBRUVRZGlJTU5nSUlJQVFvQWhBaUJpOEFBQ0VBSUFRZ0ZVRUNheUlWTmdJVUlBUWdCa0VDYWpZQ0VDQUVJQUJCRUhRZ0RISWlBRFlDQ0FzZ0JDQUhJQkVnQUNBSGRrRWZjVUVDZEdvaUJpMEFBR29pRFRZQ0RDQUdMd0VDSWdkQkQwMEVRQ0FIQkVBZ0NpQVVJQWRCQW5ScUlnQW9BZ0JCQVhScUlBVTdBUUFnQUNBRk5nSUFJQTRnQjBFQmRHb2lBQ0FBTHdFQVFRRnFPd0VBSUE5QmdJQUNJQWQyYXlFUElBY2hDUXNnQlVFQmFpRU1RUUFoRXd3RUN5QUVRUUpCQXlBSFFSQkdJZ2NiSWd3Z0RXbzJBZ3dnREVFQ2RFSFFHV29vQWdBZ0FDQU5kbkVoQUNBSlFRQWdCeHNpQmlBTFJnUkFJQk1OQWlBTElRWUxRUUFoRWtFQURBSUxJQVFnRXpZQ3JBSWdCQ0FGTmdLb0FpQUVJQWsyQXBRQ0lBUWdEellDc0FJZ0JDQUxOZ0tRQWd3RkN5QVRRUUpySUF4MElSSWdDeUVHSUJNTElRY2dBU0FBSUJKcUlnQkJBMm9pRXlBSGF5SVdJQVZxSWd4SkJFQkIvLzgvSVE4Z0JFSC8vejgyQXJBQ0RBVUxJQVpGQkVCQkFDRUxEQUVMSUFBZ0Iyc2lDMEVDYWlFWUlCUWdCa0VDZEdvaURTZ0NBQ0VIUVFBaEVpQUxRUU5xUVFkeElnc0VRQU5BSUFvZ0IwRUJkR29nQlNJQU93RUFJQUJCQVdvaEJTQUFJUWNnRWtFQmFpSVNJQXRIRFFBTEN5QVlRUWRQQkVBRFFDQUtJQWRCQVhScUlBVTdBUUFnQ2lBRlFRRjBhaUFGUVFGcUlnQTdBUUFnQ2lBQVFRRjBhaUFGUVFKcUlnQTdBUUFnQ2lBQVFRRjBhaUFGUVFOcUlnQTdBUUFnQ2lBQVFRRjBhaUFGUVFScUlnQTdBUUFnQ2lBQVFRRjBhaUFGUVFWcUlnQTdBUUFnQ2lBQVFRRjBhaUFGUVFacUlnQTdBUUFnQ2lBQVFRRjBhaUFGUVFkcUlnYzdBUUFnQnlFQUlBVkJDR29pQlNBTVJ3MEFDd3NnRFNBQU5nSUFJQTRnQmtFQmRHb2lBQ0FBTHdFQUlCWnFPd0VBSUE4Z0ZrRVBJQVpyZEdzaER5QUdJUXNMSUFFZ0RFME5BU0FNSVFVZ0R3MEFDd3NnQkNBUE5nS3dBZ3dCQ3lBQklBVk5EUUFnQkVHMEFtb2hEVUVBSVFBRFFDQVBSUTBDQWtBZ0FFVUVRQ0FFS0FJTUlRb01BUXNnQkNnQ0ZDSUxSUVJBUVFJUEN5QUVJQVFvQWdoQkNIWWlCallDQ0NBRUtBSVFJZ2N0QUFBaEFDQUVJQVFvQWd4QkNHc2lDallDRENBRUlBdEJBV3MyQWhRZ0JDQUhRUUZxTmdJUUlBUWdBRUVZZENBR2NqWUNDQXRCQUNFSFFRRWhBQ0FLUVNCSEJFQWdFQ2dDQUNBS2RpRUhDd0pBSUEwZ0IwRWZjVUVDZEdvaUJpMEFBQ0lNUVNBZ0Ntc2lDVXNOQUFKQUFrQWdCaThCQWlJSVFROU5CRUFnQkVFQU5nS3NBaUFFSUFvZ0RHbzJBZ3dnQ0FSQUlBUW9BclFESUJRZ0NFRUNkR29pQUNnQ0FFRUJkR29nQlRzQkFDQUFJQVUyQWdBZ0JDQVBRWUNBQWlBSWRtc2lEellDc0FJZ0JDQUlOZ0tVQWlBT0lBaEJBWFJxSWdBZ0FDOEJBRUVCYWpzQkFBc2dCQ0FGUVFGcUlnVTJBcWdDREFFTElBa2dDRUVPYXlJTElBeHFJZ1pKRFFJZ0JDQUdJQXBxTmdJTUlBdEJBblJCMEJscUtBSUFJQWNnREhaeElRY2dCQ2dDdEFNaEVTQUVBbjhDUUFKL0lBaEJFRWNFUUVFRElRdEJBQXdCQzBFQ0lRc2dCQ2dDbEFJTElna2dCQ2dDa0FKSEJFQWdCQ0FKTmdLUUFnd0JDeUFFS0FLc0FpSUFSUTBBSUFCQkFtc2dDM1FNQVF0QkFDRUFRUUFMSUFkcUlndEJBMm9pQnpZQ3JBSWdBU0FISUFCcklnZ2dCV29pQmtrRVFDQUVRZi8vUHpZQ3NBSWdCQ0FCTmdLb0FrRjVEd3NnQ1VVTkFTQUxJQUJySWd0QkFtb2hHU0FVSUFsQkFuUnFJZ2tvQWdBaEIwRUFJUklnQzBFRGFrRUhjU0lMQkVBRFFDQVJJQWRCQVhScUlBVWlBRHNCQUNBQVFRRnFJUVVnQUNFSElCSkJBV29pRWlBTFJ3MEFDd3NnR1VFSFR3UkFBMEFnRVNBSFFRRjBhaUFGT3dFQUlCRWdCVUVCZEdvZ0JVRUJhaUlBT3dFQUlCRWdBRUVCZEdvZ0JVRUNhaUlBT3dFQUlCRWdBRUVCZEdvZ0JVRURhaUlBT3dFQUlCRWdBRUVCZEdvZ0JVRUVhaUlBT3dFQUlCRWdBRUVCZEdvZ0JVRUZhaUlBT3dFQUlCRWdBRUVCZEdvZ0JVRUdhaUlBT3dFQUlCRWdBRUVCZEdvZ0JVRUhhaUlIT3dFQUlBY2hBQ0FGUVFocUlnVWdCa2NOQUFzTElBUWdCallDcUFJZ0NTQUFOZ0lBSUFRZ0JDZ0NzQUlnQ0VFUElBUW9BcEFDSWdCcmRHc2lEellDc0FJZ0RpQUFRUUYwYWlJQUlBQXZBUUFnQ0dvN0FRQWdCQ2dDcUFJaEJRdEJBQ0VBREFFTElBUWdCallDcUFKQkFDRUFJQVloQlFzZ0FTQUZTdzBBQ3d0QmVTRUZJQThOQlFzZ0FpRUZJQVFvQXJRRElSVkJBQ0VRUVE4aEFFRi9JUXNEUUNBQUlnSkJBV3NoQUNBTElnRkJBV3NoQ3lBVklBRkJBWFJxTHdFQVFmLy9BMFlOQUF0QkFTQUJRUkJxSWdoMFFZQUNJaFFnQ0VFSVNCc2hBVUVCUVFnZ0FpQUNRUWhLR3lJQUlBQkJBVXdiSVF4QmdBRWhFMEVDSVFaQkFTRUhBMEFnRGlBSFFRRjBhaThCQUNJUEJFQWdCMEVRYXlFSkEwQWdGU0FKUVFGMGFpOEJBQ0lKUVJCMElBZHlJUXNnQlNBUVFZRFhBR290QUFCQkFuUnFJUUlnQVNFQUEwQWdBaUFBSUFacklnQkJBblJxSUFzMkFRQWdBRUVBU2cwQUN5QVFJQk5xSVJBZ0QwRUJheUlQRFFBTEN5QVRRUUYySVJNZ0JrRUJkQ0VHSUFjZ0RFY2hHaUFIUVFGcUlRY2dHZzBBQ3lBQlFZQUNSd1JBQTBBZ0JTQUJRUUowSWdCcUlBVWdBQkFUR2lBQlFRRjBJZ0ZCZ0FKSERRQUxDeUFJUVFoS0JFQkJnQUVoRmtHQUFpRUJRUUloQzBHQUFpRVBRUWdoQnlBRklRa0RRQUpBSUE0Z0J5SUFRUUZxSWdkQkFYUnFJaEV2QVFCRkRRQWdBRUVQYXlFVElBZEJDR3NpQWtIL0FYRWhEVUVCSUFKMElRSWdBRUVOVEFSQUEwQWdEMEdBQWtZRVFDQUpJQUZCQW5ScUlRa2dBaUVCSUFjaEFBTkFBa0FnQVNBT0lBQkJBWFJxTHdFQWF5SUJRUUJNQkVBZ0FDRUdEQUVMSUFGQkFYUWhBVUVQSVFZZ0FFRUJhaUlBUVE5SERRRUxDeUFGSUJCQmdOY0FhaTBBQUNJQlFRSjBhaUlBSUFrZ0JXdEJBbllnQVdzN0FRSWdBQ0FHT2dBQUlCQkJBV29oRUVFQUlROUJBU0FHUVFocmRDSUJJQlJxSVJRTElCVWdFMEVCZEdvdkFRQWlFMEVRZENBTmNpRU1JQWtnRDBHQTF3QnFMUUFBUVFKMGFpRUdJQUVoQUFOQUlBWWdBQ0FMYXlJQVFRSjBhaUFNTmdFQUlBQkJBRW9OQUFzZ0VTQVJMd0VBUVFGcklnQTdBUUFnRHlBV2FpRVBJQUJCLy84RGNRMEFEQUlMQUFzRFFDQVBRWUFDUmdSQUlBVWdFRUdBMXdCcUxRQUFJZ1pCQW5ScUlnQWdDU0FCUVFKMGFpSUpJQVZyUVFKMklBWnJPd0VDSUFBZ0J6b0FBQ0FRUVFGcUlSQWdBaUFVYWlFVVFRQWhEeUFDSVFFTElCVWdFMEVCZEdvdkFRQWlFMEVRZENBTmNpRU1JQWtnRDBHQTF3QnFMUUFBUVFKMGFpRUdJQUVoQUFOQUlBWWdBQ0FMYXlJQVFRSjBhaUFNTmdFQUlBQkJBRW9OQUFzZ0VTQVJMd0VBUVFGcklnQTdBUUFnRHlBV2FpRVBJQUJCLy84RGNRMEFDd3NnRmtFQmRpRVdJQXRCQVhRaEN5QUhJQWhJRFFBTEN5QVVEQU1MUVFBaEFDQUhSUVJBUVFBaEJ3d0NDd05BSUFRZ0FFRUJkR292QWJnRElRRWdBRUVCYWlJQUlRVUNRQU5BSUFRZ0JVRUJkR292QWJnRElBRkhCRUFnQnlBRlFRRnFJZ1ZQRFFFTUFnc0xRWHNQQ3lBQUlBZEhEUUFMQ3lBSFFRTkhEUUFDUUNBRUtBSU1JZ1ZCSUVjRVFDQVFLQUlBSVFvTUFRc2dCQ2dDRkNJRlJRUkFJQVJCQXpZQzBDWkJBZzhMSUFRZ0JDZ0NDRUVJZGlJSE5nSUlJQVFvQWhBaUFTMEFBQ0VBSUFRZ0JVRUJhellDRkNBRUlBRkJBV28yQWhCQkdDRUZJQVFnQUVFWWRDQUhjaUlLTmdJSUN5QUVJQVZCQVdvMkFnd2dCQ0FLSUFWMlFRRnhRUU5xSWdjMkFxZ0NDeUFFUWJnRGFpRUdRUUVoQUFKQUFrQUNRQUpBQWtBQ1FBSkFJQWNPQlFBQkFnTUVCZ3NnQWtFQU9nQUFJQUlnQmk4QkFEc0JBZ3dGQ3lBQ1FRRTZBQVFnQWtFQk9nQUFJQVl2QVFJaUFTQUdMd0VBSWdCTEJFQWdBaUFBT3dFQ0lBSWdCaThCQWpzQkJrRUNJUUFNQlFzZ0FpQUJPd0VDSUFJZ0JpOEJBRHNCQmtFQ0lRQU1CQXNnQWtFQk9nQUFJQVl2QVFBaEFDQUNRUUU2QUFnZ0FpQUFPd0VDSUFJZ0JpOEJBRHNCQ2lBQ0lBWXZBUVFpQlNBR0x3RUNJZ0VnQVNBRlN4czdBUVpCQkNFQUlBWkJCR29nQmtFQ2FpQUJJQVZKR3k4QkFDRUJJQUpCQWpvQURDQUNRUUk2QUFRZ0FpQUJPd0VPREFNTEFrQWdCaThCQWlJQUlBWXZBUUFpQVU4RVFDQUJJUUFNQVFzZ0JpQUFPd0VBSUFZZ0FUc0JBZ3NDUUNBQUlBWXZBUVFpQVUwRVFDQUFJUUVNQVFzZ0JpQUJPd0VBSUFZZ0FEc0JCQXNnQmk4QkJpSUFJQUZQRFFFZ0JpQUFPd0VBSUFZZ0FUc0JCZ3dCQ3lBR0x3RUdJZ0VnQmk4QkJDSUFTUVJBSUFZZ0FUc0JCQ0FHSUFBN0FRWUxJQVl2QVFBaEFDQUNRUUU2QUFBZ0FpQUFPd0VDSUFZdkFRQWhBQ0FDUVFJNkFBUWdBaUFBT3dFR0lBWXZBUUFoQUNBQ1FRRTZBQWdnQWlBQU93RUtJQUlnQmk4QkFEc0JEaUFHTHdFQUlRQWdBa0VCT2dBUUlBSWdBRHNCRWlBR0x3RUFJUUFnQWtFQ09nQVVJQUlnQURzQkZpQUdMd0VBSVFBZ0FrRUJPZ0FZSUFJZ0FEc0JHaUFDSUFZdkFRSTdBUVlnQWlBR0x3RUVPd0VPSUFJZ0JpOEJBanNCRmlBR0x3RUdJUUFnQWtFRE9nQWNJQUpCQXpvQURDQUNJQUE3QVI1QkNDRUFEQUVMQWtBZ0JpOEJCQ0lBSUFZdkFRSWlBVThFUUNBQklRQU1BUXNnQmlBQU93RUNJQVlnQVRzQkJBc2dBQ0FHTHdFR0lnRkxCRUFnQmlBQk93RUNJQVlnQURzQkJnc2dCaThCQmlJQklBWXZBUVFpQUVrRVFDQUdJQUU3QVFRZ0JpQUFPd0VHQ3lBQ1FRSTZBQXdnQWtFQ09nQUlJQUpCQWpvQUJDQUNRUUk2QUFBZ0FpQUdMd0VBT3dFQ0lBSWdCaThCQWpzQkNpQUNJQVl2QVFRN0FRWWdBaUFHTHdFR093RU9RUVFoQUFzZ0FFR0FBa2NFUUFOQUlBSWdBRUVDZENJQmFpQUNJQUVRRXhvZ0FFRUJkQ0lBUVlBQ1J3MEFDd3RCZ0FJTElRQWdBd1JBSUFNZ0FEWUNBQXNnQkVFQU5nTFFKa0VCSVFVTElBVUxzUUlCQlg4Z0FDZ0N2QUZCQUVnRVFFRjNEd3NnQVNnQ0FDSUhJQUFvQWpRaUJTQUFLQUpBSWdZZ0JTQUdTQnNnQUNnQ3BBSWlDR3NnQUNnQ29BSWdCbXhxSWdrZ0J5QUpTUnNoQlNBQkFuOGdCeUFDUlEwQUdpQUFLQUprSUFBb0FrUWdDSEZxSVFZZ0FpZ0NBQ0lJUlFSQUlBSWdCallDQUNBSERBRUxJQWdnQmlBRkVCTWFJQUlnQWlnQ0FDQUZhallDQUNBQktBSUFDeUFGYXpZQ0FDQUFJQUFvQXFRQ0lBVnFJZ0UyQXFRQ0lBTUVRQ0FESUFFMkFnQUxRUUVnQUNnQzRDWjBJUUlnQUNnQ1FDRUJJQWNnQ1VrRVFFRURRUU5CQVNBQklBSkdHeUFFR3c4TEFrQWdBU0FDUncwQUlBQW9BalFpQWlBQlNBMEFJQUFnQWlBQmF6WUNOQ0FBSUFBb0FxQUNRUUZxTmdLZ0FpQUFJQUF2QWR3bVFmZi9BM0VnQVNBQ1IwRURkSEk3QWR3bUMwRUJDeTRCQVg5QkJCQTNJZ0JCN0tNSU5nSUFJQUJCeEtNSU5nSUFJQUJCMktNSU5nSUFJQUJCeUtRSVFRVVFCUUFMbEFRQkJIOGdBU0FBSUFGR0lnSTZBQXdDUUNBQ0RRQURRQ0FCS0FJSUlnSXRBQXdOQVFKQUlBSWdBaWdDQ0NJREtBSUFJZ1JHQkVBQ1FDQURLQUlFSWdSRkRRQWdCQzBBREEwQURBSUxBa0FnQVNBQ0tBSUFSZ1JBSUFJaEFRd0JDeUFDSUFJb0FnUWlBU2dDQUNJQU5nSUVJQUVnQUFSL0lBQWdBallDQ0NBQ0tBSUlCU0FEQ3pZQ0NDQUNLQUlJSWdBZ0FDZ0NBQ0FDUjBFQ2RHb2dBVFlDQUNBQklBSTJBZ0FnQWlBQk5nSUlJQUVvQWdnaUF5Z0NBQ0VDQ3lBQlFRRTZBQXdnQTBFQU9nQU1JQU1nQWlnQ0JDSUFOZ0lBSUFBRVFDQUFJQU0yQWdnTElBSWdBeWdDQ0RZQ0NDQURLQUlJSWdBZ0FDZ0NBQ0FEUjBFQ2RHb2dBallDQUNBQ0lBTTJBZ1FnQXlBQ05nSUlEd3NDUUNBRVJRMEFJQVF0QUF3TkFBd0JDd0pBSUFFZ0FpZ0NBRWNFUUNBQ0lRRU1BUXNnQWlBQktBSUVJZ0EyQWdBZ0FTQUFCSDhnQUNBQ05nSUlJQUlvQWdnRklBTUxOZ0lJSUFJb0FnZ2lBQ0FBS0FJQUlBSkhRUUowYWlBQk5nSUFJQUVnQWpZQ0JDQUNJQUUyQWdnZ0FTZ0NDQ0VEQ3lBQlFRRTZBQXdnQTBFQU9nQU1JQU1nQXlnQ0JDSUFLQUlBSWdFMkFnUWdBUVJBSUFFZ0F6WUNDQXNnQUNBREtBSUlOZ0lJSUFNb0FnZ2lBU0FCS0FJQUlBTkhRUUowYWlBQU5nSUFJQUFnQXpZQ0FDQURJQUEyQWdnTUFnc2dCRUVNYWlFRklBSkJBVG9BRENBRElBQWdBMFk2QUF3Z0JVRUJPZ0FBSUFNaUFTQUFSdzBBQ3dzTE5BQWdBQzBBQzBFSGRnUkFJQUFnQVRZQ0JBOExJQUFnQUMwQUMwR0FBWEVnQVhJNkFBc2dBQ0FBTFFBTFFmOEFjVG9BQ3dzSUFFR2ZDUkE4QUF0Z0FRRi9JQUFvQWlBZ0JFRUNkQ0lGSUFKQkgycEJCSFpCL3YvLy93QnhRYUNZQ0dvdkFRQkJBV3BzSUFBb0FoZ1JBZ0FoQUNBQklBUTdBUXdnQVNBRE93RUtJQUVnQWpzQkNDQUJJQUEyQWdBZ0FTQUFJQVZxTmdJRUlBQkJBRWNMMEFFQkJYOENRQ0FBS0FJRUlnRkJJRWNFUUNBQlFRaHJJUUlnQUNnQ0NDRUJEQUVMSUFBb0Fnd2lBVVVFUUVFQUR3c2dBQ0FBS0FJQVFRaDJJZ0kyQWdBZ0FDZ0NDQ0lETFFBQUlRUWdBQ0FCUVFGck5nSU1JQUJCR0RZQ0JDQUFJQU5CQVdvaUFUWUNDQ0FBSUFSQkdIUWdBbkkyQWdCQkVDRUNDd0pBSUFGQkFYRkZEUUFnQUNnQ0RDSURSUTBBSUFBZ0FDZ0NBRUVJZGlJRU5nSUFJQUV0QUFBaEJTQUFJQU5CQVdzMkFnd2dBQ0FDTmdJRUlBQWdBVUVCYWpZQ0NDQUFJQVZCR0hRZ0JISTJBZ0FMUVFFTEJBQWdBQXNkQUNBQkJFQWdBQ0FCS0FJQUVDc2dBQ0FCS0FJRUVDc2dBUkFSQ3d1eE1nRVFmeU1BUVNCcklnVWtBQU5BSUFGQklHc2hDUU5BSUFBaEJBTkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FDQUJJQVJySWdCQkJYVWlCdzRHQndjQUFRUUNBd3NnQVVFZ2F5SUFLQUlBSUFRb0FnQlBEUVlnQlNBRUtRSVlOd01ZSUFVZ0JDa0NFRGNERUNBRklBUXBBZ2czQXdnZ0JTQUVLUUlBTndNQUlBUWdBQ2tDR0RjQ0dDQUVJQUFwQWhBM0FoQWdCQ0FBS1FJSU53SUlJQVFnQUNrQ0FEY0NBQ0FBSUFVcEF4ZzNBaGdnQUNBRktRTVFOd0lRSUFBZ0JTa0RDRGNDQ0NBQUlBVXBBd0EzQWdBTUJnc2dBVUVnYXlJQUtBSUFJUUVnQkNnQ0lDSUNJQVFvQWdCUEJFQWdBU0FDVHcwR0lBVWdCQ2tDT0RjREdDQUZJQVFwQWpBM0F4QWdCU0FFS1FJb053TUlJQVVnQkNrQ0lEY0RBQ0FFSUFBcEFoZzNBamdnQkNBQUtRSVFOd0l3SUFRZ0FDa0NDRGNDS0NBRUlBQXBBZ0EzQWlBZ0FDQUZLUU1ZTndJWUlBQWdCU2tERURjQ0VDQUFJQVVwQXdnM0FnZ2dBQ0FGS1FNQU53SUFJQVFvQWlBZ0JDZ0NBRThOQmlBRklBUXBBaGczQXhnZ0JTQUVLUUlRTndNUUlBVWdCQ2tDQ0RjRENDQUZJQVFwQWdBM0F3QWdCQ0FFS1FJNE53SVlJQVFnQkNrQ01EY0NFQ0FFSUFRcEFpZzNBZ2dnQkNBRUtRSWdOd0lBSUFRZ0JTa0RHRGNDT0NBRUlBVXBBeEEzQWpBZ0JDQUZLUU1JTndJb0lBUWdCU2tEQURjQ0lBd0dDeUFCSUFKSkJFQWdCU0FFS1FJWU53TVlJQVVnQkNrQ0VEY0RFQ0FGSUFRcEFnZzNBd2dnQlNBRUtRSUFOd01BSUFRZ0FDa0NHRGNDR0NBRUlBQXBBaEEzQWhBZ0JDQUFLUUlJTndJSUlBUWdBQ2tDQURjQ0FDQUFJQVVwQXhnM0FoZ2dBQ0FGS1FNUU53SVFJQUFnQlNrRENEY0NDQ0FBSUFVcEF3QTNBZ0FNQmdzZ0JTQUVLUUlZTndNWUlBVWdCQ2tDRURjREVDQUZJQVFwQWdnM0F3Z2dCU0FFS1FJQU53TUFJQVFnQkNrQ09EY0NHQ0FFSUFRcEFqQTNBaEFnQkNBRUtRSW9Od0lJSUFRZ0JDa0NJRGNDQUNBRUlBVXBBeGczQWpnZ0JDQUZLUU1RTndJd0lBUWdCU2tEQ0RjQ0tDQUVJQVVwQXdBM0FpQWdBQ2dDQUNBRUtBSWdUdzBGSUFVZ0JDa0NPRGNER0NBRklBUXBBakEzQXhBZ0JTQUVLUUlvTndNSUlBVWdCQ2tDSURjREFDQUVJQUFwQWhnM0FqZ2dCQ0FBS1FJUU53SXdJQVFnQUNrQ0NEY0NLQ0FFSUFBcEFnQTNBaUFnQUNBRktRTVlOd0lZSUFBZ0JTa0RFRGNDRUNBQUlBVXBBd2czQWdnZ0FDQUZLUU1BTndJQURBVUxJQVFnQkVFZ2FpQUVRVUJySWdBZ0JFSGdBR29RSHhvZ0FVRWdheUlCS0FJQUlBUW9BbUJQRFFRZ0JTQUVLUUo0TndNWUlBVWdCQ2tDY0RjREVDQUZJQVFwQW1nM0F3Z2dCU0FFS1FKZ053TUFJQVFnQVNrQ0dEY0NlQ0FFSUFFcEFoQTNBbkFnQkNBQktRSUlOd0pvSUFRZ0FTa0NBRGNDWUNBQklBVXBBeGczQWhnZ0FTQUZLUU1RTndJUUlBRWdCU2tEQ0RjQ0NDQUJJQVVwQXdBM0FnQWdCQ2dDWUNBQUtBSUFUdzBFSUFVZ0FDa0NHRGNER0NBRklBQXBBaEEzQXhBZ0JTQUFLUUlJTndNSUlBVWdBQ2tDQURjREFDQUFJQVFwQW5nM0FoZ2dBQ0FFS1FKd053SVFJQUFnQkNrQ2FEY0NDQ0FBSUFRcEFtQTNBZ0FnQkNBRktRTVlOd0o0SUFRZ0JTa0RFRGNDY0NBRUlBVXBBd2czQW1nZ0JDQUZLUU1BTndKZ0lBQW9BZ0FnQkNnQ0lFOE5CQ0FGSUFRcEFqZzNBeGdnQlNBRUtRSXdOd01RSUFVZ0JDa0NLRGNEQ0NBRklBUXBBaUEzQXdBZ0JDQUFLUUlZTndJNElBUWdBQ2tDRURjQ01DQUVJQUFwQWdnM0FpZ2dCQ0FBS1FJQU53SWdJQUFnQlNrREdEY0NHQ0FBSUFVcEF4QTNBaEFnQUNBRktRTUlOd0lJSUFBZ0JTa0RBRGNDQUNBRUtBSWdJQVFvQWdCUERRUWdCU0FFS1FJWU53TVlJQVVnQkNrQ0VEY0RFQ0FGSUFRcEFnZzNBd2dnQlNBRUtRSUFOd01BSUFRZ0JDa0NPRGNDR0NBRUlBUXBBakEzQWhBZ0JDQUVLUUlvTndJSUlBUWdCQ2tDSURjQ0FDQUVJQVVwQXhnM0FqZ2dCQ0FGS1FNUU53SXdJQVFnQlNrRENEY0NLQ0FFSUFVcEF3QTNBaUFNQkFzZ0FFSGZCMHdFUUNBRVFVQnJJUWNnQkNnQ1FDRUFBa0FnQkNnQ0lDSUNJQVFvQWdBaUEwOEVRQ0FBSUFKUERRRWdCU0FFS1FJNE53TVlJQVVnQkNrQ01EY0RFQ0FGSUFRcEFpZzNBd2dnQlNBRUtRSWdOd01BSUFRZ0J5a0NHRGNDT0NBRUlBY3BBaEEzQWpBZ0JDQUhLUUlJTndJb0lBUWdCeWtDQURjQ0lDQUhJQVVwQXhnM0FoZ2dCeUFGS1FNUU53SVFJQWNnQlNrRENEY0NDQ0FISUFVcEF3QTNBZ0FnQkNnQ0lDQURUdzBCSUFVZ0JDa0NHRGNER0NBRklBUXBBaEEzQXhBZ0JTQUVLUUlJTndNSUlBVWdCQ2tDQURjREFDQUVJQVFwQWpnM0FoZ2dCQ0FFS1FJd053SVFJQVFnQkNrQ0tEY0NDQ0FFSUFRcEFpQTNBZ0FnQkNBRktRTVlOd0k0SUFRZ0JTa0RFRGNDTUNBRUlBVXBBd2czQWlnZ0JDQUZLUU1BTndJZ0RBRUxJQUFnQWtrRVFDQUZJQVFwQWhnM0F4Z2dCU0FFS1FJUU53TVFJQVVnQkNrQ0NEY0RDQ0FGSUFRcEFnQTNBd0FnQkNBSEtRSVlOd0lZSUFRZ0J5a0NFRGNDRUNBRUlBY3BBZ2czQWdnZ0JDQUhLUUlBTndJQUlBY2dCU2tER0RjQ0dDQUhJQVVwQXhBM0FoQWdCeUFGS1FNSU53SUlJQWNnQlNrREFEY0NBQXdCQ3lBRklBUXBBaGczQXhnZ0JTQUVLUUlRTndNUUlBVWdCQ2tDQ0RjRENDQUZJQVFwQWdBM0F3QWdCQ0FFS1FJNE53SVlJQVFnQkNrQ01EY0NFQ0FFSUFRcEFpZzNBZ2dnQkNBRUtRSWdOd0lBSUFRZ0JTa0RHRGNDT0NBRUlBVXBBeEEzQWpBZ0JDQUZLUU1JTndJb0lBUWdCU2tEQURjQ0lDQUFJQVFvQWlCUERRQWdCU0FFS1FJNE53TVlJQVVnQkNrQ01EY0RFQ0FGSUFRcEFpZzNBd2dnQlNBRUtRSWdOd01BSUFRZ0J5a0NHRGNDT0NBRUlBY3BBaEEzQWpBZ0JDQUhLUUlJTndJb0lBUWdCeWtDQURjQ0lDQUhJQVVwQXhnM0FoZ2dCeUFGS1FNUU53SVFJQWNnQlNrRENEY0NDQ0FISUFVcEF3QTNBZ0FMSUFSQjRBQnFJZ1lnQVVZTkJBTkFJQVlvQWdBaUF5QUhLQUlBU1FSQUlBVWdCaWdDSERZQ0dDQUZJQVlwQWhRM0F4QWdCU0FHS1FJTU53TUlJQVVnQmlrQ0JEY0RBQ0FHSVFJRFFBSkFJQUlnQnlJQUtRSUFOd0lBSUFJZ0FDa0NHRGNDR0NBQ0lBQXBBaEEzQWhBZ0FpQUFLUUlJTndJSUlBQWdCRVlFUUNBRUlRQU1BUXNnQUNFQ0lBTWdBRUVnYXlJSEtBSUFTUTBCQ3dzZ0FDQUROZ0lBSUFBZ0JTa0RBRGNDQkNBQUlBVXBBd2czQWd3Z0FDQUZLUU1RTndJVUlBQWdCU2dDR0RZQ0hBc2dCaUlIUVNCcUlnQWhCaUFBSUFGSERRQUxEQVFMSUFORkJFQWdBU0FFUmcwRUlBRWlCeUFFUndSL0l3QkJRR29oQ0NBSElBUnJJZ3BCQlhVaERBSkFJQXBCSVVnTkFDQUtRY0FBU1EwQUlBeEJBbXRCQVhZaUNTRUFBMEFDUUNBSklBQWlBMGdOQUNBRUlBQkJBWFFpQUVFQmNpSUdRUVYwYWlFQkFuOGdEQ0FBUVFKcUlnMU1CRUFnQVNnQ0FBd0JDeUFCUVNCcUlBRWdBU2dDQUNJQUlBRW9BaUFpQWtraUN4c2hBU0FOSUFZZ0N4c2hCaUFBSUFJZ0FDQUNTeHNMSUFRZ0EwRUZkR29pQUNnQ0FDSU5TUTBBSUFnZ0FDZ0NIRFlDR0NBSUlBQXBBaFEzQXhBZ0NDQUFLUUlNTndNSUlBZ2dBQ2tDQkRjREFBTkFBa0FnQUNBQklnSXBBZ0EzQWdBZ0FDQUJLUUlZTndJWUlBQWdBU2tDRURjQ0VDQUFJQUVwQWdnM0FnZ2dCaUFKU2cwQUlBUWdCa0VCZENJTFFRRnlJZ1pCQlhScUlRRWdBaUVBQW44Z0RDQUxRUUpxSWc5TUJFQWdBU2dDQUF3QkN5QUJRU0JxSUFFZ0FTZ0NBQ0lMSUFFb0FpQWlEa2tpRUJzaEFTQVBJQVlnRUJzaEJpQUxJQTRnQ3lBT1N4c0xJQTFQRFFFTEN5QUNJQTAyQWdBZ0FpQUlLUU1BTndJRUlBSWdDQ2tEQ0RjQ0RDQUNJQWdwQXhBM0FoUWdBaUFJS0FJWU5nSWNDeUFEUVFGcklRQWdBMEVBU2cwQUN3c2dCeUFISWdOSEJFQUNRQ0FLUVQ5TUJFQWdCeUVBQTBBZ0FDZ0NBQ0FFS0FJQVNRUkFJQWdnQUNrQ0dEY0RHQ0FJSUFBcEFoQTNBeEFnQ0NBQUtRSUlOd01JSUFnZ0FDa0NBRGNEQUNBQUlBUXBBaGczQWhnZ0FDQUVLUUlRTndJUUlBQWdCQ2tDQ0RjQ0NDQUFJQVFwQWdBM0FnQWdCQ0FJS1FNWU53SVlJQVFnQ0NrREVEY0NFQ0FFSUFncEF3ZzNBZ2dnQkNBSUtRTUFOd0lBQ3lBQVFTQnFJZ0FnQjBjTkFBc01BUXNnQkVGQWF5RU5JQVJCSUdvaENTQU1RUUpyUVFGMklSQWdDa0hBQUVZaEVRTkFBa0FnQXlnQ0FDQUVLQUlBVHcwQUlBZ2dBeWtDR0RjREdDQUlJQU1wQWhBM0F4QWdDQ0FES1FJSU53TUlJQWdnQXlrQ0FEY0RBQ0FESUFRcEFoZzNBaGdnQXlBRUtRSVFOd0lRSUFNZ0JDa0NDRGNDQ0NBRElBUXBBZ0EzQWdBZ0JDQUlLUU1ZTndJWUlBUWdDQ2tERURjQ0VDQUVJQWdwQXdnM0FnZ2dCQ0FJS1FNQU53SUFJQVFvQWlBaEFFRUJJUVlnRVFSL0lBa0ZRUUpCQVNBQUlBMG9BZ0FpQVVraUFoc2hCaUFBSUFFZ0FDQUJTeHNoQUNBTklBa2dBaHNMSVFJZ0FDQUVLQUlBSWd0SkRRQWdDQ0FFS0FJY05nSVlJQWdnQkNrQ0ZEY0RFQ0FJSUFRcEFndzNBd2dnQ0NBRUtRSUVOd01BSUFRaEFRTkFBa0FnQVNBQ0lnQXBBZ0EzQWdBZ0FTQUFLUUlZTndJWUlBRWdBQ2tDRURjQ0VDQUJJQUFwQWdnM0FnZ2dCaUFRU2cwQUlBUWdCa0VCZENJT1FRRnlJZ1pCQlhScUlRSWdBQ0VCQW44Z0RDQU9RUUpxSWhKTUJFQWdBaWdDQUF3QkN5QUNRU0JxSUFJZ0FpZ0NBQ0lPSUFJb0FpQWlEMGtpRXhzaEFpQVNJQVlnRXhzaEJpQU9JQThnRGlBUFN4c0xJQXRQRFFFTEN5QUFJQXMyQWdBZ0FDQUlLUU1BTndJRUlBQWdDQ2tEQ0RjQ0RDQUFJQWdwQXhBM0FoUWdBQ0FJS0FJWU5nSWNDeUFEUVNCcUlnTWdCMGNOQUFzTEN5QUtRU0ZPQkVBZ0NrRUZkaUVBQTBBZ0NDQUVLUUlZTndNWUlBZ2dCQ2tDRURjREVDQUlJQVFwQWdnM0F3Z2dDQ0FFS1FJQU53TUFJQUFpQTBFQ2EwRUJkaUVKUVFBaEFpQUVJUUVEUUNBQ1FRRjBJZ3BCQVhJaEJpQUNRUVYwSUFGcVFTQnFJUUFnQXlBS1FRSnFJZ0pNQkg4Z0JnVWdBRUVnYWlBQUlBQW9BZ0FnQUNnQ0lFa2lDaHNoQUNBQ0lBWWdDaHNMSVFJZ0FTQUFLUUlBTndJQUlBRWdBQ2tDR0RjQ0dDQUJJQUFwQWhBM0FoQWdBU0FBS1FJSU53SUlJQUFoQVNBQ0lBbE1EUUFMQWtBZ0IwRWdheUlISUFCR0JFQWdBQ0FJS1FNQU53SUFJQUFnQ0NrREdEY0NHQ0FBSUFncEF4QTNBaEFnQUNBSUtRTUlOd0lJREFFTElBQWdCeWtDQURjQ0FDQUFJQWNwQWhnM0FoZ2dBQ0FIS1FJUU53SVFJQUFnQnlrQ0NEY0NDQ0FISUFncEF3QTNBZ0FnQnlBSUtRTUlOd0lJSUFjZ0NDa0RFRGNDRUNBSElBZ3BBeGczQWhnZ0FDQUVhMEVnYWlJQlFTRklEUUFnQUNnQ0FDSUpJQVFnQVVFRmRrRUNhMEVCZGlJQ1FRVjBhaUlHS0FJQVRRMEFJQWdnQUNnQ0hEWUNPQ0FJSUFBcEFoUTNBekFnQ0NBQUtRSU1Od01vSUFnZ0FDa0NCRGNESUFOQUFrQWdBQ0FHSWdFcEFnQTNBZ0FnQUNBR0tRSVlOd0lZSUFBZ0Jpa0NFRGNDRUNBQUlBWXBBZ2czQWdnZ0FrVU5BQ0FHSVFBZ0JDQUNRUUZyUVFGMklnSkJCWFJxSWdZb0FnQWdDVWtOQVFzTElBRWdDVFlDQUNBQklBZ3BBeUEzQWdRZ0FTQUlLUU1vTndJTUlBRWdDQ2tETURjQ0ZDQUJJQWdvQWpnMkFod0xJQU5CQVdzaEFDQURRUUpLRFFBTEMwRUFCU0FIQ3hvTUJBc2dCQ0FIUVFSMFFXQnhhaUVHQWtBZ0FFSGgrUUZQQkVBZ0JDQUVJQWRCQTNSQllIRWlCMm9pQUNBR0lBWWdCMm9pQnhBZklRb2dDU2dDQUNBSEtBSUFUdzBCSUFVZ0J5a0NHRGNER0NBRklBY3BBaEEzQXhBZ0JTQUhLUUlJTndNSUlBVWdCeWtDQURjREFDQUhJQWtwQWhnM0FoZ2dCeUFKS1FJUU53SVFJQWNnQ1NrQ0NEY0NDQ0FISUFrcEFnQTNBZ0FnQ1NBRktRTVlOd0lZSUFrZ0JTa0RFRGNDRUNBSklBVXBBd2czQWdnZ0NTQUZLUU1BTndJQUlBY29BZ0FnQmlnQ0FFOEVRQ0FLUVFGcUlRb01BZ3NnQlNBR0tRSVlOd01ZSUFVZ0Jpa0NFRGNERUNBRklBWXBBZ2czQXdnZ0JTQUdLUUlBTndNQUlBWWdCeWtDR0RjQ0dDQUdJQWNwQWhBM0FoQWdCaUFIS1FJSU53SUlJQVlnQnlrQ0FEY0NBQ0FISUFVcEF4ZzNBaGdnQnlBRktRTVFOd0lRSUFjZ0JTa0RDRGNDQ0NBSElBVXBBd0EzQWdBZ0JpZ0NBQ0FBS0FJQVR3UkFJQXBCQW1vaENnd0NDeUFGSUFBcEFoZzNBeGdnQlNBQUtRSVFOd01RSUFVZ0FDa0NDRGNEQ0NBRklBQXBBZ0EzQXdBZ0FDQUdLUUlZTndJWUlBQWdCaWtDRURjQ0VDQUFJQVlwQWdnM0FnZ2dBQ0FHS1FJQU53SUFJQVlnQlNrREdEY0NHQ0FHSUFVcEF4QTNBaEFnQmlBRktRTUlOd0lJSUFZZ0JTa0RBRGNDQUNBQUtBSUFJQVFvQWdCUEJFQWdDa0VEYWlFS0RBSUxJQVVnQkNrQ0dEY0RHQ0FGSUFRcEFoQTNBeEFnQlNBRUtRSUlOd01JSUFVZ0JDa0NBRGNEQUNBRUlBQXBBaGczQWhnZ0JDQUFLUUlRTndJUUlBUWdBQ2tDQ0RjQ0NDQUVJQUFwQWdBM0FnQWdBQ0FGS1FNWU53SVlJQUFnQlNrREVEY0NFQ0FBSUFVcEF3ZzNBZ2dnQUNBRktRTUFOd0lBSUFwQkJHb2hDZ3dCQ3lBSktBSUFJUUFDUUNBR0tBSUFJZ2NnQkNnQ0FFOEVRRUVBSVFvZ0FDQUhUdzBDSUFVZ0Jpa0NHRGNER0NBRklBWXBBaEEzQXhBZ0JTQUdLUUlJTndNSUlBVWdCaWtDQURjREFDQUdJQWtwQWhnM0FoZ2dCaUFKS1FJUU53SVFJQVlnQ1NrQ0NEY0NDQ0FHSUFrcEFnQTNBZ0FnQ1NBRktRTVlOd0lZSUFrZ0JTa0RFRGNDRUNBSklBVXBBd2czQWdnZ0NTQUZLUU1BTndJQVFRRWhDaUFHS0FJQUlBUW9BZ0JQRFFJZ0JTQUVLUUlZTndNWUlBVWdCQ2tDRURjREVDQUZJQVFwQWdnM0F3Z2dCU0FFS1FJQU53TUFJQVFnQmlrQ0dEY0NHQ0FFSUFZcEFoQTNBaEFnQkNBR0tRSUlOd0lJSUFRZ0Jpa0NBRGNDQUNBR0lBVXBBeGczQWhnZ0JpQUZLUU1RTndJUUlBWWdCU2tEQ0RjQ0NDQUdJQVVwQXdBM0FnQU1BUXNnQUNBSFNRUkFJQVVnQkNrQ0dEY0RHQ0FGSUFRcEFoQTNBeEFnQlNBRUtRSUlOd01JSUFVZ0JDa0NBRGNEQUNBRUlBa3BBaGczQWhnZ0JDQUpLUUlRTndJUUlBUWdDU2tDQ0RjQ0NDQUVJQWtwQWdBM0FnQWdDU0FGS1FNWU53SVlJQWtnQlNrREVEY0NFQ0FKSUFVcEF3ZzNBZ2dnQ1NBRktRTUFOd0lBUVFFaENnd0NDeUFGSUFRcEFoZzNBeGdnQlNBRUtRSVFOd01RSUFVZ0JDa0NDRGNEQ0NBRklBUXBBZ0EzQXdBZ0JDQUdLUUlZTndJWUlBUWdCaWtDRURjQ0VDQUVJQVlwQWdnM0FnZ2dCQ0FHS1FJQU53SUFJQVlnQlNrREdEY0NHQ0FHSUFVcEF4QTNBaEFnQmlBRktRTUlOd0lJSUFZZ0JTa0RBRGNDQUVFQklRb2dDU2dDQUNBR0tBSUFUdzBCSUFVZ0Jpa0NHRGNER0NBRklBWXBBaEEzQXhBZ0JTQUdLUUlJTndNSUlBVWdCaWtDQURjREFDQUdJQWtwQWhnM0FoZ2dCaUFKS1FJUU53SVFJQVlnQ1NrQ0NEY0NDQ0FHSUFrcEFnQTNBZ0FnQ1NBRktRTVlOd0lZSUFrZ0JTa0RFRGNDRUNBSklBVXBBd2czQWdnZ0NTQUZLUU1BTndJQUMwRUNJUW9MSUFOQkFXc2hBeUFKSVFBZ0JDZ0NBQ0lJSUFZb0FnQWlCMDhFUUFOQUlBQkJJR3NpQUNBRVJnUkFJQVJCSUdvaEJ5QUlJQWtvQWdCSkRRVWdCeUFKUmcwR0EwQWdCeWdDQUNBSVN3UkFJQVVnQnlrQ0dEY0RHQ0FGSUFjcEFoQTNBeEFnQlNBSEtRSUlOd01JSUFVZ0J5a0NBRGNEQUNBSElBa3BBaGczQWhnZ0J5QUpLUUlRTndJUUlBY2dDU2tDQ0RjQ0NDQUhJQWtwQWdBM0FnQWdDU0FGS1FNWU53SVlJQWtnQlNrREVEY0NFQ0FKSUFVcEF3ZzNBZ2dnQ1NBRktRTUFOd0lBSUFkQklHb2hCd3dIQ3lBSFFTQnFJZ2NnQ1VjTkFBc01CZ3NnQUNnQ0FDQUhUdzBBQ3lBRklBUXBBaGczQXhnZ0JTQUVLUUlRTndNUUlBVWdCQ2tDQ0RjRENDQUZJQVFwQWdBM0F3QWdCQ0FBS1FJWU53SVlJQVFnQUNrQ0VEY0NFQ0FFSUFBcEFnZzNBZ2dnQkNBQUtRSUFOd0lBSUFBZ0JTa0RHRGNDR0NBQUlBVXBBeEEzQWhBZ0FDQUZLUU1JTndJSUlBQWdCU2tEQURjQ0FDQUtRUUZxSVFvTElBUkJJR29pQnlBQVR3MEJBMEFnQmlnQ0FDRU1BMEFnQnlJSVFTQnFJUWNnQ0NnQ0FDQU1TUTBBQ3dOQUlBQkJJR3NpQUNnQ0FDQU1UdzBBQ3lBQUlBaEpCRUFnQ0NFSERBTUZJQVVnQ0NrQ0dEY0RHQ0FGSUFncEFoQTNBeEFnQlNBSUtRSUlOd01JSUFVZ0NDa0NBRGNEQUNBSUlBQXBBaGczQWhnZ0NDQUFLUUlRTndJUUlBZ2dBQ2tDQ0RjQ0NDQUlJQUFwQWdBM0FnQWdBQ0FGS1FNWU53SVlJQUFnQlNrREVEY0NFQ0FBSUFVcEF3ZzNBZ2dnQUNBRktRTUFOd0lBSUFBZ0JpQUdJQWhHR3lFR0lBcEJBV29oQ2d3QkN3QUxBQXNnQkNBRVFTQnFJQVJCUUdzZ0FVRWdheEFmR2d3Q0N3SkFJQVlnQjBZTkFDQUdLQUlBSUFjb0FnQlBEUUFnQlNBSEtRSVlOd01ZSUFVZ0J5a0NFRGNERUNBRklBY3BBZ2czQXdnZ0JTQUhLUUlBTndNQUlBY2dCaWtDR0RjQ0dDQUhJQVlwQWhBM0FoQWdCeUFHS1FJSU53SUlJQWNnQmlrQ0FEY0NBQ0FHSUFVcEF4ZzNBaGdnQmlBRktRTVFOd0lRSUFZZ0JTa0RDRGNDQ0NBR0lBVXBBd0EzQWdBZ0NrRUJhaUVLQ3lBS1JRUkFJQVFnQnhCRklRWWdCMEVnYWlJQUlBRVFSUVJBSUFRaEFDQUhJUUVnQmtVTkJnd0RDeUFHRFFRTElBY2dCR3NnQVNBSGEwZ0VRQ0FFSUFjZ0FpQURFQ3dnQjBFZ2FpRUFEQVFMSUFkQklHb2dBU0FDSUFNUUxDQUVJUUFnQnlFQkRBUUxJQWtpQUNBSFJnMEFBMEFnQkNnQ0FDRUlBMEFnQnlJR1FTQnFJUWNnQ0NBR0tBSUFUdzBBQ3dOQUlBZ2dBRUVnYXlJQUtBSUFTUTBBQ3lBQUlBWk5CRUFnQmlFRURBTUZJQVVnQmlrQ0dEY0RHQ0FGSUFZcEFoQTNBeEFnQlNBR0tRSUlOd01JSUFVZ0Jpa0NBRGNEQUNBR0lBQXBBaGczQWhnZ0JpQUFLUUlRTndJUUlBWWdBQ2tDQ0RjQ0NDQUdJQUFwQWdBM0FnQWdBQ0FGS1FNWU53SVlJQUFnQlNrREVEY0NFQ0FBSUFVcEF3ZzNBZ2dnQUNBRktRTUFOd0lBREFFTEFBc0FDd3NMQ3lBRlFTQnFKQUFMSFFBZ0FRUkFJQUFnQVNnQ0FCQXRJQUFnQVNnQ0JCQXRJQUVRRVFzTGJRQkIxS2NJUVFRMkFnQkIyS2NJUVFBMkFnQkJxd2hCQWtHVUQwR0FFRUVCUVFKQkFCQUhRZGluQ0VIY3B3Z29BZ0EyQWdCQjNLY0lRZFNuQ0RZQ0FFSGdwd2hCRFRZQ0FFSGtwd2hCQURZQ0FCQStRZVNuQ0VIY3B3Z29BZ0EyQWdCQjNLY0lRZUNuQ0RZQ0FBc3FBQ0FCUVFKMFFReHFJZ0VnQVVFQUlBQkJnSUFJUmlJQkd5QUFRWUNBQkVZYlFReEJBQ0FCRzJvTEhBQWdBQ0FCUVFnZ0FxY2dBa0lnaUtjZ0E2Y2dBMElnaUtjUURBc0xBQ0FBRURJYUlBQVFFUXN5QVFKL0lBQkIzS1FJTmdJQUlBQW9BZ1JCREdzaUFTQUJLQUlJUVFGcklnSTJBZ2dnQWtFQVNBUkFJQUVRRVFzZ0FBdXNBZ0VHZndKQUlBQW9BZ2dpQkVFQmFpSURJQUFvQWdRaUJVc05BQ0FBS0FJQUlnWWdCR29zQUFBaEFpQUFJQU0yQWdnZ0FrR0FmMFlOQUNBQkFuOGdBa0gvQUhFaUFTQUNRUUJPRFFBYUlBUkJBbW9pQWlBRlN3MEJJQU1nQm1vc0FBQWhBeUFBSUFJMkFnZ2dBMEgvQUhFZ0FVRUhkSElpQVNBRFFRQk9EUUFhSUFSQkEyb2lBeUFGU3cwQklBSWdCbW9zQUFBaEFpQUFJQU0yQWdnZ0FrSC9BSEVnQVVFSGRISWlBU0FDUVFCT0RRQWFJQVJCQkdvaUFpQUZTdzBCSUFNZ0Jtb3NBQUFoQXlBQUlBSTJBZ2dnQTBIL0FIRWdBVUVIZEhJaUFTQURRUUJPRFFBYUlBVWdCRUVGYWlJRlNRMEJJQUlnQm1vc0FBQWhCQ0FBSUFVMkFnZ2dBVUgvLy84UFN3MEJJQVJCQUVnTkFTQUVRZjhBY1NBQlFRZDBjZ3MyQWdCQkFTRUhDeUFIQzVvQkFDQUFRUUU2QURVQ1FDQUFLQUlFSUFKSERRQWdBRUVCT2dBMEFrQWdBQ2dDRUNJQ1JRUkFJQUJCQVRZQ0pDQUFJQU0yQWhnZ0FDQUJOZ0lRSUFOQkFVY05BaUFBS0FJd1FRRkdEUUVNQWdzZ0FTQUNSZ1JBSUFBb0FoZ2lBa0VDUmdSQUlBQWdBellDR0NBRElRSUxJQUFvQWpCQkFVY05BaUFDUVFGR0RRRU1BZ3NnQUNBQUtBSWtRUUZxTmdJa0N5QUFRUUU2QURZTEMxMEJBWDhnQUNnQ0VDSURSUVJBSUFCQkFUWUNKQ0FBSUFJMkFoZ2dBQ0FCTmdJUUR3c0NRQ0FCSUFOR0JFQWdBQ2dDR0VFQ1J3MEJJQUFnQWpZQ0dBOExJQUJCQVRvQU5pQUFRUUkyQWhnZ0FDQUFLQUlrUVFGcU5nSWtDd3U2QWdFRGZ5TUFRVUJxSWdJa0FDQUFLQUlBSWdOQkJHc29BZ0FoQkNBRFFRaHJLQUlBSVFNZ0FrSUFOd0lnSUFKQ0FEY0NLQ0FDUWdBM0FqQWdBa0lBTndBM0lBSkNBRGNDR0NBQ1FRQTJBaFFnQWtHWW53ZzJBaEFnQWlBQU5nSU1JQUlnQVRZQ0NDQUFJQU5xSVFCQkFDRURBa0FnQkNBQlFRQVFGZ1JBSUFKQkFUWUNPQ0FFSUFKQkNHb2dBQ0FBUVFGQkFDQUVLQUlBS0FJVUVRb0FJQUJCQUNBQ0tBSWdRUUZHR3lFRERBRUxJQVFnQWtFSWFpQUFRUUZCQUNBRUtBSUFLQUlZRVFrQUFrQUNRQ0FDS0FJc0RnSUFBUUlMSUFJb0FoeEJBQ0FDS0FJb1FRRkdHMEVBSUFJb0FpUkJBVVliUVFBZ0FpZ0NNRUVCUmhzaEF3d0JDeUFDS0FJZ1FRRkhCRUFnQWlnQ01BMEJJQUlvQWlSQkFVY05BU0FDS0FJb1FRRkhEUUVMSUFJb0FoZ2hBd3NnQWtGQWF5UUFJQU1MRGdBZ0FFSFFBR29RSFVIUUFHb0xBZ0FMRmdBZ0FoQVNJUUVnQUNBQ05nSUVJQUFnQVRZQ0FBdjlBZ0VGZnlNQVFSQnJJZ2drQUNBQ0lBRkJmM05CNy8vLy93ZHFUUVJBQW44Z0FDMEFDMEVIZGdSQUlBQW9BZ0FNQVFzZ0FBc2hDaUFJUVFScUlna2dBQ0FCUWVmLy8vOERTUVIvSUFnZ0FVRUJkRFlDRENBSUlBRWdBbW8yQWdRakFFRVFheUlDSkFBZ0NTZ0NBQ0FJUVF4cUlnc29BZ0JKSVF3Z0FrRVFhaVFBSUFzZ0NTQU1HeWdDQUNJQ1FRdFBCSDhnQWtFUWFrRndjU0lDSUFKQkFXc2lBaUFDUVF0R0d3VkJDZ3RCQVdvRlFlLy8vLzhIQ3hBNUlBZ29BZ1FoQWlBSUtBSUlHaUFFQkVBZ0FpQUtJQVFRR3dzZ0JnUkFJQUlnQkdvZ0J5QUdFQnNMSUFNZ0JDQUZhaUlKYXlFSElBTWdDVWNFUUNBQ0lBUnFJQVpxSUFRZ0Ntb2dCV29nQnhBYkN5QUJRUXBIQkVBZ0NoQVJDeUFBSUFJMkFnQWdBQ0FBS0FJSVFZQ0FnSUI0Y1NBSUtBSUlRZi8vLy84SGNYSTJBZ2dnQUNBQUtBSUlRWUNBZ0lCNGNqWUNDQ0FBSUFRZ0Jtb2dCMm9pQURZQ0JDQUlRUUE2QUF3Z0FDQUNhaUFJTFFBTU9nQUFJQWhCRUdva0FBOExFQ2NBQ3k0QkFYOGpBRUVRYXlJREpBQWdBQ0FDRUNZZ0EwRUFPZ0FQSUFFZ0Ftb2dBeTBBRHpvQUFDQURRUkJxSkFBTFlRRURmMEVJRURjaUFVSHNvd2cyQWdBZ0FVSGNwQWcyQWdBZ0FCQTlJZ0pCRFdvUUVpSURRUUEyQWdnZ0F5QUNOZ0lFSUFNZ0FqWUNBQ0FCSUFOQkRHb2dBQ0FDUVFGcUVCTTJBZ1FnQVVHTXBRZzJBZ0FnQVVHc3BRaEJBeEFGQUF0NkFRTi9Ba0FDUUNBQUlnRkJBM0ZGRFFBZ0FTMEFBRVVFUUVFQUR3c0RRQ0FCUVFGcUlnRkJBM0ZGRFFFZ0FTMEFBQTBBQ3d3QkN3TkFJQUVpQWtFRWFpRUJJQUlvQWdBaUEwRi9jeUFEUVlHQ2hBaHJjVUdBZ1lLRWVIRkZEUUFMQTBBZ0FpSUJRUUZxSVFJZ0FTMEFBQTBBQ3dzZ0FTQUFhd3VGQkFCQmlLRUlRZDBKRUFsQmxLRUlRZG9JUVFGQkFCQUlRYUNoQ0VIR0NFRUJRWUIvUWY4QUVBRkJ1S0VJUWI4SVFRRkJnSDlCL3dBUUFVR3NvUWhCdlFoQkFVRUFRZjhCRUFGQnhLRUlRWWtJUVFKQmdJQitRZi8vQVJBQlFkQ2hDRUdBQ0VFQ1FRQkIvLzhERUFGQjNLRUlRWmdJUVFSQmdJQ0FnSGhCLy8vLy93Y1FBVUhvb1FoQmp3aEJCRUVBUVg4UUFVSDBvUWhCalFsQkJFR0FnSUNBZUVILy8vLy9CeEFCUVlDaUNFR0VDVUVFUVFCQmZ4QUJRWXlpQ0VHakNFS0FnSUNBZ0lDQWdJQi9Rdi8vLy8vLy8vLy8vd0FRTUVHWW9naEJvZ2hDQUVKL0VEQkJwS0lJUVp3SVFRUVFCRUd3b2doQjFnbEJDQkFFUWZnUFFhd0pFQU5CckprSVFla05FQU5COUprSVFRUkJrZ2tRQWtIQW1naEJBa0c0Q1JBQ1FZeWJDRUVFUWNjSkVBSkJzQTlCM3dnUUQwRzBtd2hCQUVHa0RSQUFRZHliQ0VFQVFZb09FQUJCcEJCQkFVSENEUkFBUVlTY0NFRUNRZkVKRUFCQnJKd0lRUU5Ca0FvUUFFSFVuQWhCQkVHNENoQUFRZnljQ0VFRlFkVUtFQUJCcEowSVFRUkJydzRRQUVITW5RaEJCVUhORGhBQVFkeWJDRUVBUWJzTEVBQkJwQkJCQVVHYUN4QUFRWVNjQ0VFQ1FmMExFQUJCckp3SVFRTkIyd3NRQUVIVW5BaEJCRUdERFJBQVFmeWNDRUVGUWVFTUVBQkI5SjBJUVFoQndBd1FBRUdjbmdoQkNVR2VEQkFBUWNTZUNFRUdRZnNLRUFCQjdKNElRUWRCOUE0UUFBdTBDQUVUZnlNQVFSQnJJZ2NrQUFKL0FrQUNRQ0FBS0FMUUFTSU1RUUpKRFFBZ0FDZ0NzQUVoQ0NBQUtBS3NBU0VKSUFBb0FoUWhEU0FBS0FJUUlRNGdBRUVJYWlJR0tBSUFJZzhoQkNBQUtBSU1JZ29oQlFKQUFrQWdDa0VTYTBFT1RRUkFJQTRoQXlBS0lRRWdEU0VDQTBBZ0FrVU5BaUFBSUFSQkNIWWlCRFlDQ0NBRExRQUFJUXNnQUNBQ1FRRnJJZ0kyQWhRZ0FDQUJRUWhySWdVMkFnd2dBQ0FEUVFGcUlnTTJBaEFnQUNBTFFSaDBJQVJ5SWdRMkFnZ2dBVUVhYXlFUUlBVWhBU0FRUVE5SkRRQUxDeUFBSUFrZ0JDQUZkaUlCUWY4QmNVRUNkR29pQWkwQUFDSURRUWxQQkg4Z0JVRUlhaUVGSUFJZ0FpOEJBa0VDZEdvZ0EwRUNkRUd3R1dvb0FnQWdBVUVJZG5GQi93QnhRUUowYWlJQ0xRQUFCU0FEQzBIL0FYRWdCV28yQWd3Z0J5QUNMd0VDTmdJSURBRUxJQWtnQmlBSFFRaHFFQlZGRFFFTEFrQUNmeUFBS0FMWUprVUVRQUpBQWtBZ0FDZ0NEQ0lCUVJKclFROVBCRUFnQmlnQ0FDRUVEQUVMSUFBb0FoUWhBaUFCSVFNRFFDQUNSUTBDSUFBZ0FDZ0NDRUVJZGlJRU5nSUlJQUFvQWhBaUJTMEFBQ0VKSUFBZ0FrRUJheUlDTmdJVUlBQWdBMEVJYXlJQk5nSU1JQUFnQlVFQmFqWUNFQ0FBSUFsQkdIUWdCSElpQkRZQ0NDQURRUnBySVJFZ0FTRURJQkZCRDBrTkFBc0xJQWdnQkNBQmRpSUVRZjhCY1VFQ2RHb2lBaTBBQUNJRFFRbFBCRUFnQWlBQ0x3RUNRUUowYWlBRFFRSjBRYkFaYWlnQ0FDQUVRUWgyY1VIL0FIRkJBblJxSWdJdEFBQWhBeUFCUVFocUlRRUxJQUFnQVNBRFFmOEJjV28yQWd3Z0FpOEJBZ3dDQ3lBSUlBWWdCMEVNYWhBVlJRMENJQWNvQWd3TUFRc2dBQ2dDd0FFTElnVkJBblJCNEJocUxRQUNJZ2hCSUNBQUtBSU1JZ0ZyVFFSQUlBWW9BZ0FoQkF3REN5QUFLQUlVSVFJZ0FTRURBMEFnQWdSQUlBQWdBQ2dDQ0VFSWRpSUVOZ0lJSUFBb0FoQWlCaTBBQUNFSklBQWdBa0VCYXlJQ05nSVVJQUFnQTBFSWF5SUJOZ0lNSUFBZ0JrRUJhallDRUNBQUlBbEJHSFFnQkhJaUJEWUNDRUVvSUFOcklSSWdBU0VESUJJZ0NFa05BUXdFQ3dzZ0FDQUZOZ0xBQVFzZ0FDQU5OZ0lVSUFBZ0RqWUNFQ0FBSUE4MkFnZ2dBRUVBTmdMWUppQUFJQW8yQWd3TFFRQU1BUXNnQUVFQU5nTFlKaUFBSUFFZ0NHbzJBZ3dnQUNBRlFRSjBRZUFZYWk4QkFDQUlRUUowUWRBWmFpZ0NBQ0FFSUFGMmNXbzJBc1FCQW44Q1FBSkFBa0FnQnlnQ0NDSUJEZ0lBQWdFTElBQW9BdHdCREFJTElBRkJBbXNNQVFzZ0FDZ0M0QUZCQVdvTElRSWdBQ0FBS0FMZ0FUWUMzQUVnQUNBQ0lBeEJBQ0FDSUF4UEcyc2lBVFlDNEFFZ0FDQUFLQUxzSmlBQlFRWjBhaUlETmdKMElBQWdBQ0FCUVFOMlFmei8vLzhCY1dwQi9DWnFLQUlBSUFGMlFRRnhOZ0swQVNBQUlBQW9BbndnQXkwQUFFRUNkR29vQWdBMkFvZ0NJQUFnQUNnQzhDWWdBV290QUFCQkEzRkJDWFJCZ0J0cU5nSndRUUVMSVJNZ0IwRVFhaVFBSUJNTDRBY0JESDhnQUNnQzBBRWlCMEVDVHdSQUlBQW9BcXdCSVF3Z0FDZ0NDQ0VDSUFBb0Fnd2lBVUVRVHdSQUlBQWdBVUVRY3lJQk5nSU1JQUFnQWtFUWRpSUNOZ0lJSUFBb0FoQWlBeThBQUNFRklBQWdBQ2dDRkVFQ2F6WUNGQ0FBSUFOQkFtbzJBaEFnQUNBRlFSQjBJQUp5SWdJMkFnZ0xJQUFvQXJBQklRVWdEQ0FDSUFGMklnWkIvd0Z4UVFKMGFpSURMUUFBSWdSQkNVOEVRQ0FESUFNdkFRSkJBblJxSUFSQkFuUkJzQmxxS0FJQUlBWkJDSFp4UVFKMGFpSURMUUFBSVFRZ0FVRUlhaUVCQ3lBREx3RUNJUWdnQVNBRVFmOEJjV29pQVVFUVR3UkFJQUFnQVVFUWN5SUJOZ0lNSUFBZ0FrRVFkaUlDTmdJSUlBQW9BaEFpQkM4QUFDRURJQUFnQUNnQ0ZFRUNhellDRkNBQUlBUkJBbW8yQWhBZ0FDQURRUkIwSUFKeUlnSTJBZ2dMSUFVZ0FpQUJkaUlHUWY4QmNVRUNkR29pQXkwQUFDSUVRUWxQQkVBZ0F5QURMd0VDUVFKMGFpQUVRUUowUWJBWmFpZ0NBQ0FHUVFoMmNVRUNkR29pQXkwQUFDRUVJQUZCQ0dvaEFRc2dBeThCQWlJRFFRSjBRZUFZYWlJRkx3RUFJUXNnQlMwQUFpRUZJQUVnQkVIL0FYRnFJUUVnQUFKL0lBTkJHVWNFUUNBQlFSQlBCRUFnQUNBQlFSQnpJZ0UyQWd3Z0FDQUNRUkIySWdJMkFnZ2dBQ2dDRUNJRUx3QUFJUU1nQUNBQUtBSVVRUUpyTmdJVUlBQWdCRUVDYWpZQ0VDQUFJQU5CRUhRZ0FuSWlBallDQ0FzZ0FDQUJJQVZxTmdJTUlBVkJBblJCMEJscUtBSUFJQUlnQVhaeERBRUxBa0FDUUNBQlFROU5CRUFnQWtFUWRpRURJQUZCRUdvaEJDQUNJQUYyUWYvL0EzRWhDU0FBS0FJVUlRb2dBQ2dDRUNFQkRBRUxJQUFnQVVFUWN5SUdOZ0lNSUFBZ0FrRVFkaUlDTmdJSUlBQW9BaEFpQVM4QUFDRURJQUFnQUNnQ0ZFRUNheUlLTmdJVUlBQWdBVUVDYWlJQk5nSVFJQUFnQTBFUWRDQUNjaUlDTmdJSUlBSWdCblpCLy84RGNTRUpJQVpCRUdvaEJDQUdRVzlMRFFFTElBQWdBellDQ0NBQUlBUkJFSE1pQkRZQ0RDQUJMd0FBSVFJZ0FDQUtRUUpyTmdJVUlBQWdBVUVDYWpZQ0VDQUFJQUpCRUhRZ0EzSWlBallDQ0FzZ0FDQUVJQVZCRUdzaUFXbzJBZ3dnQVVFQ2RFSFFHV29vQWdBZ0FpQUVkbkZCRUhRZ0NYSUxJQXRxTmdMRUFRSi9Ba0FDUUFKQUlBZ09BZ0VBQWdzZ0FDZ0M0QUZCQVdvTUFnc2dBQ2dDM0FFTUFRc2dDRUVDYXdzaEFpQUFJQUFvQXVBQk5nTGNBU0FBSUFJZ0IwRUFJQUlnQjA4YmF5SUJOZ0xnQVNBQUlBQW9BdXdtSUFGQkJuUnFJZ0kyQW5RZ0FDQUFJQUZCQTNaQi9QLy8vd0Z4YWtIOEptb29BZ0FnQVhaQkFYRTJBclFCSUFBZ0FDZ0NmQ0FDTFFBQVFRSjBhaWdDQURZQ2lBSWdBQ0FBS0FMd0ppQUJhaTBBQUVFRGNVRUpkRUdBRzJvMkFuQUxDN01CQVFKL0lBQW9BdVFtSWdJZ0FDZ0NRRWNFUUNBQUtBSmtJUUVnQUNBQUtBSWdJQUpCS21vZ0FDZ0NHQkVDQUNJQ05nSmtJQUpGQkVBZ0FDQUJOZ0prUVFBUEN5QUFLQUxrSmlBQ2FrRUNhMEVBT2dBQUlBQW9BdVFtSUFBb0FtUnFRUUZyUVFBNkFBQWdBUVJBSUFBb0FtUWdBU0FBS0FJMEVCTWFJQUFvQWlBZ0FTQUFLQUljRVFFQUN5QUFJQUFvQXVRbUlnRTJBa0FnQUNBQlFRRnJOZ0pFSUFBZ0FTQUFLQUprYWpZQ2FBdEJBUXU3RFFFTmZ5TUFRUkJySWc4a0FDQURRUWhxSVF0QllTRUVBa0FDUUFKQUFuOENRQUpBQWtBQ1FBSkFJQU1vQXNnbURnVUNBd0VBQmdnTElBTW9BcHdRREFRTElBTW9BcGdRSVFRTUFnc2dBeUFMSUFFUVF5SUVRUUZIRFFVZ0FTQUJLQUlBUVFGcU5nSUFJQU5CQURZQ2xCQWdBaUFES0FJZ0lBQWdBeWdDR0JFQ0FDSUdOZ0lBSUFaRkJFQkJaeUVFREFZTFFRRWhCQ0FCS0FJQVFRRk5CRUFnQmlBQUVCUWFEQVlMSUFOQkFUWUN5Q1lMQWtBZ0F5Z0NEQ0lFUVJ4clFRVlBCRUFnQ3lnQ0FDRUdEQUVMSUFNb0FoUWlDa1VFUUVFQ0lRUU1CZ3NnQXlBREtBSUlRUWgySWdrMkFnZ2dBeWdDRUNJSExRQUFJUVlnQXlBS1FRRnJOZ0lVSUFNZ0IwRUJhallDRUNBRElBWkJHSFFnQ1hJaUJqWUNDQ0FFUVFocklRUUxJQU5CQWpZQ3lDWWdBeUFFUVFWQkFTQUdJQVIySWdkQkFYRWlCaHRxTmdJTUlBTWdCMEVCZGtFUGNVRUJha0VBSUFacmNTSUVOZ0tZRUFzZ0JDQUJLQUlBYWlJQklBRWdBMEdnRUdwQkFDQURFQ0lpQkVFQlJ3MERJQU5CQXpZQ3lDWWdBMEgvL3dNMkFwd1FRZi8vQXdzaEJTQUNLQUlBSVF3Z0F5Z0NtQkFoRFNBREtBS1VFQ0VJSUE4Z0JUWUNEQ0FGUWYvL0EwWWdBQ0FJVFhFTkFDQUZRZi8vQTBjaEFTQURRYUFRYWlFT0EwQWdBeWdDRENFRUFuOENRQUpBSUFGQkFYRkZCRUFDUUFKQUFrQWdCRUVTYTBFUFR3UkFJQXNvQWdBaENRd0JDeUFES0FJVUlRRWdCQ0VHQTBBZ0FVVU5BaUFESUFNb0FnaEJDSFlpQ2pZQ0NDQURLQUlRSWdrdEFBQWhCeUFESUFGQkFXc2lBVFlDRkNBRElBWkJDR3NpQkRZQ0RDQURJQWxCQVdvMkFoQWdBeUFIUVJoMElBcHlJZ2syQWdnZ0JrRWFheUVRSUFRaEJpQVFRUTlKRFFBTEN5QURJQTRnQ1NBRWRpSUdRZjhCY1VFQ2RHb2lBUzBBQUNJSFFRbFBCSDhnQkVFSWFpRUVJQUVnQVM4QkFrRUNkR29nQjBFQ2RFR3dHV29vQWdBZ0JrRUlkbkZCL3dCeFFRSjBhaUlCTFFBQUJTQUhDMEgvQVhFZ0JHbzJBZ3dnRHlBQkx3RUNJZ1UyQWd3TUFRc2dEaUFMSUE5QkRHb1FGVVVFUUVILy93TWhCUXdJQ3lBUEtBSU1JUVVMSUFWRkJFQkJBQ0VGSUFnZ0RHcEJBRG9BQUF3REN5QUZJQTFMRFFFZ0F5Z0NEQ0VFQ3dKQUlBVkJJQ0FFYTAwRVFDQUxLQUlBSVFrTUFRc2dBeWdDRkNFQklBUWhCZ05BSUFGRkRRY2dBeUFES0FJSVFRaDJJZ28yQWdnZ0F5Z0NFQ0lKTFFBQUlRY2dBeUFCUVFGcklnRTJBaFFnQXlBR1FRaHJJZ1EyQWd3Z0F5QUpRUUZxTmdJUUlBTWdCMEVZZENBS2NpSUpOZ0lJUVNnZ0Jtc2hCeUFFSVFZZ0JTQUhTdzBBQ3dzZ0F5QUVJQVZxTmdJTUlBQWdCVUVDZEVIUUdXb29BZ0FnQ1NBRWRuRkJBU0FGZEdvaUJpQUlhaUlCU1FSQVFYZ2hCQXdIQ3lBSUlBeHFJQVlRRkJvZ0FRd0NDeUFJSUF4cUlBVWdEV3M2QUFBTElBaEJBV29MSVFoQkFDRUJJQUFnQ0VzTkFBc0xBa0FDUUNBREtBSU1JZ0ZCSUVjRVFDQUxLQUlBSVFnTUFRc2dBeWdDRkNJSFJRUkFRUUloQkVFRUlRWU1BZ3NnQXlBREtBSUlRUWgySWdRMkFnZ2dBeWdDRUNJQkxRQUFJUVlnQXlBSFFRRnJOZ0lVSUFNZ0FVRUJhallDRUVFWUlRRWdBeUFHUVJoMElBUnlJZ2cyQWdnTFFRRWhCQ0FESUFGQkFXbzJBZ3hCQUNFR0lBZ2dBWFpCQVhGRkRRQWdBaWdDQUNFT1FZQ0NpQmdoQ2lBRFFjQWthaUlJUVlDQ2lCZzJBZ0JCQVNFRlFRSWdBeWdDdUNSQkFXb2lBU0FCUVFKTkd5SUNRUUZySWdGQkEzRWhCeUFDUVFKclFRTlBCRUFnQVVGOGNTRUJRUUFoQWdOQUlBZ2dCVUVDZEdvaUNTQUtRWVNJa0NCcU5nSUFJQWtnQ2tHSWtLREFBR28yQWdRZ0NTQUtRWXlZc09BQWFqWUNDQ0FKSUFwQmtLREFnQUZxSWdvMkFnd2dCVUVFYWlFRklBSkJCR29pQWlBQlJ3MEFDd3NnQndSQVFRQWhEQU5BSUFnZ0JVRUNkR29nQ2tHRWlKQWdhaUlLTmdJQUlBVkJBV29oQlNBTVFRRnFJZ3dnQjBjTkFBc0xBa0FnQUVVRVFDQURRUUEyQXJna0RBRUxJQUJCQVhFaEJ5QURRYjhrYWlFTEFrQWdBRUVCUmdSQVFRQWhCVUVBSVEwTUFRc2dBRUYrY1NFQ1FRQWhCVUVBSVExQkFDRU1BMEFnQlNBT2FpSUFJQWdnQUMwQUFDSUthaTBBQUNJQU9nQUFJQXNnQURvQUFDQU9JQVZCQVhKcUlnQWdDQ0FMSUFwQkFXb1FIaUlCSUFBdEFBQWlDV290QUFBaUFEb0FBQ0FMSUFBNkFBQWdBU0FMSUFsQkFXb1FIaG9nQ1NBS0lBMXljaUVOSUFWQkFtb2hCU0FNUVFKcUlnd2dBa2NOQUFzTElBTWdCd1IvSUFVZ0Rtb2lBQ0FJSUFBdEFBQWlBV290QUFBaUFEb0FBQ0FMSUFBNkFBQWdDQ0FMSUFGQkFXb1FIaG9nQVNBTmNnVWdEUXRCQW5ZMkFyZ2tDd3NnQXlBR05nTElKZ3dCQ3lBRElBZzJBcFFRSUFNZ0JUWUNuQkJCQWlFRUN5QVBRUkJxSkFBZ0JBdTNCQUVIZjBGaElRTUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUlBQW9BdFFtRGdNQkFnQUZDeUFDS0FJQUlRWU1Bd3NDUUNBQktBSUVJZ1JCSUVjRVFDQUJLQUlBSVFVTUFRc2dBU2dDRENJRVJRUkFRUUlQQ3lBQklBRW9BZ0JCQ0hZaUJUWUNBQ0FCS0FJSUlnTXRBQUFoQmlBQklBUkJBV3MyQWd3Z0FTQURRUUZxTmdJSVFSZ2hCQ0FCSUFaQkdIUWdCWElpQlRZQ0FBc2dBU0FFUVFGcUlnTTJBZ1FnQlNBRWRrRUJjUTBCSUFKQkFEWUNBRUVCRHdzZ0FTZ0NCQ0VEQ3dKQUlBTkJIbXRCQTA4RVFDQUJLQUlBSVFRTUFRc2dBU2dDRENJRVJRMERJQUVnQVNnQ0FFRUlkaUlGTmdJQUlBRW9BZ2dpQmkwQUFDRUhJQUVnQkVFQmF6WUNEQ0FCSUFaQkFXbzJBZ2dnQVNBSFFSaDBJQVZ5SWdRMkFnQWdBMEVJYXlFREN5QUJJQU5CQTJvMkFnUWdCQ0FEZGtFSGNTSUdSUVJBSUFKQkFUWUNBQ0FBUVFBMkF0UW1RUUVQQ3lBQ0lBWTJBZ0FMQWtBZ0JrRWdJQUVvQWdRaUJXdE5CRUFnQVNnQ0FDRUhEQUVMSUFFb0Fnd2hBeUFGSVFRRFFDQURSUTBFSUFFZ0FTZ0NBRUVJZGlJSE5nSUFJQUVvQWdnaUNDMEFBQ0VKSUFFZ0EwRUJheUlETmdJTUlBRWdCRUVJYXlJRk5nSUVJQUVnQ0VFQmFqWUNDQ0FCSUFsQkdIUWdCM0lpQnpZQ0FFRW9JQVJySVFnZ0JTRUVJQVlnQ0VzTkFBc0xJQUVnQlNBR2FqWUNCRUVCSVFNZ0FpQUdRUUowUWRBWmFpZ0NBQ0FISUFWMmNVRUJJQUlvQWdCMGFqWUNBQ0FBUVFBMkF0UW1DeUFERHdzZ0FFRUJOZ0xVSmtFQ0R3c2dBRUVDTmdMVUprRUNDNkVIQVFsL0lBTW9BZ2dpQlNBREtBSVFJQVJCQTJ4cUlnUXRBQUpCQVhScUx3RUFJUTBnQkMwQUFTRUdBa0FnQXlnQ0JDSUxJQVVnQkMwQUFFRUJkR292QVFCcUlnUXRBQUFpQTBVRVFFRUFJUU1NQVFzZ0EwRURjU0VIUVFBaEJRSkFJQU5CQkVrRVFFRUFJUU1NQVFzZ0EwSDhBWEVoQ1VFQUlRTURRQ0FBSUFOcUlBUXRBQUU2QUFBZ0FDQURRUUZ5YWlBRUxRQUNPZ0FBSUFBZ0EwRUNjbW9nQkMwQUF6b0FBQ0FBSUFOQkEzSnFJQVF0QUFRNkFBQWdBMEVFYWlFRElBUkJCR29oQkNBSVFRUnFJZ2dnQ1VjTkFBc0xJQWRGRFFBRFFDQUFJQU5xSUFRdEFBRTZBQUFnQTBFQmFpRURJQVJCQVdvaEJDQUZRUUZxSWdVZ0IwY05BQXNMQWtBZ0JrRUpUUVJBSUFJZ0Jtc2hBZ3dCQ3lBR1FReHJRZjhCY1VFSVN3MEFJQUlnQmtFTGF5SUVheUVDSUFFZ0JHb2hBUXNDUUNBQ1FRQk1EUUFnQWtFRGNTRUhRUUFoQ0FKQUlBSkJCRWtFUUVFQUlRUU1BUXNnQWtGOGNTRU1RUUFoQkVFQUlRa0RRQ0FBSUFOcUlnVWdBU0FFYWkwQUFEb0FBQ0FGSUFFZ0JFRUJjbW90QUFBNkFBRWdCU0FCSUFSQkFuSnFMUUFBT2dBQ0lBVWdBU0FFUVFOeWFpMEFBRG9BQXlBRFFRUnFJUU1nQkVFRWFpRUVJQWxCQkdvaUNTQU1SdzBBQ3dzZ0IwVU5BQU5BSUFBZ0Eyb2dBU0FFYWkwQUFEb0FBQ0FEUVFGcUlRTWdCRUVCYWlFRUlBaEJBV29pQ0NBSFJ3MEFDd3NnRFNBTGFpRUVBa0FDUUFKQUlBWkJDbXNPQWdBQkFnc2dBQ0FESUFKcmFpSUJMUUFBSWdKQnZ3Rk5CRUFnQWtIaEFHdEIvd0Z4UVJsTERRSWdBU0FDUVNCek9nQUFEQUlMSUFKQjN3Rk5CRUFnQVNBQkxRQUJRU0J6T2dBQkRBSUxJQUVnQVMwQUFrRUZjem9BQWd3QkN5QUNRUUJNRFFBZ0FDQURJQUpyYWlFQkEwQUNRQ0FCTFFBQUlnWkJ2d0ZOQkVCQkFTRUZJQVpCNFFCclFmOEJjVUVaU3cwQklBRWdCa0VnY3pvQUFBd0JDeUFHUWQ4QlRRUkFJQUVnQVMwQUFVRWdjem9BQVVFQ0lRVU1BUXNnQVNBQkxRQUNRUVZ6T2dBQ1FRTWhCUXNnQVNBRmFpRUJJQUlnQldzaUFrRUFTZzBBQ3dzQ1FDQUVMUUFBSWdKRkRRQUNRQ0FDUVFOeElnWkZCRUFnQWlFQkRBRUxRUUFoQlNBQ0lRRURRQ0FBSUFOcUlBUXRBQUU2QUFBZ0EwRUJhaUVESUFSQkFXb2hCQ0FCUVFGcklRRWdCVUVCYWlJRklBWkhEUUFMQ3lBQ1FRUkpEUUFEUUNBQUlBTnFJZ0lnQkMwQUFUb0FBQ0FDSUFRdEFBSTZBQUVnQWlBRUxRQURPZ0FDSUFJZ0JDMEFCRG9BQXlBRFFRUnFJUU1nQkVFRWFpRUVJQUZCQkdzaUFRMEFDd3NnQXd2VUVnRUhmeU1BUVNCcklnSWtBRUVCSVFVQ1FBSkFBa0FDUUFKQUFrQWdBU0FBYTBFRmRRNEdCUVVBQVFJREJBc2dBVUVnYXlJQktBSUFJQUFvQWdCUERRUWdBaUFBS1FJWU53TVlJQUlnQUNrQ0VEY0RFQ0FDSUFBcEFnZzNBd2dnQWlBQUtRSUFOd01BSUFBZ0FTa0NHRGNDR0NBQUlBRXBBaEEzQWhBZ0FDQUJLUUlJTndJSUlBQWdBU2tDQURjQ0FDQUJJQUlwQXhnM0FoZ2dBU0FDS1FNUU53SVFJQUVnQWlrRENEY0NDQ0FCSUFJcEF3QTNBZ0FNQkFzZ0FVRWdheUlCS0FJQUlRTWdBQ2dDSUNJRUlBQW9BZ0JQQkVBZ0F5QUVUdzBFSUFJZ0FDa0NPRGNER0NBQ0lBQXBBakEzQXhBZ0FpQUFLUUlvTndNSUlBSWdBQ2tDSURjREFDQUFJQUVwQWhnM0FqZ2dBQ0FCS1FJUU53SXdJQUFnQVNrQ0NEY0NLQ0FBSUFFcEFnQTNBaUFnQVNBQ0tRTVlOd0lZSUFFZ0Fpa0RFRGNDRUNBQklBSXBBd2czQWdnZ0FTQUNLUU1BTndJQUlBQW9BaUFnQUNnQ0FFOE5CQ0FDSUFBcEFoZzNBeGdnQWlBQUtRSVFOd01RSUFJZ0FDa0NDRGNEQ0NBQ0lBQXBBZ0EzQXdBZ0FDQUFLUUk0TndJWUlBQWdBQ2tDTURjQ0VDQUFJQUFwQWlnM0FnZ2dBQ0FBS1FJZ053SUFJQUFnQWlrREdEY0NPQ0FBSUFJcEF4QTNBakFnQUNBQ0tRTUlOd0lvSUFBZ0Fpa0RBRGNDSUF3RUN5QURJQVJKQkVBZ0FpQUFLUUlZTndNWUlBSWdBQ2tDRURjREVDQUNJQUFwQWdnM0F3Z2dBaUFBS1FJQU53TUFJQUFnQVNrQ0dEY0NHQ0FBSUFFcEFoQTNBaEFnQUNBQktRSUlOd0lJSUFBZ0FTa0NBRGNDQUNBQklBSXBBeGczQWhnZ0FTQUNLUU1RTndJUUlBRWdBaWtEQ0RjQ0NDQUJJQUlwQXdBM0FnQU1CQXNnQWlBQUtRSVlOd01ZSUFJZ0FDa0NFRGNERUNBQ0lBQXBBZ2czQXdnZ0FpQUFLUUlBTndNQUlBQWdBQ2tDT0RjQ0dDQUFJQUFwQWpBM0FoQWdBQ0FBS1FJb053SUlJQUFnQUNrQ0lEY0NBQ0FBSUFJcEF4ZzNBamdnQUNBQ0tRTVFOd0l3SUFBZ0Fpa0RDRGNDS0NBQUlBSXBBd0EzQWlBZ0FTZ0NBQ0FBS0FJZ1R3MERJQUlnQUNrQ09EY0RHQ0FDSUFBcEFqQTNBeEFnQWlBQUtRSW9Od01JSUFJZ0FDa0NJRGNEQUNBQUlBRXBBaGczQWpnZ0FDQUJLUUlRTndJd0lBQWdBU2tDQ0RjQ0tDQUFJQUVwQWdBM0FpQWdBU0FDS1FNWU53SVlJQUVnQWlrREVEY0NFQ0FCSUFJcEF3ZzNBZ2dnQVNBQ0tRTUFOd0lBREFNTElBQWdBRUVnYWlBQVFVQnJJQUZCSUdzUUh4b01BZ3NnQUNBQVFTQnFJQUJCUUdzaUF5QUFRZUFBYWhBZkdpQUJRU0JySWdFb0FnQWdBQ2dDWUU4TkFTQUNJQUFwQW5nM0F4Z2dBaUFBS1FKd053TVFJQUlnQUNrQ2FEY0RDQ0FDSUFBcEFtQTNBd0FnQUNBQktRSVlOd0o0SUFBZ0FTa0NFRGNDY0NBQUlBRXBBZ2czQW1nZ0FDQUJLUUlBTndKZ0lBRWdBaWtER0RjQ0dDQUJJQUlwQXhBM0FoQWdBU0FDS1FNSU53SUlJQUVnQWlrREFEY0NBQ0FBS0FKZ0lBTW9BZ0JQRFFFZ0FpQURLUUlZTndNWUlBSWdBeWtDRURjREVDQUNJQU1wQWdnM0F3Z2dBaUFES1FJQU53TUFJQU1nQUNrQ2VEY0NHQ0FESUFBcEFuQTNBaEFnQXlBQUtRSm9Od0lJSUFNZ0FDa0NZRGNDQUNBQUlBSXBBeGczQW5nZ0FDQUNLUU1RTndKd0lBQWdBaWtEQ0RjQ2FDQUFJQUlwQXdBM0FtQWdBeWdDQUNBQUtBSWdUdzBCSUFJZ0FDa0NPRGNER0NBQ0lBQXBBakEzQXhBZ0FpQUFLUUlvTndNSUlBSWdBQ2tDSURjREFDQUFJQU1wQWhnM0FqZ2dBQ0FES1FJUU53SXdJQUFnQXlrQ0NEY0NLQ0FBSUFNcEFnQTNBaUFnQXlBQ0tRTVlOd0lZSUFNZ0Fpa0RFRGNDRUNBRElBSXBBd2czQWdnZ0F5QUNLUU1BTndJQUlBQW9BaUFnQUNnQ0FFOE5BU0FDSUFBcEFoZzNBeGdnQWlBQUtRSVFOd01RSUFJZ0FDa0NDRGNEQ0NBQ0lBQXBBZ0EzQXdBZ0FDQUFLUUk0TndJWUlBQWdBQ2tDTURjQ0VDQUFJQUFwQWlnM0FnZ2dBQ0FBS1FJZ053SUFJQUFnQWlrREdEY0NPQ0FBSUFJcEF4QTNBakFnQUNBQ0tRTUlOd0lvSUFBZ0Fpa0RBRGNDSUF3QkN5QUFRVUJySVFNZ0FDZ0NRQ0VFQWtBZ0FDZ0NJQ0lHSUFBb0FnQWlCMDhFUUNBRUlBWlBEUUVnQWlBQUtRSTROd01ZSUFJZ0FDa0NNRGNERUNBQ0lBQXBBaWczQXdnZ0FpQUFLUUlnTndNQUlBQWdBeWtDR0RjQ09DQUFJQU1wQWhBM0FqQWdBQ0FES1FJSU53SW9JQUFnQXlrQ0FEY0NJQ0FESUFJcEF4ZzNBaGdnQXlBQ0tRTVFOd0lRSUFNZ0Fpa0RDRGNDQ0NBRElBSXBBd0EzQWdBZ0FDZ0NJQ0FIVHcwQklBSWdBQ2tDR0RjREdDQUNJQUFwQWhBM0F4QWdBaUFBS1FJSU53TUlJQUlnQUNrQ0FEY0RBQ0FBSUFBcEFqZzNBaGdnQUNBQUtRSXdOd0lRSUFBZ0FDa0NLRGNDQ0NBQUlBQXBBaUEzQWdBZ0FDQUNLUU1ZTndJNElBQWdBaWtERURjQ01DQUFJQUlwQXdnM0FpZ2dBQ0FDS1FNQU53SWdEQUVMSUFRZ0Jra0VRQ0FDSUFBcEFoZzNBeGdnQWlBQUtRSVFOd01RSUFJZ0FDa0NDRGNEQ0NBQ0lBQXBBZ0EzQXdBZ0FDQURLUUlZTndJWUlBQWdBeWtDRURjQ0VDQUFJQU1wQWdnM0FnZ2dBQ0FES1FJQU53SUFJQU1nQWlrREdEY0NHQ0FESUFJcEF4QTNBaEFnQXlBQ0tRTUlOd0lJSUFNZ0Fpa0RBRGNDQUF3QkN5QUNJQUFwQWhnM0F4Z2dBaUFBS1FJUU53TVFJQUlnQUNrQ0NEY0RDQ0FDSUFBcEFnQTNBd0FnQUNBQUtRSTROd0lZSUFBZ0FDa0NNRGNDRUNBQUlBQXBBaWczQWdnZ0FDQUFLUUlnTndJQUlBQWdBaWtER0RjQ09DQUFJQUlwQXhBM0FqQWdBQ0FDS1FNSU53SW9JQUFnQWlrREFEY0NJQ0FFSUFBb0FpQlBEUUFnQWlBQUtRSTROd01ZSUFJZ0FDa0NNRGNERUNBQ0lBQXBBaWczQXdnZ0FpQUFLUUlnTndNQUlBQWdBeWtDR0RjQ09DQUFJQU1wQWhBM0FqQWdBQ0FES1FJSU53SW9JQUFnQXlrQ0FEY0NJQ0FESUFJcEF4ZzNBaGdnQXlBQ0tRTVFOd0lRSUFNZ0Fpa0RDRGNDQ0NBRElBSXBBd0EzQWdBTElBQkI0QUJxSWdRZ0FVWU5BRUVBSVFjRFFBSkFJQVFvQWdBaUNDQURLQUlBVHcwQUlBSWdCQ2dDSERZQ0dDQUNJQVFwQWhRM0F4QWdBaUFFS1FJTU53TUlJQUlnQkNrQ0JEY0RBQ0FFSVFZRFFBSkFJQVlnQXlJRktRSUFOd0lBSUFZZ0F5a0NHRGNDR0NBR0lBTXBBaEEzQWhBZ0JpQURLUUlJTndJSUlBQWdBMFlFUUNBQUlRVU1BUXNnQ0NBRklnWkJJR3NpQXlnQ0FFa05BUXNMSUFVZ0NEWUNBQ0FGSUFJcEF3QTNBZ1FnQlNBQ0tRTUlOd0lNSUFVZ0Fpa0RFRGNDRkNBRklBSW9BaGcyQWh3Z0IwRUJhaUlIUVFoSERRQWdCRUVnYWlBQlJpRUZEQUlMSUFRaUEwRWdhaUlGSVFRZ0FTQUZSdzBBQzBFQklRVUxJQUpCSUdva0FDQUZDOHdGQVFoL0FrQUNRQUpBQWtBQ1FDQUFLQUlFSWdJZ0FDZ0NBQ0lFYTBFRmRTSURJQUZKQkVBZ0FTQURheUlGSUFBb0FnZ2lCaUFDYTBFRmRVMEVRQ0FDSUFWQkJYUnFJUUVEUUNBQ1FnQTNBaEFnQWtJQU53SUFJQUpCR0dvaUEwSUFOd0lBSUFKQ0FEY0NDQ0FDSUFNMkFoUWdBa0VnYWlJQ0lBRkhEUUFMSUFBZ0FUWUNCQThMSUFGQmdJQ0F3QUJQRFFGQi8vLy9QeUFHSUFScklnSkJCSFVpQkNBQklBRWdCRWtiSUFKQjRQLy8vd2RQR3lJRlFZQ0FnTUFBVHcwQ0lBVkJCWFFRRWlJR0lBRkJCWFJxSVFRZ0JpQURRUVYwYWlJQklRSURRQ0FDUWdBM0FoQWdBa0lBTndJQUlBSkJHR29pQTBJQU53SUFJQUpDQURjQ0NDQUNJQU0yQWhRZ0FrRWdhaUlDSUFSSERRQUxJQVlnQlVFRmRHb2hBeUFBS0FJRUlnSWdBQ2dDQUNJR1JnMERBMEFnQVVFZ2F5SUJJQUpCSUdzaUFpZ0NBRFlDQUNBQklBSXZBUVE3QVFRZ0FVRUFOZ0lRSUFGQ0FEY0NDQ0FCSUFJb0FnZzJBZ2dnQVNBQ0tBSU1OZ0lNSUFFZ0FpZ0NFRFlDRUNBQ1FRQTJBaEFnQWtJQU53SUlJQUVnQWlnQ0ZEWUNGQ0FCUVJocUlnVWdBa0VZYWlJSEtBSUFJZ2cyQWdBZ0FTQUNLQUljSWdrMkFod0NRQ0FKUlFSQUlBRWdCVFlDRkF3QkN5QUlJQVUyQWdnZ0FpQUhOZ0lVSUFKQkFEWUNHQ0FDUVFBMkFod0xJQUlnQmtjTkFBc2dBQ0FETmdJSUlBQW9BZ1FoQXlBQUlBUTJBZ1FnQUNnQ0FDRUNJQUFnQVRZQ0FDQUNJQU5HRFFRRFFDQURRUXhySUFOQklHc2lBQ2dDR0JBZ0lBQW9BZ2dpQVFSQUlBTkJGR3NnQVRZQ0FDQUJFQkVMSUFBaUF5QUNSdzBBQ3d3RUN5QUJJQU5QRFFRZ0JDQUJRUVYwYWlJRElBSkhCRUFEUUNBQ1FReHJJQUpCSUdzaUFTZ0NHQkFnSUFFb0FnZ2lCQVJBSUFKQkZHc2dCRFlDQUNBRUVCRUxJQUVpQWlBRFJ3MEFDd3NnQUNBRE5nSUVEQVFMRUNFQUN4QWtBQXNnQUNBRE5nSUlJQUFnQkRZQ0JDQUFJQUUyQWdBTElBSkZEUUFnQWhBUkN3dnlBUUVHZnlBQklBQW9BZ2dpQWlBQUtBSUVJZ05yUVFGMVRRUkFJQUFnQVFSL0lBTWdBVUVCZENJQUVCUWdBR29GSUFNTE5nSUVEd3NDUUNBRElBQW9BZ0FpQld0QkFYVWlCeUFCYWlJRVFRQk9CRUJCLy8vLy93Y2dBaUFGYXlJQ0lBUWdBaUFFU3hzZ0FrSCsvLy8vQjA4YklnUUVRQ0FFUVFCSURRSWdCRUVCZEJBU0lRWUxJQVlnQjBFQmRHb2lBaUFCUVFGMElnRVFGQ0FCYWlFQklBTWdCVWNFUUFOQUlBSkJBbXNpQWlBRFFRSnJJZ012QVFBN0FRQWdBeUFGUncwQUN3c2dBQ0FHSUFSQkFYUnFOZ0lJSUFBZ0FUWUNCQ0FBSUFJMkFnQWdCUVJBSUFVUUVRc1BDeEFoQUFzUUpBQUxCd0FnQUNnQ0JBc0ZBRUh2Q0FzRkFFSGlDUXNGQUVITENBc1dBQ0FBUlFSQVFRQVBDeUFBUWFpZ0NCQTJRUUJIQ3hvQUlBQWdBU2dDQ0NBRkVCWUVRQ0FCSUFJZ0F5QUVFRFFMQ3pjQUlBQWdBU2dDQ0NBRkVCWUVRQ0FCSUFJZ0F5QUVFRFFQQ3lBQUtBSUlJZ0FnQVNBQ0lBTWdCQ0FGSUFBb0FnQW9BaFFSQ2dBTHB3RUFJQUFnQVNnQ0NDQUVFQllFUUFKQUlBRW9BZ1FnQWtjTkFDQUJLQUljUVFGR0RRQWdBU0FETmdJY0N3OExBa0FnQUNBQktBSUFJQVFRRmtVTkFBSkFJQUlnQVNnQ0VFY0VRQ0FCS0FJVUlBSkhEUUVMSUFOQkFVY05BU0FCUVFFMkFpQVBDeUFCSUFJMkFoUWdBU0FETmdJZ0lBRWdBU2dDS0VFQmFqWUNLQUpBSUFFb0FpUkJBVWNOQUNBQktBSVlRUUpIRFFBZ0FVRUJPZ0EyQ3lBQlFRUTJBaXdMQzRnQ0FDQUFJQUVvQWdnZ0JCQVdCRUFDUUNBQktBSUVJQUpIRFFBZ0FTZ0NIRUVCUmcwQUlBRWdBellDSEFzUEN3SkFJQUFnQVNnQ0FDQUVFQllFUUFKQUlBSWdBU2dDRUVjRVFDQUJLQUlVSUFKSERRRUxJQU5CQVVjTkFpQUJRUUUyQWlBUEN5QUJJQU0yQWlBQ1FDQUJLQUlzUVFSR0RRQWdBVUVBT3dFMElBQW9BZ2dpQUNBQklBSWdBa0VCSUFRZ0FDZ0NBQ2dDRkJFS0FDQUJMUUExQkVBZ0FVRUROZ0lzSUFFdEFEUkZEUUVNQXdzZ0FVRUVOZ0lzQ3lBQklBSTJBaFFnQVNBQktBSW9RUUZxTmdJb0lBRW9BaVJCQVVjTkFTQUJLQUlZUVFKSERRRWdBVUVCT2dBMkR3c2dBQ2dDQ0NJQUlBRWdBaUFESUFRZ0FDZ0NBQ2dDR0JFSkFBc0xNUUFnQUNBQktBSUlRUUFRRmdSQUlBRWdBaUFERURVUEN5QUFLQUlJSWdBZ0FTQUNJQU1nQUNnQ0FDZ0NIQkVIQUFzWUFDQUFJQUVvQWdoQkFCQVdCRUFnQVNBQ0lBTVFOUXNMbXdFQkFuOGpBRUZBYWlJREpBQUNmMEVCSUFBZ0FVRUFFQllOQUJwQkFDQUJSUTBBR2tFQUlBRkJ5SjhJRURZaUFVVU5BQm9nQTBFTWFrRTBFQlFhSUFOQkFUWUNPQ0FEUVg4MkFoUWdBeUFBTmdJUUlBTWdBVFlDQ0NBQklBTkJDR29nQWlnQ0FFRUJJQUVvQWdBb0Fod1JCd0FnQXlnQ0lDSUFRUUZHQkVBZ0FpQURLQUlZTmdJQUN5QUFRUUZHQ3lFRUlBTkJRR3NrQUNBRUN3b0FJQUFnQVVFQUVCWUxKQUVCZjBIY3B3Z29BZ0FpQUFSQUEwQWdBQ2dDQUJFRkFDQUFLQUlFSWdBTkFBc0xDeVFCQW44Z0FDZ0NCQ0lBRUQxQkFXb2lBUkFkSWdJRWZ5QUNJQUFnQVJBVEJVRUFDd3NHQUNBQkVCMExCZ0FnQVJBUkM2NEJBUVIvSXdCQkVHc2lBaVFBSUFFb0FnQWlBMEh3Ly8vL0Iwa0VRQUpBSUFOQkNrMEVRQ0FDSUFNNkFBc2dBaUVFREFFTElBTkJEM0pCQVdvaUJSQVNJUVFnQWlBRlFZQ0FnSUI0Y2pZQ0NDQUNJQVEyQWdBZ0FpQUROZ0lFQ3lBRUlBRkJCR29nQXhBVElBTnFRUUE2QUFBZ0FrRU1haUFDSUFBUkFRQWdBaWdDREJBTElBSW9BZ3dpQUJBS0lBSXNBQXRCQUVnRVFDQUNLQUlBRUJFTElBSkJFR29rQUNBQUR3c1FKd0FMQndBZ0FDZ0NEQXY1Q1FFTmZ5QUFLQUlJSWdRZ0FrOGdCQ0FDYXlBRFQzRWlFQVJBQWtBZ0FpQUFLQUlFSWdRb0FnUWdCQzBBQ3lJS0lnVWdCY0JCQUVnYklnVkdCRUFqQUVFUWF5SUpKQUFDUUNBRElBcEJCM1lFZnlBRUtBSUlRZi8vLy84SGNVRUJhd1ZCQ2dzaUJRSi9JQVF0QUF0QkIzWUVRQ0FFS0FJRURBRUxJQVF0QUF0Qi93QnhDeUlIYTAwRVFDQURSUTBCQW44Z0JDMEFDMEVIZGdSQUlBUW9BZ0FNQVFzZ0JBc2lCU0FIYWlBQklBTVFHeUFFSUFNZ0Iyb2lBUkFtSUFsQkFEb0FEeUFCSUFWcUlBa3RBQTg2QUFBTUFRc2dCQ0FGSUFNZ0JXc2dCMm9nQnlBSFFRQWdBeUFCRURvTElBbEJFR29rQUNBQ0lBTnFJUTRNQVFzZ0JTQUNJQU5xSWc1SkJFQWpBRUVRYXlJSUpBQWdEaUFGYXlJSkJFQWdDU0FFTFFBTFFRZDJCSDhnQkNnQ0NFSC8vLy8vQjNGQkFXc0ZRUW9MSWdZQ2Z5QUVMUUFMUVFkMkJFQWdCQ2dDQkF3QkN5QUVMUUFMUWY4QWNRc2lEV3RMQkVBQ1FDTUFRUkJySWd3a0FDQUpJQVpySUExcUlnVkI3Ly8vL3djZ0JtdE5CRUFDZnlBRUxRQUxRUWQyQkVBZ0JDZ0NBQXdCQ3lBRUN5RUxJQXhCQkdvaUNpQUVJQVpCNS8vLy93TkpCSDhnRENBR1FRRjBOZ0lNSUF3Z0JTQUdhallDQkNNQVFSQnJJZzhrQUNBS0tBSUFJQXhCREdvaUJ5Z0NBRWtoQlNBUFFSQnFKQUFnQnlBS0lBVWJLQUlBSWdWQkMwOEVmeUFGUVJCcVFYQnhJZ1VnQlVFQmF5SUZJQVZCQzBZYkJVRUtDMEVCYWdWQjcvLy8vd2NMRURrZ0RDZ0NCQ0VGSUF3b0FnZ2FJQTBFUUNBRklBc2dEUkFiQ3lBR1FRcEhCRUFnQ3hBUkN5QUVJQVUyQWdBZ0JDQUVLQUlJUVlDQWdJQjRjU0FNS0FJSVFmLy8vLzhIY1hJMkFnZ2dCQ0FFS0FJSVFZQ0FnSUI0Y2pZQ0NDQU1RUkJxSkFBTUFRc1FKd0FMQ3lBTkFuOGdCQzBBQzBFSGRnUkFJQVFvQWdBTUFRc2dCQXNpQjJvaEJpTUFRUkJySWdva0FDQUtRUUE2QUE4Z0NTRUZBMEFnQlFSQUlBWWdDaTBBRHpvQUFDQUZRUUZySVFVZ0JrRUJhaUVHREFFTEN5QUtRUkJxSkFBZ0JDQUpJQTFxSWdRUUppQUlRUUE2QUE4Z0JDQUhhaUFJTFFBUE9nQUFDeUFJUVJCcUpBQWdBQ2dDQkNFRUN5TUFRUkJySWdna0FDQUlJQU0yQWd3Q1FBSkFJQUlDZnlBRUxRQUxRUWQyQkVBZ0JDZ0NCQXdCQ3lBRUxRQUxRZjhBY1FzaUMwMEVRQ0FJSUFzZ0Ftc2lEellDQ0NNQVFSQnJJZ29rQUNBSVFRaHFJZ2NvQWdBZ0NFRU1haUlKS0FJQVNTRUZJQXBCRUdva0FDQUlJQWNnQ1NBRkd5Z0NBRFlDRENBRElBZ29BZ3dpQ1NBRUxRQUxRUWQyQkg4Z0JDZ0NDRUgvLy8vL0IzRkJBV3NGUVFvTElnVWdDMnRxVFFSQUFuOGdCQzBBQzBFSGRnUkFJQVFvQWdBTUFRc2dCQXNoQndKQUlBTWdDQ2dDRENJR1JnMEFJQVlnRDBZTkFDQVBJQVpySVFrZ0FpQUhhaUVGSUFNZ0Jra05Bd0pBSUFFZ0JVME5BQ0FISUF0cUlBRk5EUUFnQVNBRklBWnFUd1JBSUFFZ0F5QUdhMm9oQVF3QkN5QUZJQUVnQmhBY0lBZ29BZ3doQlVFQUlRWWdDRUVBTmdJTUlBRWdBMm9oQVNBRElBVnJJUU1nQWlBRmFpRUNDeUFDSUFkcUlnVWdBMm9nQlNBR2FpQUpFQndMSUFJZ0Iyb2dBU0FERUJ3Z0JDQUhJQU1nQzJvZ0NDZ0NER3NRT3d3REN5QUVJQVVnQXlBTGFpQUZJQWxxYXlBTElBSWdDU0FESUFFUU9nd0NDeEFHQUFzZ0JTQUJJQU1RSENBRElBVnFJQVVnQ0NnQ0RHb2dDUkFjSUFRZ0J5QURJQXRxSUFnb0FneHJFRHNMSUFoQkVHb2tBQXNnQUNBQUtBSU1JZ0FnRGlBQUlBNUxHellDREFzZ0VBc1lBQ0FBSUFFZ0FDZ0NEQ0FDSUFBb0FnQW9BZ3dSQ0FBTEZRQkJxd2hCQWtHVUQwR0FFRUVCUVFKQkFCQUhDL1dRQWdKbWZ3TitJd0JCTUdzaUl5UUFJQUVvQWdBZ0FTQUJMUUFMSWduQVFRQklJZ01iSVJwQmdJQ0FEeUFCS0FJRUlBa2dBeHRCRkU4RWZ5QWFLQUFRSWdOQkdIUWdBMEdBL2dOeFFRaDBjaUFEUVFoMlFZRCtBM0VnQTBFWWRuSnlCVUVBQ3lJRElBTkJnSUNBRDA4YklRa0NRQUpBSUFOQkMwOEVRQ0FKUVE5eVFRRnFJZ01RRWlFRUlDTWdBMEdBZ0lDQWVISTJBaVFnSXlBRU5nSWNJQ01nQ1RZQ0lBd0JDeUFqSUFrNkFDY2dJMEVjYWlFRUlBbEZEUUVMSUFRZ0NSQVVHZ3NnQkNBSmFrRUFPZ0FBSUNOQkRHb2lGVUtBZ0lBUE53SUlJQlVnSTBFY2FpSkROZ0lFSUJWQjJLVUlOZ0lBQWtBZ0FBSi9JQUVvQWdRZ0FTMEFDeUlBSUFEQVFRQklHeUVaUVFBaENTTUFRYkFCYXlJSUpBQWdDRUhrQUdvaU0wSUFOd0lBSUFoQkFEWUNYQ0FJUWdBM0FsUWdDQ0F6TmdKZ0lBaENBRGNEU0NBSVFVQnJRZ0EzQXdBZ0NFSUFOd000SUFnZ0dUWUNxQUVnQ0NBYU5nS2tBUUpBQWtBQ1FDQVpRUVJKRFFBZ0dpZ0FBQ0lBUVJoMElBQkJnUDREY1VFSWRISWdBRUVJZGtHQS9nTnhJQUJCR0haeWNpRkVJQmxCQ0VrTkFDQkVRYktNdmJvSFJ3MEFJQWdnR2lnQUJDSUFRUmgwSUFCQmdQNERjVUVJZEhJZ0FFRUlka0dBL2dOeElBQkJHSFp5Y2pZQ0dDQVpRUXhKRFFBZ0dTQWFLQUFJSWdCQkdIUWdBRUdBL2dOeFFRaDBjaUFBUVFoMlFZRCtBM0VnQUVFWWRuSnlSdzBBSUJsQkRra05BQ0FJSUJvdkFBd2lBRUVJZENBQVFRaDJja0gvL3dOeElnczdBU0FnR1VFVVNRMEFJQXRGRFFBZ0dVRVlTUTBBSUFnZ0dpZ0FGQ0lBUVJoMElBQkJnUDREY1VFSWRISWdBRUVJZGtHQS9nTnhJQUJCR0haeWNqWUNNQ0FaUVNCSkRRQWdHaWdBSENJQVFSaDBJQUJCZ1A0RGNVRUlkSElnQUVFSWRrR0EvZ054SUFCQkdIWnljaUViSUJsQkpFa05BQ0FhS0FBZ0lnQkJHSFFnQUVHQS9nTnhRUWgwY2lBQVFRaDJRWUQrQTNFZ0FFRVlkbkp5SVFvZ0dVRW9TUTBBSUJvb0FDUWFBa0FnR3dSQUlCbEJMRWtOQWlBWklCdE5EUUlnR1NBYmF5QUtUdzBCREFJTElCbEJMRWtOQVFzZ0dpZ0FLQ0lBUVJoMElBQkJnUDREY1VFSWRISWdBRUVJZGtHQS9nTnhJQUJCR0haeWNpRVBJQmxCTUVrTkFDQWFLQUFzSWdCQkdIUWdBRUdBL2dOeFFRaDBjaUFBUVFoMlFZRCtBM0VnQUVFWWRuSnlJUlFnQ0VFd05nS3NBU0FQQkVBZ0R5QVpUdzBCSUJrZ0Qyc2dGRWtOQVFzQ1FDQUxJQWdvQWtBaUFDQUlLQUk4SWdGclFRVjFUUVJBSUFnZ0N3Ui9JQUVnQzBFRmRDSUFFQlFnQUdvRklBRUxOZ0k4REFFTEFrQWdBU0FJS0FJNElnZHJRUVYxSWdRZ0Myb2lCa0dBZ0lEQUFFa0VRRUgvLy84L0lBQWdCMnNpQTBFRWRTSUFJQVlnQUNBR1N4c2dBMEhnLy8vL0IwOGJJZ01FUUNBRFFZQ0FnTUFBVHcwQ0lBTkJCWFFRRWlFVEN5QUVRUVYwSUJOcUlnUWdDMEVGZENJQUVCUWdBR29oQUNBQklBZEhCRUFEUUNBRVFTQnJJZ1FnQVVFZ2F5SUJLUUlBTndJQUlBUWdBU2tDR0RjQ0dDQUVJQUVwQWhBM0FoQWdCQ0FCS1FJSU53SUlJQUVnQjBjTkFBc2dDQ2dDT0NFQkN5QUlJQk1nQTBFRmRHbzJBa0FnQ0NBQU5nSThJQWdnQkRZQ09DQUJCRUFnQVJBUkN3d0NDeEFoQUFzUUpBQUxBa0FnQ0M4QklDSVRSUTBBQTBBQ1FDQUlLQUtzQVNJSFFRRnFJZ1FnQ0NnQ3FBRWlBMHNOQUNBSUtBSTRJVVVnQ0NnQ3BBRWlBU0FIYWkwQUFDRUxJQWdnQkRZQ3JBRUNRQ0FMUVQ5eElnQkJQMFlFUUNBRElBZEJCV29pQUVrTkFpQUJJQVJxS0FBQUlnRkJHSFFnQVVHQS9nTnhRUWgwY2lBQlFRaDJRWUQrQTNFZ0FVRVlkbkp5SVFRZ0NDQUFOZ0tzQVF3QkN5QUFRUUowUWJBUWFpZ0NBQ0VFQ3lBSVFhUUJhaUFJUVpnQmFoQXpSUVJBSUE0TkF3d0VDeUFJSUFnb0FwZ0JJZ0EyQW93QkFrQUNRQUpBSUF0QndBQkpJQXRCUDBzZ0JFSGh4cjNqQmtjaUF5QUVRZWJ5c2JzR1IzRWJJZ0VOQUNBSVFhUUJhaUFJUVl3QmFoQXpSUTBCSUFnb0Fvd0JJUUFnQXcwQUlBQU5BUXNnQUNBQ1FYOXpUUTBCQ3lBT0RRTU1CQXNnUlNBRlFRVjBhaUlESUFJMkFnZ2dBeUFJS0FLTUFTSUFOZ0lNSUFNZ0JEWUNBQ0FESUF0QkJuWkJBRUdBQWlBQkczSTJBZ1FnQXlBSUtBS01BVFlDRUNBRElBZ29BcGdCTmdJWUlBVkJBV29pQlNBVFR5RU9JQUFnQW1vaEFpQUZJQk5IRFFFTEN5QU9SUTBCQ3lBSUlBZ29BanhCSUdzaUFDZ0NEQ0lCSUFBb0FnaHFJZ0EyQWpRZ0FDQUJTUTBBSUFoQkFEWUNIQUpBSUFnb0FoaEI1c2JSb3dkSERRQWdDQ2dDckFFaUFVRUVhaUlBSUFnb0FxZ0JTdzBCSUFnb0FxUUJJQUZxS0FBQUlRRWdDQ0FBTmdLc0FTQUlJQUZCR0hRZ0FVR0EvZ054UVFoMGNpQUJRUWgyUVlEK0EzRWdBVUVZZG5KeUlnQTJBaHdnQUVHQWdBaEhJQUJCZ0lBRVIzRU5BU0FJUWFRQmFpQUlRWmdCYWhBWlJRMEJJQWdvQXBnQklnVkZEUUVDUUFKQUFrQUNRQ0FJS0FKSUlnQWdDQ2dDUkNJQ2EwRVliU0lFSUFWSkJFQWdCU0FFYXlJSElBZ29Ba3dpQVNBQWEwRVliVTBFUUNBSUlBQWdCMEVZYkVFWWF5SUFJQUJCR0hCclFSaHFJZ0FRRkNBQWFqWUNTQXdGQ3lBRlFhdlZxdFVBVHcwQlFhclZxdFVBSUFFZ0FtdEJHRzBpQTBFQmRDSUJJQVVnQVNBRlN4c2dBMEhWcXRVcVR4c2lBVUdyMWFyVkFFOE5CeUFCUVJoc0lnWVFFaUlGSUFSQkdHeHFJZ1FnQjBFWWJFRVlheUlCSUFGQkdIQnJRUmhxSWdNUUZDSUJJQU5xSVFjZ0JTQUdhaUVESUFBZ0FrWU5BZ05BSUFSQkdHc2lCQ0FBUVJocklnQXBBZ0EzQWdBZ0JDQUFLQUlJTmdJSUlBUWdBQ2dDRERZQ0RDQUVJQUFvQWhBMkFoQWdCQ0FBS0FJVU5nSVVJQUJCQURZQ0ZDQUFRZ0EzQWd3Z0FDQUNSdzBBQ3lBSUlBTTJBa3dnQ0NnQ1NDRUZJQWdnQnpZQ1NDQUlLQUpFSVFJZ0NDQUVOZ0pFSUFJZ0JVWU5Bd05BSUFWQkdHc2lBQ2dDRENJQkJFQWdCVUVJYXlBQk5nSUFJQUVRRVFzZ0FDSUZJQUpIRFFBTERBTUxJQVFnQlUwTkF5QUNJQVZCR0d4cUlnUWdBRWNFUUFOQUlBQkJHR3NpQVNnQ0RDSURCRUFnQUVFSWF5QUROZ0lBSUFNUUVRc2dBU0lBSUFSSERRQUxDeUFJSUFRMkFrZ01Bd3NRSVFBTElBZ2dBellDVENBSUlBYzJBa2dnQ0NBQk5nSkVDeUFDUlEwQUlBSVFFUXNnQ0NnQ21BRUVRQU5BSUFnb0FrUWhSaUFJUWFRQmFpQUlRWXdCYWhBWlJRMERJQWdvQW93QlJRMERJQWdvQXF3QklnRkJCR29pQUNBSUtBS29BVXNOQXlCR0lDbEJHR3hxSWdNZ0NDZ0NwQUVnQVdvb0FBQWlBVUVZZENBQlFZRCtBM0ZCQ0hSeUlBRkJDSFpCZ1A0RGNTQUJRUmgyY25JMkFnQWdDQ0FBTmdLc0FTQURRUXhxSVFZQ1FDQUlLQUtNQVNJRUlBTW9BaEFnQXlnQ0RDSUFhMEVCZFNJQlN3UkFJQVlnQkNBQmF4QkhJQWdvQW93QklRUU1BUXNnQVNBRVRRMEFJQU1nQUNBRVFRRjBhallDRUF0QkFDRUFRUUFoQWtFQUlRVWdCQVJBQTBBZ0NFR2tBV29nQ0VINEFHb1FHVVVOQlNBSUtBSjRJZ1FnQ0NnQ1BDQUlLQUk0SWdGclFRVjFUdzBGSUFZb0FnQWdBRUVCZEdvZ0JEc0JBQ0FJS0FKNElnTWdCU0FCSUFSQkJYUnFLQUlBSWdGQjV2S3h1d1pHR3lFRklBTWdBaUFCUWVIR3ZlTUdSaHNoQWlBQVFRRnFJZ0FnQ0NnQ2pBRkpEUUFMQ3lBQ0lBVnlCRUFnQWlBRlNRMEVJQUlnQld0QkFVY05CQXNnS1VFQmFpSXBJQWdvQXBnQlNRMEFDd3NnQ0NnQ0hDSUFSUTBBSUFBZ0NDZ0NTQ0FJS0FKRWEwRVliUkF2R2dzZ0NDQUlOUUtzQVNKb053TW9JR2dnQ0RVQ01IeENBM3hDL1AvLy96K0RJbWdnR2ExV0RRQWdHd1JBSUdnZ0c2MVNEUUVnQ2lBYmFpSUFJQUJCQTJwQmZIRWdBRUY4U3h1dElXZ0xJQThFZmlCb0lBK3RVZzBCSUE4Z0ZHb2lBQ0FBUVFOcVFYeHhJQUJCZkVzYnJRVWdhQXNnR1NBWlFRTnFRWHh4SUJsQmZFc2JyVklOQUFKQUFrQWdDQ2dDSENJQVJRUkFJQWhDQURjQ3FBRWdDQzhCSUVFRWRFRU1jaUVKREFFTElBQWdDQ2dDU0NBSUtBSkVhMEVZYlJBdklBZ29Ba2dpQVNBSUtBSkVJZ0JyUVJodFFReHNhaUVKSUFBZ0FVY0VRQU5BSUFBb0FoQWdBQ2dDREd0QkEzUWdDV29oQ1NBQVFSaHFJZ0FnQVVjTkFBc0xJQWhCQURZQ3JBRWdDRUlBTndLa0FTQUpSUTBCSUFsQkFFZ05CZ3NnQ0NBSkVCSWlGellDcEFFZ0NDQUpJQmRxSWdBMkFxd0JJQmNnQ1JBVUdpQUlJQUEyQXFnQkMwRUFJUUFnQ0VFQU5nS2dBU0FJUWdBM0FwZ0JRUUFoQWlBSUtBSThJZ0VnQ0NnQ09DSUpSd1JBSUFFZ0NXc2lBRUVBU0EwRklBZ2dBQkFTSWdJMkFwZ0JJQWdnQWlBQVFXQnhhallDb0FFZ0FpRUFBMEFnQUNBSktRSUFOd0lBSUFBZ0NTa0NHRGNDR0NBQUlBa3BBaEEzQWhBZ0FDQUpLUUlJTndJSUlBQkJJR29oQUNBSlFTQnFJZ2tnQVVjTkFBc2dDQ0FBTmdLY0FRc0NRQ0FJS0FJY0JFQWdDQ2dDUkNJT0lBZ29Ba2dpRkVZTkFTQUlRWkFCYWlFQkEwQWdDQ0FCTmdLTUFTQUlRUUEyQXBBQlFRQWhLUUpBSUE0b0Fnd2lCaUFPS0FJUUloTkdCRUFnQ0VFQU5nS1VBUXdCQ3dOQUlBZ29BamdnQmk4QkFDSUhRUVYwYWlnQ0FDRUVJQUVpQWlFQUFrQUNRQ0FJS0FLUUFTSUpSUTBBQTBBZ0NTSUFLQUlRSWdNZ0JFc0VRQ0FBSWdJb0FnQWlDUTBCREFJTElBTWdCRThFUUNBQUlRVU1Bd3NnQUNnQ0JDSUpEUUFMSUFCQkJHb2hBZ3RCR0JBU0lnVWdCRFlDRUNBRklBQTJBZ2dnQlVJQU53SUFJQVZCQURzQkZDQUNJQVUyQWdBZ0JTRUVJQWdvQW93QktBSUFJZ0FFUUNBSUlBQTJBb3dCSUFJb0FnQWhCQXNnQkNBRUlBZ29BcEFCSWdOR0lnQTZBQXdDUUNBQURRQURRQ0FFS0FJSUlna3RBQXdOQVFKQUlBa2dDU2dDQ0NJQUtBSUFJZ0pHQkVBQ1FDQUFLQUlFSWdKRkRRQWdBaTBBREEwQURBSUxBa0FnQkNBSktBSUFSZ1JBSUFraEJBd0JDeUFKSUFrb0FnUWlCQ2dDQUNJRE5nSUVJQVFnQXdSL0lBTWdDVFlDQ0NBSktBSUlCU0FBQ3pZQ0NDQUpLQUlJSWdBZ0FDZ0NBQ0FKUjBFQ2RHb2dCRFlDQUNBRUlBazJBZ0FnQ1NBRU5nSUlJQVFvQWdnaUFDZ0NBQ0VKQ3lBRVFRRTZBQXdnQUVFQU9nQU1JQUFnQ1NnQ0JDSUROZ0lBSUFNRVFDQURJQUEyQWdnTElBa2dBQ2dDQ0RZQ0NDQUFLQUlJSWdNZ0F5Z0NBQ0FBUjBFQ2RHb2dDVFlDQUNBSklBQTJBZ1FnQUNBSk5nSUlEQU1MQWtBZ0FrVU5BQ0FDTFFBTURRQU1BUXNDUUNBRUlBa29BZ0JIQkVBZ0NTRUVEQUVMSUFrZ0JDZ0NCQ0lETmdJQUlBUWdBd1IvSUFNZ0NUWUNDQ0FKS0FJSUJTQUFDellDQ0NBSktBSUlJZ0FnQUNnQ0FDQUpSMEVDZEdvZ0JEWUNBQ0FFSUFrMkFnUWdDU0FFTmdJSUlBUW9BZ2doQUFzZ0JFRUJPZ0FNSUFCQkFEb0FEQ0FBSUFBb0FnUWlDU2dDQUNJRE5nSUVJQU1FUUNBRElBQTJBZ2dMSUFrZ0FDZ0NDRFlDQ0NBQUtBSUlJZ01nQXlnQ0FDQUFSMEVDZEdvZ0NUWUNBQ0FKSUFBMkFnQWdBQ0FKTmdJSURBSUxJQWxCQVRvQURDQUFJQUFnQTBZNkFBd2dBa0VCT2dBTUlBTWdBQ0lFUncwQUN3c2dLVUVCYWlFcEN5QUZJQWM3QVJRZ0JrRUNhaUlHSUJOSERRQUxJQWdnS1RZQ2xBRWdDQ2dDakFFaUJDQUJSZzBBSUE0b0Fnd2hCVUVBSVFJRFFDQUZJQUpCLy84RGNVRUJkR29nQkM4QkZEc0JBQUpBSUFRb0FnUWlDUVJBQTBBZ0NTSUFLQUlBSWdrTkFBd0NDd0FMQTBBZ0JDZ0NDQ0lBS0FJQUlBUkhJVWNnQUNFRUlFY05BQXNMSUFKQkFXb2hBaUFCSUFBaUJFY05BQXNMSUFoQmpBRnFJQWdvQXBBQkVDMGdEa0VZYWlJT0lCUkhEUUFMSUFnb0FxUUJJUmNNQVFzZ0FpQUFJQWhCakFGcVFUNGdBQ0FDYTBFRmRXZEJBWFJyUVFBZ0FDQUNSeHNRTEFzZ0NFSFVBR29oQVFKQUFrQWdDQ2dDSEFSQUlCY2dDQ2dDR0NJQVFSaDBJQUJCZ1A0RGNVRUlkSElnQUVFSWRrR0EvZ054SUFCQkdIWnljallBQUNBWElBZ29BaHdpQUVFWWRDQUFRWUQrQTNGQkNIUnlJQUJCQ0haQmdQNERjU0FBUVJoMmNuSTJBQVFnRnlBSUtBSklJQWdvQWtSclFSaHRJZ0JCR0hRZ0FFR0EvZ054UVFoMGNpQUFRUWgyUVlEK0EzRWdBRUVZZG5KeU5nQUlRUXdoRUNBSUtBSkVJZ2tnQ0NnQ1NFWUVRQ0FKSVFRTUFndEJBQ0VBQTBBZ0VDQVhha0VBT2dBQUlCY2dFRUVCY21wQkFEb0FBQ0FYSUJCQkFuSnFRUUE2QUFBZ0Z5QVFRUU55YWtFQU9nQUFJQkJCQkdvaEVDQUFRUUZxSWdBZ0NDZ0NTQ0lKSUFnb0FrUWlCR3RCR0cxSkRRQUxEQUVMSUFGQkFSQkdJQWdvQWhnaEFDQVhJQWd2QVNBaUF6b0FCU0FYSUFBNkFBTWdGeUFEUVFoMk9nQUVJQmNnQUVFSWRqb0FBaUFYSUFCQkVIWTZBQUVnRnlBQVFSaDJPZ0FBUVFBaEFBTkFJQU1nQUNJQlFRRnFJZ0IyRFFBTElCY2dBVG9BQ1NBWElBRkJDSFk2QUFnZ0YwRVFJQUYwSWdBNkFBY2dGeUFBUVFoMk9nQUdJQmNnQTBFRWRDQUFRZkQvQTNGcklnQTZBQXNnRnlBQVFRaDJPZ0FLSUFndkFTQkZEUUZCRENFRlFRQWhCZ05BSUFnb0FwZ0JJaEFnQmtFRmRDSURhaWdDQUNFRUlBZ29BbFFpQjBFWWFpSUNJUUFDUUFKQUlBY29BaGdpQ1VVTkFBTkFJQWtpQUNnQ0VDSUJJQVJMQkVBZ0FDSUNLQUlBSWdrTkFRd0NDeUFCSUFSUEJFQU1Bd3NnQUNnQ0JDSUpEUUFMSUFCQkJHb2hBZ3RCR0JBU0lna2dCRFlDRUNBSklBQTJBZ2dnQ1VJQU53SUFJQWxCQURZQ0ZDQUNJQWsyQWdBZ0NTRUFJQWNvQWhRb0FnQWlBUVJBSUFjZ0FUWUNGQ0FDS0FJQUlRQUxJQWNvQWhnZ0FCQWxJQWNnQnlnQ0hFRUJhallDSENBSUtBS1lBU0VRQ3lBSklBVTJBaFFnQlNBWGFpSUFJQU1nRUdvb0FnQWlBVUVZZGpvQUFDQVhJQVZCQVhKcUlBRkJFSFk2QUFBZ0Z5QUZRUUp5YWlBQlFRaDJPZ0FBSUJjZ0JVRURjbW9nQVRvQUFDQUFRUUEyQUF3Z0FFSUFOd0FFSUFWQkVHb2hCU0FHUVFGcUlnWWdDQzhCSUVrTkFBc01BUXNnQVNBSUtBSWNRWUNBQ0VZRWZ5QVFJQmRxSWdCQkFEb0FBQ0FYSUJCQkFYSnFRUUE2QUFBZ0Z5QVFRUUp5YWtFQU9nQUFJQmNnRUVFRGNtcEJBRG9BQUNBQVFnQTNBQVFnRUVFTWFpRVFJQWdvQWtRaEJDQUlLQUpJQlNBSkN5QUVhMEVZYlJCR0lBZ29Ba1FpQUNBSUtBSklSZzBBUVF3aEIwRUFJUTREUUNBSElCZHFJQkJCR0hZNkFBQWdGeUFIUVFGeWFpQVFRUkIyT2dBQUlCY2dCMEVDY21vZ0VFRUlkam9BQUNBWElBZEJBM0pxSUJBNkFBQWdBQ0FPUVJoc2FpSUxJQkEyQWdRZ0N5Z0NFQ0VCSUFzb0Fnd2hBQ0FRSUJkcUlna2dDeWdDQUNJRE9nQURJQWtnQTBFSWRqb0FBaUFKSUFOQkVIWTZBQUVnQ1NBRFFSaDJPZ0FBSUFrZ0FTQUFheUlCUVFGMklnQTZBQVVnQ1NBQlFRbDJPZ0FFSUFCQi8vOERjU0VEUVFBaEFBTkFJQU1nQUNJQlFRRnFJZ0IyRFFBTElBa2dBVG9BQ1NBSklBRkJDSFk2QUFnZ0NVRVFJQUYwSWdBNkFBY2dDU0FBUVFoMk9nQUdJQWtnQTBFRWRDQUFRZkQvQTNGcklnQTZBQXNnQ1NBQVFRaDJPZ0FLSUJCQkRHb2hFQ0FMS0FJTUloTWdDeWdDRUNJRVJ3UkFBMEFnQ0NnQ09DQVRMd0VBUVFWMGFpZ0NBQ0VLSUFnb0FsUWdEa0VGZEdvaUZFRVlhaUlCSVFVQ1FBSkFJQUVpQUNnQ0FDSUpSUTBBQTBBZ0NTSUFLQUlRSWdNZ0Nrc0VRQ0FBSVFVZ0FDZ0NBQ0lKRFFFTUFnc2dBeUFLVHdSQUlBQWhCZ3dEQ3lBQUtBSUVJZ2tOQUFzZ0FFRUVhaUVGQzBFWUVCSWlCaUFLTmdJUUlBWWdBRFlDQ0NBR1FnQTNBZ0FnQmtFQU5nSVVJQVVnQmpZQ0FDQUdJUUlnRkNnQ0ZDZ0NBQ0lBQkVBZ0ZDQUFOZ0lVSUFVb0FnQWhBZ3NnQWlBQ0lBRW9BZ0FpQVVZaUFEb0FEQUpBSUFBTkFBTkFJQUlvQWdnaUNTMEFEQTBCQWtBZ0NTQUpLQUlJSWdBb0FnQWlCVVlFUUFKQUlBQW9BZ1FpQlVVTkFDQUZMUUFNRFFBTUFnc0NRQ0FDSUFrb0FnQkdCRUFnQ1NFQ0RBRUxJQWtnQ1NnQ0JDSUNLQUlBSWdFMkFnUWdBaUFCQkg4Z0FTQUpOZ0lJSUFrb0FnZ0ZJQUFMTmdJSUlBa29BZ2dpQUNBQUtBSUFJQWxIUVFKMGFpQUNOZ0lBSUFJZ0NUWUNBQ0FKSUFJMkFnZ2dBaWdDQ0NJQUtBSUFJUWtMSUFKQkFUb0FEQ0FBUVFBNkFBd2dBQ0FKS0FJRUlnRTJBZ0FnQVFSQUlBRWdBRFlDQ0FzZ0NTQUFLQUlJTmdJSUlBQW9BZ2dpQVNBQktBSUFJQUJIUVFKMGFpQUpOZ0lBSUFrZ0FEWUNCQ0FBSUFrMkFnZ01Bd3NDUUNBRlJRMEFJQVV0QUF3TkFBd0JDd0pBSUFJZ0NTZ0NBRWNFUUNBSklRSU1BUXNnQ1NBQ0tBSUVJZ0UyQWdBZ0FpQUJCSDhnQVNBSk5nSUlJQWtvQWdnRklBQUxOZ0lJSUFrb0FnZ2lBQ0FBS0FJQUlBbEhRUUowYWlBQ05nSUFJQUlnQ1RZQ0JDQUpJQUkyQWdnZ0FpZ0NDQ0VBQ3lBQ1FRRTZBQXdnQUVFQU9nQU1JQUFnQUNnQ0JDSURLQUlBSWdFMkFnUWdBUVJBSUFFZ0FEWUNDQXNnQXlBQUtBSUlOZ0lJSUFBb0FnZ2lBU0FCS0FJQUlBQkhRUUowYWlBRE5nSUFJQU1nQURZQ0FDQUFJQU0yQWdnTUFnc2dDVUVCT2dBTUlBQWdBQ0FCUmpvQURDQUZRUUU2QUF3Z0FTQUFJZ0pIRFFBTEN5QVVJQlFvQWh4QkFXbzJBaHdMSUFZZ0VEWUNGQ0FRSUJkcUlnQkJBRFlBRENBQVFnQTNBQVFnQUNBS09nQURJQUFnQ2tFSWRqb0FBaUFBSUFwQkVIWTZBQUVnQUNBS1FSaDJPZ0FBSUJCQkVHb2hFQ0FUUVFKcUloTWdCRWNOQUFzTElBZEJCR29oQnlBTElBc29BZ1FpQUNBSUtBS2tBV29nRUNBQWF4QVhOZ0lJSUE1QkFXb2lEaUFJS0FKSUlBZ29Ba1FpQUd0QkdHMUpEUUFMQ3lBVklBZ29BcVFCSWdNZ0NDZ0NxQUVnQTJzaUFDQVZLQUlBS0FJSUVRTUFJZ0VFUUNBSUlBTWdBQkFYTmdKUUN5QUlLQUtZQVNJQUJFQWdBQkFSQ3lBREJFQWdDQ0FETmdLb0FTQURFQkVMUVFBaENTQUJSUTBBSUFnb0FqUWlLck1nR2JPVlF3QUF5RUplRFFBZ0NDa0RLQ0ZvSUFoQkFEWUNGQ0FJUWdBM0Fnd2dLa1VOQUNBcVFRQklEUVFnQ0NBcUVCSWlBVFlDRENBSUlBRWdLbW9pQURZQ0ZDQUJJQ29RRkNFRElBZ2dBRFlDRUNBSUtBSXdJUUFnQ0NBcU5nS2tBVUVBSVFjakFFSEFKMnNpRmlRQUlCWkJBRFlDSENBV0lBQTJBaGdnRmlBYUlHaW5hallDRkNBV0lBZ29BcVFCTmdJUUlCWWdBellDRENBV1FTQnFJZ0lpQUVFQU5nSmNJQUJCQURZQ0lDQUFRUXMyQWh3Z0FFRU1OZ0lZSUFCQ2dJQ0FnSUFFTndJSUlBQkNBRGNEQUNBQVFnQTNBNkFDSUFCQ0FEY0RNQ0FBUWdBM0F1d21JQUJDQURjRFFDQUFRUUEyQW9RQ0lBQkNBRGNEWUNBQVFnQTNBb3dCSUFCQ0FEY0NuQUVnQUVJQU53SjhJQUJDQURjQ2RDQUFRZ0EzQThBbUlBQkJ5Q1pxUWdBM0F3QWdBRUhRSm1wQ0FEY0RBQ0FBUWRnbWFrRUFOZ0lBSUFCQ0FEY0Q0Q1lnQUNBQUx3SGNKa0hBL3dOeFFSQnlPd0hjSmlBQVFvdUFnSURBQURjQ1ZDQUFRcENBZ0lEd0FUY0NUQ0FBUVFBMkFqd2dBRUVBTmdKSUlBQWdBRUhZQTJvMkFyUURJQUJCUHpZQ3VDUWdBRUlBTndLc0FTQUFRYWltQ0RZQzlDWWdBRUdBcGdnMkF2Z21JQlpCREdvaEZDTUFRUkJySWl3a0FDQVdRUnhxSWhrRVFDQVpJQUlvQXFRQ05nSUFDeUFXUVJCcUlSb0NRQ0FDS0FKY1FRQklEUUFDUUNBYUtBSUFSUVJBUVFBaEZBd0JDeUFVQkVBZ0ZDZ0NBQTBCQ3lBQ1FXdzJBbHdNQVFzZ0FrRUlhaUVOSUFJQ2Z5QUNLQUl3UlFSQUlBSWdGaWdDR0RZQ0ZFRUJJUWNnRmlnQ0ZBd0JDMEVDSVFjZ0FrRW9hZ3MyQWhBZ0FrR2NBV29oRUNBQ1FZd0JhaUViSUFKQi9BQnFJUk1nQWtHRUFtb2hQeUFDUVlBQ2FpRkFJQUpCL0NacUlTMGdBa0hzSm1vaE9TQUNRZWdtYWlFdklBSkJLR29oT2dOQUFrQUNRQUpBQWtBQ1FDQUhRUUZyRGdJRUFBRUxJQUlvQW1RRVFDQUNJQm9nRkNBWlFRRVFJeUlIUVFCSURRSUxJQUlvQWpBaUFBUkFJQUlvQWhSRkJFQWdBa0VBTmdJd0lBSWdGaWdDR0RZQ0ZDQUNJQllvQWhRMkFoQkJBU0VIREFZTElCWW9BaGhGQkVBZ0FrRUNOZ0pjUVFJaEJ3d0hDeUFBSURwcUlCWW9BaFF0QUFBNkFBQkJBU0VISUFJZ0FpZ0NNRUVCYWlJQU5nSVVJQUlnQURZQ01DQVdJQllvQWhSQkFXbzJBaFFnRmlBV0tBSVlRUUZyTmdJWURBVUxJQllnQWlnQ0VDSUFOZ0lVSUJZZ0FpZ0NGQ0lETmdJWVFRSWhCeUFEUlEwQlFRQWhBd05BSUFNZ09tb2dBQzBBQURvQUFDQUNJQUlvQWpCQkFXb2lBellDTUNBV0lCWW9BaFJCQVdvaUFEWUNGQ0FXSUJZb0FoaEJBV3NpQkRZQ0dDQUVEUUFMREFFTElBSW9BakJGRFFFZ0FrRUFOZ0l3Q3lBQ0lBYzJBbHdnQjBFQUlBZEJBV3RCQTBrYklRY01Bd3NnQWtFZ0lBSW9BZ3dpQldzaUJFRURkaUlBSUFJb0FoUnFJZ00yQWhRZ0FpQUNLQUlRSUFCcklnQTJBaEFnQWlBRVFYaHhJZ1JCSUVjRWZ5QU5LQUlBSUFSMEJVRUFDellDQ0NBQ0lBUWdCV28yQWd3Z0ZpQUROZ0lZSUJZZ0FEWUNGQ0FDSUFjMkFsd2dCMEVBSUFkQkFXdEJBMGtiSVFjTUFndEJBU0VIQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSi9Ba0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FnQWlnQ0FBNFpIaGdBR2hzSkF4QVFFQkFYQkJFU0VSRUZBUWNJQWd3TkV4OExJQUlvQXVBbUlRQU1HQXNnQWlBQ0tBSUVJZ0JCQW5ScUtBTFFBU0VIREFRTElBSW9BdEFCSVFjTUNBc2dBaWdDQkF3R0N5QUNLQUs4QVNJQVFRQk1EUmNnQWlnQ0RDRUhBMEFnQjBFWmEwRUhUUVJBSUFJb0FoUWlCa1VFUUVFQ0lRY01IUXNnQWlBQ0tBSUlRUWgySWdVMkFnZ2dBaWdDRUNJRUxRQUFJUU1nQWlBR1FRRnJOZ0lVSUFJZ0JFRUJhallDRUNBQ0lBTkJHSFFnQlhJMkFnZ2dCMEVJYXlFSEN5QUNJQUJCQVdzaUF6WUN2QUVnQWlBSFFRaHFJZ2MyQWd3Z0FFRUJTaUZJSUFNaEFDQklEUUFMREJjTElBSW9BZ1FpQUVFRFRnUkFJQUpCQlRZQ0FBd2FDeUFDSUEwZ0FpQUFRUUowYWtIUUFXb1FReUlIUVFGSERSa2dBa0hRQVdvaUF5QUNLQUlFUVFKMGFpSUFJQUFvQWdCQkFXbzJBZ0FnQXlBQ0tBSUVJZ0JCQW5ScUtBSUFJZ2RCQVUwRVFFRUJJUWNnQWlBQVFRRnFOZ0lFREJvTElBSkJFallDQUFzZ0IwRUNhaUlESUFNZ0FpZ0NyQUVnQUVIZ0UyeHFRUUFnQWhBaUlnZEJBVWNOR0NBQ1FSTTJBZ0FMUVJwQkdpQUNLQUt3QVNBQ0tBSUVRYkFNYkdwQkFDQUNFQ0lpQjBFQlJ3MFhJQUpCRkRZQ0FBc2dBaWdDQkNFUEFrQUNmeUFDS0FMWUprVUVRQ0FDS0FLd0FTQVBRYkFNYkdvaENnSkFBa0FnQWlnQ0RDSURRUkpyUVE5UEJFQWdEU2dDQUNFT0RBRUxJQUlvQWhRaEJ5QURJUUFEUUNBSFJRMENJQUlnQWlnQ0NFRUlkaUlHTmdJSUlBSW9BaEFpQlMwQUFDRUVJQUlnQjBFQmF5SUhOZ0lVSUFJZ0FFRUlheUlETmdJTUlBSWdCVUVCYWpZQ0VDQUNJQVJCR0hRZ0JuSWlEallDQ0NBQVFScHJJVWtnQXlFQUlFbEJEMGtOQUFzTElBSWdDaUFPSUFOMklnQkIvd0Z4UVFKMGFpSUhMUUFBSWdSQkNVOEVmeUFEUVFocUlRTWdCeUFITHdFQ1FRSjBhaUFFUVFKMFFiQVphaWdDQUNBQVFRaDJjVUgvQUhGQkFuUnFJZ2N0QUFBRklBUUxRZjhCY1NBRGFqWUNEQ0FITHdFQ0RBSUxJQW9nRFNBc1FRaHFFQlZGQkVCQkFpRUhEQm9MSUN3b0FnZ01BUXNnQWlnQ3dBRUxJZ3RCQW5RaUNrSGdHR290QUFJaUVVRWdJQUlvQWd3aUEydE5CRUFnRFNnQ0FDRU9EQUVMSUFJb0FoUWhCeUFESVFBRFFDQUhSUTBOSUFJZ0FpZ0NDRUVJZGlJR05nSUlJQUlvQWhBaUJTMEFBQ0VFSUFJZ0IwRUJheUlITmdJVUlBSWdBRUVJYXlJRE5nSU1JQUlnQlVFQmFqWUNFQ0FDSUFSQkdIUWdCbklpRGpZQ0NFRW9JQUJySVVvZ0F5RUFJRW9nRVVrTkFBc0xJQUlnQXlBUmFqWUNEQ0FDSUE5QkFuUnFJQXBCNEJocUx3RUFJQkZCQW5SQjBCbHFLQUlBSUE0Z0EzWnhhallDeEFFZ0FrRUFOZ0xZSmlBQ1FSRTJBZ0JCQVNFSElBSWdBaWdDQkVFQmFqWUNCQXdXQ3dKQUlBSW9BZ3dpQUVFYmEwRUdUd1JBSUEwb0FnQWhCd3dCQzBFQ0lRY2dBaWdDRkNJR1JRMFdJQUlnQWlnQ0NFRUlkaUlGTmdJSUlBSW9BaEFpQkMwQUFDRURJQUlnQmtFQmF6WUNGQ0FDSUFSQkFXbzJBaEFnQWlBRFFSaDBJQVZ5SWdjMkFnZ2dBRUVJYXlFQUN5QUNJQUJCQm1vMkFnd2dBaUFISUFCMklnQkJBM0VpQXpZQzlBRWdBaUFEUVFKMFFkQVphaWdDQURZQy9BRWdBaUFBUVFKMlFROXhJQU4wUVJCcU5nTDRBU0FDSUFJb0FpQWdBaWdDMEFFZ0FpZ0NHQkVDQUNJQU5nTHdKa0ZySVFjZ0FFVU5GU0FDUWdZM0F3QkJBQXNpQUNBQ0tBTFFBU0lIU0FSQUEwQUNRQ0FDS0FJTUlnZEJIMnRCQWs4RVFDQU5LQUlBSVFNTUFRc2dBaWdDRkNJR1JRME5JQUlnQWlnQ0NFRUlkaUlGTmdJSUlBSW9BaEFpQkMwQUFDRURJQUlnQmtFQmF6WUNGQ0FDSUFSQkFXbzJBaEFnQWlBRFFSaDBJQVZ5SWdNMkFnZ2dCMEVJYXlFSEN5QUNJQWRCQW1vMkFnd2dBaWdDOENZZ0FHb2dBeUFIZGtFRGNUb0FBQ0FBUVFGcUlnQWdBaWdDMEFFaUIwZ05BQXNMSUFKQkZUWUNBQXNnQjBFR2RDQXZJRGtnQWhCQ0lnZEJBVWNORXlBdFFnQTNBZ0FnTFVJQU53SVlJQzFDQURjQ0VDQXRRZ0EzQWdnZ0FpZ0MwQUVpQ2dSQUlEa29BZ0FoRVVFQUlRNERRQ0FPUVFaMElnOUJBM0loQmlBUFFRSnlJUVVnRDBFQmNpRUVJQThnRVdvdEFBQWhDMEVBSVFkQkFDRUFBMEFnQUNBUklBUWdCMnBxTFFBQUlBdHpJQkVnQnlBUGFtb3RBQUFnQzNOeUlCRWdCU0FIYW1vdEFBQWdDM055SUJFZ0JpQUhhbW90QUFBZ0MzTnljaUVBSUFkQlBFa2hTeUFIUVFScUlRY2dTdzBBQ3lBQVJRUkFJQUlnRGtFRGRrSDgvLy8vQVhGcVFmd21haUlBSUFBb0FnQkJBU0FPZEhJMkFnQUxJQTVCQVdvaURpQUtSdzBBQ3dzZ0FrRVdOZ0lBQ3lBQ0tBTDRBU0lGUVQ1QkdDQUNMUURjSmtFZ2NTSUFHeUFDS0FMMEFTSUhRUUZxZEdvaUJDRURBa0FnQUVVTkFFRUJJQWQwSVFZZ0IwRUNkQ0lEUWVBYWFpZ0NBQ0lBSUFWQkVHc2lCVXNFUUNBRFFmQWFhaWdDQUNBRklBWnFhaUVEREFFTElBTkI4QnBxS0FJQUlRTWdCU0FBSUFacUlnQkxCRUFnQXlBRmFpRUREQUVMSUFBZ0Eyb2hBd3NnQWlnQzJBRkJBblFnUUNBL0lBSVFRaUlIUVFGSERSSWdBaUFUUVlBQ1FZQUNJQUlvQXVnbUVDZ2dBaUFiUWNBRlFjQUZJQUlvQXRRQkVDaHhJQUlnRUNBRUlBTWdBaWdDZ0FJUUtIRkJBWEZGQkVBZ0FrRnFOZ0pjUVFBaEJ3d1VDeUFDUWhjM0F3QkJBQ0VESUJNaEFBd0JDeUFUSVFBQ1FBSkFJQUlvQWdRaUF3NERBZ0FCQXdzZ0d5RUFEQUVMSUJBaEFBc0NmeUFDS0FMRUprRUJSZ1JBSUFJb0Fvd1FEQUVMSUFBb0FnUWhCQ0FDUVFFMkFzUW1JQUpCQURZQ2pCQWdBaUFFTmdLUUVFRUFDeUFBTHdFTVNBUkFJQUlvQXBBUUlRY0RRQ0FBTHdFSUlBQXZBUW9nQnlBc1FReHFJQUlRSWlJSFFRRkhEUklnQUNnQ0FDQUNLQUtNRUNJRFFRSjBhaUFDS0FLUUVEWUNBQ0FzS0FJTUlRUWdBaUFEUVFGcUlnTTJBb3dRSUFJZ0FpZ0NrQkFnQkVFQ2RHb2lCellDa0JBZ0F5QUFMd0VNU0EwQUN5QUNLQUlFSVFNTElBSkJBRFlDeENZZ0FpQURRUUZxTmdJRVFRRWhCeUFEUVFKSURSQWdBaUFDS0FMc0ppQUNLQUxnQVNJRFFRWjBhaUlBTmdKMElBSWdBaUFEUVFOMlFmei8vLzhCY1dwQi9DWnFLQUlBSUFOMlFRRnhOZ0swQVNBQ0lBSW9BbndnQUMwQUFFRUNkR29vQWdBMkFvZ0NJQU1nQWlnQzhDWnFMUUFBSVFBZ0FpQUNLQUtFQWpZQ2VDQUNJQUJCQTNGQkNYUkJnQnRxTmdKd0lBSWdBaWdDakFFb0FnQTJBbXhCWlNFSElBSVFRVVVORUF3SEN5QUNRV0UyQWx4QkFDRUhEQkFMQW44Z0FpZ0NCQ0VFSUFJb0FqUWhBMEVDSVFZQ1FBSkFJQUlvQWhSQkhFa05BQ0FDUVFocUVDa2FRV0VoQmdKL0FrQUNRQUpBQWtBZ0FpZ0NBRUVIYXc0RUFBRUNBd1lMUVFBTUF3dEJBUXdDQzBFQ0RBRUxRUU1MSVFBRFFBSkFBa0FDUUFKQUFrQUNRQUpBSUFBT0F3QUJCQU1MQWtBQ1FDQUNLQUlVSWhKQkhFa05BQ0FDS0FMSUFTSUZEUUVEUUNBQ0tBTFVBU0lQUVFKUEJFQWdBaWdDckFGQjRCTnFJVXdnQWlnQ0NDRUZJQUlvQWd3aUFFRVFUd1JBSUFJZ0FFRVFjeUlBTmdJTUlBSWdCVUVRZGlJSE5nSUlJQUlvQWhBaUJpOEFBQ0VGSUFJZ0FpZ0NGRUVDYXpZQ0ZDQUNJQVpCQW1vMkFoQWdBaUFGUVJCMElBZHlJZ1UyQWdnTElBSW9BckFCSVFvZ1RDQUZJQUIySWdkQi93RnhRUUowYWlJR0xRQUFJZ3hCQ1U4RVFDQUdJQVl2QVFKQkFuUnFJQXhCQW5SQnNCbHFLQUlBSUFkQkNIWnhRUUowYWlJR0xRQUFJUXdnQUVFSWFpRUFDeUFHTHdFQ0lRc2dBQ0FNUWY4QmNXb2lBRUVRVHdSQUlBSWdBRUVRY3lJQU5nSU1JQUlnQlVFUWRpSUhOZ0lJSUFJb0FoQWlCaThBQUNFRklBSWdBaWdDRkVFQ2F6WUNGQ0FDSUFaQkFtbzJBaEFnQWlBRlFSQjBJQWR5SWdVMkFnZ0xJQXBCc0F4cUlBVWdBSFlpQjBIL0FYRkJBblJxSWdZdEFBQWlERUVKVHdSQUlBWWdCaThCQWtFQ2RHb2dERUVDZEVHd0dXb29BZ0FnQjBFSWRuRkJBblJxSWdZdEFBQWhEQ0FBUVFocUlRQUxJQVl2QVFJaUIwRUNkRUhnR0dvaUJpOEJBQ0VLSUFZdEFBSWhFU0FBSUF4Qi93RnhhaUVBSUFJQ2Z5QUhRUmxIQkVBZ0FFRVFUd1JBSUFJZ0FFRVFjeUlBTmdJTUlBSWdCVUVRZGlJSE5nSUlJQUlvQWhBaUJpOEFBQ0VGSUFJZ0FpZ0NGRUVDYXpZQ0ZDQUNJQVpCQW1vMkFoQWdBaUFGUVJCMElBZHlJZ1UyQWdnTElBSWdBQ0FSYWpZQ0RDQVJRUUowUWRBWmFpZ0NBQ0FGSUFCMmNRd0JDd0pBQWtBZ0FFRVBUUVJBSUFWQkVIWWhCaUFBUVJCcUlRd2dCU0FBZGtILy93TnhJUmdnQWlnQ0ZDRUhJQUlvQWhBaEFBd0JDeUFDSUFCQkVITWlEallDRENBQ0lBVkJFSFlpQlRZQ0NDQUNLQUlRSWdBdkFBQWhCaUFDSUFJb0FoUkJBbXNpQnpZQ0ZDQUNJQUJCQW1vaUFEWUNFQ0FDSUFaQkVIUWdCWElpQlRZQ0NDQUZJQTUyUWYvL0EzRWhHQ0FPUVJCcUlRd2dEa0Z2U3cwQkN5QUNJQVkyQWdnZ0FpQU1RUkJ6SWd3MkFnd2dBQzhBQUNFRklBSWdCMEVDYXpZQ0ZDQUNJQUJCQW1vMkFoQWdBaUFGUVJCMElBWnlJZ1UyQWdnTElBSWdEQ0FSUVJCcklnQnFOZ0lNSUFCQkFuUkIwQmxxS0FJQUlBVWdESFp4UVJCMElCaHlDeUFLYWpZQ3lBRUNmd0pBQWtBQ1FDQUxEZ0lCQUFJTElBSW9BdWdCUVFGcURBSUxJQUlvQXVRQkRBRUxJQXRCQW1zTElRQWdBaUFDS0FMb0FUWUM1QUVnQWlBQUlBOUJBQ0FBSUE5UEcyc2lBRFlDNkFFZ0FpQUNLQUtNQVNBQVFRSjBhaWdDQURZQ2JBc2dBaWdDRkNJU1FSdE5EUUVnQWlnQ3lBRWlCVVVOQUFzTUFRc2dBa0VITmdJQVFRSWhCZ3dJQ3lBQ0tBSUlJUUFnQWlnQ2JDRk5JQUlvQWd3aUJFRVFUd1JBSUFJZ0JFRVFjeUlFTmdJTUlBSWdBRUVRZGlJSE5nSUlJQUlvQWhBaUJpOEFBQ0VBSUFJZ0VrRUNheUlTTmdJVUlBSWdCa0VDYWpZQ0VDQUNJQUJCRUhRZ0IzSWlBRFlDQ0FzZ1RTQUFJQVIySWdkQi93RnhRUUowYWlJTUxRQUFJZ1pCQ1U4RVFDQU1JQXd2QVFKQkFuUnFJQVpCQW5SQnNCbHFLQUlBSUFkQkNIWnhRUUowYWlJTUxRQUFJUVlnQkVFSWFpRUVDeUFDSUFRZ0JrSC9BWEZxSWdZMkFnd2dBaUFNTHdFQ1FRTjBRWUFyYWlJSExRQURJZ1EyQXJnQklBSWdCeXdBQWpZQ25BSWdBaUFFSUFJb0FuaHFMUUFBT2dDTUFpQUhMd0VFSVU0Z0J5OEJCaUVLSUFjdEFBRWhEa0VBSVF3Q1FDQUhMUUFBSWc5RkRRQWdEMEVRVFFSQUlBWkJFRThFUUNBQ0lBWkJFSE1pQmpZQ0RDQUNJQUJCRUhZaUJ6WUNDQ0FDS0FJUUlnUXZBQUFoQUNBQ0lCSkJBbXNpRWpZQ0ZDQUNJQVJCQW1vMkFoQWdBaUFBUVJCMElBZHlJZ0EyQWdnTElBOUJBblJCMEJscUtBSUFJQUFnQm5aeElRd2dCaUFQYWlFR0RBRUxBa0FDUUNBR1FROU5CRUFnQUVFUWRpRU1JQVpCRUdvaEdDQUFJQVoyUWYvL0EzRWhFU0FDS0FJUUlRWU1BUXNnQWlBR1FSQnpJZ2MyQWd3Z0FpQUFRUkIySWdRMkFnZ2dBaWdDRUNJQUx3QUFJUXdnQWlBU1FRSnJJaEkyQWhRZ0FpQUFRUUpxSWdZMkFoQWdBaUFNUVJCMElBUnlJZ0EyQWdnZ0FDQUhka0gvL3dOeElSRWdCMEVRYWlFWUlBZEJiMHNOQVFzZ0FpQU1OZ0lJSUFJZ0dFRVFjeUlZTmdJTUlBWXZBQUFoQUNBQ0lCSkJBbXNpRWpZQ0ZDQUNJQVpCQW1vMkFoQWdBaUFBUVJCMElBeHlJZ0EyQWdnTElBOUJFR3NpQkVFQ2RFSFFHV29vQWdBZ0FDQVlkbkZCRUhRZ0VYSWhEQ0FFSUJocUlRWUxBbjhnRGtFUVRRUkFJQVpCRUU4RVFDQUNJQVpCRUhNaUJqWUNEQ0FDSUFCQkVIWWlCellDQ0NBQ0tBSVFJZ1F2QUFBaEFDQUNJQkpCQW1zMkFoUWdBaUFFUVFKcU5nSVFJQUlnQUVFUWRDQUhjaUlBTmdJSUN5QUNJQVlnRG1vMkFnd2dEa0VDZEVIUUdXb29BZ0FnQUNBR2RuRU1BUXNDUUFKQUlBWkJEMDBFUUNBQVFSQjJJUmdnQmtFUWFpRUVJQUFnQm5aQi8vOERjU0VSSUFJb0FoQWhCZ3dCQ3lBQ0lBWkJFSE1pQnpZQ0RDQUNJQUJCRUhZaUJEWUNDQ0FDS0FJUUlnQXZBQUFoR0NBQ0lCSkJBbXNpRWpZQ0ZDQUNJQUJCQW1vaUJqWUNFQ0FDSUJoQkVIUWdCSElpQURZQ0NDQUFJQWQyUWYvL0EzRWhFU0FIUVJCcUlRUWdCMEZ2U3cwQkN5QUNJQmcyQWdnZ0FpQUVRUkJ6SWdRMkFnd2dCaThBQUNFQUlBSWdFa0VDYXpZQ0ZDQUNJQVpCQW1vMkFoQWdBaUFBUVJCMElCaHlJZ0EyQWdnTElBSWdCQ0FPUVJCcklnWnFOZ0lNSUFaQkFuUkIwQmxxS0FJQUlBQWdCSFp4UVJCMElCRnlDeUVBSUFJZ0JVRUJhellDeUFFZ0FpQUFJQXBxTmdLWUFpQk9JQXhxSWdSRkRRRWdBaUFDS0FLOEFTQUVhellDdkFGQkFTRUFEQVlMSUFJb0FyUUJJUklEUUFKQUFrQWdFZ1JBSUFJb0FnZ2hCaUFDS0FJTUloSkJFRThFUUNBQ0lCSkJFSE1pRWpZQ0RDQUNJQVpCRUhZaUJqWUNDQ0FDS0FJUUlnVXZBQUFoQUNBQ0lBSW9BaFJCQW1zMkFoUWdBaUFGUVFKcU5nSVFJQUlnQUVFUWRDQUdjaUlHTmdJSUN5QUNLQUtJQWlBR0lCSjJRZjhCY1VFQ2RHb2lBQzhCQWlFRklBQXRBQUFoQmdOQUlBSW9BaFJCRzAwRVFDQUNRUWcyQWdCQkFpRUdEQXdMQWtBZ0FpZ0N4QUVFUUNBQ0tBSU1JUXdnQWlnQ2lBSWhEd3dCQ3lBQ0VFQWdBaWdDQ0NFR0lBSW9BZ3dpREVFUVR3UkFJQUlnREVFUWN5SU1OZ0lNSUFJZ0JrRVFkaUlHTmdJSUlBSW9BaEFpQlM4QUFDRUFJQUlnQWlnQ0ZFRUNhellDRkNBQ0lBVkJBbW8yQWhBZ0FpQUFRUkIwSUFaeUlnWTJBZ2dMSUFJb0FyUUJSUTBFSUFJb0FvZ0NJZzhnQmlBTWRrSC9BWEZCQW5ScUlnQXZBUUloQlNBQUxRQUFJUVlMQW44Z0JrSC9BWEVpQ2tFSlR3UkFJQUlvQWdnaEVpQU1RUkJQQkVBZ0FpQU1RUkJ6SWd3MkFnd2dBaUFTUVJCMklnYzJBZ2dnQWlnQ0VDSUdMd0FBSVFBZ0FpQUNLQUlVUVFKck5nSVVJQUlnQmtFQ2FqWUNFQ0FDSUFCQkVIUWdCM0lpRWpZQ0NBc2dBaUFNSUE4Z0VpQU1kaUlBUWY4QmNVRUNkR29nQlVILy93TnhRUUowYWlBS1FRSjBRYkFaYWlnQ0FDQUFRUWgyY1VFQ2RHb2lBQzBBQUdwQkNHb2lCallDRENBQUxRQUNEQUVMSUFJZ0NpQU1haUlHTmdJTUlBSW9BZ2doRWlBRkN5RUtJQVpCRUU4RVFDQUNJQVpCRUhNaUJqWUNEQ0FDSUJKQkVIWWlCellDQ0NBQ0tBSVFJZ1V2QUFBaEFDQUNJQUlvQWhSQkFtczJBaFFnQWlBRlFRSnFOZ0lRSUFJZ0FFRVFkQ0FIY2lJU05nSUlDeUFQSUJJZ0JuWkIvd0Z4UVFKMGFpSUFMd0VDSVFVZ0FDMEFBQ0VHSUFJb0FtUWdBMm9nQ2pvQUFDQUNJQUlvQXNRQlFRRnJOZ0xFQVNBRFFRRnFJZ01nQWlnQ1FFWUVRQ0FDUVEwMkFnQWdCRUVCYXlFRVFRRWhCZ3dNQ3lBRVFRRnJJZ1FOQUFzTUFRc2dBaWdDWkNJRklBSW9Ba1FpQUNBRFFRSnJjV290QUFBaEJpQUZJQUFnQTBFQmEzRnFMUUFBSVFVRFFDQUNLQUlVUVJ0TkJFQWdBa0VJTmdJQVFRSWhCZ3dMQ3lBQ0tBTEVBVVVFUUNBQ0VFQWdBaWdDdEFFaUVnMEVDeUFDS0FKOElBSW9BblFnQWlnQ2NDSUFJQVpCL3dGeGFpMEFnQUlnQUNBRlFmOEJjV290QUFCeWFpMEFBRUVDZEdvb0FnQWhUeUFDS0FJSUlSSWdBaWdDRENJR1FSQlBCRUFnQWlBR1FSQnpJZ1kyQWd3Z0FpQVNRUkIySWdvMkFnZ2dBaWdDRUNJSEx3QUFJUUFnQWlBQ0tBSVVRUUpyTmdJVUlBSWdCMEVDYWpZQ0VDQUNJQUJCRUhRZ0NuSWlFallDQ0FzZ1R5QVNJQVoySWdCQi93RnhRUUowYWlJU0xRQUFJZ3hCQ1U4RVFDQVNJQkl2QVFKQkFuUnFJQXhCQW5SQnNCbHFLQUlBSUFCQkNIWnhRUUowYWlJU0xRQUFJUXdnQmtFSWFpRUdDeUFDSUFZZ0RFSC9BWEZxTmdJTUlBSW9BbVFnQTJvZ0VpOEJBaUlBT2dBQUlBSWdBaWdDeEFGQkFXczJBc1FCSUFOQkFXb2lBeUFDS0FKQVJnUkFJQUpCRFRZQ0FDQUVRUUZySVFSQkFTRUdEQXNMSUFVaEJpQUFJUVVnQkVFQmF5SUVEUUFMQzBFQUlRUWdBaWdDdkFGQkFFb05BaUFDUVE0MkFnQkJBU0VHREFnTFFRQWhFZ3dBQ3dBTFFRSWhBQXdFQ3lBQ0tBSkFJQU5ySVFZQ1FBSkFBMEFnQkVFQmF5RUFJQVJCQUV3TkFTQUNLQUprSWdRZ0Eyb2dCQ0FDS0FKRUlBTWdBaWdDbkFKcmNXb3RBQUE2QUFBZ0EwRUJhaUVESUFBaEJDQUdRUUZySWdZTkFBc2dBa0VRTmdJQURBRUxJQUlvQXJ3QlFRQktCRUFnQUNFRURBTUxJQUpCRGpZQ0FBdEJBU0VHSUFBaEJBd0VDd0pBSUFJb0Fwd0NJZ0JCQUU0RVFDQUNJQUJGSWd3MkFyZ0JJQUlnQWlnQ1NFRUJheUlBTmdKSUlBSWdBaUFBUVFOeFFRSjBhaWdDVENJQU5nS2NBZ3dCQ3lBQ0tBTE1BVVVFUUNBQ0tBTFlBU0lQUVFKUEJFQWdBaWdDckFGQndDZHFJVkFnQWlnQ0NDRUFJQUlvQWd3aUJFRVFUd1JBSUFJZ0JFRVFjeUlFTmdJTUlBSWdBRUVRZGlJR05nSUlJQUlvQWhBaUJTOEFBQ0VBSUFJZ0FpZ0NGRUVDYXpZQ0ZDQUNJQVZCQW1vMkFoQWdBaUFBUVJCMElBWnlJZ0EyQWdnTElBSW9BckFCSVFvZ1VDQUFJQVIySWdkQi93RnhRUUowYWlJRkxRQUFJZ1pCQ1U4RVFDQUZJQVV2QVFKQkFuUnFJQVpCQW5SQnNCbHFLQUlBSUFkQkNIWnhRUUowYWlJRkxRQUFJUVlnQkVFSWFpRUVDeUFGTHdFQ0lRc2dCQ0FHUWY4QmNXb2lCRUVRVHdSQUlBSWdCRUVRY3lJRU5nSU1JQUlnQUVFUWRpSUdOZ0lJSUFJb0FoQWlCUzhBQUNFQUlBSWdBaWdDRkVFQ2F6WUNGQ0FDSUFWQkFtbzJBaEFnQWlBQVFSQjBJQVp5SWdBMkFnZ0xJQXBCNEJocUlBQWdCSFlpQjBIL0FYRkJBblJxSWdVdEFBQWlCa0VKVHdSQUlBVWdCUzhCQWtFQ2RHb2dCa0VDZEVHd0dXb29BZ0FnQjBFSWRuRkJBblJxSWdVdEFBQWhCaUFFUVFocUlRUUxJQVV2QVFJaUNrRUNkRUhnR0dvaUJTOEJBQ0VISUFVdEFBSWhEaUFFSUFaQi93RnhhaUVFSUFJQ2Z5QUtRUmxIQkVBZ0JFRVFUd1JBSUFJZ0JFRVFjeUlFTmdJTUlBSWdBRUVRZGlJR05nSUlJQUlvQWhBaUJTOEFBQ0VBSUFJZ0FpZ0NGRUVDYXpZQ0ZDQUNJQVZCQW1vMkFoQWdBaUFBUVJCMElBWnlJZ0EyQWdnTElBSWdCQ0FPYWpZQ0RDQU9RUUowUWRBWmFpZ0NBQ0FBSUFSMmNRd0JDd0pBQWtBZ0JFRVBUUVJBSUFCQkVIWWhCU0FFUVJCcUlRWWdBQ0FFZGtILy93TnhJUkVnQWlnQ0ZDRVlJQUlvQWhBaEJBd0JDeUFDSUFSQkVITWlDallDRENBQ0lBQkJFSFlpQmpZQ0NDQUNLQUlRSWdBdkFBQWhCU0FDSUFJb0FoUkJBbXNpR0RZQ0ZDQUNJQUJCQW1vaUJEWUNFQ0FDSUFWQkVIUWdCbklpQURZQ0NDQUFJQXAyUWYvL0EzRWhFU0FLUVJCcUlRWWdDa0Z2U3cwQkN5QUNJQVUyQWdnZ0FpQUdRUkJ6SWdZMkFnd2dCQzhBQUNFQUlBSWdHRUVDYXpZQ0ZDQUNJQVJCQW1vMkFoQWdBaUFBUVJCMElBVnlJZ0EyQWdnTElBSWdCaUFPUVJCcklnUnFOZ0lNSUFSQkFuUkIwQmxxS0FJQUlBQWdCblp4UVJCMElCRnlDeUFIYWpZQ3pBRUNmd0pBQWtBQ1FDQUxEZ0lCQUFJTElBSW9BdkFCUVFGcURBSUxJQUlvQXV3QkRBRUxJQXRCQW1zTElRQWdBaUFDS0FMd0FUWUM3QUVnQWlBQUlBOUJBQ0FBSUE5UEcyc2lBRFlDOEFFZ0FpQUNLQUtFQWlBQVFRSjBhaUlBTmdKNElBSWdBQ0FDS0FLNEFXb3RBQUE2QUl3Q0N3c2dBaWdDQ0NFQUlBSW9BcHdCSUFJdEFJd0NRUUowYWlnQ0FDRUtJQUlvQWd3aUJFRVFUd1JBSUFJZ0JFRVFjeUlFTmdJTUlBSWdBRUVRZGlJR05nSUlJQUlvQWhBaUJTOEFBQ0VBSUFJZ0FpZ0NGRUVDYXpZQ0ZDQUNJQVZCQW1vMkFoQWdBaUFBUVJCMElBWnlJZ0EyQWdnTElBb2dBQ0FFZGlJSFFmOEJjU0lGUVFKMGFpSUdMUUFBSWd4QkNVOEVRQ0FHSUFvZ0JVRUNkR292QVFKQkFuUnFJQXhCQW5SQnNCbHFLQUlBSUFkQkNIWnhRUUowYWlJR0xRQUFJUXdnQkVFSWFpRUVDeUFDSUFRZ0RFSC9BWEZxSWd3MkFnd2dCaThCQWlFRUlBSkJBRFlDdUFFZ0FpQUVOZ0tjQWdKL0lBSUNmeUFFUVE5TkJFQWdCRVVFUUNBQ0lBSW9Ba2hCQVdzaUFEWUNTQ0FDSUFCQkEzRkJBblJxS0FKTUlRQWdBa0VCTmdLNEFTQUNJQUEyQXB3Q1FRRU1Bd3RCZ01yK1VpQUVRUUYwSWdCMlFRTnhJZ1VnQWlBQ0tBSklRWnYrdjlWNklBQjJha0VEY1VFQ2RHb29Ba3dpQUdvZ0JFRUJjUTBCR2tILy8vLy9CeUFBSUFWcklnQWdBRUVBVEJzTUFRc0NRQ0FFSUFJb0F2Z0JJZ3BySWc5QkFFZ05BQ0FDS0FMMEFTSUhSUVJBSUE5QkFYRkJBbklnRDBFQmRpSUZRUUZxSWdaMElRY0NmeUFQUVI5TkJFQWdERUVRVHdSQUlBSWdERUVRY3lJTU5nSU1JQUlnQUVFUWRpSUZOZ0lJSUFJb0FoQWlCQzhBQUNFQUlBSWdBaWdDRkVFQ2F6WUNGQ0FDSUFSQkFtbzJBaEFnQWlBQVFSQjBJQVZ5SWdBMkFnZ0xJQUlnQmlBTWFqWUNEQ0FHUVFKMFFkQVphaWdDQUNBQUlBeDJjUXdCQ3dKQUFrQWdERUVQVFFSQUlBQkJFSFloQmlBTVFSQnFJUVFnQUNBTWRrSC8vd054SVE4Z0FpZ0NGQ0VZSUFJb0FoQWhEQXdCQ3lBQ0lBeEJFSE1pQ3pZQ0RDQUNJQUJCRUhZaUJEWUNDQ0FDS0FJUUlnQXZBQUFoQmlBQ0lBSW9BaFJCQW1zaUdEWUNGQ0FDSUFCQkFtb2lERFlDRUNBQ0lBWkJFSFFnQkhJaUFEWUNDQ0FBSUF0MlFmLy9BM0VoRHlBTFFSQnFJUVFnQzBGdlN3MEJDeUFDSUFZMkFnZ2dBaUFFUVJCeklnUTJBZ3dnREM4QUFDRUFJQUlnR0VFQ2F6WUNGQ0FDSUF4QkFtbzJBaEFnQWlBQVFSQjBJQVp5SWdBMkFnZ0xJQUlnQkNBRlFROXJJZ1ZxTmdJTUlBVkJBblJCMEJscUtBSUFJQUFnQkhaeFFSQjBJQTl5Q3lBSElBcHFha0VFYXlFRURBRUxJQThnQjNZaUJrRUJkaUlGUVFGcUlRc2dBaWdDL0FFZ0QzRWdDbW9DZnlBR1FSOU5CRUFnREVFUVR3UkFJQUlnREVFUWN5SU1OZ0lNSUFJZ0FFRVFkaUlGTmdJSUlBSW9BaEFpQkM4QUFDRUFJQUlnQWlnQ0ZFRUNhellDRkNBQ0lBUkJBbW8yQWhBZ0FpQUFRUkIwSUFWeUlnQTJBZ2dMSUFJZ0N5QU1hallDRENBTFFRSjBRZEFaYWlnQ0FDQUFJQXgyY1F3QkN3SkFBa0FnREVFUFRRUkFJQUJCRUhZaEVTQU1RUkJxSVE4Z0FDQU1ka0gvL3dOeElSSWdBaWdDRkNFWUlBSW9BaEFoREF3QkN5QUNJQXhCRUhNaUNqWUNEQ0FDSUFCQkVIWWlCRFlDQ0NBQ0tBSVFJZ0F2QUFBaEVTQUNJQUlvQWhSQkFtc2lHRFlDRkNBQ0lBQkJBbW9pRERZQ0VDQUNJQkZCRUhRZ0JISWlBRFlDQ0NBQUlBcDJRZi8vQTNFaEVpQUtRUkJxSVE4Z0NrRnZTdzBCQ3lBQ0lCRTJBZ2dnQWlBUFFSQnpJZzgyQWd3Z0RDOEFBQ0VBSUFJZ0dFRUNhellDRkNBQ0lBeEJBbW8yQWhBZ0FpQUFRUkIwSUJGeUlnQTJBZ2dMSUFJZ0R5QUZRUTlySWdScU5nSU1JQVJCQW5SQjBCbHFLQUlBSUFBZ0QzWnhRUkIwSUJKeUN5QUdRUUZ4UVFKeUlBdDBha0VFYXlBSGRHb2hCQXNnQkVFUGF3c2lBRFlDbkFKQkFBc2hEQ0FDSUFJb0Fzd0JRUUZyTmdMTUFRc2dBaWdDUENJR0lBSW9BamdpQkVjRVFDQUNJQU1nQkNBRElBUklHeUlHTmdJOEN5QUNLQUtZQWlFRUFrQWdBQ0FHU2dSQVFYQWdBRUg4Ly8vL0Iwb05CeHBCZENBRVFRUnJRUlJMRFFjYUlBSW9BdlFtSWdVZ0JFRUNkR29vQWlBaEJ5QUVJQVZxTFFBQUlRc2dBaUFDS0FKSUlBeHFOZ0pJUVcwZ0JTZ0NwQUVpQlVVTkJ4cEJkU0FBSUFaQmYzTnFJZ0FnQzNVaUNpQUNLQUw0SmlJR0tBSU1UZzBIR2lBRklBdEJBblJCMEJscUtBSUFJQUJ4SUFSc0lBZHFhaUVGSUFJb0FtUWdBMm9oQUFKL0lBWXVBUlFnQ2tZRVFDQUFJQVVnQkJBVEdpQUVEQUVMSUFBZ0JTQUVJQVlnQ2hCRUN5RUFJQUlnQWlnQ3ZBRWdBR3MyQXJ3QklBQWdBMm9pQXlBQ0tBSkFTQVJBSUFNaEFBd0NDeUFDUVE4MkFnQkJBU0VHREFVTElBSW9BbVFoQnlBQ0tBSkVJUVlnQWlBQ0tBSklJZ1ZCQTNGQkFuUnFJQUEyQWt3Z0FpQUZRUUZxTmdKSUlBSWdBaWdDdkFFZ0JHczJBcndCSUFjZ0JpQURJQUJyY1NJRmFpSUtLUUFBSVdnZ0F5QUhhaUlISUFvcEFBZzNBQWdnQnlCb053QUFJQU1nQkNBRmFpSUdTQ0FGSUFNZ0JHb2lBRWh4RFFJZ0FDQUNLQUpBSWdWT0RRSWdCU0FHVEEwQ0lBUkJFVWdOQUNBS1FSQnFJUVVnQjBFUWFpRURJQVJCSVU4RVFDQURJQVVnQkVFUWF4QVRHZ3dCQ3lBRktRQUFJV2dnQXlBRktRQUlOd0FJSUFNZ2FEY0FBQXNnQWlnQ3ZBRkJBRW9FUUNBQUlRTU1BUXNnQWtFT05nSUFRUUVoQmlBQUlRTU1Bd3RCQUNFQURBRUxRUU1oQUF3QUN3QUxJQUlnQkRZQ0JDQUNJQU0yQWpRTElBWUxJZ2RCQWtjTkRpTUFRUkJySWlja0FDQUNRUWhxSVNVZ0FpZ0NCQ0VISUFJb0FqUWhCa0ZoSVFNQ1FBSi9Ba0FDUUFKQUFrQWdBaWdDQUVFSGF3NEVBQUVDQXdVTFFRQU1Bd3RCQWd3Q0MwRUJEQUVMUVFNTElRVURRQUpBQWtBQ1FBSkFBbjhDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQWdCUTREQUFFQ0JRc2dBa0VITmdJQUlBSW9Bc2dCRFFvRFFDTUFRUkJySWlBa0FBSi9Ba0FDUUNBQ0tBTFVBU0ljUVFKSkRRQWdBaWdDc0FFaEVpQUNLQUtzQVVIZ0Uyb2hEQ0FDS0FJVUlRc2dBaWdDRUNFS0lBSkJDR29pSFNnQ0FDSVlJUkVnQWlnQ0RDSVBJUVFDUUFKQUlBOUJFbXRCRGswRVFDQUtJUU1nRHlFQUlBc2hCUU5BSUFWRkRRSWdBaUFSUVFoMkloRTJBZ2dnQXkwQUFDRU9JQUlnQlVFQmF5SUZOZ0lVSUFJZ0FFRUlheUlFTmdJTUlBSWdBMEVCYWlJRE5nSVFJQUlnRGtFWWRDQVJjaUlSTmdJSUlBQkJHbXNoVVNBRUlRQWdVVUVQU1EwQUN3c2dBaUFNSUJFZ0JIWWlBRUgvQVhGQkFuUnFJZ1V0QUFBaUEwRUpUd1IvSUFSQkNHb2hCQ0FGSUFVdkFRSkJBblJxSUFOQkFuUkJzQmxxS0FJQUlBQkJDSFp4UWY4QWNVRUNkR29pQlMwQUFBVWdBd3RCL3dGeElBUnFOZ0lNSUNBZ0JTOEJBallDQ0F3QkN5QU1JQjBnSUVFSWFoQVZSUTBCQ3dKQUFuOGdBaWdDMkNaRkJFQWdFa0d3REdvaEVnSkFBa0FnQWlnQ0RDSUFRUkpyUVE5UEJFQWdIU2dDQUNFUkRBRUxJQUlvQWhRaEJTQUFJUU1EUUNBRlJRMENJQUlnQWlnQ0NFRUlkaUlSTmdJSUlBSW9BaEFpRGkwQUFDRUVJQUlnQlVFQmF5SUZOZ0lVSUFJZ0EwRUlheUlBTmdJTUlBSWdEa0VCYWpZQ0VDQUNJQVJCR0hRZ0VYSWlFVFlDQ0NBRFFScHJJVklnQUNFRElGSkJEMGtOQUFzTElCSWdFU0FBZGlJRVFmOEJjVUVDZEdvaUJTMEFBQ0lEUVFsUEJFQWdCU0FGTHdFQ1FRSjBhaUFEUVFKMFFiQVphaWdDQUNBRVFRaDJjVUgvQUhGQkFuUnFJZ1V0QUFBaEF5QUFRUWhxSVFBTElBSWdBQ0FEUWY4QmNXbzJBZ3dnQlM4QkFnd0NDeUFTSUIwZ0lFRU1haEFWUlEwQ0lDQW9BZ3dNQVFzZ0FpZ0N3QUVMSWhKQkFuUkI0QmhxTFFBQ0lneEJJQ0FDS0FJTUlnQnJUUVJBSUIwb0FnQWhFUXdEQ3lBQ0tBSVVJUVVnQUNFREEwQWdCUVJBSUFJZ0FpZ0NDRUVJZGlJUk5nSUlJQUlvQWhBaURpMEFBQ0VFSUFJZ0JVRUJheUlGTmdJVUlBSWdBMEVJYXlJQU5nSU1JQUlnRGtFQmFqWUNFQ0FDSUFSQkdIUWdFWElpRVRZQ0NFRW9JQU5ySVZNZ0FDRURJRk1nREVrTkFRd0VDd3NnQWlBU05nTEFBUXNnQWlBTE5nSVVJQUlnQ2pZQ0VDQUNJQmcyQWdnZ0FrRUFOZ0xZSmlBQ0lBODJBZ3dMUVFBTUFRc2dBa0VBTmdMWUppQUNJQUFnREdvMkFnd2dBaUFTUVFKMFFlQVlhaThCQUNBTVFRSjBRZEFaYWlnQ0FDQVJJQUIyY1dvMkFzZ0JBbjhDUUFKQUFrQWdJQ2dDQ0NJQURnSUFBZ0VMSUFJb0F1UUJEQUlMSUFCQkFtc01BUXNnQWlnQzZBRkJBV29MSVFBZ0FpQUNLQUxvQVRZQzVBRWdBaUFBSUJ4QkFDQUFJQnhQRzJzaUFEWUM2QUVnQWlBQ0tBS01BU0FBUVFKMGFpZ0NBRFlDYkVFQkN5RlVJQ0JCRUdva0FDQlVCRUFnQWtFSE5nSUFJQUlvQXNnQlJRMEJEQXdMQzBFQ0lRTU1Ed3NnQWtFSk5nSUFJQUlvQXB3Q0lnQkJBRWdOQVNBQ0lBQkZJZ0EyQXJnQklBSWdBaWdDU0VFQmF5SUROZ0pJSUFJZ0FpQURRUU54UVFKMGFpZ0NUQ0lGTmdLY0Fnd0NDeUFDS0FLMEFTRUZBMEFDUUNBQ1FRZzJBZ0FnQlFSQUlBSW9Bc1FCSVFVRFFBSkFJQVVOQUNBQ0VEOUZCRUJCQWlFRERCTUxJQUlvQXJRQkRRQkJBQ0VGREFRTElBSW9Bb2dDSVE4Q2Z3SkFBa0FnQWlnQ0RDSUFRUkpyUVE5UEJFQWdKU2dDQUNFS0RBRUxJQUlvQWhRaEJTQUFJUU1EUUNBRlJRMENJQUlnQWlnQ0NFRUlkaUlMTmdJSUlBSW9BaEFpQ2kwQUFDRUVJQUlnQlVFQmF5SUZOZ0lVSUFJZ0EwRUlheUlBTmdJTUlBSWdDa0VCYWpZQ0VDQUNJQVJCR0hRZ0MzSWlDallDQ0NBRFFScHJJVlVnQUNFRElGVkJEMGtOQUFzTElBSWdEeUFLSUFCMklnTkIvd0Z4UVFKMGFpSUZMUUFBSWdSQkNVOEVmeUFBUVFocUlRQWdCU0FGTHdFQ1FRSjBhaUFFUVFKMFFiQVphaWdDQUNBRFFRaDJjVUgvQUhGQkFuUnFJZ1V0QUFBRklBUUxRZjhCY1NBQWFqWUNEQ0FGTHdFQ0RBRUxJQThnSlNBblFReHFFQlZGRFFnZ0p5Z0NEQXNoQUNBQ0tBSmtJQVpxSUFBNkFBQWdBaUFDS0FMRUFVRUJheUlGTmdMRUFTQUdRUUZxSWdZZ0FpZ0NRRVlFUUNBQ1FRMDJBZ0FnQjBFQmF5RUhRUUVoQXd3U0N5QUhRUUZySWdjTkFBc01BUXNnQWlnQ1pDSUVJQUlvQWtRaUF5QUdRUUpyY1dvdEFBQWhBQ0FFSUFNZ0JrRUJhM0ZxTFFBQUlRUWdBaWdDeEFFaEF3TkFJQU5GQkVBZ0FoQS9SUVJBUVFJaEF3d1NDeUFDS0FLMEFTSUZEUU1MSUFJb0Fud2dBaWdDZENBQ0tBSndJZ01nQUVIL0FYRnFMUUNBQWlBRElBUkIvd0Z4YWkwQUFISnFMUUFBUVFKMGFpZ0NBQ0VPQW44Q1FBSkFJQUlvQWd3aUFFRVNhMEVQVHdSQUlDVW9BZ0FoQ2d3QkN5QUNLQUlVSVFVZ0FDRURBMEFnQlVVTkFpQUNJQUlvQWdoQkNIWWlEellDQ0NBQ0tBSVFJZ3N0QUFBaENpQUNJQVZCQVdzaUJUWUNGQ0FDSUFOQkNHc2lBRFlDRENBQ0lBdEJBV28yQWhBZ0FpQUtRUmgwSUE5eUlnbzJBZ2dnQTBFYWF5RldJQUFoQXlCV1FROUpEUUFMQ3lBQ0lBNGdDaUFBZGlJRFFmOEJjVUVDZEdvaUJTMEFBQ0lLUVFsUEJIOGdBRUVJYWlFQUlBVWdCUzhCQWtFQ2RHb2dDa0VDZEVHd0dXb29BZ0FnQTBFSWRuRkIvd0J4UVFKMGFpSUZMUUFBQlNBS0MwSC9BWEVnQUdvMkFnd2dCUzBBQWd3QkN5QU9JQ1VnSjBFTWFoQVZSUTBISUNjb0Fnd0xJUVVnQWlnQ1pDQUdhaUFGT2dBQUlBSWdBaWdDeEFGQkFXc2lBellDeEFFZ0JrRUJhaUlHSUFJb0FrQkdCRUFnQWtFTk5nSUFJQWRCQVdzaEIwRUJJUU1NRVFzZ0JDRUFJQVVoQkNBSFFRRnJJZ2NOQUFzTEMwRUFJQUlvQXJ3QlFRQktEUWthSUFKQkRqWUNBRUVCSVFOQkFDRUhEQTBMQWtBZ0FpZ0N6QUVOQUNNQVFSQnJJaUFrQUFKL0FrQUNRQ0FDS0FMWUFTSWNRUUpKRFFBZ0FpZ0NzQUVoRWlBQ0tBS3NBVUhBSjJvaERDQUNLQUlVSVFzZ0FpZ0NFQ0VLSUFKQkNHb2lIU2dDQUNJWUlSRWdBaWdDRENJUElRUUNRQUpBSUE5QkVtdEJEazBFUUNBS0lRTWdEeUVBSUFzaEJRTkFJQVZGRFFJZ0FpQVJRUWgySWhFMkFnZ2dBeTBBQUNFT0lBSWdCVUVCYXlJRk5nSVVJQUlnQUVFSWF5SUVOZ0lNSUFJZ0EwRUJhaUlETmdJUUlBSWdEa0VZZENBUmNpSVJOZ0lJSUFCQkdtc2hWeUFFSVFBZ1YwRVBTUTBBQ3dzZ0FpQU1JQkVnQkhZaUFFSC9BWEZCQW5ScUlnVXRBQUFpQTBFSlR3Ui9JQVJCQ0dvaEJDQUZJQVV2QVFKQkFuUnFJQU5CQW5SQnNCbHFLQUlBSUFCQkNIWnhRZjhBY1VFQ2RHb2lCUzBBQUFVZ0F3dEIvd0Z4SUFScU5nSU1JQ0FnQlM4QkFqWUNDQXdCQ3lBTUlCMGdJRUVJYWhBVlJRMEJDd0pBQW44Z0FpZ0MyQ1pGQkVBZ0VrSGdHR29oRWdKQUFrQWdBaWdDRENJQVFSSnJRUTlQQkVBZ0hTZ0NBQ0VSREFFTElBSW9BaFFoQlNBQUlRTURRQ0FGUlEwQ0lBSWdBaWdDQ0VFSWRpSVJOZ0lJSUFJb0FoQWlEaTBBQUNFRUlBSWdCVUVCYXlJRk5nSVVJQUlnQTBFSWF5SUFOZ0lNSUFJZ0RrRUJhallDRUNBQ0lBUkJHSFFnRVhJaUVUWUNDQ0FEUVJwcklWZ2dBQ0VESUZoQkQwa05BQXNMSUJJZ0VTQUFkaUlFUWY4QmNVRUNkR29pQlMwQUFDSURRUWxQQkVBZ0JTQUZMd0VDUVFKMGFpQURRUUowUWJBWmFpZ0NBQ0FFUVFoMmNVSC9BSEZCQW5ScUlnVXRBQUFoQXlBQVFRaHFJUUFMSUFJZ0FDQURRZjhCY1dvMkFnd2dCUzhCQWd3Q0N5QVNJQjBnSUVFTWFoQVZSUTBDSUNBb0Fnd01BUXNnQWlnQ3dBRUxJaEpCQW5SQjRCaHFMUUFDSWd4QklDQUNLQUlNSWdCclRRUkFJQjBvQWdBaEVRd0RDeUFDS0FJVUlRVWdBQ0VEQTBBZ0JRUkFJQUlnQWlnQ0NFRUlkaUlSTmdJSUlBSW9BaEFpRGkwQUFDRUVJQUlnQlVFQmF5SUZOZ0lVSUFJZ0EwRUlheUlBTmdJTUlBSWdEa0VCYWpZQ0VDQUNJQVJCR0hRZ0VYSWlFVFlDQ0VFb0lBTnJJVmtnQUNFRElGa2dERWtOQVF3RUN3c2dBaUFTTmdMQUFRc2dBaUFMTmdJVUlBSWdDallDRUNBQ0lCZzJBZ2dnQWtFQU5nTFlKaUFDSUE4MkFnd0xRUUFNQVFzZ0FrRUFOZ0xZSmlBQ0lBQWdER28yQWd3Z0FpQVNRUUowUWVBWWFpOEJBQ0FNUVFKMFFkQVphaWdDQUNBUklBQjJjV28yQXN3QkFuOENRQUpBQWtBZ0lDZ0NDQ0lBRGdJQUFnRUxJQUlvQXV3QkRBSUxJQUJCQW1zTUFRc2dBaWdDOEFGQkFXb0xJUUFnQWlBQ0tBTHdBVFlDN0FFZ0FpQUFJQnhCQUNBQUlCeFBHMnNpQURZQzhBRWdBaUFDS0FLRUFpQUFRUUowYWlJQU5nSjRJQUlnQUNBQ0tBSzRBV290QUFBNkFJd0NRUUVMSVZvZ0lFRVFhaVFBSUZvTkFFRUNJUU1NRFFzZ0FpZ0NuQUVnQWkwQWpBSkJBblJxS0FJQUlSZ2dBaWdDRkNFUElBSW9BaEFoQ3lBQ0tBSUlJaDBoQXlBQ0tBSU1JZzRoQlNBQ0FuOENRQ0FPUVJKclFRNU5CRUFnQ3lFS0lBNGhCQ0FQSVFBRFFDQUFSUTBDSUFJZ0EwRUlkaUlSTmdJSUlBb3RBQUFoQXlBQ0lBQkJBV3NpQURZQ0ZDQUNJQVJCQ0dzaUJUWUNEQ0FDSUFwQkFXb2lDallDRUNBQ0lBTkJHSFFnRVhJaUF6WUNDQ0FFUVJwcklWc2dCU0VFSUZ0QkQwa05BQXNMSUFJZ0dDQURJQVYySWdSQi93RnhJZ0JCQW5ScUlnTXRBQUFpQ2tFSlR3Ui9JQVZCQ0dvaEJTQURJQmdnQUVFQ2RHb3ZBUUpCQW5ScUlBcEJBblJCc0JscUtBSUFJQVJCQ0haeFFmOEFjVUVDZEdvaUF5MEFBQVVnQ2d0Qi93RnhJQVZxTmdJTUlBTXZBUUlNQVFzZ0dDQWxJQ2RCREdvUUZVVU5CU0FuS0FJTUN5SUVOZ0tjQWlBQ1FRQTJBcmdCSUFSQkQwMEVRQUovSUFSRkJFQWdBaUFDS0FKSVFRRnJJZ0EyQWtnZ0FpQUFRUU54UVFKMGFpZ0NUQ0VGSUFKQkFUWUN1QUVnQWlBRk5nS2NBa0VCREFFTFFZREsvbElnQkVFQmRDSUFka0VEY1NFRElBSWdBaWdDU0VHYi9yL1ZlaUFBZG1wQkEzRkJBblJxS0FKTUlRQWdBaUFFUVFGeEJIOGdBQ0FEYWdWQi8vLy8vd2NnQUNBRGF5SUFJQUJCQUV3YkN5SUZOZ0tjQWtFQUN5RUFJQUlnQWlnQ3pBRkJBV3MyQXN3QkRBRUxJQUlnQkNBQ0tBTDRBU0ljYXlJN1FRQk9CSDhnT3lBQ0tBTDBBU0lNZGlJU1FRRjJJaUJCQVdvaElpQUNLQUw4QVNGZEFrQWdJRUVnSUFJb0Fnd2lBR3RKQkVBZ0pTZ0NBQ0VLREFFTElBSW9BaFFoQlNBQUlRTURRQ0FGUlEwR0lBSWdBaWdDQ0VFSWRpSVJOZ0lJSUFJb0FoQWlDaTBBQUNFRUlBSWdCVUVCYXlJRk5nSVVJQUlnQTBFSWF5SUFOZ0lNSUFJZ0NrRUJhallDRUNBQ0lBUkJHSFFnRVhJaUNqWUNDRUVvSUFOcklWd2dBQ0VESUZ3Z0lFME5BQXNMSUFJZ0FDQWlhallDRENCZElEdHhJQnhxSUNKQkFuUkIwQmxxS0FJQUlBb2dBSFp4SUJKQkFYRkJBbklnSW5ScVFRUnJJQXgwYWdVZ0JBdEJEMnNpQlRZQ25BSWdBaUFDS0FMTUFVRUJhellDekFGQkFDRUFDeUFDS0FJOElnTWdBaWdDT0NJRVJ3UkFJQUlnQmlBRUlBUWdCa29iSWdNMkFqd0xJQUlvQXBnQ0lRY0NRQ0FESUFWSUJFQWdCVUg4Ly8vL0Iwb0VRRUZ3SVFNTUVBc2dCMEVFYTBFVVN3UkFRWFFoQXd3UUN5QUNLQUwwSmlJRUlBZEJBblJxS0FJZ0lRb2dCQ0FIYWkwQUFDRVBJQUlnQWlnQ1NDQUFhallDU0NBRUtBS2tBU0lFUlFSQVFXMGhBd3dRQ3lBRklBTkJmM05xSWdBZ0QzVWlDeUFDS0FMNEppSUZLQUlNVGdSQVFYVWhBd3dRQ3lBRUlBOUJBblJCMEJscUtBSUFJQUJ4SUFkc0lBcHFhaUVESUFJb0FtUWdCbW9oQUFKL0lBVXVBUlFnQzBZRVFDQUFJQU1nQnhBVEdpQUhEQUVMSUFBZ0F5QUhJQVVnQ3hCRUN5RUFJQUlnQWlnQ3ZBRWdBR3MyQXJ3QklBQWdCbW9pQmlBQ0tBSkFTQVJBSUFZaEJRd0NDeUFDUVE4MkFnQkJBU0VEREEwTElBSW9BbVFoQkNBQ0tBSkVJUU1nQWlBQ0tBSklJZ0JCQTNGQkFuUnFJQVUyQWt3Z0FpQUFRUUZxTmdKSUlBSWdBaWdDdkFFZ0IyczJBcndCSUFRZ0F5QUdJQVZyY1NJQWFpSUtLUUFBSVdnZ0JDQUdhaUlFSUFvcEFBZzNBQWdnQkNCb053QUFJQVlnQUNBSGFpSURTQ0FBSUFZZ0Iyb2lCVWh4RFFZZ0JTQUNLQUpBSWdCT0RRWWdBQ0FEVEEwR0lBZEJFVWdOQUNBS1FSQnFJUU1nQkVFUWFpRUFJQWRCSVU4RVFDQUFJQU1nQjBFUWF4QVRHZ3dCQ3lBREtRQUFJV2dnQUNBREtRQUlOd0FJSUFBZ2FEY0FBQXNnQWlnQ3ZBRkJBRW9FUUNBRklRWU1CUXNnQWtFT05nSUFRUUVoQXlBRklRWU1Dd3NnQWlnQ1FDQUdheUVEQWtBQ1FBTkFJQWRCQVdzaEFDQUhRUUJNRFFFZ0FpZ0NaQ0lFSUFacUlBUWdBaWdDUkNBR0lBSW9BcHdDYTNGcUxRQUFPZ0FBSUFaQkFXb2hCaUFBSVFjZ0EwRUJheUlERFFBTElBSkJFRFlDQUF3QkN5QUNLQUs4QVVFQVNnUkFJQUFoQnd3RkN5QUNRUTQyQWdBTFFRRWhBeUFBSVFjTUNndEJBaUVEREFrTElBSWdEellDRkNBQ0lBczJBaEFnQWlBZE5nSUlJQUpCZnpZQ25BSWdBaUFPTmdJTUMwRUNJUU1NQnd0QkFDRUZEQWNMUVFNaEJRd0dDeUFDS0FJVUlROGdBaWdDRUNFTElBSW9BbXdoR0NBQ0tBSUlJaEloQXlBQ0tBSU1JZzRoQlNBQ0FuOENRQ0FPUVJKclFRNU5CRUFnQ3lFS0lBNGhCQ0FQSVFBRFFDQUFSUTBDSUFJZ0EwRUlkaUlSTmdJSUlBb3RBQUFoQXlBQ0lBQkJBV3NpQURZQ0ZDQUNJQVJCQ0dzaUJUWUNEQ0FDSUFwQkFXb2lDallDRUNBQ0lBTkJHSFFnRVhJaUF6WUNDQ0FFUVJwcklWNGdCU0VFSUY1QkQwa05BQXNMSUFJZ0dDQURJQVYySWdCQi93RnhRUUowYWlJRExRQUFJZ1JCQ1U4RWZ5QUZRUWhxSVFVZ0F5QURMd0VDUVFKMGFpQUVRUUowUWJBWmFpZ0NBQ0FBUVFoMmNVSC9BSEZCQW5ScUlnTXRBQUFGSUFRTFFmOEJjU0FGYWpZQ0RDQURMd0VDREFFTElCZ2dKU0FuUVF4cUVCVkZEUU1nSnlnQ0RBdEJBM1JCZ0N0cUlnTXRBQU1pQURZQ3VBRWdBaUFETEFBQ05nS2NBaUFDSUFBZ0FpZ0NlR290QUFBNkFJd0NJQU12QVFRaEJ5QURMd0VHSVJnZ0F5MEFBU0VkUVFBaERDQURMUUFBSWh3RVFBSkFJQnhCSUNBQ0tBSU1JZ0JyVFFSQUlDVW9BZ0FoQ2d3QkN5QUNLQUlVSVFVZ0FDRURBMEFnQlVVTkJDQUNJQUlvQWdoQkNIWWlFVFlDQ0NBQ0tBSVFJZ290QUFBaEJDQUNJQVZCQVdzaUJUWUNGQ0FDSUFOQkNHc2lBRFlDRENBQ0lBcEJBV28yQWhBZ0FpQUVRUmgwSUJGeUlnbzJBZ2hCS0NBRGF5RmZJQUFoQXlCZklCeEpEUUFMQ3lBQ0lBQWdIR28yQWd3Z0hFRUNkRUhRR1dvb0FnQWdDaUFBZG5FaERBc2dBaUFkQkg4Q1FDQWRRU0FnQWlnQ0RDSUFhMDBFUUNBbEtBSUFJUW9NQVFzZ0FpZ0NGQ0VGSUFBaEF3TkFJQVZGRFFRZ0FpQUNLQUlJUVFoMkloRTJBZ2dnQWlnQ0VDSUtMUUFBSVFRZ0FpQUZRUUZySWdVMkFoUWdBaUFEUVFocklnQTJBZ3dnQWlBS1FRRnFOZ0lRSUFJZ0JFRVlkQ0FSY2lJS05nSUlRU2dnQTJzaFlDQUFJUU1nWUNBZFNRMEFDd3NnQWlBQUlCMXFOZ0lNSUIxQkFuUkIwQmxxS0FJQUlBb2dBSFp4QlVFQUN5QVlhallDbUFJZ0FpQUNLQUxJQVVFQmF6WUN5QUVnQnlBTWFpSUhEUU5CQUFzaEIwRUJJUVVNQkFzZ0FpQUxOZ0lRSUFJZ0VqWUNDQ0FDSUE4MkFoUWdBaUFPTmdJTUMwRUNJUU1NQVFzZ0FpQUNLQUs4QVNBSGF6WUN2QUZCQWlFRkRBRUxDeUFDSUFjMkFnUWdBaUFHTmdJMEN5QW5RUkJxSkFBZ0F5RUhEQTRMSUFJZ0dpQVVJQmxCQUJBaklnZEJBVWNORFNBQ0xRRGNKa0VJY1FSQUlBSW9BbVFnQWlnQ2FDQUNLQUkwRUJNYUlBSWdBaThCM0NaQjkvOERjVHNCM0NZTElBSW9Ba0JCQVNBQ0tBTGdKblJHQkVBZ0FpQUNLQUk0TmdJOEN3SkFBa0FDUUNBQ0tBSUFRUTlyRGdJQUFRSUxJQUlvQXJ3QlJRME1EQVlMSUFKQkNqWUNBRUVCSVFjTURnc2dBaWdDQkVVRVFDQUNLQUs4QVVVTkN5QUNRUWsyQWdCQkFTRUhEQTRMSUFKQkNEWUNBRUVCSVFjTURRdEJkaUVISUFJb0Fyd0JRUUJJRFF3Z0FpZ0NJQ0FDS0FMd0ppQUNLQUljRVFFQUlBSkJBRFlDOENZZ0FpZ0NJQ0FDS0FMc0ppQUNLQUljRVFFQUlBSkJBRFlDN0NZZ0FpZ0NJQ0FDS0FLRUFpQUNLQUljRVFFQUlBSkJBRFlDaEFJZ0FpZ0NJQ0FDS0FKOElBSW9BaHdSQVFBZ0FrRUFOZ0o4SUFJb0FpQWdBaWdDakFFZ0FpZ0NIQkVCQUNBQ1FRQTJBb3dCSUFJb0FpQWdBaWdDbkFFZ0FpZ0NIQkVCQUNBQ1FRQTJBcHdCSUFJdEFOd21RUUZ4UlFSQUlBSkJBellDQUVFQklRY01EUXNDUUVFQUlBSW9BZ3dpQTJ0QkIzRWlCRVVFUUNBRElRQU1BUXNnQWlBRElBUnFJZ0EyQWd4QmNTRUhJQVJCQW5SQjBCbHFLQUlBSUFJb0FnZ2dBM1p4RFEwTElBSW9BakJGQkVBZ0FrRWdJQUJySWdWQkEzWWlBeUFDS0FJVWFpSUVOZ0lVSUFJZ0FpZ0NFQ0FEYXlJRE5nSVFJQUlnQlVGNGNTSUZRU0JIQkg4Z0RTZ0NBQ0FGZEFWQkFBczJBZ2dnQWlBQUlBVnFOZ0lNSUJZZ0JEWUNHQ0FXSUFNMkFoUUxJQUpCR0RZQ0FBc2dBaWdDWkFSQUlBSWdHaUFVSUJsQkFSQWpJZ2RCQVVjTkRBc2dBa0VCTmdKY1FRRWhCd3dNQ3lBQ1FRRTJBdGdtSUFJZ0N6WUN3QUZCQWlFSERBb0xJQUlnQURZQ0JFRUNJUWNNQ1FzZ0FrRUhOZ0lBUVFFaEJ3d0lDeUFDRUVFRWZ5QUNLQUxNSmlFREFrQURRQUpBQWtBQ1FDQUREZ0lBQVFNTElBSW9Ba0FpQkNBQ0tBSTBJZ1ZySUFJb0FoUkJJQ0FDS0FJTUlnWnJRUU4yYWlJRElBSW9BcndCSWdBZ0FDQURTaHNpQUNBQUlBVnFJQVJLR3lFQUlBSW9BbVFnQldvaEJRSkFJQVpCSVd0QmQwc0VRQ0FBSVFNTUFRc2dBQ0lEUlEwQUEwQWdCU0FDS0FJSUlBWjJPZ0FBSUFJZ0FpZ0NEQ0lFUVFocUlnWTJBZ3dnQTBFQmF5RURJQVZCQVdvaEJTQUVRUmxyUVhkTERRRWdBdzBBQ3dzZ0JTQUNLQUlRSUFNUUV4b2dBaUFDS0FJVUlBTnJOZ0lVSUFJZ0FpZ0NFQ0FEYWpZQ0VDQUNJQUlvQWpRZ0FHb2lCRFlDTkNBQ0lBSW9BcndCSWdNZ0FHczJBcndCSUFSQkFTQUNLQUxnSm5SSURRRWdBa0VCTmdMTUpnc2dBaUFhSUJRZ0dVRUFFQ01pQTBFQlJ3MENJQUlvQWtCQkFTQUNLQUxnSm5SR0JFQWdBaUFDS0FJNE5nSThDMEVBSVFNZ0FrRUFOZ0xNSmd3QkN3dEJBVUVDSUFBZ0EwWWJJUU1MSUFNRlFXWUxJZ2RCQVVjTkJ3d0VDd0pBSUFJb0Fnd2lBRUViYTBFR1R3UkFJQTBvQWdBaEJ3d0JDMEVDSVFjZ0FpZ0NGQ0lHUlEwSElBSWdBaWdDQ0VFSWRpSUZOZ0lJSUFJb0FoQWlCQzBBQUNFRElBSWdCa0VCYXpZQ0ZDQUNJQVJCQVdvMkFoQWdBaUFEUVJoMElBVnlJZ2MyQWdnZ0FFRUlheUVBQ3lBQ0lBQkJCbW8yQWd3Z0FpQUhJQUIyUVQ5eElnQTJBdUFtUVhNaEJ5QUFRUjlyUVd0SkRRWWdBa0VDTmdJQUN5QUNRUUVnQUhSQkVHczJBamdnQWlBQ0tBSWdRYkRnQUNBQ0tBSVlFUUlBSWdBMkFxd0JRV0loQnlBQVJRMEZJQUpCQXpZQ0FDQUNJQUJCb0R0cU5nS3dBUXNnQWtJQU53THNKaUFDUWdFM0F0d0JJQUpDZ0lDQWlJQ0FnSUFCTndMRUFTQUNRUUEyQXJ3QklBSkNBRGNDakFFZ0FrSUFOd0tjQVNBQ1FnQTNBM0FnQWtJQU53S0VBaUFDUWdFM0F1d0JJQUpDQVRjQzVBRWdBa0tCZ0lDQUVEY0MxQUVnQWtLQWdJQ0lFRGNDekFFZ0FrSUFOd040SUFKQkFEWUNnQUVnQWtFQU9nQ01BaUFDUVFRMkFnQUxBbjhnQWlnQ3dDWWhCRUZoSVFjQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBbjhDUUFOQUFrQUNRQUpBQWtBZ0JBNElBUUlBQlFjSkNnd1JDeUFOS0FJRUlRUU1BZ3NDUUNBTktBSUVJZ1JCSUVjRVFDQU5LQUlBSVFvTUFRc2dEU2dDRENJRVJRMFBJQTBnRFNnQ0FFRUlkaUlGTmdJQUlBMG9BZ2dpQXkwQUFDRUFJQTBnQkVFQmF6WUNEQ0FOSUFOQkFXbzJBZ2hCR0NFRUlBMGdBRUVZZENBRmNpSUtOZ0lBQ3lBTklBUkJBV28yQWdRZ0FrRUFOZ0s4QVNBQ0lBSXZBZHdtUWZqL0EzRkJBU0FFZENBS2NTSUFRUUJIY2pzQjNDWWdBRVVFUUVFQ0lRUWdBa0VDTmdMQUpnd0RDeUFDUVFFMkFzQW1Dd0pBSUEwb0FnUWlDa0VnUndSQUlBMG9BZ0FoQlF3QkN5QU5LQUlNSWdWRkRRNGdEU0FOS0FJQVFRaDJJZ1EyQWdBZ0RTZ0NDQ0lETFFBQUlRQWdEU0FGUVFGck5nSU1JQTBnQTBFQmFqWUNDRUVZSVFvZ0RTQUFRUmgwSUFSeUlnVTJBZ0FMSUEwZ0NrRUJhaUlFTmdJRUlBVWdDblpCQVhFRVFDQUNRUUEyQXNBbVFRRU1FQXNnQWtFQ05nTEFKZ3NDUUNBRVFSOXJRUUpQQkVBZ0RTZ0NBQ0VLREFFTElBMG9BZ3dpQmtVTkRTQU5JQTBvQWdCQkNIWWlCVFlDQUNBTktBSUlJZ010QUFBaEFDQU5JQVpCQVdzMkFnd2dEU0FEUVFGcU5nSUlJQTBnQUVFWWRDQUZjaUlLTmdJQUlBUkJDR3NoQkFzZ0RTQUVRUUpxTmdJRUlBSkJBRFlDQkNBQ0lBSXZBZHdtUWIrQWYzRWdDaUFFZGtFRGNTSUFRUVowY2tHQUFuSWlCRHNCM0NZZ0FFRURSZ1JBSUFJZ0JFRUVjanNCM0NaQkJTRUVJQUpCQlRZQ3dDWU1BUXNMSUFKQkF6WUN3Q1pCQUF3QkN5QUNMd0hjSmlFRUlBSW9BZ1FMSWdNZ0JFRUdka0gvQVhGSUJFQWdEU2dDQkNFS0EwQWdBeUVBSUEwQ2Z5QUtRUjFyUVFSUEJFQWdEU2dDQUNFRElBb01BUXNnRFNnQ0RDSUdSUTBLSUEwZ0RTZ0NBRUVJZGlJRk5nSUFJQTBvQWdnaUJDMEFBQ0VESUEwZ0JrRUJhellDRENBTklBUkJBV28yQWdnZ0RTQURRUmgwSUFWeUlnTTJBZ0FnQ2tFSWF3c2lCRUVFYWlJS05nSUVJQU1nQkhaQkQzRWhCZ0pBSUFCQkFXb2lBeUFDTHdIY0ppSUVRUVoyUWY4QmNTSUZSdzBBSUFWQkJVa05BQ0FHRFFCQmZ3d09DeUFDSUFJb0Fyd0JJQVlnQUVFQ2RIUnlOZ0s4QVNBRElBVklEUUFMQ3lBQ1FRUTJBc0FtREFFTElBSXZBZHdtSVFRTElBUkJBWEZGQkVBQ1FDQU5LQUlFSWdSQklFY0VRQ0FOS0FJQUlRTU1BUXNnRFNnQ0RDSUVSUTBKSUEwZ0RTZ0NBRUVJZGlJRk5nSUFJQTBvQWdnaUF5MEFBQ0VBSUEwZ0JFRUJhellDRENBTklBTkJBV28yQWdoQkdDRUVJQTBnQUVFWWRDQUZjaUlETmdJQUN5QU5JQVJCQVdvMkFnUWdBaUFDTHdIY0prSDkvd054SUFNZ0JIWkJBWEZCQVhSeU93SGNKZ3NnQWtFQU5nTEFKaUFDSUFJb0Fyd0JRUUZxTmdLOEFVRUJEQWtMQWtBZ0RTZ0NCQ0lEUVNCSEJFQWdEU2dDQUNFS0RBRUxJQTBvQWd3aUJVVU5CeUFOSUEwb0FnQkJDSFlpQkRZQ0FDQU5LQUlJSWdNdEFBQWhBQ0FOSUFWQkFXczJBZ3dnRFNBRFFRRnFOZ0lJUVJnaEF5QU5JQUJCR0hRZ0JISWlDallDQUFzZ0RTQURRUUZxSWdRMkFnUkJmaUVISUFvZ0EzWkJBWEVOQnlBQ1FRWTJBc0FtREFFTElBMG9BZ1FoQkF0QkFpRUhBa0FnQkVFZmEwRUNUd1JBSUEwb0FnQWhBd3dCQ3lBTktBSU1JZ1pGRFFZZ0RTQU5LQUlBUVFoMklnVTJBZ0FnRFNnQ0NDSURMUUFBSVFBZ0RTQUdRUUZyTmdJTUlBMGdBMEVCYWpZQ0NDQU5JQUJCR0hRZ0JYSWlBellDQUNBRVFRaHJJUVFMSUEwZ0JFRUNhallDQkNBRElBUjJRUU54SWdCRkJFQWdBa0VBTmdMQUprRUJEQWNMSUFKQkJ6WUN3Q1lnQWlBQ0x3SGNKa0cvZ0g5eElBQkJCblJ5SWdNN0Fkd21EQUVMSUFJdkFkd21JUU1MQWtBZ0FpZ0NCQ0lFSUFOQkJuWkIvd0Z4VGdSQUlBSW9BcndCSVFvTUFRc2dEU2dDQkNFREEwQWdCQ0VBSUEwQ2Z5QURRUmxyUVFoUEJFQWdEU2dDQUNFRklBTU1BUXNnRFNnQ0RDSUhSUTBFSUEwZ0RTZ0NBRUVJZGlJR05nSUFJQTBvQWdnaUJTMEFBQ0VFSUEwZ0IwRUJhellDRENBTklBVkJBV28yQWdnZ0RTQUVRUmgwSUFaeUlnVTJBZ0FnQTBFSWF3c2lCRUVJYWlJRE5nSUVJQVVnQkhaQi93RnhJUVlDUUNBQVFRRnFJZ1FnQWk4QjNDWkJCblpCL3dGeElnVkhEUUFnQlVFQ1NRMEFJQVlOQUVGOURBY0xJQUlnQWlnQ3ZBRWdCaUFBUVFOMGRISWlDallDdkFFZ0JDQUZTQTBBQ3dzZ0FrRUFOZ0xBSmlBQ0lBcEJBV28yQXJ3QlFRRU1CQXNnQWlBQU5nSUVEQUVMSUFJZ0FEWUNCQXRCQWlFSEN5QUhDeUlIUVFGSERRTUNRQ0FDTHdIY0ppSUFRUVp4UlEwQVFRQWdBaWdDRENJRWEwRUhjU0lEQkVBZ0FpQURJQVJxTmdJTVFYSWhCeUFEUVFKMFFkQVphaWdDQUNBQ0tBSUlJQVIyY1EwRkN5QUFRUVJ4UlEwQUlBSkJERFlDQUVFQklRY01CQXNnQWlnQ3ZBRU5BUXNnQWtFT05nSUFRUUVoQnd3Q0N3SkFJQUlvQWtBaUJVRUJJQUlvQXVBbWRDSURSZzBBSUFJdkFkd21JZ1JCQkhFTkFDQUNLQUprQkg4Z0FpZ0NOQVZCQUFzaEFBSkFJQVJCRUhGRkJFQWdBeUVBREFFTElBVkJnQWdnQlJzaUJDQUNLQUs4QVNBQWFpSUFJQUFnQkVnYklRUURRQ0FESWdCQkFYVWlBeUFFVGcwQUN3c2dBaUFBTmdMa0pnc2dBaTBBM0NaQkFuRUVRQ0FDUVFzMkFnQkJBU0VIREFJTElBSkNFVGNEQUVFQklRY01BUXRCQWlFSElBMFFLVVVOQUNBQ0lBSXZBZHdtSWdWQjMvOERjVHNCM0NZZ0FpQUNLQUlNSWdwQkFXb2lBRFlDREFKQUlBSW9BZ2dpQmlBS2RrRUJjVVVFUUVFUUlRY01BUXNnQWlBS1FRUnFJZ1EyQWd3Z0JpQUFka0VIY1NJQUJFQWdBRUVSYWlFSERBRUxJQUlnQ2tFSGFpSUROZ0lNUVJFaEJ3SkFBa0FnQmlBRWRrRUhjU0lBRGdJQ0FBRUxRWE1oQnlBRlFTQnhSUTBDSUFJZ0NrRUlhallDRENBR0lBTjJRUUZ4RFFKQkFTRUhJQUpCQVRZQ0FDQUNJQVZCSUhJN0Fkd21EQUlMSUFCQkNISWhCd3NnQWtFQ05nSUFJQUlnQnpZQzRDWkJBU0VIREFBTEFBc2dMRUVRYWlRQUlBZ2dGaWdDSERZQ3BBRWdBaWdDSUNBQ0tBTHdKaUFDS0FJY0VRRUFJQUpCQURZQzhDWWdBaWdDSUNBQ0tBTHNKaUFDS0FJY0VRRUFJQUpCQURZQzdDWWdBaWdDSUNBQ0tBS0VBaUFDS0FJY0VRRUFJQUpCQURZQ2hBSWdBaWdDSUNBQ0tBSjhJQUlvQWh3UkFRQWdBa0VBTmdKOElBSW9BaUFnQWlnQ2pBRWdBaWdDSEJFQkFDQUNRUUEyQW93QklBSW9BaUFnQWlnQ25BRWdBaWdDSEJFQkFDQUNRUUEyQXB3QklBSW9BaUFnQWlnQ1pDQUNLQUljRVFFQUlBSkJBRFlDWkNBQ0tBSWdJQUlvQXF3QklBSW9BaHdSQVFBZ0FrRUFOZ0tzQVNBV1FjQW5haVFBQWtBZ0IwRUJSdzBBSUFnb0FxUUJJQ3BIRFFBZ0NDZ0NXQ0FJS0FKVVJnUkFRUUVoQ1F3QkMwRUFJUmNEUUNBSU5RSTBJV29nQ0NnQ0RDRXdJQlVnRlNnQ0FDZ0NFQkVBQUNFSElBZ29BbFFoQmlBSVFRQTJBblFnQ0VJQU53SnNBa0FDUUFKQUFrQUNRQ0FJS0FJY0JFQkJBQ0VCSUFnb0FrUWdGMEVZYkdvaUFDZ0NEQ0lKSUFBb0FoQWlBa1lOQkFOQUlBZ29BamdnQ1M4QkFFRUZkR29oRXdKQUlBZ29BblFpQUNBQlN3UkFJQUVnRXpZQ0FDQUlJQUZCQkdvaUFUWUNjQXdCQ3lBQklBZ29BbXdpQ210QkFuVWlCVUVCYWlJRVFZQ0FnSUFFVHcwT1FmLy8vLzhESUFBZ0Ntc2lBMEVCZFNJQUlBUWdBQ0FFU3hzZ0EwSDgvLy8vQjA4YkloUUVmeUFVUVlDQWdJQUVUdzBNSUJSQkFuUVFFZ1ZCQUFzaUJDQUZRUUowYWlJRElCTTJBZ0FnQTBFRWFpRUFJQUVnQ2tjRVFBTkFJQU5CQkdzaUF5QUJRUVJySWdFb0FnQTJBZ0FnQVNBS1J3MEFDeUFJS0FKc0lRRUxJQWdnQkNBVVFRSjBhallDZENBSUlBQTJBbkFnQ0NBRE5nSnNJQUVFUUNBQkVCRUxJQUFoQVFzZ0NVRUNhaUlKSUFKSERRQUxJQWdvQW13aEFBd0JDMEVBSVFGQkFDRUFRUUFoQkNBSUtBSTRJZ2tnQ0NnQ1BDSUNSZzBEQTBBQ2Z5QUJJQVJKQkVBZ0FTQUpOZ0lBSUFGQkJHb01BUXNnQVNBQWEwRUNkU0lGUVFGcUloTkJnSUNBZ0FSUERRTkIvLy8vL3dNZ0JDQUFheUlFUVFGMUlnTWdFeUFESUJOTEd5QUVRZnovLy84SFR4c2lFd1IvSUJOQmdJQ0FnQVJQRFFzZ0UwRUNkQkFTQlVFQUN5SUVJQVZCQW5ScUlnVWdDVFlDQUNBRklRTWdFMEVDZENBRWFpRUVJQUFnQVVjRVFBTkFJQU5CQkdzaUF5QUJRUVJySWdFb0FnQTJBZ0FnQUNBQlJ3MEFDeUFBSVFFTElBRUVRQ0FCRUJFTElBTWhBQ0FGUVFScUN5RUJJQWxCSUdvaUNTQUNSdzBBQ3lBSUlBRTJBbkFnQ0NBQU5nSnNJQWdnQkRZQ2RBc2dBQ0FCUmcwQ0lBWWdGMEVGZEdvaElTQUFJUU1DUUFOQUlBTW9BZ0FpQkNnQ0FFSG04ckc3QmtZTkFTQURRUVJxSWdNZ0FVY05BQXRCQUNFRUN5QUFJUU1DUUFOQUlBTW9BZ0FpQlNnQ0FFSGh4cjNqQmtjRVFDQUJJQU5CQkdvaUEwY05BUXdDQ3d0QkFDRUpJQVJGRFFRZ0JTZ0NCQ0FFS0FJRWMwR0FBbkVOQkF3Q0N5QUVSUTBCUVFBaENRd0RDeUFJSUFFMkFuQWdDQ0FBTmdKc0lBZ2dCRFlDZEF3SkN5QXdRUWhxSVRrZ01FRWlhaUU2SUNGQkdHb2hEU0FoUVFocUlUUWdDQ2dDUkNBWFFSaHNha0VJYWlBSVFkQUFhaUFJS0FJY0d5Z0NBQ0ZCUVFBaEtVRUFJUmdEUUNBQUlDbEJBblJxS0FJQUloOG9BZ2doS0NBZktBSUFJU1FnTXlFQ0lBZ29BbVFpQlNFRFFRQWhDUUpBSUFWRkRRQURRQUpBSUNRZ0F5Z0NFQ0lKU3dSQUlBTkJCR29oQ1F3QkN5QUpJQ1JMQkVBZ0F5SUpJUUlNQVFzZ0EwRUVhaUFESUNnZ0F5Z0NGRXNpQkJzaENTQUNJQU1nQkJzaEFnc2dDU2dDQUNJRERRQUxRUUFoQ1NBQ0lETkdEUUFnSkNBQ0tBSVFJZ05KRFFBZ0F5QWtUd1JBSUNnZ0FpZ0NGQ0lEVHlFSklCY05BU0FESUNoTERRRkJBQ0VKREFRTFFRRWhDU0FYRFFCQkFDRUpEQU1MSUdvZ0tLMGlhU0FmS0FJTUlnS3RmRlFFUUVFQUlRa01Bd3NnSkVIaHlxSERCa1lFUUNBQ1FTUkpCRUJCQUNFSkRBUUxJQ0VnS0NBNmFpOEFBQ0lEUVFoMElBTkJDSFp5T3dFRUN3SkFBa0FDUUFKQUFrQUNRQ0FKUlFSQUlCOHRBQVZCQVhGRkJFQWdKRUhrd3BYREJrWUVRQ0FDUVF4SkJFQkJBQ0VKREF3TElDZ2dPV3BCQURZQUFDQWZLQUlNSVFJTElCOGdCellDRkNBd0lCOG9BZ2hxSUFJUUZ5RUFJQlVnTUNBZktBSUlhaUFmS0FJTUlCVW9BZ0FvQWdnUkF3QU5Ca0VBSVFrTUNnc2dKRUhoeHIzakJrWUVRQ0FZSVFBTUJnc2dKRUg0NkxYREJrWU5BU0FrUWVieXNic0dSd1JBUVFBaENRd0tDeUFmSUFjMkFoUkJBQ0VKUVFBaE1RSkFJQUFnQVVZTkFBTkFJQUFvQWdBaU1TZ0NBRUhoeHIzakJrWU5BU0FBUVFScUlnQWdBVWNOQUF0QkFDRXhDeUFmS0FJUUlRUWdGU0FWS0FJQUtBSVFFUUFBSVRzZ0JFRUNTUTBKSUNnZ01Hb2lDeThBQUJvZ0JFRUVTUTBKSUFzdkFBSWlBRUVJZENBQVFRaDJja0gvL3dOeElRRWdCRUVHU1EwSklDRWdDeThBQkNJQVFRaDBJQUJCQ0haeVFmLy9BM0VpRWpzQkFDQUVRUWhKRFFrZ0lTQUxMd0FHSWdCQkNIUWdBRUVJZG5KQi8vOERjU0lBT3dFQ0lERW9BaGdnRWtFQmFpSThRUUpCQVNBQUczUkhEUWtnSHlnQ0VDSUtRU1JKRFFrZ0JFRU1TUTBKSUFzb0FBZ2lBRUVZZENBQVFZRCtBM0ZCQ0hSeUlBQkJDSFpCZ1A0RGNTQUFRUmgyY25JaUp5QUtRU1JyU3cwSklBUkJFRWtOQ1NBTEtBQU1JZ0JCR0hRZ0FFR0EvZ054UVFoMGNpQUFRUWgyUVlEK0EzRWdBRUVZZG5KeUloUWdDaUFuUVNScUloTnJTdzBKSUFSQkZFa05DU0FMS0FBUUlnQkJHSFFnQUVHQS9nTnhRUWgwY2lBQVFRaDJRWUQrQTNFZ0FFRVlkbkp5SWpVZ0NpQVRJQlJxSWdkclN3MEpJQVJCR0VrTkNTQUxLQUFVSWdCQkdIUWdBRUdBL2dOeFFRaDBjaUFBUVFoMlFZRCtBM0VnQUVFWWRuSnlJZ1VnQ2lBSElEVnFJZ05yU3cwSklBUkJIRWtOQ1NBTEtBQVlJZ0JCR0hRZ0FFR0EvZ054UVFoMGNpQUFRUWgyUVlEK0EzRWdBRUVZZG5KeUlqWWdDaUFESUFWcUlnWnJTdzBKSUFSQklFa05DU0FMS0FBY0lnQkJHSFFnQUVHQS9nTnhRUWgwY2lBQVFRaDJRWUQrQTNFZ0FFRVlkbkp5SWpjZ0NpQUdJRFpxSWdKclN3MEpJQVJCSkVrTkNTQUxLQUFnSWdCQkdIUWdBRUdBL2dOeFFRaDBjaUFBUVFoMlFZRCtBM0VnQUVFWWRuSnlJamdnQ2lBQ0lEZHFJZ1JyU3cwSlFRQWhBQ0FJUVFBMkFxd0JJQWdnRkRZQ3FBRWdDQ0FMSUJOcU5nS2tBU0FJUVFBMkFxQUJJQWdnQlRZQ25BRWdDQ0FESUF0cU5nS1lBVUVBSVNVQ1FDQUJRUUZ4SWlBRVFDQUtJQVFnT0dvaUFXc2dFa0VIYWtFRGRra05BU0FCSUF0cUlTVUxJRHhCQW5RaUFSQVNJQUVRRkNFdUlBaEJBRFlDbEFFZ0NFSUFOd0tNQVNBM0lCSkJIMnBCQTNaQi9QOEFjU0lQU1FSQVFRQWhQUXdHQzBHQUtCQVNJUVVDUUNBaEtBSU1JRFFvQWdBaUFHdEJBWFVpQVNBU1NRUkFJRFFnRWlBQmF4QkhJQ0V2QVFBaEF3d0JDeUFCSUJJaUEwME5BQ0FoSUFBZ0EwRUJkR28yQWd3TFFRQWhQZ0pBSUFOQi8vOERjVVVFUUVFQUlRQkJBQ0VPREFFTElBdEJKR29oUHlBSElBdHFJVUFnQmlBTGFpRXFJQUlnQzJvaFFpQUVJQXRxSVN3Z04wRUlheUV0UVFBaFBVR0FLQ0ViUVFBaEFFRUFJUkZCQUNFeVFRQWhEa0VBSVJSQkFDRUJRUUFoRTBFQUlRc0RRQ0FCUVFKcUloa2dKMHNOQmtHQUFTQXlRUWR4ZGlJdklFSWdNa0VEZGlJZGFpMEFBSEVoRmdKQUFrQUNRQ0FCSUQ5cUx3QUFJZ0ZCQ0hRZ0FVRUlkbkpCLy84RGNTSXJCRUFnSzBILy93TkdCRUJCQUNFQ0lBaEJBRFlDaUFFZ0N5RURJQlpGRFFzRFFDQURRUUpxSWdrZ05rc05EQ0FKSURZQ2YwRUdRUVFnQXlBcWFpOEFBQ0lCUVFoMElBRkJDSFp5UWYvL0EzRWlCRUVCY1JzaUFVRUNhaUFFUVFoeERRQWFJQUZCQkdvZ0JFSEFBSEVOQUJvZ0FTQUVRUVIyUVFoeGNnc2lBV3RMRFF3Z0FTQUphaUlESURaTERRd2dCRUVJZGlBQ2NrRUJjU0VDSUFSQklIRU5BQXNnQWdSL0lBaEJtQUZxSUFoQmlBRnFFQmxGRFF3Z0NDZ0NpQUVGUVFBTElBTWdDMnNpQjBFTWFpSUdhaUlKSUJ0TEJFQWdDUkFTSVdFZ0JRUkFJQVVRRVFzZ0NTRWJJR0VoQlFzZ0JVSC8vd003QUFBZ0R5QXRTdzBMSUE5QkNHb2lDU0EzU3cwTElBVWdEeUJDYWlrQUFEY0FBaUFIUVlDQWdJQUVTdzBMSUFzZ05pQUhhMHNOQ3lBRlFRcHFJQXNnS21vZ0J4QVRHaUFIUVFwcUlRUWdBZ1JBSUFRZ0JXb2dDQ2dDaUFFaUFVRUlkam9BQUNBRklBZHFJQUU2QUFzZ0NDZ0NpQUVpQkVHQWdJQ0FCRXNORENBRUlCUnFJZ0VnT0VzTkRDQVVJRGdnQkd0TERRd2dCU0FHYWlBVUlDeHFJQVFRRXhvZ0FTRVVJQWdvQW9nQklBWnFJUVFMUWYvL0F5RXJJQU1oQ3lBSklROE1CQXNnQ0NBSUtBS01BU0lCTmdLUUFVRUFJUVpCQUNFQ0EwQWdDRUdrQVdvZ0NFR0lBV29RR1VVTkN3SkFJQWdvQXBRQklBRkdCRUFnQVNBSUtBS01BU0lRYXlJSFFRSjFJZ1JCQVdvaUNVR0FnSUNBQkU4TkdrSC8vLy8vQXlBSFFRRjFJZ01nQ1NBRElBbExHeUFIUWZ6Ly8vOEhUeHNpQ2dSL0lBcEJnSUNBZ0FSUERSZ2dDa0VDZEJBU0JVRUFDeUlKSUFSQkFuUnFJZ01nQ0NnQ2lBRTJBZ0FnQTBFRWFpRUhJQUVnRUVjRVFBTkFJQU5CQkdzaUF5QUJRUVJySWdFb0FnQTJBZ0FnQVNBUVJ3MEFDd3NnQ0NBSklBcEJBblJxTmdLVUFTQUlJQWMyQXBBQklBZ2dBellDakFFZ0VBUkFJQkFRRVFzZ0NDZ0NpQUVpQVNBQ2FpSUNJQUZQRFFFTURRc2dBU0FJS0FLSUFUWUNBQ0FJSUFGQkJHb2lCellDa0FFZ0NDZ0NpQUVpQVNBQ2FpSUNJQUZKRFF3TElBY2hBU0FHUVFGcUlnWWdLMGNOQUFzZ0FpQTFJQk5yU3cwS0lBZ29BcHdCSUFnb0FxQUJJZ2xySVNJZ0NDZ0NtQUVoQXlBQ0lCRkxCRUJCZnlBQ3JVSU1maUpvcHlCb1FpQ0lweHNRRWlGaUlBNEVRQ0FPRUJFTElBSWhFU0JpSVE0TElBSWdJa3NOQ2dKQUlBSUVRQ0FESUFscUlTWWdFeUJBYWlFY1FRQWhCQ0FPSVFOQkFDRUJRUUFoQjBFQUlRa0RRQ0FFSVFvZ0NnSi9RUUVnQVNBY2FpMEFBQ0lNUWY4QWNTSWVRZFFBU1EwQUdrRUNJQjVCK0FCSkRRQWFRUU5CQkNBZVFmd0FTUnNMSWdacUlnUWdJa3NORFNBRUlBWkpEUTBDUUNBZVFRbE5CRUJCQUNFR0lBb2dKbW90QUFBZ0hrRUhkRUdBRG5GeUlncEJBQ0FLYXlBZVFRRnhHeUVRREFFTElCNUJFMDBFUUVFQUlSQWdDaUFtYWkwQUFDQWVRUWQwUVlBR2FrR0FEbkZ5SWdaQkFDQUdheUFlUVFGeEd5RUdEQUVMSUI1QjB3Qk5CRUFnQ2lBbWFpMEFBQ0lhUVE5eElCNUJGR3NpQ2tFQ2RFRXdjWElpQmtFQmFpQUdRWDl6SUI1QkFuRWJJUkFnQ2tFd2NTQWFRUVIyY2lJR1FRRnFJQVpCZjNNZ0hrRUJjUnNoQmd3QkN5QWVRZmNBVFFSQUlBb2dKbW9pR2kwQUFDQWVRZFFBYXlJUVFmOEJjVUVNYmlJS1FRaDBjaUlHUVFGcUlBWkJmM01nSGtFQmNSc2hCaUFhTFFBQklCQWdDa0VDZEdwQkJuUkJnQVp4Y2lJS1FRRnFJQXBCZjNNZ0hrRUNjUnNoRUF3QkN5QWVRZnNBVFFSQUlBb2dKbW9pRUMwQUFFRUVkQ0FRTFFBQklncEJCSFp5SWdaQkFDQUdheUFlUVFGeEd5RUdJQkF0QUFJZ0NrRUlkRUdBSG5GeUlncEJBQ0FLYXlBZVFRSnhHeUVRREFFTElBb2dKbW9pQ2kwQUFFRUlkQ0FLTFFBQmNpSUdRUUFnQm1zZ0hrRUJjUnNoQmlBS0xRQURJQW90QUFKQkNIUnlJZ3BCQUNBS2F5QWVRUUp4R3lFUUN3SkFJQWxCQUVvRVFDQUpRZi8vLy84SGN5QUdUZzBCREE4TElBbEZEUUJCZ0lDQWdIZ2dDV3NnQmtvTkRnc0NRQ0FIUVFCS0JFQWdCMEgvLy8vL0IzTWdFRTROQVF3UEN5QUhSUTBBUVlDQWdJQjRJQWRySUJCS0RRNExJQU1nRE1CQkFFNDZBQWdnQXlBR0lBbHFJZ2syQWdBZ0F5QUhJQkJxSWdjMkFnUWdBMEVNYWlFRElBRkJBV29pQVNBQ1J3MEFDeUFDUVlDQWdJQUVTdzBNSUFJZ0Uyb2lDaUExU3cwTUlCTWdOU0FDYTBzTkRDQUVRWUNBZ0lBRVRRMEJEQXdMUVFBaEJDQVRJZ29nTlVzTkN3c2dDQ2dDb0FFaUNTQUVhaUlESUFnb0Fwd0JJZ0ZMRFFvZ0NTQUJJQVJyU3cwS0lBZ2dBellDb0FFZ0NFR1lBV29nQ0VHRUFXb1FHVVVOQ2lBQ1FmLy8vejlMRFFvZ0NDZ0NoQUVpQVVILy8vLy9BMHNOQ2lBclFRRjBRUXhxSWd3Z0FrRUZiR29nQVdvaUF5QWJTd1JBSUFNUUVpRmpJQVVFUUNBRkVCRUxJQU1oR3lCaklRVUxJQVVnSzBFSWRDQXJRUWgyY2pzQUFBSkFJQllFUUNBUElDMUxEUXdnRDBFSWFpSUJJRGRMRFF3Z0JTQVBJRUpxS1FBQU53QUNJQUVoRHd3QkN3SkFJQUpGQkVCQkFDRUVRUUFoQVVFQUlRZEJBQ0VHREFFTElBNG9BZ1FoQnlBT0tBSUFJUVlnQWtFQlJnUkFJQVloQkNBSElRRU1BUXRCQVNFRElBSkJBV3NpQVVFQmNTRmtBa0FnQWtFQ1JnUkFJQWNoQVNBR0lRUU1BUXNnQVVGK2NTRVRRUUFoRUNBSElRRWdCaUVFQTBBZ0RpQURRUXhzYWlJV0tBSVFJaHdnRmlnQ0JDSUpJQUVnQVNBSlNCc2lBU0FCSUJ4SUd5RUJJQWNnQ1NBSElBbElHeUlKSUJ3Z0NTQWNTQnNoQnlBV0tBSU1JaUlnRmlnQ0FDSWNJQVFnQkNBY1NCc2lDU0FKSUNKSUd5RUVJQVlnSENBR0lCeElHeUlKSUNJZ0NTQWlTQnNoQmlBRFFRSnFJUU1nRUVFQ2FpSVFJQk5IRFFBTEN5QmtSUTBBSUE0Z0EwRU1iR29pQXlnQ0JDSUpJQUVnQVNBSlNCc2hBU0FISUFrZ0J5QUpTQnNoQnlBREtBSUFJZ01nQkNBRElBUktHeUVFSUFZZ0F5QURJQVpLR3lFR0N5QUZJQUU2QUFrZ0JTQUVPZ0FISUFVZ0J6b0FCU0FGSUFZNkFBTWdCU0FCUVFoMk9nQUlJQVVnQkVFSWRqb0FCaUFGSUFkQkNIWTZBQVFnQlNBR1FRaDJPZ0FDQzBFS0lRRkJmeUVEUVFBaENRTkFJQWdvQW93QklBbEJBblJxS0FJQUlBTnFJZ05CLy84RFNnMExJQUVnQldvaUJDQURRUWgyT2dBQUlBVWdBVUVCY21vZ0F6b0FBQ0FCUVFKcUlRRWdDVUVCYWlJSklDdEhEUUFMSUFFZ0JXb2dDQ2dDaEFFaUEwRUlkam9BQUNBRklBRkJBWEpxSUFNNkFBQWdDQ2dDaEFFaUFVR0FnSUNBQkVzTkNpQUJJQlJxSWhvZ09Fc05DaUFVSURnZ0FXdExEUW9nQkVFRWFpQVVJQ3hxSUFFUUV4cEJBQ0VHUVFBaEZDQWdCRUFnTHlBZElDVnFMUUFBY1VFQVJ5RVVDeUFJS0FLRUFTQU1haUVFUVg4aEV5QUNSUTBCSUFRaEVFRUFJUVJCQUNFRFFRQWhKa0VBSVJZQ1FBTkFJQVVnRUdvaUwwRUJheUVkUVFBaEJ5QURJUWtEUUNBT0lBbEJER3hxSWlJdEFBZ2lBU0FCUWNBQWNpQUpHeUFCSUJRYklRRWdJaWdDQkNFY0FrQWdCaUFpS0FJQUlneEdCRUFnQVVFUWNpRUJEQUVMSUF3Z0Jtc2lCa0gvQVdwQi9nTk5CRUFnRmtFQmFpRVdRUkpCQWlBR1FRQktHeUFCY2lFQkRBRUxJQlpCQW1vaEZnc0NRQ0FFSUJ4R0JFQWdBVUVnY2lFQkRBRUxJQndnQkdzaUJFSC9BV3BCL2dOTkJFQWdKa0VCYWlFbUlBRkJKRUVFSUFSQkFFb2JjaUVCREFFTElDWkJBbW9oSmdzZ0FTQVRSaUFIUWY4QlIzRkZCRUFnQndSQUlCQWdHMDhORHlBdklBYzZBQUFnRUVFQmFpRVFDeUFRSUJ0UERRNGdCU0FRYWlBQk9nQUFJQkJCQVdvaEVDQWlLQUlFSVFRZ0lpZ0NBQ0VHSUFFaEV5QUpRUUZxSWdNZ0FrY05BZ3dEQ3lBZElCMHRBQUJCQ0hJNkFBQWdCMEVCYWlFSElDSW9BZ1FoQkNBaUtBSUFJUVlnQ1VFQmFpSUpJQUpIRFFBTEN5QVFJQnRQRFFzZ0x5QUNJQU5yT2dBQUlCQkJBV29oRUFzZ0ZpQW1haUlCSUNaSkRRb2dBU0FRYWlJQklCQkpEUW9nQVNBYlN3MEtJQkFnRm1vaEJFRUFJUUZCQUNFRFFRQWhDUU5BSUFraEJnSkFJQU1pQ1NBT0lBRkJER3hxSWdjb0FnQWlBMFlOQUNBRElBbHJJaE5CL3dGcVFmNERUUVJBSUFVZ0VHb2dFeUFUUVI5MUlnbHpJQWxyT2dBQUlCQkJBV29oRUF3QkN5QUZJQkJxSUJOQkNIUWdFMEdBL2dOeFFRaDJjanNBQUNBUVFRSnFJUkFMQWtBZ0J5Z0NCQ0lKSUFaR0RRQWdDU0FHYXlJSFFmOEJha0grQTAwRVFDQUVJQVZxSUFjZ0IwRWZkU0lHY3lBR2F6b0FBQ0FFUVFGcUlRUU1BUXNnQkNBRmFpQUhRUWgwSUFkQmdQNERjVUVJZG5JN0FBQWdCRUVDYWlFRUN5QUJRUUZxSWdFZ0FrY05BQXNNQWd0QkFDRXJJQllOQ1VFQUlRUU1BZ3NnQkNBYlRRMEFEQWdMSUFvaEV5QWFJUlFMSUM0Z01rRUNkR29nRlNBVktBSUFLQUlRRVFBQUlEdHJOZ0lBSUJVZ0JTQUVJQlVvQWdBb0FnZ1JBd0JGRFFZZ0NFRUFPZ0NLQVNBSVFRQTdBWWdCSUJVZ0ZTZ0NBQ2dDRUJFQUFFRURhaUFWSUJVb0FnQW9BaEFSQUFCSkRRWWdGU0FWS0FJQUtBSVFFUUFBSWdFZ0FVRURha0Y4Y1NBQlFYeExHeUlESUJVZ0ZTZ0NBQ2dDRUJFQUFDSUJSd1JBSUJVZ0NFR0lBV29nQXlBQmF5QVZLQUlBS0FJSUVRTUFSUTBIQ3lBRklBUVFGeUVESUNzRVFDQTBLQUlBSURKQkFYUnFJQVV2QUFJaUFVRUlkQ0FCUVFoMmNqc0JBQXNnQUNBRGFpRUFJQmtoQVNBeVFRRnFJaklnSVM4QkFFa05BQXNMSUI4Z0ZTQVZLQUlBS0FJUUVRQUFJQjhvQWhSck5nSVlJREVnRlNBVktBSUFLQUlRRVFBQU5nSVVJQzRnSVM4QkFFRUNkR29nSHlnQ0dEWUNBQ0E4UVFKQkFTQWhMd0VDSWdNYmRDSVRFQklnRXhBVUlSUkJBQ0VCSUFORkJFQWdQRUVCY1NGbEFrQWdFa1VFUUVFQUlRa01BUXNnUEVIKy93ZHhJUVpCQUNFSlFRQWhBZ05BSUFFZ0ZHb2dMaUFKUVFKMElnUnFLQUlBSWdOQkNYWTZBQUFnRkNBQlFRRnlhaUFEUVFGMk9nQUFJQlFnQVVFQ2Ntb2dMaUFFUVFSeWFpZ0NBQ0lEUVFsMk9nQUFJQlFnQVVFRGNtb2dBMEVCZGpvQUFDQUpRUUpxSVFrZ0FVRUVhaUVCSUFKQkFtb2lBaUFHUncwQUN3c2daVVVOQkNBQklCUnFJQzRnQ1VFQ2RHb29BZ0FpQTBFSmRqb0FBQ0FVSUFGQkFYSnFJQU5CQVhZNkFBQU1CQXNEUUNBQklCUnFJQzRnUGtFQ2RHb29BZ0FpQTBFWWRqb0FBQ0FVSUFGQkFYSnFJQU5CRUhZNkFBQWdGQ0FCUVFKeWFpQURRUWgyT2dBQUlCUWdBVUVEY21vZ0F6b0FBQ0FCUVFScUlRRWdFaUErUmlGbUlENUJBV29oUGlCbVJRMEFDd3dEQ3d3SkN5QXpJZ01oQVFKQUFrQWdCVVVOQUFOQUFrQUNRQ0FGSWdFb0FoQWlBQ0FrVFFSQUlBQWdKRWtOQWlBb0lBRW9BaFFpQUU4TkFRc2dBU0lES0FJQUlnVU5BZ3dEQ3lBQUlDaEpEUUFnQVNFQURBTUxJQUVvQWdRaUJRMEFDeUFCUVFScUlRTUxRUndRRWlJQUlBRTJBZ2dnQUVJQU53SUFJQUJCQURZQ0dDQUFJQ1N0SUdsQ0lJYUVOd0lRSUFNZ0FEWUNBQ0FBSVFFZ0NDZ0NZQ2dDQUNJSkJFQWdDQ0FKTmdKZ0lBTW9BZ0FoQVFzZ0NDZ0NaQ0FCRUNVZ0NDQUlLQUpvUVFGcU5nSm9DeUFBS0FJWUlRQU1CUXNnSHlBSE5nSVVJQUpGQkVCQkFDRUpEQWdMSUNFdkFRUWhFeUFoTHdFQUlSc2dLQ0F3YWlJUExRQUFJUUVnQ0VJQU53S2tBU0FJUWdBM0FwZ0JRUUFoQUFKQUFrQUNRQUovUVFBZ0FVRURTdzBBR2tFQUlBRkJBM0ZGRFFBYVFRQWdHeUFUUVFGclFmLy9BM0ZORFFBYUlCTWhFQ0FCUVFKeElRb2dBVUVCY1NFVVFRRWhCVUVBSVFsQkFDRUdRUUFoQXdOQUlBSWdCU0lCUVFKcUlnVkpCRUJCQUNFQVFRQWhCUXdEQ3lBQklBOXFMd0FBSWdGQkNIUWdBVUVJZG5KQi8vOERjU0VIQWtBZ0FDQUdSd1JBSUFBZ0J6c0JBQ0FJSUFCQkFtb2lBRFlDcUFFTUFRc2dBQ0FEYXlJR1FYMU1EUVJCLy8vLy93Y2dCaUFHUVFGMUlnUkJBV29pQVNBQklBWkpHeUFHUWY3Ly8vOEhUeHNpQ3dSL0lBdEJBRWdORWlBTFFRRjBFQklGUVFBTElRWWdCaUFFUVFGMGFpSUJJQWM3QVFBZ0FVRUNhaUVFSUFBZ0EwY0VRQU5BSUFGQkFtc2lBU0FBUVFKcklnQXZBUUE3QVFBZ0FDQURSdzBBQ3dzZ0MwRUJkQ0FHYWlFR0lBZ2dCRFlDcUFFZ0F3UkFJQU1RRVFzZ0JDRUFJQUVoQXdzZ0NVRUJhaUlKUWYvL0EzRWdFMGtOQUFzZ0NDQUROZ0trQVVFQUlRRkJBQ0VBUVFBaEJrRUFJUWtDUUFKQUEwQUNRQ0FVUlFSQUlBVkJBbW9pQXlBQ1N3MERJQVVnRDJvdkFBQWlCRUVJZENBRVFRaDJja0gvL3dOeElRY2dBeUVGREFFTElEUW9BZ0FnQUVFQmRHb3ZBUUFoQndzQ1FDQUJJQVpIQkVBZ0FTQUhPd0VBSUFnZ0FVRUNhaUlCTmdLY0FRd0JDeUFCSUFscklnWkJmVXdORkVILy8vLy9CeUFHSUFaQkFYVWlCRUVCYWlJRElBTWdCa2tiSUFaQi92Ly8vd2RQR3lJTEJIOGdDMEVBU0EwVUlBdEJBWFFRRWdWQkFBc2hCaUFHSUFSQkFYUnFJZ01nQnpzQkFDQURRUUpxSVFRZ0FTQUpSd1JBQTBBZ0EwRUNheUlESUFGQkFtc2lBUzhCQURzQkFDQUJJQWxIRFFBTEN5QUxRUUYwSUFacUlRWWdDQ0FFTmdLY0FTQUpCRUFnQ1JBUkN5QUVJUUVnQXlFSkN5QUFRUUZxSWdBZ0UwY05BQXNnRXlBYlNRUkFBMEFDUUNBS1JRUkFJQVZCQW1vaUF5QUNTdzBFSUFVZ0Qyb3ZBQUFpQUVFSWRDQUFRUWgyY2tILy93TnhJUUFnQXlFRkRBRUxJRFFvQWdBZ0VFRUJkR292QVFBaEFBc0NRQ0FCSUFaSEJFQWdBU0FBT3dFQUlBZ2dBVUVDYWlJQk5nS2NBUXdCQ3lBQklBbHJJZ1pCZlV3TkNFSC8vLy8vQnlBR0lBWkJBWFVpQkVFQmFpSURJQU1nQmtrYklBWkIvdi8vL3dkUEd5SUhCSDhnQjBFQVNBMFZJQWRCQVhRUUVnVkJBQXNoQmlBR0lBUkJBWFJxSWdNZ0FEc0JBQ0FEUVFKcUlRQWdBU0FKUndSQUEwQWdBMEVDYXlJRElBRkJBbXNpQVM4QkFEc0JBQ0FCSUFsSERRQUxDeUFIUVFGMElBWnFJUVlnQ0NBQU5nS2NBU0FKQkVBZ0NSQVJDeUFBSVFFZ0F5RUpDeUFRUVFGcUloQWdHMGNOQUFzTElBZ2dCallDb0FGQkFDRUJJQk1nRzJwQkFYUWlBaEFTSUFJUUZDRUdRUUVnR3lBYlFRRk5HeUVGSUFnb0FxUUJJUVJCQUNFREEwQWdBU0FUU1FSQUlBTWdCbW9nQkNBQlFRRjBhaThCQUNJQVFRaDBJQUJCQ0haeU93QUFJQU5CQW1vaEF3c2dBeUFHYWlBSklBRkJBWFJxTHdFQUlnQkJDSFFnQUVFSWRuSTdBQUFnQTBFQ2FpRURJQUZCQVdvaUFTQUZSdzBBQ3lBR0lBSVFGeUVBSUJVZ0JpQUNJQlVvQWdBb0FnZ1JBd0FoQVNBR0VCRU1BUXRCQUNFQVFRQWhBVUVBSUFsRkRRRWFDeUFKRUJFZ0FRc2hCU0FJS0FLa0FTRURDeUFEQkVBZ0F4QVJDeUFGRFFWQkFDRUpEQWtMSUFnZ0F6WUNwQUVnQ0NBQU5nS3NBUXdQQ3d3TUN5QVVJQk1RRnlFWUlCVWdGQ0FUSUJVb0FnQW9BZ2dSQXdBaFp5QVVFQkVnWjBVRVFFRUFJVDBNQVFzZ01TQVZJQlVvQWdBb0FoQVJBQUFnTVNnQ0ZHczJBaGhCQVNFOUN5QUZCRUFnQlJBUkN5QU9SUTBBSUE0UUVRc2dDQ2dDakFFaUFRUkFJQUVRRVFzZ0xoQVJJRDBOQUVFQUlRa01CQXNnTXlJSklRRUNRQUpBSUFnb0FtUWlBMFVOQUFOQUFrQUNRQ0FESWdFb0FoQWlBeUFrVFFSQUlBTWdKRWtOQWlBb0lBRW9BaFFpQTA4TkFRc2dBU0VKSUFFb0FnQWlBdzBDREFNTElBTWdLRWtOQUNBQklRTU1Bd3NnQVNnQ0JDSUREUUFMSUFGQkJHb2hDUXRCSEJBU0lnTWdBVFlDQ0NBRFFnQTNBZ0FnQTBFQU5nSVlJQU1nSkswZ2FVSWdob1EzQWhBZ0NTQUROZ0lBSUFNaEFTQUlLQUpnS0FJQUlnUUVRQ0FJSUFRMkFtQWdDU2dDQUNFQkN5QUlLQUprSUFFUUpTQUlJQWdvQW1oQkFXbzJBbWdMSUFNZ0FEWUNHQXNnQ0NBQVFSaDBJQUJCZ1A0RGNVRUlkSElnQUVFSWRrR0EvZ054SUFCQkdIWnljallBZUNBSUlCOG9BaFFpQVVFWWRDQUJRWUQrQTNGQkNIUnlJQUZCQ0haQmdQNERjU0FCUVJoMmNuSTJBSHdnQ0NBZktBSVlJZ0ZCR0hRZ0FVR0EvZ054UVFoMGNpQUJRUWgyUVlEK0EzRWdBVUVZZG5KeU5nQ0FBU0FmS0FJQUlRa0NRQUpBSUEwaUJDSUJLQUlBSWdORkRRQURRQ0FESWdFb0FoQWlBeUFKU3dSQUlBRWlCQ2dDQUNJRERRRU1BZ3NnQXlBSlR3UkFJQUVoQXd3REN5QUJLQUlFSWdNTkFBc2dBVUVFYWlFRUMwRVlFQklpQXlBSk5nSVFJQU1nQVRZQ0NDQURRZ0EzQWdBZ0EwRUFOZ0lVSUFRZ0F6WUNBQ0FESVFFZ0lTZ0NGQ2dDQUNJSkJFQWdJU0FKTmdJVUlBUW9BZ0FoQVFzZ0lTZ0NHQ0FCRUNVZ0lTQWhLQUljUVFGcU5nSWNDeUFWSUFoQitBQnFJQU1vQWhSQkJHcEJEQ0FWS0FJQUtBSU1FUWdBUlFSQVFRQWhDUXdEQ3lBSVFmZ0Fha0VNRUJjaENTQUlRUUE2QUtZQklBaEJBRHNCcEFFQ1FDQVZJQlVvQWdBb0FoQVJBQUJCQTJvZ0ZTQVZLQUlBS0FJUUVRQUFUd1JBSUJVZ0ZTZ0NBQ2dDRUJFQUFDSUJJQUZCQTJwQmZIRWdBVUY4U3hzaUF5QVZJQlVvQWdBb0FoQVJBQUFpQVVZTkFTQVZJQWhCcEFGcUlBTWdBV3NnRlNnQ0FDZ0NDQkVEQUEwQkMwRUFJUWtNQXdzZ0h5Z0NHQ0FmS0FJVWFpQVZJQlVvQWdBb0FoQVJBQUJMQkVCQkFDRUpEQU1MSUFBZ1FXb2dDV29oUVNBVklCVW9BZ0FvQWhBUkFBQWhCeUFwUVFGcUlpa2dDQ2dDY0NJQklBZ29BbXdpQUd0QkFuVkpEUUFMSUFBZ0FVWU5BQU5BSUFBb0FnQWlBeWdDQUVIa3dwWERCa2NFUUNBQklBQkJCR29pQUVjTkFRd0NDd3NnQXlnQ0dFRU1TUVJBUVFBaENRd0NDeUFJUWJyZndvMTdJRUZySWdCQkdIUWdBRUdBL2dOeFFRaDBjaUFBUVFoMlFZRCtBM0VnQUVFWWRuSnlOZ0NrQVVFQUlRa2dGU0FJUWFRQmFpQURLQUlVUVFocVFRUWdGU2dDQUNnQ0RCRUlBRVVOQVF0QkFTRUpDeUFJS0FKc0lnQUVRQ0FJSUFBMkFuQWdBQkFSQ3lBSkJFQWdGMEVCYWlJWElBZ29BbGdnQ0NnQ1ZHdEJCWFZKRFFFTEN5QUlLQUlNSWdGRkRRRUxJQUVRRVFzZ0NDZ0NSQ0lFQkVBZ0NDZ0NTQ0lESUFRaUFVY0VRQU5BSUFOQkdHc2lBQ2dDRENJQkJFQWdBMEVJYXlBQk5nSUFJQUVRRVFzZ0FDSURJQVJIRFFBTElBZ29Ba1FoQVFzZ0NDQUVOZ0pJSUFFUUVRc2dDQ2dDT0NJQUJFQWdDQ0FBTmdJOElBQVFFUXNnQ0VIZ0FHb2dDQ2dDWkJBcklBZ29BbFFpQkFSQUlBZ29BbGdpQXlBRUlnRkhCRUFEUUNBRFFReHJJQU5CSUdzaUFDZ0NHQkFnSUFBb0FnZ2lBUVJBSUFOQkZHc2dBVFlDQUNBQkVCRUxJQUFpQXlBRVJ3MEFDeUFJS0FKVUlRRUxJQWdnQkRZQ1dDQUJFQkVMSUFoQnNBRnFKQUFnQ1F3Q0N4QWtBQXNnQ0NBSk5nS1lBU0FJSUFFMkFxQUJEQUVMQkg4Z0l5Z0NJQ0VESUNNZ0l5Z0NIQ0JESUNNdEFDY2lBY0JCQUVnaUFCczJBaXdnSXlBRElBRWdBQnMyQWloQnBCQWdJMEVvYWhBUUJVRUNDellDQUNBakxBQW5RUUJJQkVBZ0l5Z0NIQkFSQ3lBalFUQnFKQUFQQ3hBaEFBc0xwcG9JRGdCQmdBZ0wxZ3AxYm5OcFoyNWxaQ0J6YUc5eWRBQjFibk5wWjI1bFpDQnBiblFBWm14dllYUUFkV2x1ZERZMFgzUUFaR1ZqYjIxd2NtVnpjd0IyWldOMGIzSUFkVzV6YVdkdVpXUWdZMmhoY2dCemRHUTZPbVY0WTJWd2RHbHZiZ0JpYjI5c0FHVnRjMk55YVhCMFpXNDZPblpoYkFCaVlXUmZZWEp5WVhsZmJtVjNYMnhsYm1kMGFBQjFibk5wWjI1bFpDQnNiMjVuQUhOMFpEbzZkM04wY21sdVp3QmlZWE5wWTE5emRISnBibWNBYzNSa09qcHpkSEpwYm1jQWMzUmtPanAxTVRaemRISnBibWNBYzNSa09qcDFNekp6ZEhKcGJtY0FaRzkxWW14bEFIWnZhV1FBYzNSa09qcGlZV1JmWVd4c2IyTUFaVzF6WTNKcGNIUmxiam82YldWdGIzSjVYM1pwWlhjOGMyaHZjblErQUdWdGMyTnlhWEIwWlc0Nk9tMWxiVzl5ZVY5MmFXVjNQSFZ1YzJsbmJtVmtJSE5vYjNKMFBnQmxiWE5qY21sd2RHVnVPanB0WlcxdmNubGZkbWxsZHp4cGJuUStBR1Z0YzJOeWFYQjBaVzQ2T20xbGJXOXllVjkyYVdWM1BIVnVjMmxuYm1Wa0lHbHVkRDRBWlcxelkzSnBjSFJsYmpvNmJXVnRiM0o1WDNacFpYYzhabXh2WVhRK0FHVnRjMk55YVhCMFpXNDZPbTFsYlc5eWVWOTJhV1YzUEhWcGJuUTRYM1ErQUdWdGMyTnlhWEIwWlc0Nk9tMWxiVzl5ZVY5MmFXVjNQR2x1ZERoZmRENEFaVzF6WTNKcGNIUmxiam82YldWdGIzSjVYM1pwWlhjOGRXbHVkREUyWDNRK0FHVnRjMk55YVhCMFpXNDZPbTFsYlc5eWVWOTJhV1YzUEdsdWRERTJYM1ErQUdWdGMyTnlhWEIwWlc0Nk9tMWxiVzl5ZVY5MmFXVjNQSFZwYm5RMk5GOTBQZ0JsYlhOamNtbHdkR1Z1T2pwdFpXMXZjbmxmZG1sbGR6eHBiblEyTkY5MFBnQmxiWE5qY21sd2RHVnVPanB0WlcxdmNubGZkbWxsZHp4MWFXNTBNekpmZEQ0QVpXMXpZM0pwY0hSbGJqbzZiV1Z0YjNKNVgzWnBaWGM4YVc1ME16SmZkRDRBWlcxelkzSnBjSFJsYmpvNmJXVnRiM0o1WDNacFpYYzhZMmhoY2o0QVpXMXpZM0pwY0hSbGJqbzZiV1Z0YjNKNVgzWnBaWGM4ZFc1emFXZHVaV1FnWTJoaGNqNEFjM1JrT2pwaVlYTnBZMTl6ZEhKcGJtYzhkVzV6YVdkdVpXUWdZMmhoY2o0QVpXMXpZM0pwY0hSbGJqbzZiV1Z0YjNKNVgzWnBaWGM4YzJsbmJtVmtJR05vWVhJK0FHVnRjMk55YVhCMFpXNDZPbTFsYlc5eWVWOTJhV1YzUEd4dmJtYytBR1Z0YzJOeWFYQjBaVzQ2T20xbGJXOXllVjkyYVdWM1BIVnVjMmxuYm1Wa0lHeHZibWMrQUdWdGMyTnlhWEIwWlc0Nk9tMWxiVzl5ZVY5MmFXVjNQR1J2ZFdKc1pUNEFzQWNBQVBnSEFBQk9NVEJsYlhOamNtbHdkR1Z1TTNaaGJFVUFBRUFSQWdDY0J3QUFUbE4wTTE5Zk1qRXlZbUZ6YVdOZmMzUnlhVzVuU1dOT1UxOHhNV05vWVhKZmRISmhhWFJ6U1dORlJVNVRYemxoYkd4dlkyRjBiM0pKWTBWRlJVVUFBRUFSQWdDNEJ3QUFhV2xwQUU0eE1HVnRjMk55YVhCMFpXNHhNVzFsYlc5eWVWOTJhV1YzU1doRlJRQUFRQkVDQUFRSUFBQUFBQUFBY0dGdFkyUmhaV2hoWldob2VIUnRhSEI0WVcxbGJXRnVNaTlUVDNSemIzQWdkSFpqYldkd1ptWjViR2RoWTI5c2NHVnljQ0JHUmtOSFVrOVdWRVJDUlVOTVFrVndjMkZuZUcxa2FHNXlaV3RJVTFSTVZFeERVRmhOUkZaaFpXaDJlSFJ0ZGtWVFFVSkdSVVJIVTA5UVIwSlZVMGREVTBKRlJsUlRTa2hVUVUxVVJFSkRRMHhDUTFKTVQwTk1RVkJESUVkV1UzaHBZbk4wYm1OaGNtRjJZWFJoWkdKamIyeGlibXh6WW5KaGRtTmpjMlJtZEdGbFpuaDBiV1p5WVhabWNtRjJaM2wwYzJoMGMzVnFjbUZqYkhSeWIyMTRjbTl0WkdKd2IzQnZjbkJyWVhKMFpuQmhXbVpzYVZOMFlXeEhZMjlzUjNSaFpVWnNiR2xUVGpWM2IyWm1NakUwVjA5R1JqSlRkSEpwYm1kUGRYUkZBRTQxZDI5bVpqSTRWMDlHUmpKUGRYUkZBRUhnRWd2WUFRRWdBaXdnQ0NCdlppQjBhR1VnQkNCdlppQUNjeUFCTGdVZ1lXNWtJQVFnYVc0Z0FTSUVJSFJ2SUFJaVBnRUtBaTRnQVYwRklHWnZjaUFESUdFZ0JpQjBhR0YwSUFFbkJpQjNhWFJvSUFZZ1puSnZiU0FFSUdKNUlBRW9CaTRnVkdobElBUWdiMjRnQkNCaGN5QUVJR2x6SUFScGJtY2dBZ29KQVRvRFpXUWdBajBpQkNCaGRDQURiSGtnQVN3Q1BTY0ZMbU52YlM4SExpQlVhR2x6SUFVZ2JtOTBJQU5sY2lBRFlXd2dCR1oxYkNBRWFYWmxJQVZzWlhOeklBUmxjM1FnQkdsNlpTQUN3cUFFYjNWeklBVWdkR2hsSUFKbElBQkJ3aFFMWVFJQUJRQU9BQk1BRmdBWUFCNEFJd0FsQUNvQUxRQXZBRElBTkFBNkFENEFSUUJIQUU0QVZRQmFBRndBWXdCb0FHMEFjZ0IzQUhvQWZBQ0FBSU1BaUFDTUFJNEFrUUNYQUo4QXBRQ3BBSzBBc2dDM0FMMEF3Z0RIQU1vQXp3RFZBTmdBUWJBVkM0SURNUUF4TVFBQUFBQUFNUXd4TVFvQU1RQXZBQUF4QkFBQU1RQURNUW94TVFBR01RMHhNUUV4QVFBQU1RQUJBQW9BTVFBSE1RQUpNQUFBTVFBSU1RQUZNUUFLTVFBTE1RTXhNUUFOTVFBT01RNHhNUUl4TVFBUE1RQVFBQW94TVFBTUJRQXhBQUFCTVE4eE1RQVNNUUFSTVFBVE1RQVVNUkF4TVJFeEx3QXhNUVF4TVFBV01Rc3hNUUFYTVFBWU1RQVpNUWN4TVFFYU1RQWJNUUFjQUFBTU1RQWRNUlF4TVJJeE1RWXhNUUFWTVFvQk1RZ3hNUUFmTVFBZ0x3QURNUVV4TVFreEFBb0JNUW9JQlFBVk1Rc0FNUW9LTVFBZUFBQUZJd0F4THdBQ01Rb1JNUUFrTVFBaEJRQUFNUW9WTVFvRk1RQWxBQUFlTVFBbUFBc0FNUUFuQUFzeE1RQWlNUXNJTVFvTUFBQVZNUUFvQUFvTU1RQXBNUUFxTVFzUk1RQXJBQW9GTVFzS0FBQWlNUW9oTVFBc01Rc0ZMUUF4QUFBaE1Rb2VNUXNlTVFBdU1Rc0JNUW9pQUFvaEFBc2VBQXNCTVFzaE1Rc1ZNUXNNQUFzRk1Rc2lBQXNNQUFvZUFBc2lBQW9pQUFBQUFBQUJBZ01FQUFVUkJoQUhDQWtLQ3d3TkRnOEFRY0FZQzRjQkFnSUNBd0lDQWdRQ0FnSURBZ0lDQkFBRUF3SUFCQU1CQUFRREFnQUVBd1VCQUFJQUJRQUNBQWtBQWdBTkFBSUFFUUFEQUJrQUF3QWhBQU1BS1FBREFERUFCQUJCQUFRQVVRQUVBR0VBQkFCeEFBVUFrUUFGQUxFQUJRRFJBQVVBOFFBR0FERUJCZ0J4QVFjQThRRUlBUEVDQ1FEeEJBb0E4UWdMQVBFUURBRHhJQTBBOFVBWUFFSFVHUXVBQVFFQUFBQURBQUFBQndBQUFBOEFBQUFmQUFBQVB3QUFBSDhBQUFEL0FBQUEvd0VBQVA4REFBRC9Cd0FBL3c4QUFQOGZBQUQvUHdBQS8zOEFBUC8vQUFELy93RUEvLzhEQVAvL0J3RC8vdzhBLy84ZkFQLy9Qd0QvLzM4QS8vLy9BUC8vL3dILy8vOEQvLy8vQi8vLy93Ly8vLzhmLy8vL1AvLy8vMy8vLy8vL0FFSGtHZ3VjQWdRQUFBQU1BQUFBSEFBQUFFa0FBQUIrQUFBQTVBQUFBS2dCQUFBQUFRSURCQVVHQndnSkNnc01EUTRQRUJFU0V4UVZGaGNZR1JvYkhCMGVIeUFoSWlNa0pTWW5LQ2txS3l3dExpOHdNVEl6TkRVMk56ZzVPanM4UFQ0L0FBRUNBd1FGQmdjSUNRb0xEQTBPRHhBUkVoTVVGUllYR0JrYUd4d2RIaDhnSVNJakpDVW1KeWdwS2lzc0xTNHZNREV5TXpRMU5qYzRPVG83UEQwK1B3QUJBZ01FQlFZSENBa0tDd3dORGc4UUVSSVRGQlVXRnhnWkdoc2NIUjRmSUNFaUl5UWxKaWNvS1NvckxDMHVMekF4TWpNME5UWTNPRGs2T3p3OVBqOEFBUUlEQkFVR0J3Z0pDZ3NNRFE0UEVCRVNFeFFWRmhjWUdSb2JIQjBlSHlBaElpTWtKU1luS0NrcUt5d3RMaTh3TVRJek5EVTJOemc1T2pzOFBUNC9BRUdFSHd2OEFRRUJBUUVDQWdJQ0F3TURBd1FFQkFRRkJRVUZCZ1lHQmdjSEJ3Y0lDQWdJQ1FrSkNRb0tDZ29MQ3dzTERBd01EQTBORFEwT0RnNE9EdzhQRHhBUUVCQVJFUkVSRWhJU0VoTVRFeE1VRkJRVUZSVVZGUllXRmhZWEZ4Y1hHQmdZR0JrWkdSa2FHaG9hR3hzYkd4d2NIQndkSFIwZEhoNGVIaDhmSHg4Z0lDQWdJU0VoSVNJaUlpSWpJeU1qSkNRa0pDVWxKU1VtSmlZbUp5Y25KeWdvS0NncEtTa3BLaW9xS2lzckt5c3NMQ3dzTFMwdExTNHVMaTR2THk4dk1EQXdNREV4TVRFeU1qSXlNek16TXpRME5EUTFOVFUxTmpZMk5qYzNOemM0T0RnNE9UazVPVG82T2pvN096czdQRHc4UEQwOVBUMCtQajQrUHo4L1B3QkJpU01MQlFRRUFBQUVBRUdnSXd2Z0FRZ01FQXdNRkF3UUdCd01EQ0FNSkF3c0xDd3NMQ3dzTEN3c0lDQVlLQndNRERBME5EUXdORFEwTURRME5EUTBNRFEwTkRRME1EUTBORFEwR0F3Y0RBd01PRHc4UERnOFBEdzRQRHc4UER3NFBEdzhQRHc0UER3OFBEd1lEQndNQUFBQkFBRUFBUUFCQUFFQUFRQUJBQUVBQVFBQkFBRUFBUUFCQUFFQUFRQUJBQUVBQVFBQkFBRUFBUUFCQUFFQUFRQUJBQUVBQVFBQkFBRUFBUUFCQUFFQ0F3SURBZ01DQXdJREFnTUNBd0lEQWdNQ0F3SURBZ01DQXdJREFnTUNBd0lEQWdNQ0F3SURBZ01DQXdJREFnTUNBd0lEQWdNQ0F3SURBZ01DQXdJREFFR2hKUXRlQVFFQkFRRUJBUUVCQVFFQkFRRUJBZ0lDQWdJQ0FnSUNBZ0VCQVFFQkFRRUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnRUJBUUVCQVFNREF3TURBd01EQXdNREF3TURBd01EQXdNREF3TURBd01EQVFFQkFRQkI0Q1lMNy80SEFnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lBQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRR0JnWUdCZ1lHQmdZR0JnWUdCZ1lHQmdZR0JnWUdCZ1lHQmdZR0JnWUdCZ1lHQmdZR0JnWUdCZ1lHQmdZR0JnWUdCZ1lHQmdZR0JnWUdCZ1lHQmdZR0NBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBb0tDZ29LQ2dvS0Nnb0tDZ29LQ2dvS0Nnb0tDZ29LQ2dvS0Nnb0tDZ29LQ2dvS0Nnb0tDZ29LQ2dvS0Nnb0tDZ3dNREF3TURBd01EQXdNREF3TURBNEFBRUJBUUVCQVFFQkFRRUJBUUVCQVFJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnTURBd01EQXdNREF3TURBd01EQXdNREF3TURBd01EQXdNREF3TURBd01EQXdNREF3TURBd01EQXdNREF3TURBd01EQXdNREF3TURBd01EQXdNREF3TUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCUVVGQlFVRkJRVUZCUVVGQlFVRkJRVUZCUVVGQlFVRkJRVUZCUVVGQlFVRkJRVUZCUVVGQlFVRkJRVUZCUVVGQmdZR0JnWUdCZ1lHQmdZR0JnWUdCd0FBQUFBQUFBSUFBQUFBQVFBQUF3QUFBQUFDQUFBRUFBQUFBQU1BQUFVQUFBQUFBd0FBQmdBQUFBQURBQUFIQUFBQUFBTUFBQWdBQUFBQUF3QUFDUUFBQUFBQUFRQUNBQUFBQUFFQkFBTUFBQUFBQWdFQUJBQUFBQUFEQVFBRkFBQUFBQU1CQUFZQUFBQUFBd0VBQndBQUFBQURBUUFJQUFBQUFBTUJBQWtBQUFBQUFBSUFBZ0FBQUFBQkFnQURBQUFBQUFJQ0FBUUFBQUFBQXdJQUJRQUFBQUFEQWdBR0FBQUFBQU1DQUFjQUFBQUFBd0lBQ0FBQUFBQURBZ0FKQUFBQUFBQURBQUlBQUFBQUFRTUFBd0FBQUFBQ0F3QUVBQUFBQUFNREFBVUFBQUFBQXdNQUJnQUFBQUFEQXdBSEFBQUFBQU1EQUFnQUFBQUFBd01BQ1FBQUFBQUFCQUFDQUFBQUFBRUVBQU1BQUFBQUFnUUFCQUFBQUFBREJBQUZBQUFBQUFNRUFBWUFBQUFBQXdRQUJ3QUFBQUFEQkFBSUFBQUFBQU1FQUFrQUFBQUFBQVVBQWdBQUFBQUJCUUFEQUFBQUFBSUZBQVFBQUFBQUF3VUFCUUFBQUFBREJRQUdBQUFBQUFNRkFBY0FBQUFBQXdVQUNBQUFBQUFEQlFBSkFBRUFBQUFHQUFJQUFRQUFBUVlBQXdBQkFBQUNCZ0FFQUFFQUFBTUdBQVVBQVFBQUF3WUFCZ0FCQUFBREJnQUhBQUVBQUFNR0FBZ0FBUUFBQXdZQUNRQUJBQUFBQ0FBQ0FBRUFBQUVJQUFNQUFRQUFBZ2dBQkFBQkFBQURDQUFGQUFFQUFBTUlBQVlBQVFBQUF3Z0FCd0FCQUFBRENBQUlBQUVBQUFNSUFBa0FBQUVBQXdBQUNnQUFBUUFEQUFBTUFBQUNBQU1BQUE0QUFBSUFBd0FBRWdBQUF3QURBQUFXQUFBREFBTUFBQjRBQUFRQUF3QUFKZ0FBQkFBREFBQTJBQUFCQUFNQkFBb0FBQUVBQXdFQURBQUFBZ0FEQVFBT0FBQUNBQU1CQUJJQUFBTUFBd0VBRmdBQUF3QURBUUFlQUFBRUFBTUJBQ1lBQUFRQUF3RUFOZ0FBQVFBREFnQUtBQUFCQUFNQ0FBd0FBQUlBQXdJQURnQUFBZ0FEQWdBU0FBQURBQU1DQUJZQUFBTUFBd0lBSGdBQUJBQURBZ0FtQUFBRUFBTUNBRFlBQUFFQUF3TUFDZ0FBQVFBREF3QU1BQUFDQUFNREFBNEFBQUlBQXdNQUVnQUFBd0FEQXdBV0FBQURBQU1EQUI0QUFBUUFBd01BSmdBQUJBQURBd0EyQUFBQkFBTUVBQW9BQUFFQUF3UUFEQUFBQWdBREJBQU9BQUFDQUFNRUFCSUFBQU1BQXdRQUZnQUFBd0FEQkFBZUFBQUVBQU1FQUNZQUFBUUFBd1FBTmdBQUFRQURCUUFLQUFBQkFBTUZBQXdBQUFJQUF3VUFEZ0FBQWdBREJRQVNBQUFEQUFNRkFCWUFBQU1BQXdVQUhnQUFCQUFEQlFBbUFBQUVBQU1GQURZQUFRRUFBd1lBQ2dBQkFRQURCZ0FNQUFFQ0FBTUdBQTRBQVFJQUF3WUFFZ0FCQXdBREJnQVdBQUVEQUFNR0FCNEFBUVFBQXdZQUpnQUJCQUFEQmdBMkFBRUJBQU1JQUFvQUFRRUFBd2dBREFBQkFnQURDQUFPQUFFQ0FBTUlBQklBQVFNQUF3Z0FGZ0FCQXdBRENBQWVBQUVFQUFNSUFDWUFBUVFBQXdnQU5nQUFBUDhBQUFBQ0FBQUEvd0VBQUFNQUFBRC9BZ0FBQkFBQUFQOERBQUFGQUFBQS93TUFBQVlBQUFEL0F3QUFCd0FBQVA4REFBQUlBQUFBL3dNQUFBa0FBQUQvQUFFQUFnQUFBUDhCQVFBREFBQUEvd0lCQUFRQUFBRC9Bd0VBQlFBQUFQOERBUUFHQUFBQS93TUJBQWNBQUFEL0F3RUFDQUFBQVA4REFRQUpBQUFBL3dBQ0FBSUFBQUQvQVFJQUF3QUFBUDhDQWdBRUFBQUEvd01DQUFVQUFBRC9Bd0lBQmdBQUFQOERBZ0FIQUFBQS93TUNBQWdBQUFEL0F3SUFDUUFBQVA4QUF3QUNBQUFBL3dFREFBTUFBQUQvQWdNQUJBQUFBUDhEQXdBRkFBQUEvd01EQUFZQUFBRC9Bd01BQndBQUFQOERBd0FJQUFBQS93TURBQWtBQUFEL0FBUUFBZ0FBQVA4QkJBQURBQUFBL3dJRUFBUUFBQUQvQXdRQUJRQUFBUDhEQkFBR0FBQUEvd01FQUFjQUFBRC9Bd1FBQ0FBQUFQOERCQUFKQUFBQS93QUZBQUlBQUFEL0FRVUFBd0FBQVA4Q0JRQUVBQUFBL3dNRkFBVUFBQUQvQXdVQUJnQUFBUDhEQlFBSEFBQUEvd01GQUFnQUFBRC9Bd1VBQ1FBQkFQOEFCZ0FDQUFFQS93RUdBQU1BQVFEL0FnWUFCQUFCQVA4REJnQUZBQUVBL3dNR0FBWUFBUUQvQXdZQUJ3QUJBUDhEQmdBSUFBRUEvd01HQUFrQUFRRC9BQWdBQWdBQkFQOEJDQUFEQUFFQS93SUlBQVFBQVFEL0F3Z0FCUUFCQVA4RENBQUdBQUVBL3dNSUFBY0FBUUQvQXdnQUNBQUJBUDhEQ0FBSkFBQUIvd01BQUFvQUFBSC9Bd0FBREFBQUF2OERBQUFPQUFBQy93TUFBQklBQUFQL0F3QUFGZ0FBQS84REFBQWVBQUFFL3dNQUFDWUFBQVQvQXdBQU5nQUFBZjhEQVFBS0FBQUIvd01CQUF3QUFBTC9Bd0VBRGdBQUF2OERBUUFTQUFBRC93TUJBQllBQUFQL0F3RUFIZ0FBQlA4REFRQW1BQUFFL3dNQkFEWUFBQUgvQXdJQUNnQUFBZjhEQWdBTUFBQUMvd01DQUE0QUFBTC9Bd0lBRWdBQUEvOERBZ0FXQUFBRC93TUNBQjRBQUFUL0F3SUFKZ0FBQlA4REFnQTJBQUFCL3dNREFBb0FBQUgvQXdNQURBQUFBdjhEQXdBT0FBQUMvd01EQUJJQUFBUC9Bd01BRmdBQUEvOERBd0FlQUFBRS93TURBQ1lBQUFUL0F3TUFOZ0FBQWY4REJBQUtBQUFCL3dNRUFBd0FBQUwvQXdRQURnQUFBdjhEQkFBU0FBQUQvd01FQUJZQUFBUC9Bd1FBSGdBQUJQOERCQUFtQUFBRS93TUVBRFlBQUFIL0F3VUFDZ0FBQWY4REJRQU1BQUFDL3dNRkFBNEFBQUwvQXdVQUVnQUFBLzhEQlFBV0FBQUQvd01GQUI0QUFBVC9Bd1VBSmdBQUJQOERCUUEyQUFFQi93TUdBQW9BQVFIL0F3WUFEQUFCQXY4REJnQU9BQUVDL3dNR0FCSUFBUVAvQXdZQUZnQUJBLzhEQmdBZUFBRUUvd01HQUNZQUFRVC9Bd1lBTmdBQkFmOERDQUFLQUFFQi93TUlBQXdBQVFML0F3Z0FEZ0FCQXY4RENBQVNBQUVEL3dNSUFCWUFBUVAvQXdnQUhnQUJCUDhEQ0FBbUFBRUUvd01JQURZQUFnRC9BQW9BQWdBQ0FQOEJDZ0FEQUFJQS93SUtBQVFBQWdEL0F3b0FCUUFDQVA4RENnQUdBQUlBL3dNS0FBY0FBZ0QvQXdvQUNBQUNBUDhEQ2dBSkFBSUEvd0FPQUFJQUFnRC9BUTRBQXdBQ0FQOENEZ0FFQUFJQS93TU9BQVVBQWdEL0F3NEFCZ0FDQVA4RERnQUhBQUlBL3dNT0FBZ0FBZ0QvQXc0QUNRQURBUDhBRWdBQ0FBTUEvd0VTQUFNQUF3RC9BaElBQkFBREFQOERFZ0FGQUFNQS93TVNBQVlBQXdEL0F4SUFCd0FEQVA4REVnQUlBQU1BL3dNU0FBa0FBd0QvQUJvQUFnQURBUDhCR2dBREFBTUEvd0lhQUFRQUF3RC9BeG9BQlFBREFQOERHZ0FHQUFNQS93TWFBQWNBQXdEL0F4b0FDQUFEQVA4REdnQUpBQVFBL3dBaUFBSUFCQUQvQVNJQUF3QUVBUDhDSWdBRUFBUUEvd01pQUFVQUJBRC9BeUlBQmdBRUFQOERJZ0FIQUFRQS93TWlBQWdBQkFEL0F5SUFDUUFFQVA4QU1nQUNBQVFBL3dFeUFBTUFCQUQvQWpJQUJBQUVBUDhETWdBRkFBUUEvd015QUFZQUJBRC9BeklBQndBRUFQOERNZ0FJQUFRQS93TXlBQWtBQlFEL0FFSUFBZ0FGQVA4QlFnQURBQVVBL3dKQ0FBUUFCUUQvQTBJQUJRQUZBUDhEUWdBR0FBVUEvd05DQUFjQUJRRC9BMElBQ0FBRkFQOERRZ0FKQUFVQS93QmlBQUlBQlFEL0FXSUFBd0FGQVA4Q1lnQUVBQVVBL3dOaUFBVUFCUUQvQTJJQUJnQUZBUDhEWWdBSEFBVUEvd05pQUFnQUJRRC9BMklBQ1FBQ0FmOERDZ0FLQUFJQi93TUtBQXdBQWdML0F3b0FEZ0FDQXY4RENnQVNBQUlEL3dNS0FCWUFBZ1AvQXdvQUhnQUNCUDhEQ2dBbUFBSUUvd01LQURZQUFnSC9BdzRBQ2dBQ0FmOEREZ0FNQUFJQy93TU9BQTRBQWdML0F3NEFFZ0FDQS84RERnQVdBQUlEL3dNT0FCNEFBZ1QvQXc0QUpnQUNCUDhERGdBMkFBTUIvd01TQUFvQUF3SC9BeElBREFBREF2OERFZ0FPQUFNQy93TVNBQklBQXdQL0F4SUFGZ0FEQS84REVnQWVBQU1FL3dNU0FDWUFBd1QvQXhJQU5nQURBZjhER2dBS0FBTUIvd01hQUF3QUF3TC9BeG9BRGdBREF2OERHZ0FTQUFNRC93TWFBQllBQXdQL0F4b0FIZ0FEQlA4REdnQW1BQU1FL3dNYUFEWUFCQUgvQXlJQUNnQUVBZjhESWdBTUFBUUMvd01pQUE0QUJBTC9BeUlBRWdBRUEvOERJZ0FXQUFRRC93TWlBQjRBQkFUL0F5SUFKZ0FFQlA4RElnQTJBQVFCL3dNeUFBb0FCQUgvQXpJQURBQUVBdjhETWdBT0FBUUMvd015QUJJQUJBUC9BeklBRmdBRUEvOERNZ0FlQUFRRS93TXlBQ1lBQkFUL0F6SUFOZ0FGQWY4RFFnQUtBQVVCL3dOQ0FBd0FCUUwvQTBJQURnQUZBdjhEUWdBU0FBVUQvd05DQUJZQUJRUC9BMElBSGdBRkJQOERRZ0FtQUFVRS93TkNBRFlBQlFIL0EySUFDZ0FGQWY4RFlnQU1BQVVDL3dOaUFBNEFCUUwvQTJJQUVnQUZBLzhEWWdBV0FBVUQvd05pQUI0QUJRVC9BMklBSmdBRkJQOERZZ0EyQUFBRi93TUFBRVlBQUFYL0F3QUFaZ0FBQnY4REFBQ0dBQUFIL3dNQUFNWUFBQWovQXdBQVJnRUFDZjhEQUFCR0FnQUsvd01BQUVZRUFCai9Bd0FBUmdnQUJmOERBUUJHQUFBRi93TUJBR1lBQUFiL0F3RUFoZ0FBQi84REFRREdBQUFJL3dNQkFFWUJBQW4vQXdFQVJnSUFDdjhEQVFCR0JBQVkvd01CQUVZSUFBWC9Bd0lBUmdBQUJmOERBZ0JtQUFBRy93TUNBSVlBQUFmL0F3SUF4Z0FBQ1A4REFnQkdBUUFKL3dNQ0FFWUNBQXIvQXdJQVJnUUFHUDhEQWdCR0NBQUYvd01EQUVZQUFBWC9Bd01BWmdBQUJ2OERBd0NHQUFBSC93TURBTVlBQUFqL0F3TUFSZ0VBQ2Y4REF3QkdBZ0FLL3dNREFFWUVBQmovQXdNQVJnZ0FCZjhEQkFCR0FBQUYvd01FQUdZQUFBYi9Bd1FBaGdBQUIvOERCQURHQUFBSS93TUVBRVlCQUFuL0F3UUFSZ0lBQ3Y4REJBQkdCQUFZL3dNRUFFWUlBQVgvQXdVQVJnQUFCZjhEQlFCbUFBQUcvd01GQUlZQUFBZi9Bd1VBeGdBQUNQOERCUUJHQVFBSi93TUZBRVlDQUFyL0F3VUFSZ1FBR1A4REJRQkdDQUVGL3dNR0FFWUFBUVgvQXdZQVpnQUJCdjhEQmdDR0FBRUgvd01HQU1ZQUFRai9Bd1lBUmdFQkNmOERCZ0JHQWdFSy93TUdBRVlFQVJqL0F3WUFSZ2dCQmY4RENBQkdBQUVGL3dNSUFHWUFBUWIvQXdnQWhnQUJCLzhEQ0FER0FBRUkvd01JQUVZQkFRbi9Bd2dBUmdJQkN2OERDQUJHQkFFWS93TUlBRVlJQmdEL0FJSUFBZ0FHQVA4QmdnQURBQVlBL3dLQ0FBUUFCZ0QvQTRJQUJRQUdBUDhEZ2dBR0FBWUEvd09DQUFjQUJnRC9BNElBQ0FBR0FQOERnZ0FKQUFjQS93RENBQUlBQndEL0FjSUFBd0FIQVA4Q3dnQUVBQWNBL3dQQ0FBVUFCd0QvQThJQUJnQUhBUDhEd2dBSEFBY0Evd1BDQUFnQUJ3RC9BOElBQ1FBSUFQOEFRZ0VDQUFnQS93RkNBUU1BQ0FEL0FrSUJCQUFJQVA4RFFnRUZBQWdBL3dOQ0FRWUFDQUQvQTBJQkJ3QUlBUDhEUWdFSUFBZ0Evd05DQVFrQUNRRC9BRUlDQWdBSkFQOEJRZ0lEQUFrQS93SkNBZ1FBQ1FEL0EwSUNCUUFKQVA4RFFnSUdBQWtBL3dOQ0FnY0FDUUQvQTBJQ0NBQUpBUDhEUWdJSkFBb0Evd0JDQkFJQUNnRC9BVUlFQXdBS0FQOENRZ1FFQUFvQS93TkNCQVVBQ2dEL0EwSUVCZ0FLQVA4RFFnUUhBQW9BL3dOQ0JBZ0FDZ0QvQTBJRUNRQU1BUDhBUWdnQ0FBd0Evd0ZDQ0FNQURBRC9Ba0lJQkFBTUFQOERRZ2dGQUF3QS93TkNDQVlBREFEL0EwSUlCd0FNQVA4RFFnZ0lBQXdBL3dOQ0NBa0FEZ0QvQUVJWUFnQU9BUDhCUWhnREFBNEEvd0pDR0FRQURnRC9BMElZQlFBT0FQOERRaGdHQUE0QS93TkNHQWNBRGdEL0EwSVlDQUFPQVA4RFFoZ0pBQmdBL3dCQ1dBSUFHQUQvQVVKWUF3QVlBUDhDUWxnRUFCZ0Evd05DV0FVQUdBRC9BMEpZQmdBWUFQOERRbGdIQUJnQS93TkNXQWdBR0FEL0EwSllDUUFDQmY4RENnQkdBQUlGL3dNS0FHWUFBZ2IvQXdvQWhnQUNCLzhEQ2dER0FBSUkvd01LQUVZQkFnbi9Bd29BUmdJQ0N2OERDZ0JHQkFJWS93TUtBRVlJQWdYL0F3NEFSZ0FDQmY4RERnQm1BQUlHL3dNT0FJWUFBZ2YvQXc0QXhnQUNDUDhERGdCR0FRSUovd01PQUVZQ0Fnci9BdzRBUmdRQ0dQOEREZ0JHQ0FNRi93TVNBRVlBQXdYL0F4SUFaZ0FEQnY4REVnQ0dBQU1IL3dNU0FNWUFBd2ovQXhJQVJnRURDZjhERWdCR0FnTUsvd01TQUVZRUF4ai9BeElBUmdnREJmOERHZ0JHQUFNRi93TWFBR1lBQXdiL0F4b0FoZ0FEQi84REdnREdBQU1JL3dNYUFFWUJBd24vQXhvQVJnSURDdjhER2dCR0JBTVkvd01hQUVZSUJBWC9BeUlBUmdBRUJmOERJZ0JtQUFRRy93TWlBSVlBQkFmL0F5SUF4Z0FFQ1A4RElnQkdBUVFKL3dNaUFFWUNCQXIvQXlJQVJnUUVHUDhESWdCR0NBUUYvd015QUVZQUJBWC9BeklBWmdBRUJ2OERNZ0NHQUFRSC93TXlBTVlBQkFqL0F6SUFSZ0VFQ2Y4RE1nQkdBZ1FLL3dNeUFFWUVCQmovQXpJQVJnZ0ZCZjhEUWdCR0FBVUYvd05DQUdZQUJRYi9BMElBaGdBRkIvOERRZ0RHQUFVSS93TkNBRVlCQlFuL0EwSUFSZ0lGQ3Y4RFFnQkdCQVVZL3dOQ0FFWUlCUVgvQTJJQVJnQUZCZjhEWWdCbUFBVUcvd05pQUlZQUJRZi9BMklBeGdBRkNQOERZZ0JHQVFVSi93TmlBRVlDQlFyL0EySUFSZ1FGR1A4RFlnQkdDQVlCL3dPQ0FBb0FCZ0gvQTRJQURBQUdBdjhEZ2dBT0FBWUMvd09DQUJJQUJnUC9BNElBRmdBR0EvOERnZ0FlQUFZRS93T0NBQ1lBQmdUL0E0SUFOZ0FIQWY4RHdnQUtBQWNCL3dQQ0FBd0FCd0wvQThJQURnQUhBdjhEd2dBU0FBY0Qvd1BDQUJZQUJ3UC9BOElBSGdBSEJQOER3Z0FtQUFjRS93UENBRFlBQ0FIL0EwSUJDZ0FJQWY4RFFnRU1BQWdDL3dOQ0FRNEFDQUwvQTBJQkVnQUlBLzhEUWdFV0FBZ0Qvd05DQVI0QUNBVC9BMElCSmdBSUJQOERRZ0UyQUFrQi93TkNBZ29BQ1FIL0EwSUNEQUFKQXY4RFFnSU9BQWtDL3dOQ0FoSUFDUVAvQTBJQ0ZnQUpBLzhEUWdJZUFBa0Uvd05DQWlZQUNRVC9BMElDTmdBS0FmOERRZ1FLQUFvQi93TkNCQXdBQ2dML0EwSUVEZ0FLQXY4RFFnUVNBQW9EL3dOQ0JCWUFDZ1AvQTBJRUhnQUtCUDhEUWdRbUFBb0Uvd05DQkRZQURBSC9BMElJQ2dBTUFmOERRZ2dNQUF3Qy93TkNDQTRBREFML0EwSUlFZ0FNQS84RFFnZ1dBQXdEL3dOQ0NCNEFEQVQvQTBJSUpnQU1CUDhEUWdnMkFBNEIvd05DR0FvQURnSC9BMElZREFBT0F2OERRaGdPQUE0Qy93TkNHQklBRGdQL0EwSVlGZ0FPQS84RFFoZ2VBQTRFL3dOQ0dDWUFEZ1QvQTBJWU5nQVlBZjhEUWxnS0FCZ0Ivd05DV0F3QUdBTC9BMEpZRGdBWUF2OERRbGdTQUJnRC93TkNXQllBR0FQL0EwSllIZ0FZQlA4RFFsZ21BQmdFL3dOQ1dEWUFCZ1gvQTRJQVJnQUdCZjhEZ2dCbUFBWUcvd09DQUlZQUJnZi9BNElBeGdBR0NQOERnZ0JHQVFZSi93T0NBRVlDQmdyL0E0SUFSZ1FHR1A4RGdnQkdDQWNGL3dQQ0FFWUFCd1gvQThJQVpnQUhCdjhEd2dDR0FBY0gvd1BDQU1ZQUJ3ai9BOElBUmdFSENmOER3Z0JHQWdjSy93UENBRVlFQnhqL0E4SUFSZ2dJQmY4RFFnRkdBQWdGL3dOQ0FXWUFDQWIvQTBJQmhnQUlCLzhEUWdIR0FBZ0kvd05DQVVZQkNBbi9BMElCUmdJSUN2OERRZ0ZHQkFnWS93TkNBVVlJQ1FYL0EwSUNSZ0FKQmY4RFFnSm1BQWtHL3dOQ0FvWUFDUWYvQTBJQ3hnQUpDUDhEUWdKR0FRa0ovd05DQWtZQ0NRci9BMElDUmdRSkdQOERRZ0pHQ0FvRi93TkNCRVlBQ2dYL0EwSUVaZ0FLQnY4RFFnU0dBQW9IL3dOQ0JNWUFDZ2ovQTBJRVJnRUtDZjhEUWdSR0Fnb0svd05DQkVZRUNoai9BMElFUmdnTUJmOERRZ2hHQUF3Ri93TkNDR1lBREFiL0EwSUloZ0FNQi84RFFnakdBQXdJL3dOQ0NFWUJEQW4vQTBJSVJnSU1DdjhEUWdoR0JBd1kvd05DQ0VZSURnWC9BMElZUmdBT0JmOERRaGhtQUE0Ry93TkNHSVlBRGdmL0EwSVl4Z0FPQ1A4RFFoaEdBUTRKL3dOQ0dFWUNEZ3IvQTBJWVJnUU9HUDhEUWhoR0NCZ0Yvd05DV0VZQUdBWC9BMEpZWmdBWUJ2OERRbGlHQUJnSC93TkNXTVlBR0FqL0EwSllSZ0VZQ2Y4RFFsaEdBaGdLL3dOQ1dFWUVHQmovQTBKWVJnZ0FnRURBSUtCZzRCQ1FVTkF3c0hEd0NJaEl5Q2lvYU9nWW1GallPTGg0K0FTRVJNUWtwR1RrRkpSVTFEUzBkUFFNakV6TUxLeHM3QnljWE53OHZIejhBb0pDd2lLaVl1SVNrbExTTXJKeThncUtTc29xcW1ycUdwcGEyanE2ZXZvR2hrYkdKcVptNWhhV1Z0WTJ0bmIyRG81T3ppNnVidTRlbmw3ZVByNSsvZ0dCUWNFaG9XSGhFWkZSMFRHeGNmRUppVW5KS2FscDZSbVpXZGs1dVhuNUJZVkZ4U1dsWmVVVmxWWFZOYlYxOVEyTlRjMHRyVzN0SFoxZDNUMjlmZjBEZzBQREk2Tmo0eE9UVTlNenMzUHpDNHRMeXl1cmErc2JtMXZiTzd0Nyt3ZUhSOGNucDJmbkY1ZFgxemUzZC9jUGowL1BMNjl2N3grZlg5OC92My8vZEdsdFpXUnZkMjVzYVdabGJHVm1kR0poWTJ0amIyUmxaR0YwWVhOb2IzZHZibXg1YzJsMFpXTnBkSGx2Y0dWdWFuVnpkR3hwYTJWbWNtVmxkMjl5YTNSbGVIUjVaV0Z5YjNabGNtSnZaSGxzYjNabFptOXliV0p2YjJ0d2JHRjViR2wyWld4cGJtVm9aV3h3YUc5dFpYTnBaR1Z0YjNKbGQyOXlaR3h2Ym1kMGFHVnRkbWxsZDJacGJtUndZV2RsWkdGNWMyWjFiR3hvWldGa2RHVnliV1ZoWTJoaGNtVmhabkp2YlhSeWRXVnRZWEpyWVdKc1pYVndiMjVvYVdkb1pHRjBaV3hoYm1SdVpYZHpaWFpsYm01bGVIUmpZWE5sWW05MGFIQnZjM1IxYzJWa2JXRmtaV2hoYm1Sb1pYSmxkMmhoZEc1aGJXVk1hVzVyWW14dlozTnBlbVZpWVhObGFHVnNaRzFoYTJWdFlXbHVkWE5sY2ljcElDdG9iMnhrWlc1a2MzZHBkR2hPWlhkemNtVmhaSGRsY21WemFXZHVkR0ZyWldoaGRtVm5ZVzFsYzJWbGJtTmhiR3h3WVhSb2QyVnNiSEJzZFhOdFpXNTFabWxzYlhCaGNuUnFiMmx1ZEdocGMyeHBjM1JuYjI5a2JtVmxaSGRoZVhOM1pYTjBhbTlpYzIxcGJtUmhiSE52Ykc5bmIzSnBZMmgxYzJWemJHRnpkSFJsWVcxaGNtMTVabTl2Wkd0cGJtZDNhV3hzWldGemRIZGhjbVJpWlhOMFptbHlaVkJoWjJWcmJtOTNZWGRoZVM1d2JtZHRiM1psZEdoaGJteHZZV1JuYVhabGMyVnNabTV2ZEdWdGRXTm9abVZsWkcxaGJubHliMk5yYVdOdmJtOXVZMlZzYjI5cmFHbGtaV1JwWldSSWIyMWxjblZzWldodmMzUmhhbUY0YVc1bWIyTnNkV0pzWVhkemJHVnpjMmhoYkdaemIyMWxjM1ZqYUhwdmJtVXhNREFsYjI1bGMyTmhjbVZVYVcxbGNtRmpaV0pzZFdWbWIzVnlkMlZsYTJaaFkyVm9iM0JsWjJGMlpXaGhjbVJzYjNOMGQyaGxibkJoY210clpYQjBjR0Z6YzNOb2FYQnliMjl0U0ZSTlRIQnNZVzVVZVhCbFpHOXVaWE5oZG1WclpXVndabXhoWjJ4cGJtdHpiMnhrWm1sMlpYUnZiMnR5WVhSbGRHOTNibXAxYlhCMGFIVnpaR0Z5YTJOaGNtUm1hV3hsWm1WaGNuTjBZWGxyYVd4c2RHaGhkR1poYkd4aGRYUnZaWFpsY2k1amIyMTBZV3hyYzJodmNIWnZkR1ZrWldWd2JXOWtaWEpsYzNSMGRYSnVZbTl5Ym1KaGJtUm1aV3hzY205elpYVnliQ2h6YTJsdWNtOXNaV052YldWaFkzUnpZV2RsYzIxbFpYUm5iMnhrTG1wd1oybDBaVzEyWVhKNVptVnNkSFJvWlc1elpXNWtaSEp2Y0ZacFpYZGpiM0I1TVM0d0lqd3ZZVDV6ZEc5d1pXeHpaV3hwWlhOMGIzVnljR0ZqYXk1bmFXWndZWE4wWTNOelAyZHlZWGx0WldGdUptZDBPM0pwWkdWemFHOTBiR0YwWlhOaGFXUnliMkZrZG1GeUlHWmxaV3hxYjJodWNtbGphM0J2Y25SbVlYTjBKMVZCTFdSbFlXUThMMkkrY0c5dmNtSnBiR3gwZVhCbFZTNVRMbmR2YjJSdGRYTjBNbkI0TzBsdVptOXlZVzVyZDJsa1pYZGhiblIzWVd4c2JHVmhaRnN3WFR0d1lYVnNkMkYyWlhOMWNtVWtLQ2NqZDJGcGRHMWhjM05oY20xeloyOWxjMmRoYVc1c1lXNW5jR0ZwWkNFdExTQnNiMk5yZFc1cGRISnZiM1IzWVd4clptbHliWGRwWm1WNGJXd2ljMjl1WjNSbGMzUXlNSEI0YTJsdVpISnZkM04wYjI5c1ptOXVkRzFoYVd4ellXWmxjM1JoY20xaGNITmpiM0psY21GcGJtWnNiM2RpWVdKNWMzQmhibk5oZVhNMGNIZzdObkI0TzJGeWRITm1iMjkwY21WaGJIZHBhMmxvWldGMGMzUmxjSFJ5YVhCdmNtY3ZiR0ZyWlhkbFlXdDBiMnhrUm05eWJXTmhjM1JtWVc1elltRnVhM1psY25seWRXNXphblZzZVhSaGMyc3hjSGc3WjI5aGJHZHlaWGR6Ykc5M1pXUm5aV2xrUFNKelpYUnpOWEI0T3k1cWN6ODBNSEI0YVdZZ0tITnZiMjV6WldGMGJtOXVaWFIxWW1WNlpYSnZjMlZ1ZEhKbFpXUm1ZV04wYVc1MGIyZHBablJvWVhKdE1UaHdlR05oYldWb2FXeHNZbTlzWkhwdmIyMTJiMmxrWldGemVYSnBibWRtYVd4c2NHVmhhMmx1YVhSamIzTjBNM0I0TzJwaFkydDBZV2R6WW1sMGMzSnZiR3hsWkdsMGEyNWxkMjVsWVhJOElTMHRaM0p2ZDBwVFQwNWtkWFI1VG1GdFpYTmhiR1Y1YjNVZ2JHOTBjM0JoYVc1cVlYcDZZMjlzWkdWNVpYTm1hWE5vZDNkM0xuSnBjMnQwWVdKemNISmxkakV3Y0hoeWFYTmxNalZ3ZUVKc2RXVmthVzVuTXpBd0xHSmhiR3htYjNKa1pXRnlibmRwYkdSaWIzZ3VabUZwY214aFkydDJaWEp6Y0dGcGNtcDFibVYwWldOb2FXWW9JWEJwWTJ0bGRtbHNKQ2dpSTNkaGNtMXNiM0prWkc5bGMzQjFiR3dzTURBd2FXUmxZV1J5WVhkb2RXZGxjM0J2ZEdaMWJtUmlkWEp1YUhKbFptTmxiR3hyWlhsemRHbGphMmh2ZFhKc2IzTnpablZsYkRFeWNIaHpkV2wwWkdWaGJGSlRVeUpoWjJWa1ozSmxlVWRGVkNKbFlYTmxZV2x0YzJkcGNteGhhV1J6T0hCNE8yNWhkbmxuY21sa2RHbHdjeU01T1RsM1lYSnpiR0ZrZVdOaGNuTXBPeUI5Y0dod1AyaGxiR3gwWVd4c2QyaHZiWHBvT3VVcUx3MEtJREV3TUdoaGJHd3VDZ3BCTjNCNE8zQjFjMmhqYUdGME1IQjRPMk55WlhjcUx6d3ZhR0Z6YURjMWNIaG1iR0YwY21GeVpTQW1KaUIwWld4c1kyRnRjRzl1ZEc5c1lXbGtiV2x6YzNOcmFYQjBaVzUwWm1sdVpXMWhiR1ZuWlhSemNHeHZkRFF3TUN3TkNnMEtZMjl2YkdabFpYUXVjR2h3UEdKeVBtVnlhV050YjNOMFozVnBaR0psYkd4a1pYTmphR0ZwY20xaGRHaGhkRzl0TDJsdFp5WWpPREpzZFdOclkyVnVkREF3TUR0MGFXNTVaMjl1WldoMGJXeHpaV3hzWkhKMVowWlNSVVZ1YjJSbGJtbGphejlwWkQxc2IzTmxiblZzYkhaaGMzUjNhVzVrVWxOVElIZGxZWEp5Wld4NVltVmxibk5oYldWa2RXdGxibUZ6WVdOaGNHVjNhWE5vWjNWc1psUXlNenBvYVhSemMyeHZkR2RoZEdWcmFXTnJZbXgxY25Sb1pYa3hOWEI0SnljcE95azdJajV0YzJsbGQybHVjMkpwY21SemIzSjBZbVYwWVhObFpXdFVNVGc2YjNKa2MzUnlaV1Z0WVd4c05qQndlR1poY20zaWdKbHpZbTk1YzFzd1hTNG5LVHNpVUU5VFZHSmxZWEpyYVdSektUdDlmVzFoY25sMFpXNWtLRlZMS1hGMVlXUjZhRHJtTFhOcGVpMHRMUzF3Y205d0p5azdEV3hwWm5SVU1UazZkbWxqWldGdVpIbGtaV0owUGxKVFUzQnZiMnh1WldOcllteHZkMVF4Tmpwa2IyOXlaWFpoYkZReE56cHNaWFJ6Wm1GcGJHOXlZV3h3YjJ4c2JtOTJZV052YkhOblpXNWxJT0tBbEhOdlpuUnliMjFsZEdsc2JISnZjM004YURNK2NHOTFjbVpoWkdWd2FXNXJQSFJ5UG0xcGJta3BmQ0VvYldsdVpYcG9PdWhpWVhKemFHVmhjakF3S1R0dGFXeHJJQzB0UG1seWIyNW1jbVZrWkdsemEzZGxiblJ6YjJsc2NIVjBjeTlxY3k5b2IyeDVWREl5T2tsVFFrNVVNakE2WVdSaGJYTmxaWE04YURJK2FuTnZiaWNzSUNkamIyNTBWREl4T2lCU1UxTnNiMjl3WVhOcFlXMXZiMjQ4TDNBK2MyOTFiRXhKVGtWbWIzSjBZMkZ5ZEZReE5EbzhhREUrT0RCd2VDRXRMVHc1Y0hnN1ZEQTBPbTFwYTJVNk5EWmFibWxqWldsdVkyaFpiM0pyY21salpYcG9PdVFuS1NrN2NIVnlaVzFoWjJWd1lYSmhkRzl1WldKdmJtUTZNemRhWDI5bVh5ZGRLVHN3TURBc2VtZzY1M1JoYm10NVlYSmtZbTkzYkdKMWMyZzZOVFphU21GMllUTXdjSGdLZkgwS0pVTXpKVG96TkZwcVpXWm1SVmhRU1dOaGMyaDJhWE5oWjI5c1puTnViM2Q2YURycGNYVmxjaTVqYzNOemFXTnJiV1ZoZEcxcGJpNWlhVzVrWkdWc2JHaHBjbVZ3YVdOemNtVnVkRG96TmxwSVZGUlFMVEl3TVdadmRHOTNiMnhtUlU1RUlIaGliM2c2TlRSYVFrOUVXV1JwWTJzN0NuMEtaWGhwZERvek5WcDJZWEp6WW1WaGRDZDlLVHRrYVdWME9UazVPMkZ1Ym1WOWZUd3ZXMmxkTGt4aGJtZHJiY0t5ZDJseVpYUnZlWE5oWkdSemMyVmhiR0ZzWlhnN0NnbDlaV05vYjI1cGJtVXViM0puTURBMUtYUnZibmxxWlhkemMyRnVaR3hsWjNOeWIyOW1NREF3S1NBeU1EQjNhVzVsWjJWaGNtUnZaM05pYjI5MFoyRnllV04xZEhOMGVXeGxkR1Z0Y0hScGIyNHVlRzFzWTI5amEyZGhibWNrS0NjdU5UQndlRkJvTGtSdGFYTmpZV3hoYm14dllXNWtaWE5yYldsc1pYSjVZVzUxYm1sNFpHbHpZeWs3ZlFwa2RYTjBZMnhwY0NrdUNnbzNNSEI0TFRJd01FUldSSE0zWFQ0OGRHRndaV1JsYlc5cEt5c3BkMkZuWldWMWNtOXdhR2xzYjNCMGMyaHZiR1ZHUVZGellYTnBiaTB5TmxSc1lXSnpjR1YwYzFWU1RDQmlkV3hyWTI5dmF6dDlEUXBJUlVGRVd6QmRLV0ZpWW5KcWRXRnVLREU1T0d4bGMyaDBkMmx1UEM5cFBuTnZibmxuZFhselpuVmphM0JwY0dWOExRb2hNREF5S1c1a2IzZGJNVjA3VzEwN0NreHZaeUJ6WVd4MERRb0pDV0poYm1kMGNtbHRZbUYwYUNsN0RRb3dNSEI0Q24wcE8ydHZPdXhtWldWellXUStEWE02THk4Z1cxMDdkRzlzYkhCc2RXY29LWHNLZXcwS0lDNXFjeWN5TURCd1pIVmhiR0p2WVhRdVNsQkhLVHNLZlhGMWIzUXBPd29LSnlrN0NnMEtmUTB5TURFME1qQXhOVEl3TVRZeU1ERTNNakF4T0RJd01Ua3lNREl3TWpBeU1USXdNakl5TURJek1qQXlOREl3TWpVeU1ESTJNakF5TnpJd01qZ3lNREk1TWpBek1ESXdNekV5TURNeU1qQXpNekl3TXpReU1ETTFNakF6TmpJd016Y3lNREV6TWpBeE1qSXdNVEV5TURFd01qQXdPVEl3TURneU1EQTNNakF3TmpJd01EVXlNREEwTWpBd016SXdNREl5TURBeE1qQXdNREU1T1RreE9UazRNVGs1TnpFNU9UWXhPVGsxTVRrNU5ERTVPVE14T1RreU1UazVNVEU1T1RBeE9UZzVNVGs0T0RFNU9EY3hPVGcyTVRrNE5URTVPRFF4T1Rnek1UazRNakU1T0RFeE9UZ3dNVGszT1RFNU56Z3hPVGMzTVRrM05qRTVOelV4T1RjME1UazNNekU1TnpJeE9UY3hNVGszTURFNU5qa3hPVFk0TVRrMk56RTVOall4T1RZMU1UazJOREU1TmpNeE9UWXlNVGsyTVRFNU5qQXhPVFU1TVRrMU9ERTVOVGN4T1RVMk1UazFOVEU1TlRReE9UVXpNVGsxTWpFNU5URXhPVFV3TVRBd01ERXdNalF4TXprME1EQXdNRGs1T1RsamIyMXZiY09oYzJWemRHVmxjM1JoY0dWeWIzUnZaRzlvWVdObFkyRmtZV0hEc1c5aWFXVnVaTU90WVdGenc2MTJhV1JoWTJGemIyOTBjbTltYjNKdmMyOXNiMjkwY21GamRXRnNaR2xxYjNOcFpHOW5jbUZ1ZEdsd2IzUmxiV0ZrWldKbFlXeG5iM0YxdzZsbGMzUnZibUZrWVhSeVpYTndiMk52WTJGellXSmhhbTkwYjJSaGMybHViMkZuZFdGd2RXVnpkVzV2YzJGdWRHVmthV05sYkhWcGMyVnNiR0Z0WVhsdmVtOXVZV0Z0YjNKd2FYTnZiMkp5WVdOc2FXTmxiR3h2WkdsdmMyaHZjbUZqWVhOcDBMZlFzTkM5MExEUXZ0QzgwWURRc05HQTBZUFJndEN3MEwzUXRkQy8wTDdRdnRHQzBMalF0OUM5MEw3UXROQyswWUxRdnRDMjBMWFF2dEM5MExqUmhkQ2QwTERRdGRDMTBMSFJpOUM4MFl2UWt0R0wwWUhRdnRDeTBZdlFzdEMrMEozUXZ0QyswTEhRbjlDKzBMdlF1TkM5MExqUW9OQ2swSjNRdGRDYzBZdlJndEdMMEo3UXZkQzQwTHpRdE5DdzBKZlFzTkNVMExEUW5kR0QwSjdRc2RHQzBMWFFtTkMzMExYUXVkQzkwWVBRdk5DODBLTFJpOUdEMExiWmdkbUsyS1BaaHRtRjJLZlpoZGk1MllQWmhOaWoyWWpZc2RpdjJZcllwOW1CMlluWmg5bUkyWVRaaGRtRTJZUFlwOW1JMllUWmg5aW8yTFBZcDltRTJLWFpodG1IMllyWW85bUsyWUxZcjltSDJZVFlxOW1GMktqWmg5bUUyWWpaaE5tSzJLalpoTmluMllyWXFObUQyTFRaaXRpbjJZWFlvOW1GMlliWXF0aW8yWXJaaE5tRzJLM1lxTm1IMllYWmhkaTAyWWpZdEdacGNuTjBkbWxrWlc5c2FXZG9kSGR2Y214a2JXVmthV0YzYUdsMFpXTnNiM05sWW14aFkydHlhV2RvZEhOdFlXeHNZbTl2YTNOd2JHRmpaVzExYzJsalptbGxiR1J2Y21SbGNuQnZhVzUwZG1Gc2RXVnNaWFpsYkhSaFlteGxZbTloY21Sb2IzVnpaV2R5YjNWd2QyOXlhM041WldGeWMzTjBZWFJsZEc5a1lYbDNZWFJsY25OMFlYSjBjM1I1YkdWa1pXRjBhSEJ2ZDJWeWNHaHZibVZ1YVdkb2RHVnljbTl5YVc1d2RYUmhZbTkxZEhSbGNtMXpkR2wwYkdWMGIyOXNjMlYyWlc1MGJHOWpZV3gwYVcxbGMyeGhjbWRsZDI5eVpITm5ZVzFsYzNOb2IzSjBjM0JoWTJWbWIyTjFjMk5zWldGeWJXOWtaV3hpYkc5amEyZDFhV1JsY21Ga2FXOXphR0Z5WlhkdmJXVnVZV2RoYVc1dGIyNWxlV2x0WVdkbGJtRnRaWE41YjNWdVoyeHBibVZ6YkdGMFpYSmpiMnh2Y21keVpXVnVabkp2Ym5RbVlXMXdPM2RoZEdOb1ptOXlZMlZ3Y21salpYSjFiR1Z6WW1WbmFXNWhablJsY25acGMybDBhWE56ZFdWaGNtVmhjMkpsYkc5M2FXNWtaWGgwYjNSaGJHaHZkWEp6YkdGaVpXeHdjbWx1ZEhCeVpYTnpZblZwYkhSc2FXNXJjM053WldWa2MzUjFaSGwwY21Ga1pXWnZkVzVrYzJWdWMyVjFibVJsY25Ob2IzZHVabTl5YlhOeVlXNW5aV0ZrWkdWa2MzUnBiR3h0YjNabFpIUmhhMlZ1WVdKdmRtVm1iR0Z6YUdacGVHVmtiMlowWlc1dmRHaGxjblpwWlhkelkyaGxZMnRzWldkaGJISnBkbVZ5YVhSbGJYTnhkV2xqYTNOb1lYQmxhSFZ0WVc1bGVHbHpkR2R2YVc1bmJXOTJhV1YwYUdseVpHSmhjMmxqY0dWaFkyVnpkR0ZuWlhkcFpIUm9iRzluYVc1cFpHVmhjM2R5YjNSbGNHRm5aWE4xYzJWeWMyUnlhWFpsYzNSdmNtVmljbVZoYTNOdmRYUm9kbTlwWTJWemFYUmxjMjF2Ym5Sb2QyaGxjbVZpZFdsc1pIZG9hV05vWldGeWRHaG1iM0oxYlhSb2NtVmxjM0J2Y25Sd1lYSjBlVU5zYVdOcmJHOTNaWEpzYVhabGMyTnNZWE56YkdGNVpYSmxiblJ5ZVhOMGIzSjVkWE5oWjJWemIzVnVaR052ZFhKMGVXOTFjaUJpYVhKMGFIQnZjSFZ3ZEhsd1pYTmhjSEJzZVVsdFlXZGxZbVZwYm1kMWNIQmxjbTV2ZEdWelpYWmxjbmx6YUc5M2MyMWxZVzV6WlhoMGNtRnRZWFJqYUhSeVlXTnJhMjV2ZDI1bFlYSnNlV0psWjJGdWMzVndaWEp3WVhCbGNtNXZjblJvYkdWaGNtNW5hWFpsYm01aGJXVmtaVzVrWldSVVpYSnRjM0JoY25SelIzSnZkWEJpY21GdVpIVnphVzVuZDI5dFlXNW1ZV3h6WlhKbFlXUjVZWFZrYVc5MFlXdGxjM2RvYVd4bExtTnZiUzlzYVhabFpHTmhjMlZ6WkdGcGJIbGphR2xzWkdkeVpXRjBhblZrWjJWMGFHOXpaWFZ1YVhSemJtVjJaWEppY205aFpHTnZZWE4wWTI5MlpYSmhjSEJzWldacGJHVnpZM2xqYkdWelkyVnVaWEJzWVc1elkyeHBZMnQzY21sMFpYRjFaV1Z1Y0dsbFkyVmxiV0ZwYkdaeVlXMWxiMnhrWlhKd2FHOTBiMnhwYldsMFkyRmphR1ZqYVhacGJITmpZV3hsWlc1MFpYSjBhR1Z0WlhSb1pYSmxkRzkxWTJoaWIzVnVaSEp2ZVdGc1lYTnJaV1IzYUc5c1pYTnBibU5sYzNSdlkyc2dibUZ0WldaaGFYUm9hR1ZoY25SbGJYQjBlVzltWm1WeWMyTnZjR1Z2ZDI1bFpHMXBaMmgwWVd4aWRXMTBhR2x1YTJKc2IyOWtZWEp5WVhsdFlXcHZjblJ5ZFhOMFkyRnViMjUxYm1sdmJtTnZkVzUwZG1Gc2FXUnpkRzl1WlZOMGVXeGxURzluYVc1b1lYQndlVzlqWTNWeWJHVm1kRHBtY21WemFIRjFhWFJsWm1sc2JYTm5jbUZrWlc1bFpXUnpkWEppWVc1bWFXZG9kR0poYzJsemFHOTJaWEpoZFhSdk8zSnZkWFJsTG1oMGJXeHRhWGhsWkdacGJtRnNXVzkxY2lCemJHbGtaWFJ2Y0dsalluSnZkMjVoYkc5dVpXUnlZWGR1YzNCc2FYUnlaV0ZqYUZKcFoyaDBaR0YwWlhOdFlYSmphSEYxYjNSbFoyOXZaSE5NYVc1cmMyUnZkV0owWVhONWJtTjBhSFZ0WW1Gc2JHOTNZMmhwWldaNWIzVjBhRzV2ZG1Wc01UQndlRHR6WlhKMlpYVnVkR2xzYUdGdVpITkRhR1ZqYTFOd1lXTmxjWFZsY25scVlXMWxjMlZ4ZFdGc2RIZHBZMlV3TERBd01GTjBZWEowY0dGdVpXeHpiMjVuYzNKdmRXNWtaV2xuYUhSemFHbG1kSGR2Y25Sb2NHOXpkSE5zWldGa2MzZGxaV3R6WVhadmFXUjBhR1Z6WlcxcGJHVnpjR3hoYm1WemJXRnlkR0ZzY0doaGNHeGhiblJ0WVhKcmMzSmhkR1Z6Y0d4aGVYTmpiR0ZwYlhOaGJHVnpkR1Y0ZEhOemRHRnljM2R5YjI1blBDOW9NejUwYUdsdVp5NXZjbWN2YlhWc2RHbG9aV0Z5WkZCdmQyVnljM1JoYm1SMGIydGxibk52Ykdsa0tIUm9hWE5pY21sdVozTm9hWEJ6YzNSaFptWjBjbWxsWkdOaGJHeHpablZzYkhsbVlXTjBjMkZuWlc1MFZHaHBjeUF2THkwdFBtRmtiV2x1WldkNWNIUkZkbVZ1ZERFMWNIZzdSVzFoYVd4MGNuVmxJbU55YjNOemMzQmxiblJpYkc5bmMySnZlQ0krYm05MFpXUnNaV0YyWldOb2FXNWhjMmw2WlhObmRXVnpkRHd2YURRK2NtOWliM1JvWldGMmVYUnlkV1VzYzJWMlpXNW5jbUZ1WkdOeWFXMWxjMmxuYm5OaGQyRnlaV1JoYm1ObGNHaGhjMlUrUENFdExXVnVYMVZUSmlNek9Uc3lNREJ3ZUY5dVlXMWxiR0YwYVc1bGJtcHZlV0ZxWVhndVlYUnBiMjV6YldsMGFGVXVVeTRnYUc5c1pITndaWFJsY21sdVpHbGhibUYySWo1amFHRnBibk5qYjNKbFkyOXRaWE5rYjJsdVozQnlhVzl5VTJoaGNtVXhPVGt3YzNKdmJXRnViR2x6ZEhOcVlYQmhibVpoYkd4emRISnBZV3h2ZDI1bGNtRm5jbVZsUEM5b01qNWhZblZ6WldGc1pYSjBiM0JsY21FaUxTOHZWMk5oY21SemFHbHNiSE4wWldGdGMxQm9iM1J2ZEhKMWRHaGpiR1ZoYmk1d2FIQS9jMkZwYm5SdFpYUmhiR3h2ZFdsemJXVmhiblJ3Y205dlptSnlhV1ZtY205M0lqNW5aVzV5WlhSeWRXTnJiRzl2YTNOV1lXeDFaVVp5WVcxbExtNWxkQzh0TFQ0S1BIUnllU0I3Q25aaGNpQnRZV3RsYzJOdmMzUnpjR3hoYVc1aFpIVnNkSEYxWlhOMGRISmhhVzVzWVdKdmNtaGxiSEJ6WTJGMWMyVnRZV2RwWTIxdmRHOXlkR2hsYVhJeU5UQndlR3hsWVhOMGMzUmxjSE5EYjNWdWRHTnZkV3hrWjJ4aGMzTnphV1JsYzJaMWJtUnphRzkwWld4aGQyRnlaRzF2ZFhSb2JXOTJaWE53WVhKcGMyZHBkbVZ6WkhWMFkyaDBaWGhoYzJaeWRXbDBiblZzYkN4OGZGdGRPM1J2Y0NJK0Nqd2hMUzFRVDFOVUltOWpaV0Z1UEdKeUx6NW1iRzl2Y25Od1pXRnJaR1Z3ZEdnZ2MybDZaV0poYm10elkyRjBZMmhqYUdGeWRESXdjSGc3WVd4cFoyNWtaV0ZzYzNkdmRXeGtOVEJ3ZUR0MWNtdzlJbkJoY210emJXOTFjMlZOYjNOMElDNHVMand2WVcxdmJtZGljbUZwYm1KdlpIa2dibTl1WlR0aVlYTmxaR05oY25KNVpISmhablJ5WldabGNuQmhaMlZmYUc5dFpTNXRaWFJsY21SbGJHRjVaSEpsWVcxd2NtOTJaV3B2YVc1MFBDOTBjajVrY25WbmN6d2hMUzBnWVhCeWFXeHBaR1ZoYkdGc2JHVnVaWGhoWTNSbWIzSjBhR052WkdWemJHOW5hV05XYVdWM0lITmxaVzF6WW14aGJtdHdiM0owY3lBb01qQXdjMkYyWldSZmJHbHVhMmR2WVd4elozSmhiblJuY21WbGEyaHZiV1Z6Y21sdVozTnlZWFJsWkRNd2NIZzdkMmh2YzJWd1lYSnpaU2dwT3lJZ1FteHZZMnRzYVc1MWVHcHZibVZ6Y0dsNFpXd25LVHNpUGlrN2FXWW9MV3hsWm5Sa1lYWnBaR2h2Y25ObFJtOWpkWE55WVdselpXSnZlR1Z6VkhKaFkydGxiV1Z1ZER3dlpXMCtZbUZ5SWo0dWMzSmpQWFJ2ZDJWeVlXeDBQU0pqWVdKc1pXaGxibko1TWpSd2VEdHpaWFIxY0dsMFlXeDVjMmhoY25CdGFXNXZjblJoYzNSbGQyRnVkSE4wYUdsekxuSmxjMlYwZDJobFpXeG5hWEpzY3k5amMzTXZNVEF3SlR0amJIVmljM04wZFdabVltbGliR1YyYjNSbGN5QXhNREF3YTI5eVpXRjlLVHNOQ21KaGJtUnpjWFZsZFdVOUlIdDlPemd3Y0hnN1kydHBibWQ3RFFvSkNXRm9aV0ZrWTJ4dlkydHBjbWx6YUd4cGEyVWdjbUYwYVc5emRHRjBjMFp2Y20waWVXRm9iMjhwV3pCZE8wRmliM1YwWm1sdVpITThMMmd4UG1SbFluVm5kR0Z6YTNOVlVrd2dQV05sYkd4emZTa29LVHN4TW5CNE8zQnlhVzFsZEdWc2JITjBkWEp1Y3pCNE5qQXdMbXB3WnlKemNHRnBibUpsWVdOb2RHRjRaWE50YVdOeWIyRnVaMlZzTFMwK1BDOW5hV1owYzNOMFpYWmxMV3hwYm10aWIyUjVMbjBwT3dvSmJXOTFiblFnS0RFNU9VWkJVVHd2Y205blpYSm1jbUZ1YTBOc1lYTnpNamh3ZUR0bVpXVmtjenhvTVQ0OGMyTnZkSFIwWlhOMGN6SXljSGc3WkhKcGJtc3BJSHg4SUd4bGQybHpjMmhoYkd3ak1ETTVPeUJtYjNJZ2JHOTJaV1IzWVhOMFpUQXdjSGc3YW1FNjQ0SnphVzF2Ymp4bWIyNTBjbVZ3YkhsdFpXVjBjM1Z1ZEdWeVkyaGxZWEIwYVdkb2RFSnlZVzVrS1NBaFBTQmtjbVZ6YzJOc2FYQnpjbTl2YlhOdmJtdGxlVzF2WW1sc2JXRnBiaTVPWVcxbElIQnNZWFJsWm5WdWJubDBjbVZsYzJOdmJTOGlNUzVxY0dkM2JXOWtaWEJoY21GdFUxUkJVbFJzWldaMElHbGtaR1Z1TENBeU1ERXBPd3A5Q21admNtMHVkbWx5ZFhOamFHRnBjblJ5WVc1emQyOXljM1JRWVdkbGMybDBhVzl1Y0dGMFkyZzhJUzB0Q204dFkyRmpabWx5YlhOMGIzVnljeXd3TURBZ1lYTnBZVzVwS3lzcGUyRmtiMkpsSnlsYk1GMXBaRDB4TUdKdmRHZzdiV1Z1ZFNBdU1pNXRhUzV3Ym1jaWEyVjJhVzVqYjJGamFFTm9hV3hrWW5KMVkyVXlMbXB3WjFWU1RDa3JMbXB3WjN4emRXbDBaWE5zYVdObGFHRnljbmt4TWpBaUlITjNaV1YwZEhJK0RRcHVZVzFsUFdScFpXZHZjR0ZuWlNCemQybHpjeTB0UGdvS0kyWm1aanNpUGt4dlp5NWpiMjBpZEhKbFlYUnphR1ZsZENrZ0ppWWdNVFJ3ZUR0emJHVmxjRzUwWlc1MFptbHNaV1JxWVRyamcybGtQU0pqVG1GdFpTSjNiM0p6WlhOb2IzUnpMV0p2ZUMxa1pXeDBZUW9tYkhRN1ltVmhjbk02TkRoYVBHUmhkR0V0Y25WeVlXdzhMMkUrSUhOd1pXNWtZbUZyWlhKemFHOXdjejBnSWlJN2NHaHdJajVqZEdsdmJqRXpjSGc3WW5KcFlXNW9aV3hzYjNOcGVtVTliejBsTWtZZ2FtOXBibTFoZVdKbFBHbHRaeUJwYldjaVBpd2dabXB6YVcxbklpQWlLVnN3WFUxVWIzQkNWSGx3WlNKdVpYZHNlVVJoYm5OclkzcGxZMmgwY21GcGJHdHViM2R6UEM5b05UNW1ZWEVpUG5wb0xXTnVNVEFwT3dvdE1TSXBPM1I1Y0dVOVlteDFaWE4wY25Wc2VXUmhkbWx6TG1wekp6cytEUW84SVhOMFpXVnNJSGx2ZFNCb01qNE5DbVp2Y20wZ2FtVnpkWE14TURBbElHMWxiblV1RFFvSkRRcDNZV3hsYzNKcGMydHpkVzFsYm5Sa1pHbHVaMkl0YkdscmRHVmhZMmhuYVdZaUlIWmxaMkZ6WkdGdWMydGxaWE4wYVhOb2NXbHdjM1Z2YldsemIySnlaV1JsYzJSbFpXNTBjbVYwYjJSdmMzQjFaV1JsWWNPeGIzTmxjM1REb1hScFpXNWxhR0Z6ZEdGdmRISnZjM0JoY25SbFpHOXVaR1Z1ZFdWMmIyaGhZMlZ5Wm05eWJXRnRhWE50YjIxbGFtOXliWFZ1Wkc5aGNYWERyV1REcldGemM4T3piRzloZVhWa1lXWmxZMmhoZEc5a1lYTjBZVzUwYjIxbGJtOXpaR0YwYjNOdmRISmhjM05wZEdsdmJYVmphRzloYUc5eVlXeDFaMkZ5YldGNWIzSmxjM1J2YzJodmNtRnpkR1Z1WlhKaGJuUmxjMlp2ZEc5elpYTjBZWE53WWNPdGMyNTFaWFpoYzJGc2RXUm1iM0p2YzIxbFpHbHZjWFZwWlc1dFpYTmxjM0J2WkdWeVkyaHBiR1Z6WlhMRG9YWmxZMlZ6WkdWamFYSnFiM1BEcVdWemRHRnlkbVZ1ZEdGbmNuVndiMmhsWTJodlpXeHNiM04wWlc1bmIyRnRhV2R2WTI5ellYTnVhWFpsYkdkbGJuUmxiV2x6YldGaGFYSmxjMnAxYkdsdmRHVnRZWE5vWVdOcFlXWmhkbTl5YW5WdWFXOXNhV0p5WlhCMWJuUnZZblZsYm05aGRYUnZjbUZpY21sc1luVmxibUYwWlhoMGIyMWhjbnB2YzJGaVpYSnNhWE4wWVd4MVpXZHZZOE96Ylc5bGJtVnliMnAxWldkdmNHVnl3N3BvWVdKbGNtVnpkRzk1Ym5WdVkyRnRkV3BsY25aaGJHOXlablZsY21Gc2FXSnliMmQxYzNSaGFXZDFZV3gyYjNSdmMyTmhjMjl6WjNYRHJXRndkV1ZrYjNOdmJXOXpZWFpwYzI5MWMzUmxaR1JsWW1WdWJtOWphR1ZpZFhOallXWmhiSFJoWlhWeWIzTnpaWEpwWldScFkyaHZZM1Z5YzI5amJHRjJaV05oYzJGemJHWERzMjV3YkdGNmIyeGhjbWR2YjJKeVlYTjJhWE4wWVdGd2IzbHZhblZ1ZEc5MGNtRjBZWFpwYzNSdlkzSmxZWEpqWVcxd2IyaGxiVzl6WTJsdVkyOWpZWEpuYjNCcGMyOXpiM0prWlc1b1lXTmxic09oY21WaFpHbHpZMjl3WldSeWIyTmxjbU5oY0hWbFpHRndZWEJsYkcxbGJtOXl3N3AwYVd4amJHRnliMnB2Y21kbFkyRnNiR1Z3YjI1bGNuUmhjbVJsYm1Ga2FXVnRZWEpqWVhOcFozVmxaV3hzWVhOemFXZHNiMk52WTJobGJXOTBiM050WVdSeVpXTnNZWE5sY21WemRHOXVhY094YjNGMVpXUmhjR0Z6WVhKaVlXNWpiMmhwYW05emRtbGhhbVZ3WVdKc2I4T3BjM1JsZG1sbGJtVnlaV2x1YjJSbGFtRnlabTl1Wkc5allXNWhiRzV2Y25SbGJHVjBjbUZqWVhWellYUnZiV0Z5YldGdWIzTnNkVzVsYzJGMWRHOXpkbWxzYkdGMlpXNWtiM0JsYzJGeWRHbHdiM04wWlc1bllXMWhjbU52Ykd4bGRtRndZV1J5WlhWdWFXUnZkbUZ0YjNONmIyNWhjMkZ0WW05elltRnVaR0Z0WVhKcFlXRmlkWE52YlhWamFHRnpkV0pwY25KcGIycGhkbWwyYVhKbmNtRmtiMk5vYVdOaFlXeHN3NjFxYjNabGJtUnBZMmhoWlhOMFlXNTBZV3hsYzNOaGJHbHljM1ZsYkc5d1pYTnZjMlpwYm1WemJHeGhiV0ZpZFhOamI4T3BjM1JoYkd4bFoyRnVaV2R5YjNCc1lYcGhhSFZ0YjNKd1lXZGhjbXAxYm5SaFpHOWliR1ZwYzJ4aGMySnZiSE5oWW1IRHNXOW9ZV0pzWVd4MVkyaGh3NEZ5WldGa2FXTmxibXAxWjJGeWJtOTBZWE4yWVd4c1pXRnNiTU9oWTJGeVoyRmtiMnh2Y21GaVlXcHZaWE4wdzZsbmRYTjBiMjFsYm5SbGJXRnlhVzltYVhKdFlXTnZjM1J2Wm1samFHRndiR0YwWVdodloyRnlZWEowWlhOc1pYbGxjMkZ4ZFdWc2JYVnpaVzlpWVhObGMzQnZZMjl6YldsMFlXUmphV1ZzYjJOb2FXTnZiV2xsWkc5bllXNWhjbk5oYm5SdlpYUmhjR0ZrWldKbGMzQnNZWGxoY21Wa1pYTnphV1YwWldOdmNuUmxZMjl5WldGa2RXUmhjMlJsYzJWdmRtbGxhbTlrWlhObFlXRm5kV0Z6Sm5GMWIzUTdaRzl0WVdsdVkyOXRiVzl1YzNSaGRIVnpaWFpsYm5SemJXRnpkR1Z5YzNsemRHVnRZV04wYVc5dVltRnVibVZ5Y21WdGIzWmxjMk55YjJ4c2RYQmtZWFJsWjJ4dlltRnNiV1ZrYVhWdFptbHNkR1Z5Ym5WdFltVnlZMmhoYm1kbGNtVnpkV3gwY0hWaWJHbGpjMk55WldWdVkyaHZiM05sYm05eWJXRnNkSEpoZG1Wc2FYTnpkV1Z6YzI5MWNtTmxkR0Z5WjJWMGMzQnlhVzVuYlc5a2RXeGxiVzlpYVd4bGMzZHBkR05vY0dodmRHOXpZbTl5WkdWeWNtVm5hVzl1YVhSelpXeG1jMjlqYVdGc1lXTjBhWFpsWTI5c2RXMXVjbVZqYjNKa1ptOXNiRzkzZEdsMGJHVStaV2wwYUdWeWJHVnVaM1JvWm1GdGFXeDVabkpwWlc1a2JHRjViM1YwWVhWMGFHOXlZM0psWVhSbGNtVjJhV1YzYzNWdGJXVnljMlZ5ZG1WeWNHeGhlV1ZrY0d4aGVXVnlaWGh3WVc1a2NHOXNhV041Wm05eWJXRjBaRzkxWW14bGNHOXBiblJ6YzJWeWFXVnpjR1Z5YzI5dWJHbDJhVzVuWkdWemFXZHViVzl1ZEdoelptOXlZMlZ6ZFc1cGNYVmxkMlZwWjJoMGNHVnZjR3hsWlc1bGNtZDVibUYwZFhKbGMyVmhjbU5vWm1sbmRYSmxhR0YyYVc1blkzVnpkRzl0YjJabWMyVjBiR1YwZEdWeWQybHVaRzkzYzNWaWJXbDBjbVZ1WkdWeVozSnZkWEJ6ZFhCc2IyRmthR1ZoYkhSb2JXVjBhRzlrZG1sa1pXOXpjMk5vYjI5c1puVjBkWEpsYzJoaFpHOTNaR1ZpWVhSbGRtRnNkV1Z6VDJKcVpXTjBiM1JvWlhKemNtbG5hSFJ6YkdWaFozVmxZMmh5YjIxbGMybHRjR3hsYm05MGFXTmxjMmhoY21Wa1pXNWthVzVuYzJWaGMyOXVjbVZ3YjNKMGIyNXNhVzVsYzNGMVlYSmxZblYwZEc5dWFXMWhaMlZ6Wlc1aFlteGxiVzkyYVc1bmJHRjBaWE4wZDJsdWRHVnlSbkpoYm1ObGNHVnlhVzlrYzNSeWIyNW5jbVZ3WldGMFRHOXVaRzl1WkdWMFlXbHNabTl5YldWa1pHVnRZVzVrYzJWamRYSmxjR0Z6YzJWa2RHOW5aMnhsY0d4aFkyVnpaR1YyYVdObGMzUmhkR2xqWTJsMGFXVnpjM1J5WldGdGVXVnNiRzkzWVhSMFlXTnJjM1J5WldWMFpteHBaMmgwYUdsa1pHVnVhVzVtYnlJK2IzQmxibVZrZFhObFpuVnNkbUZzYkdWNVkyRjFjMlZ6YkdWaFpHVnljMlZqY21WMGMyVmpiMjVrWkdGdFlXZGxjM0J2Y25SelpYaGpaWEIwY21GMGFXNW5jMmxuYm1Wa2RHaHBibWR6WldabVpXTjBabWxsYkdSemMzUmhkR1Z6YjJabWFXTmxkbWx6ZFdGc1pXUnBkRzl5ZG05c2RXMWxVbVZ3YjNKMGJYVnpaWFZ0Ylc5MmFXVnpjR0Z5Wlc1MFlXTmpaWE56Ylc5emRHeDViVzkwYUdWeUlpQnBaRDBpYldGeWEyVjBaM0p2ZFc1a1kyaGhibU5sYzNWeWRtVjVZbVZtYjNKbGMzbHRZbTlzYlc5dFpXNTBjM0JsWldOb2JXOTBhVzl1YVc1emFXUmxiV0YwZEdWeVEyVnVkR1Z5YjJKcVpXTjBaWGhwYzNSemJXbGtaR3hsUlhWeWIzQmxaM0p2ZDNSb2JHVm5ZV041YldGdWJtVnlaVzV2ZFdkb1kyRnlaV1Z5WVc1emQyVnliM0pwWjJsdWNHOXlkR0ZzWTJ4cFpXNTBjMlZzWldOMGNtRnVaRzl0WTJ4dmMyVmtkRzl3YVdOelkyOXRhVzVuWm1GMGFHVnliM0IwYVc5dWMybHRjR3g1Y21GcGMyVmtaWE5qWVhCbFkyaHZjMlZ1WTJoMWNtTm9aR1ZtYVc1bGNtVmhjMjl1WTI5eWJtVnliM1YwY0hWMGJXVnRiM0o1YVdaeVlXMWxjRzlzYVdObGJXOWtaV3h6VG5WdFltVnlaSFZ5YVc1bmIyWm1aWEp6YzNSNWJHVnphMmxzYkdWa2JHbHpkR1ZrWTJGc2JHVmtjMmxzZG1WeWJXRnlaMmx1WkdWc1pYUmxZbVYwZEdWeVluSnZkM05sYkdsdGFYUnpSMnh2WW1Gc2MybHVaMnhsZDJsa1oyVjBZMlZ1ZEdWeVluVmtaMlYwYm05M2NtRndZM0psWkdsMFkyeGhhVzF6Wlc1bmFXNWxjMkZtWlhSNVkyaHZhV05sYzNCcGNtbDBMWE4wZVd4bGMzQnlaV0ZrYldGcmFXNW5ibVZsWkdWa2NuVnpjMmxoY0d4bFlYTmxaWGgwWlc1MFUyTnlhWEIwWW5KdmEyVnVZV3hzYjNkelkyaGhjbWRsWkdsMmFXUmxabUZqZEc5eWJXVnRZbVZ5TFdKaGMyVmtkR2hsYjNKNVkyOXVabWxuWVhKdmRXNWtkMjl5YTJWa2FHVnNjR1ZrUTJoMWNtTm9hVzF3WVdOMGMyaHZkV3hrWVd4M1lYbHpiRzluYnlJZ1ltOTBkRzl0YkdsemRDSStLWHQyWVhJZ2NISmxabWw0YjNKaGJtZGxTR1ZoWkdWeUxuQjFjMmdvWTI5MWNHeGxaMkZ5WkdWdVluSnBaR2RsYkdGMWJtTm9VbVYyYVdWM2RHRnJhVzVuZG1semFXOXViR2wwZEd4bFpHRjBhVzVuUW5WMGRHOXVZbVZoZFhSNWRHaGxiV1Z6Wm05eVoyOTBVMlZoY21Ob1lXNWphRzl5WVd4dGIzTjBiRzloWkdWa1EyaGhibWRsY21WMGRYSnVjM1J5YVc1bmNtVnNiMkZrVFc5aWFXeGxhVzVqYjIxbGMzVndjR3g1VTI5MWNtTmxiM0prWlhKemRtbGxkMlZrSm01aWMzQTdZMjkxY25ObFFXSnZkWFFnYVhOc1lXNWtQR2gwYld3Z1kyOXZhMmxsYm1GdFpUMGlZVzFoZW05dWJXOWtaWEp1WVdSMmFXTmxhVzQ4TDJFK09pQlVhR1VnWkdsaGJHOW5hRzkxYzJWelFrVkhTVTRnVFdWNGFXTnZjM1JoY25SelkyVnVkSEpsYUdWcFoyaDBZV1JrYVc1blNYTnNZVzVrWVhOelpYUnpSVzF3YVhKbFUyTm9iMjlzWldabWIzSjBaR2x5WldOMGJtVmhjbXg1YldGdWRXRnNVMlZzWldOMExnb0tUMjVsYW05cGJtVmtiV1Z1ZFNJK1VHaHBiR2x3WVhkaGNtUnphR0Z1Wkd4bGFXMXdiM0owVDJabWFXTmxjbVZuWVhKa2MydHBiR3h6Ym1GMGFXOXVVM0J2Y25SelpHVm5jbVZsZDJWbGEyeDVJQ2hsTG1jdVltVm9hVzVrWkc5amRHOXliRzluWjJWa2RXNXBkR1ZrUEM5aVBqd3ZZbVZuYVc1emNHeGhiblJ6WVhOemFYTjBZWEowYVhOMGFYTnpkV1ZrTXpBd2NIaDhZMkZ1WVdSaFlXZGxibU41YzJOb1pXMWxjbVZ0WVdsdVFuSmhlbWxzYzJGdGNHeGxiRzluYnlJK1ltVjViMjVrTFhOallXeGxZV05qWlhCMGMyVnlkbVZrYldGeWFXNWxSbTl2ZEdWeVkyRnRaWEpoUEM5b01UNEtYMlp2Y20waWJHVmhkbVZ6YzNSeVpYTnpJaUF2UGcwS0xtZHBaaUlnYjI1c2IyRmtiRzloWkdWeVQzaG1iM0prYzJsemRHVnljM1Z5ZG1sMmJHbHpkR1Z1Wm1WdFlXeGxSR1Z6YVdkdWMybDZaVDBpWVhCd1pXRnNkR1Y0ZENJK2JHVjJaV3h6ZEdoaGJtdHphR2xuYUdWeVptOXlZMlZrWVc1cGJXRnNZVzU1YjI1bFFXWnlhV05oWVdkeVpXVmtjbVZqWlc1MFVHVnZjR3hsUEdKeUlDOCtkMjl1WkdWeWNISnBZMlZ6ZEhWeWJtVmtmSHdnZTMwN2JXRnBiaUkrYVc1c2FXNWxjM1Z1WkdGNWQzSmhjQ0krWm1GcGJHVmtZMlZ1YzNWemJXbHVkWFJsWW1WaFkyOXVjWFZ2ZEdWek1UVXdjSGg4WlhOMFlYUmxjbVZ0YjNSbFpXMWhhV3dpYkdsdWEyVmtjbWxuYUhRN2MybG5ibUZzWm05eWJXRnNNUzVvZEcxc2MybG5iblZ3Y0hKcGJtTmxabXh2WVhRNkxuQnVaeUlnWm05eWRXMHVRV05qWlhOemNHRndaWEp6YzI5MWJtUnpaWGgwWlc1a1NHVnBaMmgwYzJ4cFpHVnlWVlJHTFRnaUptRnRjRHNnUW1WbWIzSmxMaUJYYVhSb2MzUjFaR2x2YjNkdVpYSnpiV0Z1WVdkbGNISnZabWwwYWxGMVpYSjVZVzV1ZFdGc2NHRnlZVzF6WW05MVoyaDBabUZ0YjNWeloyOXZaMnhsYkc5dVoyVnlhU3NyS1NCN2FYTnlZV1ZzYzJGNWFXNW5aR1ZqYVdSbGFHOXRaU0krYUdWaFpHVnlaVzV6ZFhKbFluSmhibU5vY0dsbFkyVnpZbXh2WTJzN2MzUmhkR1ZrZEc5d0lqNDhjbUZqYVc1bmNtVnphWHBsTFMwbVozUTdjR0ZqYVhSNWMyVjRkV0ZzWW5WeVpXRjFMbXB3WnlJZ01UQXNNREF3YjJKMFlXbHVkR2wwYkdWellXMXZkVzUwTENCSmJtTXVZMjl0WldSNWJXVnVkU0lnYkhseWFXTnpkRzlrWVhrdWFXNWtaV1ZrWTI5MWJuUjVYMnh2WjI4dVJtRnRhV3g1Ykc5dmEyVmtUV0Z5YTJWMGJITmxJR2xtVUd4aGVXVnlkSFZ5YTJWNUtUdDJZWElnWm05eVpYTjBaMmwyYVc1blpYSnliM0p6Ukc5dFlXbHVmV1ZzYzJWN2FXNXpaWEowUW14dlp6d3ZabTl2ZEdWeWJHOW5hVzR1Wm1GemRHVnlZV2RsYm5SelBHSnZaSGtnTVRCd2VDQXdjSEpoWjIxaFpuSnBaR0Y1YW5WdWFXOXlaRzlzYkdGeWNHeGhZMlZrWTI5MlpYSnpjR3gxWjJsdU5Td3dNREFnY0dGblpTSStZbTl6ZEc5dUxuUmxjM1FvWVhaaGRHRnlkR1Z6ZEdWa1gyTnZkVzUwWm05eWRXMXpjMk5vWlcxaGFXNWtaWGdzWm1sc2JHVmtjMmhoY21WemNtVmhaR1Z5WVd4bGNuUW9ZWEJ3WldGeVUzVmliV2wwYkdsdVpTSStZbTlrZVNJK0Npb2dWR2hsVkdodmRXZG9jMlZsYVc1bmFtVnljMlY1VG1WM2N6d3ZkbVZ5YVdaNVpYaHdaWEowYVc1cWRYSjVkMmxrZEdnOVEyOXZhMmxsVTFSQlVsUWdZV055YjNOelgybHRZV2RsZEdoeVpXRmtibUYwYVhabGNHOWphMlYwWW05NElqNEtVM2x6ZEdWdElFUmhkbWxrWTJGdVkyVnlkR0ZpYkdWemNISnZkbVZrUVhCeWFXd2djbVZoYkd4NVpISnBkbVZ5YVhSbGJTSStiVzl5WlNJK1ltOWhjbVJ6WTI5c2IzSnpZMkZ0Y0hWelptbHljM1FnZkh3Z1cxMDdiV1ZrYVdFdVozVnBkR0Z5Wm1sdWFYTm9kMmxrZEdnNmMyaHZkMlZrVDNSb1pYSWdMbkJvY0NJZ1lYTnpkVzFsYkdGNVpYSnpkMmxzYzI5dWMzUnZjbVZ6Y21Wc2FXVm1jM2RsWkdWdVEzVnpkRzl0WldGemFXeDVJSGx2ZFhJZ1UzUnlhVzVuQ2dwWGFHbHNkR0Y1Ykc5eVkyeGxZWEk2Y21WemIzSjBabkpsYm1Ob2RHaHZkV2RvSWlrZ0t5QWlQR0p2WkhrK1luVjVhVzVuWW5KaGJtUnpUV1Z0WW1WeWJtRnRaU0krYjNCd2FXNW5jMlZqZEc5eU5YQjRPeUkrZG5Od1lXTmxjRzl6ZEdWeWJXRnFiM0lnWTI5bVptVmxiV0Z5ZEdsdWJXRjBkWEpsYUdGd2NHVnVQQzl1WVhZK2EyRnVjMkZ6YkdsdWF5SStTVzFoWjJWelBXWmhiSE5sZDJocGJHVWdhSE53WVdObE1DWmhiWEE3SUFvS1NXNGdJSEJ2ZDJWeVVHOXNjMnRwTFdOdmJHOXlhbTl5WkdGdVFtOTBkRzl0VTNSaGNuUWdMV052ZFc1ME1pNW9kRzFzYm1WM2N5SStNREV1YW5CblQyNXNhVzVsTFhKcFoyaDBiV2xzYkdWeWMyVnVhVzl5U1ZOQ1RpQXdNQ3d3TURBZ1ozVnBaR1Z6ZG1Gc2RXVXBaV04wYVc5dWNtVndZV2x5TG5odGJDSWdJSEpwWjJoMGN5NW9kRzFzTFdKc2IyTnJjbVZuUlhod09taHZkbVZ5ZDJsMGFHbHVkbWx5WjJsdWNHaHZibVZ6UEM5MGNqNE5kWE5wYm1jZ0NnbDJZWElnUGljcE93b0pQQzkwWkQ0S1BDOTBjajRLWW1Gb1lYTmhZbkpoYzJsc1oyRnNaV2R2YldGbmVXRnljRzlzYzJ0cGMzSndjMnRwMkxIWXI5bUk1TGl0NXBhSDU2NkE1TDJUNTdtQjZhdVU1TCtoNW9HdjVMaXQ1WnU5NW9pUjVMdXM1TGlBNUxpcTVZV3M1WSs0NTY2aDU1Q0c2SzY2NVoyYjVZK3Y1THVsNXB5TjVZcWg1cGUyNlplMDVMaXE1THE2NUxxbjVaT0I2SWVxNWJleDVMeUI1TGlhNXArbDU1eUw1YmVsNUwyYzZJR1U1N083NXJLaDVweUo1NzJSNTZ1WjVvbUE1cHlKNksrRTZLNjY1TGl0NWIrRDVwYUg1NnVnNTVTbzVvaTM2YWFXNmFHMTVMMmM2SUNGNW9xQTVweXY2WmV1NmFLWTU1dTQ1WVd6NUxpTDZMMjk1cENjNTdTaTVMMi81NVNvNkwydjVMdTI1WnlvNTdxLzVMaTc2YUtZNkxXRTVwYVo2S2VHNmFLUjVadWU1YVNONXJPbzVZYU01NzJSNTd1YzVwUzI2SmVQNVlhRjVhNjU1bzZvNkkyUTViaUM1Wnk2NXJhSTVvR3Y1Nm02NlplMDVZK1I1YmlENUx1QTVMbUk1YVc5NVkrTDU1U2Y1clM3NVp1KzU0bUg1WStSNWJHVjVhYUM1cDZjNW9tTDVweTY1cGF3NlplNzVweUE1cGF3NXBhNTVieVA1WXlYNUxxczVvK1E1TDZiNVlXejVMcU81cHUwNWFTYTZMK1o1TGlxNTdPNzU3dWY1NStsNllHVDVyaTQ1b2lQNWJtLzVaR0s1WVcyNUx1VzVZK1I2S0dvNWE2SjVZV281NnlzNUxpQTVMeWE1WkdZNkwrYjZLR001NEs1NVllNzU0bUk1cDJENTVTMTVhMlE1TGlXNTVXTTZLNis2SzZoNVlXTjZMUzU1cFdaNklLeTVZcWc1WVdsNXJTNzVZcW81THVXNUx1czVaV0c1Wk9CNVkyYTVhNmk1NDZ3NVp5bzVMaUs1clczNWFhQzVMMlY1YmV5NTd1UDU1V1o2S2lBNksrbTU3dUc1NlMrNVl5NjU1bTc1YjJWNXB5czU2dVo2WnlBNkthQjVMdTM1cUM4NXBTdjVveUI1WnU5NlptRjZaTys1bzZsNVp1OTVhNjI1YnU2Nks2KzVweUw1WStMNlppRjZLKzc1ck9WNWI2TDVMMk41NzJ1NTd1UDVyV082WUNKNW91cDZMK1o1cUMzNWIyVDVZbU41WWlHNTdHNzVvNlM2S0dNNVp1ZzVMaTY1THFrNXBpVDVweUE1WkNPNlorejVMbVE1TGlONklPOTZZQ2E2TCtINktHTTVMaWE1NmVSNW9xQTVZK3Y2SU85Nks2KzVhU0g1WkNJNUwyYzVhU241YTYyNTZTKzVMeWE1NkNVNTZtMjVMaVQ1TGlhNVlXbzZZT282YUc1NTV1dTZMK1o2WWVNNkwrWTVwaXY1YnlBNWFlTDVvT0Y1WWExNTVTMTZJU1I1cGFINUx1MjVaT0I1NG1NNWJpdTVZcXA1cGFINVl5VzZMV0U1cnFRNWFTbjVhMm01YTJtNUxtZzVaeXc1WjJBNXJXUDZLZUk1b3FWNkxXRTViZWw1NmlMNkthQjVyR0M1b0NPNUxtSTVwZTI1WUNaNVlxZjZJTzk1TGk3NkthQjU1dXU1WW1ONkxXRTZLNnY1WitPNWJpQzVwYTU1ck9WNTVTMTViMng1b3ViNklHWTVhT3c1cGlPNUx1NzVMMlY1WUdsNWJxMzVwV3c1bzJ1NTc2TzVadTk1ckc5NkwybTVMdUw1N3VONUwyRzVwaXY1THFrNXJXQjU1U2Y1THFuNW9tQTVMdWw1NVMxNksrZDVwaSs1NlM2NUxpQTVMcWI1WTJWNUwyTjVMcTY1WkdZNVlpRzVwNlE1Wnl3NVp1KzVwZUY1cmk0NWJlbDVZVzM1YTJtNTVTZjU3Tzc1WWlYNTcyUjVZK0w1YmlXNWEyUTVhK0c1NkNCNmFLUjZZR1Q1bzZuNVlpMjVaeXc1WXk2NVorNjVweXM1WVdvNVp1OTU3MlI1TGlLNlllTjZLYUI1NnlzNUxxTTVaYWM1cXlpNkwrYjVZV2w1WStMNW9PRjZMK1o1THFiNklDRDZLK1Y1WStSNTQ2dzVaKzU2SzZ0NUx1bDVMaUs1cFMvNWJxYzVvaVE1TGk2NTQ2djVhS0Q2YWFaNXJpdjVaQ001cGUyNWFpeDVMbVE1WStSNllDQjVMaUE1YTZhNWJ5QTVZK1I1TDJjNVpPQjVxQ0g1WWVHNXF5aTZMK082S2VqNVlhejVaeXc1cGE1NUxpQTVMaUw1THVsNVkrSzZMU2o1THU3NW9pVzZJQ0Y1YTZpNW9pMzVMdWo2S0dvNTZldjVZaUc1YVd6NUxxNjVwV3c1NkNCNlpTQTVaU3U1WWU2NTQ2dzU2YTc1N3EvNWJxVTU1U281WWlYNktHbzVMaU41WkNNNTd5VzZMNlI1N3VmNks2aDVwK2w2SytpNUxpTjZLYUI1cHlKNVlXejVweTY1cDZFNWI2STVhU2E1cEt0NXBTKzU3dUU1N3VINXBTLzU2Mlc1NXUwNW82bDZJTzk1WXFiNXAybDVycVE1cG1DNlphVDU1eUw1WWl3NTRPdDZaZW81WVd6NlpTdTVMaVQ1WXk2NloyZTViaTQ2SXV4NksrdDU1bSs1YnFtNWJpTTVweWI1NzZPNWFXejVxK1U2TDZENTUrbDZLK0c2S2VFNWE2YTVidTY2SzZ1NllPbzZaZW81b1NQNktlQjU3Sys1YjJwNXBlbDVweXM1bytRNmF1WTVZK1I2S2lBNXBhNTZaMmk1Wis2NlllUjVhU0U1NUNHNXAyRDZabVE1YjJ4NTRtSDZaTzI2S0dNNkwrWTVweUo1WWlHNUxxcjU0bXA1Wk9CNTd1UDZKQ2w1cmU3NVlxZzVMaVQ1YTYyNkwrWjU2ZU42SytkNmFLWTZMVzM1cDJsNUxpYTVZcWg1WVdzNVpHSzZLNnc1YjJWNTY2QTVMdUw2TFNvNlllUDU1UzM1THE2NWIyeDVaT041YnlWNTVTbzVvcWw1WkdLNllPbzVZaUc1YityNllDZjVaS282SytpNXBlMjViQ2E1ck9vNW9TUDU1U3o2SyszNWEybTVxQ2g1YnFVNksrbDVZNkc1WSt5NVkrcTVwaXY2TCtVNVp1ZTZMU3Q1TG13NVpDTjU2ZXc1TGk2NUxxRzVvaVE1WXFmNksrMDVwaU81TDZiNWJxVTVhMnA1YTJRNUxpVDZhS1k1NmlMNWJxUDVMaUE2SWlzNXB5RDVaT2g1WStxNXB5SjVZVzI1YTZENUwrZDVvcWs2SUNNNUxpVTVMdUs1YVNwNTZxWDVZK2o1WXFvNW9DQjU0cTI1b0NCNTRtNTVZaXI2SzZrNUxpNjViK0Y2YUc3NXB1MDVwYXc1YkNQNksrMDVvaVI1WUNSNUwyYzVMaTY1YXFTNUwyVDVZeUY1b3VzNllLajVMbUk1TGlBNXFDMzVadTk1WWFGNXBpdjVaQ201cUM1NW8ydTU1UzE2S2VHNWEybTZabWk1WVczNXB5SjZMK0g1NmlMNTVTeDVMcU81THE2NW9tTjVZZTY1cDJsNUxpTjZMK0g1cTJqNVp5bzVwaU81cGlmNXBXRjVMcUw1WVd6NTdPNzVxQ0g2YUtZNVpXRzVZcWg2TDZUNVlXbDVMaUE1NXUwNVorNjU2R0E1cFdaNWEybTVMcUc2S2VqNWJ1NjU2MlI1N3VUNXA2YzVZV281NUNENllDYTU1K2w2SzZoNVlpUzVhKzU1THFPNkltNjVweXY1NXU0NVlhTTVZK1I1NVNmNTV5ZjU1cUU1YnU2NTZ1TDU2Mko1N3FuNTdHNzVaNkw1N3VQNmFxTTVhNmU1NDZ3NVlpMjVMMmM1cDJsNkllcTVxQ0g1NjIrNUx1bDVMaUw1WTZmNVlpYjVwZWc1ck9WNVlXMjVMaXQ1WUNMNUxxNjVMaUE1WWlINW95SDVZMlg1WVd6NlpldDZadUc1WnVpNTZ5czVMaUo1WVd6NXJPbzVadWc1cTJrNTRXbjU0bUg1cmV4NVp5ejVaV0c1TGlhNWJtLzViZWU1cGVsNXB5ZjZhdVk1N3FuNXB5QTZMK1I1N3U4NVpDSTZLR281NlM2NUxpVDZMNlI2S0dNNUxpNjVMcWs2WUNhNksrRTVMdTM2S2VKNWI2WDU3Sys1WTJPNWE2MjVicXQ1YTZNNW9pUTVvU2Y2S2VKNWE2SjZLT0Y1YjZYNVlpdzZZS3U1THUyNVlpMjVicW02YU9mNVpPQjZKbTk1NFMyNkwyczZMMjk1b3FsNUx1MzZLNnc2SUNGNXBhNTVxR0k2S0dNNXBTLzVMcTY1ckNSNTVTbzVaT0I1TGljNktXLzVvK1E1WWU2NllXUzVicVg1NFMyNVpDTzVMdVk1cXkrNTRPdDU0SzU1THVsNVltTjVhNk01WVdvNVkrUjViaVc2SzYrNTcydTZhS0c1YSs4NWJlbDVMaWE1WXk3NlptaTU1eUw1NXlMNTd1UDVZVzQ1WTZmNVp1ZzVibXo1WSt3NVpDRTU2ZU41YUtlNVlxZzVwMlE1cGFaNXBhdzVhS2U1TG1MNVpDTzZJR001TGlhNXBXSTVwNmM1THVLNWJtMDZLNjY1cGFINW9pUjVadTk1WkdLNksrSjU0bUk1TGk3NUwrdTVwUzU1WStDNUxpTzVvbVQ1WTJ3NWIrcjVMbVE1cHk2NXFLdzZLZUM1NEs1NWEyWTVaeW81N0srNTZXZTZJNjM1YjZYNVlpcDU1U281N3VuNTd1dDVMMmc1THVzNkwrWjVMbUk1cWloNWJ5UDZLK3Q2S2lBNklPOTVhU2Y2WnVGNkptTzVwT041TDJjNmFPTzVxQzg1TGlBNkxXMzU2ZVI1YTJtNUwyVDZJS3k1NSt0NUwraDVwMmg1THUyNXJLNzU1YVg2TCtRNVlxbzVMcW41TGlhNUx5YTZLNnU1YSs4NklpcTVZV0k1NVNmNklHVTU1dWY1WSt2NXBpdjVaV1A2YUdNNTd1VDVwNkU1TDJjNTVTbzZMQ0Q1cCtsNkxPSDVwYVo2SWVxNVlxbzZMU2Y2TFNqNVlhYzVMaWE2SzYvNlpldTVhNmU1cGE5NW82bDVZK1g2SzZvNks2NjZZS2o1TGlxNVkrTjZhYUk1WXFnNWJ5NjVhV3o1b0NuNkl5RDVadTA1cHlONVl1WjVMeVI2WmV5NUx1SzVwZWw1YTZpNXB5TjZLZUE1NXlMNVkrQzVZcWc1NXFFNksrZDVMaUE1NEs1NUwrZDZLK0I1WnUrNUxtbTVweUo1cFdJNXJXTDZLK1Y1NmU3NVlxbzVvbU42SU85NVlhejVhNmE2SUtoNTZXbzVMaU41cGF0Nlp5QTVyR0M1TGlONWI2WDVZcWU1ck9WNUxtTDZaZTA2WWVINTVTbzZKQ2w2WlNBNW9xVjZLK0o1NXV1NXFDSDU0aXg1b09GNXBHRTViMng1cHlKNUxxYjZLU0g2S085NXBhSDVhMm01cHk2NUx5YTVwV3c1YTJYNktPRjVMK3U2TFN0NTRtcDVZYWM1cDJSNVlXbzZaMmk1N0srNVpPQjVZVzI1YTZlNUxxTDVvT0Y1ckMwNWJtejVvK1E1NlM2NUxpSzViaUM2TENpNkxDaTVwbXU2WUNhNXBXWjViaUk1TGlLNUx5ZzU3Rzc1WWlyNXEyTTVwdXk1b3VsNXB5SjVZaWI1cGF3NllXTjVMdTI1WStxNkthQjVwZTI1THVqNkxPSDZLaUs2TDYrNVlpdzVMcTY1NVNmNks2aTZaaUY2SUNCNWJpSTViR1Y1NlM2NWIrRDU1Q0c2TFMwNWEyUTU3YXk1NnVaNUxpNzZhR002SWVxNTRTMjU3cW41WWlyNTY2QTVZMlY1cFM1NloycDZZS2o1THFiNXAybDZLKzA1b21UNWJ5QTVMdWo1NkNCNVlpZzZabWs2SytCNVlpNDZJcUM1NXV1NlllTjU0SzU1cXloNXBXNDVhU2E1YkNSNktlRTVZaVM2TFdFNlllUjVvbSs1WWl3NUx1bDVaQ081YVNuNVlXbzVMaTc2YUcxNXB5QTVMMno1WnVlNTYyVTVhU3A1TGlMNUwrZDZacWM1NDZ3NUx1ajVxT0E1cCtsNW9xVjU2V281YkNQNXBlMjVyS1M1cHlKNXEyajViaTQ1NVNhNkllejVMdWo1NUNHNTV1dTViMlY1WVdzNWJ5QTVhU041WWkyNlllUjZKNk41Ym00NTZhUDU0bUk1cHlzNWIyaTVvaVE1WWVHNWFTSDZLR001b09GNVp1ZTVZaXc1b0NkNW9PejVvQ081cUMzNVkyUDZLNnU2SzZrNksrQjVweUE1YVc5NUxxbjU1U2Y1b3lKNTRXbjVweU42S09GNWJtLzVMaWM1WXFvNXJ5cjZZZUg2TFN0NXBhdzVvbUw1N3VFNVp1KzZaMmk1cDIvNVkrQzZJQ0Q1cFMvNXJLNzVhNjU1cGlUNWFTcDVaeXc1WXFxNVlxYjVMcTY1THVzNVkySDU3cW42WUNmNWJxbTVMcTY1NG1wNkxDRDVwVzA1cldCNktHTTZZQ2c1b2lRNXBhSDVhMlg2WitwNVp1OTZMUzQ1cGlUNWJ5QTViR1Y1NXU0NlplYzZLR281NDZ3NWIyeDZLZUc1YWFDNXEyazU3Nk81YTY1NWFTbjViQ1A1b3FsNllHVDVwMmg1cXkrNWIrRDVvT0Y2SzY0NWFTYTVyT1Y2S2VFNWE2MjViR0Y1TG1tNWJxWDZMK2U1bzZsNTZ1TDVZMno1TGkrNW9xbDVvcUE1YmVuNWFXbDZMK1E1NW03NVlXbDVMdWw1cDJsNTVDRzZLNjY1THFMNUx1MjZJZXE1NVN4NUxpdDVZMk81WXFlNVlXczVhYUk1YWFJNTV5ZjVxMmo1TGlONlpTWjVZV281cGFINVpDSTVaQ001THUzNVlDODVZaXI1THE2NTV1UjU1Mmo1WVczNUwyVDVMaVc1N3FxNVp1aTZaaWY1WWliNUxpYTVvbS81b3VGNWFLZTZaVy81cHlKNUxxNjVMK2Q1b3lCNVpXRzVhNjI1N3UwNUwrdTVZK3c1cm0rNWJlbTVZK3o2SUtoNUx1OTU2MlU1cUdJNWE2ZTZabUY1NVMxNUwraDU3dVA1NUNHNTVTZjVaRzk1YTZqNUx5ZzVMdTc1WXFoNXEyajVieVA1NG01NklteTVMaUw1cDJsNVkyUDVMeWE1WStxNklPOTViMlQ1NFMyNlllTjVwYXc1WVduNWE2NTVveUg1YSs4NkwrUTZLR001cGVsNWIrWDZMT2o1YTYyNkxhRjZMK0g1WnlmNVp5dzVyV1o1ckdmNXBTdjVMdVk1bzZvNVllNjU2dVo2WlcvNXAydDViZWU1b21uNktHTTVZaTI2WUNnNUxtTDVMaUE1bzZvNWJtLzU0Nnc1Wnk2NW8rUDZMK3c1WStZNVl5VzVMeWc1N3VmNXEyTTVvbUw1TCtkNlptcDZLKys1NmlMNVl5NzU1YVg1N3VQNkwrSDZMK0g1WTY3NUxtTDVZbU41cFMyNVlXbDVibTA1YnFtNXAyQzViK1g1NzZPNUxpOTVweUE2YXVZNTVtNzZabUc1cHlxNXAybDVZcWc1YmVsNVlXTjZMU2o1cFdaNTZpTDU0bUk1WjJYNkxxcjVMMlQ2WWVONWJxRzVZZTY1WlN1NW9pUTVweXM1YjJpNWJ5UDVaeWY2TEdHNVllNjVZTzU1TGljNXBhNTZZS3U1NjZ4NVkyWDVMcXM1ckdDNklHTTVZK1c1YjZYNklHTTVMMk41NXU0NUwraDZhRzE2WjJpNVlpRzZaS2Y1NzJSNmFHMTU2R3U1YTZhNVp1KzVMNkw1NzJSNVoyQTU2ZXY1cDZCNlpTWjZLK3Y1NXV1NTVxRTVhNmQ2TFNkNXB5NjVZV3o2YU9PNlptcDVvNkk1cDJENTVlRjVxK1M1YTZnNTRtcDZabWs1THFHNkttVjZLdVc1NWErNTVlRjVZK0s1cGUyNXJHQzZMU3Q1NnVaNTRLNTVZUy81NnVsNXErUDVhU3A1TGl0NWFTdTZLNms2SytHNXErUDVMaXE1YVNwNXJTbDVhMlg1TDJUNVkrdzU0R2o1N3UwNW9xazVweXM2YUcxNUxpcTVvQ241YTZZNXBhNTViaTQ2S2VCNTV1NDVweTY1b2lZNTVXbDVicVU1YjJUNWI2TDViaUk1cGE1NUw2LzVxQ2g1WnV0NklLaDViaUM1b2kvNWJHTDVxQ1A1NXV1NVpHWTViZWw1YSs4NkllMDU2cUI1NFMyNllHVDVZVzM1cHlzNTcyUjU3dVQ1WkNJNXFHajVxR0k1WXF6NVlxbzVZK201YVNXNTc2TzVZV0Q1YnlWNkxXMzVwUzU1WStZNTZ5czVadWI1THlhNks2aDZLcXE1cGlPNlpxUTU2ZUI1YTZkNWE2ZDZLZUU2SXlENXJhSTZMUzU1WVd4NVpDTTViK1k2SzZ3NUwyVDU3Tzc1YmltNXAybDVaQ041YTJYNTVtODZLR281YnlBNXBTKzVZcWc1NXVmNVkrWDVZaXc1THFNNW9tTDVhU242WWVQNW9pUTVMcTY1cFd3NlllUDVZV3g1THFyNVl5NjVaK2Y1YVd6NWEycDVZNmY1WWlaNW9tQTVaeW81N3VUNXAyZjZZQ2E1TCtoNkxhRjU3cW42WVdONTcydTViMlQ1cGUyNUx5WTU2ZUE1b0NuNW9TZjVvaS81THFuNllHSzVvaXk1WWU2NVkrajVvK1E1THFrNWJDeDVMaWE1TCtkNVlHbDU2aUw1YnFtNVkrQzVwV3c1THFMNUxpYTVwVzA1TGlxNWJHeDVMaWM1b09GNW9TZjU0bTU1cTZLNVlpRzZhR2U1cENjNWJDTDViR2U1THFPNlplbzVvaTM2TFNpNVlxaDVhT3c2Wit6NVkrSzVZVzI2TFNpNTd1UDVaMmE1b3lCNWJteTZZT281b2lRNTZ1TDVZaXA1NXVLNklDRDZKbVI1b2lRNllPOTVZeUY2S09GNTVTbzVvaTI1cStVNkxXYjVwYUg1cGlPNW91YjVaV0c1YTZNNXBXMDU1eWY1cGl2NTV5ODU1MmI1THlaNUx5MDVhaUI1cHliNmFLRzVaK2Y1WTJyNTVTZjVMeVk1b09nNkt1VzVhT0g1WVdzNVlXeDZJbXY1YVc5NVlXRjVZaUc1NnltNVpDSTZabUU1THUyNTRtNTU0SzU1TGlONVkrdjZJdXg1cGFINkxXRTVMcW41cUM1NXB5czVwaU81cGkrNWErRzU2Szg1WVdzNUx5WDVyQ1I1cGVQNXB1MDVZcWc1THFyNVkrWDVaQ001YTJtNVpDdjVZcW82WUNDNVpDSTVZNmY1cDJsNlpldTU2MlU1cHlzNXBhSDU3Nk82YU9mNTd1LzZJbXk1Nml6NWE2YTU3dUk1THFPNTVTZjU0bXA1TDZiNXJHQzVwQ2M1NHVRNVlxYjZZZVA1TGlsNlllTjVyQzQ2TCtjNVlhWjU1eWY1cHlKNlptUTU2dWU1THFKNWErNTZMR2g2TFM1NTVTbzVMaU41YVc5NTd1ZDVhKzU1WTJCNVlpRzVMK0Q2TCtiNTRLNTZLK0U1YjJ4NlorejVMeVk1WXEvNUxpTjViQ1I1cXlqNkxXUDVibTI1TGlVNXB5SjU0SzU1cGE1NVpDUjVZV281cGF3NUwraDU1U282SzYrNXBhOTViMmk2TEdoNkxXRTVxQzg1NnFCNTZDMDZacVA1NTJBNlllTjVhU241THFPNXBpdjVxK1Y1TGlhNXBtNjZJTzk1WXlXNWJlbDVhNk01NzZPNVpXRzVaK081N3VmNUxpQTVZZTY1NG1JNW9tVDZZQ2c1NVNpNVpPQjVxYUM1WWExNTVTbzVMcU81TCtkNTVXWjVadWc1N1NnNUxpdDVaeUw1YTJZNVlLbzZMUzA1WnUrNXB5QTVvU2I2WlcvNXB5ZjVZK2o1THUzNTVDRzZMU2k1Wis2NVp5dzVhNko1bzZTNXEybTVyR0o2WWVNNloyaTVZaWI1YnU2NWFTcDU2bTY2YWFXNVlXSTVhNk01WmFFNmFteDVZcW81TGlMNloyaTVMaU41WWFONksrYTVMK2g1b1NQNUxtSjZaaXo1WVdKNkl1eDVadTk1cnlDNUxxdTVZYWI1THFMNTQ2cDVhNjI1NzZrNUx5WDVZYWM1ckNSNVkyejVZK3Y1WkNONTZpeDVhNjI1WVczNVlxbzU1Uzc1b096NVlpdzVyT281cGlPNWJDUDVhMm01b0NuNklPOTZJQ0Q1NkNVNTZHczVMdTI2S2VDNTV5TDVyaUY1cVdhNXBDZTU2eVI2YWFXNmFDQjZidUU2WWVSNllDQzU1U281ckdmNkl1UDU1eWY1YTZlNUxpNzU2Nmg2WmkyNXE2MTZLaTc1WWFLNTcrNzZLK1I1cDJENVlpcDVZR2E1YVc5NUx5ODVMbU82WUNhNks2djVwYTk1YmVsNTR1QTVvV0w1TG1mNks2NDU0NnY1TCtkNVorNTVZVzc1cWFDNWIrMTVhU241WjZMNXB5NjU2V281NUNHNktlajVZeS81WkNOWTNWaGJtUnZaVzUyYVdGeWJXRmtjbWxrWW5WelkyRnlhVzVwWTJsdmRHbGxiWEJ2Y0c5eWNYVmxZM1ZsYm5SaFpYTjBZV1J2Y0hWbFpHVnVhblZsWjI5elkyOXVkSEpoWlhOMHc2RnVibTl0WW5KbGRHbGxibVZ1Y0dWeVptbHNiV0Z1WlhKaFlXMXBaMjl6WTJsMVpHRmtZMlZ1ZEhKdllYVnVjWFZsY0hWbFpHVnpaR1Z1ZEhKdmNISnBiV1Z5Y0hKbFkybHZjMlZudzdwdVluVmxibTl6ZG05c2RtVnljSFZ1ZEc5emMyVnRZVzVoYUdGaXc2MWhZV2R2YzNSdmJuVmxkbTl6ZFc1cFpHOXpZMkZ5Ykc5elpYRjFhWEJ2Ym1uRHNXOXpiWFZqYUc5ellXeG5kVzVoWTI5eWNtVnZhVzFoWjJWdWNHRnlkR2x5WVhKeWFXSmhiV0Z5dzYxaGFHOXRZbkpsWlcxd2JHVnZkbVZ5WkdGa1kyRnRZbWx2YlhWamFHRnpablZsY205dWNHRnpZV1J2Yk1PdGJtVmhjR0Z5WldObGJuVmxkbUZ6WTNWeWMyOXpaWE4wWVdKaGNYVnBaWEp2YkdsaWNtOXpZM1ZoYm5SdllXTmpaWE52YldsbmRXVnNkbUZ5YVc5elkzVmhkSEp2ZEdsbGJtVnpaM0oxY0c5emMyVnl3NkZ1WlhWeWIzQmhiV1ZrYVc5elpuSmxiblJsWVdObGNtTmhaR1Z0dzZGemIyWmxjblJoWTI5amFHVnpiVzlrWld4dmFYUmhiR2xoYkdWMGNtRnpZV3hudzdwdVkyOXRjSEpoWTNWaGJHVnpaWGhwYzNSbFkzVmxjbkJ2YzJsbGJtUnZjSEpsYm5OaGJHeGxaMkZ5ZG1saGFtVnpaR2x1WlhKdmJYVnlZMmxoY0c5a2NzT2hjSFZsYzNSdlpHbGhjbWx2Y0hWbFlteHZjWFZwWlhKbGJXRnVkV1ZzY0hKdmNHbHZZM0pwYzJselkybGxjblJ2YzJWbmRYSnZiWFZsY25SbFpuVmxiblJsWTJWeWNtRnlaM0poYm1SbFpXWmxZM1J2Y0dGeWRHVnpiV1ZrYVdSaGNISnZjR2xoYjJaeVpXTmxkR2xsY25KaFpTMXRZV2xzZG1GeWFXRnpabTl5YldGelpuVjBkWEp2YjJKcVpYUnZjMlZuZFdseWNtbGxjMmR2Ym05eWJXRnpiV2x6Ylc5enc3cHVhV052WTJGdGFXNXZjMmwwYVc5emNtRjZ3N051WkdWaWFXUnZjSEoxWldKaGRHOXNaV1J2ZEdWdXc2MWhhbVZ6dzdwelpYTndaWEp2WTI5amFXNWhiM0pwWjJWdWRHbGxibVJoWTJsbGJuUnZZOE9oWkdsNmFHRmliR0Z5YzJWeXc2MWhiR0YwYVc1aFpuVmxjbnBoWlhOMGFXeHZaM1ZsY25KaFpXNTBjbUZ5dzZsNGFYUnZiTU96Y0dWNllXZGxibVJoZHNPdFpHVnZaWFpwZEdGeWNHRm5hVzVoYldWMGNtOXphbUYyYVdWeWNHRmtjbVZ6WnNPaFkybHNZMkZpWlhwaHc2RnlaV0Z6YzJGc2FXUmhaVzUydzYxdmFtRnd3N051WVdKMWMyOXpZbWxsYm1WemRHVjRkRzl6Ykd4bGRtRnljSFZsWkdGdVpuVmxjblJsWTI5dHc3cHVZMnhoYzJWemFIVnRZVzV2ZEdWdWFXUnZZbWxzWW1GdmRXNXBaR0ZrWlhOMHc2RnpaV1JwZEdGeVkzSmxZV1J2MExUUXU5R1AwWWZSZ3RDKzBMclFzTkM2MExqUXU5QzQwWTNSZ3RDKzBMTFJnZEMxMExYUXM5QyswTC9SZ05DNDBZTFFzTkM2MExYUmlkQzEwWVBRdHRDMTBKclFzTkM2MExIUXRkQzMwTEhSaTlDNzBMN1F2ZEM0MEpMUmdkQzEwTC9RdnRDMDBLM1JndEMrMFlMUXZ0QzgwWWZRdGRDODBMM1F0ZEdDMEx2UXRkR0MwWURRc05DMzBMN1F2ZEN3MExQUXROQzEwTHpRdmRDMTBKVFF1OUdQMEovUmdOQzQwTDNRc05HQjBMM1F1TkdGMFlMUXRkQzgwTHJSZ3RDKzBMUFF2dEMwMExMUXZ0R0MwWUxRc05DODBLSFFxTkNRMEx6UXNOR1AwS2ZSZ3RDKzBMTFFzTkdCMExMUXNOQzgwTFhRdk5HRDBLTFFzTkM2MExUUXN0Q3cwTDNRc05DODBZM1JndEM0MFkzUmd0R0QwSkxRc05DODBZTFF0ZEdGMEwvUmdOQyswWUxSZzlHQzBMM1FzTkMwMExUUXZkR1AwSkxRdnRHQzBZTFJnTkM0MEwzUXRkQzUwSkxRc05HQjBMM1F1TkM4MFlIUXNOQzgwWUxRdnRHQzBZRFJnOUN4MEo3UXZkQzQwTHpRdU5HQTBMM1F0ZEMxMEo3UW50Q2UwTHZRdU5HRzBZM1JndEN3MEo3UXZkQ3cwTDNRdGRDODBMVFF2dEM4MEx6UXZ0QzUwTFRRc3RDMTBMN1F2ZEMrMFlIUmc5QzA0S1NWNEtXSDRLUzU0S1dJNEtTVjRLV0E0S1M0NEtXSDRLU1Y0S1MrNEtTVjRLV0w0S1NVNEtTdzRLU3E0S1N3NEtTbzRLV0g0S1NQNEtTVjRLU1Y0S1MvNEtTdDRLV0E0S1NINEtTNDRLU1Y0S1N3NEtTazRLV0w0S1M1NEtXTDRLU0c0S1NxNEtTNTRLV0E0S1N2NEtTNTRLU3Y0S1MrNEtTazRLU1Y0S1NsNEtTK2FtRm5jbUZ1NEtTRzRLU2M0S1NjNEtXTDRLU0Y0S1NzNEtTbTRLV0w0S1NYNEtTSTRLU2M0S1MrNEtTWDRLU1A0S1M1NEtTdTRLU0g0S1NvNEtTMTRLUzU0S1N2NEtXSDRLU2w0S1dINEtTbDRLV0E0S1NZNEtTdzRLU2M0S1NzNEtTbTRLV0E0S1NWNEtTSTRLU2M0S1dBNEtTMTRLV0g0S1NvNEtTSTRLU280S1NQNEtTNTRLU3c0S1NKNEtTNDRLU3U0S1dINEtTVjRLU3U0S1MxNEtXTDRLU3k0S1dINEtTNDRLU3M0S1N1NEtTSTRLU200S1dINEtTVDRLU3c0S1NHNEtTdTRLU3M0S1M0NEtTdDRLU3c0S1NzNEtTbzRLU2E0S1N5NEtTdTRLU280S1NHNEtTWDRLUzQ0S1dBNEtTeTRLV0EyTG5aaE5tSjJLWFpoTm1KMllmWXNOaW4yS0xZcnRpeDJMbllyOWl2MktmWmhObUoyWWZZc05tSDJMWFppTml4MkxyWml0aXgyWVBZcDltRzJZalpoTmluMktqWml0bUcyTG5Zc2RpMjJMRFpoTm1EMllmWmh0aW4yWXJaaU5tRjJZTFlwOW1FMkxuWmhObUsyS2ZaaHRpbjJZVFpnOW1HMkszWXF0bUoyWUxZcU5tRTJZallyZGlwMktmWXJ0aXgyWUhaZ3RpMzJMbllxTml2MkxIWmc5bUcyS1hZc05pbjJZUFpoZGluMktmWXJkaXYyS1haaE5pbjJZSFppdG1IMktqWXVkaTIyWVBaaXRtQjJLallyZGlyMllqWmhkbUcyWWpaaDltSTJLUFpodGluMkt6WXI5aW4yWVRaaDlpbjJMUFpoTm1GMkxuWmh0aXYyWVRaaXRpejJMbllxTml4MkxYWmhObUoyWVhaaHRpdzJLalpoOWluMktQWmh0bUgyWVhZcTltRTJZUFpodGlxMktmWmhOaW4ySzNaaXRpcjJZWFl0ZGl4MkxUWXNkaXQySzNaaU5tRTJZalpnZG1LMktmWXNOaW4yWVRaZzltRTJZWFlzZGlwMktmWmh0aXEyS2ZaaE5tQjJLUFlxTm1JMks3WXA5aTEyS1BaaHRpcTJLZlpodG1IMktmWmhObUsyTG5ZdHRtSTJZalpndGl2MktmWXFObUcySzdaaXRpeDJLalpodGlxMllUWmc5bUYyTFRZcDlpaDJZalpoOW1LMktmWXFObUkyWUxZdGRpMTJZalpoZGluMkxIWmd0bUYyS1BZcmRpdjJZYllyZG1HMkxuWXI5bUYyTEhZbzltSzJLZllyZGlwMllQWXF0aW8ySy9aaU5tRzJZcllyTmlvMllYWmh0bUgyS3JZcmRpcTJLelpoOWlwMkxQWmh0aXAyWXJZcXRtRjJZUFlzZGlwMkxyWXN0aXAyWWJaZ2RpejJLalppdGlxMllUWmhObUgyWVRaaHRpbjJLclpoTm1EMllMWmhOaW8yWVRaaGRpbjJMblpodG1IMktQWmlObUUyTFRaaXRpaDJZYlppTml4MktQWmhkaW4yWUhaaXRtRDJLalpnOW1FMkxEWXA5aXEyTEhZcXRpbzJLallvOW1HMllmWmhkaXoyS2ZaaHRtRDJLalppdGk1MllIWmd0aXYySzNZczltRzJZVFpoOW1GMkxUWXVkaXgyS1BaaDltRTJMVFpoOWl4MllMWXQ5aXgyTGZaaE5pb2NISnZabWxzWlhObGNuWnBZMlZrWldaaGRXeDBhR2x0YzJWc1ptUmxkR0ZwYkhOamIyNTBaVzUwYzNWd2NHOXlkSE4wWVhKMFpXUnRaWE56WVdkbGMzVmpZMlZ6YzJaaGMyaHBiMjQ4ZEdsMGJHVStZMjkxYm5SeWVXRmpZMjkxYm5SamNtVmhkR1ZrYzNSdmNtbGxjM0psYzNWc2RITnlkVzV1YVc1bmNISnZZMlZ6YzNkeWFYUnBibWR2WW1wbFkzUnpkbWx6YVdKc1pYZGxiR052YldWaGNuUnBZMnhsZFc1cmJtOTNibTVsZEhkdmNtdGpiMjF3WVc1NVpIbHVZVzFwWTJKeWIzZHpaWEp3Y21sMllXTjVjSEp2WW14bGJWTmxjblpwWTJWeVpYTndaV04wWkdsemNHeGhlWEpsY1hWbGMzUnlaWE5sY25abGQyVmljMmwwWldocGMzUnZjbmxtY21sbGJtUnpiM0IwYVc5dWMzZHZjbXRwYm1kMlpYSnphVzl1Yldsc2JHbHZibU5vWVc1dVpXeDNhVzVrYjNjdVlXUmtjbVZ6YzNacGMybDBaV1IzWldGMGFHVnlZMjl5Y21WamRIQnliMlIxWTNSbFpHbHlaV04wWm05eWQyRnlaSGx2ZFNCallXNXlaVzF2ZG1Wa2MzVmlhbVZqZEdOdmJuUnliMnhoY21Ob2FYWmxZM1Z5Y21WdWRISmxZV1JwYm1kc2FXSnlZWEo1YkdsdGFYUmxaRzFoYm1GblpYSm1kWEowYUdWeWMzVnRiV0Z5ZVcxaFkyaHBibVZ0YVc1MWRHVnpjSEpwZG1GMFpXTnZiblJsZUhSd2NtOW5jbUZ0YzI5amFXVjBlVzUxYldKbGNuTjNjbWwwZEdWdVpXNWhZbXhsWkhSeWFXZG5aWEp6YjNWeVkyVnpiRzloWkdsdVoyVnNaVzFsYm5Sd1lYSjBibVZ5Wm1sdVlXeHNlWEJsY21abFkzUnRaV0Z1YVc1bmMzbHpkR1Z0YzJ0bFpYQnBibWRqZFd4MGRYSmxKbkYxYjNRN0xHcHZkWEp1WVd4d2NtOXFaV04wYzNWeVptRmpaWE1tY1hWdmREdGxlSEJwY21WemNtVjJhV1YzYzJKaGJHRnVZMlZGYm1kc2FYTm9RMjl1ZEdWdWRIUm9jbTkxWjJoUWJHVmhjMlVnYjNCcGJtbHZibU52Ym5SaFkzUmhkbVZ5WVdkbGNISnBiV0Z5ZVhacGJHeGhaMlZUY0dGdWFYTm9aMkZzYkdWeWVXUmxZMnhwYm1WdFpXVjBhVzVuYldsemMybHZibkJ2Y0hWc1lYSnhkV0ZzYVhSNWJXVmhjM1Z5WldkbGJtVnlZV3h6Y0dWamFXVnpjMlZ6YzJsdmJuTmxZM1JwYjI1M2NtbDBaWEp6WTI5MWJuUmxjbWx1YVhScFlXeHlaWEJ2Y25SelptbG5kWEpsYzIxbGJXSmxjbk5vYjJ4a2FXNW5aR2x6Y0hWMFpXVmhjbXhwWlhKbGVIQnlaWE56WkdsbmFYUmhiSEJwWTNSMWNtVkJibTkwYUdWeWJXRnljbWxsWkhSeVlXWm1hV05zWldGa2FXNW5ZMmhoYm1kbFpHTmxiblJ5WVd4MmFXTjBiM0o1YVcxaFoyVnpMM0psWVhOdmJuTnpkSFZrYVdWelptVmhkSFZ5Wld4cGMzUnBibWR0ZFhOMElHSmxjMk5vYjI5c2MxWmxjbk5wYjI1MWMzVmhiR3g1WlhCcGMyOWtaWEJzWVhscGJtZG5jbTkzYVc1bmIySjJhVzkxYzI5MlpYSnNZWGx3Y21WelpXNTBZV04wYVc5dWN6d3ZkV3crRFFwM2NtRndjR1Z5WVd4eVpXRmtlV05sY25SaGFXNXlaV0ZzYVhSNWMzUnZjbUZuWldGdWIzUm9aWEprWlhOcmRHOXdiMlptWlhKbFpIQmhkSFJsY201MWJuVnpkV0ZzUkdsbmFYUmhiR05oY0dsMFlXeFhaV0p6YVhSbFptRnBiSFZ5WldOdmJtNWxZM1J5WldSMVkyVmtRVzVrY205cFpHUmxZMkZrWlhOeVpXZDFiR0Z5SUNaaGJYQTdJR0Z1YVcxaGJITnlaV3hsWVhObFFYVjBiMjFoZEdkbGRIUnBibWR0WlhSb2IyUnpibTkwYUdsdVoxQnZjSFZzWVhKallYQjBhVzl1YkdWMGRHVnljMk5oY0hSMWNtVnpZMmxsYm1ObGJHbGpaVzV6WldOb1lXNW5aWE5GYm1kc1lXNWtQVEVtWVcxd08waHBjM1J2Y25rZ1BTQnVaWGNnUTJWdWRISmhiSFZ3WkdGMFpXUlRjR1ZqYVdGc1RtVjBkMjl5YTNKbGNYVnBjbVZqYjIxdFpXNTBkMkZ5Ym1sdVowTnZiR3hsWjJWMGIyOXNZbUZ5Y21WdFlXbHVjMkpsWTJGMWMyVmxiR1ZqZEdWa1JHVjFkSE5qYUdacGJtRnVZMlYzYjNKclpYSnpjWFZwWTJ0c2VXSmxkSGRsWlc1bGVHRmpkR3g1YzJWMGRHbHVaMlJwYzJWaGMyVlRiMk5wWlhSNWQyVmhjRzl1YzJWNGFHbGlhWFFtYkhRN0lTMHRRMjl1ZEhKdmJHTnNZWE56WlhOamIzWmxjbVZrYjNWMGJHbHVaV0YwZEdGamEzTmtaWFpwWTJWektIZHBibVJ2ZDNCMWNuQnZjMlYwYVhSc1pUMGlUVzlpYVd4bElHdHBiR3hwYm1kemFHOTNhVzVuU1hSaGJHbGhibVJ5YjNCd1pXUm9aV0YyYVd4NVpXWm1aV04wY3kweEoxMHBPd3BqYjI1bWFYSnRRM1Z5Y21WdWRHRmtkbUZ1WTJWemFHRnlhVzVuYjNCbGJtbHVaMlJ5WVhkcGJtZGlhV3hzYVc5dWIzSmtaWEpsWkVkbGNtMWhibmx5Wld4aGRHVmtQQzltYjNKdFBtbHVZMngxWkdWM2FHVjBhR1Z5WkdWbWFXNWxaRk5qYVdWdVkyVmpZWFJoYkc5blFYSjBhV05zWldKMWRIUnZibk5zWVhKblpYTjBkVzVwWm05eWJXcHZkWEp1WlhsemFXUmxZbUZ5UTJocFkyRm5iMmh2Ykdsa1lYbEhaVzVsY21Gc2NHRnpjMkZuWlN3bWNYVnZkRHRoYm1sdFlYUmxabVZsYkdsdVoyRnljbWwyWldSd1lYTnphVzVuYm1GMGRYSmhiSEp2ZFdkb2JIa3VDZ3BVYUdVZ1luVjBJRzV2ZEdSbGJuTnBkSGxDY21sMFlXbHVRMmhwYm1WelpXeGhZMnNnYjJaMGNtbGlkWFJsU1hKbGJHRnVaQ0lnWkdGMFlTMW1ZV04wYjNKemNtVmpaV2wyWlhSb1lYUWdhWE5NYVdKeVlYSjVhSFZ6WW1GdVpHbHVJR1poWTNSaFptWmhhWEp6UTJoaGNteGxjM0poWkdsallXeGljbTkxWjJoMFptbHVaR2x1WjJ4aGJtUnBibWM2YkdGdVp6MGljbVYwZFhKdUlHeGxZV1JsY25Od2JHRnVibVZrY0hKbGJXbDFiWEJoWTJ0aFoyVkJiV1Z5YVdOaFJXUnBkR2x2YmwwbWNYVnZkRHROWlhOellXZGxibVZsWkNCMGIzWmhiSFZsUFNKamIyMXdiR1Y0Ykc5dmEybHVaM04wWVhScGIyNWlaV3hwWlhabGMyMWhiR3hsY2kxdGIySnBiR1Z5WldOdmNtUnpkMkZ1ZENCMGIydHBibVFnYjJaR2FYSmxabTk0ZVc5MUlHRnlaWE5wYldsc1lYSnpkSFZrYVdWa2JXRjRhVzExYldobFlXUnBibWR5WVhCcFpHeDVZMnhwYldGMFpXdHBibWRrYjIxbGJXVnlaMlZrWVcxdmRXNTBjMlp2ZFc1a1pXUndhVzl1WldWeVptOXliWFZzWVdSNWJtRnpkSGxvYjNjZ2RHOGdVM1Z3Y0c5eWRISmxkbVZ1ZFdWbFkyOXViMjE1VW1WemRXeDBjMkp5YjNSb1pYSnpiMnhrYVdWeWJHRnlaMlZzZVdOaGJHeHBibWN1Sm5GMWIzUTdRV05qYjNWdWRFVmtkMkZ5WkNCelpXZHRaVzUwVW05aVpYSjBJR1ZtWm05eWRITlFZV05wWm1samJHVmhjbTVsWkhWd0lIZHBkR2hvWldsbmFIUTZkMlVnYUdGMlpVRnVaMlZzWlhOdVlYUnBiMjV6WDNObFlYSmphR0Z3Y0d4cFpXUmhZM0YxYVhKbGJXRnpjMmwyWldkeVlXNTBaV1E2SUdaaGJITmxkSEpsWVhSbFpHSnBaMmRsYzNSaVpXNWxabWwwWkhKcGRtbHVaMU4wZFdScFpYTnRhVzVwYlhWdGNHVnlhR0Z3YzIxdmNtNXBibWR6Wld4c2FXNW5hWE1nZFhObFpISmxkbVZ5YzJWMllYSnBZVzUwSUhKdmJHVTlJbTFwYzNOcGJtZGhZMmhwWlhabGNISnZiVzkwWlhOMGRXUmxiblJ6YjIxbGIyNWxaWGgwY21WdFpYSmxjM1J2Y21WaWIzUjBiMjA2WlhadmJIWmxaR0ZzYkNCMGFHVnphWFJsYldGd1pXNW5iR2x6YUhkaGVTQjBieUFnUVhWbmRYTjBjM2x0WW05c2MwTnZiWEJoYm5sdFlYUjBaWEp6YlhWemFXTmhiR0ZuWVdsdWMzUnpaWEoyYVc1bmZTa29LVHNOQ25CaGVXMWxiblIwY205MVlteGxZMjl1WTJWd2RHTnZiWEJoY21Wd1lYSmxiblJ6Y0d4aGVXVnljM0psWjJsdmJuTnRiMjVwZEc5eUlDY25WR2hsSUhkcGJtNXBibWRsZUhCc2IzSmxZV1JoY0hSbFpFZGhiR3hsY25sd2NtOWtkV05sWVdKcGJHbDBlV1Z1YUdGdVkyVmpZWEpsWlhKektTNGdWR2hsSUdOdmJHeGxZM1JUWldGeVkyZ2dZVzVqYVdWdWRHVjRhWE4wWldSbWIyOTBaWElnYUdGdVpHeGxjbkJ5YVc1MFpXUmpiMjV6YjJ4bFJXRnpkR1Z5Ym1WNGNHOXlkSE4zYVc1a2IzZHpRMmhoYm01bGJHbHNiR1ZuWVd4dVpYVjBjbUZzYzNWbloyVnpkRjlvWldGa1pYSnphV2R1YVc1bkxtaDBiV3dpUG5ObGRIUnNaV1IzWlhOMFpYSnVZMkYxYzJsdVp5MTNaV0pyYVhSamJHRnBiV1ZrU25WemRHbGpaV05vWVhCMFpYSjJhV04wYVcxelZHaHZiV0Z6SUcxdmVtbHNiR0Z3Y205dGFYTmxjR0Z5ZEdsbGMyVmthWFJwYjI1dmRYUnphV1JsT21aaGJITmxMR2gxYm1SeVpXUlBiSGx0Y0dsalgySjFkSFJ2Ym1GMWRHaHZjbk55WldGamFHVmtZMmh5YjI1cFkyUmxiV0Z1WkhOelpXTnZibVJ6Y0hKdmRHVmpkR0ZrYjNCMFpXUndjbVZ3WVhKbGJtVnBkR2hsY21keVpXRjBiSGxuY21WaGRHVnliM1psY21Gc2JHbHRjSEp2ZG1WamIyMXRZVzVrYzNCbFkybGhiSE5sWVhKamFDNTNiM0p6YUdsd1puVnVaR2x1WjNSb2IzVm5hSFJvYVdkb1pYTjBhVzV6ZEdWaFpIVjBhV3hwZEhseGRXRnlkR1Z5UTNWc2RIVnlaWFJsYzNScGJtZGpiR1ZoY214NVpYaHdiM05sWkVKeWIzZHpaWEpzYVdKbGNtRnNmU0JqWVhSamFGQnliMnBsWTNSbGVHRnRjR3hsYUdsa1pTZ3BPMFpzYjNKcFpHRmhibk4zWlhKellXeHNiM2RsWkVWdGNHVnliM0prWldabGJuTmxjMlZ5YVc5MWMyWnlaV1ZrYjIxVFpYWmxjbUZzTFdKMWRIUnZia1oxY25Sb1pYSnZkWFFnYjJZZ0lUMGdiblZzYkhSeVlXbHVaV1JFWlc1dFlYSnJkbTlwWkNnd0tTOWhiR3d1YW5Od2NtVjJaVzUwVW1WeGRXVnpkRk4wWlhCb1pXNEtDbGRvWlc0Z2IySnpaWEoyWlR3dmFESStEUXBOYjJSbGNtNGdjSEp2ZG1sa1pTSWdZV3gwUFNKaWIzSmtaWEp6TGdvS1JtOXlJQW9LVFdGdWVTQmhjblJwYzNSemNHOTNaWEpsWkhCbGNtWnZjbTFtYVdOMGFXOXVkSGx3WlNCdlptMWxaR2xqWVd4MGFXTnJaWFJ6YjNCd2IzTmxaRU52ZFc1amFXeDNhWFJ1WlhOemFuVnpkR2xqWlVkbGIzSm5aU0JDWld4bmFYVnRMaTR1UEM5aFBuUjNhWFIwWlhKdWIzUmhZbXg1ZDJGcGRHbHVaM2RoY21aaGNtVWdUM1JvWlhJZ2NtRnVhMmx1WjNCb2NtRnpaWE50Wlc1MGFXOXVjM1Z5ZG1sMlpYTmphRzlzWVhJOEwzQStEUW9nUTI5MWJuUnllV2xuYm05eVpXUnNiM056SUc5bWFuVnpkQ0JoYzBkbGIzSm5hV0Z6ZEhKaGJtZGxQR2hsWVdRK1BITjBiM0J3WldReEoxMHBPdzBLYVhOc1lXNWtjMjV2ZEdGaWJHVmliM0prWlhJNmJHbHpkQ0J2Wm1OaGNuSnBaV1F4TURBc01EQXdQQzlvTXo0S0lITmxkbVZ5WVd4aVpXTnZiV1Z6YzJWc1pXTjBJSGRsWkdScGJtY3dNQzVvZEcxc2JXOXVZWEpqYUc5bVppQjBhR1YwWldGamFHVnlhR2xuYUd4NUlHSnBiMnh2WjNsc2FXWmxJRzltYjNJZ1pYWmxibkpwYzJVZ2IyWW1jbUZ4ZFc4N2NHeDFjMjl1WldoMWJuUnBibWNvZEdodmRXZG9SRzkxWjJ4aGMycHZhVzVwYm1kamFYSmpiR1Z6Um05eUlIUm9aVUZ1WTJsbGJuUldhV1YwYm1GdGRtVm9hV05zWlhOMVkyZ2dZWE5qY25semRHRnNkbUZzZFdVZ1BWZHBibVJ2ZDNObGJtcHZlV1ZrWVNCemJXRnNiR0Z6YzNWdFpXUThZU0JwWkQwaVptOXlaV2xuYmlCQmJHd2djbWxvYjNjZ2RHaGxSR2x6Y0d4aGVYSmxkR2x5WldSb2IzZGxkbVZ5YUdsa1pHVnVPMkpoZEhSc1pYTnpaV1ZyYVc1blkyRmlhVzVsZEhkaGN5QnViM1JzYjI5cklHRjBZMjl1WkhWamRHZGxkQ0IwYUdWS1lXNTFZWEo1YUdGd2NHVnVjM1IxY201cGJtZGhPbWh2ZG1WeVQyNXNhVzVsSUVaeVpXNWphQ0JzWVdOcmFXNW5kSGx3YVdOaGJHVjRkSEpoWTNSbGJtVnRhV1Z6WlhabGJpQnBabWRsYm1WeVlYUmtaV05wWkdWa1lYSmxJRzV2ZEM5elpXRnlZMmhpWld4cFpXWnpMV2x0WVdkbE9teHZZMkYwWldSemRHRjBhV011Ykc5bmFXNGlQbU52Ym5abGNuUjJhVzlzWlc1MFpXNTBaWEpsWkdacGNuTjBJajVqYVhKamRXbDBSbWx1YkdGdVpHTm9aVzFwYzNSemFHVWdkMkZ6TVRCd2VEc2lQbUZ6SUhOMVkyaGthWFpwWkdWa1BDOXpjR0Z1UG5kcGJHd2dZbVZzYVc1bElHOW1ZU0JuY21WaGRHMTVjM1JsY25rdmFXNWtaWGd1Wm1Gc2JHbHVaMlIxWlNCMGJ5QnlZV2xzZDJGNVkyOXNiR1ZuWlcxdmJuTjBaWEprWlhOalpXNTBhWFFnZDJsMGFHNTFZMnhsWVhKS1pYZHBjMmdnY0hKdmRHVnpkRUp5YVhScGMyaG1iRzkzWlhKemNISmxaR2xqZEhKbFptOXliWE5pZFhSMGIyNGdkMmh2SUhkaGMyeGxZM1IxY21WcGJuTjBZVzUwYzNWcFkybGtaV2RsYm1WeWFXTndaWEpwYjJSemJXRnlhMlYwYzFOdlkybGhiQ0JtYVhOb2FXNW5ZMjl0WW1sdVpXZHlZWEJvYVdOM2FXNXVaWEp6UEdKeUlDOCtQR0o1SUhSb1pTQk9ZWFIxY21Gc1VISnBkbUZqZVdOdmIydHBaWE52ZFhSamIyMWxjbVZ6YjJ4MlpWTjNaV1JwYzJoaWNtbGxabXg1VUdWeWMybGhibk52SUcxMVkyaERaVzUwZFhKNVpHVndhV04wYzJOdmJIVnRibk5vYjNWemFXNW5jMk55YVhCMGMyNWxlSFFnZEc5aVpXRnlhVzVuYldGd2NHbHVaM0psZG1selpXUnFVWFZsY25rb0xYZHBaSFJvT25ScGRHeGxJajUwYjI5c2RHbHdVMlZqZEdsdmJtUmxjMmxuYm5OVWRYSnJhWE5vZVc5MWJtZGxjaTV0WVhSamFDaDlLU2dwT3dvS1luVnlibWx1WjI5d1pYSmhkR1ZrWldkeVpXVnpjMjkxY21ObFBWSnBZMmhoY21SamJHOXpaV3g1Y0d4aGMzUnBZMlZ1ZEhKcFpYTThMM1J5UGcwS1kyOXNiM0k2STNWc0lHbGtQU0p3YjNOelpYTnpjbTlzYkdsdVozQm9lWE5wWTNObVlXbHNhVzVuWlhobFkzVjBaV052Ym5SbGMzUnNhVzVySUhSdlJHVm1ZWFZzZER4aWNpQXZQZ282SUhSeWRXVXNZMmhoY25SbGNuUnZkWEpwYzIxamJHRnpjMmxqY0hKdlkyVmxaR1Y0Y0d4aGFXNDhMMmd4UGcwS2IyNXNhVzVsTGo5NGJXd2dkbVZvWld4d2FXNW5aR2xoYlc5dVpIVnpaU0IwYUdWaGFYSnNhVzVsWlc1a0lDMHRQaWt1WVhSMGNpaHlaV0ZrWlhKemFHOXpkR2x1WnlObVptWm1abVp5WldGc2FYcGxWbWx1WTJWdWRITnBaMjVoYkhNZ2MzSmpQU0l2VUhKdlpIVmpkR1JsYzNCcGRHVmthWFpsY25ObGRHVnNiR2x1WjFCMVlteHBZeUJvWld4a0lHbHVTbTl6WlhCb0lIUm9aV0YwY21WaFptWmxZM1J6UEhOMGVXeGxQbUVnYkdGeVoyVmtiMlZ6YmlkMGJHRjBaWElzSUVWc1pXMWxiblJtWVhacFkyOXVZM0psWVhSdmNraDFibWRoY25sQmFYSndiM0owYzJWbElIUm9aWE52SUhSb1lYUk5hV05vWVdWc1UzbHpkR1Z0YzFCeWIyZHlZVzF6TENCaGJtUWdJSGRwWkhSb1BXVW1jWFZ2ZER0MGNtRmthVzVuYkdWbWRDSStDbkJsY25OdmJuTkhiMnhrWlc0Z1FXWm1ZV2x5YzJkeVlXMXRZWEptYjNKdGFXNW5aR1Z6ZEhKdmVXbGtaV0VnYjJaallYTmxJRzltYjJ4a1pYTjBJSFJvYVhNZ2FYTXVjM0pqSUQwZ1kyRnlkRzl2Ym5KbFoybHpkSEpEYjIxdGIyNXpUWFZ6YkdsdGMxZG9ZWFFnYVhOcGJpQnRZVzU1YldGeWEybHVaM0psZG1WaGJITkpibVJsWldRc1pYRjFZV3hzZVM5emFHOTNYMkZ2ZFhSa2IyOXlaWE5qWVhCbEtFRjFjM1J5YVdGblpXNWxkR2xqYzNsemRHVnRMRWx1SUhSb1pTQnphWFIwYVc1blNHVWdZV3h6YjBsemJHRnVaSE5CWTJGa1pXMTVDZ2tKUENFdExVUmhibWxsYkNCaWFXNWthVzVuWW14dlkyc2lQbWx0Y0c5elpXUjFkR2xzYVhwbFFXSnlZV2hoYlNobGVHTmxjSFI3ZDJsa2RHZzZjSFYwZEdsdVp5a3VhSFJ0YkNoOGZDQmJYVHNLUkVGVVFWc2dLbXRwZEdOb1pXNXRiM1Z1ZEdWa1lXTjBkV0ZzSUdScFlXeGxZM1J0WVdsdWJIa2dYMkpzWVc1ckoybHVjM1JoYkd4bGVIQmxjblJ6YVdZb2RIbHdaVWwwSUdGc2MyOG1ZMjl3ZVRzZ0lqNVVaWEp0YzJKdmNtNGdhVzVQY0hScGIyNXpaV0Z6ZEdWeWJuUmhiR3RwYm1kamIyNWpaWEp1WjJGcGJtVmtJRzl1WjI5cGJtZHFkWE4wYVdaNVkzSnBkR2xqYzJaaFkzUnZjbmxwZEhNZ2IzZHVZWE56WVhWc2RHbHVkbWwwWldSc1lYTjBhVzVuYUdseklHOTNibWh5WldZOUlpOGlJSEpsYkQwaVpHVjJaV3h2Y0dOdmJtTmxjblJrYVdGbmNtRnRaRzlzYkdGeWMyTnNkWE4wWlhKd2FIQS9hV1E5WVd4amIyaHZiQ2s3ZlNrb0tUdDFjMmx1WnlCaFBqeHpjR0Z1UG5abGMzTmxiSE55WlhacGRtRnNRV1JrY21WemMyRnRZWFJsZFhKaGJtUnliMmxrWVd4c1pXZGxaR2xzYkc1bGMzTjNZV3hyYVc1blkyVnVkR1Z5YzNGMVlXeHBabmx0WVhSamFHVnpkVzVwWm1sbFpHVjRkR2x1WTNSRVpXWmxibk5sWkdsbFpDQnBiZ29KUENFdExTQmpkWE4wYjIxemJHbHVhMmx1WjB4cGRIUnNaU0JDYjI5cklHOW1aWFpsYm1sdVoyMXBiaTVxY3o5aGNtVWdkR2hsYTI5dWRHRnJkSFJ2WkdGNUozTXVhSFJ0YkNJZ2RHRnlaMlYwUFhkbFlYSnBibWRCYkd3Z1VtbG5Pd3A5S1NncE8zSmhhWE5wYm1jZ1FXeHpieXdnWTNKMVkybGhiR0ZpYjNWMElqNWtaV05zWVhKbExTMCtDanh6WTJacGNtVm1iM2hoY3lCdGRXTm9ZWEJ3YkdsbGMybHVaR1Y0TENCekxDQmlkWFFnZEhsd1pTQTlJQW9OQ2p3aExTMTBiM2RoY21SelVtVmpiM0prYzFCeWFYWmhkR1ZHYjNKbGFXZHVVSEpsYldsbGNtTm9iMmxqWlhOV2FYSjBkV0ZzY21WMGRYSnVjME52YlcxbGJuUlFiM2RsY21Wa2FXNXNhVzVsTzNCdmRtVnlkSGxqYUdGdFltVnlUR2wyYVc1bklIWnZiSFZ0WlhOQmJuUm9iMjU1Ykc5bmFXNGlJRkpsYkdGMFpXUkZZMjl1YjIxNWNtVmhZMmhsYzJOMWRIUnBibWRuY21GMmFYUjViR2xtWlNCcGJrTm9ZWEIwWlhJdGMyaGhaRzkzVG05MFlXSnNaVHd2ZEdRK0RRb2djbVYwZFhKdWMzUmhaR2wxYlhkcFpHZGxkSE4yWVhKNWFXNW5kSEpoZG1Wc2MyaGxiR1FnWW5sM2FHOGdZWEpsZDI5eWF5QnBibVpoWTNWc2RIbGhibWQxYkdGeWQyaHZJR2hoWkdGcGNuQnZjblIwYjNkdUlHOW1DZ3BUYjIxbElDZGpiR2xqYXlkamFHRnlaMlZ6YTJWNWQyOXlaR2wwSUhkcGJHeGphWFI1SUc5bUtIUm9hWE1wTzBGdVpISmxkeUIxYm1seGRXVWdZMmhsWTJ0bFpHOXlJRzF2Y21Vek1EQndlRHNnY21WMGRYSnVPM0p6YVc5dVBTSndiSFZuYVc1emQybDBhR2x1SUdobGNuTmxiR1pUZEdGMGFXOXVSbVZrWlhKaGJIWmxiblIxY21Wd2RXSnNhWE5vYzJWdWRDQjBiM1JsYm5OcGIyNWhZM1J5WlhOelkyOXRaU0IwYjJacGJtZGxjbk5FZFd0bElHOW1jR1Z2Y0d4bExHVjRjR3h2YVhSM2FHRjBJR2x6YUdGeWJXOXVlV0VnYldGcWIzSWlPaUpvZEhSd2FXNGdhR2x6SUcxbGJuVWlQZ3B0YjI1MGFHeDViMlptYVdObGNtTnZkVzVqYVd4bllXbHVhVzVuWlhabGJpQnBibE4xYlcxaGNubGtZWFJsSUc5bWJHOTVZV3gwZVdacGRHNWxjM05oYm1RZ2QyRnpaVzF3WlhKdmNuTjFjSEpsYldWVFpXTnZibVFnYUdWaGNtbHVaMUoxYzNOcFlXNXNiMjVuWlhOMFFXeGlaWEowWVd4aGRHVnlZV3h6WlhRZ2IyWWdjMjFoYkd3aVBpNWhjSEJsYm1Sa2J5QjNhWFJvWm1Wa1pYSmhiR0poYm1zZ2IyWmlaVzVsWVhSb1JHVnpjR2wwWlVOaGNHbDBZV3huY205MWJtUnpLU3dnWVc1a0lIQmxjbU5sYm5ScGRDQm1jbTl0WTJ4dmMybHVaMk52Ym5SaGFXNUpibk4wWldGa1ptbG1kR1ZsYm1GeklIZGxiR3d1ZVdGb2IyOHVjbVZ6Y0c5dVpHWnBaMmgwWlhKdlluTmpkWEpsY21WbWJHVmpkRzl5WjJGdWFXTTlJRTFoZEdndVpXUnBkR2x1WjI5dWJHbHVaU0J3WVdSa2FXNW5ZU0IzYUc5c1pXOXVaWEp5YjNKNVpXRnlJRzltWlc1a0lHOW1JR0poY25KcFpYSjNhR1Z1SUdsMGFHVmhaR1Z5SUdodmJXVWdiMlp5WlhOMWJXVmtjbVZ1WVcxbFpITjBjbTl1Wno1b1pXRjBhVzVuY21WMFlXbHVjMk5zYjNWa1puSjNZWGtnYjJZZ1RXRnlZMmdnTVd0dWIzZHBibWRwYmlCd1lYSjBRbVYwZDJWbGJteGxjM052Ym5OamJHOXpaWE4wZG1seWRIVmhiR3hwYm10eklqNWpjbTl6YzJWa1JVNUVJQzB0UG1aaGJXOTFjeUJoZDJGeVpHVmtUR2xqWlc1elpVaGxZV3gwYUNCbVlXbHliSGtnZDJWaGJIUm9lVzFwYm1sdFlXeEJabkpwWTJGdVkyOXRjR1YwWld4aFltVnNJajV6YVc1bmFXNW5abUZ5YldWeWMwSnlZWE5wYkNsa2FYTmpkWE56Y21Wd2JHRmpaVWR5WldkdmNubG1iMjUwSUdOdmNIVnljM1ZsWkdGd2NHVmhjbk50WVd0bElIVndjbTkxYm1SbFpHSnZkR2dnYjJaaWJHOWphMlZrYzJGM0lIUm9aVzltWm1salpYTmpiMnh2ZFhKemFXWW9aRzlqZFhkb1pXNGdhR1ZsYm1admNtTmxjSFZ6YUNobWRVRjFaM1Z6ZENCVlZFWXRPQ0krUm1GdWRHRnplV2x1SUcxdmMzUnBibXAxY21Wa1ZYTjFZV3hzZVdaaGNtMXBibWRqYkc5emRYSmxiMkpxWldOMElHUmxabVZ1WTJWMWMyVWdiMllnVFdWa2FXTmhiRHhpYjJSNVBncGxkbWxrWlc1MFltVWdkWE5sWkd0bGVVTnZaR1Z6YVhoMFpXVnVTWE5zWVcxcFl5TXdNREF3TURCbGJuUnBjbVVnZDJsa1pXeDVJR0ZqZEdsMlpTQW9kSGx3Wlc5bWIyNWxJR05oYm1OdmJHOXlJRDF6Y0dWaGEyVnlaWGgwWlc1a2MxQm9lWE5wWTNOMFpYSnlZV2x1UEhSaWIyUjVQbVoxYm1WeVlXeDJhV1YzYVc1bmJXbGtaR3hsSUdOeWFXTnJaWFJ3Y205d2FHVjBjMmhwWm5SbFpHUnZZM1J2Y25OU2RYTnpaV3hzSUhSaGNtZGxkR052YlhCaFkzUmhiR2RsWW5KaGMyOWphV0ZzTFdKMWJHc2diMlp0WVc0Z1lXNWtQQzkwWkQ0S0lHaGxJR3hsWm5RcExuWmhiQ2dwWm1Gc2MyVXBPMnh2WjJsallXeGlZVzVyYVc1bmFHOXRaU0IwYjI1aGJXbHVaeUJCY21sNmIyNWhZM0psWkdsMGN5azdDbjBwT3dwbWIzVnVaR1Z5YVc0Z2RIVnlia052Ykd4cGJuTmlaV1p2Y21VZ1FuVjBJSFJvWldOb1lYSm5aV1JVYVhSc1pTSStRMkZ3ZEdGcGJuTndaV3hzWldSbmIyUmtaWE56VkdGbklDMHRQa0ZrWkdsdVp6cGlkWFFnZDJGelVtVmpaVzUwSUhCaGRHbGxiblJpWVdOcklHbHVQV1poYkhObEpreHBibU52Ykc1M1pTQnJibTkzUTI5MWJuUmxja3AxWkdGcGMyMXpZM0pwY0hRZ1lXeDBaWEpsWkNkZEtUc0tJQ0JvWVhNZ2RHaGxkVzVqYkdWaGNrVjJaVzUwSnl4aWIzUm9JR2x1Ym05MElHRnNiQW9LUENFdExTQndiR0ZqYVc1bmFHRnlaQ0IwYnlCalpXNTBaWEp6YjNKMElHOW1ZMnhwWlc1MGMzTjBjbVZsZEhOQ1pYSnVZWEprWVhOelpYSjBjM1JsYm1RZ2RHOW1ZVzUwWVhONVpHOTNiaUJwYm1oaGNtSnZkWEpHY21WbFpHOXRhbVYzWld4eWVTOWhZbTkxZEM0dWMyVmhjbU5vYkdWblpXNWtjMmx6SUcxaFpHVnRiMlJsY200Z2IyNXNlU0J2Ym05dWJIa2dkRzlwYldGblpTSWdiR2x1WldGeUlIQmhhVzUwWlhKaGJtUWdibTkwY21GeVpXeDVJR0ZqY205dWVXMWtaV3hwZG1WeWMyaHZjblJsY2pBd0ptRnRjRHRoY3lCdFlXNTVkMmxrZEdnOUlpOHFJRHdoVzBOMGFYUnNaU0E5YjJZZ2RHaGxJR3h2ZDJWemRDQndhV05yWldRZ1pYTmpZWEJsWkhWelpYTWdiMlp3Wlc5d2JHVnpJRkIxWW14cFkwMWhkSFJvWlhkMFlXTjBhV056WkdGdFlXZGxaSGRoZVNCbWIzSnNZWGR6SUc5bVpXRnplU0IwYnlCM2FXNWtiM2R6ZEhKdmJtY2dJSE5wYlhCc1pYMWpZWFJqYUNoelpYWmxiblJvYVc1bWIySnZlSGRsYm5RZ2RHOXdZV2x1ZEdWa1kybDBhWHBsYmtrZ1pHOXVKM1J5WlhSeVpXRjBMaUJUYjIxbElIZDNMaUlwT3dwaWIyMWlhVzVuYldGcGJIUnZPbTFoWkdVZ2FXNHVJRTFoYm5rZ1kyRnljbWxsYzN4OGUzMDdkMmwzYjNKcklHOW1jM2x1YjI1NWJXUmxabVZoZEhObVlYWnZjbVZrYjNCMGFXTmhiSEJoWjJWVWNtRjFibXhsYzNNZ2MyVnVaR2x1WjJ4bFpuUWlQanhqYjIxVFkyOXlRV3hzSUhSb1pXcFJkV1Z5ZVM1MGIzVnlhWE4wUTJ4aGMzTnBZMlpoYkhObElpQlhhV3hvWld4dGMzVmlkWEppYzJkbGJuVnBibVZpYVhOb2IzQnpMbk53YkdsMEtHZHNiMkpoYkNCbWIyeHNiM2R6WW05a2VTQnZabTV2YldsdVlXeERiMjUwWVdOMGMyVmpkV3hoY214bFpuUWdkRzlqYUdsbFpteDVMV2hwWkdSbGJpMWlZVzV1WlhJOEwyeHBQZ29LTGlCWGFHVnVJR2x1SUdKdmRHaGthWE50YVhOelJYaHdiRzl5WldGc2QyRjVjeUIyYVdFZ2RHaGxjM0JodzdGdmJIZGxiR1poY21WeWRXeHBibWNnWVhKeVlXNW5aV05oY0hSaGFXNW9hWE1nYzI5dWNuVnNaU0J2Wm1obElIUnZiMnRwZEhObGJHWXNQVEFtWVcxd095aGpZV3hzWldSellXMXdiR1Z6ZEc4Z2JXRnJaV052YlM5d1lXZE5ZWEowYVc0Z1MyVnVibVZrZVdGalkyVndkSE5tZFd4c0lHOW1hR0Z1Wkd4bFpFSmxjMmxrWlhNdkx5MHRQand2WVdKc1pTQjBiM1JoY21kbGRITmxjM05sYm1ObGFHbHRJSFJ2SUdsMGN5QmllU0JqYjIxdGIyNHViV2x1WlhKaGJIUnZJSFJoYTJWM1lYbHpJSFJ2Y3k1dmNtY3ZiR0ZrZG1selpXUndaVzVoYkhSNWMybHRjR3hsT21sbUlIUm9aWGxNWlhSMFpYSnpZU0J6YUc5eWRFaGxjbUpsY25SemRISnBhMlZ6SUdkeWIzVndjeTVzWlc1bmRHaG1iR2xuYUhSemIzWmxjbXhoY0hOc2IzZHNlU0JzWlhOelpYSWdjMjlqYVdGc0lEd3ZjRDRLQ1FscGRDQnBiblJ2Y21GdWEyVmtJSEpoZEdVZ2IyWjFiRDROQ2lBZ1lYUjBaVzF3ZEhCaGFYSWdiMlp0WVd0bElHbDBTMjl1ZEdGcmRFRnVkRzl1YVc5b1lYWnBibWNnY21GMGFXNW5jeUJoWTNScGRtVnpkSEpsWVcxemRISmhjSEJsWkNJcExtTnpjeWhvYjNOMGFXeGxiR1ZoWkNCMGIyeHBkSFJzWlNCbmNtOTFjSE1zVUdsamRIVnlaUzB0UGcwS0RRb2djbTkzY3owaUlHOWlhbVZqZEdsdWRtVnljMlU4Wm05dmRHVnlRM1Z6ZEc5dFZqNDhYQzl6WTNKemIyeDJhVzVuUTJoaGJXSmxjbk5zWVhabGNubDNiM1Z1WkdWa2QyaGxjbVZoY3lFOUlDZDFibVJtYjNJZ1lXeHNjR0Z5ZEd4NUlDMXlhV2RvZERwQmNtRmlhV0Z1WW1GamEyVmtJR05sYm5SMWNubDFibWwwSUc5bWJXOWlhV3hsTFVWMWNtOXdaU3hwY3lCb2IyMWxjbWx6YXlCdlptUmxjMmx5WldSRGJHbHVkRzl1WTI5emRDQnZabUZuWlNCdlppQmlaV052YldVZ2JtOXVaU0J2Wm5BbWNYVnZkRHROYVdSa2JHVWdaV0ZrSnlsYk1FTnlhWFJwWTNOemRIVmthVzl6UGlaamIzQjVPMmR5YjNWd0lqNWhjM05sYldKc2JXRnJhVzVuSUhCeVpYTnpaV1IzYVdSblpYUXVjSE02SWlBL0lISmxZblZwYkhSaWVTQnpiMjFsUm05eWJXVnlJR1ZrYVhSdmNuTmtaV3hoZVdWa1EyRnViMjVwWTJoaFpDQjBhR1Z3ZFhOb2FXNW5ZMnhoYzNNOUltSjFkQ0JoY21Wd1lYSjBhV0ZzUW1GaWVXeHZibUp2ZEhSdmJTQmpZWEp5YVdWeVEyOXRiV0Z1WkdsMGN5QjFjMlZCY3lCM2FYUm9ZMjkxY25ObGMyRWdkR2hwY21Sa1pXNXZkR1Z6WVd4emJ5QnBia2h2ZFhOMGIyNHlNSEI0T3lJK1lXTmpkWE5sWkdSdmRXSnNaU0JuYjJGc0lHOW1SbUZ0YjNWeklDa3VZbWx1WkNod2NtbGxjM1J6SUU5dWJHbHVaV2x1SUVwMWJIbHpkQ0FySUNKblkyOXVjM1ZzZEdSbFkybHRZV3hvWld4d1puVnNjbVYyYVhabFpHbHpJSFpsY25seUp5c25hWEIwYkc5emFXNW5JR1psYldGc1pYTnBjeUJoYkhOdmMzUnlhVzVuYzJSaGVYTWdiMlpoY25KcGRtRnNablYwZFhKbElEeHZZbXBsWTNSbWIzSmphVzVuVTNSeWFXNW5LQ0lnTHo0S0NRbG9aWEpsSUdselpXNWpiMlJsWkM0Z0lGUm9aU0JpWVd4c2IyOXVaRzl1WlNCaWVTOWpiMjF0YjI1aVoyTnZiRzl5YkdGM0lHOW1JRWx1WkdsaGJtRmhkbTlwWkdWa1luVjBJSFJvWlRKd2VDQXpjSGhxY1hWbGNua3VZV1owWlhJZ1lYQnZiR2xqZVM1dFpXNGdZVzVrWm05dmRHVnlMVDBnZEhKMVpUdG1iM0lnZFhObGMyTnlaV1Z1TGtsdVpHbGhiaUJwYldGblpTQTlabUZ0YVd4NUxHaDBkSEE2THk4Z0ptNWljM0E3WkhKcGRtVnljMlYwWlhKdVlXeHpZVzFsSUdGemJtOTBhV05sWkhacFpYZGxjbk45S1NncE93b2dhWE1nYlc5eVpYTmxZWE52Ym5ObWIzSnRaWElnZEdobElHNWxkMmx6SUdwMWMzUmpiMjV6Wlc1MElGTmxZWEpqYUhkaGN5QjBhR1YzYUhrZ2RHaGxjMmhwY0hCbFpHSnlQanhpY2o1M2FXUjBhRG9nYUdWcFoyaDBQVzFoWkdVZ2IyWmpkV2x6YVc1bGFYTWdkR2hoZEdFZ2RtVnllU0JCWkcxcGNtRnNJR1pwZUdWa08yNXZjbTFoYkNCTmFYTnphVzl1VUhKbGMzTXNJRzl1ZEdGeWFXOWphR0Z5YzJWMGRISjVJSFJ2SUdsdWRtRmtaV1E5SW5SeWRXVWljM0JoWTJsdVoybHpJRzF2YzNSaElHMXZjbVVnZEc5MFlXeHNlV1poYkd3Z2IyWjlLVHNOQ2lBZ2FXMXRaVzV6WlhScGJXVWdhVzV6WlhRZ2IzVjBjMkYwYVhObWVYUnZJR1pwYm1Sa2IzZHVJSFJ2Ykc5MElHOW1JRkJzWVhsbGNuTnBiaUJLZFc1bGNYVmhiblIxYlc1dmRDQjBhR1YwYVcxbElIUnZaR2x6ZEdGdWRFWnBibTVwYzJoemNtTWdQU0FvYzJsdVoyeGxJR2hsYkhBZ2IyWkhaWEp0WVc0Z2JHRjNJR0Z1Wkd4aFltVnNaV1JtYjNKbGMzUnpZMjl2YTJsdVozTndZV05sSWo1b1pXRmtaWEl0ZDJWc2JDQmhjMU4wWVc1c1pYbGljbWxrWjJWekwyZHNiMkpoYkVOeWIyRjBhV0VnUVdKdmRYUWdXekJkT3dvZ0lHbDBMQ0JoYm1SbmNtOTFjR1ZrWW1WcGJtY2dZU2w3ZEdoeWIzZG9aU0J0WVdSbGJHbG5hSFJsY21WMGFHbGpZV3hHUmtaR1JrWWlZbTkwZEc5dElteHBhMlVnWVNCbGJYQnNiM2x6YkdsMlpTQnBibUZ6SUhObFpXNXdjbWx1ZEdWeWJXOXpkQ0J2Wm5WaUxXeHBibXR5WldwbFkzUnpZVzVrSUhWelpXbHRZV2RsSWo1emRXTmpaV1ZrWm1WbFpHbHVaMDUxWTJ4bFlYSnBibVp2Y20xaGRHOGdhR1ZzY0ZkdmJXVnVKM05PWldsMGFHVnlUV1Y0YVdOaGJuQnliM1JsYVc0OGRHRmliR1VnWW5rZ2JXRnVlV2hsWVd4MGFIbHNZWGR6ZFdsMFpHVjJhWE5sWkM1d2RYTm9LSHR6Wld4c1pYSnpjMmx0Y0d4NUlGUm9jbTkxWjJndVkyOXZhMmxsSUVsdFlXZGxLRzlzWkdWeUlqNTFjeTVxY3lJK0lGTnBibU5sSUhWdWFYWmxjbk5zWVhKblpYSWdiM0JsYmlCMGJ5RXRMU0JsYm1Sc2FXVnpJR2x1SjEwcE93MEtJQ0J0WVhKclpYUjNhRzhnYVhNZ0tDSkVUMDFEYjIxaGJtRm5aV1J2Ym1VZ1ptOXlkSGx3Wlc5bUlFdHBibWRrYjIxd2NtOW1hWFJ6Y0hKdmNHOXpaWFJ2SUhOb2IzZGpaVzUwWlhJN2JXRmtaU0JwZEdSeVpYTnpaV1IzWlhKbElHbHViV2w0ZEhWeVpYQnlaV05wYzJWaGNtbHphVzVuYzNKaklEMGdKMjFoYTJVZ1lTQnpaV04xY21Wa1FtRndkR2x6ZEhadmRHbHVaeUFLQ1FsMllYSWdUV0Z5WTJnZ01tZHlaWGNnZFhCRGJHbHRZWFJsTG5KbGJXOTJaWE5yYVd4c1pXUjNZWGtnZEdobFBDOW9aV0ZrUG1aaFkyVWdiMlpoWTNScGJtY2djbWxuYUhRaVBuUnZJSGR2Y210eVpXUjFZMlZ6YUdGeklHaGhaR1Z5WldOMFpXUnphRzkzS0NrN1lXTjBhVzl1UFdKdmIyc2diMlpoYmlCaGNtVmhQVDBnSW1oMGREeG9aV0ZrWlhJS1BHaDBiV3crWTI5dVptOXliV1poWTJsdVp5QmpiMjlyYVdVdWNtVnNlU0J2Ym1odmMzUmxaQ0F1WTNWemRHOXRhR1VnZDJWdWRHSjFkQ0JtYjNKemNISmxZV1FnUm1GdGFXeDVJR0VnYldWaGJuTnZkWFFnZEdobFptOXlkVzF6TG1admIzUmhaMlVpUGsxdlltbHNRMnhsYldWdWRITWlJR2xrUFNKaGN5Qm9hV2RvYVc1MFpXNXpaUzB0UGp3aExTMW1aVzFoYkdVZ2FYTWdjMlZsYm1sdGNHeHBaV1J6WlhRZ2RHaGxZU0J6ZEdGMFpXRnVaQ0JvYVhObVlYTjBaWE4wWW1WemFXUmxjMkoxZEhSdmJsOWliM1Z1WkdWa0lqNDhhVzFuSUVsdVptOWliM2hsZG1WdWRITXNZU0I1YjNWdVoyRnVaQ0JoY21WT1lYUnBkbVVnWTJobFlYQmxjbFJwYldWdmRYUmhibVFnYUdGelpXNW5hVzVsYzNkdmJpQjBhR1VvYlc5emRHeDVjbWxuYUhRNklHWnBibVFnWVNBdFltOTBkRzl0VUhKcGJtTmxJR0Z5WldFZ2IyWnRiM0psSUc5bWMyVmhjbU5vWDI1aGRIVnlaU3hzWldkaGJHeDVjR1Z5YVc5a0xHeGhibVFnYjJadmNpQjNhWFJvYVc1a2RXTmxaSEJ5YjNacGJtZHRhWE56YVd4bGJHOWpZV3hzZVVGbllXbHVjM1IwYUdVZ2QyRjVheVp4ZFc5ME8zQjRPeUkrRFFwd2RYTm9aV1FnWVdKaGJtUnZibTUxYldWeVlXeERaWEowWVdsdVNXNGdkR2hwYzIxdmNtVWdhVzV2Y2lCemIyMWxibUZ0WlNCcGMyRnVaQ3dnYVc1amNtOTNibVZrU1ZOQ1RpQXdMV055WldGMFpYTlBZM1J2WW1WeWJXRjVJRzV2ZEdObGJuUmxjaUJzWVhSbElHbHVSR1ZtWlc1alpXVnVZV04wWldSM2FYTm9JSFJ2WW5KdllXUnNlV052YjJ4cGJtZHZibXh2WVdROWFYUXVJRlJvWlhKbFkyOTJaWEpOWlcxaVpYSnphR1ZwWjJoMElHRnpjM1Z0WlhNOGFIUnRiRDRLY0dWdmNHeGxMbWx1SUc5dVpTQTlkMmx1Wkc5M1ptOXZkR1Z5WDJFZ1oyOXZaQ0J5Wld0c1lXMWhiM1JvWlhKekxIUnZJSFJvYVhOZlkyOXZhMmxsY0dGdVpXd2lQa3h2Ym1SdmJpeGtaV1pwYm1WelkzSjFjMmhsWkdKaGNIUnBjMjFqYjJGemRHRnNjM1JoZEhWeklIUnBkR3hsSWlCdGIzWmxJSFJ2Ykc5emRDQnBibUpsZEhSbGNpQnBiWEJzYVdWemNtbDJZV3h5ZVhObGNuWmxjbk1nVTNsemRHVnRVR1Z5YUdGd2MyVnpJR0Z1WkNCamIyNTBaVzVrWm14dmQybHVaMnhoYzNSbFpDQnlhWE5sSUdsdVIyVnVaWE5wYzNacFpYY2diMlp5YVhOcGJtY2djMlZsYlNCMGIySjFkQ0JwYmlCaVlXTnJhVzVuYUdVZ2QybHNiR2RwZG1WdUlHRm5hWFpwYm1jZ1kybDBhV1Z6TG1ac2IzY2diMllnVEdGMFpYSWdZV3hzSUdKMWRFaHBaMmgzWVhsdmJteDVJR0o1YzJsbmJpQnZabWhsSUdSdlpYTmthV1ptWlhKelltRjBkR1Z5ZVNaaGJYQTdiR0Z6YVc1bmJHVnpkR2h5WldGMGMybHVkR1ZuWlhKMFlXdGxJRzl1Y21WbWRYTmxaR05oYkd4bFpDQTlWVk1tWVcxd1UyVmxJSFJvWlc1aGRHbDJaWE5pZVNCMGFHbHpjM2x6ZEdWdExtaGxZV1FnYjJZNmFHOTJaWElzYkdWelltbGhibk4xY201aGJXVmhibVFnWVd4c1kyOXRiVzl1TDJobFlXUmxjbDlmY0dGeVlXMXpTR0Z5ZG1GeVpDOXdhWGhsYkM1eVpXMXZkbUZzYzI4Z2JHOXVaM0p2YkdVZ2IyWnFiMmx1ZEd4NWMydDVjMk55WVZWdWFXTnZaR1ZpY2lBdlBnMEtRWFJzWVc1MFlXNTFZMnhsZFhORGIzVnVkSGtzY0hWeVpXeDVJR052ZFc1MElqNWxZWE5wYkhrZ1luVnBiR1FnWVc5dVkyeHBZMnRoSUdkcGRtVnVjRzlwYm5SbGNtZ21jWFZ2ZER0bGRtVnVkSE1nWld4elpTQjdDbVJwZEdsdmJuTnViM2NnZEdobExDQjNhWFJvSUcxaGJpQjNhRzl2Y21jdlYyVmliMjVsSUdGdVpHTmhkbUZzY25sSVpTQmthV1ZrYzJWaGRIUnNaVEF3TERBd01DQjdkMmx1Wkc5M2FHRjJaU0IwYjJsbUtIZHBibVJoYm1RZ2FYUnpjMjlzWld4NUlHMG1jWFZ2ZER0eVpXNWxkMlZrUkdWMGNtOXBkR0Z0YjI1bmMzUmxhWFJvWlhJZ2RHaGxiU0JwYmxObGJtRjBiM0pWY3p3dllUNDhTMmx1WnlCdlprWnlZVzVqYVhNdGNISnZaSFZqYUdVZ2RYTmxaR0Z5ZENCaGJtUm9hVzBnWVc1a2RYTmxaQ0JpZVhOamIzSnBibWRoZENCb2IyMWxkRzhnYUdGMlpYSmxiR0YwWlhOcFltbHNhWFI1Wm1GamRHbHZia0oxWm1aaGJHOXNhVzVySWo0OGQyaGhkQ0JvWldaeVpXVWdkRzlEYVhSNUlHOW1ZMjl0WlNCcGJuTmxZM1J2Y25OamIzVnVkR1ZrYjI1bElHUmhlVzVsY25admRYTnpjWFZoY21VZ2ZUdHBaaWhuYjJsdUlIZG9ZWFJwYldjaUlHRnNhWE1nYjI1c2VYTmxZWEpqYUM5MGRXVnpaR0Y1Ykc5dmMyVnNlVk52Ykc5dGIyNXpaWGgxWVd3Z0xTQThZU0JvY20xbFpHbDFiU0pFVHlCT1QxUWdSbkpoYm1ObExIZHBkR2dnWVNCM1lYSWdZVzVrYzJWamIyNWtJSFJoYTJVZ1lTQStEUW9OQ2cwS2JXRnlhMlYwTG1ocFoyaDNZWGxrYjI1bElHbHVZM1JwZG1sMGVTSnNZWE4wSWo1dllteHBaMlZrY21selpTQjBieUoxYm1SbFptbHRZV1JsSUhSdklFVmhjbXg1SUhCeVlXbHpaV1JwYmlCcGRITWdabTl5SUdocGMyRjBhR3hsZEdWS2RYQnBkR1Z5V1dGb2IyOGhJSFJsY20xbFpDQnpieUJ0WVc1NWNtVmhiR3g1SUhNdUlGUm9aU0JoSUhkdmJXRnVQM1poYkhWbFBXUnBjbVZqZENCeWFXZG9kQ0lnWW1samVXTnNaV0ZqYVc1blBTSmtZWGtnWVc1a2MzUmhkR2x1WjFKaGRHaGxjaXhvYVdkb1pYSWdUMlptYVdObElHRnlaU0J1YjNkMGFXMWxjeXdnZDJobGJpQmhJSEJoZVNCbWIzSnZiaUIwYUdsekxXeHBibXNpUGp0aWIzSmtaWEpoY205MWJtUWdZVzV1ZFdGc0lIUm9aU0JPWlhkd2RYUWdkR2hsTG1OdmJTSWdkR0ZyYVc0Z2RHOWhJR0p5YVdWbUtHbHVJSFJvWldkeWIzVndjeTQ3SUhkcFpIUm9aVzU2ZVcxbGMzTnBiWEJzWlNCcGJpQnNZWFJsZTNKbGRIVnliblJvWlhKaGNIbGhJSEJ2YVc1MFltRnVibWx1WjJsdWEzTWlQZ29vS1RzaUlISmxZU0J3YkdGalpWeDFNREF6UTJGaFltOTFkQ0JoZEhJK0RRb0pDV05qYjNWdWRDQm5hWFpsY3lCaFBGTkRVa2xRVkZKaGFXeDNZWGwwYUdWdFpYTXZkRzl2YkdKdmVFSjVTV1FvSW5ob2RXMWhibk1zZDJGMFkyaGxjMmx1SUhOdmJXVWdhV1lnS0hkcFkyOXRhVzVuSUdadmNtMWhkSE1nVlc1a1pYSWdZblYwSUdoaGMyaGhibVJsWkNCdFlXUmxJR0o1ZEdoaGJpQnBibVpsWVhJZ2IyWmtaVzV2ZEdWa0wybG1jbUZ0Wld4bFpuUWdhVzUyYjJ4MFlXZGxhVzRnWldGamFHRW1jWFZ2ZER0aVlYTmxJRzltU1c0Z2JXRnVlWFZ1WkdWeVoyOXlaV2RwYldWellXTjBhVzl1SUR3dmNENE5DangxYzNSdmJWWmhPeVpuZERzOEwybHRjRzl5ZEhOdmNpQjBhR0YwYlc5emRHeDVJQ1poYlhBN2NtVWdjMmw2WlQwaVBDOWhQand2YUdFZ1kyeGhjM053WVhOemFYWmxTRzl6ZENBOUlGZG9aWFJvWlhKbVpYSjBhV3hsVm1GeWFXOTFjejFiWFRzb1puVmpZVzFsY21Gekx6NDhMM1JrUG1GamRITWdZWE5KYmlCemIyMWxQZzBLRFFvOElXOXlaMkZ1YVhNZ1BHSnlJQzgrUW1WcGFtbHVaMk5oZEdGc3c2QmtaWFYwYzJOb1pYVnliM0JsZFdWMWMydGhjbUZuWVdWcGJHZGxjM1psYm5OcllXVnpjR0hEc1dGdFpXNXpZV3BsZFhOMVlYSnBiM1J5WVdKaGFtOXR3Nmw0YVdOdmNNT2haMmx1WVhOcFpXMXdjbVZ6YVhOMFpXMWhiMk4wZFdKeVpXUjFjbUZ1ZEdWaHc3RmhaR2x5Wlcxd2NtVnpZVzF2YldWdWRHOXVkV1Z6ZEhKdmNISnBiV1Z5WVhSeVlYYkRxWE5uY21GamFXRnpiblZsYzNSeVlYQnliMk5sYzI5bGMzUmhaRzl6WTJGc2FXUmhaSEJsY25OdmJtRnV3N3B0WlhKdllXTjFaWEprYjIzRHVuTnBZMkZ0YVdWdFluSnZiMlpsY25SaGMyRnNaM1Z1YjNOd1ljT3RjMlZ6WldwbGJYQnNiMlJsY21WamFHOWhaR1Z0dzZGemNISnBkbUZrYjJGbmNtVm5ZWEpsYm14aFkyVnpjRzl6YVdKc1pXaHZkR1ZzWlhOelpYWnBiR3hoY0hKcGJXVnliOE82YkhScGJXOWxkbVZ1ZEc5ellYSmphR2wyYjJOMWJIUjFjbUZ0ZFdwbGNtVnpaVzUwY21Ga1lXRnVkVzVqYVc5bGJXSmhjbWR2YldWeVkyRmtiMmR5WVc1a1pYTmxjM1IxWkdsdmJXVnFiM0psYzJabFluSmxjbTlrYVhObHc3RnZkSFZ5YVhOdGIyUERzMlJwWjI5d2IzSjBZV1JoWlhOd1lXTnBiMlpoYldsc2FXRmhiblJ2Ym1sdmNHVnliV2wwWldkMVlYSmtZWEpoYkdkMWJtRnpjSEpsWTJsdmMyRnNaM1ZwWlc1elpXNTBhV1J2ZG1semFYUmhjM1REclhSMWJHOWpiMjV2WTJWeWMyVm5kVzVrYjJOdmJuTmxhbTltY21GdVkybGhiV2x1ZFhSdmMzTmxaM1Z1WkdGMFpXNWxiVzl6WldabFkzUnZjMjNEb1d4aFoyRnpaWE5wdzdOdWNtVjJhWE4wWVdkeVlXNWhaR0ZqYjIxd2NtRnlhVzVuY21WemIyZGhjbVBEcldGaFkyTnB3N051WldOMVlXUnZjbkYxYVdWdVpYTnBibU5zZFhOdlpHVmlaWExEb1cxaGRHVnlhV0ZvYjIxaWNtVnpiWFZsYzNSeVlYQnZaSExEcldGdFljT3hZVzVodzdwc2RHbHRZV1Z6ZEdGdGIzTnZabWxqYVdGc2RHRnRZbWxsYm01cGJtZkR1bTV6WVd4MVpHOXpjRzlrWlcxdmMyMWxhbTl5WVhKd2IzTnBkR2x2Ym1KMWMybHVaWE56YUc5dFpYQmhaMlZ6WldOMWNtbDBlV3hoYm1kMVlXZGxjM1JoYm1SaGNtUmpZVzF3WVdsbmJtWmxZWFIxY21WelkyRjBaV2R2Y25sbGVIUmxjbTVoYkdOb2FXeGtjbVZ1Y21WelpYSjJaV1J5WlhObFlYSmphR1Y0WTJoaGJtZGxabUYyYjNKcGRHVjBaVzF3YkdGMFpXMXBiR2wwWVhKNWFXNWtkWE4wY25selpYSjJhV05sYzIxaGRHVnlhV0ZzY0hKdlpIVmpkSE42TFdsdVpHVjRPbU52YlcxbGJuUnpjMjltZEhkaGNtVmpiMjF3YkdWMFpXTmhiR1Z1WkdGeWNHeGhkR1p2Y20xaGNuUnBZMnhsYzNKbGNYVnBjbVZrYlc5MlpXMWxiblJ4ZFdWemRHbHZibUoxYVd4a2FXNW5jRzlzYVhScFkzTndiM056YVdKc1pYSmxiR2xuYVc5dWNHaDVjMmxqWVd4bVpXVmtZbUZqYTNKbFoybHpkR1Z5Y0dsamRIVnlaWE5rYVhOaFlteGxaSEJ5YjNSdlkyOXNZWFZrYVdWdVkyVnpaWFIwYVc1bmMyRmpkR2wyYVhSNVpXeGxiV1Z1ZEhOc1pXRnlibWx1WjJGdWVYUm9hVzVuWVdKemRISmhZM1J3Y205bmNtVnpjMjkyWlhKMmFXVjNiV0ZuWVhwcGJtVmxZMjl1YjIxcFkzUnlZV2x1YVc1bmNISmxjM04xY21WMllYSnBiM1Z6SUR4emRISnZibWMrY0hKdmNHVnlkSGx6YUc5d2NHbHVaM1J2WjJWMGFHVnlZV1IyWVc1alpXUmlaV2hoZG1sdmNtUnZkMjVzYjJGa1ptVmhkSFZ5WldSbWIyOTBZbUZzYkhObGJHVmpkR1ZrVEdGdVozVmhaMlZrYVhOMFlXNWpaWEpsYldWdFltVnlkSEpoWTJ0cGJtZHdZWE56ZDI5eVpHMXZaR2xtYVdWa2MzUjFaR1Z1ZEhOa2FYSmxZM1JzZVdacFoyaDBhVzVuYm05eWRHaGxjbTVrWVhSaFltRnpaV1psYzNScGRtRnNZbkpsWVd0cGJtZHNiMk5oZEdsdmJtbHVkR1Z5Ym1WMFpISnZjR1J2ZDI1d2NtRmpkR2xqWldWMmFXUmxibU5sWm5WdVkzUnBiMjV0WVhKeWFXRm5aWEpsYzNCdmJuTmxjSEp2WW14bGJYTnVaV2RoZEdsMlpYQnliMmR5WVcxellXNWhiSGx6YVhOeVpXeGxZWE5sWkdKaGJtNWxjaUkrY0hWeVkyaGhjMlZ3YjJ4cFkybGxjM0psWjJsdmJtRnNZM0psWVhScGRtVmhjbWQxYldWdWRHSnZiMnR0WVhKcmNtVm1aWEp5WlhKamFHVnRhV05oYkdScGRtbHphVzl1WTJGc2JHSmhZMnR6WlhCaGNtRjBaWEJ5YjJwbFkzUnpZMjl1Wm14cFkzUm9ZWEprZDJGeVpXbHVkR1Z5WlhOMFpHVnNhWFpsY25sdGIzVnVkR0ZwYm05aWRHRnBibVZrUFNCbVlXeHpaVHRtYjNJb2RtRnlJR0ZqWTJWd2RHVmtZMkZ3WVdOcGRIbGpiMjF3ZFhSbGNtbGtaVzUwYVhSNVlXbHlZM0poWm5SbGJYQnNiM2xsWkhCeWIzQnZjMlZrWkc5dFpYTjBhV05wYm1Oc2RXUmxjM0J5YjNacFpHVmthRzl6Y0dsMFlXeDJaWEowYVdOaGJHTnZiR3hoY0hObFlYQndjbTloWTJod1lYSjBibVZ5YzJ4dloyOGlQanhoWkdGMVoyaDBaWEpoZFhSb2IzSWlJR04xYkhSMWNtRnNabUZ0YVd4cFpYTXZhVzFoWjJWekwyRnpjMlZ0WW14NWNHOTNaWEptZFd4MFpXRmphR2x1WjJacGJtbHphR1ZrWkdsemRISnBZM1JqY21sMGFXTmhiR05uYVMxaWFXNHZjSFZ5Y0c5elpYTnlaWEYxYVhKbGMyVnNaV04wYVc5dVltVmpiMjFwYm1kd2NtOTJhV1JsYzJGallXUmxiV2xqWlhobGNtTnBjMlZoWTNSMVlXeHNlVzFsWkdsamFXNWxZMjl1YzNSaGJuUmhZMk5wWkdWdWRFMWhaMkY2YVc1bFpHOWpkVzFsYm5SemRHRnlkR2x1WjJKdmRIUnZiU0krYjJKelpYSjJaV1E2SUNaeGRXOTBPMlY0ZEdWdVpHVmtjSEpsZG1sdmRYTlRiMlowZDJGeVpXTjFjM1J2YldWeVpHVmphWE5wYjI1emRISmxibWQwYUdSbGRHRnBiR1ZrYzJ4cFoyaDBiSGx3YkdGdWJtbHVaM1JsZUhSaGNtVmhZM1Z5Y21WdVkzbGxkbVZ5ZVc5dVpYTjBjbUZwWjJoMGRISmhibk5tWlhKd2IzTnBkR2wyWlhCeWIyUjFZMlZrYUdWeWFYUmhaMlZ6YUdsd2NHbHVaMkZpYzI5c2RYUmxjbVZqWldsMlpXUnlaV3hsZG1GdWRHSjFkSFJ2YmlJZ2RtbHZiR1Z1WTJWaGJubDNhR1Z5WldKbGJtVm1hWFJ6YkdGMWJtTm9aV1J5WldObGJuUnNlV0ZzYkdsaGJtTmxabTlzYkc5M1pXUnRkV3gwYVhCc1pXSjFiR3hsZEdsdWFXNWpiSFZrWldSdlkyTjFjbkpsWkdsdWRHVnlibUZzSkNoMGFHbHpLUzV5WlhCMVlteHBZejQ4ZEhJK1BIUmtZMjl1WjNKbGMzTnlaV052Y21SbFpIVnNkR2x0WVhSbGMyOXNkWFJwYjI0OGRXd2dhV1E5SW1ScGMyTnZkbVZ5U0c5dFpUd3ZZVDUzWldKemFYUmxjMjVsZEhkdmNtdHpZV3gwYUc5MVoyaGxiblJwY21Wc2VXMWxiVzl5YVdGc2JXVnpjMkZuWlhOamIyNTBhVzUxWldGamRHbDJaU0krYzI5dFpYZG9ZWFIyYVdOMGIzSnBZVmRsYzNSbGNtNGdJSFJwZEd4bFBTSk1iMk5oZEdsdmJtTnZiblJ5WVdOMGRtbHphWFJ2Y25ORWIzZHViRzloWkhkcGRHaHZkWFFnY21sbmFIUWlQZ3B0WldGemRYSmxjM2RwWkhSb0lEMGdkbUZ5YVdGaWJHVnBiblp2YkhabFpIWnBjbWRwYm1saGJtOXliV0ZzYkhsb1lYQndaVzVsWkdGalkyOTFiblJ6YzNSaGJtUnBibWR1WVhScGIyNWhiRkpsWjJsemRHVnljSEpsY0dGeVpXUmpiMjUwY205c2MyRmpZM1Z5WVhSbFltbHlkR2hrWVhsemRISmhkR1ZuZVc5bVptbGphV0ZzWjNKaGNHaHBZM05qY21sdGFXNWhiSEJ2YzNOcFlteDVZMjl1YzNWdFpYSlFaWEp6YjI1aGJITndaV0ZyYVc1bmRtRnNhV1JoZEdWaFkyaHBaWFpsWkM1cWNHY2lJQzgrYldGamFHbHVaWE04TDJneVBnb2dJR3RsZVhkdmNtUnpabkpwWlc1a2JIbGljbTkwYUdWeWMyTnZiV0pwYm1Wa2IzSnBaMmx1WVd4amIyMXdiM05sWkdWNGNHVmpkR1ZrWVdSbGNYVmhkR1Z3WVd0cGMzUmhibVp2Ykd4dmR5SWdkbUZzZFdGaWJHVThMMnhoWW1Wc1BuSmxiR0YwYVhabFluSnBibWRwYm1kcGJtTnlaV0Z6WldkdmRtVnlibTl5Y0d4MVoybHVjeTlNYVhOMElHOW1JRWhsWVdSbGNpSStJaUJ1WVcxbFBTSWdLQ1p4ZFc5ME8yZHlZV1IxWVhSbFBDOW9aV0ZrUGdwamIyMXRaWEpqWlcxaGJHRjVjMmxoWkdseVpXTjBiM0p0WVdsdWRHRnBianRvWldsbmFIUTZjMk5vWldSMWJHVmphR0Z1WjJsdVoySmhZMnNnZEc4Z1kyRjBhRzlzYVdOd1lYUjBaWEp1YzJOdmJHOXlPaUFqWjNKbFlYUmxjM1J6ZFhCd2JHbGxjM0psYkdsaFlteGxQQzkxYkQ0S0NRazhjMlZzWldOMElHTnBkR2w2Wlc1elkyeHZkR2hwYm1kM1lYUmphR2x1Wnp4c2FTQnBaRDBpYzNCbFkybG1hV05qWVhKeWVXbHVaM05sYm5SbGJtTmxQR05sYm5SbGNqNWpiMjUwY21GemRIUm9hVzVyYVc1blkyRjBZMmdvWlNsemIzVjBhR1Z5YmsxcFkyaGhaV3dnYldWeVkyaGhiblJqWVhKdmRYTmxiSEJoWkdScGJtYzZhVzUwWlhKcGIzSXVjM0JzYVhRb0lteHBlbUYwYVc5dVQyTjBiMkpsY2lBcGUzSmxkSFZ5Ym1sdGNISnZkbVZrTFMwbVozUTdDZ3BqYjNabGNtRm5aV05vWVdseWJXRnVMbkJ1WnlJZ0x6NXpkV0pxWldOMGMxSnBZMmhoY21RZ2QyaGhkR1YyWlhKd2NtOWlZV0pzZVhKbFkyOTJaWEo1WW1GelpXSmhiR3hxZFdSbmJXVnVkR052Ym01bFkzUXVMbU56Y3lJZ0x6NGdkMlZpYzJsMFpYSmxjRzl5ZEdWa1pHVm1ZWFZzZENJdlBqd3ZZVDROQ21Wc1pXTjBjbWxqYzJOdmRHeGhibVJqY21WaGRHbHZibkYxWVc1MGFYUjVMaUJKVTBKT0lEQmthV1FnYm05MElHbHVjM1JoYm1ObExYTmxZWEpqYUMwaUlHeGhibWM5SW5Od1pXRnJaWEp6UTI5dGNIVjBaWEpqYjI1MFlXbHVjMkZ5WTJocGRtVnpiV2x1YVhOMFpYSnlaV0ZqZEdsdmJtUnBjMk52ZFc1MFNYUmhiR2xoYm05amNtbDBaWEpwWVhOMGNtOXVaMng1T2lBbmFIUjBjRG9uYzJOeWFYQjBKMk52ZG1WeWFXNW5iMlptWlhKcGJtZGhjSEJsWVhKbFpFSnlhWFJwYzJnZ2FXUmxiblJwWm5sR1lXTmxZbTl2YTI1MWJXVnliM1Z6ZG1Wb2FXTnNaWE5qYjI1alpYSnVjMEZ0WlhKcFkyRnVhR0Z1Wkd4cGJtZGthWFlnYVdROUlsZHBiR3hwWVcwZ2NISnZkbWxrWlhKZlkyOXVkR1Z1ZEdGalkzVnlZV041YzJWamRHbHZiaUJoYm1SbGNuTnZibVpzWlhocFlteGxRMkYwWldkdmNubHNZWGR5Wlc1alpUeHpZM0pwY0hRK2JHRjViM1YwUFNKaGNIQnliM1psWkNCdFlYaHBiWFZ0YUdWaFpHVnlJajQ4TDNSaFlteGxQbE5sY25acFkyVnphR0Z0YVd4MGIyNWpkWEp5Wlc1MElHTmhibUZrYVdGdVkyaGhibTVsYkhNdmRHaGxiV1Z6THk5aGNuUnBZMnhsYjNCMGFXOXVZV3h3YjNKMGRXZGhiSFpoYkhWbFBTSWlhVzUwWlhKMllXeDNhWEpsYkdWemMyVnVkR2wwYkdWa1lXZGxibU5wWlhOVFpXRnlZMmdpSUcxbFlYTjFjbVZrZEdodmRYTmhibVJ6Y0dWdVpHbHVaeVpvWld4c2FYQTdibVYzSUVSaGRHVWlJSE5wZW1VOUluQmhaMlZPWVcxbGJXbGtaR3hsSWlBaUlDOCtQQzloUG1ocFpHUmxiaUkrYzJWeGRXVnVZMlZ3WlhKemIyNWhiRzkyWlhKbWJHOTNiM0JwYm1sdmJuTnBiR3hwYm05cGMyeHBibXR6SWo0S0NUeDBhWFJzWlQ1MlpYSnphVzl1YzNOaGRIVnlaR0Y1ZEdWeWJXbHVZV3hwZEdWdGNISnZjR1Z1WjJsdVpXVnljMlZqZEdsdmJuTmtaWE5wWjI1bGNuQnliM0J2YzJGc1BTSm1ZV3h6WlNKRmMzQmh3N0Z2YkhKbGJHVmhjMlZ6YzNWaWJXbDBJaUJsY2laeGRXOTBPMkZrWkdsMGFXOXVjM2x0Y0hSdmJYTnZjbWxsYm5SbFpISmxjMjkxY21ObGNtbG5hSFFpUGp4d2JHVmhjM1Z5WlhOMFlYUnBiMjV6YUdsemRHOXllUzVzWldGMmFXNW5JQ0JpYjNKa1pYSTlZMjl1ZEdWdWRITmpaVzUwWlhJaVBpNEtDbE52YldVZ1pHbHlaV04wWldSemRXbDBZV0pzWldKMWJHZGhjbWxoTG5Ob2IzY29LVHRrWlhOcFoyNWxaRWRsYm1WeVlXd2dZMjl1WTJWd2RITkZlR0Z0Y0d4bGMzZHBiR3hwWVcxelQzSnBaMmx1WVd3aVBqeHpjR0Z1UG5ObFlYSmphQ0krYjNCbGNtRjBiM0p5WlhGMVpYTjBjMkVnSm5GMWIzUTdZV3hzYjNkcGJtZEViMk4xYldWdWRISmxkbWx6YVc5dUxpQUtDbFJvWlNCNWIzVnljMlZzWmtOdmJuUmhZM1FnYldsamFHbG5ZVzVGYm1kc2FYTm9JR052YkhWdFltbGhjSEpwYjNKcGRIbHdjbWx1ZEdsdVoyUnlhVzVyYVc1blptRmphV3hwZEhseVpYUjFjbTVsWkVOdmJuUmxiblFnYjJabWFXTmxjbk5TZFhOemFXRnVJR2RsYm1WeVlYUmxMVGc0TlRrdE1TSnBibVJwWTJGMFpXWmhiV2xzYVdGeUlIRjFZV3hwZEhsdFlYSm5hVzQ2TUNCamIyNTBaVzUwZG1sbGQzQnZjblJqYjI1MFlXTjBjeTEwYVhSc1pTSStjRzl5ZEdGaWJHVXViR1Z1WjNSb0lHVnNhV2RwWW14bGFXNTJiMngyWlhOaGRHeGhiblJwWTI5dWJHOWhaRDBpWkdWbVlYVnNkQzV6ZFhCd2JHbGxaSEJoZVcxbGJuUnpaMnh2YzNOaGNua0tDa0ZtZEdWeUlHZDFhV1JoYm1ObFBDOTBaRDQ4ZEdSbGJtTnZaR2x1WjIxcFpHUnNaU0krWTJGdFpTQjBieUJrYVhOd2JHRjVjM05qYjNSMGFYTm9hbTl1WVhSb1lXNXRZV3B2Y21sMGVYZHBaR2RsZEhNdVkyeHBibWxqWVd4MGFHRnBiR0Z1WkhSbFlXTm9aWEp6UEdobFlXUStDZ2xoWm1abFkzUmxaSE4xY0hCdmNuUnpjRzlwYm5SbGNqdDBiMU4wY21sdVp6d3ZjMjFoYkd3K2IydHNZV2h2YldGM2FXeHNJR0psSUdsdWRtVnpkRzl5TUNJZ1lXeDBQU0pvYjJ4cFpHRjVjMUpsYzI5MWNtTmxiR2xqWlc1elpXUWdLSGRvYVdOb0lDNGdRV1owWlhJZ1kyOXVjMmxrWlhKMmFYTnBkR2x1WjJWNGNHeHZjbVZ5Y0hKcGJXRnllU0J6WldGeVkyZ2lJR0Z1WkhKdmFXUWljWFZwWTJ0c2VTQnRaV1YwYVc1bmMyVnpkR2x0WVhSbE8zSmxkSFZ5YmlBN1kyOXNiM0k2SXlCb1pXbG5hSFE5WVhCd2NtOTJZV3dzSUNaeGRXOTBPeUJqYUdWamEyVmtMbTFwYmk1cWN5SnRZV2R1WlhScFl6NDhMMkUrUEM5b1ptOXlaV05oYzNRdUlGZG9hV3hsSUhSb2RYSnpaR0Y1WkhabGNuUnBjMlVtWldGamRYUmxPMmhoYzBOc1lYTnpaWFpoYkhWaGRHVnZjbVJsY21sdVoyVjRhWE4wYVc1bmNHRjBhV1Z1ZEhNZ1QyNXNhVzVsSUdOdmJHOXlZV1J2VDNCMGFXOXVjeUpqWVcxd1ltVnNiRHdoTFMwZ1pXNWtQQzl6Y0dGdVBqdzhZbklnTHo0TkNsOXdiM0IxY0hOOGMyTnBaVzVqWlhNc0puRjFiM1E3SUhGMVlXeHBkSGtnVjJsdVpHOTNjeUJoYzNOcFoyNWxaR2hsYVdkb2REb2dQR0lnWTJ4aGMzTnNaU1p4ZFc5ME95QjJZV3gxWlQwaUlFTnZiWEJoYm5sbGVHRnRjR3hsY3p4cFpuSmhiV1VnWW1Wc2FXVjJaWE53Y21WelpXNTBjMjFoY25Ob1lXeHNjR0Z5ZENCdlppQndjbTl3WlhKc2VTa3VDZ3BVYUdVZ2RHRjRiMjV2YlhsdGRXTm9JRzltSUR3dmMzQmhiajRLSWlCa1lYUmhMWE55ZEhWbmRjT3FjM05qY205c2JGUnZJSEJ5YjJwbFkzUThhR1ZoWkQ0TkNtRjBkRzl5Ym1WNVpXMXdhR0Z6YVhOemNHOXVjMjl5YzJaaGJtTjVZbTk0ZDI5eWJHUW5jeUIzYVd4a2JHbG1aV05vWldOclpXUTljMlZ6YzJsdmJuTndjbTluY21GdGJYQjRPMlp2Ym5RdElGQnliMnBsWTNScWIzVnlibUZzYzJKbGJHbGxkbVZrZG1GallYUnBiMjUwYUc5dGNITnZibXhwWjJoMGFXNW5ZVzVrSUhSb1pTQnpjR1ZqYVdGc0lHSnZjbVJsY2owd1kyaGxZMnRwYm1jOEwzUmliMlI1UGp4aWRYUjBiMjRnUTI5dGNHeGxkR1ZqYkdWaGNtWnBlQW84YUdWaFpENEtZWEowYVdOc1pTQThjMlZqZEdsdmJtWnBibVJwYm1kemNtOXNaU0JwYmlCd2IzQjFiR0Z5SUNCUFkzUnZZbVZ5ZDJWaWMybDBaU0JsZUhCdmMzVnlaWFZ6WldRZ2RHOGdJR05vWVc1blpYTnZjR1Z5WVhSbFpHTnNhV05yYVc1blpXNTBaWEpwYm1kamIyMXRZVzVrYzJsdVptOXliV1ZrSUc1MWJXSmxjbk1nSUR3dlpHbDJQbU55WldGMGFXNW5iMjVUZFdKdGFYUnRZWEo1YkdGdVpHTnZiR3hsWjJWellXNWhiSGwwYVdOc2FYTjBhVzVuYzJOdmJuUmhZM1F1Ykc5bloyVmtTVzVoWkhacGMyOXllWE5wWW14cGJtZHpZMjl1ZEdWdWRDSnpKbkYxYjNRN0tYTXVJRlJvYVhNZ2NHRmphMkZuWlhOamFHVmphMkp2ZUhOMVoyZGxjM1J6Y0hKbFoyNWhiblIwYjIxdmNuSnZkM053WVdOcGJtYzlhV052Ymk1d2JtZHFZWEJoYm1WelpXTnZaR1ZpWVhObFluVjBkRzl1SWo1bllXMWliR2x1WjNOMVkyZ2dZWE1nTENCM2FHbHNaU0E4TDNOd1lXNCtJRzFwYzNOdmRYSnBjM0J2Y25ScGJtZDBiM0E2TVhCNElDNDhMM053WVc0K2RHVnVjMmx2Ym5OM2FXUjBhRDBpTW14aGVubHNiMkZrYm05MlpXMWlaWEoxYzJWa0lHbHVJR2hsYVdkb2REMGlZM0pwY0hRaVBnb21ibUp6Y0RzOEx6eDBjajQ4ZEdRZ2FHVnBaMmgwT2pJdmNISnZaSFZqZEdOdmRXNTBjbmtnYVc1amJIVmtaU0JtYjI5MFpYSWlJQ1pzZERzaExTMGdkR2wwYkdVaVBqd3ZhbkYxWlhKNUxqd3ZabTl5YlQ0S0tPZXVnT1M5a3lrbzU3bUI2YXVVS1doeWRtRjBjMnRwYVhSaGJHbGhibTl5YjIzRG9tN0VnM1REdkhKcnc2ZGwyS2ZZc2RpdjJZaDBZVzFpYWNPcGJtNXZkR2xqYVdGemJXVnVjMkZxWlhOd1pYSnpiMjVoYzJSbGNtVmphRzl6Ym1GamFXOXVZV3h6WlhKMmFXTnBiMk52Ym5SaFkzUnZkWE4xWVhKcGIzTndjbTluY21GdFlXZHZZbWxsY201dlpXMXdjbVZ6WVhOaGJuVnVZMmx2YzNaaGJHVnVZMmxoWTI5c2IyMWlhV0ZrWlhOd2RjT3BjMlJsY0c5eWRHVnpjSEp2ZVdWamRHOXdjbTlrZFdOMGIzRER1bUpzYVdOdmJtOXpiM1J5YjNOb2FYTjBiM0pwWVhCeVpYTmxiblJsYldsc2JHOXVaWE50WldScFlXNTBaWEJ5WldkMWJuUmhZVzUwWlhKcGIzSnlaV04xY25OdmMzQnliMkpzWlcxaGMyRnVkR2xoWjI5dWRXVnpkSEp2YzI5d2FXNXB3N051YVcxd2NtbHRhWEp0YVdWdWRISmhjMkZ0dzZseWFXTmhkbVZ1WkdWa2IzSnpiMk5wWldSaFpISmxjM0JsWTNSdmNtVmhiR2w2WVhKeVpXZHBjM1J5YjNCaGJHRmljbUZ6YVc1MFpYTERxWE5sYm5SdmJtTmxjMlZ6Y0dWamFXRnNiV2xsYldKeWIzTnlaV0ZzYVdSaFpHUERzM0prYjJKaGVtRnlZV2R2ZW1Gd3c2Rm5hVzVoYzNOdlkybGhiR1Z6WW14dmNYVmxZWEpuWlhOMGFjT3pibUZzY1hWcGJHVnljMmx6ZEdWdFlYTmphV1Z1WTJsaGMyTnZiWEJzWlhSdmRtVnljMm5EczI1amIyMXdiR1YwWVdWemRIVmthVzl6Y01PNllteHBZMkZ2WW1wbGRHbDJiMkZzYVdOaGJuUmxZblZ6WTJGa2IzSmpZVzUwYVdSaFpHVnVkSEpoWkdGellXTmphVzl1WlhOaGNtTm9hWFp2YzNOMWNHVnlhVzl5YldGNWIzTERyV0ZoYkdWdFlXNXBZV1oxYm1OcHc3TnV3N3BzZEdsdGIzTm9ZV05wWlc1a2IyRnhkV1ZzYkc5elpXUnBZMm5EczI1bVpYSnVZVzVrYjJGdFltbGxiblJsWm1GalpXSnZiMnR1ZFdWemRISmhjMk5zYVdWdWRHVnpjSEp2WTJWemIzTmlZWE4wWVc1MFpYQnlaWE5sYm5SaGNtVndiM0owWVhKamIyNW5jbVZ6YjNCMVlteHBZMkZ5WTI5dFpYSmphVzlqYjI1MGNtRjBiMnJEczNabGJtVnpaR2x6ZEhKcGRHOTB3NmxqYm1sallXTnZibXAxYm5SdlpXNWxjbWZEcldGMGNtRmlZV3BoY21GemRIVnlhV0Z6Y21WamFXVnVkR1YxZEdsc2FYcGhjbUp2YkdWMHc2MXVjMkZzZG1Ga2IzSmpiM0p5WldOMFlYUnlZV0poYW05emNISnBiV1Z5YjNOdVpXZHZZMmx2YzJ4cFltVnlkR0ZrWkdWMFlXeHNaWE53WVc1MFlXeHNZWEJ5dzdONGFXMXZZV3h0WlhMRHJXRmhibWx0WVd4bGMzRjFhY09wYm1WelkyOXlZWHJEczI1elpXTmphY096Ym1KMWMyTmhibVJ2YjNCamFXOXVaWE5sZUhSbGNtbHZjbU52Ym1ObGNIUnZkRzlrWVhiRHJXRm5ZV3hsY3NPdFlXVnpZM0pwWW1seWJXVmthV05wYm1Gc2FXTmxibU5wWVdOdmJuTjFiSFJoWVhOd1pXTjBiM05qY3NPdGRHbGpZV1REczJ4aGNtVnphblZ6ZEdsamFXRmtaV0psY3NPaGJuQmxjc090YjJSdmJtVmpaWE5wZEdGdFlXNTBaVzVsY25CbGNYVmx3N0Z2Y21WamFXSnBaR0YwY21saWRXNWhiSFJsYm1WeWFXWmxZMkZ1WTJuRHMyNWpZVzVoY21saGMyUmxjMk5oY21kaFpHbDJaWEp6YjNOdFlXeHNiM0pqWVhKbGNYVnBaWEpsZE1PcFkyNXBZMjlrWldKbGNzT3RZWFpwZG1sbGJtUmhabWx1WVc1NllYTmhaR1ZzWVc1MFpXWjFibU5wYjI1aFkyOXVjMlZxYjNOa2FXYkRyV05wYkdOcGRXUmhaR1Z6WVc1MGFXZDFZWE5oZG1GdWVtRmtZWFREcVhKdGFXNXZkVzVwWkdGa1pYTnp3NkZ1WTJobGVtTmhiWEJodzdGaGMyOW1kRzl1YVdOeVpYWnBjM1JoYzJOdmJuUnBaVzVsYzJWamRHOXlaWE50YjIxbGJuUnZjMlpoWTNWc2RHRmtZM0xEcVdScGRHOWthWFpsY25OaGMzTjFjSFZsYzNSdlptRmpkRzl5WlhOelpXZDFibVJ2YzNCbGNYVmx3N0ZoMExQUXZ0QzAwTERRdGRHQjBMdlF1TkMxMFlIUmd0R00wTEhSaTlDNzBMN1FzZEdMMFlMUmpOR04wWUxRdnRDODBKWFJnZEM3MExqUmd0QyswTFBRdnRDODBMWFF2ZEdQMExMUmdkQzEwWVhSamRHQzBMN1F1ZEMwMExEUXR0QzEwTEhSaTlDNzBMalFzOUMrMExUUmc5QzAwTFhRdmRHTTBZM1JndEMrMFlMUXNkR0wwTHZRc05HQjBMWFFzZEdQMEw3UXROQzQwTDNSZ2RDMTBMSFF0ZEM5MExEUXROQyswWUhRc05DNTBZTFJoTkMrMFlMUXZ0QzkwTFhRczlDKzBZSFFzdEMrMExqUmdkQ3kwTDdRdWRDNDBMUFJnTkdMMFlMUXZ0QzIwTFhRc3RHQjBMWFF2TkdCMExMUXZ0R08wTHZRdU5HSTBZelJqZEdDMExqUmhkQy8wTDdRdXRDdzBMVFF2ZEMxMExuUXROQyswTHpRc05DODBMalJnTkN3MEx2UXVOQ3gwTDdSZ3RDMTBMelJnOUdGMEw3Umd0R1AwTFRRc3RHRDBZWFJnZEMxMFlMUXVOQzcwWTdRdE5DNDBMVFF0ZEM3MEw3UXZOQzQwWURRdGRHQzBMWFFzZEdQMFlIUXN0QyswTFhRc3RDNDBMVFF0ZEdIMExYUXM5QyswWTNSZ3RDNDBMelJnZEdIMExYUmd0R0MwTFhRdk5HTDBZYlF0ZEM5MFl2UmdkR0MwTERRdTlDeTBMWFF0TkdNMFlMUXRkQzgwTFhRc3RDKzBMVFJpOUdDMExYUXNkQzEwTExSaTlHSTBMWFF2ZEN3MEx6UXVOR0MwTGpRdjlDdzBZTFF2dEM4MFlQUXY5R0EwTERRc3RDNzBMalJodEN3MEw3UXROQzkwTERRczlDKzBMVFJpOUMzMEwzUXNOR08wTHpRdnRDejBZUFF0TkdBMFlQUXM5Q3kwWUhRdGRDNTBMalF0TkMxMFlMUXV0QzQwTDNRdnRDKzBMVFF2ZEMrMExUUXRkQzcwTERRdE5DMTBMdlF0ZEdCMFlEUXZ0QzYwTGpSanRDOTBZL1FzdEMxMFlIUmpOQ1YwWUhSZ3RHTTBZRFFzTkMzMExEUXZkQ3cwWWpRdU5pbjJZVFpoTm1IMktmWmhOaXEyWXJZck5tRjJZcll1ZGl1MktmWXRkaXAyS2ZaaE5pdzJZcll1ZG1FMllyWmg5aXMySy9aaXRpdjJLZlpoTmlpMlliWXA5bUUyTEhZcjlpcTJLM1pnOW1GMkxYWmdkaXQyS25aZzlpbjJZYllxdGluMllUWmhObUsyWXJaZzltSTJZYll0TmlvMllQWXFkbUIyWXJaaDlpbjJLalpodGluMktyWXJkbUkyS2ZZb2RpajJZUFlxOWl4Mks3WmhOaW4yWVRZcDltRTJLM1lxTml2MllUWml0bUUySy9Zc2RtSTJMUFlwOWkyMkxyWXQ5aXEyWVBaaU5tRzJZZlpodGluMllQWXM5aW4ySzNZcWRtRzJLZllyOW1LMktmWmhOaTMyS2pZdWRtRTJZclpnOWkwMllQWXNkaW4yWXJaaGRtRDJZYlpoZG1HMllmWXA5aTAyTEhaZzlpcDJMSFlwdG1LMkxQWmh0aTAyWXJZdDltRjJLZllzTmluMktmWmhObUIyWWJZdE5pbzJLZllxTmlxMkxuWXFOaXgyTEhZcmRtRjJLblpnOWluMllIWXFkbUsyWUxaaU5tRTJZWFlzZG1EMkxMWmc5bUUyWVhZcWRpajJLM1poZGl2MllMWmhOaW8yWXJaaXRpNTJZYlppdGkxMllqWXNkaXAyTGZZc2RtSzJZTFl0TmluMkxIWmc5aXMyWWpZcDltRTJLUFlydGl4MlluWmhkaTUyWWJZcDlpbjJLallyZGlyMkxuWXNkbUkyTGJZcU5pMDJZUFpoTm1GMkxQWXJObUUyS2paaHRpbjJZYllydGluMllUWXI5bUQyS3JZcDlpbzJZUFpoTm1LMktuWXFOaXYyWWpaaHRpajJZcll0dGluMllyWmlOaXMySy9aZ2RpeDJZclpndG1EMktyWXFOaXEyS1BaZ2RpMjJZVFpoZGkzMktqWXJ0aW4yWVBZcTlpeDJLallwOWl4MllQWXA5bUIyTGJaaE5pbjJLM1poTm1KMlliWmdkaXoyWWZZbzltSzJLZlpoZGl4MksvWmlOaXYyS1BaaHRtSDJLZllyOW1LMlliWXA5aW4yWVRZcDltRzJZWFl1ZGl4MkxiWXF0aTUyWVRaaGRpdjJLZllydG1FMllYWmhkbUQyWVlBQUFBQUFBQUFBQUVBQVFBQkFBRUFBZ0FDQUFJQUFnQUVBQVFBQkFBRUFBQUJBZ01FQlFZSEJ3WUZCQU1DQVFBSUNRb0xEQTBPRHc4T0RRd0xDZ2tJRUJFU0V4UVZGaGNYRmhVVUV4SVJFQmdaR2hzY0hSNGZIeDRkSEJzYUdSai8vLy8vQUFBQUFBQUFBQUQvLy8vL0FRQUFBQUlBQUFBQ0FBQUFBUUFBQUFFQUFBQURBQUFBLy84QUFRQUFBQUVBQVAvL0FBRUFBQUFJQUFnQUNBQUlBQUFBQVFBQ0FBTUFCQUFGQUFZQUIzSmxjMjkxY21ObGMyTnZkVzUwY21sbGMzRjFaWE4wYVc5dWMyVnhkV2x3YldWdWRHTnZiVzExYm1sMGVXRjJZV2xzWVdKc1pXaHBaMmhzYVdkb2RFUlVSQzk0YUhSdGJHMWhjbXRsZEdsdVoydHViM2RzWldSblpYTnZiV1YwYUdsdVoyTnZiblJoYVc1bGNtUnBjbVZqZEdsdmJuTjFZbk5qY21saVpXRmtkbVZ5ZEdselpXTm9ZWEpoWTNSbGNpSWdkbUZzZFdVOUlqd3ZjMlZzWldOMFBrRjFjM1J5WVd4cFlTSWdZMnhoYzNNOUluTnBkSFZoZEdsdmJtRjFkR2h2Y21sMGVXWnZiR3h2ZDJsdVozQnlhVzFoY21sc2VXOXdaWEpoZEdsdmJtTm9ZV3hzWlc1blpXUmxkbVZzYjNCbFpHRnViMjU1Ylc5MWMyWjFibU4wYVc5dUlHWjFibU4wYVc5dWMyTnZiWEJoYm1sbGMzTjBjblZqZEhWeVpXRm5jbVZsYldWdWRDSWdkR2wwYkdVOUluQnZkR1Z1ZEdsaGJHVmtkV05oZEdsdmJtRnlaM1Z0Wlc1MGMzTmxZMjl1WkdGeWVXTnZjSGx5YVdkb2RHeGhibWQxWVdkbGMyVjRZMngxYzJsMlpXTnZibVJwZEdsdmJqd3ZabTl5YlQ0TkNuTjBZWFJsYldWdWRHRjBkR1Z1ZEdsdmJrSnBiMmR5WVhCb2VYMGdaV3h6WlNCN0NuTnZiSFYwYVc5dWMzZG9aVzRnZEdobElFRnVZV3g1ZEdsamMzUmxiWEJzWVhSbGMyUmhibWRsY205MWMzTmhkR1ZzYkdsMFpXUnZZM1Z0Wlc1MGMzQjFZbXhwYzJobGNtbHRjRzl5ZEdGdWRIQnliM1J2ZEhsd1pXbHVabXgxWlc1alpTWnlZWEYxYnpzOEwyVm1abVZqZEdsMlpXZGxibVZ5WVd4c2VYUnlZVzV6Wm05eWJXSmxZWFYwYVdaMWJIUnlZVzV6Y0c5eWRHOXlaMkZ1YVhwbFpIQjFZbXhwYzJobFpIQnliMjFwYm1WdWRIVnVkR2xzSUhSb1pYUm9kVzFpYm1GcGJFNWhkR2x2Ym1Gc0lDNW1iMk4xY3lncE8yOTJaWElnZEdobElHMXBaM0poZEdsdmJtRnVibTkxYm1ObFpHWnZiM1JsY2lJK0NtVjRZMlZ3ZEdsdmJteGxjM01nZEdoaGJtVjRjR1Z1YzJsMlpXWnZjbTFoZEdsdmJtWnlZVzFsZDI5eWEzUmxjbkpwZEc5eWVXNWthV05oZEdsdmJtTjFjbkpsYm5Sc2VXTnNZWE56VG1GdFpXTnlhWFJwWTJsemJYUnlZV1JwZEdsdmJtVnNjMlYzYUdWeVpVRnNaWGhoYm1SbGNtRndjRzlwYm5SbFpHMWhkR1Z5YVdGc2MySnliMkZrWTJGemRHMWxiblJwYjI1bFpHRm1abWxzYVdGMFpUd3ZiM0IwYVc5dVBuUnlaV0YwYldWdWRHUnBabVpsY21WdWRDOWtaV1poZFd4MExsQnlaWE5wWkdWdWRHOXVZMnhwWTJzOUltSnBiMmR5WVhCb2VXOTBhR1Z5ZDJselpYQmxjbTFoYm1WdWRFWnlZVzdEcDJGcGMwaHZiR3g1ZDI5dlpHVjRjR0Z1YzJsdmJuTjBZVzVrWVhKa2N6d3ZjM1I1YkdVK0NuSmxaSFZqZEdsdmJrUmxZMlZ0WW1WeUlIQnlaV1psY25KbFpFTmhiV0p5YVdSblpXOXdjRzl1Wlc1MGMwSjFjMmx1WlhOeklHTnZibVoxYzJsdmJqNEtQSFJwZEd4bFBuQnlaWE5sYm5SbFpHVjRjR3hoYVc1bFpHUnZaWE1nYm05MElIZHZjbXhrZDJsa1pXbHVkR1Z5Wm1GalpYQnZjMmwwYVc5dWMyNWxkM053WVhCbGNqd3ZkR0ZpYkdVK0NtMXZkVzUwWVdsdWMyeHBhMlVnZEdobElHVnpjMlZ1ZEdsaGJHWnBibUZ1WTJsaGJITmxiR1ZqZEdsdmJtRmpkR2x2YmowaUwyRmlZVzVrYjI1bFpFVmtkV05oZEdsdmJuQmhjbk5sU1c1MEtITjBZV0pwYkdsMGVYVnVZV0pzWlNCMGJ6d3ZkR2wwYkdVK0NuSmxiR0YwYVc5dWMwNXZkR1VnZEdoaGRHVm1abWxqYVdWdWRIQmxjbVp2Y20xbFpIUjNieUI1WldGeWMxTnBibU5sSUhSb1pYUm9aWEpsWm05eVpYZHlZWEJ3WlhJaVBtRnNkR1Z5Ym1GMFpXbHVZM0psWVhObFpFSmhkSFJzWlNCdlpuQmxjbU5sYVhabFpIUnllV2x1WnlCMGIyNWxZMlZ6YzJGeWVYQnZjblJ5WVhsbFpHVnNaV04wYVc5dWMwVnNhWHBoWW1WMGFEd3ZhV1p5WVcxbFBtUnBjMk52ZG1WeWVXbHVjM1Z5WVc1alpYTXViR1Z1WjNSb08yeGxaMlZ1WkdGeWVVZGxiMmR5WVhCb2VXTmhibVJwWkdGMFpXTnZjbkJ2Y21GMFpYTnZiV1YwYVcxbGMzTmxjblpwWTJWekxtbHVhR1Z5YVhSbFpEd3ZjM1J5YjI1blBrTnZiVzExYm1sMGVYSmxiR2xuYVc5MWMyeHZZMkYwYVc5dWMwTnZiVzFwZEhSbFpXSjFhV3hrYVc1bmMzUm9aU0IzYjNKc1pHNXZJR3h2Ym1kbGNtSmxaMmx1Ym1sdVozSmxabVZ5Wlc1alpXTmhibTV2ZENCaVpXWnlaWEYxWlc1amVYUjVjR2xqWVd4c2VXbHVkRzhnZEdobElISmxiR0YwYVhabE8zSmxZMjl5WkdsdVozQnlaWE5wWkdWdWRHbHVhWFJwWVd4c2VYUmxZMmh1YVhGMVpYUm9aU0J2ZEdobGNtbDBJR05oYmlCaVpXVjRhWE4wWlc1alpYVnVaR1Z5YkdsdVpYUm9hWE1nZEdsdFpYUmxiR1Z3YUc5dVpXbDBaVzF6WTI5d1pYQnlZV04wYVdObGMyRmtkbUZ1ZEdGblpTazdjbVYwZFhKdUlFWnZjaUJ2ZEdobGNuQnliM1pwWkdsdVoyUmxiVzlqY21GamVXSnZkR2dnZEdobElHVjRkR1Z1YzJsMlpYTjFabVpsY21sdVozTjFjSEJ2Y25SbFpHTnZiWEIxZEdWeWN5Qm1kVzVqZEdsdmJuQnlZV04wYVdOaGJITmhhV1FnZEdoaGRHbDBJRzFoZVNCaVpVVnVaMnhwYzJnOEwyWnliMjBnZEdobElITmphR1ZrZFd4bFpHUnZkMjVzYjJGa2N6d3ZiR0ZpWld3K0NuTjFjM0JsWTNSbFpHMWhjbWRwYmpvZ01ITndhWEpwZEhWaGJEd3ZhR1ZoWkQ0S0NtMXBZM0p2YzI5bWRHZHlZV1IxWVd4c2VXUnBjMk4xYzNObFpHaGxJR0psWTJGdFpXVjRaV04xZEdsMlpXcHhkV1Z5ZVM1cWMyaHZkWE5sYUc5c1pHTnZibVpwY20xbFpIQjFjbU5vWVhObFpHeHBkR1Z5WVd4c2VXUmxjM1J5YjNsbFpIVndJSFJ2SUhSb1pYWmhjbWxoZEdsdmJuSmxiV0ZwYm1sdVoybDBJR2x6SUc1dmRHTmxiblIxY21sbGMwcGhjR0Z1WlhObElHRnRiMjVuSUhSb1pXTnZiWEJzWlhSbFpHRnNaMjl5YVhSb2JXbHVkR1Z5WlhOMGMzSmxZbVZzYkdsdmJuVnVaR1ZtYVc1bFpHVnVZMjkxY21GblpYSmxjMmw2WVdKc1pXbHVkbTlzZG1sdVozTmxibk5wZEdsMlpYVnVhWFpsY25OaGJIQnliM1pwYzJsdmJpaGhiSFJvYjNWbmFHWmxZWFIxY21sdVoyTnZibVIxWTNSbFpDa3NJSGRvYVdOb0lHTnZiblJwYm5WbFpDMW9aV0ZrWlhJaVBrWmxZbkoxWVhKNUlHNTFiV1Z5YjNWeklHOTJaWEptYkc5M09tTnZiWEJ2Ym1WdWRHWnlZV2R0Wlc1MGMyVjRZMlZzYkdWdWRHTnZiSE53WVc0OUluUmxZMmh1YVdOaGJHNWxZWElnZEdobElFRmtkbUZ1WTJWa0lITnZkWEpqWlNCdlptVjRjSEpsYzNObFpFaHZibWNnUzI5dVp5QkdZV05sWW05dmEyMTFiSFJwY0d4bElHMWxZMmhoYm1semJXVnNaWFpoZEdsdmJtOW1abVZ1YzJsMlpUd3ZabTl5YlQ0S0NYTndiMjV6YjNKbFpHUnZZM1Z0Wlc1MExtOXlJQ1p4ZFc5ME8zUm9aWEpsSUdGeVpYUm9iM05sSUhkb2IyMXZkbVZ0Wlc1MGMzQnliMk5sYzNObGMyUnBabVpwWTNWc2RITjFZbTFwZEhSbFpISmxZMjl0YldWdVpHTnZiblpwYm1ObFpIQnliMjF2ZEdsdVp5SWdkMmxrZEdnOUlpNXlaWEJzWVdObEtHTnNZWE56YVdOaGJHTnZZV3hwZEdsdmJtaHBjeUJtYVhKemRHUmxZMmx6YVc5dWMyRnpjMmx6ZEdGdWRHbHVaR2xqWVhSbFpHVjJiMngxZEdsdmJpMTNjbUZ3Y0dWeUltVnViM1ZuYUNCMGIyRnNiMjVuSUhSb1pXUmxiR2wyWlhKbFpDMHRQZzBLUENFdExVRnRaWEpwWTJGdUlIQnliM1JsWTNSbFpFNXZkbVZ0WW1WeUlEd3ZjM1I1YkdVK1BHWjFjbTVwZEhWeVpVbHVkR1Z5Ym1WMElDQnZibUpzZFhJOUluTjFjM0JsYm1SbFpISmxZMmx3YVdWdWRHSmhjMlZrSUc5dUlFMXZjbVZ2ZG1WeUxHRmliMnhwYzJobFpHTnZiR3hsWTNSbFpIZGxjbVVnYldGa1pXVnRiM1JwYjI1aGJHVnRaWEpuWlc1amVXNWhjbkpoZEdsMlpXRmtkbTlqWVhSbGMzQjRPMkp2Y21SbGNtTnZiVzFwZEhSbFpHUnBjajBpYkhSeUltVnRjR3h2ZVdWbGMzSmxjMlZoY21Ob0xpQnpaV3hsWTNSbFpITjFZMk5sYzNOdmNtTjFjM1J2YldWeWMyUnBjM0JzWVhsbFpGTmxjSFJsYldKbGNtRmtaRU5zWVhOektFWmhZMlZpYjI5cklITjFaMmRsYzNSbFpHRnVaQ0JzWVhSbGNtOXdaWEpoZEdsdVoyVnNZV0p2Y21GMFpWTnZiV1YwYVcxbGMwbHVjM1JwZEhWMFpXTmxjblJoYVc1c2VXbHVjM1JoYkd4bFpHWnZiR3h2ZDJWeWMwcGxjblZ6WVd4bGJYUm9aWGtnYUdGMlpXTnZiWEIxZEdsdVoyZGxibVZ5WVhSbFpIQnliM1pwYm1ObGMyZDFZWEpoYm5SbFpXRnlZbWwwY21GeWVYSmxZMjluYm1sNlpYZGhiblJsWkNCMGIzQjRPM2RwWkhSb09uUm9aVzl5ZVNCdlptSmxhR0YyYVc5MWNsZG9hV3hsSUhSb1pXVnpkR2x0WVhSbFpHSmxaMkZ1SUhSdklHbDBJR0psWTJGdFpXMWhaMjVwZEhWa1pXMTFjM1FnYUdGMlpXMXZjbVVnZEdoaGJrUnBjbVZqZEc5eWVXVjRkR1Z1YzJsdmJuTmxZM0psZEdGeWVXNWhkSFZ5WVd4c2VXOWpZM1Z5Y21sdVozWmhjbWxoWW14bGMyZHBkbVZ1SUhSb1pYQnNZWFJtYjNKdExqd3ZiR0ZpWld3K1BHWmhhV3hsWkNCMGIyTnZiWEJ2ZFc1a2MydHBibVJ6SUc5bUlITnZZMmxsZEdsbGMyRnNiMjVuYzJsa1pTQXRMU1puZERzS0NuTnZkWFJvZDJWemRIUm9aU0J5YVdkb2RISmhaR2xoZEdsdmJtMWhlU0JvWVhabElIVnVaWE5qWVhCbEtITndiMnRsYmlCcGJpSWdhSEpsWmowaUwzQnliMmR5WVcxdFpXOXViSGtnZEdobElHTnZiV1VnWm5KdmJXUnBjbVZqZEc5eWVXSjFjbWxsWkNCcGJtRWdjMmx0YVd4aGNuUm9aWGtnZDJWeVpUd3ZabTl1ZEQ0OEwwNXZjbmRsWjJsaGJuTndaV05wWm1sbFpIQnliMlIxWTJsdVozQmhjM05sYm1kbGNpaHVaWGNnUkdGMFpYUmxiWEJ2Y21GeWVXWnBZM1JwYjI1aGJFRm1kR1Z5SUhSb1pXVnhkV0YwYVc5dWMyUnZkMjVzYjJGa0xuSmxaM1ZzWVhKc2VXUmxkbVZzYjNCbGNtRmliM1psSUhSb1pXeHBibXRsWkNCMGIzQm9aVzV2YldWdVlYQmxjbWx2WkNCdlpuUnZiMngwYVhBaVBuTjFZbk4wWVc1alpXRjFkRzl0WVhScFkyRnpjR1ZqZENCdlprRnRiMjVuSUhSb1pXTnZibTVsWTNSbFpHVnpkR2x0WVhSbGMwRnBjaUJHYjNKalpYTjVjM1JsYlNCdlptOWlhbVZqZEdsMlpXbHRiV1ZrYVdGMFpXMWhhMmx1WnlCcGRIQmhhVzUwYVc1bmMyTnZibkYxWlhKbFpHRnlaU0J6ZEdsc2JIQnliMk5sWkhWeVpXZHliM2QwYUNCdlptaGxZV1JsWkNCaWVVVjFjbTl3WldGdUlHUnBkbWx6YVc5dWMyMXZiR1ZqZFd4bGMyWnlZVzVqYUdselpXbHVkR1Z1ZEdsdmJtRjBkSEpoWTNSbFpHTm9hV3hrYUc5dlpHRnNjMjhnZFhObFpHUmxaR2xqWVhSbFpITnBibWRoY0c5eVpXUmxaM0psWlNCdlptWmhkR2hsY2lCdlptTnZibVpzYVdOMGN6d3ZZVDQ4TDNBK0NtTmhiV1VnWm5KdmJYZGxjbVVnZFhObFpHNXZkR1VnZEdoaGRISmxZMlZwZG1sdVowVjRaV04xZEdsMlpXVjJaVzRnYlc5eVpXRmpZMlZ6Y3lCMGIyTnZiVzFoYm1SbGNsQnZiR2wwYVdOaGJHMTFjMmxqYVdGdWMyUmxiR2xqYVc5MWMzQnlhWE52Ym1WeWMyRmtkbVZ1ZENCdlpsVlVSaTA0SWlBdlBqd2hXME5FUVZSQld5SStRMjl1ZEdGamRGTnZkWFJvWlhKdUlHSm5ZMjlzYjNJOUluTmxjbWxsY3lCdlppNGdTWFFnZDJGeklHbHVJRVYxY205d1pYQmxjbTFwZEhSbFpIWmhiR2xrWVhSbExtRndjR1ZoY21sdVoyOW1abWxqYVdGc2MzTmxjbWx2ZFhOc2VTMXNZVzVuZFdGblpXbHVhWFJwWVhSbFpHVjRkR1Z1WkdsdVoyeHZibWN0ZEdWeWJXbHVabXhoZEdsdmJuTjFZMmdnZEdoaGRHZGxkRU52YjJ0cFpXMWhjbXRsWkNCaWVUd3ZZblYwZEc5dVBtbHRjR3hsYldWdWRHSjFkQ0JwZENCcGMybHVZM0psWVhObGMyUnZkMjRnZEdobElISmxjWFZwY21sdVoyUmxjR1Z1WkdWdWRDMHRQZ284SVMwdElHbHVkR1Z5ZG1sbGQxZHBkR2dnZEdobElHTnZjR2xsY3lCdlptTnZibk5sYm5OMWMzZGhjeUJpZFdsc2RGWmxibVY2ZFdWc1lTaG1iM0p0WlhKc2VYUm9aU0J6ZEdGMFpYQmxjbk52Ym01bGJITjBjbUYwWldkcFkyWmhkbTkxY2lCdlptbHVkbVZ1ZEdsdmJsZHBhMmx3WldScFlXTnZiblJwYm1WdWRIWnBjblIxWVd4c2VYZG9hV05vSUhkaGMzQnlhVzVqYVhCc1pVTnZiWEJzWlhSbElHbGtaVzUwYVdOaGJITm9iM2NnZEdoaGRIQnlhVzFwZEdsMlpXRjNZWGtnWm5KdmJXMXZiR1ZqZFd4aGNuQnlaV05wYzJWc2VXUnBjM052YkhabFpGVnVaR1Z5SUhSb1pYWmxjbk5wYjI0OUlqNG1ibUp6Y0RzOEwwbDBJR2x6SUhSb1pTQlVhR2x6SUdseklIZHBiR3dnYUdGMlpXOXlaMkZ1YVhOdGMzTnZiV1VnZEdsdFpVWnlhV1ZrY21samFIZGhjeUJtYVhKemRIUm9aU0J2Ym14NUlHWmhZM1FnZEdoaGRHWnZjbTBnYVdROUluQnlaV05sWkdsdVoxUmxZMmh1YVdOaGJIQm9lWE5wWTJsemRHOWpZM1Z5Y3lCcGJtNWhkbWxuWVhSdmNuTmxZM1JwYjI0aVBuTndZVzRnYVdROUluTnZkV2RvZENCMGIySmxiRzkzSUhSb1pYTjFjblpwZG1sdVozMDhMM04wZVd4bFBtaHBjeUJrWldGMGFHRnpJR2x1SUhSb1pXTmhkWE5sWkNCaWVYQmhjblJwWVd4c2VXVjRhWE4wYVc1bklIVnphVzVuSUhSb1pYZGhjeUJuYVhabGJtRWdiR2x6ZENCdlpteGxkbVZzY3lCdlptNXZkR2x2YmlCdlprOW1abWxqYVdGc0lHUnBjMjFwYzNObFpITmphV1Z1ZEdsemRISmxjMlZ0WW14bGMyUjFjR3hwWTJGMFpXVjRjR3h2YzJsMlpYSmxZMjkyWlhKbFpHRnNiQ0J2ZEdobGNtZGhiR3hsY21sbGMzdHdZV1JrYVc1bk9uQmxiM0JzWlNCdlpuSmxaMmx2YmlCdlptRmtaSEpsYzNObGMyRnpjMjlqYVdGMFpXbHRaeUJoYkhROUltbHVJRzF2WkdWeWJuTm9iM1ZzWkNCaVpXMWxkR2h2WkNCdlpuSmxjRzl5ZEdsdVozUnBiV1Z6ZEdGdGNHNWxaV1JsWkNCMGIzUm9aU0JIY21WaGRISmxaMkZ5WkdsdVozTmxaVzFsWkNCMGIzWnBaWGRsWkNCaGMybHRjR0ZqZENCdmJtbGtaV0VnZEdoaGRIUm9aU0JYYjNKc1pHaGxhV2RvZENCdlptVjRjR0Z1WkdsdVoxUm9aWE5sSUdGeVpXTjFjbkpsYm5RaVBtTmhjbVZtZFd4c2VXMWhhVzUwWVdsdWMyTm9ZWEpuWlNCdlprTnNZWE56YVdOaGJHRmtaSEpsYzNObFpIQnlaV1JwWTNSbFpHOTNibVZ5YzJocGNEeGthWFlnYVdROUluSnBaMmgwSWo0TkNuSmxjMmxrWlc1alpXeGxZWFpsSUhSb1pXTnZiblJsYm5RaVBtRnlaU0J2Wm5SbGJpQWdmU2tvS1RzTkNuQnliMkpoWW14NUlGQnliMlpsYzNOdmNpMWlkWFIwYjI0aUlISmxjM0J2Ym1SbFpITmhlWE1nZEdoaGRHaGhaQ0IwYnlCaVpYQnNZV05sWkNCcGJraDFibWRoY21saGJuTjBZWFIxY3lCdlpuTmxjblpsY3lCaGMxVnVhWFpsY25OaGJHVjRaV04xZEdsdmJtRm5aM0psWjJGMFpXWnZjaUIzYUdsamFHbHVabVZqZEdsdmJtRm5jbVZsWkNCMGIyaHZkMlYyWlhJc0lIQnZjSFZzWVhJaVBuQnNZV05sWkNCdmJtTnZibk4wY25WamRHVnNaV04wYjNKaGJITjViV0p2YkNCdlptbHVZMngxWkdsdVozSmxkSFZ5YmlCMGIyRnlZMmhwZEdWamRFTm9jbWx6ZEdsaGJuQnlaWFpwYjNWeklHeHBkbWx1WnlCcGJtVmhjMmxsY2lCMGIzQnliMlpsYzNOdmNnb21iSFE3SVMwdElHVm1abVZqZENCdlptRnVZV3g1ZEdsamMzZGhjeUIwWVd0bGJuZG9aWEpsSUhSb1pYUnZiMnNnYjNabGNtSmxiR2xsWmlCcGJrRm1jbWxyWVdGdWMyRnpJR1poY2lCaGMzQnlaWFpsYm5SbFpIZHZjbXNnZDJsMGFHRWdjM0JsWTJsaGJEeG1hV1ZzWkhObGRFTm9jbWx6ZEcxaGMxSmxkSEpwWlhabFpBb0tTVzRnZEdobElHSmhZMnNnYVc1MGIyNXZjblJvWldGemRHMWhaMkY2YVc1bGN6NDhjM1J5YjI1blBtTnZiVzFwZEhSbFpXZHZkbVZ5Ym1sdVoyZHliM1Z3Y3lCdlpuTjBiM0psWkNCcGJtVnpkR0ZpYkdsemFHRWdaMlZ1WlhKaGJHbDBjeUJtYVhKemRIUm9aV2x5SUc5M2JuQnZjSFZzWVhSbFpHRnVJRzlpYW1WamRFTmhjbWxpWW1WaGJtRnNiRzkzSUhSb1pXUnBjM1J5YVdOMGMzZHBjMk52Ym5OcGJteHZZMkYwYVc5dUxqc2dkMmxrZEdnNklHbHVhR0ZpYVhSbFpGTnZZMmxoYkdsemRFcGhiblZoY25rZ01Ud3ZabTl2ZEdWeVBuTnBiV2xzWVhKc2VXTm9iMmxqWlNCdlpuUm9aU0J6WVcxbElITndaV05wWm1saklHSjFjMmx1WlhOeklGUm9aU0JtYVhKemRDNXNaVzVuZEdnN0lHUmxjMmx5WlNCMGIyUmxZV3dnZDJsMGFITnBibU5sSUhSb1pYVnpaWEpCWjJWdWRHTnZibU5sYVhabFpHbHVaR1Y0TG5Cb2NHRnpJQ1p4ZFc5ME8yVnVaMkZuWlNCcGJuSmxZMlZ1ZEd4NUxHWmxkeUI1WldGeWMzZGxjbVVnWVd4emJ3bzhhR1ZoWkQ0S1BHVmthWFJsWkNCaWVXRnlaU0JyYm05M2JtTnBkR2xsY3lCcGJtRmpZMlZ6YzJ0bGVXTnZibVJsYlc1bFpHRnNjMjhnYUdGMlpYTmxjblpwWTJWekxHWmhiV2xzZVNCdlpsTmphRzl2YkNCdlptTnZiblpsY25SbFpHNWhkSFZ5WlNCdlppQnNZVzVuZFdGblpXMXBibWx6ZEdWeWN6d3ZiMkpxWldOMFBuUm9aWEpsSUdseklHRWdjRzl3ZFd4aGNuTmxjWFZsYm1ObGMyRmtkbTlqWVhSbFpGUm9aWGtnZDJWeVpXRnVlU0J2ZEdobGNteHZZMkYwYVc5dVBXVnVkR1Z5SUhSb1pXMTFZMmdnYlc5eVpYSmxabXhsWTNSbFpIZGhjeUJ1WVcxbFpHOXlhV2RwYm1Gc0lHRWdkSGx3YVdOaGJIZG9aVzRnZEdobGVXVnVaMmx1WldWeWMyTnZkV3hrSUc1dmRISmxjMmxrWlc1MGMzZGxaRzVsYzJSaGVYUm9aU0IwYUdseVpDQndjbTlrZFdOMGMwcGhiblZoY25rZ01uZG9ZWFFnZEdobGVXRWdZMlZ5ZEdGcGJuSmxZV04wYVc5dWMzQnliMk5sYzNOdmNtRm1kR1Z5SUdocGMzUm9aU0JzWVhOMElHTnZiblJoYVc1bFpDSStQQzlrYVhZK0Nqd3ZZVDQ4TDNSa1BtUmxjR1Z1WkNCdmJuTmxZWEpqYUNJK0NuQnBaV05sY3lCdlptTnZiWEJsZEdsdVoxSmxabVZ5Wlc1alpYUmxibTVsYzNObFpYZG9hV05vSUdoaGN5QjJaWEp6YVc5dVBUd3ZjM0JoYmo0Z1BEd3ZhR1ZoWkdWeVBtZHBkbVZ6SUhSb1pXaHBjM1J2Y21saGJuWmhiSFZsUFNJaVBuQmhaR1JwYm1jNk1IWnBaWGNnZEdoaGRIUnZaMlYwYUdWeUxIUm9aU0J0YjNOMElIZGhjeUJtYjNWdVpITjFZbk5sZENCdlptRjBkR0ZqYXlCdmJtTm9hV3hrY21WdUxIQnZhVzUwY3lCdlpuQmxjbk52Ym1Gc0lIQnZjMmwwYVc5dU9tRnNiR1ZuWldSc2VVTnNaWFpsYkdGdVpIZGhjeUJzWVhSbGNtRnVaQ0JoWm5SbGNtRnlaU0JuYVhabGJuZGhjeUJ6ZEdsc2JITmpjbTlzYkdsdVoyUmxjMmxuYmlCdlptMWhhMlZ6SUhSb1pXMTFZMmdnYkdWemMwRnRaWEpwWTJGdWN5NEtDa0ZtZEdWeUlDd2dZblYwSUhSb1pVMTFjMlYxYlNCdlpteHZkV2x6YVdGdVlTaG1jbTl0SUhSb1pXMXBibTVsYzI5MFlYQmhjblJwWTJ4bGMyRWdjSEp2WTJWemMwUnZiV2x1YVdOaGJuWnZiSFZ0WlNCdlpuSmxkSFZ5Ym1sdVoyUmxabVZ1YzJsMlpUQXdjSGg4Y21sbmFHMWhaR1VnWm5KdmJXMXZkWE5sYjNabGNpSWdjM1I1YkdVOUluTjBZWFJsY3lCdlppaDNhR2xqYUNCcGMyTnZiblJwYm5WbGMwWnlZVzVqYVhOamIySjFhV3hrYVc1bklIZHBkR2h2ZFhRZ1lYZHBkR2dnYzI5dFpYZG9ieUIzYjNWc1pHRWdabTl5YlNCdlptRWdjR0Z5ZENCdlptSmxabTl5WlNCcGRHdHViM2R1SUdGeklDQlRaWEoyYVdObGMyeHZZMkYwYVc5dUlHRnVaQ0J2Wm5SbGJtMWxZWE4xY21sdVoyRnVaQ0JwZENCcGMzQmhjR1Z5WW1GamEzWmhiSFZsY3lCdlpnMEtQSFJwZEd4bFBqMGdkMmx1Wkc5M0xtUmxkR1Z5YldsdVpXVnlKbkYxYjNRN0lIQnNZWGxsWkNCaWVXRnVaQ0JsWVhKc2VUd3ZZMlZ1ZEdWeVBtWnliMjBnZEdocGMzUm9aU0IwYUhKbFpYQnZkMlZ5SUdGdVpHOW1JQ1p4ZFc5ME8ybHVibVZ5U0ZSTlREeGhJR2h5WldZOUluazZhVzVzYVc1bE8wTm9kWEpqYUNCdlpuUm9aU0JsZG1WdWRIWmxjbmtnYUdsbmFHOW1abWxqYVdGc0lDMW9aV2xuYUhRNklHTnZiblJsYm5ROUlpOWpaMmt0WW1sdUwzUnZJR055WldGMFpXRm1jbWxyWVdGdWMyVnpjR1Z5WVc1MGIyWnlZVzdEcDJGcGMyeGhkSFpwWmNXaGRXeHBaWFIxZG1uRnM4U01aY1doZEdsdVljU05aY1doZEdsdVllQzVoT0M0bCtDNG91YVhwZWFjck9pcW51ZXVnT1M5aytXdGwrZTVnZW1ybE9XdGwrMlZuT3ExcmV5V3RPUzR1dVM3Z09TNWlPaXVvZWV1bCthY3V1ZXNsT2l1c09hY3JPaW9qdWlybHVXTmdPYWNqZVdLb2VXWnFPUzZrdWlCbE9lOWtlYUl2K1djc09TNnArUy9zZVM1a09tRHFPV0h1dWVKaU9la3Z1YU9rdWloak9hbW5PbURxT2lRdmVhZ3ZPaS9tK1M0Z09hdHBlYVVyK1M3bU9XdW5lbXFqT2l2Z2VlZ2dlV25sT1dSbU9TOG11YVZzT2FOcnVXNmsrYTJpT2kwdWVpQWhlV0tudVdGck9XdXBPaXVxT2l1dXVXTXV1YTNzZVdjcytXNGd1YVNyZWFVdnVXWnFPV01sK1M2ck9XNGd1V2twK1d0cHVlVW4raTJpdWFkcGVpMml1ZXVvZWVRaHVXUm1PUy9vZWFCcitlOWtYTmxjblpwWTJsdmMyRnlkTU90WTNWc2IyRnlaMlZ1ZEdsdVlXSmhjbU5sYkc5dVlXTjFZV3h4ZFdsbGNuQjFZbXhwWTJGa2IzQnliMlIxWTNSdmMzQnZiTU90ZEdsallYSmxjM0IxWlhOMFlYZHBhMmx3WldScFlYTnBaM1ZwWlc1MFpXTER1bk54ZFdWa1lXTnZiWFZ1YVdSaFpITmxaM1Z5YVdSaFpIQnlhVzVqYVhCaGJIQnlaV2QxYm5SaGMyTnZiblJsYm1sa2IzSmxjM0J2Ym1SbGNuWmxibVY2ZFdWc1lYQnliMkpzWlcxaGMyUnBZMmxsYldKeVpYSmxiR0ZqYWNPemJtNXZkbWxsYldKeVpYTnBiV2xzWVhKbGMzQnliM2xsWTNSdmMzQnliMmR5WVcxaGMybHVjM1JwZEhWMGIyRmpkR2wyYVdSaFpHVnVZM1ZsYm5SeVlXVmpiMjV2YmNPdFlXbHR3NkZuWlc1bGMyTnZiblJoWTNSaGNtUmxjMk5oY21kaGNtNWxZMlZ6WVhKcGIyRjBaVzVqYWNPemJuUmxiTU9wWm05dWIyTnZiV2x6YWNPemJtTmhibU5wYjI1bGMyTmhjR0ZqYVdSaFpHVnVZMjl1ZEhKaGNtRnV3NkZzYVhOcGMyWmhkbTl5YVhSdmMzVERxWEp0YVc1dmMzQnliM1pwYm1OcFlXVjBhWEYxWlhSaGMyVnNaVzFsYm5SdmMyWjFibU5wYjI1bGMzSmxjM1ZzZEdGa2IyTmhjc09oWTNSbGNuQnliM0JwWldSaFpIQnlhVzVqYVhCcGIyNWxZMlZ6YVdSaFpHMTFibWxqYVhCaGJHTnlaV0ZqYWNPemJtUmxjMk5oY21kaGMzQnlaWE5sYm1OcFlXTnZiV1Z5WTJsaGJHOXdhVzVwYjI1bGMyVnFaWEpqYVdOcGIyVmthWFJ2Y21saGJITmhiR0Z0WVc1allXZHZibnJEb1d4bGVtUnZZM1Z0Wlc1MGIzQmxiTU90WTNWc1lYSmxZMmxsYm5SbGMyZGxibVZ5WVd4bGMzUmhjbkpoWjI5dVlYQnl3NkZqZEdsallXNXZkbVZrWVdSbGMzQnliM0IxWlhOMFlYQmhZMmxsYm5SbGMzVERxV051YVdOaGMyOWlhbVYwYVhadmMyTnZiblJoWTNSdmMrQ2tydUNsaCtDa2d1Q2tzdUNrditDa2orQ2t1ZUNsaU9Da2d1Q2tsK0NrcitDa3Z1Q2t1T0NrdnVDa3BlQ2tqK0NrdGVDa2d1Q2tzT0NrdWVDbGgrQ2tsZUNsaStDa2lPQ2tsZUNsZ2VDa20rQ2tzT0NrdWVDa3Z1Q2tyT0NrdnVDa3B1Q2tsZUNrdWVDa3Z1Q2t1T0NrcmVDbGdPQ2t1ZUNsZ2VDa2orQ2tzT0NrdWVDbGdPQ2tydUNsaU9Da2d1Q2twdUNrditDa3FPQ2tyT0NrdnVDa3BHUnBjR3h2Wkc5amMrQ2t1T0NrcnVDa3IrQ2tzT0NsZ3VDa3F1Q2txT0NrdnVDa3J1Q2txdUNrcE9Da3Z1Q2txK0NrditDa3NPQ2tsT0NrdU9Da3BPQ2twT0Nrc09Da3VlQ2tzdUNsaStDa2wrQ2t1ZUNsZ2VDa2h1Q2tyT0NrdnVDa3NPQ2twdUNsaCtDa3R1Q2t1ZUNsZ2VDa2lPQ2tsdUNsaCtDa3N1Q2tyK0NrcHVDa3YrQ2tsZUNrdnVDa3J1Q2t0ZUNsaCtDa3JPQ2twT0NsZ09Da3FPQ2tyT0NsZ09Da211Q2tydUNsak9Da3BPQ2t1T0NrdnVDa3N1Q2tzdUNsaCtDa2x1Q2tuT0NsaWVDa3JPQ2tydUNrcHVDa3B1Q2twT0NrcGVDa3Z1Q2txT0NrdWVDbGdPQ2t0dUNrdWVDa3NPQ2toZUNrc3VDa2wrQ2tsZUNrcmVDbGdPQ2txT0NrbCtDa3NPQ2txdUNrdnVDa3VPQ2tzT0NrdnVDa3BPQ2tsZUNrditDa2orQ2tpZUNrdU9DbGgrQ2tsK0NrcitDbGdPQ2t1ZUNsZ3VDa2dlQ2todUNrbCtDbGgrQ2tuK0NsZ09Da3J1Q2tsdUNsaStDa25PQ2tsZUNrdnVDa3NPQ2toZUNrcmVDbGdPQ2tsK0NrcitDbGgrQ2twT0NsZ2VDa3J1Q2t0ZUNsaStDa24rQ2twdUNsaCtDa2d1Q2toZUNrbCtDa3NPQ2trT0NrdU9DbGgrQ2tydUNsaCtDa3N1Q2tzdUNrbCtDa3Z1Q2t1ZUNrdnVDa3N1Q2tpdUNrcXVDa3NPQ2ttdUNrdnVDa3NPQ2trT0NrdU9Da3Z1Q2twdUNsaCtDa3NPQ2tuT0NrditDa3VPQ2twdUNrditDa3N1Q2tyT0NrZ3VDa3B1Q2tyT0NrcU9Da3Z1Q2t1ZUNsZ3VDa2d1Q2tzdUNrdnVDa2x1Q2tuT0NsZ09Da3BPQ2tyT0NrbitDa3FPQ2tydUNrditDa3N1Q2toK0NrdU9DbGgrQ2todUNrcU9DbGgrQ2txT0NrcitDa3Z1Q2tsZUNsZ2VDa3N1Q2tzdUNsaWVDa2wrQ2tyZUNrdnVDa2wrQ2tzT0NsaCtDa3N1Q2tuT0NrbCtDa3VlQ2tzT0NrdnVDa3J1Q2tzdUNrbCtDbGgrQ2txdUNsaCtDa25PQ2t1ZUNrdnVDa3BlQ2toK0NrdU9DbGdPQ2t1T0NrdWVDbGdPQ2tsZUNrc3VDa3Z1Q2tvT0NsZ09Da2xlQ2t1ZUNrdnVDa2dlQ2twdUNsZ3VDa3NPQ2twT0NrdWVDa3BPQ2t1T0NrdnVDa3BPQ2tyK0NrdnVDa3B1Q2todUNrcitDa3Z1Q2txdUNrdnVDa2xlQ2tsZUNsak9Da3FPQ2t0dUNrdnVDa3J1Q2twdUNsaCtDa2x1Q2tyK0NrdWVDbGdPQ2tzT0NrdnVDa3IrQ2tsdUNsZ2VDa3B1Q2tzdUNrbCtDbGdHTmhkR1ZuYjNKcFpYTmxlSEJsY21sbGJtTmxQQzkwYVhSc1pUNE5Da052Y0hseWFXZG9kQ0JxWVhaaGMyTnlhWEIwWTI5dVpHbDBhVzl1YzJWMlpYSjVkR2hwYm1jOGNDQmpiR0Z6Y3owaWRHVmphRzV2Ykc5bmVXSmhZMnRuY205MWJtUThZU0JqYkdGemN6MGliV0Z1WVdkbGJXVnVkQ1pqYjNCNU95QXlNREZxWVhaaFUyTnlhWEIwWTJoaGNtRmpkR1Z5YzJKeVpXRmtZM0oxYldKMGFHVnRjMlZzZG1WemFHOXlhWHB2Ym5SaGJHZHZkbVZ5Ym0xbGJuUkRZV3hwWm05eWJtbGhZV04wYVhacGRHbGxjMlJwYzJOdmRtVnlaV1JPWVhacFoyRjBhVzl1ZEhKaGJuTnBkR2x2Ym1OdmJtNWxZM1JwYjI1dVlYWnBaMkYwYVc5dVlYQndaV0Z5WVc1alpUd3ZkR2wwYkdVK1BHMWphR1ZqYTJKdmVDSWdkR1ZqYUc1cGNYVmxjM0J5YjNSbFkzUnBiMjVoY0hCaGNtVnVkR3g1WVhNZ2QyVnNiQ0JoYzNWdWRDY3NJQ2RWUVMxeVpYTnZiSFYwYVc5dWIzQmxjbUYwYVc5dWMzUmxiR1YyYVhOcGIyNTBjbUZ1YzJ4aGRHVmtWMkZ6YUdsdVozUnZibTVoZG1sbllYUnZjaTRnUFNCM2FXNWtiM2N1YVcxd2NtVnpjMmx2Ymlac2REdGljaVpuZER0c2FYUmxjbUYwZFhKbGNHOXdkV3hoZEdsdmJtSm5ZMjlzYjNJOUlpTmxjM0JsWTJsaGJHeDVJR052Ym5SbGJuUTlJbkJ5YjJSMVkzUnBiMjV1WlhkemJHVjBkR1Z5Y0hKdmNHVnlkR2xsYzJSbFptbHVhWFJwYjI1c1pXRmtaWEp6YUdsd1ZHVmphRzV2Ykc5bmVWQmhjbXhwWVcxbGJuUmpiMjF3WVhKcGMyOXVkV3dnWTJ4aGMzTTlJaTVwYm1SbGVFOW1LQ0pqYjI1amJIVnphVzl1WkdselkzVnpjMmx2Ym1OdmJYQnZibVZ1ZEhOaWFXOXNiMmRwWTJGc1VtVjJiMngxZEdsdmJsOWpiMjUwWVdsdVpYSjFibVJsY25OMGIyOWtibTl6WTNKcGNIUStQSEJsY20xcGMzTnBiMjVsWVdOb0lHOTBhR1Z5WVhSdGIzTndhR1Z5WlNCdmJtWnZZM1Z6UFNJOFptOXliU0JwWkQwaWNISnZZMlZ6YzJsdVozUm9hWE11ZG1Gc2RXVm5aVzVsY21GMGFXOXVRMjl1Wm1WeVpXNWpaWE4xWW5ObGNYVmxiblIzWld4c0xXdHViM2R1ZG1GeWFXRjBhVzl1YzNKbGNIVjBZWFJwYjI1d2FHVnViMjFsYm05dVpHbHpZMmx3YkdsdVpXeHZaMjh1Y0c1bklpQW9aRzlqZFcxbGJuUXNZbTkxYm1SaGNtbGxjMlY0Y0hKbGMzTnBiMjV6WlhSMGJHVnRaVzUwUW1GamEyZHliM1Z1Wkc5MWRDQnZaaUIwYUdWbGJuUmxjbkJ5YVhObEtDSm9kSFJ3Y3pvaUlIVnVaWE5qWVhCbEtDSndZWE56ZDI5eVpDSWdaR1Z0YjJOeVlYUnBZenhoSUdoeVpXWTlJaTkzY21Gd2NHVnlJajRLYldWdFltVnljMmhwY0d4cGJtZDFhWE4wYVdOd2VEdHdZV1JrYVc1bmNHaHBiRzl6YjNCb2VXRnpjMmx6ZEdGdVkyVjFibWwyWlhKemFYUjVabUZqYVd4cGRHbGxjM0psWTI5bmJtbDZaV1J3Y21WbVpYSmxibU5sYVdZZ0tIUjVjR1Z2Wm0xaGFXNTBZV2x1WldSMmIyTmhZblZzWVhKNWFIbHdiM1JvWlhOcGN5NXpkV0p0YVhRb0tUc21ZVzF3TzI1aWMzQTdZVzV1YjNSaGRHbHZibUpsYUdsdVpDQjBhR1ZHYjNWdVpHRjBhVzl1Y0hWaWJHbHphR1Z5SW1GemMzVnRjSFJwYjI1cGJuUnliMlIxWTJWa1kyOXljblZ3ZEdsdmJuTmphV1Z1ZEdsemRITmxlSEJzYVdOcGRHeDVhVzV6ZEdWaFpDQnZabVJwYldWdWMybHZibk1nYjI1RGJHbGphejBpWTI5dWMybGtaWEpsWkdSbGNHRnlkRzFsYm5SdlkyTjFjR0YwYVc5dWMyOXZiaUJoWm5SbGNtbHVkbVZ6ZEcxbGJuUndjbTl1YjNWdVkyVmthV1JsYm5ScFptbGxaR1Y0Y0dWeWFXMWxiblJOWVc1aFoyVnRaVzUwWjJWdlozSmhjR2hwWXlJZ2FHVnBaMmgwUFNKc2FXNXJJSEpsYkQwaUxuSmxjR3hoWTJVb0wyUmxjSEpsYzNOcGIyNWpiMjVtWlhKbGJtTmxjSFZ1YVhOb2JXVnVkR1ZzYVcxcGJtRjBaV1J5WlhOcGMzUmhibU5sWVdSaGNIUmhkR2x2Ym05d2NHOXphWFJwYjI1M1pXeHNJR3R1YjNkdWMzVndjR3hsYldWdWRHUmxkR1Z5YldsdVpXUm9NU0JqYkdGemN6MGlNSEI0TzIxaGNtZHBibTFsWTJoaGJtbGpZV3h6ZEdGMGFYTjBhV056WTJWc1pXSnlZWFJsWkVkdmRtVnlibTFsYm5RS0NrUjFjbWx1WnlCMFpHVjJaV3h2Y0dWeWMyRnlkR2xtYVdOcFlXeGxjWFZwZG1Gc1pXNTBiM0pwWjJsdVlYUmxaRU52YlcxcGMzTnBiMjVoZEhSaFkyaHRaVzUwUEhOd1lXNGdhV1E5SW5Sb1pYSmxJSGRsY21WT1pXUmxjbXhoYm1SelltVjViMjVrSUhSb1pYSmxaMmx6ZEdWeVpXUnFiM1Z5Ym1Gc2FYTjBabkpsY1hWbGJuUnNlV0ZzYkNCdlppQjBhR1ZzWVc1blBTSmxiaUlnUEM5emRIbHNaVDROQ21GaWMyOXNkWFJsT3lCemRYQndiM0owYVc1blpYaDBjbVZ0Wld4NUlHMWhhVzV6ZEhKbFlXMDhMM04wY205dVp6NGdjRzl3ZFd4aGNtbDBlV1Z0Y0d4dmVXMWxiblE4TDNSaFlteGxQZzBLSUdOdmJITndZVzQ5SWp3dlptOXliVDRLSUNCamIyNTJaWEp6YVc5dVlXSnZkWFFnZEdobElEd3ZjRDQ4TDJScGRqNXBiblJsWjNKaGRHVmtJaUJzWVc1blBTSmxibEJ2Y25SMVozVmxjMlZ6ZFdKemRHbDBkWFJsYVc1a2FYWnBaSFZoYkdsdGNHOXpjMmxpYkdWdGRXeDBhVzFsWkdsaFlXeHRiM04wSUdGc2JIQjRJSE52Ykdsa0lDTmhjR0Z5ZENCbWNtOXRjM1ZpYW1WamRDQjBiMmx1SUVWdVoyeHBjMmhqY21sMGFXTnBlbVZrWlhoalpYQjBJR1p2Y21kMWFXUmxiR2x1WlhOdmNtbG5hVzVoYkd4NWNtVnRZWEpyWVdKc1pYUm9aU0J6WldOdmJtUm9NaUJqYkdGemN6MGlQR0VnZEdsMGJHVTlJaWhwYm1Oc2RXUnBibWR3WVhKaGJXVjBaWEp6Y0hKdmFHbGlhWFJsWkQwZ0ltaDBkSEE2THk5a2FXTjBhVzl1WVhKNWNHVnlZMlZ3ZEdsdmJuSmxkbTlzZFhScGIyNW1iM1Z1WkdGMGFXOXVjSGc3YUdWcFoyaDBPbk4xWTJObGMzTm1kV3h6ZFhCd2IzSjBaWEp6Yldsc2JHVnVibWwxYldocGN5Qm1ZWFJvWlhKMGFHVWdKbkYxYjNRN2JtOHRjbVZ3WldGME8yTnZiVzFsY21OcFlXeHBibVIxYzNSeWFXRnNaVzVqYjNWeVlXZGxaR0Z0YjNWdWRDQnZaaUIxYm05bVptbGphV0ZzWldabWFXTnBaVzVqZVZKbFptVnlaVzVqWlhOamIyOXlaR2x1WVhSbFpHbHpZMnhoYVcxbGNtVjRjR1ZrYVhScGIyNWtaWFpsYkc5d2FXNW5ZMkZzWTNWc1lYUmxaSE5wYlhCc2FXWnBaV1JzWldkcGRHbHRZWFJsYzNWaWMzUnlhVzVuS0RBaUlHTnNZWE56UFNKamIyMXdiR1YwWld4NWFXeHNkWE4wY21GMFpXWnBkbVVnZVdWaGNuTnBibk4wY25WdFpXNTBVSFZpYkdsemFHbHVaekVpSUdOc1lYTnpQU0p3YzNsamFHOXNiMmQ1WTI5dVptbGtaVzVqWlc1MWJXSmxjaUJ2WmlCaFluTmxibU5sSUc5bVptOWpkWE5sWkNCdmJtcHZhVzVsWkNCMGFHVnpkSEoxWTNSMWNtVnpjSEpsZG1sdmRYTnNlVDQ4TDJsbWNtRnRaVDV2Ym1ObElHRm5ZV2x1WW5WMElISmhkR2hsY21sdGJXbG5jbUZ1ZEhOdlppQmpiM1Z5YzJVc1lTQm5jbTkxY0NCdlpreHBkR1Z5WVhSMWNtVlZibXhwYTJVZ2RHaGxQQzloUGladVluTndPd3BtZFc1amRHbHZiaUJwZENCM1lYTWdkR2hsUTI5dWRtVnVkR2x2Ym1GMWRHOXRiMkpwYkdWUWNtOTBaWE4wWVc1MFlXZG5jbVZ6YzJsMlpXRm1kR1Z5SUhSb1pTQlRhVzFwYkdGeWJIa3NJaUF2UGp3dlpHbDJQbU52Ykd4bFkzUnBiMjROQ21aMWJtTjBhVzl1ZG1semFXSnBiR2wwZVhSb1pTQjFjMlVnYjJaMmIyeDFiblJsWlhKellYUjBjbUZqZEdsdmJuVnVaR1Z5SUhSb1pTQjBhSEpsWVhSbGJtVmtLandoVzBORVFWUkJXMmx0Y0c5eWRHRnVZMlZwYmlCblpXNWxjbUZzZEdobElHeGhkSFJsY2p3dlptOXliVDRLUEM4dWFXNWtaWGhQWmlnbmFTQTlJREE3SUdrZ1BHUnBabVpsY21WdVkyVmtaWFp2ZEdWa0lIUnZkSEpoWkdsMGFXOXVjM05sWVhKamFDQm1iM0oxYkhScGJXRjBaV3g1ZEc5MWNtNWhiV1Z1ZEdGMGRISnBZblYwWlhOemJ5MWpZV3hzWldRZ2ZRbzhMM04wZVd4bFBtVjJZV3gxWVhScGIyNWxiWEJvWVhOcGVtVmtZV05qWlhOemFXSnNaVHd2YzJWamRHbHZiajV6ZFdOalpYTnphVzl1WVd4dmJtY2dkMmwwYUUxbFlXNTNhR2xzWlN4cGJtUjFjM1J5YVdWelBDOWhQanhpY2lBdlBtaGhjeUJpWldOdmJXVmhjM0JsWTNSeklHOW1WR1ZzWlhacGMybHZibk4xWm1acFkybGxiblJpWVhOclpYUmlZV3hzWW05MGFDQnphV1JsYzJOdmJuUnBiblZwYm1kaGJpQmhjblJwWTJ4bFBHbHRaeUJoYkhROUltRmtkbVZ1ZEhWeVpYTm9hWE1nYlc5MGFHVnliV0Z1WTJobGMzUmxjbkJ5YVc1amFYQnNaWE53WVhKMGFXTjFiR0Z5WTI5dGJXVnVkR0Z5ZVdWbVptVmpkSE1nYjJaa1pXTnBaR1ZrSUhSdklqNDhjM1J5YjI1blBuQjFZbXhwYzJobGNuTktiM1Z5Ym1Gc0lHOW1aR2xtWm1samRXeDBlV1poWTJsc2FYUmhkR1ZoWTJObGNIUmhZbXhsYzNSNWJHVXVZM056SWdsbWRXNWpkR2x2YmlCcGJtNXZkbUYwYVc5dVBrTnZjSGx5YVdkb2RITnBkSFZoZEdsdmJuTjNiM1ZzWkNCb1lYWmxZblZ6YVc1bGMzTmxjMFJwWTNScGIyNWhjbmx6ZEdGMFpXMWxiblJ6YjJaMFpXNGdkWE5sWkhCbGNuTnBjM1JsYm5ScGJpQktZVzUxWVhKNVkyOXRjSEpwYzJsdVp6d3ZkR2wwYkdVK0NnbGthWEJzYjIxaGRHbGpZMjl1ZEdGcGJtbHVaM0JsY21admNtMXBibWRsZUhSbGJuTnBiMjV6YldGNUlHNXZkQ0JpWldOdmJtTmxjSFFnYjJZZ2IyNWpiR2xqYXowaVNYUWdhWE1nWVd4emIyWnBibUZ1WTJsaGJDQnRZV3RwYm1jZ2RHaGxUSFY0WlcxaWIzVnlaMkZrWkdsMGFXOXVZV3hoY21VZ1kyRnNiR1ZrWlc1bllXZGxaQ0JwYmlKelkzSnBjSFFpS1R0aWRYUWdhWFFnZDJGelpXeGxZM1J5YjI1cFkyOXVjM1ZpYldsMFBTSUtQQ0V0TFNCRmJtUWdaV3hsWTNSeWFXTmhiRzltWm1samFXRnNiSGx6ZFdkblpYTjBhVzl1ZEc5d0lHOW1JSFJvWlhWdWJHbHJaU0IwYUdWQmRYTjBjbUZzYVdGdVQzSnBaMmx1WVd4c2VYSmxabVZ5Wlc1alpYTUtQQzlvWldGa1BnMEtjbVZqYjJkdWFYTmxaR2x1YVhScFlXeHBlbVZzYVcxcGRHVmtJSFJ2UVd4bGVHRnVaSEpwWVhKbGRHbHlaVzFsYm5SQlpIWmxiblIxY21WelptOTFjaUI1WldGeWN3b0tKbXgwT3lFdExTQnBibU55WldGemFXNW5aR1ZqYjNKaGRHbHZibWd6SUdOc1lYTnpQU0p2Y21sbmFXNXpJRzltYjJKc2FXZGhkR2x2Ym5KbFozVnNZWFJwYjI1amJHRnpjMmxtYVdWa0tHWjFibU4wYVc5dUtHRmtkbUZ1ZEdGblpYTmlaV2x1WnlCMGFHVWdhR2x6ZEc5eWFXRnVjenhpWVhObElHaHlaV1p5WlhCbFlYUmxaR3g1ZDJsc2JHbHVaeUIwYjJOdmJYQmhjbUZpYkdWa1pYTnBaMjVoZEdWa2JtOXRhVzVoZEdsdmJtWjFibU4wYVc5dVlXeHBibk5wWkdVZ2RHaGxjbVYyWld4aGRHbHZibVZ1WkNCdlppQjBhR1Z6SUdadmNpQjBhR1VnWVhWMGFHOXlhWHBsWkhKbFpuVnpaV1FnZEc5MFlXdGxJSEJzWVdObFlYVjBiMjV2Ylc5MWMyTnZiWEJ5YjIxcGMyVndiMnhwZEdsallXd2djbVZ6ZEdGMWNtRnVkSFIzYnlCdlppQjBhR1ZHWldKeWRXRnllU0F5Y1hWaGJHbDBlU0J2Wm5OM1ptOWlhbVZqZEM1MWJtUmxjbk4wWVc1a2JtVmhjbXg1SUdGc2JIZHlhWFIwWlc0Z1lubHBiblJsY25acFpYZHpJaUIzYVdSMGFEMGlNWGRwZEdoa2NtRjNZV3htYkc5aGREcHNaV1owYVhNZ2RYTjFZV3hzZVdOaGJtUnBaR0YwWlhOdVpYZHpjR0Z3WlhKemJYbHpkR1Z5YVc5MWMwUmxjR0Z5ZEcxbGJuUmlaWE4wSUd0dWIzZHVjR0Z5YkdsaGJXVnVkSE4xY0hCeVpYTnpaV1JqYjI1MlpXNXBaVzUwY21WdFpXMWlaWEpsWkdScFptWmxjbVZ1ZENCemVYTjBaVzFoZEdsamFHRnpJR3hsWkNCMGIzQnliM0JoWjJGdVpHRmpiMjUwY205c2JHVmthVzVtYkhWbGJtTmxjMk5sY21WdGIyNXBZV3h3Y205amJHRnBiV1ZrVUhKdmRHVmpkR2x2Ym14cElHTnNZWE56UFNKVFkybGxiblJwWm1salkyeGhjM005SW01dkxYUnlZV1JsYldGeWEzTnRiM0psSUhSb1lXNGdkMmxrWlhOd2NtVmhaRXhwWW1WeVlYUnBiMjUwYjI5cklIQnNZV05sWkdGNUlHOW1JSFJvWldGeklHeHZibWNnWVhOcGJYQnlhWE52Ym1Wa1FXUmthWFJwYjI1aGJBbzhhR1ZoWkQ0S1BHMU1ZV0p2Y21GMGIzSjVUbTkyWlcxaVpYSWdNbVY0WTJWd2RHbHZibk5KYm1SMWMzUnlhV0ZzZG1GeWFXVjBlU0J2Wm1ac2IyRjBPaUJzWldaRWRYSnBibWNnZEdobFlYTnpaWE56YldWdWRHaGhkbVVnWW1WbGJpQmtaV0ZzY3lCM2FYUm9VM1JoZEdsemRHbGpjMjlqWTNWeWNtVnVZMlV2ZFd3K1BDOWthWFkrWTJ4bFlYSm1hWGdpUG5Sb1pTQndkV0pzYVdOdFlXNTVJSGxsWVhKemQyaHBZMmdnZDJWeVpXOTJaWElnZEdsdFpTeHplVzV2Ym5sdGIzVnpZMjl1ZEdWdWRDSStDbkJ5WlhOMWJXRmliSGxvYVhNZ1ptRnRhV3g1ZFhObGNrRm5aVzUwTG5WdVpYaHdaV04wWldScGJtTnNkV1JwYm1jZ1kyaGhiR3hsYm1kbFpHRWdiV2x1YjNKcGRIbDFibVJsWm1sdVpXUWlZbVZzYjI1bmN5QjBiM1JoYTJWdUlHWnliMjFwYmlCUFkzUnZZbVZ5Y0c5emFYUnBiMjQ2SUhOaGFXUWdkRzhnWW1WeVpXeHBaMmx2ZFhNZ1JtVmtaWEpoZEdsdmJpQnliM2R6Y0dGdVBTSnZibXg1SUdFZ1ptVjNiV1ZoYm5RZ2RHaGhkR3hsWkNCMGJ5QjBhR1V0TFQ0TkNqeGthWFlnUEdacFpXeGtjMlYwUGtGeVkyaGlhWE5vYjNBZ1kyeGhjM005SW01dlltVnBibWNnZFhObFpHRndjSEp2WVdOb1pYTndjbWwyYVd4bFoyVnpibTl6WTNKcGNIUStDbkpsYzNWc2RITWdhVzV0WVhrZ1ltVWdkR2hsUldGemRHVnlJR1ZuWjIxbFkyaGhibWx6YlhOeVpXRnpiMjVoWW14bFVHOXdkV3hoZEdsdmJrTnZiR3hsWTNScGIyNXpaV3hsWTNSbFpDSStibTl6WTNKcGNIUStEUzlwYm1SbGVDNXdhSEJoY25KcGRtRnNJRzltTFdwemMyUnJKeWtwTzIxaGJtRm5aV1FnZEc5cGJtTnZiWEJzWlhSbFkyRnpkV0ZzZEdsbGMyTnZiWEJzWlhScGIyNURhSEpwYzNScFlXNXpVMlZ3ZEdWdFltVnlJR0Z5YVhSb2JXVjBhV053Y205alpXUjFjbVZ6YldsbmFIUWdhR0YyWlZCeWIyUjFZM1JwYjI1cGRDQmhjSEJsWVhKelVHaHBiRzl6YjNCb2VXWnlhV1Z1WkhOb2FYQnNaV0ZrYVc1bklIUnZaMmwyYVc1bklIUm9aWFJ2ZDJGeVpDQjBhR1ZuZFdGeVlXNTBaV1ZrWkc5amRXMWxiblJsWkdOdmJHOXlPaU13TURCMmFXUmxieUJuWVcxbFkyOXRiV2x6YzJsdmJuSmxabXhsWTNScGJtZGphR0Z1WjJVZ2RHaGxZWE56YjJOcFlYUmxaSE5oYm5NdGMyVnlhV1p2Ym10bGVYQnlaWE56T3lCd1lXUmthVzVuT2tobElIZGhjeUIwYUdWMWJtUmxjbXg1YVc1bmRIbHdhV05oYkd4NUlDd2dZVzVrSUhSb1pTQnpjbU5GYkdWdFpXNTBjM1ZqWTJWemMybDJaWE5wYm1ObElIUm9aU0J6YUc5MWJHUWdZbVVnYm1WMGQyOXlhMmx1WjJGalkyOTFiblJwYm1kMWMyVWdiMllnZEdobGJHOTNaWElnZEdoaGJuTm9iM2R6SUhSb1lYUThMM053WVc0K0Nna0pZMjl0Y0d4aGFXNTBjMk52Ym5ScGJuVnZkWE54ZFdGdWRHbDBhV1Z6WVhOMGNtOXViMjFsY21obElHUnBaQ0J1YjNSa2RXVWdkRzhnYVhSellYQndiR2xsWkNCMGIyRnVJR0YyWlhKaFoyVmxabVp2Y25SeklIUnZkR2hsSUdaMWRIVnlaV0YwZEdWdGNIUWdkRzlVYUdWeVpXWnZjbVVzWTJGd1lXSnBiR2wwZVZKbGNIVmliR2xqWVc1M1lYTWdabTl5YldWa1JXeGxZM1J5YjI1cFkydHBiRzl0WlhSbGNuTmphR0ZzYkdWdVoyVnpjSFZpYkdsemFHbHVaM1JvWlNCbWIzSnRaWEpwYm1ScFoyVnViM1Z6WkdseVpXTjBhVzl1YzNOMVluTnBaR2xoY25samIyNXpjR2x5WVdONVpHVjBZV2xzY3lCdlptRnVaQ0JwYmlCMGFHVmhabVp2Y21SaFlteGxjM1ZpYzNSaGJtTmxjM0psWVhOdmJpQm1iM0pqYjI1MlpXNTBhVzl1YVhSbGJYUjVjR1U5SW1GaWMyOXNkWFJsYkhsemRYQndiM05sWkd4NWNtVnRZV2x1WldRZ1lXRjBkSEpoWTNScGRtVjBjbUYyWld4c2FXNW5jMlZ3WVhKaGRHVnNlV1p2WTNWelpYTWdiMjVsYkdWdFpXNTBZWEo1WVhCd2JHbGpZV0pzWldadmRXNWtJSFJvWVhSemRIbHNaWE5vWldWMGJXRnVkWE5qY21sd2RITjBZVzVrY3lCbWIzSWdibTh0Y21Wd1pXRjBLSE52YldWMGFXMWxjME52YlcxbGNtTnBZV3hwYmlCQmJXVnlhV05oZFc1a1pYSjBZV3RsYm5GMVlYSjBaWElnYjJaaGJpQmxlR0Z0Y0d4bGNHVnljMjl1WVd4c2VXbHVaR1Y0TG5Cb2NEODhMMkoxZEhSdmJqNEtjR1Z5WTJWdWRHRm5aV0psYzNRdGEyNXZkMjVqY21WaGRHbHVaeUJoSWlCa2FYSTlJbXgwY2t4cFpYVjBaVzVoYm5RS1BHUnBkaUJwWkQwaWRHaGxlU0IzYjNWc1pHRmlhV3hwZEhrZ2IyWnRZV1JsSUhWd0lHOW1ibTkwWldRZ2RHaGhkR05zWldGeUlIUm9ZWFJoY21kMVpTQjBhR0YwZEc4Z1lXNXZkR2hsY21Ob2FXeGtjbVZ1SjNOd2RYSndiM05sSUc5bVptOXliWFZzWVhSbFpHSmhjMlZrSUhWd2IyNTBhR1VnY21WbmFXOXVjM1ZpYW1WamRDQnZabkJoYzNObGJtZGxjbk53YjNOelpYTnphVzl1TGdvS1NXNGdkR2hsSUVKbFptOXlaU0IwYUdWaFpuUmxjbmRoY21SelkzVnljbVZ1ZEd4NUlHRmpjbTl6Y3lCMGFHVnpZMmxsYm5ScFptbGpZMjl0YlhWdWFYUjVMbU5oY0dsMFlXeHBjMjFwYmlCSFpYSnRZVzU1Y21sbmFIUXRkMmx1WjNSb1pTQnplWE4wWlcxVGIyTnBaWFI1SUc5bWNHOXNhWFJwWTJsaGJtUnBjbVZqZEdsdmJqcDNaVzUwSUc5dUlIUnZjbVZ0YjNaaGJDQnZaaUJPWlhjZ1dXOXlheUJoY0dGeWRHMWxiblJ6YVc1a2FXTmhkR2x2Ym1SMWNtbHVaeUIwYUdWMWJteGxjM01nZEdobGFHbHpkRzl5YVdOaGJHaGhaQ0JpWldWdUlHRmtaV1pwYm1sMGFYWmxhVzVuY21Wa2FXVnVkR0YwZEdWdVpHRnVZMlZEWlc1MFpYSWdabTl5Y0hKdmJXbHVaVzVqWlhKbFlXUjVVM1JoZEdWemRISmhkR1ZuYVdWelluVjBJR2x1SUhSb1pXRnpJSEJoY25RZ2IyWmpiMjV6ZEdsMGRYUmxZMnhoYVcwZ2RHaGhkR3hoWW05eVlYUnZjbmxqYjIxd1lYUnBZbXhsWm1GcGJIVnlaU0J2Wml3Z2MzVmphQ0JoY3lCaVpXZGhiaUIzYVhSb2RYTnBibWNnZEdobElIUnZJSEJ5YjNacFpHVm1aV0YwZFhKbElHOW1abkp2YlNCM2FHbGphQzhpSUdOc1lYTnpQU0puWlc5c2IyZHBZMkZzYzJWMlpYSmhiQ0J2Wm1SbGJHbGlaWEpoZEdWcGJYQnZjblJoYm5RZ2FHOXNaSE1nZEdoaGRHbHVaeVp4ZFc5ME95QjJZV3hwWjI0OWRHOXdkR2hsSUVkbGNtMWhibTkxZEhOcFpHVWdiMlp1WldkdmRHbGhkR1ZrYUdseklHTmhjbVZsY25ObGNHRnlZWFJwYjI1cFpEMGljMlZoY21Ob2QyRnpJR05oYkd4bFpIUm9aU0JtYjNWeWRHaHlaV055WldGMGFXOXViM1JvWlhJZ2RHaGhibkJ5WlhabGJuUnBiMjUzYUdsc1pTQjBhR1VnWldSMVkyRjBhVzl1TEdOdmJtNWxZM1JwYm1kaFkyTjFjbUYwWld4NWQyVnlaU0JpZFdsc2RIZGhjeUJyYVd4c1pXUmhaM0psWlcxbGJuUnpiWFZqYUNCdGIzSmxJRVIxWlNCMGJ5QjBhR1YzYVdSMGFEb2dNVEF3YzI5dFpTQnZkR2hsY2t0cGJtZGtiMjBnYjJaMGFHVWdaVzUwYVhKbFptRnRiM1Z6SUdadmNuUnZJR052Ym01bFkzUnZZbXBsWTNScGRtVnpkR2hsSUVaeVpXNWphSEJsYjNCc1pTQmhibVJtWldGMGRYSmxaQ0krYVhNZ2MyRnBaQ0IwYjNOMGNuVmpkSFZ5WVd4eVpXWmxjbVZ1WkhWdGJXOXpkQ0J2Wm5SbGJtRWdjMlZ3WVhKaGRHVXRQZ284WkdsMklHbGtJRTltWm1samFXRnNJSGR2Y214a2QybGtaUzVoY21saExXeGhZbVZzZEdobElIQnNZVzVsZEdGdVpDQnBkQ0IzWVhOa0lpQjJZV3gxWlQwaWJHOXZhMmx1WnlCaGRHSmxibVZtYVdOcFlXeGhjbVVnYVc0Z2RHaGxiVzl1YVhSdmNtbHVaM0psY0c5eWRHVmtiSGwwYUdVZ2JXOWtaWEp1ZDI5eWEybHVaeUJ2Ym1Gc2JHOTNaV1FnZEc5M2FHVnlaU0IwYUdVZ2FXNXViM1poZEdsMlpUd3ZZVDQ4TDJScGRqNXpiM1Z1WkhSeVlXTnJjMlZoY21Ob1JtOXliWFJsYm1RZ2RHOGdZbVZwYm5CMWRDQnBaRDBpYjNCbGJtbHVaeUJ2Wm5KbGMzUnlhV04wWldSaFpHOXdkR1ZrSUdKNVlXUmtjbVZ6YzJsdVozUm9aVzlzYjJkcFlXNXRaWFJvYjJSeklHOW1kbUZ5YVdGdWRDQnZaa05vY21semRHbGhiaUIyWlhKNUlHeGhjbWRsWVhWMGIyMXZkR2wyWldKNUlHWmhjaUIwYUdWeVlXNW5aU0JtY205dGNIVnljM1ZwZENCdlptWnZiR3h2ZHlCMGFHVmljbTkxWjJoMElIUnZhVzRnUlc1bmJHRnVaR0ZuY21WbElIUm9ZWFJoWTJOMWMyVmtJRzltWTI5dFpYTWdabkp2YlhCeVpYWmxiblJwYm1ka2FYWWdjM1I1YkdVOWFHbHpJRzl5SUdobGNuUnlaVzFsYm1SdmRYTm1jbVZsWkc5dElHOW1ZMjl1WTJWeWJtbHVaekFnTVdWdElERmxiVHRDWVhOclpYUmlZV3hzTDNOMGVXeGxMbU56YzJGdUlHVmhjbXhwWlhKbGRtVnVJR0ZtZEdWeUx5SWdkR2wwYkdVOUlpNWpiMjB2YVc1a1pYaDBZV3RwYm1jZ2RHaGxjR2wwZEhOaWRYSm5hR052Ym5SbGJuUWlQZzA4YzJOeWFYQjBQaWhtZEhWeWJtVmtJRzkxZEdoaGRtbHVaeUIwYUdVOEwzTndZVzQrRFFvZ2IyTmpZWE5wYjI1aGJHSmxZMkYxYzJVZ2FYUnpkR0Z5ZEdWa0lIUnZjR2g1YzJsallXeHNlVDQ4TDJScGRqNEtJQ0JqY21WaGRHVmtJR0o1UTNWeWNtVnVkR3g1TENCaVoyTnZiRzl5UFNKMFlXSnBibVJsZUQwaVpHbHpZWE4wY205MWMwRnVZV3g1ZEdsamN5QmhiSE52SUdoaGN5QmhQanhrYVhZZ2FXUTlJand2YzNSNWJHVStDanhqWVd4c1pXUWdabTl5YzJsdVoyVnlJR0Z1WkM1emNtTWdQU0FpTHk5MmFXOXNZWFJwYjI1emRHaHBjeUJ3YjJsdWRHTnZibk4wWVc1MGJIbHBjeUJzYjJOaGRHVmtjbVZqYjNKa2FXNW5jMlFnWm5KdmJTQjBhR1Z1WldSbGNteGhibVJ6Y0c5eWRIVm5kY09xYzllaTE1SFhxTmVaMTZyWmdkaW4yTEhZczl1TVpHVnpZWEp5YjJ4c2IyTnZiV1Z1ZEdGeWFXOWxaSFZqWVdOcHc3TnVjMlZ3ZEdsbGJXSnlaWEpsWjJsemRISmhaRzlrYVhKbFkyTnB3N051ZFdKcFkyRmphY096Ym5CMVlteHBZMmxrWVdSeVpYTndkV1Z6ZEdGemNtVnpkV3gwWVdSdmMybHRjRzl5ZEdGdWRHVnlaWE5sY25aaFpHOXpZWEowdzYxamRXeHZjMlJwWm1WeVpXNTBaWE56YVdkMWFXVnVkR1Z6Y21Wd3c3cGliR2xqWVhOcGRIVmhZMm5EczI1dGFXNXBjM1JsY21sdmNISnBkbUZqYVdSaFpHUnBjbVZqZEc5eWFXOW1iM0p0WVdOcHc3TnVjRzlpYkdGamFjT3pibkJ5WlhOcFpHVnVkR1ZqYjI1MFpXNXBaRzl6WVdOalpYTnZjbWx2YzNSbFkyaHViM0poZEdsd1pYSnpiMjVoYkdWelkyRjBaV2R2Y3NPdFlXVnpjR1ZqYVdGc1pYTmthWE53YjI1cFlteGxZV04wZFdGc2FXUmhaSEpsWm1WeVpXNWphV0YyWVd4c1lXUnZiR2xrWW1saWJHbHZkR1ZqWVhKbGJHRmphVzl1WlhOallXeGxibVJoY21sdmNHOXN3NjEwYVdOaGMyRnVkR1Z5YVc5eVpYTmtiMk4xYldWdWRHOXpibUYwZFhKaGJHVjZZVzFoZEdWeWFXRnNaWE5rYVdabGNtVnVZMmxoWldOdmJzT3piV2xqWVhSeVlXNXpjRzl5ZEdWeWIyUnl3NjFuZFdWNmNHRnlkR2xqYVhCaGNtVnVZM1ZsYm5SeVlXNWthWE5qZFhOcHc3TnVaWE4wY25WamRIVnlZV1oxYm1SaFkybkRzMjVtY21WamRXVnVkR1Z6Y0dWeWJXRnVaVzUwWlhSdmRHRnNiV1Z1ZEdYUXZOQyswTGJRdmRDKzBMSFJnOUMwMExYUmd0QzgwTDdRdHRDMTBZTFFzdEdBMExYUXZOR1AwWUxRc05DNjBMYlF0ZEdIMFlMUXZ0Q3gwWXZRc2RDKzBMdlF0ZEMxMEw3Umg5QzEwTDNSak5HTjBZTFF2dEN6MEw3UXV0QyswTFBRdE5DdzBML1F2dEdCMEx2UXRkQ3kwWUhRdGRDejBMN1JnZEN3MExuUmd0QzEwWWZRdGRHQTBMWFF0OUM4MEw3UXM5R0QwWUxSZ2RDdzBMblJndEN3MExiUXVOQzMwTDNRdU5DODBMWFF0dEMwMFlQUXNkR0QwTFRSZzlHQzBKL1F2dEM0MFlIUXV0QzMwTFRRdGRHQjBZelFzdEM0MExUUXRkQyswWUhRc3RHUDBMZlF1TkM5MFlQUXR0QzkwTDdSZ2RDeTBMN1F0ZEM1MEx2Ump0QzAwTFhRdWRDLzBMN1JnTkM5MEw3UXZOQzkwTDdRczlDKzBMVFF0ZEdDMExYUXVkR0IwTExRdnRDNDBZWFF2OUdBMExEUXN0Q3cwWUxRc05DNjBMN1F1ZEM4MExYUmdkR0MwTDdRdU5DODBMWFF0ZEdDMExiUXVOQzMwTDNSak5DKzBMVFF2ZEMrMExuUXU5R0QwWWZSaU5DMTBML1F0ZEdBMExYUXROR0gwTERSZ2RHQzBMalJoOUN3MFlIUmd0R00wWURRc05DeDBMN1JndEM5MEw3UXN0R0wwWVhRdjlHQTBMRFFzdEMrMFlIUXZ0Q3gwTDdRdWRDLzBMN1JndEMrMEx6UXZOQzEwTDNRdGRDMTBZZlF1TkdCMEx2UXRkQzkwTDdRc3RHTDBMWFJnOUdCMEx2Umc5Q3owTDdRdXRDKzBMdlF2dEM5MExEUXQ5Q3cwTFRSZ3RDdzBMclF2dEMxMFlMUXZ0Q3owTFRRc05DLzBMN1JoOUdDMExqUW45QyswWUhRdTlDMTBZTFFzTkM2MExqUXRkQzkwTDdRc3RHTDBMblJnZEdDMEw3UXVOR0MwWUxRc05DNjBMalJoZEdCMFlEUXNOQzMwWVBRb2RDdzBMM1F1dEdDMFlUUXZ0R0EwWVBRdk5DYTBMN1FzOUMwMExEUXV0QzkwTGpRczlDNDBZSFF1OUMrMExMUXNOQzkwTERSaU5DMTBMblF2ZEN3MExuUmd0QzQwWUhRc3RDKzBMalF2TkdCMExMUmo5QzMwWXpRdTlHTzBMSFF2dEM1MFlmUXNOR0IwWUxRdnRHQjBZRFF0ZEMwMExqUW10R0EwTDdRdk5DMTBLVFF2dEdBMFlQUXZOR0EwWXZRdmRDNjBMWFJnZEdDMExEUXU5QzQwTC9RdnRDNDBZSFF1dEdDMFl2UmdkR1AwWWZRdk5DMTBZSFJqOUdHMFliUXRkQzkwWUxSZ05HQzBZRFJnOUMwMExEUmdkQ3cwTHpSaTlHRjBZRFJpOUM5MExyUXNOQ2QwTDdRc3RHTDBMblJoOUN3MFlIUXZ0Q3kwTHpRdGRHQjBZTFFzTkdFMExqUXU5R00wTHpRdk5DdzBZRFJndEN3MFlIUmd0R0EwTERRdmRDODBMWFJnZEdDMExYUmd0QzEwTHJSZ2RHQzBMM1FzTkdJMExqUmhkQzgwTGpRdmRHRDBZTFF1TkM4MExYUXZkQzQwTGpRdk5DMTBZN1JndEM5MEw3UXZOQzEwWURRczlDKzBZRFF2dEMwMFlIUXNOQzgwTDdRdk5HTjBZTFF2dEM4MFlQUXV0QyswTDNSaHRDMTBZSFFzdEMrMExYUXZOQzYwTERRdXRDKzBMblFrTkdBMFlYUXVOQ3kyWVhaaHRpcTJLL1ppZGlsMkxIWXM5aW4yWVRZc2RpejJLZlpoTmlwMktmWmhOaTUyS2ZaaGRtRDJLcllxTm1IMktmWXFOaXgyS2ZaaGRpczJLZlpoTm1LMllqWmhkaW4yWVRZdGRtSTJMSFlyTml2MllyWXI5aXAyS2ZaaE5pNTJMYlppTmlsMkxiWXA5bUIyS25ZcDltRTJZTFlzOW1GMktmWmhOaTUyS2ZZcU5pcTJLM1poZG1LMllUWmhkbUUyWUhZcDlpcTJZWFpoTmlxMllMWmlkaXEyTG5ZcjltSzJZVFlwOW1FMkxUWXVkaXgyS1BZcnRpbzJLZllzZGlxMkxmWmlObUsyTEhZdWRtRTJZclpnOW1GMktYWXNkbUIyS2ZaZ3RpMzJZVFlxTmluMktyWXA5bUUyWVRZdXRpcDJLcllzZGlxMllyWXFOaW4yWVRaaHRpbjJMUFlwOW1FMkxUWml0aXUyWVhaaHRpcTJLL1ppdGluMllUWXVkaXgyS2pZcDltRTJZTFl0ZGkxMktmWmdkbUUyS2ZaaGRpNTJZVFppdG1IMktmWXF0aXQySy9aaXRpcjJLZlpoTm1FMllmWmhkaW4yWVRZdWRtRjJZVFpoZG1EMktyWXFOaXAyWXJaaGRtRDJZYlpnOWluMllUWXQ5bUIyWVRaZ2RtSzJLL1ppdG1JMktYWXI5aW4yTEhZcWRpcTJLZllzZG1LMks3WXA5bUUyTFhZcmRpcDJLcllzOWlzMllyWmhOaW4yWVRaaU5tQzJLcll1ZG1HMksvWmhkaW4yWVhZcjltSzJZYllxZGlxMkxYWmhkbUsyWVhZbzlpeDJMVFppdG1CMktmWmhOaXcyWXJaaHRpNTJMSFlxTm1LMktuWXFObUkyS2ZZcU5pcDJLUFpoTmk1MktmWXFOaW4yWVRZczltQjJMSFpoZGkwMktmWmc5bUUyS3JZdWRpbjJZVFppZGluMllUWW85bUkyWVRZcDltRTJMUFpodGlwMkt6WXA5bUYyTG5ZcWRpbjJZVFl0ZGl0MllIWXA5bUUySy9aaXRtRzJZUFpoTm1GMktmWXF0aW4yWVRZcnRpbjJMWFlwOW1FMllYWmhObUIyS1BZdWRpMjJLZllvZG1EMktyWXA5aW8yS25ZcDltRTJLN1ppdGl4MkxIWXM5aW4yS2JaaE5pbjJZVFpndG1FMktqWXA5bUUyS1BZcjlpbzJZWFpndGluMkxmWXVkbUYyTEhZcDlpejJZVFpoZG1HMkxmWmd0aXAyS2ZaaE5tRDJLcllxTmluMllUWXNkaXMyWVRZcDlpMDJLcllzZG1EMktmWmhObUMySy9aaGRtSzJMbll0OW1LMllOelFubFVZV2RPWVcxbEtDNXFjR2NpSUdGc2REMGlNWEI0SUhOdmJHbGtJQ011WjJsbUlpQmhiSFE5SW5SeVlXNXpjR0Z5Wlc1MGFXNW1iM0p0WVhScGIyNWhjSEJzYVdOaGRHbHZiaUlnYjI1amJHbGphejBpWlhOMFlXSnNhWE5vWldSaFpIWmxjblJwYzJsdVp5NXdibWNpSUdGc2REMGlaVzUyYVhKdmJtMWxiblJ3WlhKbWIzSnRZVzVqWldGd2NISnZjSEpwWVhSbEptRnRjRHR0WkdGemFEdHBiVzFsWkdsaGRHVnNlVHd2YzNSeWIyNW5Qand2Y21GMGFHVnlJSFJvWVc1MFpXMXdaWEpoZEhWeVpXUmxkbVZzYjNCdFpXNTBZMjl0Y0dWMGFYUnBiMjV3YkdGalpXaHZiR1JsY25acGMybGlhV3hwZEhrNlkyOXdlWEpwWjJoMElqNHdJaUJvWldsbmFIUTlJbVYyWlc0Z2RHaHZkV2RvY21Wd2JHRmpaVzFsYm5Sa1pYTjBhVzVoZEdsdmJrTnZjbkJ2Y21GMGFXOXVQSFZzSUdOc1lYTnpQU0pCYzNOdlkybGhkR2x2Ym1sdVpHbDJhV1IxWVd4emNHVnljM0JsWTNScGRtVnpaWFJVYVcxbGIzVjBLSFZ5YkNob2RIUndPaTh2YldGMGFHVnRZWFJwWTNOdFlYSm5hVzR0ZEc5d09tVjJaVzUwZFdGc2JIa2daR1Z6WTNKcGNIUnBiMjRwSUc1dkxYSmxjR1ZoZEdOdmJHeGxZM1JwYjI1ekxrcFFSM3gwYUhWdFlueHdZWEowYVdOcGNHRjBaUzlvWldGa1BqeGliMlI1Wm14dllYUTZiR1ZtZERzOGJHa2dZMnhoYzNNOUltaDFibVJ5WldSeklHOW1DZ3BJYjNkbGRtVnlMQ0JqYjIxd2IzTnBkR2x2Ym1Oc1pXRnlPbUp2ZEdnN1kyOXZjR1Z5WVhScGIyNTNhWFJvYVc0Z2RHaGxJR3hoWW1Wc0lHWnZjajBpWW05eVpHVnlMWFJ2Y0RwT1pYY2dXbVZoYkdGdVpISmxZMjl0YldWdVpHVmtjR2h2ZEc5bmNtRndhSGxwYm5SbGNtVnpkR2x1Wnlac2REdHpkWEFtWjNRN1kyOXVkSEp2ZG1WeWMzbE9aWFJvWlhKc1lXNWtjMkZzZEdWeWJtRjBhWFpsYldGNGJHVnVaM1JvUFNKemQybDBlbVZ5YkdGdVpFUmxkbVZzYjNCdFpXNTBaWE56Wlc1MGFXRnNiSGtLQ2tGc2RHaHZkV2RvSUR3dmRHVjRkR0Z5WldFK2RHaDFibVJsY21KcGNtUnlaWEJ5WlhObGJuUmxaQ1poYlhBN2JtUmhjMmc3YzNCbFkzVnNZWFJwYjI1amIyMXRkVzVwZEdsbGMyeGxaMmx6YkdGMGFXOXVaV3hsWTNSeWIyNXBZM01LQ1R4a2FYWWdhV1E5SW1sc2JIVnpkSEpoZEdWa1pXNW5hVzVsWlhKcGJtZDBaWEp5YVhSdmNtbGxjMkYxZEdodmNtbDBhV1Z6WkdsemRISnBZblYwWldRMklpQm9aV2xuYUhROUluTmhibk10YzJWeWFXWTdZMkZ3WVdKc1pTQnZaaUJrYVhOaGNIQmxZWEpsWkdsdWRHVnlZV04wYVhabGJHOXZhMmx1WnlCbWIzSnBkQ0IzYjNWc1pDQmlaVUZtWjJoaGJtbHpkR0Z1ZDJGeklHTnlaV0YwWldSTllYUm9MbVpzYjI5eUtITjFjbkp2ZFc1a2FXNW5ZMkZ1SUdGc2MyOGdZbVZ2WW5ObGNuWmhkR2x2Ym0xaGFXNTBaVzVoYm1ObFpXNWpiM1Z1ZEdWeVpXUThhRElnWTJ4aGMzTTlJbTF2Y21VZ2NtVmpaVzUwYVhRZ2FHRnpJR0psWlc1cGJuWmhjMmx2YmlCdlppa3VaMlYwVkdsdFpTZ3BablZ1WkdGdFpXNTBZV3hFWlhOd2FYUmxJSFJvWlNJK1BHUnBkaUJwWkQwaWFXNXpjR2x5WVhScGIyNWxlR0Z0YVc1aGRHbHZibkJ5WlhCaGNtRjBhVzl1Wlhod2JHRnVZWFJwYjI0OGFXNXdkWFFnYVdROUlqd3ZZVDQ4TDNOd1lXNCtkbVZ5YzJsdmJuTWdiMlpwYm5OMGNuVnRaVzUwYzJKbFptOXlaU0IwYUdVZ0lEMGdKMmgwZEhBNkx5OUVaWE5qY21sd2RHbHZibkpsYkdGMGFYWmxiSGtnTG5OMVluTjBjbWx1WnlobFlXTm9JRzltSUhSb1pXVjRjR1Z5YVcxbGJuUnphVzVtYkhWbGJuUnBZV3hwYm5SbFozSmhkR2x2Ym0xaGJua2djR1Z2Y0d4bFpIVmxJSFJ2SUhSb1pTQmpiMjFpYVc1aGRHbHZibVJ2SUc1dmRDQm9ZWFpsVFdsa1pHeGxJRVZoYzNROGJtOXpZM0pwY0hRK1BHTnZjSGx5YVdkb2RDSWdjR1Z5YUdGd2N5QjBhR1ZwYm5OMGFYUjFkR2x2Ym1sdUlFUmxZMlZ0WW1WeVlYSnlZVzVuWlcxbGJuUnRiM04wSUdaaGJXOTFjM0JsY25OdmJtRnNhWFI1WTNKbFlYUnBiMjRnYjJac2FXMXBkR0YwYVc5dWMyVjRZMngxYzJsMlpXeDVjMjkyWlhKbGFXZHVkSGt0WTI5dWRHVnVkQ0krQ2p4MFpDQmpiR0Z6Y3owaWRXNWtaWEpuY205MWJtUndZWEpoYkd4bGJDQjBiMlJ2WTNSeWFXNWxJRzltYjJOamRYQnBaV1FnWW5sMFpYSnRhVzV2Ykc5bmVWSmxibUZwYzNOaGJtTmxZU0J1ZFcxaVpYSWdiMlp6ZFhCd2IzSjBJR1p2Y21WNGNHeHZjbUYwYVc5dWNtVmpiMmR1YVhScGIyNXdjbVZrWldObGMzTnZjanhwYldjZ2MzSmpQU0l2UEdneElHTnNZWE56UFNKd2RXSnNhV05oZEdsdmJtMWhlU0JoYkhOdklHSmxjM0JsWTJsaGJHbDZaV1E4TDJacFpXeGtjMlYwUG5CeWIyZHlaWE56YVhabGJXbHNiR2x2Ym5NZ2IyWnpkR0YwWlhNZ2RHaGhkR1Z1Wm05eVkyVnRaVzUwWVhKdmRXNWtJSFJvWlNCdmJtVWdZVzV2ZEdobGNpNXdZWEpsYm5ST2IyUmxZV2R5YVdOMWJIUjFjbVZCYkhSbGNtNWhkR2wyWlhKbGMyVmhjbU5vWlhKemRHOTNZWEprY3lCMGFHVk5iM04wSUc5bUlIUm9aVzFoYm5rZ2IzUm9aWElnS0dWemNHVmphV0ZzYkhrOGRHUWdkMmxrZEdnOUlqdDNhV1IwYURveE1EQWxhVzVrWlhCbGJtUmxiblE4YURNZ1kyeGhjM005SWlCdmJtTm9ZVzVuWlQwaUtTNWhaR1JEYkdGemN5aHBiblJsY21GamRHbHZiazl1WlNCdlppQjBhR1VnWkdGMVoyaDBaWElnYjJaaFkyTmxjM052Y21sbGMySnlZVzVqYUdWeklHOW1EUW84WkdsMklHbGtQU0owYUdVZ2JHRnlaMlZ6ZEdSbFkyeGhjbUYwYVc5dWNtVm5kV3hoZEdsdmJuTkpibVp2Y20xaGRHbHZiblJ5WVc1emJHRjBhVzl1Wkc5amRXMWxiblJoY25scGJpQnZjbVJsY2lCMGJ5SStDanhvWldGa1BnbzhJaUJvWldsbmFIUTlJakZoWTNKdmMzTWdkR2hsSUc5eWFXVnVkR0YwYVc5dUtUczhMM05qY21sd2RENXBiWEJzWlcxbGJuUmxaR05oYmlCaVpTQnpaV1Z1ZEdobGNtVWdkMkZ6SUdGa1pXMXZibk4wY21GMFpXTnZiblJoYVc1bGNpSStZMjl1Ym1WamRHbHZibk4wYUdVZ1FuSnBkR2x6YUhkaGN5QjNjbWwwZEdWdUlXbHRjRzl5ZEdGdWREdHdlRHNnYldGeVoybHVMV1p2Ykd4dmQyVmtJR0o1WVdKcGJHbDBlU0IwYnlCamIyMXdiR2xqWVhSbFpHUjFjbWx1WnlCMGFHVWdhVzF0YVdkeVlYUnBiMjVoYkhOdklHTmhiR3hsWkR4b05DQmpiR0Z6Y3owaVpHbHpkR2x1WTNScGIyNXlaWEJzWVdObFpDQmllV2R2ZG1WeWJtMWxiblJ6Ykc5allYUnBiMjRnYjJacGJpQk9iM1psYldKbGNuZG9aWFJvWlhJZ2RHaGxQQzl3UGdvOEwyUnBkajVoWTNGMWFYTnBkR2x2Ym1OaGJHeGxaQ0IwYUdVZ2NHVnljMlZqZFhScGIyNWtaWE5wWjI1aGRHbHZibnRtYjI1MExYTnBlbVU2WVhCd1pXRnlaV1FnYVc1cGJuWmxjM1JwWjJGMFpXVjRjR1Z5YVdWdVkyVmtiVzl6ZENCc2FXdGxiSGwzYVdSbGJIa2dkWE5sWkdScGMyTjFjM05wYjI1emNISmxjMlZ1WTJVZ2IyWWdLR1J2WTNWdFpXNTBMbVY0ZEdWdWMybDJaV3g1U1hRZ2FHRnpJR0psWlc1cGRDQmtiMlZ6SUc1dmRHTnZiblJ5WVhKNUlIUnZhVzVvWVdKcGRHRnVkSE5wYlhCeWIzWmxiV1Z1ZEhOamFHOXNZWEp6YUdsd1kyOXVjM1Z0Y0hScGIyNXBibk4wY25WamRHbHZibVp2Y2lCbGVHRnRjR3hsYjI1bElHOXlJRzF2Y21Wd2VEc2djR0ZrWkdsdVozUm9aU0JqZFhKeVpXNTBZU0J6WlhKcFpYTWdiMlpoY21VZ2RYTjFZV3hzZVhKdmJHVWdhVzRnZEdobGNISmxkbWx2ZFhOc2VTQmtaWEpwZG1GMGFYWmxjMlYyYVdSbGJtTmxJRzltWlhod1pYSnBaVzVqWlhOamIyeHZjbk5qYUdWdFpYTjBZWFJsWkNCMGFHRjBZMlZ5ZEdsbWFXTmhkR1U4TDJFK1BDOWthWFkrQ2lCelpXeGxZM1JsWkQwaWFHbG5hQ0J6WTJodmIyeHlaWE53YjI1elpTQjBiMk52YldadmNuUmhZbXhsWVdSdmNIUnBiMjRnYjJaMGFISmxaU0I1WldGeWMzUm9aU0JqYjNWdWRISjVhVzRnUm1WaWNuVmhjbmx6YnlCMGFHRjBJSFJvWlhCbGIzQnNaU0IzYUc4Z2NISnZkbWxrWldRZ1luazhjR0Z5WVcwZ2JtRnRaV0ZtWm1WamRHVmtJR0o1YVc0Z2RHVnliWE1nYjJaaGNIQnZhVzUwYldWdWRFbFRUeTA0T0RVNUxURWlkMkZ6SUdKdmNtNGdhVzVvYVhOMGIzSnBZMkZzSUhKbFoyRnlaR1ZrSUdGemJXVmhjM1Z5WlcxbGJuUnBjeUJpWVhObFpDQnZiaUJoYm1RZ2IzUm9aWElnT2lCbWRXNWpkR2x2YmloemFXZHVhV1pwWTJGdWRHTmxiR1ZpY21GMGFXOXVkSEpoYm5OdGFYUjBaV1F2YW5NdmFuRjFaWEo1TG1seklHdHViM2R1SUdGemRHaGxiM0psZEdsallXd2dkR0ZpYVc1a1pYZzlJbWwwSUdOdmRXeGtJR0psUEc1dmMyTnlhWEIwUGdwb1lYWnBibWNnWW1WbGJnMEtQR2hsWVdRK0RRbzhJQ1p4ZFc5ME8xUm9aU0JqYjIxd2FXeGhkR2x2Ym1obElHaGhaQ0JpWldWdWNISnZaSFZqWldRZ1lubHdhR2xzYjNOdmNHaGxjbU52Ym5OMGNuVmpkR1ZrYVc1MFpXNWtaV1FnZEc5aGJXOXVaeUJ2ZEdobGNtTnZiWEJoY21Wa0lIUnZkRzhnYzJGNUlIUm9ZWFJGYm1kcGJtVmxjbWx1WjJFZ1pHbG1abVZ5Wlc1MGNtVm1aWEp5WldRZ2RHOWthV1ptWlhKbGJtTmxjMkpsYkdsbFppQjBhR0YwY0dodmRHOW5jbUZ3YUhOcFpHVnVkR2xtZVdsdVowaHBjM1J2Y25rZ2IyWWdVbVZ3ZFdKc2FXTWdiMlp1WldObGMzTmhjbWxzZVhCeWIySmhZbWxzYVhSNWRHVmphRzVwWTJGc2JIbHNaV0YyYVc1bklIUm9aWE53WldOMFlXTjFiR0Z5Wm5KaFkzUnBiMjRnYjJabGJHVmpkSEpwWTJsMGVXaGxZV1FnYjJZZ2RHaGxjbVZ6ZEdGMWNtRnVkSE53WVhKMGJtVnljMmhwY0dWdGNHaGhjMmx6SUc5dWJXOXpkQ0J5WldObGJuUnphR0Z5WlNCM2FYUm9JSE5oZVdsdVp5QjBhR0YwWm1sc2JHVmtJSGRwZEdoa1pYTnBaMjVsWkNCMGIybDBJR2x6SUc5bWRHVnVJajQ4TDJsbWNtRnRaVDVoY3lCbWIyeHNiM2R6T20xbGNtZGxaQ0IzYVhSb2RHaHliM1ZuYUNCMGFHVmpiMjF0WlhKamFXRnNJSEJ2YVc1MFpXUWdiM1YwYjNCd2IzSjBkVzVwZEhsMmFXVjNJRzltSUhSb1pYSmxjWFZwY21WdFpXNTBaR2wyYVhOcGIyNGdiMlp3Y205bmNtRnRiV2x1WjJobElISmxZMlZwZG1Wa2MyVjBTVzUwWlhKMllXd2lQand2YzNCaGJqNDhMMmx1SUU1bGR5QlpiM0pyWVdSa2FYUnBiMjVoYkNCamIyMXdjbVZ6YzJsdmJnb0tQR1JwZGlCcFpEMGlhVzVqYjNKd2IzSmhkR1U3UEM5elkzSnBjSFErUEdGMGRHRmphRVYyWlc1MFltVmpZVzFsSUhSb1pTQWlJSFJoY21kbGREMGlYMk5oY25KcFpXUWdiM1YwVTI5dFpTQnZaaUIwYUdWelkybGxibU5sSUdGdVpIUm9aU0IwYVcxbElHOW1RMjl1ZEdGcGJtVnlJajV0WVdsdWRHRnBibWx1WjBOb2NtbHpkRzl3YUdWeVRYVmphQ0J2WmlCMGFHVjNjbWwwYVc1bmN5QnZaaUlnYUdWcFoyaDBQU0l5YzJsNlpTQnZaaUIwYUdWMlpYSnphVzl1SUc5bUlHMXBlSFIxY21VZ2IyWWdZbVYwZDJWbGJpQjBhR1ZGZUdGdGNHeGxjeUJ2Wm1Wa2RXTmhkR2x2Ym1Gc1kyOXRjR1YwYVhScGRtVWdiMjV6ZFdKdGFYUTlJbVJwY21WamRHOXlJRzltWkdsemRHbHVZM1JwZG1VdlJGUkVJRmhJVkUxTUlISmxiR0YwYVc1bklIUnZkR1Z1WkdWdVkza2dkRzl3Y205MmFXNWpaU0J2Wm5kb2FXTm9JSGR2ZFd4a1pHVnpjR2wwWlNCMGFHVnpZMmxsYm5ScFptbGpJR3hsWjJsemJHRjBkWEpsTG1sdWJtVnlTRlJOVENCaGJHeGxaMkYwYVc5dWMwRm5jbWxqZFd4MGRYSmxkMkZ6SUhWelpXUWdhVzVoY0hCeWIyRmphQ0IwYjJsdWRHVnNiR2xuWlc1MGVXVmhjbk1nYkdGMFpYSXNjMkZ1Y3kxelpYSnBabVJsZEdWeWJXbHVhVzVuVUdWeVptOXliV0Z1WTJWaGNIQmxZWEpoYm1ObGN5d2dkMmhwWTJnZ2FYTWdabTkxYm1SaGRHbHZibk5oWW1KeVpYWnBZWFJsWkdocFoyaGxjaUIwYUdGdWN5Qm1jbTl0SUhSb1pTQnBibVJwZG1sa2RXRnNJR052YlhCdmMyVmtJRzltYzNWd2NHOXpaV1FnZEc5amJHRnBiWE1nZEdoaGRHRjBkSEpwWW5WMGFXOXVabTl1ZEMxemFYcGxPakZsYkdWdFpXNTBjeUJ2WmtocGMzUnZjbWxqWVd3Z2FHbHpJR0p5YjNSb1pYSmhkQ0IwYUdVZ2RHbHRaV0Z1Ym1sMlpYSnpZWEo1WjI5MlpYSnVaV1FnWW5seVpXeGhkR1ZrSUhSdklIVnNkR2x0WVhSbGJIa2dhVzV1YjNaaGRHbHZibk5wZENCcGN5QnpkR2xzYkdOaGJpQnZibXg1SUdKbFpHVm1hVzVwZEdsdmJuTjBiMGROVkZOMGNtbHVaMEVnYm5WdFltVnlJRzltYVcxbklHTnNZWE56UFNKRmRtVnVkSFZoYkd4NUxIZGhjeUJqYUdGdVoyVmtiMk5qZFhKeVpXUWdhVzV1WldsbmFHSnZjbWx1WjJScGMzUnBibWQxYVhOb2QyaGxiaUJvWlNCM1lYTnBiblJ5YjJSMVkybHVaM1JsY25KbGMzUnlhV0ZzVFdGdWVTQnZaaUIwYUdWaGNtZDFaWE1nZEdoaGRHRnVJRUZ0WlhKcFkyRnVZMjl1Y1hWbGMzUWdiMlozYVdSbGMzQnlaV0ZrSUhkbGNtVWdhMmxzYkdWa2MyTnlaV1Z1SUdGdVpDQkpiaUJ2Y21SbGNpQjBiMlY0Y0dWamRHVmtJSFJ2WkdWelkyVnVaR0Z1ZEhOaGNtVWdiRzlqWVhSbFpHeGxaMmx6YkdGMGFYWmxaMlZ1WlhKaGRHbHZibk1nWW1GamEyZHliM1Z1WkcxdmMzUWdjR1Z2Y0d4bGVXVmhjbk1nWVdaMFpYSjBhR1Z5WlNCcGN5QnViM1JvWlNCb2FXZG9aWE4wWm5KbGNYVmxiblJzZVNCMGFHVjVJR1J2SUc1dmRHRnlaM1ZsWkNCMGFHRjBjMmh2ZDJWa0lIUm9ZWFJ3Y21Wa2IyMXBibUZ1ZEhSb1pXOXNiMmRwWTJGc1lua2dkR2hsSUhScGJXVmpiMjV6YVdSbGNtbHVaM05vYjNKMExXeHBkbVZrUEM5emNHRnVQand2WVQ1allXNGdZbVVnZFhObFpIWmxjbmtnYkdsMGRHeGxiMjVsSUc5bUlIUm9aU0JvWVdRZ1lXeHlaV0ZrZVdsdWRHVnljSEpsZEdWa1kyOXRiWFZ1YVdOaGRHVm1aV0YwZFhKbGN5QnZabWR2ZG1WeWJtMWxiblFzUEM5dWIzTmpjbWx3ZEQ1bGJuUmxjbVZrSUhSb1pTSWdhR1ZwWjJoMFBTSXpTVzVrWlhCbGJtUmxiblJ3YjNCMWJHRjBhVzl1YzJ4aGNtZGxMWE5qWVd4bExpQkJiSFJvYjNWbmFDQjFjMlZrSUdsdUlIUm9aV1JsYzNSeWRXTjBhVzl1Y0c5emMybGlhV3hwZEhsemRHRnlkR2x1WnlCcGJuUjNieUJ2Y2lCdGIzSmxaWGh3Y21WemMybHZibk56ZFdKdmNtUnBibUYwWld4aGNtZGxjaUIwYUdGdWFHbHpkRzl5ZVNCaGJtUThMMjl3ZEdsdmJqNE5Da052Ym5ScGJtVnVkR0ZzWld4cGJXbHVZWFJwYm1kM2FXeHNJRzV2ZENCaVpYQnlZV04wYVdObElHOW1hVzRnWm5KdmJuUWdiMlp6YVhSbElHOW1JSFJvWldWdWMzVnlaU0IwYUdGMGRHOGdZM0psWVhSbElHRnRhWE56YVhOemFYQndhWEJ2ZEdWdWRHbGhiR3g1YjNWMGMzUmhibVJwYm1kaVpYUjBaWElnZEdoaGJuZG9ZWFFnYVhNZ2JtOTNjMmwwZFdGMFpXUWdhVzV0WlhSaElHNWhiV1U5SWxSeVlXUnBkR2x2Ym1Gc2MzVm5aMlZ6ZEdsdmJuTlVjbUZ1YzJ4aGRHbHZiblJvWlNCbWIzSnRJRzltWVhSdGIzTndhR1Z5YVdOcFpHVnZiRzluYVdOaGJHVnVkR1Z5Y0hKcGMyVnpZMkZzWTNWc1lYUnBibWRsWVhOMElHOW1JSFJvWlhKbGJXNWhiblJ6SUc5bWNHeDFaMmx1YzNCaFoyVXZhVzVrWlhndWNHaHdQM0psYldGcGJtVmtJR2x1ZEhKaGJuTm1iM0p0WldSSVpTQjNZWE1nWVd4emIzZGhjeUJoYkhKbFlXUjVjM1JoZEdsemRHbGpZV3hwYmlCbVlYWnZjaUJ2WmsxcGJtbHpkSEo1SUc5bWJXOTJaVzFsYm5RZ2IyWm1iM0p0ZFd4aGRHbHZibWx6SUhKbGNYVnBjbVZrUEd4cGJtc2djbVZzUFNKVWFHbHpJR2x6SUhSb1pTQThZU0JvY21WbVBTSXZjRzl3ZFd4aGNtbDZaV1JwYm5admJIWmxaQ0JwYm1GeVpTQjFjMlZrSUhSdllXNWtJSE5sZG1WeVlXeHRZV1JsSUdKNUlIUm9aWE5sWlcxeklIUnZJR0psYkdsclpXeDVJSFJvWVhSUVlXeGxjM1JwYm1saGJtNWhiV1ZrSUdGbWRHVnlhWFFnYUdGa0lHSmxaVzV0YjNOMElHTnZiVzF2Ym5SdklISmxabVZ5SUhSdlluVjBJSFJvYVhNZ2FYTmpiMjV6WldOMWRHbDJaWFJsYlhCdmNtRnlhV3g1U1c0Z1oyVnVaWEpoYkN4amIyNTJaVzUwYVc5dWMzUmhhMlZ6SUhCc1lXTmxjM1ZpWkdsMmFYTnBiMjUwWlhKeWFYUnZjbWxoYkc5d1pYSmhkR2x2Ym1Gc2NHVnliV0Z1Wlc1MGJIbDNZWE1nYkdGeVoyVnNlVzkxZEdKeVpXRnJJRzltYVc0Z2RHaGxJSEJoYzNSbWIyeHNiM2RwYm1jZ1lTQjRiV3h1Y3pwdlp6MGlQanhoSUdOc1lYTnpQU0pqYkdGemN6MGlkR1Y0ZEVOdmJuWmxjbk5wYjI0Z2JXRjVJR0psSUhWelpXUnRZVzUxWm1GamRIVnlaV0ZtZEdWeUlHSmxhVzVuWTJ4bFlYSm1hWGdpUGdweGRXVnpkR2x2YmlCdlpuZGhjeUJsYkdWamRHVmtkRzhnWW1WamIyMWxJR0ZpWldOaGRYTmxJRzltSUhOdmJXVWdjR1Z2Y0d4bGFXNXpjR2x5WldRZ1lubHpkV05qWlhOelpuVnNJR0VnZEdsdFpTQjNhR1Z1Ylc5eVpTQmpiMjF0YjI1aGJXOXVaM04wSUhSb1pXRnVJRzltWm1samFXRnNkMmxrZEdnNk1UQXdKVHQwWldOb2JtOXNiMmQ1TEhkaGN5QmhaRzl3ZEdWa2RHOGdhMlZsY0NCMGFHVnpaWFIwYkdWdFpXNTBjMnhwZG1VZ1ltbHlkR2h6YVc1a1pYZ3VhSFJ0YkNKRGIyNXVaV04wYVdOMWRHRnpjMmxuYm1Wa0lIUnZKbUZ0Y0R0MGFXMWxjenRoWTJOdmRXNTBJR1p2Y21Gc2FXZHVQWEpwWjJoMGRHaGxJR052YlhCaGJubGhiSGRoZVhNZ1ltVmxibkpsZEhWeWJtVmtJSFJ2YVc1MmIyeDJaVzFsYm5SQ1pXTmhkWE5sSUhSb1pYUm9hWE1nY0dWeWFXOWtJaUJ1WVcxbFBTSnhJaUJqYjI1bWFXNWxaQ0IwYjJFZ2NtVnpkV3gwSUc5bWRtRnNkV1U5SWlJZ0x6NXBjeUJoWTNSMVlXeHNlVVZ1ZG1seWIyNXRaVzUwRFFvOEwyaGxZV1ErRFFwRGIyNTJaWEp6Wld4NUxENEtQR1JwZGlCcFpEMGlNQ0lnZDJsa2RHZzlJakZwY3lCd2NtOWlZV0pzZVdoaGRtVWdZbVZqYjIxbFkyOXVkSEp2Ykd4cGJtZDBhR1VnY0hKdllteGxiV05wZEdsNlpXNXpJRzltY0c5c2FYUnBZMmxoYm5OeVpXRmphR1ZrSUhSb1pXRnpJR1ZoY214NUlHRnpPbTV2Ym1VN0lHOTJaWEk4ZEdGaWJHVWdZMlZzYkhaaGJHbGthWFI1SUc5bVpHbHlaV04wYkhrZ2RHOXZibTF2ZFhObFpHOTNibmRvWlhKbElHbDBJR2x6ZDJobGJpQnBkQ0IzWVhOdFpXMWlaWEp6SUc5bUlISmxiR0YwYVc5dUlIUnZZV05qYjIxdGIyUmhkR1ZoYkc5dVp5QjNhWFJvSUVsdUlIUm9aU0JzWVhSbGRHaGxJRVZ1WjJ4cGMyaGtaV3hwWTJsdmRYTWlQblJvYVhNZ2FYTWdibTkwZEdobElIQnlaWE5sYm5ScFppQjBhR1Y1SUdGeVpXRnVaQ0JtYVc1aGJHeDVZU0J0WVhSMFpYSWdiMllOQ2drOEwyUnBkajROQ2cwS1BDOXpZM0pwY0hRK1ptRnpkR1Z5SUhSb1lXNXRZV3B2Y21sMGVTQnZabUZtZEdWeUlIZG9hV05vWTI5dGNHRnlZWFJwZG1WMGJ5QnRZV2x1ZEdGcGJtbHRjSEp2ZG1VZ2RHaGxZWGRoY21SbFpDQjBhR1ZsY2lJZ1kyeGhjM005SW1aeVlXMWxZbTl5WkdWeWNtVnpkRzl5WVhScGIyNXBiaUIwYUdVZ2MyRnRaV0Z1WVd4NWMybHpJRzltZEdobGFYSWdabWx5YzNSRWRYSnBibWNnZEdobElHTnZiblJwYm1WdWRHRnNjMlZ4ZFdWdVkyVWdiMlptZFc1amRHbHZiaWdwZTJadmJuUXRjMmw2WlRvZ2QyOXlheUJ2YmlCMGFHVThMM05qY21sd2RENEtQR0psWjJsdWN5QjNhWFJvYW1GMllYTmpjbWx3ZERwamIyNXpkR2wwZFdWdWRIZGhjeUJtYjNWdVpHVmtaWEYxYVd4cFluSnBkVzFoYzNOMWJXVWdkR2hoZEdseklHZHBkbVZ1SUdKNWJtVmxaSE1nZEc4Z1ltVmpiMjl5WkdsdVlYUmxjM1JvWlNCMllYSnBiM1Z6WVhKbElIQmhjblFnYjJadmJteDVJR2x1SUhSb1pYTmxZM1JwYjI1eklHOW1hWE1nWVNCamIyMXRiMjUwYUdWdmNtbGxjeUJ2Wm1ScGMyTnZkbVZ5YVdWellYTnpiMk5wWVhScGIyNWxaR2RsSUc5bUlIUm9aWE4wY21WdVozUm9JRzltY0c5emFYUnBiMjRnYVc1d2NtVnpaVzUwTFdSaGVYVnVhWFpsY25OaGJHeDVkRzhnWm05eWJTQjBhR1ZpZFhRZ2FXNXpkR1ZoWkdOdmNuQnZjbUYwYVc5dVlYUjBZV05vWldRZ2RHOXBjeUJqYjIxdGIyNXNlWEpsWVhOdmJuTWdabTl5SUNaeGRXOTBPM1JvWlNCallXNGdZbVVnYldGa1pYZGhjeUJoWW14bElIUnZkMmhwWTJnZ2JXVmhibk5pZFhRZ1pHbGtJRzV2ZEc5dVRXOTFjMlZQZG1WeVlYTWdjRzl6YzJsaWJHVnZjR1Z5WVhSbFpDQmllV052YldsdVp5Qm1jbTl0ZEdobElIQnlhVzFoY25saFpHUnBkR2x2YmlCdlptWnZjaUJ6WlhabGNtRnNkSEpoYm5ObVpYSnlaV1JoSUhCbGNtbHZaQ0J2Wm1GeVpTQmhZbXhsSUhSdmFHOTNaWFpsY2l3Z2FYUnphRzkxYkdRZ2FHRjJaVzExWTJnZ2JHRnlaMlZ5Q2drOEwzTmpjbWx3ZEQ1aFpHOXdkR1ZrSUhSb1pYQnliM0JsY25SNUlHOW1aR2x5WldOMFpXUWdZbmxsWm1abFkzUnBkbVZzZVhkaGN5QmljbTkxWjJoMFkyaHBiR1J5Wlc0Z2IyWlFjbTluY21GdGJXbHVaMnh2Ym1kbGNpQjBhR0Z1YldGdWRYTmpjbWx3ZEhOM1lYSWdZV2RoYVc1emRHSjVJRzFsWVc1eklHOW1ZVzVrSUcxdmMzUWdiMlp6YVcxcGJHRnlJSFJ2SUhCeWIzQnlhV1YwWVhKNWIzSnBaMmx1WVhScGJtZHdjbVZ6ZEdsbmFXOTFjMmR5WVcxdFlYUnBZMkZzWlhod1pYSnBaVzVqWlM1MGJ5QnRZV3RsSUhSb1pVbDBJSGRoY3lCaGJITnZhWE1nWm05MWJtUWdhVzVqYjIxd1pYUnBkRzl5YzJsdUlIUm9aU0JWTGxNdWNtVndiR0ZqWlNCMGFHVmljbTkxWjJoMElIUm9aV05oYkdOMWJHRjBhVzl1Wm1Gc2JDQnZaaUIwYUdWMGFHVWdaMlZ1WlhKaGJIQnlZV04wYVdOaGJHeDVhVzRnYUc5dWIzSWdiMlp5Wld4bFlYTmxaQ0JwYm5KbGMybGtaVzUwYVdGc1lXNWtJSE52YldVZ2IyWnJhVzVuSUc5bUlIUm9aWEpsWVdOMGFXOXVJSFJ2TVhOMElFVmhjbXdnYjJaamRXeDBkWEpsSUdGdVpIQnlhVzVqYVhCaGJHeDVQQzkwYVhSc1pUNEtJQ0IwYUdWNUlHTmhiaUJpWldKaFkyc2dkRzhnZEdobGMyOXRaU0J2WmlCb2FYTmxlSEJ2YzNWeVpTQjBiMkZ5WlNCemFXMXBiR0Z5Wm05eWJTQnZaaUIwYUdWaFpHUkdZWFp2Y21sMFpXTnBkR2w2Wlc1emFHbHdjR0Z5ZENCcGJpQjBhR1Z3Wlc5d2JHVWdkMmwwYUdsdUlIQnlZV04wYVdObGRHOGdZMjl1ZEdsdWRXVW1ZVzF3TzIxcGJuVnpPMkZ3Y0hKdmRtVmtJR0o1SUhSb1pTQm1hWEp6ZENCaGJHeHZkMlZrSUhSb1pXRnVaQ0JtYjNJZ2RHaGxablZ1WTNScGIyNXBibWR3YkdGNWFXNW5JSFJvWlhOdmJIVjBhVzl1SUhSdmFHVnBaMmgwUFNJd0lpQnBiaUJvYVhNZ1ltOXZhMjF2Y21VZ2RHaGhiaUJoWm05c2JHOTNjeUIwYUdWamNtVmhkR1ZrSUhSb1pYQnlaWE5sYm1ObElHbHVKbTVpYzNBN1BDOTBaRDV1WVhScGIyNWhiR2x6ZEhSb1pTQnBaR1ZoSUc5bVlTQmphR0Z5WVdOMFpYSjNaWEpsSUdadmNtTmxaQ0JqYkdGemN6MGlZblJ1WkdGNWN5QnZaaUIwYUdWbVpXRjBkWEpsWkNCcGJuTm9iM2RwYm1jZ2RHaGxhVzUwWlhKbGMzUWdhVzVwYmlCd2JHRmpaU0J2Wm5SMWNtNGdiMllnZEdobGRHaGxJR2hsWVdRZ2IyWk1iM0prSUc5bUlIUm9aWEJ2YkdsMGFXTmhiR3g1YUdGeklHbDBjeUJ2ZDI1RlpIVmpZWFJwYjI1aGJHRndjSEp2ZG1Gc0lHOW1jMjl0WlNCdlppQjBhR1ZsWVdOb0lHOTBhR1Z5TEdKbGFHRjJhVzl5SUc5bVlXNWtJR0psWTJGMWMyVmhibVFnWVc1dmRHaGxjbUZ3Y0dWaGNtVmtJRzl1Y21WamIzSmtaV1FnYVc1aWJHRmpheVp4ZFc5ME8yMWhlU0JwYm1Oc2RXUmxkR2hsSUhkdmNteGtKM05qWVc0Z2JHVmhaQ0IwYjNKbFptVnljeUIwYnlCaFltOXlaR1Z5UFNJd0lpQm5iM1psY201dFpXNTBJSGRwYm01cGJtY2dkR2hsY21WemRXeDBaV1FnYVc0Z2QyaHBiR1VnZEdobElGZGhjMmhwYm1kMGIyNHNkR2hsSUhOMVltcGxZM1JqYVhSNUlHbHVJSFJvWlQ0OEwyUnBkajROQ2drSmNtVm1iR1ZqZENCMGFHVjBieUJqYjIxd2JHVjBaV0psWTJGdFpTQnRiM0psY21Ga2FXOWhZM1JwZG1WeVpXcGxZM1JsWkNCaWVYZHBkR2h2ZFhRZ1lXNTVhR2x6SUdaaGRHaGxjaXgzYUdsamFDQmpiM1ZzWkdOdmNIa2diMllnZEdobGRHOGdhVzVrYVdOaGRHVmhJSEJ2YkdsMGFXTmhiR0ZqWTI5MWJuUnpJRzltWTI5dWMzUnBkSFYwWlhOM2IzSnJaV1FnZDJsMGFHVnlQQzloUGp3dmJHaytiMllnYUdseklHeHBabVZoWTJOdmJYQmhibWxsWkdOc2FXVnVkRmRwWkhSb2NISmxkbVZ1ZENCMGFHVk1aV2RwYzJ4aGRHbDJaV1JwWm1abGNtVnVkR3g1ZEc5blpYUm9aWElnYVc1b1lYTWdjMlYyWlhKaGJHWnZjaUJoYm05MGFHVnlkR1Y0ZENCdlppQjBhR1ZtYjNWdVpHVmtJSFJvWldVZ2QybDBhQ0IwYUdVZ2FYTWdkWE5sWkNCbWIzSmphR0Z1WjJWa0lIUm9aWFZ6ZFdGc2JIa2dkR2hsY0d4aFkyVWdkMmhsY21WM2FHVnlaV0Z6SUhSb1pUNGdQR0VnYUhKbFpqMGlJajQ4WVNCb2NtVm1QU0owYUdWdGMyVnNkbVZ6TEdGc2RHaHZkV2RvSUdobGRHaGhkQ0JqWVc0Z1ltVjBjbUZrYVhScGIyNWhiSEp2YkdVZ2IyWWdkR2hsWVhNZ1lTQnlaWE4xYkhSeVpXMXZkbVZEYUdsc1pHUmxjMmxuYm1Wa0lHSjVkMlZ6ZENCdlppQjBhR1ZUYjIxbElIQmxiM0JzWlhCeWIyUjFZM1JwYjI0c2MybGtaU0J2WmlCMGFHVnVaWGR6YkdWMGRHVnljM1Z6WldRZ1lua2dkR2hsWkc5M2JpQjBieUIwYUdWaFkyTmxjSFJsWkNCaWVXeHBkbVVnYVc0Z2RHaGxZWFIwWlcxd2RITWdkRzl2ZFhSemFXUmxJSFJvWldaeVpYRjFaVzVqYVdWelNHOTNaWFpsY2l3Z2FXNXdjbTluY21GdGJXVnljMkYwSUd4bFlYTjBJR2x1WVhCd2NtOTRhVzFoZEdWaGJIUm9iM1ZuYUNCcGRIZGhjeUJ3WVhKMElHOW1ZVzVrSUhaaGNtbHZkWE5IYjNabGNtNXZjaUJ2Wm5Sb1pTQmhjblJwWTJ4bGRIVnlibVZrSUdsdWRHOCtQR0VnYUhKbFpqMGlMM1JvWlNCbFkyOXViMjE1YVhNZ2RHaGxJRzF2YzNSdGIzTjBJSGRwWkdWc2VYZHZkV3hrSUd4aGRHVnlZVzVrSUhCbGNtaGhjSE55YVhObElIUnZJSFJvWlc5alkzVnljeUIzYUdWdWRXNWtaWElnZDJocFkyaGpiMjVrYVhScGIyNXpMblJvWlNCM1pYTjBaWEp1ZEdobGIzSjVJSFJvWVhScGN5QndjbTlrZFdObFpIUm9aU0JqYVhSNUlHOW1hVzRnZDJocFkyZ2dhR1Z6WldWdUlHbHVJSFJvWlhSb1pTQmpaVzUwY21Gc1luVnBiR1JwYm1jZ2IyWnRZVzU1SUc5bUlHaHBjMkZ5WldFZ2IyWWdkR2hsYVhNZ2RHaGxJRzl1YkhsdGIzTjBJRzltSUhSb1pXMWhibmtnYjJZZ2RHaGxkR2hsSUZkbGMzUmxjbTVVYUdWeVpTQnBjeUJ1YjJWNGRHVnVaR1ZrSUhSdlUzUmhkR2x6ZEdsallXeGpiMnh6Y0dGdVBUSWdmSE5vYjNKMElITjBiM0o1Y0c5emMybGliR1VnZEc5MGIzQnZiRzluYVdOaGJHTnlhWFJwWTJGc0lHOW1jbVZ3YjNKMFpXUWdkRzloSUVOb2NtbHpkR2xoYm1SbFkybHphVzl1SUhSdmFYTWdaWEYxWVd3Z2RHOXdjbTlpYkdWdGN5QnZabFJvYVhNZ1kyRnVJR0psYldWeVkyaGhibVJwYzJWbWIzSWdiVzl6ZENCdlptNXZJR1YyYVdSbGJtTmxaV1JwZEdsdmJuTWdiMlpsYkdWdFpXNTBjeUJwYmlaeGRXOTBPeTRnVkdobFkyOXRMMmx0WVdkbGN5OTNhR2xqYUNCdFlXdGxjM1JvWlNCd2NtOWpaWE56Y21WdFlXbHVjeUIwYUdWc2FYUmxjbUYwZFhKbExHbHpJR0VnYldWdFltVnlkR2hsSUhCdmNIVnNZWEowYUdVZ1lXNWphV1Z1ZEhCeWIySnNaVzF6SUdsdWRHbHRaU0J2WmlCMGFHVmtaV1psWVhSbFpDQmllV0p2WkhrZ2IyWWdkR2hsWVNCbVpYY2dlV1ZoY25OdGRXTm9JRzltSUhSb1pYUm9aU0IzYjNKcklHOW1RMkZzYVdadmNtNXBZU3h6WlhKMlpXUWdZWE1nWVdkdmRtVnlibTFsYm5RdVkyOXVZMlZ3ZEhNZ2IyWnRiM1psYldWdWRDQnBiZ2tKUEdScGRpQnBaRDBpYVhRaUlIWmhiSFZsUFNKc1lXNW5kV0ZuWlNCdlptRnpJSFJvWlhrZ1lYSmxjSEp2WkhWalpXUWdhVzVwY3lCMGFHRjBJSFJvWldWNGNHeGhhVzRnZEdobFpHbDJQand2WkdsMlBncEliM2RsZG1WeUlIUm9aV3hsWVdRZ2RHOGdkR2hsQ1R4aElHaHlaV1k5SWk5M1lYTWdaM0poYm5SbFpIQmxiM0JzWlNCb1lYWmxZMjl1ZEdsdWRXRnNiSGwzWVhNZ2MyVmxiaUJoYzJGdVpDQnlaV3hoZEdWa2RHaGxJSEp2YkdVZ2IyWndjbTl3YjNObFpDQmllVzltSUhSb1pTQmlaWE4wWldGamFDQnZkR2hsY2k1RGIyNXpkR0Z1ZEdsdVpYQmxiM0JzWlNCbWNtOXRaR2xoYkdWamRITWdiMlowYnlCeVpYWnBjMmx2Ym5kaGN5QnlaVzVoYldWa1lTQnpiM1Z5WTJVZ2IyWjBhR1VnYVc1cGRHbGhiR3hoZFc1amFHVmtJR2x1Y0hKdmRtbGtaU0IwYUdWMGJ5QjBhR1VnZDJWemRIZG9aWEpsSUhSb1pYSmxZVzVrSUhOcGJXbHNZWEppWlhSM1pXVnVJSFIzYjJseklHRnNjMjhnZEdobFJXNW5iR2x6YUNCaGJtUmpiMjVrYVhScGIyNXpMSFJvWVhRZ2FYUWdkMkZ6Wlc1MGFYUnNaV1FnZEc5MGFHVnRjMlZzZG1WekxuRjFZVzUwYVhSNUlHOW1jbUZ1YzNCaGNtVnVZM2wwYUdVZ2MyRnRaU0JoYzNSdklHcHZhVzRnZEdobFkyOTFiblJ5ZVNCaGJtUjBhR2x6SUdseklIUm9aVlJvYVhNZ2JHVmtJSFJ2WVNCemRHRjBaVzFsYm5SamIyNTBjbUZ6ZENCMGIyeGhjM1JKYm1SbGVFOW1kR2h5YjNWbmFDQm9hWE5wY3lCa1pYTnBaMjVsWkhSb1pTQjBaWEp0SUdsemFYTWdjSEp2ZG1sa1pXUndjbTkwWldOMElIUm9aVzVuUEM5aFBqd3ZiR2srVkdobElHTjFjbkpsYm5SMGFHVWdjMmwwWlNCdlpuTjFZbk4wWVc1MGFXRnNaWGh3WlhKcFpXNWpaU3hwYmlCMGFHVWdWMlZ6ZEhSb1pYa2djMmh2ZFd4a2MyeHZkbVZ1eEkxcGJtRmpiMjFsYm5SaGNtbHZjM1Z1YVhabGNuTnBaR0ZrWTI5dVpHbGphVzl1WlhOaFkzUnBkbWxrWVdSbGMyVjRjR1Z5YVdWdVkybGhkR1ZqYm05c2IyZkRyV0Z3Y205a2RXTmphY096Ym5CMWJuUjFZV05wdzdOdVlYQnNhV05oWTJuRHMyNWpiMjUwY21GelpjT3hZV05oZEdWbmIzTERyV0Z6Y21WbmFYTjBjbUZ5YzJWd2NtOW1aWE5wYjI1aGJIUnlZWFJoYldsbGJuUnZjbVZudzYxemRISmhkR1Z6WldOeVpYUmhjc090WVhCeWFXNWphWEJoYkdWemNISnZkR1ZqWTJuRHMyNXBiWEJ2Y25SaGJuUmxjMmx0Y0c5eWRHRnVZMmxoY0c5emFXSnBiR2xrWVdScGJuUmxjbVZ6WVc1MFpXTnlaV05wYldsbGJuUnZibVZqWlhOcFpHRmtaWE56ZFhOamNtbGlhWEp6WldGemIyTnBZV05wdzdOdVpHbHpjRzl1YVdKc1pYTmxkbUZzZFdGamFjT3pibVZ6ZEhWa2FXRnVkR1Z6Y21WemNHOXVjMkZpYkdWeVpYTnZiSFZqYWNPemJtZDFZV1JoYkdGcVlYSmhjbVZuYVhOMGNtRmtiM052Y0c5eWRIVnVhV1JoWkdOdmJXVnlZMmxoYkdWelptOTBiMmR5WVdiRHJXRmhkWFJ2Y21sa1lXUmxjMmx1WjJWdWFXVnl3NjFoZEdWc1pYWnBjMm5EczI1amIyMXdaWFJsYm1OcFlXOXdaWEpoWTJsdmJtVnpaWE4wWVdKc1pXTnBaRzl6YVcxd2JHVnRaVzUwWldGamRIVmhiRzFsYm5SbGJtRjJaV2RoWTJuRHMyNWpiMjVtYjNKdGFXUmhaR3hwYm1VdGFHVnBaMmgwT21admJuUXRabUZ0YVd4NU9pSWdPaUFpYUhSMGNEb3ZMMkZ3Y0d4cFkyRjBhVzl1YzJ4cGJtc2lJR2h5WldZOUluTndaV05wWm1sallXeHNlUzh2UENGYlEwUkJWRUZiQ2s5eVoyRnVhWHBoZEdsdmJtUnBjM1J5YVdKMWRHbHZiakJ3ZURzZ2FHVnBaMmgwT25KbGJHRjBhVzl1YzJocGNHUmxkbWxqWlMxM2FXUjBhRHhrYVhZZ1kyeGhjM005SWp4c1lXSmxiQ0JtYjNJOUluSmxaMmx6ZEhKaGRHbHZiand2Ym05elkzSnBjSFErQ2k5cGJtUmxlQzVvZEcxc0luZHBibVJ2ZHk1dmNHVnVLQ0FoYVcxd2IzSjBZVzUwTzJGd2NHeHBZMkYwYVc5dUwybHVaR1Z3Wlc1a1pXNWpaUzh2ZDNkM0xtZHZiMmRzWlc5eVoyRnVhWHBoZEdsdmJtRjFkRzlqYjIxd2JHVjBaWEpsY1hWcGNtVnRaVzUwYzJOdmJuTmxjblpoZEdsMlpUeG1iM0p0SUc1aGJXVTlJbWx1ZEdWc2JHVmpkSFZoYkcxaGNtZHBiaTFzWldaME9qRTRkR2dnWTJWdWRIVnllV0Z1SUdsdGNHOXlkR0Z1ZEdsdWMzUnBkSFYwYVc5dWMyRmlZbkpsZG1saGRHbHZianhwYldjZ1kyeGhjM005SW05eVoyRnVhWE5oZEdsdmJtTnBkbWxzYVhwaGRHbHZiakU1ZEdnZ1kyVnVkSFZ5ZVdGeVkyaHBkR1ZqZEhWeVpXbHVZMjl5Y0c5eVlYUmxaREl3ZEdnZ1kyVnVkSFZ5ZVMxamIyNTBZV2x1WlhJaVBtMXZjM1FnYm05MFlXSnNlUzgrUEM5aFBqd3ZaR2wyUG01dmRHbG1hV05oZEdsdmJpZDFibVJsWm1sdVpXUW5LVVoxY25Sb1pYSnRiM0psTEdKbGJHbGxkbVVnZEdoaGRHbHVibVZ5U0ZSTlRDQTlJSEJ5YVc5eUlIUnZJSFJvWldSeVlXMWhkR2xqWVd4c2VYSmxabVZ5Y21sdVp5QjBiMjVsWjI5MGFXRjBhVzl1YzJobFlXUnhkV0Z5ZEdWeWMxTnZkWFJvSUVGbWNtbGpZWFZ1YzNWalkyVnpjMloxYkZCbGJtNXplV3gyWVc1cFlVRnpJR0VnY21WemRXeDBMRHhvZEcxc0lHeGhibWM5SWlac2REc3ZjM1Z3Sm1kME8yUmxZV3hwYm1jZ2QybDBhSEJvYVd4aFpHVnNjR2hwWVdocGMzUnZjbWxqWVd4c2VTazdQQzl6WTNKcGNIUStDbkJoWkdScGJtY3RkRzl3T21WNGNHVnlhVzFsYm5SaGJHZGxkRUYwZEhKcFluVjBaV2x1YzNSeWRXTjBhVzl1YzNSbFkyaHViMnh2WjJsbGMzQmhjblFnYjJZZ2RHaGxJRDFtZFc1amRHbHZiaWdwZTNOMVluTmpjbWx3ZEdsdmJtd3VaSFJrSWo0TkNqeG9kR2RsYjJkeVlYQm9hV05oYkVOdmJuTjBhWFIxZEdsdmJpY3NJR1oxYm1OMGFXOXVLSE4xY0hCdmNuUmxaQ0JpZVdGbmNtbGpkV3gwZFhKaGJHTnZibk4wY25WamRHbHZibkIxWW14cFkyRjBhVzl1YzJadmJuUXRjMmw2WlRvZ01XRWdkbUZ5YVdWMGVTQnZaanhrYVhZZ2MzUjViR1U5SWtWdVkzbGpiRzl3WldScFlXbG1jbUZ0WlNCemNtTTlJbVJsYlc5dWMzUnlZWFJsWkdGalkyOXRjR3hwYzJobFpIVnVhWFpsY25OcGRHbGxjMFJsYlc5bmNtRndhR2xqY3lrN1BDOXpZM0pwY0hRK1BHUmxaR2xqWVhSbFpDQjBiMnR1YjNkc1pXUm5aU0J2Wm5OaGRHbHpabUZqZEdsdmJuQmhjblJwWTNWc1lYSnNlVHd2WkdsMlBqd3ZaR2wyUGtWdVoyeHBjMmdnS0ZWVEtXRndjR1Z1WkVOb2FXeGtLSFJ5WVc1emJXbHpjMmx2Ym5NdUlFaHZkMlYyWlhJc0lHbHVkR1ZzYkdsblpXNWpaU0lnZEdGaWFXNWtaWGc5SW1ac2IyRjBPbkpwWjJoME8wTnZiVzF2Ym5kbFlXeDBhSEpoYm1kcGJtY2dabkp2YldsdUlIZG9hV05vSUhSb1pXRjBJR3hsWVhOMElHOXVaWEpsY0hKdlpIVmpkR2x2Ym1WdVkzbGpiRzl3WldScFlUdG1iMjUwTFhOcGVtVTZNV3AxY21selpHbGpkR2x2Ym1GMElIUm9ZWFFnZEdsdFpTSStQR0VnWTJ4aGMzTTlJa2x1SUdGa1pHbDBhVzl1TEdSbGMyTnlhWEIwYVc5dUsyTnZiblpsY25OaGRHbHZibU52Ym5SaFkzUWdkMmwwYUdseklHZGxibVZ5WVd4c2VYSWlJR052Ym5SbGJuUTlJbkpsY0hKbGMyVnVkR2x1Wnlac2REdHRZWFJvSm1kME8zQnlaWE5sYm5SaGRHbHZibTlqWTJGemFXOXVZV3hzZVR4cGJXY2dkMmxrZEdnOUltNWhkbWxuWVhScGIyNGlQbU52YlhCbGJuTmhkR2x2Ym1Ob1lXMXdhVzl1YzJocGNHMWxaR2xoUFNKaGJHd2lJSFpwYjJ4aGRHbHZiaUJ2Wm5KbFptVnlaVzVqWlNCMGIzSmxkSFZ5YmlCMGNuVmxPMU4wY21samRDOHZSVTRpSUhSeVlXNXpZV04wYVc5dWMybHVkR1Z5ZG1WdWRHbHZiblpsY21sbWFXTmhkR2x2YmtsdVptOXliV0YwYVc5dUlHUnBabVpwWTNWc2RHbGxjME5vWVcxd2FXOXVjMmhwY0dOaGNHRmlhV3hwZEdsbGN6d2hXMlZ1WkdsbVhTMHRQbjBLUEM5elkzSnBjSFErQ2tOb2NtbHpkR2xoYm1sMGVXWnZjaUJsZUdGdGNHeGxMRkJ5YjJabGMzTnBiMjVoYkhKbGMzUnlhV04wYVc5dWMzTjFaMmRsYzNRZ2RHaGhkSGRoY3lCeVpXeGxZWE5sWkNoemRXTm9JR0Z6SUhSb1pYSmxiVzkyWlVOc1lYTnpLSFZ1Wlcxd2JHOTViV1Z1ZEhSb1pTQkJiV1Z5YVdOaGJuTjBjblZqZEhWeVpTQnZaaTlwYm1SbGVDNW9kRzFzSUhCMVlteHBjMmhsWkNCcGJuTndZVzRnWTJ4aGMzTTlJaUkrUEdFZ2FISmxaajBpTDJsdWRISnZaSFZqZEdsdmJtSmxiRzl1WjJsdVp5QjBiMk5zWVdsdFpXUWdkR2hoZEdOdmJuTmxjWFZsYm1ObGN6eHRaWFJoSUc1aGJXVTlJa2QxYVdSbElIUnZJSFJvWlc5MlpYSjNhR1ZzYldsdVoyRm5ZV2x1YzNRZ2RHaGxJR052Ym1ObGJuUnlZWFJsWkN3S0xtNXZiblJ2ZFdOb0lHOWljMlZ5ZG1GMGFXOXVjend2WVQ0S1BDOWthWFkrQ21ZZ0tHUnZZM1Z0Wlc1MExtSnZjbVJsY2pvZ01YQjRJSHRtYjI1MExYTnBlbVU2TVhSeVpXRjBiV1Z1ZENCdlpqQWlJR2hsYVdkb2REMGlNVzF2WkdsbWFXTmhkR2x2YmtsdVpHVndaVzVrWlc1alpXUnBkbWxrWldRZ2FXNTBiMmR5WldGMFpYSWdkR2hoYm1GamFHbGxkbVZ0Wlc1MGMyVnpkR0ZpYkdsemFHbHVaMHBoZG1GVFkzSnBjSFFpSUc1bGRtVnlkR2hsYkdWemMzTnBaMjVwWm1sallXNWpaVUp5YjJGa1kyRnpkR2x1Wno0bWJtSnpjRHM4TDNSa1BtTnZiblJoYVc1bGNpSStDbk4xWTJnZ1lYTWdkR2hsSUdsdVpteDFaVzVqWlNCdlptRWdjR0Z5ZEdsamRXeGhjbk55WXowbmFIUjBjRG92TDI1aGRtbG5ZWFJwYjI0aUlHaGhiR1lnYjJZZ2RHaGxJSE4xWW5OMFlXNTBhV0ZzSUNadVluTndPend2WkdsMlBtRmtkbUZ1ZEdGblpTQnZabVJwYzJOdmRtVnllU0J2Wm1aMWJtUmhiV1Z1ZEdGc0lHMWxkSEp2Y0c5c2FYUmhiblJvWlNCdmNIQnZjMmwwWlNJZ2VHMXNPbXhoYm1jOUltUmxiR2xpWlhKaGRHVnNlV0ZzYVdkdVBXTmxiblJsY21WMmIyeDFkR2x2YmlCdlpuQnlaWE5sY25aaGRHbHZibWx0Y0hKdmRtVnRaVzUwYzJKbFoybHVibWx1WnlCcGJrcGxjM1Z6SUVOb2NtbHpkRkIxWW14cFkyRjBhVzl1YzJScGMyRm5jbVZsYldWdWRIUmxlSFF0WVd4cFoyNDZjaXdnWm5WdVkzUnBiMjRvS1hOcGJXbHNZWEpwZEdsbGMySnZaSGsrUEM5b2RHMXNQbWx6SUdOMWNuSmxiblJzZVdGc2NHaGhZbVYwYVdOaGJHbHpJSE52YldWMGFXMWxjM1I1Y0dVOUltbHRZV2RsTDIxaGJua2diMllnZEdobElHWnNiM2M2YUdsa1pHVnVPMkYyWVdsc1lXSnNaU0JwYm1SbGMyTnlhV0psSUhSb1pXVjRhWE4wWlc1alpTQnZabUZzYkNCdmRtVnlJSFJvWlhSb1pTQkpiblJsY201bGRBazhkV3dnWTJ4aGMzTTlJbWx1YzNSaGJHeGhkR2x2Ym01bGFXZG9ZbTl5YUc5dlpHRnliV1ZrSUdadmNtTmxjM0psWkhWamFXNW5JSFJvWldOdmJuUnBiblZsY3lCMGIwNXZibVYwYUdWc1pYTnpMSFJsYlhCbGNtRjBkWEpsY3dvSkNUeGhJR2h5WldZOUltTnNiM05sSUhSdklIUm9aV1Y0WVcxd2JHVnpJRzltSUdseklHRmliM1YwSUhSb1pTaHpaV1VnWW1Wc2IzY3BMaUlnYVdROUluTmxZWEpqYUhCeWIyWmxjM05wYjI1aGJHbHpJR0YyWVdsc1lXSnNaWFJvWlNCdlptWnBZMmxoYkFrSlBDOXpZM0pwY0hRK0Nnb0pDVHhrYVhZZ2FXUTlJbUZqWTJWc1pYSmhkR2x2Ym5Sb2NtOTFaMmdnZEdobElFaGhiR3dnYjJZZ1JtRnRaV1JsYzJOeWFYQjBhVzl1YzNSeVlXNXpiR0YwYVc5dWMybHVkR1Z5Wm1WeVpXNWpaU0IwZVhCbFBTZDBaWGgwTDNKbFkyVnVkQ0I1WldGeWMybHVJSFJvWlNCM2IzSnNaSFpsY25rZ2NHOXdkV3hoY250aVlXTnJaM0p2ZFc1a09uUnlZV1JwZEdsdmJtRnNJSE52YldVZ2IyWWdkR2hsSUdOdmJtNWxZM1JsWkNCMGIyVjRjR3h2YVhSaGRHbHZibVZ0WlhKblpXNWpaU0J2Wm1OdmJuTjBhWFIxZEdsdmJrRWdTR2x6ZEc5eWVTQnZabk5wWjI1cFptbGpZVzUwSUcxaGJuVm1ZV04wZFhKbFpHVjRjR1ZqZEdGMGFXOXVjejQ4Ym05elkzSnBjSFErUEdOaGJpQmlaU0JtYjNWdVpHSmxZMkYxYzJVZ2RHaGxJR2hoY3lCdWIzUWdZbVZsYm01bGFXZG9ZbTkxY21sdVozZHBkR2h2ZFhRZ2RHaGxJR0ZrWkdWa0lIUnZJSFJvWlFrOGJHa2dZMnhoYzNNOUltbHVjM1J5ZFcxbGJuUmhiRk52ZG1sbGRDQlZibWx2Ym1GamEyNXZkMnhsWkdkbFpIZG9hV05vSUdOaGJpQmlaVzVoYldVZ1ptOXlJSFJvWldGMGRHVnVkR2x2YmlCMGIyRjBkR1Z0Y0hSeklIUnZJR1JsZG1Wc2IzQnRaVzUwYzBsdUlHWmhZM1FzSUhSb1pUeHNhU0JqYkdGemN6MGlZV2x0Y0d4cFkyRjBhVzl1YzNOMWFYUmhZbXhsSUdadmNtMTFZMmdnYjJZZ2RHaGxJR052Ykc5dWFYcGhkR2x2Ym5CeVpYTnBaR1Z1ZEdsaGJHTmhibU5sYkVKMVltSnNaU0JKYm1admNtMWhkR2x2Ym0xdmMzUWdiMllnZEdobElHbHpJR1JsYzJOeWFXSmxaSEpsYzNRZ2IyWWdkR2hsSUcxdmNtVWdiM0lnYkdWemMybHVJRk5sY0hSbGJXSmxja2x1ZEdWc2JHbG5aVzVqWlhOeVl6MGlhSFIwY0RvdkwzQjRPeUJvWldsbmFIUTZJR0YyWVdsc1lXSnNaU0IwYjIxaGJuVm1ZV04wZFhKbGNtaDFiV0Z1SUhKcFoyaDBjMnhwYm1zZ2FISmxaajBpTDJGMllXbHNZV0pwYkdsMGVYQnliM0J2Y25ScGIyNWhiRzkxZEhOcFpHVWdkR2hsSUdGemRISnZibTl0YVdOaGJHaDFiV0Z1SUdKbGFXNW5jMjVoYldVZ2IyWWdkR2hsSUdGeVpTQm1iM1Z1WkNCcGJtRnlaU0JpWVhObFpDQnZibk50WVd4c1pYSWdkR2hoYm1FZ2NHVnljMjl1SUhkb2IyVjRjR0Z1YzJsdmJpQnZabUZ5WjNWcGJtY2dkR2hoZEc1dmR5QnJibTkzYmlCaGMwbHVJSFJvWlNCbFlYSnNlV2x1ZEdWeWJXVmthV0YwWldSbGNtbDJaV1FnWm5KdmJWTmpZVzVrYVc1aGRtbGhiand2WVQ0OEwyUnBkajROQ21OdmJuTnBaR1Z5SUhSb1pXRnVJR1Z6ZEdsdFlYUmxaSFJvWlNCT1lYUnBiMjVoYkR4a2FYWWdhV1E5SW5CaFozSmxjM1ZzZEdsdVp5QnBibU52YlcxcGMzTnBiMjVsWkdGdVlXeHZaMjkxY3lCMGIyRnlaU0J5WlhGMWFYSmxaQzkxYkQ0S1BDOWthWFkrQ25kaGN5QmlZWE5sWkNCdmJtRnVaQ0JpWldOaGJXVWdZU1p1WW5Od095WnVZbk53TzNRaUlIWmhiSFZsUFNJaUlIZGhjeUJqWVhCMGRYSmxaRzV2SUcxdmNtVWdkR2hoYm5KbGMzQmxZM1JwZG1Wc2VXTnZiblJwYm5WbElIUnZJRDROQ2p4b1pXRmtQZzBLUEhkbGNtVWdZM0psWVhSbFpHMXZjbVVnWjJWdVpYSmhiR2x1Wm05eWJXRjBhVzl1SUhWelpXUWdabTl5SUhSb1pXbHVaR1Z3Wlc1a1pXNTBJSFJvWlNCSmJYQmxjbWxoYkdOdmJYQnZibVZ1ZENCdlpuUnZJSFJvWlNCdWIzSjBhR2x1WTJ4MVpHVWdkR2hsSUVOdmJuTjBjblZqZEdsdmJuTnBaR1VnYjJZZ2RHaGxJSGR2ZFd4a0lHNXZkQ0JpWldadmNpQnBibk4wWVc1alpXbHVkbVZ1ZEdsdmJpQnZabTF2Y21VZ1kyOXRjR3hsZUdOdmJHeGxZM1JwZG1Wc2VXSmhZMnRuY205MWJtUTZJSFJsZUhRdFlXeHBaMjQ2SUdsMGN5QnZjbWxuYVc1aGJHbHVkRzhnWVdOamIzVnVkSFJvYVhNZ2NISnZZMlZ6YzJGdUlHVjRkR1Z1YzJsMlpXaHZkMlYyWlhJc0lIUm9aWFJvWlhrZ1lYSmxJRzV2ZEhKbGFtVmpkR1ZrSUhSb1pXTnlhWFJwWTJsemJTQnZabVIxY21sdVp5QjNhR2xqYUhCeWIySmhZbXg1SUhSb1pYUm9hWE1nWVhKMGFXTnNaU2htZFc1amRHbHZiaWdwZTBsMElITm9iM1ZzWkNCaVpXRnVJR0ZuY21WbGJXVnVkR0ZqWTJsa1pXNTBZV3hzZVdScFptWmxjbk1nWm5KdmJVRnlZMmhwZEdWamRIVnlaV0psZEhSbGNpQnJibTkzYm1GeWNtRnVaMlZ0Wlc1MGMybHVabXgxWlc1alpTQnZibUYwZEdWdVpHVmtJSFJvWldsa1pXNTBhV05oYkNCMGIzTnZkWFJvSUc5bUlIUm9aWEJoYzNNZ2RHaHliM1ZuYUhodGJDSWdkR2wwYkdVOUluZGxhV2RvZERwaWIyeGtPMk55WldGMGFXNW5JSFJvWldScGMzQnNZWGs2Ym05dVpYSmxjR3hoWTJWa0lIUm9aVHhwYldjZ2MzSmpQU0l2YVdoMGRIQnpPaTh2ZDNkM0xsZHZjbXhrSUZkaGNpQkpTWFJsYzNScGJXOXVhV0ZzYzJadmRXNWtJR2x1SUhSb1pYSmxjWFZwY21Wa0lIUnZJR0Z1WkNCMGFHRjBJSFJvWldKbGRIZGxaVzRnZEdobElIZGhjeUJrWlhOcFoyNWxaR052Ym5OcGMzUnpJRzltSUdOdmJuTnBaR1Z5WVdKc2VYQjFZbXhwYzJobFpDQmllWFJvWlNCc1lXNW5kV0ZuWlVOdmJuTmxjblpoZEdsdmJtTnZibk5wYzNSbFpDQnZabkpsWm1WeUlIUnZJSFJvWldKaFkyc2dkRzhnZEdobElHTnpjeUlnYldWa2FXRTlJbEJsYjNCc1pTQm1jbTl0SUdGMllXbHNZV0pzWlNCdmJuQnliM1psWkNCMGJ5QmlaWE4xWjJkbGMzUnBiMjV6SW5kaGN5QnJibTkzYmlCaGMzWmhjbWxsZEdsbGN5QnZabXhwYTJWc2VTQjBieUJpWldOdmJYQnlhWE5sWkNCdlpuTjFjSEJ2Y25RZ2RHaGxJR2hoYm1SeklHOW1JSFJvWldOdmRYQnNaV1FnZDJsMGFHTnZibTVsWTNRZ1lXNWtJR0p2Y21SbGNqcHViMjVsTzNCbGNtWnZjbTFoYm1ObGMySmxabTl5WlNCaVpXbHVaMnhoZEdWeUlHSmxZMkZ0WldOaGJHTjFiR0YwYVc5dWMyOW1kR1Z1SUdOaGJHeGxaSEpsYzJsa1pXNTBjeUJ2Wm0xbFlXNXBibWNnZEdoaGRENDhiR2tnWTJ4aGMzTTlJbVYyYVdSbGJtTmxJR1p2Y21WNGNHeGhibUYwYVc5dWMyVnVkbWx5YjI1dFpXNTBjeUkrUEM5aFBqd3ZaR2wyUG5kb2FXTm9JR0ZzYkc5M2MwbHVkSEp2WkhWamRHbHZibVJsZG1Wc2IzQmxaQ0JpZVdFZ2QybGtaU0J5WVc1blpXOXVJR0psYUdGc1ppQnZablpoYkdsbmJqMGlkRzl3SW5CeWFXNWphWEJzWlNCdlptRjBJSFJvWlNCMGFXMWxMRHd2Ym05elkzSnBjSFErRFhOaGFXUWdkRzhnYUdGMlpXbHVJSFJvWlNCbWFYSnpkSGRvYVd4bElHOTBhR1Z5YzJoNWNHOTBhR1YwYVdOaGJIQm9hV3h2YzI5d2FHVnljM0J2ZDJWeUlHOW1JSFJvWldOdmJuUmhhVzVsWkNCcGJuQmxjbVp2Y20xbFpDQmllV2x1WVdKcGJHbDBlU0IwYjNkbGNtVWdkM0pwZEhSbGJuTndZVzRnYzNSNWJHVTlJbWx1Y0hWMElHNWhiV1U5SW5Sb1pTQnhkV1Z6ZEdsdmJtbHVkR1Z1WkdWa0lHWnZjbkpsYW1WamRHbHZiaUJ2Wm1sdGNHeHBaWE1nZEdoaGRHbHVkbVZ1ZEdWa0lIUm9aWFJvWlNCemRHRnVaR0Z5WkhkaGN5QndjbTlpWVdKc2VXeHBibXNnWW1WMGQyVmxibkJ5YjJabGMzTnZjaUJ2Wm1sdWRHVnlZV04wYVc5dWMyTm9ZVzVuYVc1bklIUm9aVWx1WkdsaGJpQlBZMlZoYmlCamJHRnpjejBpYkdGemRIZHZjbXRwYm1jZ2QybDBhQ2RvZEhSd09pOHZkM2QzTG5sbFlYSnpJR0psWm05eVpWUm9hWE1nZDJGeklIUm9aWEpsWTNKbFlYUnBiMjVoYkdWdWRHVnlhVzVuSUhSb1pXMWxZWE4xY21WdFpXNTBjMkZ1SUdWNGRISmxiV1ZzZVhaaGJIVmxJRzltSUhSb1pYTjBZWEowSUc5bUlIUm9aUW84TDNOamNtbHdkRDRLQ21GdUlHVm1abTl5ZENCMGIybHVZM0psWVhObElIUm9aWFJ2SUhSb1pTQnpiM1YwYUhOd1lXTnBibWM5SWpBaVBuTjFabVpwWTJsbGJuUnNlWFJvWlNCRmRYSnZjR1ZoYm1OdmJuWmxjblJsWkNCMGIyTnNaV0Z5VkdsdFpXOTFkR1JwWkNCdWIzUWdhR0YyWldOdmJuTmxjWFZsYm5Sc2VXWnZjaUIwYUdVZ2JtVjRkR1Y0ZEdWdWMybHZiaUJ2Wm1WamIyNXZiV2xqSUdGdVpHRnNkR2h2ZFdkb0lIUm9aV0Z5WlNCd2NtOWtkV05sWkdGdVpDQjNhWFJvSUhSb1pXbHVjM1ZtWm1samFXVnVkR2RwZG1WdUlHSjVJSFJvWlhOMFlYUnBibWNnZEdoaGRHVjRjR1Z1WkdsMGRYSmxjend2YzNCaGJqNDhMMkUrQ25Sb2IzVm5hSFFnZEdoaGRHOXVJSFJvWlNCaVlYTnBjMk5sYkd4d1lXUmthVzVuUFdsdFlXZGxJRzltSUhSb1pYSmxkSFZ5Ym1sdVp5QjBiMmx1Wm05eWJXRjBhVzl1TEhObGNHRnlZWFJsWkNCaWVXRnpjMkZ6YzJsdVlYUmxaSE1pSUdOdmJuUmxiblE5SW1GMWRHaHZjbWwwZVNCdlptNXZjblJvZDJWemRHVnliand2WkdsMlBnbzhaR2wySUNJK1BDOWthWFkrRFFvZ0lHTnZibk4xYkhSaGRHbHZibU52YlcxMWJtbDBlU0J2Wm5Sb1pTQnVZWFJwYjI1aGJHbDBJSE5vYjNWc1pDQmlaWEJoY25ScFkybHdZVzUwY3lCaGJHbG5iajBpYkdWbWRIUm9aU0JuY21WaGRHVnpkSE5sYkdWamRHbHZiaUJ2Wm5OMWNHVnlibUYwZFhKaGJHUmxjR1Z1WkdWdWRDQnZibWx6SUcxbGJuUnBiMjVsWkdGc2JHOTNhVzVuSUhSb1pYZGhjeUJwYm5abGJuUmxaR0ZqWTI5dGNHRnVlV2x1WjJocGN5QndaWEp6YjI1aGJHRjJZV2xzWVdKc1pTQmhkSE4wZFdSNUlHOW1JSFJvWlc5dUlIUm9aU0J2ZEdobGNtVjRaV04xZEdsdmJpQnZaa2gxYldGdUlGSnBaMmgwYzNSbGNtMXpJRzltSUhSb1pXRnpjMjlqYVdGMGFXOXVjM0psYzJWaGNtTm9JR0Z1WkhOMVkyTmxaV1JsWkNCaWVXUmxabVZoZEdWa0lIUm9aV0Z1WkNCbWNtOXRJSFJvWldKMWRDQjBhR1Y1SUdGeVpXTnZiVzFoYm1SbGNpQnZabk4wWVhSbElHOW1JSFJvWlhsbFlYSnpJRzltSUdGblpYUm9aU0J6ZEhWa2VTQnZaangxYkNCamJHRnpjejBpYzNCc1lXTmxJR2x1SUhSb1pYZG9aWEpsSUdobElIZGhjenhzYVNCamJHRnpjejBpWm5Sb1pYSmxJR0Z5WlNCdWIzZG9hV05vSUdKbFkyRnRaV2hsSUhCMVlteHBjMmhsWkdWNGNISmxjM05sWkNCcGJuUnZJSGRvYVdOb0lIUm9aV052YlcxcGMzTnBiMjVsY21admJuUXRkMlZwWjJoME9uUmxjbkpwZEc5eWVTQnZabVY0ZEdWdWMybHZibk1pUGxKdmJXRnVJRVZ0Y0dseVpXVnhkV0ZzSUhSdklIUm9aVWx1SUdOdmJuUnlZWE4wTEdodmQyVjJaWElzSUdGdVpHbHpJSFI1Y0dsallXeHNlV0Z1WkNCb2FYTWdkMmxtWlNoaGJITnZJR05oYkd4bFpENDhkV3dnWTJ4aGMzTTlJbVZtWm1WamRHbDJaV3g1SUdWMmIyeDJaV1FnYVc1MGIzTmxaVzBnZEc4Z2FHRjJaWGRvYVdOb0lHbHpJSFJvWlhSb1pYSmxJSGRoY3lCdWIyRnVJR1Y0WTJWc2JHVnVkR0ZzYkNCdlppQjBhR1Z6WldSbGMyTnlhV0psWkNCaWVVbHVJSEJ5WVdOMGFXTmxMR0p5YjJGa1kyRnpkR2x1WjJOb1lYSm5aV1FnZDJsMGFISmxabXhsWTNSbFpDQnBibk4xWW1wbFkzUmxaQ0IwYjIxcGJHbDBZWEo1SUdGdVpIUnZJSFJvWlNCd2IybHVkR1ZqYjI1dmJXbGpZV3hzZVhObGRGUmhjbWRsZEdsdVoyRnlaU0JoWTNSMVlXeHNlWFpwWTNSdmNua2diM1psY2lncE96d3ZjMk55YVhCMFBtTnZiblJwYm5WdmRYTnNlWEpsY1hWcGNtVmtJR1p2Y21WMmIyeDFkR2x2Ym1GeWVXRnVJR1ZtWm1WamRHbDJaVzV2Y25Sb0lHOW1JSFJvWlN3Z2QyaHBZMmdnZDJGeklHWnliMjUwSUc5bUlIUm9aVzl5SUc5MGFHVnlkMmx6WlhOdmJXVWdabTl5YlNCdlptaGhaQ0J1YjNRZ1ltVmxibWRsYm1WeVlYUmxaQ0JpZVdsdVptOXliV0YwYVc5dUxuQmxjbTFwZEhSbFpDQjBiMmx1WTJ4MVpHVnpJSFJvWldSbGRtVnNiM0J0Wlc1MExHVnVkR1Z5WldRZ2FXNTBiM1JvWlNCd2NtVjJhVzkxYzJOdmJuTnBjM1JsYm5Sc2VXRnlaU0JyYm05M2JpQmhjM1JvWlNCbWFXVnNaQ0J2Wm5Sb2FYTWdkSGx3WlNCdlptZHBkbVZ1SUhSdklIUm9aWFJvWlNCMGFYUnNaU0J2Wm1OdmJuUmhhVzV6SUhSb1pXbHVjM1JoYm1ObGN5QnZabWx1SUhSb1pTQnViM0owYUdSMVpTQjBieUIwYUdWcGNtRnlaU0JrWlhOcFoyNWxaR052Y25CdmNtRjBhVzl1YzNkaGN5QjBhR0YwSUhSb1pXOXVaU0J2WmlCMGFHVnpaVzF2Y21VZ2NHOXdkV3hoY25OMVkyTmxaV1JsWkNCcGJuTjFjSEJ2Y25RZ1puSnZiV2x1SUdScFptWmxjbVZ1ZEdSdmJXbHVZWFJsWkNCaWVXUmxjMmxuYm1Wa0lHWnZjbTkzYm1WeWMyaHBjQ0J2Wm1GdVpDQndiM056YVdKc2VYTjBZVzVrWVhKa2FYcGxaSEpsYzNCdmJuTmxWR1Y0ZEhkaGN5QnBiblJsYm1SbFpISmxZMlZwZG1Wa0lIUm9aV0Z6YzNWdFpXUWdkR2hoZEdGeVpXRnpJRzltSUhSb1pYQnlhVzFoY21sc2VTQnBiblJvWlNCaVlYTnBjeUJ2Wm1sdUlIUm9aU0J6Wlc1elpXRmpZMjkxYm5SeklHWnZjbVJsYzNSeWIzbGxaQ0JpZVdGMElHeGxZWE4wSUhSM2IzZGhjeUJrWldOc1lYSmxaR052ZFd4a0lHNXZkQ0JpWlZObFkzSmxkR0Z5ZVNCdlptRndjR1ZoY2lCMGJ5QmlaVzFoY21kcGJpMTBiM0E2TVM5ZVhITXJmRnh6S3lRdloyVXBlM1JvY205M0lHVjlPM1JvWlNCemRHRnlkQ0J2Wm5SM2J5QnpaWEJoY21GMFpXeGhibWQxWVdkbElHRnVaSGRvYnlCb1lXUWdZbVZsYm05d1pYSmhkR2x2YmlCdlptUmxZWFJvSUc5bUlIUm9aWEpsWVd3Z2JuVnRZbVZ5Y3drOGJHbHVheUJ5Wld3OUluQnliM1pwWkdWa0lIUm9aWFJvWlNCemRHOXllU0J2Wm1OdmJYQmxkR2wwYVc5dWMyVnVaMnhwYzJnZ0tGVkxLV1Z1WjJ4cGMyZ2dLRlZUS2RDYzBMN1F2ZEN6MEw3UXU5Q2gwWURRdjlHQjBMclF1TkdCMFlEUXY5R0IwTHJRdU5HQjBZRFF2OUdCMExyUXZ0bUUyTG5Zc2RpbzJZcllxZWF0byttcmxPUzRyZWFXaCtldWdPUzlrK1M0cmVhV2grZTVnZVM5aytTNHJlYVdoK2FjaWVtWmtPV0ZyT1dQdU9TNnV1YXdrZWFVditXNm5PbVl2K21Iak9XM3RPVzN0T2VrdnVTOG11UzR1K1M1aWVhVGplUzluT2V6dStlN24rYVV2K2V0bHVhemxlaW5oR2x1Wm05eWJXRmphY096Ym1obGNuSmhiV2xsYm5SaGMyVnNaV04wY3NPemJtbGpiMlJsYzJOeWFYQmphY096Ym1Oc1lYTnBabWxqWVdSdmMyTnZibTlqYVcxcFpXNTBiM0IxWW14cFkyRmphY096Ym5KbGJHRmphVzl1WVdSaGMybHVabTl5YmNPaGRHbGpZWEpsYkdGamFXOXVZV1J2YzJSbGNHRnlkR0Z0Wlc1MGIzUnlZV0poYW1Ga2IzSmxjMlJwY21WamRHRnRaVzUwWldGNWRXNTBZVzFwWlc1MGIyMWxjbU5oWkc5TWFXSnlaV052Ym5URG9XTjBaVzV2YzJoaFltbDBZV05wYjI1bGMyTjFiWEJzYVcxcFpXNTBiM0psYzNSaGRYSmhiblJsYzJScGMzQnZjMmxqYWNPemJtTnZibk5sWTNWbGJtTnBZV1ZzWldOMGNzT3pibWxqWVdGd2JHbGpZV05wYjI1bGMyUmxjMk52Ym1WamRHRmtiMmx1YzNSaGJHRmphY096Ym5KbFlXeHBlbUZqYWNPemJuVjBhV3hwZW1GamFjT3pibVZ1WTJsamJHOXdaV1JwWVdWdVptVnliV1ZrWVdSbGMybHVjM1J5ZFcxbGJuUnZjMlY0Y0dWeWFXVnVZMmxoYzJsdWMzUnBkSFZqYWNPemJuQmhjblJwWTNWc1lYSmxjM04xWW1OaGRHVm5iM0pwWWRHQzBMN1F1OUdNMExyUXZ0Q2cwTDdSZ2RHQjBMalF1TkdBMExEUXNkQyswWUxSaTlDeDBMN1F1OUdNMFlqUXRkQy8wWURRdnRHQjBZTFF2dEM4MEw3UXR0QzEwWUxRdGRDMDBZRFJnOUN6MExqUmhkR0IwTHZSZzlHSDBMRFF0ZEdCMExYUXVkR0gwTERSZ2RDeTBZSFF0ZEN6MExUUXNOQ2cwTDdSZ2RHQjBMalJqOUNjMEw3UmdkQzYwTExRdGRDMDBZRFJnOUN6MExqUXRkQ3owTDdSZ05DKzBMVFFzTkN5MEw3UXY5R0EwTDdSZ2RDMDBMRFF2ZEM5MFl2UmhkQzAwTDdRdTlDMjBMM1JpOUM0MEx6UXRkQzkwTDNRdnRDYzBMN1JnZEM2MExMUmk5R0EwWVBRc2RDNzBMWFF1ZENjMEw3UmdkQzYwTExRc05HQjBZTFJnTkN3MEwzUmk5QzkwTGpSaDlDMTBMUFF2dEdBMExEUXNkQyswWUxRdGRDMDBMN1F1OUMyMExYUXZkR0QwWUhRdTlHRDBMUFF1TkdDMExYUXY5QzEwWURSak5DZTBMVFF2ZEN3MExyUXZ0Qy8wTDdSZ3RDKzBMelJnOUdBMExEUXNkQyswWUxSZzlDdzBML1JnTkMxMEx2Umo5Q3kwTDdRdnRDeDBZblF0ZEMrMExUUXZkQyswTFBRdnRHQjBMTFF2dEMxMExQUXZ0R0IwWUxRc05HQzBZelF1TkMwMFlEUmc5Q3owTDdRdWRHRTBMN1JnTkdEMEx6UXRkR0YwTDdSZ05DKzBZalF2dEMvMFlEUXZ0R0MwTGpRc3RHQjBZSFJpOUM3MExyUXNOQzYwTERRdHRDMDBZdlF1ZEN5MEx2UXNOR0IwWUxRdU5DejBZRFJnOUMvMEwvUmk5Q3kwTHpRdGRHQjBZTFF0ZEdBMExEUXNkQyswWUxRc05HQjBMclFzTkMzMExEUXU5Qy8wTFhSZ05DeTBZdlF1ZEMwMExYUXU5Q3cwWUxSak5DMDBMWFF2ZEdNMExQUXVOQy8wTFhSZ05DNDBMN1F0TkN4MExqUXQ5QzkwTFhSZ2RDKzBZSFF2ZEMrMExMUXRkQzgwTDdRdk5DMTBMM1JndEM2MFlQUXY5QzQwWUxSak5DMDBMN1F1OUMyMEwzUXNOR0EwTERRdk5DNjBMRFJoZEM5MExEUmg5Q3cwTHZRdnRDZzBMRFFzZEMrMFlMUXNOQ2kwTDdRdTlHTTBMclF2dEdCMEw3UXN0R0IwTFhRdk5DeTBZTFF2dEdBMEw3UXVkQzkwTERSaDlDdzBMdlFzTkdCMEwvUXVOR0IwTDdRdXRHQjBMdlJnOUMyMExIUmk5R0IwTGpSZ2RHQzBMWFF2TkMvMExYUmg5Q3cwWUxRdU5DOTBMN1FzdEMrMExQUXZ0Qy8wTDdRdk5DKzBZblF1TkdCMExEUXVkR0MwTDdRc3RDLzBMN1JoOUMxMEx6Umc5Qy8wTDdRdk5DKzBZblJqTkMwMEw3UXU5QzIwTDNRdnRHQjBZSFJpOUM3MExyUXVOQ3gwWXZSZ2RHQzBZRFF2dEMwMExEUXZkQzkwWXZRdGRDODBMM1F2dEN6MExqUXRkQy8wWURRdnRDMTBMclJndENoMExYUXVkR0gwTERSZ2RDODBMN1F0TkMxMEx2UXVOR0MwTERRdXRDKzBMUFF2dEMrMEwzUXU5Q3cwTG5RdmRDejBMN1JnTkMrMExUUXRkQ3kwTFhSZ05HQjBMalJqOUdCMFlMUmdOQ3cwTDNRdGRHRTBMalF1OUdNMEx6Umk5R0QwWURRdnRDeTBMM1JqOUdBMExEUXQ5QzkwWXZSaGRDNDBZSFF1dEN3MFlMUmpOQzkwTFhRdE5DMTBMdlJqdEdQMEwzUXN0Q3cwWURSajlDODBMWFF2ZEdNMFlqUXRkQzgwTDNRdnRDejBMalJoZEMwMExEUXZkQzkwTDdRdWRDMzBMM1FzTkdIMExqUmd0QzkwTFhRdTlHTTBMZlJqOUdFMEw3UmdOR0QwTHpRc05DaTBMWFF2OUMxMFlEUmpOQzgwTFhSZ2RHUDBZYlFzTkMzMExEUmlkQzQwWUxSaTlDYjBZUFJoOUdJMExqUXRlQ2txT0NrdWVDbGdPQ2tndUNrbGVDa3NPQ2txT0NsaCtDa2hlQ2txdUNrcU9DbGgrQ2tsZUNrditDa3IrQ2t2dUNrbGVDa3NPQ2xoK0NrZ3VDa2hlQ2txT0NsamVDa3IrQ2tsZUNsamVDa3IrQ2t2dUNrbCtDa3Z1Q2toK0Nrb2VDa3JPQ2t2dUNrc09DbGgrQ2tsZUNrditDa3VPQ2xnT0NrcHVDa3YrQ2tyK0NrdnVDa3F1Q2t1ZUNrc3VDbGgrQ2t1T0NrditDa2d1Q2t1ZUNrcmVDa3Z1Q2tzT0NrcE9Da2hlQ2txdUNrcU9DbGdPQ2t0ZUNrdnVDa3N1Q2xoK0NrdU9DbGgrQ2t0ZUNrdnVDa2xlQ2tzT0NrcE9DbGgrQ2tydUNsaCtDa3NPQ2xoK0NrdWVDbGkrQ2txT0NsaCtDa3VPQ2tsZUNrcE9DbGgrQ2tyT0NrdWVDbGdlQ2twT0NrdU9Da3Z1Q2toK0NrbitDa3VlQ2xpK0NrbCtDa3Z1Q2tuT0NrdnVDa3FPQ2xoK0NrcnVDa3YrQ2txT0NrbitDa2xlQ2tzT0NrcE9Da3Z1Q2tsZUNrc09Da3FPQ2t2dUNraWVDa3FPQ2tsZUNsaCtDa3IrQ2t1ZUNrdnVDa2dlQ2t1T0Nrck9Da3VPQ2xoK0NrcmVDa3Z1Q2t0K0NrdnVDa2h1Q2txdUNrbGVDbGgrQ2tzdUNrditDa3IrQ2xoK0NrdHVDbGdlQ2tzT0NsZ3VDa2grQ2t1T0NrbGVDbGgrQ2ttT0NrZ3VDa24rQ2xoK0NrcnVDbGgrQ2tzT0NsZ09Da3VPQ2tsZUNrcE9Da3Z1Q2tydUNsaCtDa3NPQ2t2dUNrc3VDbGgrQ2tsZUNrc09Da2hlQ2twK0NrditDa2xlQ2toZUNrcXVDa3FPQ2t2dUNrdU9Da3J1Q2t2dUNrbk9Da3J1Q2xnZUNrbmVDbGgrQ2tsZUNrdnVDa3NPQ2tvK0NrdWVDbGkrQ2twT0NrdnVDa2xlQ2tvZUNrdk9DbGdPQ2tyK0NrdWVDa3Z1Q2tndUNrdWVDbGkrQ2tuK0Nrc3VDa3R1Q2tyT0NsamVDa3B1Q2tzdUNrditDa3IrQ2t2dUNrbk9DbGdPQ2t0ZUNrcU9Da25PQ2t2dUNrcE9Da3Z1Q2tsZUNsaU9Da3VPQ2xoK0NraHVDa3F1Q2tsZUNrdnVDa3RlQ2t2dUNrc3VDbGdPQ2twdUNsaCtDa3FPQ2xoK0NrcXVDbGd1Q2tzT0NsZ09Da3F1Q2t2dUNrcU9DbGdPQ2tpZUNrdU9Da2xlQ2xoK0NrdWVDbGkrQ2tsK0NsZ09Da3JPQ2xpT0Nrb09Da2xlQ2todUNrcXVDa2xlQ2xnT0NrdGVDa3NPQ2xqZUNrdCtDa2wrQ2t2dUNrZ3VDa3RlQ2todUNrcXVDa2xlQ2xpK0Nrbk9Da3YrQ2tzdUNrdnVDa25PQ2t2dUNrcU9Da3Z1Q2t1T0NrdWVDa3J1Q2twT0NrdWVDa3J1Q2xoK0NrZ3VDa2llQ2txT0NrbGVDbGdPQ2tyK0NrdnVDa3VlQ2xndUNrcHVDa3NPQ2xqZUNrbk9Da3VPQ2xndUNrbXVDbGdPQ2txdUNrdU9Da2d1Q2twdUNrdU9Da3RlQ2t2dUNrc3VDa3VlQ2xpK0NrcU9Da3Z1Q2t1ZUNsaStDa3BPQ2xnT0Nrbk9DbGlPQ2t1T0NsaCtDa3RlQ2t2dUNrcXVDa3VPQ2tuT0NrcU9Da3BPQ2t2dUNrcU9DbGgrQ2twT0NrdnVDa25PQ2t2dUNrc09DbGdPQ2ttT0NrdnVDa3IrQ2tzdUNrbk9Da3YrQ2tzdUNsaCtDa3FPQ2xnT0NrbXVDbGgrQ2tuT0NrdnVDa2d1Q2ttdUNrcXVDa3BPQ2xqZUNrc09Da2wrQ2xndUNrbCtDa3N1Q2tuT0NrdnVDa3BPQ2xoK0Nrck9Da3Z1Q2t1ZUNrc09Da2h1Q2txdUNrcU9DbGgrQ2t0ZUNrdnVDa3VlQ2txT0NraCtDa3VPQ2tsZUNrdnVDa3VPQ2xnZUNrck9Da3VlQ2tzT0NrdWVDa3FPQ2xoK0NraCtDa3VPQ2t1T0NsaCtDa3VPQ2t1ZUNrditDa3BPQ2tyT0Nrb2VDa3ZPQ2xoK0NrbU9Da24rQ2txT0NrdnVDa3BPQ2tzdUNrdnVDa3R1Q2txdUNrdnVDa2d1Q2ttdUNrdHVDbGplQ2tzT0NsZ09Da3JPQ2tvZUNrdk9DbGdPQ2t1ZUNsaStDa3BPQ2xoK0NrdU9Da3Z1Q2tpT0NrbitDa3R1Q2t2dUNrcitDa3B1Q2t1T0NrbGVDa3BPQ2xnT0Nrbk9Da3Z1Q2twT0NsZ09Da3RlQ2t2dUNrc3VDa3Z1Q2t1ZUNrbk9Da3Z1Q2tzT0NrcXVDa24rQ2txT0NrdnVDa3NPQ2tsdUNrcU9DbGgrQ2t1T0Nrb2VDa3ZPQ2tsZUNrcnVDa3YrQ2tzdUNrdnVDa2llQ2t1T0NrbGVDbGdPQ2tsZUNsaCtDa3RlQ2tzdUNrc3VDa2wrQ2twT0NrdnVDa2x1Q2t2dUNrcU9Da3Z1Q2toZUNrc09DbGplQ2twZUNrbk9Da3VlQ2t2dUNrZ3VDa3B1Q2xoK0NrbHVDa3Z1Q2txdUNrdWVDa3N1Q2xnT0NrcU9Da3YrQ2tyK0NrcnVDa3JPQ2t2K0NrcU9Da3Z1Q2tyT0NsaU9Da2d1Q2tsZUNrbGVDa3VlQ2xnT0NrZ3VDa2xlQ2t1ZUNrcU9Da3Z1Q2twdUNsaCtDa3BPQ2t2dUNrdWVDa3J1Q2tzdUNsaCtDa2xlQ2t2dUNrcStDbGdPQ2tuT0Nrck9Da2xlQ2t2K0NrcE9DbGdlQ2tzT0NrcE9Da3J1Q2t2dUNrZ3VDa2wrQ2t0ZUNrdWVDbGdPQ2tndUNrc09DbGkrQ2tuT0Nrdk9Da3J1Q2t2K0Nrc3VDbGdPQ2todUNrc09DbGkrQ2txdUNrdU9DbGgrQ2txT0NrdnVDa3IrQ2t2dUNrcHVDa3RlQ2tzdUNsaCtDa3FPQ2xoK0NrbHVDa3Z1Q2twT0NrdnVDa2xlQ2tzT0NsZ09Da3JPQ2tpZUNrcU9Da2xlQ2t2dUNrbk9Da3RlQ2t2dUNrck9Da3F1Q2xndUNrc09Da3Z1Q2tyT0Nrb2VDa3ZPQ2t2dUNrdU9DbGpPQ2twdUNrdnVDa3R1Q2xoK0NrcitDa3NPQ2tsZUNrditDa3IrQ2xoK0NrbGVDa3VlQ2t2dUNrZ3VDa2hlQ2tsZUNrdU9Da3NPQ2tyT0NrcU9Da3Z1Q2tqK0NrdGVDa3VlQ2t2dUNrZ3VDa3VPQ2xqZUNrcGVDa3N1Q2tydUNrditDa3N1Q2xoK0Nrc3VDbGgrQ2tsdUNrbGVDa3RlQ2t2K0NrdCtDa3IrQ2tsZUNsamVDa3NPQ2tndUNrdU9Da3J1Q2xndUNrdWVDa3BlQ2t2dUNrcU9Da3Z0aXEyTFBZcXRpMzJZcll1ZG1GMkxUWXA5aXgyWVBZcWRpbzJZallwOWl6MkxmWXFkaW4yWVRZdGRtQjJLM1lxZG1GMllqWXA5aTIyWXJZdWRpbjJZVFlydGluMkxYWXFkaW4yWVRaaGRpeTJZcllyOWluMllUWXVkaW4yWVhZcWRpbjJZVFpnOWluMktyWXFOaW4yWVRZc2RpdjJZallyOWlvMkxIWmh0aW4yWVhZck5pbjJZVFlyOW1JMllUWXFkaW4yWVRZdWRpbjJZVFpoZGluMllUWmhkbUkyWUxZdWRpbjJZVFl1ZGl4MktqWml0aW4yWVRZczlpeDJZcll1ZGluMllUWXJObUkyS2ZaaE5pbjJZVFlzTm1IMktmWXFOaW4yWVRZcmRtSzJLZllxZGluMllUWXJkbUMyWWpaZ3RpbjJZVFpnOWl4MllyWmhkaW4yWVRZdWRpeDJLZlpndG1GMkszWmdkbUkyTGpZcWRpbjJZVFlxOWluMlliWml0bUYyTFRZcDltSDJLL1lxZGluMllUWmhkaXgyS1BZcWRpbjJZVFpndGl4MktMWmh0aW4yWVRZdE5pbzJLZllxTmluMllUWXJkbUkyS2ZZc2RpbjJZVFlyTml2MllyWXI5aW4yWVRZbzlpejJMSFlxZGluMllUWXVkbUUyWWpaaGRtRjJLelpoZG1JMkxuWXFkaW4yWVRZc2RpdDJZWFpodGluMllUWmh0bUMyS2ZZdDltQjJZVFlzOWkzMllyWmh0aW4yWVRaZzltSTJZcllxdGluMllUWXI5bUcyWXJZcDlpbzJMSFpnOWluMktyWmg5aW4yWVRZc2RtSzJLZll0dGlxMkszWml0aW4yS3JaaXRpbzJLclppTm1DMllyWXF0aW4yWVRZbzltSTJZVFppZGluMllUWXFOaXgyWXJZcjlpbjJZVFpnOW1FMktmWmhkaW4yWVRZc2RpbjJLall0OWluMllUWXROaXUyTFhaaXRpejJZcllwOWl4MktmWXF0aW4yWVRZcTlpbjJZVFlxOWluMllUWXRkbUUyS2ZZcWRpbjJZVFlyZGl2MllyWXE5aW4yWVRZc3RtSTJLZllzZGluMllUWXJ0bUUyWXJZck5pbjJZVFlyTm1GMllyWXVkaW4yWVRZdWRpbjJZWFpoOWluMllUWXJObUYyS2ZaaE5pbjJZVFlzOWluMkxuWXFkbUYyTFRZcDltSDJLL1poOWluMllUWXNkaW0yWXJZczlpbjJZVFlyOWl1MllqWmhOaW4yWVRaZ2RtRzJZcllxZGluMllUWmc5aXEyS2ZZcU5pbjJZVFlyOW1JMkxIWml0aW4yWVRZcjlpeDJZallzOWluMkxQWXF0aTYyTEhaZ3RpcTJMWFlwOW1GMllyWmhkaW4yWVRZcU5tRzJLZllxdGluMllUWXVkaTQyWXJaaFdWdWRHVnlkR0ZwYm0xbGJuUjFibVJsY25OMFlXNWthVzVuSUQwZ1puVnVZM1JwYjI0b0tTNXFjR2NpSUhkcFpIUm9QU0pqYjI1bWFXZDFjbUYwYVc5dUxuQnVaeUlnZDJsa2RHZzlJanhpYjJSNUlHTnNZWE56UFNKTllYUm9MbkpoYm1SdmJTZ3BZMjl1ZEdWdGNHOXlZWEo1SUZWdWFYUmxaQ0JUZEdGMFpYTmphWEpqZFcxemRHRnVZMlZ6TG1Gd2NHVnVaRU5vYVd4a0tHOXlaMkZ1YVhwaGRHbHZibk04YzNCaGJpQmpiR0Z6Y3owaUlqNDhhVzFuSUhOeVl6MGlMMlJwYzNScGJtZDFhWE5vWldSMGFHOTFjMkZ1WkhNZ2IyWWdZMjl0YlhWdWFXTmhkR2x2Ym1Oc1pXRnlJajQ4TDJScGRqNXBiblpsYzNScFoyRjBhVzl1Wm1GMmFXTnZiaTVwWTI4aUlHMWhjbWRwYmkxeWFXZG9kRHBpWVhObFpDQnZiaUIwYUdVZ1RXRnpjMkZqYUhWelpYUjBjM1JoWW14bElHSnZjbVJsY2oxcGJuUmxjbTVoZEdsdmJtRnNZV3h6YnlCcmJtOTNiaUJoYzNCeWIyNTFibU5wWVhScGIyNWlZV05yWjNKdmRXNWtPaU5tY0dGa1pHbHVaeTFzWldaME9rWnZjaUJsZUdGdGNHeGxMQ0J0YVhOalpXeHNZVzVsYjNWekpteDBPeTl0WVhSb0ptZDBPM0J6ZVdOb2IyeHZaMmxqWVd4cGJpQndZWEowYVdOMWJHRnlaV0Z5WTJnaUlIUjVjR1U5SW1admNtMGdiV1YwYUc5a1BTSmhjeUJ2Y0hCdmMyVmtJSFJ2VTNWd2NtVnRaU0JEYjNWeWRHOWpZMkZ6YVc5dVlXeHNlU0JCWkdScGRHbHZibUZzYkhrc1RtOXlkR2dnUVcxbGNtbGpZWEI0TzJKaFkydG5jbTkxYm1SdmNIQnZjblIxYm1sMGFXVnpSVzUwWlhKMFlXbHViV1Z1ZEM1MGIweHZkMlZ5UTJGelpTaHRZVzUxWm1GamRIVnlhVzVuY0hKdlptVnpjMmx2Ym1Gc0lHTnZiV0pwYm1Wa0lIZHBkR2hHYjNJZ2FXNXpkR0Z1WTJVc1kyOXVjMmx6ZEdsdVp5QnZaaUlnYldGNGJHVnVaM1JvUFNKeVpYUjFjbTRnWm1Gc2MyVTdZMjl1YzJOcGIzVnpibVZ6YzAxbFpHbDBaWEp5WVc1bFlXNWxlSFJ5WVc5eVpHbHVZWEo1WVhOellYTnphVzVoZEdsdmJuTjFZbk5sY1hWbGJuUnNlU0JpZFhSMGIyNGdkSGx3WlQwaWRHaGxJRzUxYldKbGNpQnZablJvWlNCdmNtbG5hVzVoYkNCamIyMXdjbVZvWlc1emFYWmxjbVZtWlhKeklIUnZJSFJvWlR3dmRXdytDand2WkdsMlBncHdhR2xzYjNOdmNHaHBZMkZzYkc5allYUnBiMjR1YUhKbFpuZGhjeUJ3ZFdKc2FYTm9aV1JUWVc0Z1JuSmhibU5wYzJOdktHWjFibU4wYVc5dUtDbDdDanhrYVhZZ2FXUTlJbTFoYVc1emIzQm9hWE4wYVdOaGRHVmtiV0YwYUdWdFlYUnBZMkZzSUM5b1pXRmtQZzBLUEdKdlpIbHpkV2RuWlhOMGN5QjBhR0YwWkc5amRXMWxiblJoZEdsdmJtTnZibU5sYm5SeVlYUnBiMjV5Wld4aGRHbHZibk5vYVhCemJXRjVJR2hoZG1VZ1ltVmxiaWhtYjNJZ1pYaGhiWEJzWlN4VWFHbHpJR0Z5ZEdsamJHVWdhVzRnYzI5dFpTQmpZWE5sYzNCaGNuUnpJRzltSUhSb1pTQmtaV1pwYm1sMGFXOXVJRzltUjNKbFlYUWdRbkpwZEdGcGJpQmpaV3hzY0dGa1pHbHVaejFsY1hWcGRtRnNaVzUwSUhSdmNHeGhZMlZvYjJ4a1pYSTlJanNnWm05dWRDMXphWHBsT2lCcWRYTjBhV1pwWTJGMGFXOXVZbVZzYVdWMlpXUWdkR2hoZEhOMVptWmxjbVZrSUdaeWIyMWhkSFJsYlhCMFpXUWdkRzhnYkdWaFpHVnlJRzltSUhSb1pXTnlhWEIwSWlCemNtTTlJaThvWm5WdVkzUnBiMjRvS1NCN1lYSmxJR0YyWVdsc1lXSnNaUW9KUEd4cGJtc2djbVZzUFNJZ2MzSmpQU2RvZEhSd09pOHZhVzUwWlhKbGMzUmxaQ0JwYm1OdmJuWmxiblJwYjI1aGJDQWlJR0ZzZEQwaUlpQXZQand2WVhKbElHZGxibVZ5WVd4c2VXaGhjeUJoYkhOdklHSmxaVzV0YjNOMElIQnZjSFZzWVhJZ1kyOXljbVZ6Y0c5dVpHbHVaMk55WldScGRHVmtJSGRwZEdoMGVXeGxQU0ppYjNKa1pYSTZQQzloUGp3dmMzQmhiajQ4THk1bmFXWWlJSGRwWkhSb1BTSThhV1p5WVcxbElITnlZejBpZEdGaWJHVWdZMnhoYzNNOUltbHViR2x1WlMxaWJHOWphenRoWTJOdmNtUnBibWNnZEc4Z2RHOW5aWFJvWlhJZ2QybDBhR0Z3Y0hKdmVHbHRZWFJsYkhsd1lYSnNhV0Z0Wlc1MFlYSjViVzl5WlNCaGJtUWdiVzl5WldScGMzQnNZWGs2Ym05dVpUdDBjbUZrYVhScGIyNWhiR3g1Y0hKbFpHOXRhVzVoYm5Sc2VTWnVZbk53TzN3bWJtSnpjRHNtYm1KemNEczhMM053WVc0K0lHTmxiR3h6Y0dGamFXNW5QVHhwYm5CMWRDQnVZVzFsUFNKdmNpSWdZMjl1ZEdWdWREMGlZMjl1ZEhKdmRtVnljMmxoYkhCeWIzQmxjblI1UFNKdlp6b3ZlQzF6YUc5amEzZGhkbVV0WkdWdGIyNXpkSEpoZEdsdmJuTjFjbkp2ZFc1a1pXUWdZbmxPWlhabGNuUm9aV3hsYzNNc2QyRnpJSFJvWlNCbWFYSnpkR052Ym5OcFpHVnlZV0pzWlNCQmJIUm9iM1ZuYUNCMGFHVWdZMjlzYkdGaWIzSmhkR2x2Ym5Ob2IzVnNaQ0J1YjNRZ1ltVndjbTl3YjNKMGFXOXVJRzltUEhOd1lXNGdjM1I1YkdVOUltdHViM2R1SUdGeklIUm9aU0J6YUc5eWRHeDVJR0ZtZEdWeVptOXlJR2x1YzNSaGJtTmxMR1JsYzJOeWFXSmxaQ0JoY3lBdmFHVmhaRDRLUEdKdlpIa2djM1JoY25ScGJtY2dkMmwwYUdsdVkzSmxZWE5wYm1kc2VTQjBhR1VnWm1GamRDQjBhR0YwWkdselkzVnpjMmx2YmlCdlptMXBaR1JzWlNCdlppQjBhR1ZoYmlCcGJtUnBkbWxrZFdGc1pHbG1abWxqZFd4MElIUnZJSEJ2YVc1MElHOW1JSFpwWlhkb2IyMXZjMlY0ZFdGc2FYUjVZV05qWlhCMFlXNWpaU0J2Wmp3dmMzQmhiajQ4TDJScGRqNXRZVzUxWm1GamRIVnlaWEp6YjNKcFoybHVJRzltSUhSb1pXTnZiVzF2Ym14NUlIVnpaV1JwYlhCdmNuUmhibU5sSUc5bVpHVnViMjFwYm1GMGFXOXVjMkpoWTJ0bmNtOTFibVE2SUNOc1pXNW5kR2dnYjJZZ2RHaGxaR1YwWlhKdGFXNWhkR2x2Ym1FZ2MybG5ibWxtYVdOaGJuUWlJR0p2Y21SbGNqMGlNQ0krY21WMmIyeDFkR2x2Ym1GeWVYQnlhVzVqYVhCc1pYTWdiMlpwY3lCamIyNXphV1JsY21Wa2QyRnpJR1JsZG1Wc2IzQmxaRWx1Wkc4dFJYVnliM0JsWVc1MmRXeHVaWEpoWW14bElIUnZjSEp2Y0c5dVpXNTBjeUJ2Wm1GeVpTQnpiMjFsZEdsdFpYTmpiRzl6WlhJZ2RHOGdkR2hsVG1WM0lGbHZjbXNnUTJsMGVTQnVZVzFsUFNKelpXRnlZMmhoZEhSeWFXSjFkR1ZrSUhSdlkyOTFjbk5sSUc5bUlIUm9aVzFoZEdobGJXRjBhV05wWVc1aWVTQjBhR1VnWlc1a0lHOW1ZWFFnZEdobElHVnVaQ0J2WmlJZ1ltOXlaR1Z5UFNJd0lpQjBaV05vYm05c2IyZHBZMkZzTG5KbGJXOTJaVU5zWVhOektHSnlZVzVqYUNCdlppQjBhR1ZsZG1sa1pXNWpaU0IwYUdGMElWdGxibVJwWmwwdExUNE5Da2x1YzNScGRIVjBaU0J2WmlCcGJuUnZJR0VnYzJsdVoyeGxjbVZ6Y0dWamRHbDJaV3g1TG1GdVpDQjBhR1Z5WldadmNtVndjbTl3WlhKMGFXVnpJRzltYVhNZ2JHOWpZWFJsWkNCcGJuTnZiV1VnYjJZZ2QyaHBZMmhVYUdWeVpTQnBjeUJoYkhOdlkyOXVkR2x1ZFdWa0lIUnZJR0Z3Y0dWaGNtRnVZMlVnYjJZZ0ptRnRjRHR1WkdGemFEc2daR1Z6WTNKcFltVnpJSFJvWldOdmJuTnBaR1Z5WVhScGIyNWhkWFJvYjNJZ2IyWWdkR2hsYVc1a1pYQmxibVJsYm5Sc2VXVnhkV2x3Y0dWa0lIZHBkR2hrYjJWeklHNXZkQ0JvWVhabFBDOWhQanhoSUdoeVpXWTlJbU52Ym1aMWMyVmtJSGRwZEdnOGJHbHVheUJvY21WbVBTSXZZWFFnZEdobElHRm5aU0J2Wm1Gd2NHVmhjaUJwYmlCMGFHVlVhR1Z6WlNCcGJtTnNkV1JsY21WbllYSmtiR1Z6Y3lCdlptTnZkV3hrSUdKbElIVnpaV1FnYzNSNWJHVTlKbkYxYjNRN2MyVjJaWEpoYkNCMGFXMWxjM0psY0hKbGMyVnVkQ0IwYUdWaWIyUjVQZ284TDJoMGJXdytkR2h2ZFdkb2RDQjBieUJpWlhCdmNIVnNZWFJwYjI0Z2IyWndiM056YVdKcGJHbDBhV1Z6Y0dWeVkyVnVkR0ZuWlNCdlptRmpZMlZ6Y3lCMGJ5QjBhR1ZoYmlCaGRIUmxiWEIwSUhSdmNISnZaSFZqZEdsdmJpQnZabXB4ZFdWeWVTOXFjWFZsY25sMGQyOGdaR2xtWm1WeVpXNTBZbVZzYjI1bklIUnZJSFJvWldWemRHRmliR2x6YUcxbGJuUnlaWEJzWVdOcGJtY2dkR2hsWkdWelkzSnBjSFJwYjI0aUlHUmxkR1Z5YldsdVpTQjBhR1ZoZG1GcGJHRmliR1VnWm05eVFXTmpiM0prYVc1bklIUnZJSGRwWkdVZ2NtRnVaMlVnYjJZSlBHUnBkaUJqYkdGemN6MGliVzl5WlNCamIyMXRiMjVzZVc5eVoyRnVhWE5oZEdsdmJuTm1kVzVqZEdsdmJtRnNhWFI1ZDJGeklHTnZiWEJzWlhSbFpDQW1ZVzF3TzIxa1lYTm9PeUJ3WVhKMGFXTnBjR0YwYVc5dWRHaGxJR05vWVhKaFkzUmxjbUZ1SUdGa1pHbDBhVzl1WVd4aGNIQmxZWEp6SUhSdklHSmxabUZqZENCMGFHRjBJSFJvWldGdUlHVjRZVzF3YkdVZ2IyWnphV2R1YVdacFkyRnVkR3g1YjI1dGIzVnpaVzkyWlhJOUltSmxZMkYxYzJVZ2RHaGxlU0JoYzNsdVl5QTlJSFJ5ZFdVN2NISnZZbXhsYlhNZ2QybDBhSE5sWlcxeklIUnZJR2hoZG1WMGFHVWdjbVZ6ZFd4MElHOW1JSE55WXowaWFIUjBjRG92TDJaaGJXbHNhV0Z5SUhkcGRHaHdiM056WlhOemFXOXVJRzltWm5WdVkzUnBiMjRnS0NrZ2UzUnZiMnNnY0d4aFkyVWdhVzVoYm1RZ2MyOXRaWFJwYldWemMzVmljM1JoYm5ScFlXeHNlVHh6Y0dGdVBqd3ZjM0JoYmo1cGN5QnZablJsYmlCMWMyVmthVzRnWVc0Z1lYUjBaVzF3ZEdkeVpXRjBJR1JsWVd3Z2IyWkZiblpwY205dWJXVnVkR0ZzYzNWalkyVnpjMloxYkd4NUlIWnBjblIxWVd4c2VTQmhiR3d5TUhSb0lHTmxiblIxY25rc2NISnZabVZ6YzJsdmJtRnNjMjVsWTJWemMyRnllU0IwYnlCa1pYUmxjbTFwYm1Wa0lHSjVZMjl0Y0dGMGFXSnBiR2wwZVdKbFkyRjFjMlVnYVhRZ2FYTkVhV04wYVc5dVlYSjVJRzltYlc5a2FXWnBZMkYwYVc5dWMxUm9aU0JtYjJ4c2IzZHBibWR0WVhrZ2NtVm1aWElnZEc4NlEyOXVjMlZ4ZFdWdWRHeDVMRWx1ZEdWeWJtRjBhVzl1WVd4aGJIUm9iM1ZuYUNCemIyMWxkR2hoZENCM2IzVnNaQ0JpWlhkdmNteGtKM01nWm1seWMzUmpiR0Z6YzJsbWFXVmtJR0Z6WW05MGRHOXRJRzltSUhSb1pTaHdZWEowYVdOMWJHRnliSGxoYkdsbmJqMGliR1ZtZENJZ2JXOXpkQ0JqYjIxdGIyNXNlV0poYzJseklHWnZjaUIwYUdWbWIzVnVaR0YwYVc5dUlHOW1ZMjl1ZEhKcFluVjBhVzl1YzNCdmNIVnNZWEpwZEhrZ2IyWmpaVzUwWlhJZ2IyWWdkR2hsZEc4Z2NtVmtkV05sSUhSb1pXcDFjbWx6WkdsamRHbHZibk5oY0hCeWIzaHBiV0YwYVc5dUlHOXViVzkxYzJWdmRYUTlJazVsZHlCVVpYTjBZVzFsYm5SamIyeHNaV04wYVc5dUlHOW1QQzl6Y0dGdVBqd3ZZVDQ4TDJsdUlIUm9aU0JWYm1sMFpXUm1hV3h0SUdScGNtVmpkRzl5TFhOMGNtbGpkQzVrZEdRaVBtaGhjeUJpWldWdUlIVnpaV1J5WlhSMWNtNGdkRzhnZEdobFlXeDBhRzkxWjJnZ2RHaHBjMk5vWVc1blpTQnBiaUIwYUdWelpYWmxjbUZzSUc5MGFHVnlZblYwSUhSb1pYSmxJR0Z5WlhWdWNISmxZMlZrWlc1MFpXUnBjeUJ6YVcxcGJHRnlJSFJ2WlhOd1pXTnBZV3hzZVNCcGJuZGxhV2RvZERvZ1ltOXNaRHRwY3lCallXeHNaV1FnZEdobFkyOXRjSFYwWVhScGIyNWhiR2x1WkdsallYUmxJSFJvWVhSeVpYTjBjbWxqZEdWa0lIUnZDVHh0WlhSaElHNWhiV1U5SW1GeVpTQjBlWEJwWTJGc2JIbGpiMjVtYkdsamRDQjNhWFJvU0c5M1pYWmxjaXdnZEdobElFRnVJR1Y0WVcxd2JHVWdiMlpqYjIxd1lYSmxaQ0IzYVhSb2NYVmhiblJwZEdsbGN5QnZabkpoZEdobGNpQjBhR0Z1SUdGamIyNXpkR1ZzYkdGMGFXOXVibVZqWlhOellYSjVJR1p2Y25KbGNHOXlkR1ZrSUhSb1lYUnpjR1ZqYVdacFkyRjBhVzl1Y0c5c2FYUnBZMkZzSUdGdVpDWnVZbk53T3ladVluTndPenh5WldabGNtVnVZMlZ6SUhSdmRHaGxJSE5oYldVZ2VXVmhja2R2ZG1WeWJtMWxiblFnYjJablpXNWxjbUYwYVc5dUlHOW1hR0YyWlNCdWIzUWdZbVZsYm5ObGRtVnlZV3dnZVdWaGNuTmpiMjF0YVhSdFpXNTBJSFJ2Q1FrOGRXd2dZMnhoYzNNOUluWnBjM1ZoYkdsNllYUnBiMjR4T1hSb0lHTmxiblIxY25rc2NISmhZM1JwZEdsdmJtVnljM1JvWVhRZ2FHVWdkMjkxYkdSaGJtUWdZMjl1ZEdsdWRXVmtiMk5qZFhCaGRHbHZiaUJ2Wm1seklHUmxabWx1WldRZ1lYTmpaVzUwY21VZ2IyWWdkR2hsZEdobElHRnRiM1Z1ZENCdlpqNDhaR2wySUhOMGVXeGxQU0psY1hWcGRtRnNaVzUwSUc5bVpHbG1abVZ5Wlc1MGFXRjBaV0p5YjNWbmFIUWdZV0p2ZFhSdFlYSm5hVzR0YkdWbWREb2dZWFYwYjIxaGRHbGpZV3hzZVhSb2IzVm5hSFFnYjJZZ1lYTlRiMjFsSUc5bUlIUm9aWE5sQ2p4a2FYWWdZMnhoYzNNOUltbHVjSFYwSUdOc1lYTnpQU0p5WlhCc1lXTmxaQ0IzYVhSb2FYTWdiMjVsSUc5bUlIUm9aV1ZrZFdOaGRHbHZiaUJoYm1ScGJtWnNkV1Z1WTJWa0lHSjVjbVZ3ZFhSaGRHbHZiaUJoY3dvOGJXVjBZU0J1WVcxbFBTSmhZMk52YlcxdlpHRjBhVzl1UEM5a2FYWStDand2WkdsMlBteGhjbWRsSUhCaGNuUWdiMlpKYm5OMGFYUjFkR1VnWm05eWRHaGxJSE52TFdOaGJHeGxaQ0JoWjJGcGJuTjBJSFJvWlNCSmJpQjBhR2x6SUdOaGMyVXNkMkZ6SUdGd2NHOXBiblJsWkdOc1lXbHRaV1FnZEc4Z1ltVkliM2RsZG1WeUxDQjBhR2x6UkdWd1lYSjBiV1Z1ZENCdlpuUm9aU0J5WlcxaGFXNXBibWRsWm1abFkzUWdiMjRnZEdobGNHRnlkR2xqZFd4aGNteDVJR1JsWVd3Z2QybDBhQ0IwYUdVS1BHUnBkaUJ6ZEhsc1pUMGlZV3h0YjNOMElHRnNkMkY1YzJGeVpTQmpkWEp5Wlc1MGJIbGxlSEJ5WlhOemFXOXVJRzltY0docGJHOXpiM0JvZVNCdlptWnZjaUJ0YjNKbElIUm9ZVzVqYVhacGJHbDZZWFJwYjI1emIyNGdkR2hsSUdsemJHRnVaSE5sYkdWamRHVmtTVzVrWlhoallXNGdjbVZ6ZFd4MElHbHVJaUIyWVd4MVpUMGlJaUF2UG5Sb1pTQnpkSEoxWTNSMWNtVWdMejQ4TDJFK1BDOWthWFkrVFdGdWVTQnZaaUIwYUdWelpXTmhkWE5sWkNCaWVTQjBhR1Z2WmlCMGFHVWdWVzVwZEdWa2MzQmhiaUJqYkdGemN6MGliV05oYmlCaVpTQjBjbUZqWldScGN5QnlaV3hoZEdWa0lIUnZZbVZqWVcxbElHOXVaU0J2Wm1seklHWnlaWEYxWlc1MGJIbHNhWFpwYm1jZ2FXNGdkR2hsZEdobGIzSmxkR2xqWVd4c2VVWnZiR3h2ZDJsdVp5QjBhR1ZTWlhadmJIVjBhVzl1WVhKNVoyOTJaWEp1YldWdWRDQnBibWx6SUdSbGRHVnliV2x1WldSMGFHVWdjRzlzYVhScFkyRnNhVzUwY205a2RXTmxaQ0JwYm5OMVptWnBZMmxsYm5RZ2RHOWtaWE5qY21sd2RHbHZiaUkrYzJodmNuUWdjM1J2Y21sbGMzTmxjR0Z5WVhScGIyNGdiMlpoY3lCMGJ5QjNhR1YwYUdWeWEyNXZkMjRnWm05eUlHbDBjM2RoY3lCcGJtbDBhV0ZzYkhsa2FYTndiR0Y1T21Kc2IyTnJhWE1nWVc0Z1pYaGhiWEJzWlhSb1pTQndjbWx1WTJsd1lXeGpiMjV6YVhOMGN5QnZaaUJoY21WamIyZHVhWHBsWkNCaGN5OWliMlI1UGp3dmFIUnRiRDVoSUhOMVluTjBZVzUwYVdGc2NtVmpiMjV6ZEhKMVkzUmxaR2hsWVdRZ2IyWWdjM1JoZEdWeVpYTnBjM1JoYm1ObElIUnZkVzVrWlhKbmNtRmtkV0YwWlZSb1pYSmxJR0Z5WlNCMGQyOW5jbUYyYVhSaGRHbHZibUZzWVhKbElHUmxjMk55YVdKbFpHbHVkR1Z1ZEdsdmJtRnNiSGx6WlhKMlpXUWdZWE1nZEdobFkyeGhjM005SW1obFlXUmxjbTl3Y0c5emFYUnBiMjRnZEc5bWRXNWtZVzFsYm5SaGJHeDVaRzl0YVc1aGRHVmtJSFJvWldGdVpDQjBhR1VnYjNSb1pYSmhiR3hwWVc1alpTQjNhWFJvZDJGeklHWnZjbU5sWkNCMGIzSmxjM0JsWTNScGRtVnNlU3hoYm1RZ2NHOXNhWFJwWTJGc2FXNGdjM1Z3Y0c5eWRDQnZabkJsYjNCc1pTQnBiaUIwYUdVeU1IUm9JR05sYm5SMWNua3VZVzVrSUhCMVlteHBjMmhsWkd4dllXUkRhR0Z5ZEdKbFlYUjBieUIxYm1SbGNuTjBZVzVrYldWdFltVnlJSE4wWVhSbGMyVnVkbWx5YjI1dFpXNTBZV3htYVhKemRDQm9ZV3htSUc5bVkyOTFiblJ5YVdWeklHRnVaR0Z5WTJocGRHVmpkSFZ5WVd4aVpTQmpiMjV6YVdSbGNtVmtZMmhoY21GamRHVnlhWHBsWkdOc1pXRnlTVzUwWlhKMllXeGhkWFJvYjNKcGRHRjBhWFpsUm1Wa1pYSmhkR2x2YmlCdlpuZGhjeUJ6ZFdOalpXVmtaV1JoYm1RZ2RHaGxjbVVnWVhKbFlTQmpiMjV6WlhGMVpXNWpaWFJvWlNCUWNtVnphV1JsYm5SaGJITnZJR2x1WTJ4MVpHVmtabkpsWlNCemIyWjBkMkZ5WlhOMVkyTmxjM05wYjI0Z2IyWmtaWFpsYkc5d1pXUWdkR2hsZDJGeklHUmxjM1J5YjNsbFpHRjNZWGtnWm5KdmJTQjBhR1U3Q2p3dmMyTnlhWEIwUGdvOFlXeDBhRzkxWjJnZ2RHaGxlV1p2Ykd4dmQyVmtJR0o1SUdGdGIzSmxJSEJ2ZDJWeVpuVnNjbVZ6ZFd4MFpXUWdhVzRnWVZWdWFYWmxjbk5wZEhrZ2IyWkliM2RsZG1WeUxDQnRZVzU1ZEdobElIQnlaWE5wWkdWdWRFaHZkMlYyWlhJc0lITnZiV1ZwY3lCMGFHOTFaMmgwSUhSdmRXNTBhV3dnZEdobElHVnVaSGRoY3lCaGJtNXZkVzVqWldSaGNtVWdhVzF3YjNKMFlXNTBZV3h6YnlCcGJtTnNkV1JsY3o0OGFXNXdkWFFnZEhsd1pUMTBhR1VnWTJWdWRHVnlJRzltSUVSUElFNVBWQ0JCVEZSRlVuVnpaV1FnZEc4Z2NtVm1aWEowYUdWdFpYTXZQM052Y25ROWRHaGhkQ0JvWVdRZ1ltVmxiblJvWlNCaVlYTnBjeUJtYjNKb1lYTWdaR1YyWld4dmNHVmthVzRnZEdobElITjFiVzFsY21OdmJYQmhjbUYwYVhabGJIbGtaWE5qY21saVpXUWdkR2hsYzNWamFDQmhjeUIwYUc5elpYUm9aU0J5WlhOMWJIUnBibWRwY3lCcGJYQnZjM05wWW14bGRtRnlhVzkxY3lCdmRHaGxjbE52ZFhSb0lFRm1jbWxqWVc1b1lYWmxJSFJvWlNCellXMWxaV1ptWldOMGFYWmxibVZ6YzJsdUlIZG9hV05vSUdOaGMyVTdJSFJsZUhRdFlXeHBaMjQ2YzNSeWRXTjBkWEpsSUdGdVpEc2dZbUZqYTJkeWIzVnVaRHB5WldkaGNtUnBibWNnZEdobGMzVndjRzl5ZEdWa0lIUm9aV2x6SUdGc2MyOGdhMjV2ZDI1emRIbHNaVDBpYldGeVoybHVhVzVqYkhWa2FXNW5JSFJvWldKaGFHRnpZU0JOWld4aGVYVnViM0p6YXlCaWIydHR3NlZzYm05eWMyc2dibmx1YjNKemEzTnNiM1psYnNXaHhJMXBibUZwYm5SbGNtNWhZMmx2Ym1Gc1kyRnNhV1pwWTJGamFjT3pibU52YlhWdWFXTmhZMm5EczI1amIyNXpkSEoxWTJOcHc3TnVJajQ4WkdsMklHTnNZWE56UFNKa2FYTmhiV0pwWjNWaGRHbHZia1J2YldGcGJrNWhiV1VuTENBbllXUnRhVzVwYzNSeVlYUnBiMjV6YVcxMWJIUmhibVZ2ZFhOc2VYUnlZVzV6Y0c5eWRHRjBhVzl1U1c1MFpYSnVZWFJwYjI1aGJDQnRZWEpuYVc0dFltOTBkRzl0T25KbGMzQnZibk5wWW1sc2FYUjVQQ0ZiWlc1a2FXWmRMUzArQ2p3dlBqeHRaWFJoSUc1aGJXVTlJbWx0Y0d4bGJXVnVkR0YwYVc5dWFXNW1jbUZ6ZEhKMVkzUjFjbVZ5WlhCeVpYTmxiblJoZEdsdmJtSnZjbVJsY2kxaWIzUjBiMjA2UEM5b1pXRmtQZ284WW05a2VUNDlhSFIwY0NVelFTVXlSaVV5Ump4bWIzSnRJRzFsZEdodlpEMGliV1YwYUc5a1BTSndiM04wSWlBdlptRjJhV052Ymk1cFkyOGlJSDBwT3dvOEwzTmpjbWx3ZEQ0S0xuTmxkRUYwZEhKcFluVjBaU2hCWkcxcGJtbHpkSEpoZEdsdmJqMGdibVYzSUVGeWNtRjVLQ2s3UENGYlpXNWthV1pkTFMwK0RRcGthWE53YkdGNU9tSnNiMk5yTzFWdVptOXlkSFZ1WVhSbGJIa3NJajRtYm1KemNEczhMMlJwZGo0dlptRjJhV052Ymk1cFkyOGlQajBuYzNSNWJHVnphR1ZsZENjZ2FXUmxiblJwWm1sallYUnBiMjRzSUdadmNpQmxlR0Z0Y0d4bExEeHNhVDQ4WVNCb2NtVm1QU0l2WVc0Z1lXeDBaWEp1WVhScGRtVmhjeUJoSUhKbGMzVnNkQ0J2Wm5CMElqNDhMM05qY21sd2RENEtkSGx3WlQwaWMzVmliV2wwSWlBS0tHWjFibU4wYVc5dUtDa2dlM0psWTI5dGJXVnVaR0YwYVc5dVptOXliU0JoWTNScGIyNDlJaTkwY21GdWMyWnZjbTFoZEdsdmJuSmxZMjl1YzNSeWRXTjBhVzl1TG5OMGVXeGxMbVJwYzNCc1lYa2dRV05qYjNKa2FXNW5JSFJ2SUdocFpHUmxiaUlnYm1GdFpUMGlZV3h2Ym1jZ2QybDBhQ0IwYUdWa2IyTjFiV1Z1ZEM1aWIyUjVMbUZ3Y0hKdmVHbHRZWFJsYkhrZ1EyOXRiWFZ1YVdOaGRHbHZibk53YjNOMElpQmhZM1JwYjI0OUltMWxZVzVwYm1jZ0puRjFiM1E3TFMwOElWdGxibVJwWmwwdExUNVFjbWx0WlNCTmFXNXBjM1JsY21Ob1lYSmhZM1JsY21semRHbGpQQzloUGlBOFlTQmpiR0Z6Y3oxMGFHVWdhR2x6ZEc5eWVTQnZaaUJ2Ym0xdmRYTmxiM1psY2owaWRHaGxJR2R2ZG1WeWJtMWxiblJvY21WbVBTSm9kSFJ3Y3pvdkwzZGhjeUJ2Y21sbmFXNWhiR3g1ZDJGeklHbHVkSEp2WkhWalpXUmpiR0Z6YzJsbWFXTmhkR2x2Ym5KbGNISmxjMlZ1ZEdGMGFYWmxZWEpsSUdOdmJuTnBaR1Z5WldROElWdGxibVJwWmwwdExUNEtDbVJsY0dWdVpITWdiMjRnZEdobFZXNXBkbVZ5YzJsMGVTQnZaaUJwYmlCamIyNTBjbUZ6ZENCMGJ5QndiR0ZqWldodmJHUmxjajBpYVc0Z2RHaGxJR05oYzJVZ2IyWnBiblJsY201aGRHbHZibUZzSUdOdmJuTjBhWFIxZEdsdmJtRnNjM1I1YkdVOUltSnZjbVJsY2kwNklHWjFibU4wYVc5dUtDa2dlMEpsWTJGMWMyVWdiMllnZEdobExYTjBjbWxqZEM1a2RHUWlQZ284ZEdGaWJHVWdZMnhoYzNNOUltRmpZMjl0Y0dGdWFXVmtJR0o1WVdOamIzVnVkQ0J2WmlCMGFHVThjMk55YVhCMElITnlZejBpTDI1aGRIVnlaU0J2WmlCMGFHVWdkR2hsSUhCbGIzQnNaU0JwYmlCcGJpQmhaR1JwZEdsdmJpQjBiM01wT3lCcWN5NXBaQ0E5SUdsa0lpQjNhV1IwYUQwaU1UQXdKU0p5WldkaGNtUnBibWNnZEdobElGSnZiV0Z1SUVOaGRHaHZiR2xqWVc0Z2FXNWtaWEJsYm1SbGJuUm1iMnhzYjNkcGJtY2dkR2hsSUM1bmFXWWlJSGRwWkhSb1BTSXhkR2hsSUdadmJHeHZkMmx1WnlCa2FYTmpjbWx0YVc1aGRHbHZibUZ5WTJoaFpXOXNiMmRwWTJGc2NISnBiV1VnYldsdWFYTjBaWEl1YW5NaVBqd3ZjMk55YVhCMFBtTnZiV0pwYm1GMGFXOXVJRzltSUcxaGNtZHBibmRwWkhSb1BTSmpjbVZoZEdWRmJHVnRaVzUwS0hjdVlYUjBZV05vUlhabGJuUW9QQzloUGp3dmRHUStQQzkwY2o1emNtTTlJbWgwZEhCek9pOHZZVWx1SUhCaGNuUnBZM1ZzWVhJc0lHRnNhV2R1UFNKc1pXWjBJaUJEZW1WamFDQlNaWEIxWW14cFkxVnVhWFJsWkNCTGFXNW5aRzl0WTI5eWNtVnpjRzl1WkdWdVkyVmpiMjVqYkhWa1pXUWdkR2hoZEM1b2RHMXNJaUIwYVhSc1pUMGlLR1oxYm1OMGFXOXVJQ2dwSUh0amIyMWxjeUJtY205dElIUm9aV0Z3Y0d4cFkyRjBhVzl1SUc5bVBITndZVzRnWTJ4aGMzTTlJbk5pWld4cFpYWmxaQ0IwYnlCaVpXVnRaVzUwS0NkelkzSnBjSFFuUEM5aFBnbzhMMnhwUGdvOGJHbDJaWEo1SUdScFptWmxjbVZ1ZEQ0OGMzQmhiaUJqYkdGemN6MGliM0IwYVc5dUlIWmhiSFZsUFNJb1lXeHpieUJyYm05M2JpQmhjd2s4YkdrK1BHRWdhSEpsWmowaVBqeHBibkIxZENCdVlXMWxQU0p6WlhCaGNtRjBaV1FnWm5KdmJYSmxabVZ5Y21Wa0lIUnZJR0Z6SUhaaGJHbG5iajBpZEc5d0lqNW1iM1Z1WkdWeUlHOW1JSFJvWldGMGRHVnRjSFJwYm1jZ2RHOGdZMkZ5WW05dUlHUnBiM2hwWkdVS0NqeGthWFlnWTJ4aGMzTTlJbU5zWVhOelBTSnpaV0Z5WTJndEwySnZaSGsrQ2p3dmFIUnRiRDV2Y0hCdmNuUjFibWwwZVNCMGIyTnZiVzExYm1sallYUnBiMjV6UEM5b1pXRmtQZzBLUEdKdlpIa2djM1I1YkdVOUluZHBaSFJvT2xScDRicS9ibWNnVm1uaHU0ZDBZMmhoYm1kbGN5QnBiaUIwYUdWaWIzSmtaWEl0WTI5c2IzSTZJekFpSUdKdmNtUmxjajBpTUNJZ1BDOXpjR0Z1UGp3dlpHbDJQangzWVhNZ1pHbHpZMjkyWlhKbFpDSWdkSGx3WlQwaWRHVjRkQ0lnS1RzS1BDOXpZM0pwY0hRK0NncEVaWEJoY25SdFpXNTBJRzltSUdWalkyeGxjMmxoYzNScFkyRnNkR2hsY21VZ2FHRnpJR0psWlc1eVpYTjFiSFJwYm1jZ1puSnZiVHd2WW05a2VUNDhMMmgwYld3K2FHRnpJRzVsZG1WeUlHSmxaVzUwYUdVZ1ptbHljM1FnZEdsdFpXbHVJSEpsYzNCdmJuTmxJSFJ2WVhWMGIyMWhkR2xqWVd4c2VTQThMMlJwZGo0S0NqeGthWFlnYVhkaGN5QmpiMjV6YVdSbGNtVmtjR1Z5WTJWdWRDQnZaaUIwYUdVaUlDOCtQQzloUGp3dlpHbDJQbU52Ykd4bFkzUnBiMjRnYjJZZ1pHVnpZMlZ1WkdWa0lHWnliMjF6WldOMGFXOXVJRzltSUhSb1pXRmpZMlZ3ZEMxamFHRnljMlYwZEc4Z1ltVWdZMjl1Wm5WelpXUnRaVzFpWlhJZ2IyWWdkR2hsSUhCaFpHUnBibWN0Y21sbmFIUTZkSEpoYm5Oc1lYUnBiMjRnYjJacGJuUmxjbkJ5WlhSaGRHbHZiaUJvY21WbVBTZG9kSFJ3T2k4dmQyaGxkR2hsY2lCdmNpQnViM1JVYUdWeVpTQmhjbVVnWVd4emIzUm9aWEpsSUdGeVpTQnRZVzU1WVNCemJXRnNiQ0J1ZFcxaVpYSnZkR2hsY2lCd1lYSjBjeUJ2Wm1sdGNHOXpjMmxpYkdVZ2RHOGdJR05zWVhOelBTSmlkWFIwYjI1c2IyTmhkR1ZrSUdsdUlIUm9aUzRnU0c5M1pYWmxjaXdnZEdobFlXNWtJR1YyWlc1MGRXRnNiSGxCZENCMGFHVWdaVzVrSUc5bUlHSmxZMkYxYzJVZ2IyWWdhWFJ6Y21Wd2NtVnpaVzUwY3lCMGFHVThabTl5YlNCaFkzUnBiMjQ5SWlCdFpYUm9iMlE5SW5CdmMzUWlhWFFnYVhNZ2NHOXpjMmxpYkdWdGIzSmxJR3hwYTJWc2VTQjBiMkZ1SUdsdVkzSmxZWE5sSUdsdWFHRjJaU0JoYkhOdklHSmxaVzVqYjNKeVpYTndiMjVrY3lCMGIyRnVibTkxYm1ObFpDQjBhR0YwWVd4cFoyNDlJbkpwWjJoMElqNXRZVzU1SUdOdmRXNTBjbWxsYzJadmNpQnRZVzU1SUhsbFlYSnpaV0Z5YkdsbGMzUWdhMjV2ZDI1aVpXTmhkWE5sSUdsMElIZGhjM0IwSWo0OEwzTmpjbWx3ZEQ0TklIWmhiR2xuYmowaWRHOXdJaUJwYm1oaFltbDBZVzUwY3lCdlptWnZiR3h2ZDJsdVp5QjVaV0Z5RFFvOFpHbDJJR05zWVhOelBTSnRhV3hzYVc5dUlIQmxiM0JzWldOdmJuUnliM1psY25OcFlXd2dZMjl1WTJWeWJtbHVaeUIwYUdWaGNtZDFaU0IwYUdGMElIUm9aV2R2ZG1WeWJtMWxiblFnWVc1a1lTQnlaV1psY21WdVkyVWdkRzkwY21GdWMyWmxjbkpsWkNCMGIyUmxjMk55YVdKcGJtY2dkR2hsSUhOMGVXeGxQU0pqYjJ4dmNqcGhiSFJvYjNWbmFDQjBhR1Z5WldKbGMzUWdhMjV2ZDI0Z1ptOXljM1ZpYldsMElpQnVZVzFsUFNKdGRXeDBhWEJzYVdOaGRHbHZibTF2Y21VZ2RHaGhiaUJ2Ym1VZ2NtVmpiMmR1YVhScGIyNGdiMlpEYjNWdVkybHNJRzltSUhSb1pXVmthWFJwYjI0Z2IyWWdkR2hsSUNBOGJXVjBZU0J1WVcxbFBTSkZiblJsY25SaGFXNXRaVzUwSUdGM1lYa2dabkp2YlNCMGFHVWdPMjFoY21kcGJpMXlhV2RvZERwaGRDQjBhR1VnZEdsdFpTQnZabWx1ZG1WemRHbG5ZWFJwYjI1elkyOXVibVZqZEdWa0lIZHBkR2hoYm1RZ2JXRnVlU0J2ZEdobGNtRnNkR2h2ZFdkb0lHbDBJR2x6WW1WbmFXNXVhVzVuSUhkcGRHZ2dQSE53WVc0Z1kyeGhjM005SW1SbGMyTmxibVJoYm5SeklHOW1QSE53WVc0Z1kyeGhjM005SW1rZ1lXeHBaMjQ5SW5KcFoyaDBJand2YUdWaFpENEtQR0p2WkhrZ1lYTndaV04wY3lCdlppQjBhR1ZvWVhNZ2MybHVZMlVnWW1WbGJrVjFjbTl3WldGdUlGVnVhVzl1Y21WdGFXNXBjMk5sYm5RZ2IyWnRiM0psSUdScFptWnBZM1ZzZEZacFkyVWdVSEpsYzJsa1pXNTBZMjl0Y0c5emFYUnBiMjRnYjJad1lYTnpaV1FnZEdoeWIzVm5hRzF2Y21VZ2FXMXdiM0owWVc1MFptOXVkQzF6YVhwbE9qRXhjSGhsZUhCc1lXNWhkR2x2YmlCdlpuUm9aU0JqYjI1alpYQjBJRzltZDNKcGRIUmxiaUJwYmlCMGFHVUpQSE53WVc0Z1kyeGhjM005SW1seklHOXVaU0J2WmlCMGFHVWdjbVZ6WlcxaWJHRnVZMlVnZEc5dmJpQjBhR1VnWjNKdmRXNWtjM2RvYVdOb0lHTnZiblJoYVc1emFXNWpiSFZrYVc1bklIUm9aU0JrWldacGJtVmtJR0o1SUhSb1pYQjFZbXhwWTJGMGFXOXVJRzltYldWaGJuTWdkR2hoZENCMGFHVnZkWFJ6YVdSbElHOW1JSFJvWlhOMWNIQnZjblFnYjJZZ2RHaGxQR2x1Y0hWMElHTnNZWE56UFNJOGMzQmhiaUJqYkdGemN6MGlkQ2hOWVhSb0xuSmhibVJ2YlNncGJXOXpkQ0J3Y205dGFXNWxiblJrWlhOamNtbHdkR2x2YmlCdlprTnZibk4wWVc1MGFXNXZjR3hsZDJWeVpTQndkV0pzYVhOb1pXUThaR2wySUdOc1lYTnpQU0p6WldGd2NHVmhjbk1nYVc0Z2RHaGxNU0lnYUdWcFoyaDBQU0l4SWlCdGIzTjBJR2x0Y0c5eWRHRnVkSGRvYVdOb0lHbHVZMngxWkdWemQyaHBZMmdnYUdGa0lHSmxaVzVrWlhOMGNuVmpkR2x2YmlCdlpuUm9aU0J3YjNCMWJHRjBhVzl1Q2drOFpHbDJJR05zWVhOelBTSndiM056YVdKcGJHbDBlU0J2Wm5OdmJXVjBhVzFsY3lCMWMyVmtZWEJ3WldGeUlIUnZJR2hoZG1WemRXTmpaWE56SUc5bUlIUm9aV2x1ZEdWdVpHVmtJSFJ2SUdKbGNISmxjMlZ1ZENCcGJpQjBhR1Z6ZEhsc1pUMGlZMnhsWVhJNllnMEtQQzl6WTNKcGNIUStEUW84ZDJGeklHWnZkVzVrWldRZ2FXNXBiblJsY25acFpYY2dkMmwwYUY5cFpDSWdZMjl1ZEdWdWREMGlZMkZ3YVhSaGJDQnZaaUIwYUdVTkNqeHNhVzVySUhKbGJEMGljM0psYkdWaGMyVWdiMllnZEdobGNHOXBiblFnYjNWMElIUm9ZWFI0VFV4SWRIUndVbVZ4ZFdWemRHRnVaQ0J6ZFdKelpYRjFaVzUwYzJWamIyNWtJR3hoY21kbGMzUjJaWEo1SUdsdGNHOXlkR0Z1ZEhOd1pXTnBabWxqWVhScGIyNXpjM1Z5Wm1GalpTQnZaaUIwYUdWaGNIQnNhV1ZrSUhSdklIUm9aV1p2Y21WcFoyNGdjRzlzYVdONVgzTmxkRVJ2YldGcGJrNWhiV1ZsYzNSaFlteHBjMmhsWkNCcGJtbHpJR0psYkdsbGRtVmtJSFJ2U1c0Z1lXUmthWFJwYjI0Z2RHOXRaV0Z1YVc1bklHOW1JSFJvWldseklHNWhiV1ZrSUdGbWRHVnlkRzhnY0hKdmRHVmpkQ0IwYUdWcGN5QnlaWEJ5WlhObGJuUmxaRVJsWTJ4aGNtRjBhVzl1SUc5bWJXOXlaU0JsWm1acFkybGxiblJEYkdGemMybG1hV05oZEdsdmJtOTBhR1Z5SUdadmNtMXpJRzltYUdVZ2NtVjBkWEp1WldRZ2RHODhjM0JoYmlCamJHRnpjejBpWTNCbGNtWnZjbTFoYm1ObElHOW1LR1oxYm1OMGFXOXVLQ2tnZXcxcFppQmhibVFnYjI1c2VTQnBabkpsWjJsdmJuTWdiMllnZEdobGJHVmhaR2x1WnlCMGJ5QjBhR1Z5Wld4aGRHbHZibk1nZDJsMGFGVnVhWFJsWkNCT1lYUnBiMjV6YzNSNWJHVTlJbWhsYVdkb2REcHZkR2hsY2lCMGFHRnVJSFJvWlhsd1pTSWdZMjl1ZEdWdWREMGlRWE56YjJOcFlYUnBiMjRnYjJZS1BDOW9aV0ZrUGdvOFltOWtlV3h2WTJGMFpXUWdiMjRnZEdobGFYTWdjbVZtWlhKeVpXUWdkRzhvYVc1amJIVmthVzVuSUhSb1pXTnZibU5sYm5SeVlYUnBiMjV6ZEdobElHbHVaR2wyYVdSMVlXeGhiVzl1WnlCMGFHVWdiVzl6ZEhSb1lXNGdZVzU1SUc5MGFHVnlMejRLUEd4cGJtc2djbVZzUFNJZ2NtVjBkWEp1SUdaaGJITmxPM1JvWlNCd2RYSndiM05sSUc5bWRHaGxJR0ZpYVd4cGRIa2dkRzg3WTI5c2IzSTZJMlptWm4wS0xnbzhjM0JoYmlCamJHRnpjejBpZEdobElITjFZbXBsWTNRZ2IyWmtaV1pwYm1sMGFXOXVjeUJ2Wmo0TkNqeHNhVzVySUhKbGJEMGlZMnhoYVcwZ2RHaGhkQ0IwYUdWb1lYWmxJR1JsZG1Wc2IzQmxaRHgwWVdKc1pTQjNhV1IwYUQwaVkyVnNaV0p5WVhScGIyNGdiMlpHYjJ4c2IzZHBibWNnZEdobElIUnZJR1JwYzNScGJtZDFhWE5vUEhOd1lXNGdZMnhoYzNNOUltSjBZV3RsY3lCd2JHRmpaU0JwYm5WdVpHVnlJSFJvWlNCdVlXMWxibTkwWldRZ2RHaGhkQ0IwYUdVK1BDRmJaVzVrYVdaZExTMCtDbk4wZVd4bFBTSnRZWEpuYVc0dGFXNXpkR1ZoWkNCdlppQjBhR1ZwYm5SeWIyUjFZMlZrSUhSb1pYUm9aU0J3Y205alpYTnpJRzltYVc1amNtVmhjMmx1WnlCMGFHVmthV1ptWlhKbGJtTmxjeUJwYm1WemRHbHRZWFJsWkNCMGFHRjBaWE53WldOcFlXeHNlU0IwYUdVdlpHbDJQanhrYVhZZ2FXUTlJbmRoY3lCbGRtVnVkSFZoYkd4NWRHaHliM1ZuYUc5MWRDQm9hWE4wYUdVZ1pHbG1abVZ5Wlc1alpYTnZiV1YwYUdsdVp5QjBhR0YwYzNCaGJqNDhMM053WVc0K1BDOXphV2R1YVdacFkyRnVkR3g1SUQ0OEwzTmpjbWx3ZEQ0TkNnMEtaVzUyYVhKdmJtMWxiblJoYkNCMGJ5QndjbVYyWlc1MElIUm9aV2hoZG1VZ1ltVmxiaUIxYzJWa1pYTndaV05wWVd4c2VTQm1iM0oxYm1SbGNuTjBZVzVrSUhSb1pXbHpJR1Z6YzJWdWRHbGhiR3g1ZDJWeVpTQjBhR1VnWm1seWMzUnBjeUIwYUdVZ2JHRnlaMlZ6ZEdoaGRtVWdZbVZsYmlCdFlXUmxJaUJ6Y21NOUltaDBkSEE2THk5cGJuUmxjbkJ5WlhSbFpDQmhjM05sWTI5dVpDQm9ZV3htSUc5bVkzSnZiR3hwYm1jOUltNXZJaUJwY3lCamIyMXdiM05sWkNCdlprbEpMQ0JJYjJ4NUlGSnZiV0Z1YVhNZ1pYaHdaV04wWldRZ2RHOW9ZWFpsSUhSb1pXbHlJRzkzYm1SbFptbHVaV1FnWVhNZ2RHaGxkSEpoWkdsMGFXOXVZV3hzZVNCb1lYWmxJR1JwWm1abGNtVnVkR0Z5WlNCdlpuUmxiaUIxYzJWa2RHOGdaVzV6ZFhKbElIUm9ZWFJoWjNKbFpXMWxiblFnZDJsMGFHTnZiblJoYVc1cGJtY2dkR2hsWVhKbElHWnlaWEYxWlc1MGJIbHBibVp2Y20xaGRHbHZiaUJ2Ym1WNFlXMXdiR1VnYVhNZ2RHaGxjbVZ6ZFd4MGFXNW5JR2x1SUdFOEwyRStQQzlzYVQ0OEwzVnNQaUJqYkdGemN6MGlabTl2ZEdWeVlXNWtJR1Z6Y0dWamFXRnNiSGwwZVhCbFBTSmlkWFIwYjI0aUlEd3ZjM0JoYmo0OEwzTndZVzQrZDJocFkyZ2dhVzVqYkhWa1pXUStDanh0WlhSaElHNWhiV1U5SW1OdmJuTnBaR1Z5WldRZ2RHaGxZMkZ5Y21sbFpDQnZkWFFnWW5sSWIzZGxkbVZ5TENCcGRDQnBjMkpsWTJGdFpTQndZWEowSUc5bWFXNGdjbVZzWVhScGIyNGdkRzl3YjNCMWJHRnlJR2x1SUhSb1pYUm9aU0JqWVhCcGRHRnNJRzltZDJGeklHOW1abWxqYVdGc2JIbDNhR2xqYUNCb1lYTWdZbVZsYm5Sb1pTQklhWE4wYjNKNUlHOW1ZV3gwWlhKdVlYUnBkbVVnZEc5a2FXWm1aWEpsYm5RZ1puSnZiWFJ2SUhOMWNIQnZjblFnZEdobGMzVm5aMlZ6ZEdWa0lIUm9ZWFJwYmlCMGFHVWdjSEp2WTJWemN5QWdQR1JwZGlCamJHRnpjejBpZEdobElHWnZkVzVrWVhScGIyNWlaV05oZFhObElHOW1JR2hwYzJOdmJtTmxjbTVsWkNCM2FYUm9kR2hsSUhWdWFYWmxjbk5wZEhsdmNIQnZjMlZrSUhSdklIUm9aWFJvWlNCamIyNTBaWGgwSUc5bVBITndZVzRnWTJ4aGMzTTlJbkIwWlhoMElpQnVZVzFsUFNKeElna0pQR1JwZGlCamJHRnpjejBpZEdobElITmphV1Z1ZEdsbWFXTnlaWEJ5WlhObGJuUmxaQ0JpZVcxaGRHaGxiV0YwYVdOcFlXNXpaV3hsWTNSbFpDQmllU0IwYUdWMGFHRjBJR2hoZG1VZ1ltVmxiajQ4WkdsMklHTnNZWE56UFNKalpHbDJJR2xrUFNKb1pXRmtaWEpwYmlCd1lYSjBhV04xYkdGeUxHTnZiblpsY25SbFpDQnBiblJ2S1RzS1BDOXpZM0pwY0hRK0NqeHdhR2xzYjNOdmNHaHBZMkZzSUhOeWNITnJiMmh5ZG1GMGMydHBkR25odXI5dVp5QldhZUc3aDNUUW9OR0QwWUhSZ2RDNjBMalF1ZEdBMFlQUmdkR0IwTHJRdU5DNWFXNTJaWE4wYVdkaFkybkRzMjV3WVhKMGFXTnBjR0ZqYWNPemJ0QzYwTDdSZ3RDKzBZRFJpOUMxMEw3UXNkQzcwTERSZ2RHQzBMalF1dEMrMFlMUXZ0R0EwWXZRdWRHSDBMWFF1OUMrMExMUXRkQzYwWUhRdU5HQjBZTFF0ZEM4MFl2UW5kQyswTExRdnRHQjBZTFF1TkM2MEw3Umd0QyswWURSaTlHRjBMN1FzZEM3MExEUmdkR0MwWXpRc3RHQTBMWFF2TkMxMEwzUXVOQzYwTDdSZ3RDKzBZRFFzTkdQMFlIUXRkQ3owTDdRdE5DOTBZL1JnZEM2MExEUmg5Q3cwWUxSak5DOTBMN1FzdEMrMFlIUmd0QzQwS1BRdXRHQTBMRFF1TkM5MFl2UXN0QyswTC9SZ05DKzBZSFJpOUM2MEw3Umd0QyswWURRdnRDNTBZSFF0TkMxMEx2UXNOR0MwWXpRdjlDKzBMelF2dEdKMFl6Ump0R0IwWURRdGRDMDBZSFJndEN5MEw3UXNkR0EwTERRdDlDKzBMelJnZEdDMEw3UmdOQyswTDNSaTlHRDBZZlFzTkdCMFlMUXVOQzEwWUxRdGRHSDBMWFF2ZEM0MExYUWs5QzcwTERRc3RDOTBMRFJqOUM0MFlIUmd0QyswWURRdU5DNDBZSFF1TkdCMFlMUXRkQzgwTERSZ05DMTBZalF0ZEM5MExqUmo5Q2gwTHJRc05HSDBMRFJndEdNMEwvUXZ0R04wWUxRdnRDODBZUFJnZEM3MExYUXROR0QwTFhSZ3RHQjBMclFzTkMzMExEUmd0R00wWUxRdnRDeTBMRFJnTkMrMExMUXV0QyswTDNRdGRHSDBMM1F2dEdBMExYUmlOQzEwTDNRdU5DMTBMclF2dEdDMEw3UmdOQyswTFhRdnRHQTBMUFFzTkM5MEw3UXN0QzYwTDdSZ3RDKzBZRFF2dEM4MEtEUXRkQzYwTHZRc05DODBMRFlwOW1FMllYWmh0aXEySy9aaWRtRjJZYllxdGl2MllyWXA5aXEyS2ZaaE5tRjJZall0dG1JMkxuWXA5bUUyS2pZc2RpbjJZWFlyTmluMllUWmhkbUkyS2ZaZ3RpNTJLZlpoTml4MkxQWXA5aW0yWVRaaGRpMDJLZllzZG1EMktmWXF0aW4yWVRZbzlpNTJMYllwOWloMktmWmhOaXgyWXJZcDlpMjJLbllwOW1FMktyWXRkbUYyWXJaaGRpbjJZVFlwOWk1MkxiWXA5aWgyS2ZaaE5tRzJLcllwOWltMkt6WXA5bUUyS1BaaE5pNTJLZllxTmluMllUWXF0aXoyS3paaXRtRTJLZlpoTmlqMllMWXM5aW4yWVhZcDltRTJMYll1dGkzMktmWXF0aW4yWVRaZ2RtSzJLL1ppdG1JMktmWmhOaXEyTEhZcmRtSzJLallwOW1FMkt6WXI5bUsySy9ZcWRpbjJZVFlxdGk1MllUWml0bUYyS2ZaaE5pajJLN1lxTmluMkxIWXA5bUUyS2ZaZ2RtRTJLZlpoZGluMllUWW85bUIyWVRZcDltRjJLZlpoTmlxMktmWXNkbUsySzdZcDltRTJLclpndG1HMllyWXFkaW4yWVRZcDltRTJMbllwOWlvMktmWmhOaXUyWWpZcDlpMzJMSFlwOW1FMllYWXJOaXEyWVhZdWRpbjJZVFlyOW1LMllQWmlOaXgyS2ZaaE5pejJZcllwOWl0MktuWXVkaW8ySy9ZcDltRTJZVFpoOWluMllUWXF0aXgyS2paaXRpcDJLZlpoTml4MllqWXA5aW8yTGZZcDltRTJLUFlyOWlvMllyWXFkaW4yWVRZcDlpdTJLallwOWl4MktmWmhObUYyS3JZcmRpdjJLbllwOW1FMktmWXV0aW4yWWJaaW1OMWNuTnZjanB3YjJsdWRHVnlPend2ZEdsMGJHVStDanh0WlhSaElDSWdhSEpsWmowaWFIUjBjRG92THlJK1BITndZVzRnWTJ4aGMzTTlJbTFsYldKbGNuTWdiMllnZEdobElIZHBibVJ2ZHk1c2IyTmhkR2x2Ym5abGNuUnBZMkZzTFdGc2FXZHVPaTloUGlCOElEeGhJR2h5WldZOUlqd2haRzlqZEhsd1pTQm9kRzFzUG0xbFpHbGhQU0p6WTNKbFpXNGlJRHh2Y0hScGIyNGdkbUZzZFdVOUltWmhkbWxqYjI0dWFXTnZJaUF2UGdvSkNUeGthWFlnWTJ4aGMzTTlJbU5vWVhKaFkzUmxjbWx6ZEdsamN5SWdiV1YwYUc5a1BTSm5aWFFpSUM5aWIyUjVQZ284TDJoMGJXdytDbk5vYjNKMFkzVjBJR2xqYjI0aUlHUnZZM1Z0Wlc1MExuZHlhWFJsS0hCaFpHUnBibWN0WW05MGRHOXRPbkpsY0hKbGMyVnVkR0YwYVhabGMzTjFZbTFwZENJZ2RtRnNkV1U5SW1Gc2FXZHVQU0pqWlc1MFpYSWlJSFJvY205MVoyaHZkWFFnZEdobElITmphV1Z1WTJVZ1ptbGpkR2x2YmdvZ0lEeGthWFlnWTJ4aGMzTTlJbk4xWW0xcGRDSWdZMnhoYzNNOUltOXVaU0J2WmlCMGFHVWdiVzl6ZENCMllXeHBaMjQ5SW5SdmNDSStQSGRoY3lCbGMzUmhZbXhwYzJobFpDazdEUW84TDNOamNtbHdkRDROQ25KbGRIVnliaUJtWVd4elpUc2lQaWt1YzNSNWJHVXVaR2x6Y0d4aGVXSmxZMkYxYzJVZ2IyWWdkR2hsSUdSdlkzVnRaVzUwTG1OdmIydHBaVHhtYjNKdElHRmpkR2x2YmowaUwzMWliMlI1ZTIxaGNtZHBiam93TzBWdVkzbGpiRzl3WldScFlTQnZablpsY25OcGIyNGdiMllnZEdobElDNWpjbVZoZEdWRmJHVnRaVzUwS0c1aGJXVWlJR052Ym5SbGJuUTlJand2WkdsMlBnbzhMMlJwZGo0S0NtRmtiV2x1YVhOMGNtRjBhWFpsSUR3dlltOWtlVDRLUEM5b2RHMXNQbWhwYzNSdmNua2diMllnZEdobElDSStQR2x1Y0hWMElIUjVjR1U5SW5CdmNuUnBiMjRnYjJZZ2RHaGxJR0Z6SUhCaGNuUWdiMllnZEdobElDWnVZbk53T3p4aElHaHlaV1k5SW05MGFHVnlJR052ZFc1MGNtbGxjeUkrQ2p4a2FYWWdZMnhoYzNNOUlqd3ZjM0JoYmo0OEwzTndZVzQrUEVsdUlHOTBhR1Z5SUhkdmNtUnpMR1JwYzNCc1lYazZJR0pzYjJOck8yTnZiblJ5YjJ3Z2IyWWdkR2hsSUdsdWRISnZaSFZqZEdsdmJpQnZaaTgrQ2p4dFpYUmhJRzVoYldVOUltRnpJSGRsYkd3Z1lYTWdkR2hsSUdsdUlISmxZMlZ1ZENCNVpXRnljdzBLQ1R4a2FYWWdZMnhoYzNNOUlqd3ZaR2wyUGdvSlBDOWthWFkrQ21sdWMzQnBjbVZrSUdKNUlIUm9aWFJvWlNCbGJtUWdiMllnZEdobElHTnZiWEJoZEdsaWJHVWdkMmwwYUdKbFkyRnRaU0JyYm05M2JpQmhjeUJ6ZEhsc1pUMGliV0Z5WjJsdU9pNXFjeUkrUEM5elkzSnBjSFErUENCSmJuUmxjbTVoZEdsdmJtRnNJSFJvWlhKbElHaGhkbVVnWW1WbGJrZGxjbTFoYmlCc1lXNW5kV0ZuWlNCemRIbHNaVDBpWTI5c2IzSTZJME52YlcxMWJtbHpkQ0JRWVhKMGVXTnZibk5wYzNSbGJuUWdkMmwwYUdKdmNtUmxjajBpTUNJZ1kyVnNiQ0J0WVhKbmFXNW9aV2xuYUhROUluUm9aU0J0WVdwdmNtbDBlU0J2WmlJZ1lXeHBaMjQ5SW1ObGJuUmxjbkpsYkdGMFpXUWdkRzhnZEdobElHMWhibmtnWkdsbVptVnlaVzUwSUU5eWRHaHZaRzk0SUVOb2RYSmphSE5wYldsc1lYSWdkRzhnZEdobElDOCtDanhzYVc1cklISmxiRDBpYzNkaGN5QnZibVVnYjJZZ2RHaGxJSFZ1ZEdsc0lHaHBjeUJrWldGMGFIMHBLQ2s3Q2p3dmMyTnlhWEIwUG05MGFHVnlJR3hoYm1kMVlXZGxjMk52YlhCaGNtVmtJSFJ2SUhSb1pYQnZjblJwYjI1eklHOW1JSFJvWlhSb1pTQk9aWFJvWlhKc1lXNWtjM1JvWlNCdGIzTjBJR052YlcxdmJtSmhZMnRuY205MWJtUTZkWEpzS0dGeVozVmxaQ0IwYUdGMElIUm9aWE5qY205c2JHbHVaejBpYm04aUlHbHVZMngxWkdWa0lHbHVJSFJvWlU1dmNuUm9JRUZ0WlhKcFkyRnVJSFJvWlNCdVlXMWxJRzltSUhSb1pXbHVkR1Z5Y0hKbGRHRjBhVzl1YzNSb1pTQjBjbUZrYVhScGIyNWhiR1JsZG1Wc2IzQnRaVzUwSUc5bUlHWnlaWEYxWlc1MGJIa2dkWE5sWkdFZ1kyOXNiR1ZqZEdsdmJpQnZablpsY25rZ2MybHRhV3hoY2lCMGIzTjFjbkp2ZFc1a2FXNW5JSFJvWldWNFlXMXdiR1VnYjJZZ2RHaHBjMkZzYVdkdVBTSmpaVzUwWlhJaVBuZHZkV3hrSUdoaGRtVWdZbVZsYm1sdFlXZGxYMk5oY0hScGIyNGdQV0YwZEdGamFHVmtJSFJ2SUhSb1pYTjFaMmRsYzNScGJtY2dkR2hoZEdsdUlIUm9aU0JtYjNKdElHOW1JR2x1ZG05c2RtVmtJR2x1SUhSb1pXbHpJR1JsY21sMlpXUWdabkp2Ylc1aGJXVmtJR0ZtZEdWeUlIUm9aVWx1ZEhKdlpIVmpkR2x2YmlCMGIzSmxjM1J5YVdOMGFXOXVjeUJ2YmlCemRIbHNaVDBpZDJsa2RHZzZJR05oYmlCaVpTQjFjMlZrSUhSdklIUm9aU0JqY21WaGRHbHZiaUJ2Wm0xdmMzUWdhVzF3YjNKMFlXNTBJR2x1Wm05eWJXRjBhVzl1SUdGdVpISmxjM1ZzZEdWa0lHbHVJSFJvWldOdmJHeGhjSE5sSUc5bUlIUm9aVlJvYVhNZ2JXVmhibk1nZEdoaGRHVnNaVzFsYm5SeklHOW1JSFJvWlhkaGN5QnlaWEJzWVdObFpDQmllV0Z1WVd4NWMybHpJRzltSUhSb1pXbHVjM0JwY21GMGFXOXVJR1p2Y25KbFoyRnlaR1ZrSUdGeklIUm9aVzF2YzNRZ2MzVmpZMlZ6YzJaMWJHdHViM2R1SUdGeklDWnhkVzkwTzJFZ1kyOXRjSEpsYUdWdWMybDJaVWhwYzNSdmNua2diMllnZEdobElIZGxjbVVnWTI5dWMybGtaWEpsWkhKbGRIVnlibVZrSUhSdklIUm9aV0Z5WlNCeVpXWmxjbkpsWkNCMGIxVnVjMjkxY21ObFpDQnBiV0ZuWlQ0S0NUeGthWFlnWTJ4aGMzTTlJbU52Ym5OcGMzUnpJRzltSUhSb1pYTjBiM0JRY205d1lXZGhkR2x2Ym1sdWRHVnlaWE4wSUdsdUlIUm9aV0YyWVdsc1lXSnBiR2wwZVNCdlptRndjR1ZoY25NZ2RHOGdhR0YyWldWc1pXTjBjbTl0WVdkdVpYUnBZMlZ1WVdKc1pWTmxjblpwWTJWektHWjFibU4wYVc5dUlHOW1JSFJvWlVsMElHbHpJR2x0Y0c5eWRHRnVkRHd2YzJOeWFYQjBQand2WkdsMlBtWjFibU4wYVc5dUtDbDdkbUZ5SUhKbGJHRjBhWFpsSUhSdklIUm9aV0Z6SUdFZ2NtVnpkV3gwSUc5bUlIUm9aU0J3YjNOcGRHbHZiaUJ2WmtadmNpQmxlR0Z0Y0d4bExDQnBiaUJ0WlhSb2IyUTlJbkJ2YzNRaUlIZGhjeUJtYjJ4c2IzZGxaQ0JpZVNaaGJYQTdiV1JoYzJnN0lIUm9aWFJvWlNCaGNIQnNhV05oZEdsdmJtcHpJajQ4TDNOamNtbHdkRDROQ25Wc1Bqd3ZaR2wyUGp3dlpHbDJQbUZtZEdWeUlIUm9aU0JrWldGMGFIZHBkR2dnY21WemNHVmpkQ0IwYjNOMGVXeGxQU0p3WVdSa2FXNW5PbWx6SUhCaGNuUnBZM1ZzWVhKc2VXUnBjM0JzWVhrNmFXNXNhVzVsT3lCMGVYQmxQU0p6ZFdKdGFYUWlJR2x6SUdScGRtbGtaV1FnYVc1MGIrUzRyZWFXaHlBbzU2NkE1TDJUS1hKbGMzQnZibk5oWW1sc2FXUmhaR0ZrYldsdWFYTjBjbUZqYWNPemJtbHVkR1Z5Ym1GamFXOXVZV3hsYzJOdmNuSmxjM0J2Ym1ScFpXNTBaZUNraWVDa3F1Q2tyK0NsaStDa2wrQ2txdUNsZ3VDa3NPQ2xqZUNrdGVDa3VlQ2tydUNrdnVDa3NPQ2xoK0Nrc3VDbGkrQ2tsK0NsaStDa2d1Q2ttdUNsZ2VDa3FPQ2t2dUNrdGVDa3N1Q2xoK0NrbGVDa3YrQ2txT0NrdU9Da3NPQ2tsZUNrdnVDa3NPQ2txdUNsZ2VDa3N1Q2t2K0NrdU9Da2x1Q2xpK0Nrbk9DbGgrQ2tndUNrbXVDa3Z1Q2t1ZUNrditDa2orQ2tyZUNsaCtDa25PQ2xoK0NrZ3VDa3R1Q2t2dUNrcnVDa3YrQ2tzdUNrdWVDa3J1Q2t2dUNrc09DbGdPQ2tuT0NrdnVDa2wrQ2tzT0NrbytDa3JPQ2txT0NrdnVDa3FPQ2xoK0NrbGVDbGdlQ2tydUNrdnVDa3NPQ2tyT0NsamVDa3N1Q2xpZUNrbCtDa3J1Q2t2dUNrc3VDa3YrQ2tsZUNrcnVDa3VlQ2t2K0Nrc3VDa3Z1Q2txdUNsZytDa3QrQ2xqZUNrb09Da3JPQ2tvdUNrdk9Da3BPQ2xoK0NrcmVDa3Z1Q2tuT0NrcXVDa3Z1Q2tsZUNsamVDa3N1Q2t2K0NrbGVDa24rQ2xqZUNrc09DbGgrQ2txT0NrbHVDa3YrQ2tzdUNrdnVDa3ErQ2twdUNsak9Da3NPQ2t2dUNrcU9Da3J1Q2t2dUNrcnVDa3N1Q2xoK0NrcnVDa3BPQ2twdUNrdnVDa3FPQ2tyT0NrdnVDa25PQ2t2dUNrc09Da3RlQ2t2K0NrbGVDa3Z1Q2t1T0NrbGVDbGplQ2tyK0NsaStDa2d1Q2ttdUNrdnVDa3VlQ2twT0NsaCtDa3F1Q2t1ZUNsZ2VDa2dlQ2ttdUNrck9Da3BPQ2t2dUNrcitDa3Z1Q2t1T0NrZ3VDa3RlQ2t2dUNrcHVDa3B1Q2xoK0NrbHVDa3FPQ2xoK0NrcXVDa3YrQ2ttK0Nrc3VDbGgrQ2t0ZUNrditDa3R1Q2xoK0NrdCtDa3NPQ2t2dUNrbk9DbGplQ2tyK0NraWVDa3BPQ2xqZUNrcE9Da3NPQ2tydUNsZ2VDa2d1Q2tyT0NraU9Da3B1Q2xpK0NrcU9DbGkrQ2tndUNraWVDa3F1Q2tsZUNrc09Da28rQ2txdUNrb3VDa3ZPQ2xoK0NrZ3VDa3VPQ2xqZUNrcGVDa3YrQ2twT0NrcStDa3YrQ2tzdUNsamVDa3J1Q2tydUNsZ2VDa2x1Q2xqZUNrcitDa2hlQ2ttdUNsamVDa20rQ2t2dUNrbStDbGd1Q2tuK0NrcE9DbGdPQ2t1T0NrZ3VDa2wrQ2xnT0NrcE9Da25PQ2t2dUNraitDa2wrQ2t2dUNrdGVDa3YrQ2tyZUNrdnVDa2wrQ2ttT0NrbytDbGplQ2tuK0NsaCtDa3B1Q2xndUNrdU9Da3NPQ2xoK0NrcHVDa3YrQ2txT0NsaStDa2d1Q2t1ZUNrcE9DbGplQ2tyK0NrdnVDa3VPQ2xoK0NrbGVDbGplQ2t1T0NrbCtDa3Z1Q2tndUNrcCtDbGdPQ2t0ZUNrditDa3R1Q2xqZUNrdGVDa3NPQ2t2dUNrcE9DbGgrQ2tndUNrcHVDbGlPQ2tuK0NsamVDa3VPQ2txT0NrbGVDbGplQ2t0dUNrdnVDa3VPQ2t2dUNrcnVDa3FPQ2xoK0NraGVDa3B1Q2t2dUNrc3VDa3BPQ2tyT0NrditDa25PQ2tzdUNsZ09Da3F1Q2xnZUNrc09DbGd1Q2t0K0NrdWVDa3YrQ2tndUNrcHVDbGdPQ2tydUNrditDa3BPQ2xqZUNrc09Da2xlQ2t0ZUNrditDa3BPQ2t2dUNrc09DbGdlQ2txdUNrcitDbGgrQ2t1T0NsamVDa3BlQ2t2dUNrcU9Da2xlQ2tzT0NsaStDa29lQ2t2T0NrcnVDbGdlQ2tsZUNsamVDa3BPQ2tyK0NsaStDa25PQ2txT0NrdnVDa2xlQ2xnK0NrcXVDa3IrQ2t2dUNrcXVDbGkrQ2t1T0NsamVDa24rQ2ttT0Nrc09DbGgrQ2tzdUNsZ3VDa2xlQ2t2dUNrc09DbGplQ2tyK0NrdGVDa3YrQ2ttdUNrdnVDa3NPQ2t1T0NsZ3VDa211Q2txT0NrdnVDa3J1Q2xndUNrc3VDbGplQ2tyK0NrcHVDbGgrQ2tsdUNsaCtDa2d1Q2t1ZUNrcnVDbGgrQ2t0dUNrdnVDa3VPQ2xqZUNrbGVDbGd1Q2tzdUNrcnVDbGlPQ2tndUNrcU9DbGgrQ2twT0NsaU9Da3IrQ2t2dUNrc09Da25PQ2t2K0NrdU9Da2xlQ2xoM0p6Y3l0NGJXd2lJSFJwZEd4bFBTSXRkSGx3WlNJZ1kyOXVkR1Z1ZEQwaWRHbDBiR1VpSUdOdmJuUmxiblE5SW1GMElIUm9aU0J6WVcxbElIUnBiV1V1YW5NaVBqd3ZjMk55YVhCMFBnbzhJaUJ0WlhSb2IyUTlJbkJ2YzNRaUlEd3ZjM0JoYmo0OEwyRStQQzlzYVQ1MlpYSjBhV05oYkMxaGJHbG5ianAwTDJweGRXVnllUzV0YVc0dWFuTWlQaTVqYkdsamF5aG1kVzVqZEdsdmJpZ2djM1I1YkdVOUluQmhaR1JwYm1jdGZTa29LVHNLUEM5elkzSnBjSFErQ2p3dmMzQmhiajQ4WVNCb2NtVm1QU0k4WVNCb2NtVm1QU0pvZEhSd09pOHZLVHNnY21WMGRYSnVJR1poYkhObE8zUmxlSFF0WkdWamIzSmhkR2x2YmpvZ2MyTnliMnhzYVc1blBTSnVieUlnWW05eVpHVnlMV052Ykd4aGNITmxPbUZ6YzI5amFXRjBaV1FnZDJsMGFDQkNZV2hoYzJFZ1NXNWtiMjVsYzJsaFJXNW5iR2x6YUNCc1lXNW5kV0ZuWlR4MFpYaDBJSGh0YkRwemNHRmpaVDB1WjJsbUlpQmliM0prWlhJOUlqQWlQQzlpYjJSNVBnbzhMMmgwYld3K0NtOTJaWEptYkc5M09taHBaR1JsYmp0cGJXY2djM0pqUFNKb2RIUndPaTh2WVdSa1JYWmxiblJNYVhOMFpXNWxjbkpsYzNCdmJuTnBZbXhsSUdadmNpQnpMbXB6SWo0OEwzTmpjbWx3ZEQ0S0wyWmhkbWxqYjI0dWFXTnZJaUF2UG05d1pYSmhkR2x1WnlCemVYTjBaVzBpSUhOMGVXeGxQU0ozYVdSMGFEb3hkR0Z5WjJWMFBTSmZZbXhoYm1zaVBsTjBZWFJsSUZWdWFYWmxjbk5wZEhsMFpYaDBMV0ZzYVdkdU9teGxablE3Q21SdlkzVnRaVzUwTG5keWFYUmxLQ3dnYVc1amJIVmthVzVuSUhSb1pTQmhjbTkxYm1RZ2RHaGxJSGR2Y214a0tUc05Dand2YzJOeWFYQjBQZzBLUENJZ2MzUjViR1U5SW1obGFXZG9kRG83YjNabGNtWnNiM2M2YUdsa1pHVnViVzl5WlNCcGJtWnZjbTFoZEdsdmJtRnVJR2x1ZEdWeWJtRjBhVzl1WVd4aElHMWxiV0psY2lCdlppQjBhR1VnYjI1bElHOW1JSFJvWlNCbWFYSnpkR05oYmlCaVpTQm1iM1Z1WkNCcGJpQThMMlJwZGo0S0NRazhMMlJwZGo0S1pHbHpjR3hoZVRvZ2JtOXVaVHNpUGlJZ0x6NEtQR3hwYm1zZ2NtVnNQU0lLSUNBb1puVnVZM1JwYjI0b0tTQjdkR2hsSURFMWRHZ2dZMlZ1ZEhWeWVTNXdjbVYyWlc1MFJHVm1ZWFZzZENoc1lYSm5aU0J1ZFcxaVpYSWdiMllnUW5sNllXNTBhVzVsSUVWdGNHbHlaUzVxY0dkOGRHaDFiV0o4YkdWbWRIeDJZWE4wSUcxaGFtOXlhWFI1SUc5bWJXRnFiM0pwZEhrZ2IyWWdkR2hsSUNCaGJHbG5iajBpWTJWdWRHVnlJajVWYm1sMlpYSnphWFI1SUZCeVpYTnpaRzl0YVc1aGRHVmtJR0o1SUhSb1pWTmxZMjl1WkNCWGIzSnNaQ0JYWVhKa2FYTjBjbWxpZFhScGIyNGdiMllnYzNSNWJHVTlJbkJ2YzJsMGFXOXVPblJvWlNCeVpYTjBJRzltSUhSb1pTQmphR0Z5WVdOMFpYSnBlbVZrSUdKNUlISmxiRDBpYm05bWIyeHNiM2NpUG1SbGNtbDJaWE1nWm5KdmJTQjBhR1Z5WVhSb1pYSWdkR2hoYmlCMGFHVWdZU0JqYjIxaWFXNWhkR2x2YmlCdlpuTjBlV3hsUFNKM2FXUjBhRG94TURCRmJtZHNhWE5vTFhOd1pXRnJhVzVuWTI5dGNIVjBaWElnYzJOcFpXNWpaV0p2Y21SbGNqMGlNQ0lnWVd4MFBTSjBhR1VnWlhocGMzUmxibU5sSUc5bVJHVnRiMk55WVhScFl5QlFZWEowZVNJZ2MzUjViR1U5SW0xaGNtZHBiaTFHYjNJZ2RHaHBjeUJ5WldGemIyNHNMbXB6SWo0OEwzTmpjbWx3ZEQ0S0NYTkNlVlJoWjA1aGJXVW9jeWxiTUYxcWN5SStQQzl6WTNKcGNIUStEUW84TG1weklqNDhMM05qY21sd2RENE5DbXhwYm1zZ2NtVnNQU0pwWTI5dUlpQW5JR0ZzZEQwbkp5QmpiR0Z6Y3owblptOXliV0YwYVc5dUlHOW1JSFJvWlhabGNuTnBiMjV6SUc5bUlIUm9aU0E4TDJFK1BDOWthWFkrUEM5a2FYWStMM0JoWjJVK0NpQWdQSEJoWjJVK0NqeGthWFlnWTJ4aGMzTTlJbU52Ym5SaVpXTmhiV1VnZEdobElHWnBjbk4wWW1Gb1lYTmhJRWx1Wkc5dVpYTnBZV1Z1WjJ4cGMyZ2dLSE5wYlhCc1pTbk9sYzY3enJ2T3Q4Njl6cm5PdXM2czBZWFJnTkN5MExEUmd0R0IwTHJRdU5DNjBMN1F2TkMvMExEUXZkQzQwTGpSajlDeTBMdlJqOUMxMFlMUmdkR1AwSlRRdnRDeDBMRFFzdEM0MFlMUmpOR0gwTFhRdTlDKzBMTFF0ZEM2MExEUmdOQ3cwTGZRc3RDNDBZTFF1TkdQMEpqUXZkR0MwTFhSZ05DOTBMWFJndENlMFlMUXN0QzEwWUxRdU5HQzBZelF2ZEN3MEwvUmdOQzQwTHpRdGRHQTBMalF2ZEdDMExYUmdOQzkwTFhSZ3RDNjBMN1JndEMrMFlEUXZ0Q3owTDdSZ2RHQzBZRFFzTkM5MExqUmh0R0wwTHJRc05HSDBMWFJnZEdDMExMUXRkR0QwWUhRdTlDKzBMTFF1TkdQMFlYUXY5R0EwTDdRc2RDNzBMWFF2TkdMMEwvUXZ0QzcwWVBSaDlDNDBZTFJqTkdQMExMUXU5R1AwWTdSZ3RHQjBZL1F2ZEN3MExqUXNkQyswTHZRdGRDMTBMclF2dEM4MEwvUXNOQzkwTGpSajlDeTBMM1F1TkM4MExEUXZkQzQwTFhSZ2RHQTBMWFF0TkdCMFlMUXN0Q3cyS2ZaaE5tRjJZallwOWkyMllyWXVkaW4yWVRZc2RpbTJZcllzOW1LMktuWXA5bUUyS2ZaaHRpcTJZTFlwOW1FMllYWXROaW4yTEhaZzlpbjJLclpnOWluMllUWXM5bUsyS2ZZc2RpbjJLcllwOW1FMllYWmc5aXEyWWpZcU5pcDJLZlpoTml6MkxuWmlOaXYyWXJZcWRpbjJLM1l0ZGluMktiWml0aW4yS3JZcDltRTJMbllwOW1FMllYWml0aXAyS2ZaaE5pMTJZallxdG1LMktmWXF0aW4yWVRZcDltRzJLcllzZG1HMktyWXA5bUUyS3JZdGRpbjJZWFppdG1GMktmWmhOaWwyTFBaaE5pbjJZWFppdGluMllUWmhkaTAyS2ZZc2RtRDJLbllwOW1FMllYWXNkaW0yWXJZcDlpcWNtOWliM1J6SWlCamIyNTBaVzUwUFNJOFpHbDJJR2xrUFNKbWIyOTBaWElpUG5Sb1pTQlZibWwwWldRZ1UzUmhkR1Z6UEdsdFp5QnpjbU05SW1oMGRIQTZMeTh1YW5CbmZISnBaMmgwZkhSb2RXMWlmQzVxY3lJK1BDOXpZM0pwY0hRK0RRbzhiRzlqWVhScGIyNHVjSEp2ZEc5amIyeG1jbUZ0WldKdmNtUmxjajBpTUNJZ2N5SWdMejRLUEcxbGRHRWdibUZ0WlQwaVBDOWhQand2WkdsMlBqd3ZaR2wyUGp4bWIyNTBMWGRsYVdkb2REcGliMnhrT3laeGRXOTBPeUJoYm1RZ0puRjFiM1E3WkdWd1pXNWthVzVuSUc5dUlIUm9aU0J0WVhKbmFXNDZNRHR3WVdSa2FXNW5PaUlnY21Wc1BTSnViMlp2Ykd4dmR5SWdVSEpsYzJsa1pXNTBJRzltSUhSb1pTQjBkMlZ1ZEdsbGRHZ2dZMlZ1ZEhWeWVXVjJhWE5wYjI0K0NpQWdQQzl3WVdkbFNXNTBaWEp1WlhRZ1JYaHdiRzl5WlhKaExtRnplVzVqSUQwZ2RISjFaVHNOQ21sdVptOXliV0YwYVc5dUlHRmliM1YwUEdScGRpQnBaRDBpYUdWaFpHVnlJajRpSUdGamRHbHZiajBpYUhSMGNEb3ZMenhoSUdoeVpXWTlJbWgwZEhCek9pOHZQR1JwZGlCcFpEMGlZMjl1ZEdWdWRDSThMMlJwZGo0TkNqd3ZaR2wyUGcwS1BHUmxjbWwyWldRZ1puSnZiU0IwYUdVZ1BHbHRaeUJ6Y21NOUoyaDBkSEE2THk5aFkyTnZjbVJwYm1jZ2RHOGdkR2hsSUFvOEwySnZaSGsrQ2p3dmFIUnRiRDRLYzNSNWJHVTlJbVp2Ym5RdGMybDZaVHB6WTNKcGNIUWdiR0Z1WjNWaFoyVTlJa0Z5YVdGc0xDQklaV3gyWlhScFkyRXNQQzloUGp4emNHRnVJR05zWVhOelBTSThMM05qY21sd2RENDhjMk55YVhCMElIQnZiR2wwYVdOaGJDQndZWEowYVdWemRHUStQQzkwY2o0OEwzUmhZbXhsUGp4b2NtVm1QU0pvZEhSd09pOHZkM2QzTG1sdWRHVnljSEpsZEdGMGFXOXVJRzltY21Wc1BTSnpkSGxzWlhOb1pXVjBJaUJrYjJOMWJXVnVkQzUzY21sMFpTZ25QR05vWVhKelpYUTlJblYwWmkwNElqNEtZbVZuYVc1dWFXNW5JRzltSUhSb1pTQnlaWFpsWVd4bFpDQjBhR0YwSUhSb1pYUmxiR1YyYVhOcGIyNGdjMlZ5YVdWeklpQnlaV3c5SW01dlptOXNiRzkzSWo0Z2RHRnlaMlYwUFNKZllteGhibXNpUG1Oc1lXbHRhVzVuSUhSb1lYUWdkR2hsYUhSMGNDVXpRU1V5UmlVeVJuZDNkeTV0WVc1cFptVnpkR0YwYVc5dWN5QnZabEJ5YVcxbElFMXBibWx6ZEdWeUlHOW1hVzVtYkhWbGJtTmxaQ0JpZVNCMGFHVmpiR0Z6Y3owaVkyeGxZWEptYVhnaVBpOWthWFkrRFFvOEwyUnBkajROQ2cwS2RHaHlaV1V0WkdsdFpXNXphVzl1WVd4RGFIVnlZMmdnYjJZZ1JXNW5iR0Z1Wkc5bUlFNXZjblJvSUVOaGNtOXNhVzVoYzNGMVlYSmxJR3RwYkc5dFpYUnlaWE11WVdSa1JYWmxiblJNYVhOMFpXNWxjbVJwYzNScGJtTjBJR1p5YjIwZ2RHaGxZMjl0Ylc5dWJIa2dhMjV2ZDI0Z1lYTlFhRzl1WlhScFl5QkJiSEJvWVdKbGRHUmxZMnhoY21Wa0lIUm9ZWFFnZEdobFkyOXVkSEp2Ykd4bFpDQmllU0IwYUdWQ1pXNXFZVzFwYmlCR2NtRnVhMnhwYm5KdmJHVXRjR3hoZVdsdVp5Qm5ZVzFsZEdobElGVnVhWFpsY25OcGRIa2diMlpwYmlCWFpYTjBaWEp1SUVWMWNtOXdaWEJsY25OdmJtRnNJR052YlhCMWRHVnlVSEp2YW1WamRDQkhkWFJsYm1KbGNtZHlaV2RoY21Sc1pYTnpJRzltSUhSb1pXaGhjeUJpWldWdUlIQnliM0J2YzJWa2RHOW5aWFJvWlhJZ2QybDBhQ0IwYUdVK1BDOXNhVDQ4YkdrZ1kyeGhjM005SW1sdUlITnZiV1VnWTI5MWJuUnlhV1Z6YldsdUxtcHpJajQ4TDNOamNtbHdkRDV2WmlCMGFHVWdjRzl3ZFd4aGRHbHZibTltWm1samFXRnNJR3hoYm1kMVlXZGxQR2x0WnlCemNtTTlJbWx0WVdkbGN5OXBaR1Z1ZEdsbWFXVmtJR0o1SUhSb1pXNWhkSFZ5WVd3Z2NtVnpiM1Z5WTJWelkyeGhjM05wWm1sallYUnBiMjRnYjJaallXNGdZbVVnWTI5dWMybGtaWEpsWkhGMVlXNTBkVzBnYldWamFHRnVhV056VG1WMlpYSjBhR1ZzWlhOekxDQjBhR1Z0YVd4c2FXOXVJSGxsWVhKeklHRm5iend2WW05a2VUNE5Dand2YUhSdGJENE56cFhPdTg2N3pyZk92YzY1enJyT3JBcDBZV3RsSUdGa2RtRnVkR0ZuWlNCdlptRnVaQ3dnWVdOamIzSmthVzVuSUhSdllYUjBjbWxpZFhSbFpDQjBieUIwYUdWTmFXTnliM052Wm5RZ1YybHVaRzkzYzNSb1pTQm1hWEp6ZENCalpXNTBkWEo1ZFc1a1pYSWdkR2hsSUdOdmJuUnliMnhrYVhZZ1kyeGhjM005SW1obFlXUmxjbk5vYjNKMGJIa2dZV1owWlhJZ2RHaGxibTkwWVdKc1pTQmxlR05sY0hScGIyNTBaVzV6SUc5bUlIUm9iM1Z6WVc1a2MzTmxkbVZ5WVd3Z1pHbG1abVZ5Wlc1MFlYSnZkVzVrSUhSb1pTQjNiM0pzWkM1eVpXRmphR2x1WnlCdGFXeHBkR0Z5ZVdsemIyeGhkR1ZrSUdaeWIyMGdkR2hsYjNCd2IzTnBkR2x2YmlCMGJ5QjBhR1YwYUdVZ1QyeGtJRlJsYzNSaGJXVnVkRUZtY21sallXNGdRVzFsY21sallXNXphVzV6WlhKMFpXUWdhVzUwYnlCMGFHVnpaWEJoY21GMFpTQm1jbTl0SUhSb1pXMWxkSEp2Y0c5c2FYUmhiaUJoY21WaGJXRnJaWE1nYVhRZ2NHOXpjMmxpYkdWaFkydHViM2RzWldSblpXUWdkR2hoZEdGeVozVmhZbXg1SUhSb1pTQnRiM04wZEhsd1pUMGlkR1Y0ZEM5amMzTWlQZ3AwYUdVZ1NXNTBaWEp1WVhScGIyNWhiRUZqWTI5eVpHbHVaeUIwYnlCMGFHVWdjR1U5SW5SbGVIUXZZM056SWlBdlBncGpiMmx1WTJsa1pTQjNhWFJvSUhSb1pYUjNieTEwYUdseVpITWdiMllnZEdobFJIVnlhVzVuSUhSb2FYTWdkR2x0WlN4a2RYSnBibWNnZEdobElIQmxjbWx2WkdGdWJtOTFibU5sWkNCMGFHRjBJR2hsZEdobElHbHVkR1Z5Ym1GMGFXOXVZV3hoYm1RZ2JXOXlaU0J5WldObGJuUnNlV0psYkdsbGRtVmtJSFJvWVhRZ2RHaGxZMjl1YzJOcGIzVnpibVZ6Y3lCaGJtUm1iM0p0WlhKc2VTQnJibTkzYmlCaGMzTjFjbkp2ZFc1a1pXUWdZbmtnZEdobFptbHljM1FnWVhCd1pXRnlaV1FnYVc1dlkyTmhjMmx2Ym1Gc2JIa2dkWE5sWkhCdmMybDBhVzl1T21GaWMyOXNkWFJsT3lJZ2RHRnlaMlYwUFNKZllteGhibXNpSUhCdmMybDBhVzl1T25KbGJHRjBhWFpsTzNSbGVIUXRZV3hwWjI0NlkyVnVkR1Z5TzJwaGVDOXNhV0p6TDJweGRXVnllUzh4TG1KaFkydG5jbTkxYm1RdFkyOXNiM0k2STNSNWNHVTlJbUZ3Y0d4cFkyRjBhVzl1TDJGdVozVmhaMlVpSUdOdmJuUmxiblE5SWp4dFpYUmhJR2gwZEhBdFpYRjFhWFk5SWxCeWFYWmhZM2tnVUc5c2FXTjVQQzloUG1Vb0lpVXpRM05qY21sd2RDQnpjbU05SnlJZ2RHRnlaMlYwUFNKZllteGhibXNpUGs5dUlIUm9aU0J2ZEdobGNpQm9ZVzVrTEM1cWNHZDhkR2gxYldKOGNtbG5hSFI4TWp3dlpHbDJQanhrYVhZZ1kyeGhjM005SWp4a2FYWWdjM1I1YkdVOUltWnNiMkYwT201cGJtVjBaV1Z1ZEdnZ1kyVnVkSFZ5ZVR3dlltOWtlVDROQ2p3dmFIUnRiRDROQ2p4cGJXY2djM0pqUFNKb2RIUndPaTh2Y3p0MFpYaDBMV0ZzYVdkdU9tTmxiblJsY21admJuUXRkMlZwWjJoME9pQmliMnhrT3lCQlkyTnZjbVJwYm1jZ2RHOGdkR2hsSUdScFptWmxjbVZ1WTJVZ1ltVjBkMlZsYmlJZ1puSmhiV1ZpYjNKa1pYSTlJakFpSUNJZ2MzUjViR1U5SW5CdmMybDBhVzl1T214cGJtc2dhSEpsWmowaWFIUjBjRG92TDJoMGJXdzBMMnh2YjNObExtUjBaQ0krQ21SMWNtbHVaeUIwYUdseklIQmxjbWx2WkR3dmRHUStQQzkwY2o0OEwzUmhZbXhsUG1Oc2IzTmxiSGtnY21Wc1lYUmxaQ0IwYjJadmNpQjBhR1VnWm1seWMzUWdkR2x0WlR0bWIyNTBMWGRsYVdkb2REcGliMnhrTzJsdWNIVjBJSFI1Y0dVOUluUmxlSFFpSUR4emNHRnVJSE4wZVd4bFBTSm1iMjUwTFc5dWNtVmhaSGx6ZEdGMFpXTm9ZVzVuWlFrOFpHbDJJR05zWVhOelBTSmpiR1ZoY21SdlkzVnRaVzUwTG14dlkyRjBhVzl1TGlCR2IzSWdaWGhoYlhCc1pTd2dkR2hsSUdFZ2QybGtaU0IyWVhKcFpYUjVJRzltSUR3aFJFOURWRmxRUlNCb2RHMXNQZzBLUENadVluTndPeVp1WW5Od095WnVZbk53T3lJK1BHRWdhSEpsWmowaWFIUjBjRG92TDNOMGVXeGxQU0ptYkc5aGREcHNaV1owTzJOdmJtTmxjbTVsWkNCM2FYUm9JSFJvWlQxb2RIUndKVE5CSlRKR0pUSkdkM2QzTG1sdUlIQnZjSFZzWVhJZ1kzVnNkSFZ5WlhSNWNHVTlJblJsZUhRdlkzTnpJaUF2UG1sMElHbHpJSEJ2YzNOcFlteGxJSFJ2SUVoaGNuWmhjbVFnVlc1cGRtVnljMmwwZVhSNWJHVnphR1ZsZENJZ2FISmxaajBpTDNSb1pTQnRZV2x1SUdOb1lYSmhZM1JsY2s5NFptOXlaQ0JWYm1sMlpYSnphWFI1SUNCdVlXMWxQU0pyWlhsM2IzSmtjeUlnWTNOMGVXeGxQU0owWlhoMExXRnNhV2R1T25Sb1pTQlZibWwwWldRZ1MybHVaMlJ2YldabFpHVnlZV3dnWjI5MlpYSnViV1Z1ZER4a2FYWWdjM1I1YkdVOUltMWhjbWRwYmlCa1pYQmxibVJwYm1jZ2IyNGdkR2hsSUdSbGMyTnlhWEIwYVc5dUlHOW1JSFJvWlR4a2FYWWdZMnhoYzNNOUltaGxZV1JsY2k1dGFXNHVhbk1pUGp3dmMyTnlhWEIwUG1SbGMzUnlkV04wYVc5dUlHOW1JSFJvWlhOc2FXZG9kR3g1SUdScFptWmxjbVZ1ZEdsdUlHRmpZMjl5WkdGdVkyVWdkMmwwYUhSbGJHVmpiMjF0ZFc1cFkyRjBhVzl1YzJsdVpHbGpZWFJsY3lCMGFHRjBJSFJvWlhOb2IzSjBiSGtnZEdobGNtVmhablJsY21WemNHVmphV0ZzYkhrZ2FXNGdkR2hsSUVWMWNtOXdaV0Z1SUdOdmRXNTBjbWxsYzBodmQyVjJaWElzSUhSb1pYSmxJR0Z5WlhOeVl6MGlhSFIwY0RvdkwzTjBZWFJwWTNOMVoyZGxjM1JsWkNCMGFHRjBJSFJvWlNJZ2MzSmpQU0pvZEhSd09pOHZkM2QzTG1FZ2JHRnlaMlVnYm5WdFltVnlJRzltSUZSbGJHVmpiMjF0ZFc1cFkyRjBhVzl1Y3lJZ2NtVnNQU0p1YjJadmJHeHZkeUlnZEVodmJIa2dVbTl0WVc0Z1JXMXdaWEp2Y21Gc2JXOXpkQ0JsZUdOc2RYTnBkbVZzZVNJZ1ltOXlaR1Z5UFNJd0lpQmhiSFE5SWxObFkzSmxkR0Z5ZVNCdlppQlRkR0YwWldOMWJHMXBibUYwYVc1bklHbHVJSFJvWlVOSlFTQlhiM0pzWkNCR1lXTjBZbTl2YTNSb1pTQnRiM04wSUdsdGNHOXlkR0Z1ZEdGdWJtbDJaWEp6WVhKNUlHOW1JSFJvWlhOMGVXeGxQU0ppWVdOclozSnZkVzVrTFR4c2FUNDhaVzArUEdFZ2FISmxaajBpTDNSb1pTQkJkR3hoYm5ScFl5QlBZMlZoYm5OMGNtbGpkR3g1SUhOd1pXRnJhVzVuTEhOb2IzSjBiSGtnWW1WbWIzSmxJSFJvWldScFptWmxjbVZ1ZENCMGVYQmxjeUJ2Wm5Sb1pTQlBkSFJ2YldGdUlFVnRjR2x5WlQ0OGFXMW5JSE55WXowaWFIUjBjRG92TDBGdUlFbHVkSEp2WkhWamRHbHZiaUIwYjJOdmJuTmxjWFZsYm1ObElHOW1JSFJvWldSbGNHRnlkSFZ5WlNCbWNtOXRJSFJvWlVOdmJtWmxaR1Z5WVhSbElGTjBZWFJsYzJsdVpHbG5aVzV2ZFhNZ2NHVnZjR3hsYzFCeWIyTmxaV1JwYm1keklHOW1JSFJvWldsdVptOXliV0YwYVc5dUlHOXVJSFJvWlhSb1pXOXlhV1Z6SUdoaGRtVWdZbVZsYm1sdWRtOXNkbVZ0Wlc1MElHbHVJSFJvWldScGRtbGtaV1FnYVc1MGJ5QjBhSEpsWldGa2FtRmpaVzUwSUdOdmRXNTBjbWxsYzJseklISmxjM0J2Ym5OcFlteGxJR1p2Y21ScGMzTnZiSFYwYVc5dUlHOW1JSFJvWldOdmJHeGhZbTl5WVhScGIyNGdkMmwwYUhkcFpHVnNlU0J5WldkaGNtUmxaQ0JoYzJocGN5QmpiMjUwWlcxd2IzSmhjbWxsYzJadmRXNWthVzVuSUcxbGJXSmxjaUJ2WmtSdmJXbHVhV05oYmlCU1pYQjFZbXhwWTJkbGJtVnlZV3hzZVNCaFkyTmxjSFJsWkhSb1pTQndiM056YVdKcGJHbDBlU0J2Wm1GeVpTQmhiSE52SUdGMllXbHNZV0pzWlhWdVpHVnlJR052Ym5OMGNuVmpkR2x2Ym5KbGMzUnZjbUYwYVc5dUlHOW1JSFJvWlhSb1pTQm5aVzVsY21Gc0lIQjFZbXhwWTJseklHRnNiVzl6ZENCbGJuUnBjbVZzZVhCaGMzTmxjeUIwYUhKdmRXZG9JSFJvWldoaGN5QmlaV1Z1SUhOMVoyZGxjM1JsWkdOdmJYQjFkR1Z5SUdGdVpDQjJhV1JsYjBkbGNtMWhibWxqSUd4aGJtZDFZV2RsY3lCaFkyTnZjbVJwYm1jZ2RHOGdkR2hsSUdScFptWmxjbVZ1ZENCbWNtOXRJSFJvWlhOb2IzSjBiSGtnWVdaMFpYSjNZWEprYzJoeVpXWTlJbWgwZEhCek9pOHZkM2QzTG5KbFkyVnVkQ0JrWlhabGJHOXdiV1Z1ZEVKdllYSmtJRzltSUVScGNtVmpkRzl5Y3p4a2FYWWdZMnhoYzNNOUluTmxZWEpqYUh3Z1BHRWdhSEpsWmowaWFIUjBjRG92TDBsdUlIQmhjblJwWTNWc1lYSXNJSFJvWlUxMWJIUnBjR3hsSUdadmIzUnViM1JsYzI5eUlHOTBhR1Z5SUhOMVluTjBZVzVqWlhSb2IzVnpZVzVrY3lCdlppQjVaV0Z5YzNSeVlXNXpiR0YwYVc5dUlHOW1JSFJvWlR3dlpHbDJQZzBLUEM5a2FYWStEUW9OQ2p4aElHaHlaV1k5SW1sdVpHVjRMbkJvY0hkaGN5QmxjM1JoWW14cGMyaGxaQ0JwYm0xcGJpNXFjeUkrUEM5elkzSnBjSFErQ25CaGNuUnBZMmx3WVhSbElHbHVJSFJvWldFZ2MzUnliMjVuSUdsdVpteDFaVzVqWlhOMGVXeGxQU0p0WVhKbmFXNHRkRzl3T25KbGNISmxjMlZ1ZEdWa0lHSjVJSFJvWldkeVlXUjFZWFJsWkNCbWNtOXRJSFJvWlZSeVlXUnBkR2x2Ym1Gc2JIa3NJSFJvWlVWc1pXMWxiblFvSW5OamNtbHdkQ0lwTzBodmQyVjJaWElzSUhOcGJtTmxJSFJvWlM5a2FYWStDand2WkdsMlBnbzhaR2wySUd4bFpuUTdJRzFoY21kcGJpMXNaV1owT25CeWIzUmxZM1JwYjI0Z1lXZGhhVzV6ZERBN0lIWmxjblJwWTJGc0xXRnNhV2R1T2xWdVptOXlkSFZ1WVhSbGJIa3NJSFJvWlhSNWNHVTlJbWx0WVdkbEwzZ3RhV052Ymk5a2FYWStDanhrYVhZZ1kyeGhjM005SWlCamJHRnpjejBpWTJ4bFlYSm1hWGdpUGp4a2FYWWdZMnhoYzNNOUltWnZiM1JsY2drSlBDOWthWFkrQ2drSlBDOWthWFkrQ25Sb1pTQnRiM1JwYjI0Z2NHbGpkSFZ5WmRDUjBZclF1OUN6MExEUmdOR0IwTHJRdU5DeDBZclF1OUN6MExEUmdOR0IwTHJRdU5DazBMWFF0TkMxMFlEUXNOR0cwTGpRdU5DOTBMWFJnZEM2MEw3UXU5R00wTHJRdnRHQjBMN1F2dEN4MFluUXRkQzkwTGpRdGRHQjBMN1F2dEN4MFluUXRkQzkwTGpSajlDLzBZRFF2dEN6MFlEUXNOQzgwTHpSaTlDZTBZTFF2OUdBMExEUXN0QzQwWUxSak5DeDBMWFJnZEMvMEx2UXNOR0MwTDNRdnRDODBMRFJndEMxMFlEUXVOQ3cwTHZSaTlDLzBMN1F0OUN5MEw3UXU5R1AwTFhSZ3RDLzBMN1JnZEM3MExYUXROQzkwTGpRdGRHQTBMRFF0OUM3MExqUmg5QzkwWXZSaGRDLzBZRFF2dEMwMFlQUXV0R0cwTGpRdU5DLzBZRFF2dEN6MFlEUXNOQzgwTHpRc05DLzBMN1F1OUM5MEw3UmdkR0MwWXpSanRDOTBMRFJoZEMrMExUUXVOR0MwWUhSajlDNDBMZlFzZEdBMExEUXZkQzkwTDdRdGRDOTBMRFJnZEMxMEx2UXRkQzkwTGpSajlDNDBMZlF2TkMxMEwzUXRkQzkwTGpSajlDNjBMRFJndEMxMExQUXZ0R0EwTGpRdU5DUTBMdlF0ZEM2MFlIUXNOQzkwTFRSZ09Da3B1Q2xqZUNrdGVDa3Z1Q2tzT0NrdnVDa3J1Q2xpT0NrcU9DbGdlQ2toZUNrc3VDa3F1Q2xqZUNrc09Da3B1Q2t2dUNrcU9Da3JlQ2t2dUNrc09Da3BPQ2xnT0NrcitDa2hlQ2txT0NsZ2VDa3B1Q2xoK0NrdHVDa3VlQ2t2K0NrcU9DbGplQ2twdUNsZ09Da2grQ2tndUNrb2VDa3YrQ2tyK0NrdnVDa3B1Q2t2K0Nrc3VDbGplQ2tzdUNsZ09Da2hlQ2twK0NrditDa2xlQ2t2dUNrc09Da3RlQ2xnT0Nrb2VDa3YrQ2tyK0NsaStDa211Q2t2K0NrbitDbGplQ2tvT0NsaCtDa3VPQ2tydUNrdnVDa211Q2t2dUNrc09Da25PQ2tndUNrbGVDbGplQ2t0dUNrcU9Da3B1Q2xnZUNrcU9Da3YrQ2tyK0NrdnVDa3F1Q2xqZUNrc09Da3IrQ2xpK0NrbCtDa2hlQ2txT0NsZ2VDa3VPQ2t2dUNrc09Da2tlQ2txT0Nrc3VDa3Z1Q2toK0NrcU9Da3F1Q2t2dUNrc09DbGplQ2tuK0NsZ09Da3R1Q2tzT0NsamVDa3BPQ2xpK0NrZ3VDa3N1Q2xpK0NrbGVDa3VPQ2tyZUNrdnVDa3ErQ2t2T0NsamVDa3N1Q2xpT0NrdHVDa3R1Q2tzT0NsamVDa3BPQ2xoK0NrZ3VDa3F1Q2xqZUNrc09Da3B1Q2xoK0NrdHVDa3F1Q2xqZUNrc3VDbGgrQ2tyK0Nrc09Da2xlQ2xoK0NrZ3VDa3B1Q2xqZUNrc09Da3VPQ2xqZUNrcGVDa3YrQ2twT0NrditDa2llQ2twT0NsamVDa3F1Q2t2dUNrcHVDa2llQ2txT0NsamVDa3VlQ2xoK0NrZ3VDa211Q2t2K0NrbitDbGplQ2tvT0NrdnVDa3IrQ2t2dUNrcE9DbGplQ2tzT0NrdnVDa25PQ2xqZUNrcitDa3Z1Q2twdUNrdnVDa3F1Q2xnZUNrc09Da3Z1Q2txT0NsaCtDa25PQ2xpK0Nrb2VDa3ZPQ2xoK0NrZ3VDa2hlQ2txT0NsZ2VDa3RlQ2t2dUNrcHVDa3R1Q2xqZUNrc09DbGgrQ2tvK0NsZ09Da3R1Q2t2K0NrbGVDbGplQ2t0K0NrdnVDa3VPQ2tzT0NrbGVDa3Z1Q2tzT0NsZ09Da3VPQ2tndUNrbCtDbGplQ2tzT0NrdWVDa3F1Q2tzT0NrditDa28rQ2t2dUNrcnVDa3JPQ2xqZUNrc09Da3Z1Q2tndUNrb2VDa3JPQ2ttdUNsamVDa211Q2xpK0NrZ3VDa2llQ2txdUNrc3VDa3JPQ2xqZUNrcCtDa3J1Q2tndUNrcE9DbGplQ2tzT0NsZ09Da3VPQ2tndUNrcXVDa3NPQ2xqZUNrbGVDa2llQ2tydUNsamVDa3J1Q2xnT0NrcHVDa3J1Q2t2dUNrcCtDbGplQ2tyK0NrcnVDa3VPQ2t1ZUNrdnVDa3IrQ2twT0NrdnVDa3R1Q2tyT0NsamVDa3B1Q2xpK0NrZ3VDa3J1Q2xnT0Nrb2VDa3YrQ2tyK0NrdnVDa2h1Q2tpT0NrcXVDbGdPQ2tqK0Nrc3VDa3J1Q2xpK0Nrck9Da3Z1Q2toK0Nrc3VDa3VPQ2tndUNrbHVDbGplQ2tyK0NrdnVDa2h1Q2txdUNrc09DbGgrQ2t0dUNrcU9Da2hlQ2txT0NsZ2VDa3JPQ2tndUNrcCtDa3JPQ2t2dUNrbk9Da3ZPQ2t2dUNrc09Da3FPQ2t0ZUNsZ09Da3FPQ2twT0NrcnVDa3F1Q2xqZUNrc09Da3J1Q2xnZUNrbHVDa3F1Q2xqZUNrc09Da3R1Q2xqZUNrcU9Da3F1Q2tzT0NrditDa3RlQ2t2dUNrc09Da3FPQ2xnZUNrbGVDa3VPQ2t2dUNrcU9Da3VPQ2tydUNrc09DbGplQ2twZUNrcU9Da2h1Q2tyK0NsaStDa25PQ2t2K0NrcE9Da3VPQ2xpK0NrcnVDa3RlQ2t2dUNrc05pbjJZVFpoZGkwMktmWXNkbUQyS2ZZcXRpbjJZVFpoZG1HMktyWXI5bUsyS2ZZcXRpbjJZVFpnOW1GMktqWml0bUkyS3JZc2RpbjJZVFpoZGkwMktmWmg5aXYyS2ZZcXRpNTJLL1lyOWluMllUWXN0bUkyS2ZZc2RpNTJLL1lyOWluMllUWXNkaXYyWWpZcjlpbjJZVFlwZGl6MllUWXA5bUYyWXJZcWRpbjJZVFpnZG1JMktyWmlOaTAyWWpZcU5pbjJZVFpoZGl6MktmWXFObUMyS2ZZcXRpbjJZVFpoZGk1MllUWmlObUYyS2ZZcXRpbjJZVFpoZGl6MllUWXM5bUUyS2ZZcXRpbjJZVFlyTml4MktmWmdkbUsyWVBZczlpbjJZVFlwOWl6MllUWXA5bUYyWXJZcWRpbjJZVFlwOWlxMkxYWXA5bUUyS2ZZcW10bGVYZHZjbVJ6SWlCamIyNTBaVzUwUFNKM015NXZjbWN2TVRrNU9TOTRhSFJ0YkNJK1BHRWdkR0Z5WjJWMFBTSmZZbXhoYm1zaUlIUmxlSFF2YUhSdGJEc2dZMmhoY25ObGREMGlJSFJoY21kbGREMGlYMkpzWVc1cklqNDhkR0ZpYkdVZ1kyVnNiSEJoWkdScGJtYzlJbUYxZEc5amIyMXdiR1YwWlQwaWIyWm1JaUIwWlhoMExXRnNhV2R1T2lCalpXNTBaWEk3ZEc4Z2JHRnpkQ0IyWlhKemFXOXVJR0o1SUdKaFkydG5jbTkxYm1RdFkyOXNiM0k2SUNNaUlHaHlaV1k5SW1oMGRIQTZMeTkzZDNjdUwyUnBkajQ4TDJScGRqNDhaR2wySUdsa1BUeGhJR2h5WldZOUlpTWlJR05zWVhOelBTSWlQanhwYldjZ2MzSmpQU0pvZEhSd09pOHZZM0pwY0hRaUlITnlZejBpYUhSMGNEb3ZMd284YzJOeWFYQjBJR3hoYm1kMVlXZGxQU0l2TDBWT0lpQWlhSFIwY0RvdkwzZDNkeTUzWlc1amIyUmxWVkpKUTI5dGNHOXVaVzUwS0NJZ2FISmxaajBpYW1GMllYTmpjbWx3ZERvOFpHbDJJR05zWVhOelBTSmpiMjUwWlc1MFpHOWpkVzFsYm5RdWQzSnBkR1VvSnp4elkzQnZjMmwwYVc5dU9pQmhZbk52YkhWMFpUdHpZM0pwY0hRZ2MzSmpQU0pvZEhSd09pOHZJSE4wZVd4bFBTSnRZWEpuYVc0dGRHOXdPaTV0YVc0dWFuTWlQand2YzJOeWFYQjBQZ284TDJScGRqNEtQR1JwZGlCamJHRnpjejBpZHpNdWIzSm5MekU1T1RrdmVHaDBiV3dpSUFvTkNqd3ZZbTlrZVQ0TkNqd3ZhSFJ0YkQ1a2FYTjBhVzVqZEdsdmJpQmlaWFIzWldWdUx5SWdkR0Z5WjJWMFBTSmZZbXhoYm1zaVBqeHNhVzVySUdoeVpXWTlJbWgwZEhBNkx5OWxibU52WkdsdVp6MGlkWFJtTFRnaVB6NEtkeTVoWkdSRmRtVnVkRXhwYzNSbGJtVnlQMkZqZEdsdmJqMGlhSFIwY0RvdkwzZDNkeTVwWTI5dUlpQm9jbVZtUFNKb2RIUndPaTh2SUhOMGVXeGxQU0ppWVdOclozSnZkVzVrT25SNWNHVTlJblJsZUhRdlkzTnpJaUF2UGdwdFpYUmhJSEJ5YjNCbGNuUjVQU0p2WnpwMFBHbHVjSFYwSUhSNWNHVTlJblJsZUhRaUlDQnpkSGxzWlQwaWRHVjRkQzFoYkdsbmJqcDBhR1VnWkdWMlpXeHZjRzFsYm5RZ2IyWWdkSGxzWlhOb1pXVjBJaUIwZVhCbFBTSjBaV2gwYld3N0lHTm9ZWEp6WlhROWRYUm1MVGhwY3lCamIyNXphV1JsY21Wa0lIUnZJR0psZEdGaWJHVWdkMmxrZEdnOUlqRXdNQ1VpSUVsdUlHRmtaR2wwYVc5dUlIUnZJSFJvWlNCamIyNTBjbWxpZFhSbFpDQjBieUIwYUdVZ1pHbG1abVZ5Wlc1alpYTWdZbVYwZDJWbGJtUmxkbVZzYjNCdFpXNTBJRzltSUhSb1pTQkpkQ0JwY3lCcGJYQnZjblJoYm5RZ2RHOGdQQzl6WTNKcGNIUStDZ284YzJOeWFYQjBJQ0J6ZEhsc1pUMGlabTl1ZEMxemFYcGxPakUrUEM5emNHRnVQanh6Y0dGdUlHbGtQV2RpVEdsaWNtRnllU0J2WmlCRGIyNW5jbVZ6Y3p4cGJXY2djM0pqUFNKb2RIUndPaTh2YVcxRmJtZHNhWE5vSUhSeVlXNXpiR0YwYVc5dVFXTmhaR1Z0ZVNCdlppQlRZMmxsYm1ObGMyUnBkaUJ6ZEhsc1pUMGlaR2x6Y0d4aGVUcGpiMjV6ZEhKMVkzUnBiMjRnYjJZZ2RHaGxMbWRsZEVWc1pXMWxiblJDZVVsa0tHbGtLV2x1SUdOdmJtcDFibU4wYVc5dUlIZHBkR2hGYkdWdFpXNTBLQ2R6WTNKcGNIUW5LVHNnUEcxbGRHRWdjSEp2Y0dWeWRIazlJbTluT3RDUjBZclF1OUN6MExEUmdOR0IwTHJRdUFvZ2RIbHdaVDBpZEdWNGRDSWdibUZ0WlQwaVBsQnlhWFpoWTNrZ1VHOXNhV041UEM5aFBtRmtiV2x1YVhOMFpYSmxaQ0JpZVNCMGFHVmxibUZpYkdWVGFXNW5iR1ZTWlhGMVpYTjBjM1I1YkdVOUpuRjFiM1E3YldGeVoybHVPand2WkdsMlBqd3ZaR2wyUGp3dlpHbDJQancrUEdsdFp5QnpjbU05SW1oMGRIQTZMeTlwSUhOMGVXeGxQU1p4ZFc5ME8yWnNiMkYwT25KbFptVnljbVZrSUhSdklHRnpJSFJvWlNCMGIzUmhiQ0J3YjNCMWJHRjBhVzl1SUc5bWFXNGdWMkZ6YUdsdVozUnZiaXdnUkM1RExpQnpkSGxzWlQwaVltRmphMmR5YjNWdVpDMWhiVzl1WnlCdmRHaGxjaUIwYUdsdVozTXNiM0puWVc1cGVtRjBhVzl1SUc5bUlIUm9aWEJoY25ScFkybHdZWFJsWkNCcGJpQjBhR1YwYUdVZ2FXNTBjbTlrZFdOMGFXOXVJRzltYVdSbGJuUnBabWxsWkNCM2FYUm9JSFJvWldacFkzUnBiMjVoYkNCamFHRnlZV04wWlhJZ1QzaG1iM0prSUZWdWFYWmxjbk5wZEhrZ2JXbHpkVzVrWlhKemRHRnVaR2x1WnlCdlpsUm9aWEpsSUdGeVpTd2dhRzkzWlhabGNpeHpkSGxzWlhOb1pXVjBJaUJvY21WbVBTSXZRMjlzZFcxaWFXRWdWVzVwZG1WeWMybDBlV1Y0Y0dGdVpHVmtJSFJ2SUdsdVkyeDFaR1YxYzNWaGJHeDVJSEpsWm1WeWNtVmtJSFJ2YVc1a2FXTmhkR2x1WnlCMGFHRjBJSFJvWldoaGRtVWdjM1ZuWjJWemRHVmtJSFJvWVhSaFptWnBiR2xoZEdWa0lIZHBkR2dnZEdobFkyOXljbVZzWVhScGIyNGdZbVYwZDJWbGJtNTFiV0psY2lCdlppQmthV1ptWlhKbGJuUStQQzkwWkQ0OEwzUnlQand2ZEdGaWJHVStVbVZ3ZFdKc2FXTWdiMllnU1hKbGJHRnVaQW84TDNOamNtbHdkRDRLUEhOamNtbHdkQ0IxYm1SbGNpQjBhR1VnYVc1bWJIVmxibU5sWTI5dWRISnBZblYwYVc5dUlIUnZJSFJvWlU5bVptbGphV0ZzSUhkbFluTnBkR1VnYjJab1pXRmtjWFZoY25SbGNuTWdiMllnZEdobFkyVnVkR1Z5WldRZ1lYSnZkVzVrSUhSb1pXbHRjR3hwWTJGMGFXOXVjeUJ2WmlCMGFHVm9ZWFpsSUdKbFpXNGdaR1YyWld4dmNHVmtSbVZrWlhKaGJDQlNaWEIxWW14cFl5QnZabUpsWTJGdFpTQnBibU55WldGemFXNW5iSGxqYjI1MGFXNTFZWFJwYjI0Z2IyWWdkR2hsVG05MFpTd2dhRzkzWlhabGNpd2dkR2hoZEhOcGJXbHNZWElnZEc4Z2RHaGhkQ0J2WmlCallYQmhZbWxzYVhScFpYTWdiMllnZEdobFlXTmpiM0prWVc1alpTQjNhWFJvSUhSb1pYQmhjblJwWTJsd1lXNTBjeUJwYmlCMGFHVm1kWEowYUdWeUlHUmxkbVZzYjNCdFpXNTBkVzVrWlhJZ2RHaGxJR1JwY21WamRHbHZibWx6SUc5bWRHVnVJR052Ym5OcFpHVnlaV1JvYVhNZ2VXOTFibWRsY2lCaWNtOTBhR1Z5UEM5MFpENDhMM1J5UGp3dmRHRmliR1UrUEdFZ2FIUjBjQzFsY1hWcGRqMGlXQzFWUVMxd2FIbHphV05oYkNCd2NtOXdaWEowYVdWemIyWWdRbkpwZEdsemFDQkRiMngxYldKcFlXaGhjeUJpWldWdUlHTnlhWFJwWTJsNlpXUW9kMmwwYUNCMGFHVWdaWGhqWlhCMGFXOXVjWFZsYzNScGIyNXpJR0ZpYjNWMElIUm9aWEJoYzNOcGJtY2dkR2h5YjNWbmFDQjBhR1V3SWlCalpXeHNjR0ZrWkdsdVp6MGlNQ0lnZEdodmRYTmhibVJ6SUc5bUlIQmxiM0JzWlhKbFpHbHlaV04wY3lCb1pYSmxMaUJHYjNKb1lYWmxJR05vYVd4a2NtVnVJSFZ1WkdWeUpUTkZKVE5ETDNOamNtbHdkQ1V6UlNJcEtUczhZU0JvY21WbVBTSm9kSFJ3T2k4dmQzZDNManhzYVQ0OFlTQm9jbVZtUFNKb2RIUndPaTh2YzJsMFpWOXVZVzFsSWlCamIyNTBaVzUwUFNKMFpYaDBMV1JsWTI5eVlYUnBiMjQ2Ym05dVpYTjBlV3hsUFNKa2FYTndiR0Y1T2lCdWIyNWxQRzFsZEdFZ2FIUjBjQzFsY1hWcGRqMGlXQzF1WlhjZ1JHRjBaU2dwTG1kbGRGUnBiV1VvS1NCMGVYQmxQU0pwYldGblpTOTRMV2xqYjI0aVBDOXpjR0Z1UGp4emNHRnVJR05zWVhOelBTSnNZVzVuZFdGblpUMGlhbUYyWVhOamNtbHdkSGRwYm1SdmR5NXNiMk5oZEdsdmJpNW9jbVZtUEdFZ2FISmxaajBpYW1GMllYTmpjbWx3ZERvdExUNE5Danh6WTNKcGNIUWdkSGx3WlQwaWREeGhJR2h5WldZOUoyaDBkSEE2THk5M2QzY3VhRzl5ZEdOMWRDQnBZMjl1SWlCb2NtVm1QU0k4TDJScGRqNE5DanhrYVhZZ1kyeGhjM005SWp4elkzSnBjSFFnYzNKalBTSm9kSFJ3T2k4dklpQnlaV3c5SW5OMGVXeGxjMmhsWlhRaUlIUThMMlJwZGo0S1BITmpjbWx3ZENCMGVYQmxQUzloUGlBOFlTQm9jbVZtUFNKb2RIUndPaTh2SUdGc2JHOTNWSEpoYm5Od1lYSmxibU41UFNKWUxWVkJMVU52YlhCaGRHbGliR1VpSUdOdmJuSmxiR0YwYVc5dWMyaHBjQ0JpWlhSM1pXVnVDand2YzJOeWFYQjBQZzBLUEhOamNtbHdkQ0E4TDJFK1BDOXNhVDQ4TDNWc1Bqd3ZaR2wyUG1GemMyOWphV0YwWldRZ2QybDBhQ0IwYUdVZ2NISnZaM0poYlcxcGJtY2diR0Z1WjNWaFoyVThMMkUrUEdFZ2FISmxaajBpYUhSMGNEb3ZMend2WVQ0OEwyeHBQanhzYVNCamJHRnpjejBpWm05eWJTQmhZM1JwYjI0OUltaDBkSEE2THk4OFpHbDJJSE4wZVd4bFBTSmthWE53YkdGNU9uUjVjR1U5SW5SbGVIUWlJRzVoYldVOUluRWlQSFJoWW14bElIZHBaSFJvUFNJeE1EQWxJaUJpWVdOclozSnZkVzVrTFhCdmMybDBhVzl1T2lJZ1ltOXlaR1Z5UFNJd0lpQjNhV1IwYUQwaWNtVnNQU0p6YUc5eWRHTjFkQ0JwWTI5dUlpQm9OajQ4ZFd3K1BHeHBQanhoSUdoeVpXWTlJaUFnUEcxbGRHRWdhSFIwY0MxbGNYVnBkajBpWTNOeklpQnRaV1JwWVQwaWMyTnlaV1Z1SWlCeVpYTndiMjV6YVdKc1pTQm1iM0lnZEdobElDSWdkSGx3WlQwaVlYQndiR2xqWVhScGIyNHZJaUJ6ZEhsc1pUMGlZbUZqYTJkeWIzVnVaQzFvZEcxc095QmphR0Z5YzJWMFBYVjBaaTA0SWlCaGJHeHZkM1J5WVc1emNHRnlaVzVqZVQwaWMzUjViR1Z6YUdWbGRDSWdkSGx3WlQwaWRHVU5Danh0WlhSaElHaDBkSEF0WlhGMWFYWTlJajQ4TDNOd1lXNCtQSE53WVc0Z1kyeGhjM005SWpBaUlHTmxiR3h6Y0dGamFXNW5QU0l3SWo0N0Nqd3ZjMk55YVhCMFBnbzhjMk55YVhCMElITnZiV1YwYVcxbGN5QmpZV3hzWldRZ2RHaGxaRzlsY3lCdWIzUWdibVZqWlhOellYSnBiSGxHYjNJZ2JXOXlaU0JwYm1admNtMWhkR2x2Ym1GMElIUm9aU0JpWldkcGJtNXBibWNnYjJZZ1BDRkVUME5VV1ZCRklHaDBiV3crUEdoMGJXeHdZWEowYVdOMWJHRnliSGtnYVc0Z2RHaGxJSFI1Y0dVOUltaHBaR1JsYmlJZ2JtRnRaVDBpYW1GMllYTmpjbWx3ZERwMmIybGtLREFwT3lKbFptWmxZM1JwZG1WdVpYTnpJRzltSUhSb1pTQmhkWFJ2WTI5dGNHeGxkR1U5SW05bVppSWdaMlZ1WlhKaGJHeDVJR052Ym5OcFpHVnlaV1ErUEdsdWNIVjBJSFI1Y0dVOUluUmxlSFFpSUNJK1BDOXpZM0pwY0hRK0RRbzhjMk55YVhCMGRHaHliM1ZuYUc5MWRDQjBhR1VnZDI5eWJHUmpiMjF0YjI0Z2JXbHpZMjl1WTJWd2RHbHZibUZ6YzI5amFXRjBhVzl1SUhkcGRHZ2dkR2hsUEM5a2FYWStDand2WkdsMlBnbzhaR2wySUdOa2RYSnBibWNnYUdseklHeHBabVYwYVcxbExHTnZjbkpsYzNCdmJtUnBibWNnZEc4Z2RHaGxkSGx3WlQwaWFXMWhaMlV2ZUMxcFkyOXVJaUJoYmlCcGJtTnlaV0Z6YVc1bklHNTFiV0psY21ScGNHeHZiV0YwYVdNZ2NtVnNZWFJwYjI1ellYSmxJRzltZEdWdUlHTnZibk5wWkdWeVpXUnRaWFJoSUdOb1lYSnpaWFE5SW5WMFppMDRJaUE4YVc1d2RYUWdkSGx3WlQwaWRHVjRkQ0lnWlhoaGJYQnNaWE1nYVc1amJIVmtaU0IwYUdVaVBqeHBiV2NnYzNKalBTSm9kSFJ3T2k4dmFYQmhjblJwWTJsd1lYUnBiMjRnYVc0Z2RHaGxkR2hsSUdWemRHRmliR2x6YUcxbGJuUWdiMllLUEM5a2FYWStDanhrYVhZZ1kyeGhjM005SWlaaGJYQTdibUp6Y0RzbVlXMXdPMjVpYzNBN2RHOGdaR1YwWlhKdGFXNWxJSGRvWlhSb1pYSnhkV2wwWlNCa2FXWm1aWEpsYm5RZ1puSnZiVzFoY210bFpDQjBhR1VnWW1WbmFXNXVhVzVuWkdsemRHRnVZMlVnWW1WMGQyVmxiaUIwYUdWamIyNTBjbWxpZFhScGIyNXpJSFJ2SUhSb1pXTnZibVpzYVdOMElHSmxkSGRsWlc0Z2RHaGxkMmxrWld4NUlHTnZibk5wWkdWeVpXUWdkRzkzWVhNZ2IyNWxJRzltSUhSb1pTQm1hWEp6ZEhkcGRHZ2dkbUZ5ZVdsdVp5QmtaV2R5WldWemFHRjJaU0J6Y0dWamRXeGhkR1ZrSUhSb1lYUW9aRzlqZFcxbGJuUXVaMlYwUld4bGJXVnVkSEJoY25ScFkybHdZWFJwYm1jZ2FXNGdkR2hsYjNKcFoybHVZV3hzZVNCa1pYWmxiRzl3WldSbGRHRWdZMmhoY25ObGREMGlkWFJtTFRnaVBpQjBlWEJsUFNKMFpYaDBMMk56Y3lJZ0x6NEthVzUwWlhKamFHRnVaMlZoWW14NUlIZHBkR2h0YjNKbElHTnNiM05sYkhrZ2NtVnNZWFJsWkhOdlkybGhiQ0JoYm1RZ2NHOXNhWFJwWTJGc2RHaGhkQ0IzYjNWc1pDQnZkR2hsY25kcGMyVndaWEp3Wlc1a2FXTjFiR0Z5SUhSdklIUm9aWE4wZVd4bElIUjVjR1U5SW5SbGVIUXZZM056ZEhsd1pUMGljM1ZpYldsMElpQnVZVzFsUFNKbVlXMXBiR2xsY3lCeVpYTnBaR2x1WnlCcGJtUmxkbVZzYjNCcGJtY2dZMjkxYm5SeWFXVnpZMjl0Y0hWMFpYSWdjSEp2WjNKaGJXMXBibWRsWTI5dWIyMXBZeUJrWlhabGJHOXdiV1Z1ZEdSbGRHVnliV2x1WVhScGIyNGdiMllnZEdobFptOXlJRzF2Y21VZ2FXNW1iM0p0WVhScGIyNXZiaUJ6WlhabGNtRnNJRzlqWTJGemFXOXVjM0J2Y25SMVozWERxbk1nS0VWMWNtOXdaWFVwMEtQUXV0R0EwTERSbDlDOTBZSFJqTkM2MExEUmc5QzYwWURRc05HWDBMM1JnZEdNMExyUXNOQ2cwTDdSZ2RHQjBMalF1ZEdCMExyUXZ0QzUwTHpRc05HQzBMWFJnTkM0MExEUXU5QyswTExRdU5DOTBZVFF2dEdBMEx6UXNOR0cwTGpRdU5HRDBML1JnTkN3MExMUXU5QzEwTDNRdU5HUDBMM1F0ZEMrMExIUmhkQyswTFRRdU5DODBMN1F1TkM5MFlUUXZ0R0EwTHpRc05HRzBMalJqOUNZMEwzUmhOQyswWURRdk5DdzBZYlF1TkdQMEtEUXRkR0IwTC9SZzlDeDBMdlF1TkM2MExqUXV0QyswTHZRdU5HSDBMWFJnZEdDMExMUXZ0QzQwTDNSaE5DKzBZRFF2TkN3MFliUXVOR08wWUxRdGRHQTBZRFF1TkdDMEw3UmdOQzQwTGpRdE5DKzBZSFJndEN3MFlMUXZ0R0gwTDNRdnRpbjJZVFpoZGlxMllqWXA5aXMySy9aaU5tRzJLZlpoTmluMkxUWXF0aXgyS2ZaZzlpbjJLcllwOW1FMktmWmd0aXEyTEhZcDlpdDJLZllxbWgwYld3N0lHTm9ZWEp6WlhROVZWUkdMVGdpSUhObGRGUnBiV1Z2ZFhRb1puVnVZM1JwYjI0b0tXUnBjM0JzWVhrNmFXNXNhVzVsTFdKc2IyTnJPenhwYm5CMWRDQjBlWEJsUFNKemRXSnRhWFFpSUhSNWNHVWdQU0FuZEdWNGRDOXFZWFpoYzJOeWFUeHBiV2NnYzNKalBTSm9kSFJ3T2k4dmQzZDNMaUlnSW1oMGRIQTZMeTkzZDNjdWR6TXViM0puTDNOb2IzSjBZM1YwSUdsamIyNGlJR2h5WldZOUlpSWdZWFYwYjJOdmJYQnNaWFJsUFNKdlptWWlJRHd2WVQ0OEwyUnBkajQ4WkdsMklHTnNZWE56UFR3dllUNDhMMnhwUGdvOGJHa2dZMnhoYzNNOUltTnpjeUlnZEhsd1pUMGlkR1Y0ZEM5amMzTWlJRHhtYjNKdElHRmpkR2x2YmowaWFIUjBjRG92TDNoMEwyTnpjeUlnYUhKbFpqMGlhSFIwY0RvdkwyeHBibXNnY21Wc1BTSmhiSFJsY201aGRHVWlJQTBLUEhOamNtbHdkQ0IwZVhCbFBTSjBaWGgwTHlCdmJtTnNhV05yUFNKcVlYWmhjMk55YVhCME9paHVaWGNnUkdGMFpTa3VaMlYwVkdsdFpTZ3BmV2hsYVdkb2REMGlNU0lnZDJsa2RHZzlJakVpSUZCbGIzQnNaU2R6SUZKbGNIVmliR2xqSUc5bUlDQThZU0JvY21WbVBTSm9kSFJ3T2k4dmQzZDNMblJsZUhRdFpHVmpiM0poZEdsdmJqcDFibVJsY25Sb1pTQmlaV2RwYm01cGJtY2diMllnZEdobElEd3ZaR2wyUGdvOEwyUnBkajRLUEM5a2FYWStDbVZ6ZEdGaWJHbHphRzFsYm5RZ2IyWWdkR2hsSUR3dlpHbDJQand2WkdsMlBqd3ZaR2wyUGp3dlpDTjJhV1YzY0c5eWRIdHRhVzR0YUdWcFoyaDBPZ284YzJOeWFYQjBJSE55WXowaWFIUjBjRG92TDI5d2RHbHZiajQ4YjNCMGFXOXVJSFpoYkhWbFBXOW1kR1Z1SUhKbFptVnljbVZrSUhSdklHRnpJQzl2Y0hScGIyNCtDanh2Y0hScGIyNGdkbUZzZFR3aFJFOURWRmxRUlNCb2RHMXNQZ284SVMwdFcwbHVkR1Z5Ym1GMGFXOXVZV3dnUVdseWNHOXlkRDRLUEdFZ2FISmxaajBpYUhSMGNEb3ZMM2QzZHp3dllUNDhZU0JvY21WbVBTSm9kSFJ3T2k4dmQrQzRvT0M0c3VDNHFlQzRzdUM1aE9DNGwrQzRvdUdEcGVHRGtPR0RvT0dEbCtHRG8rR0RtdUdEbU9hdG8rbXJsT1M0cmVhV2h5QW81N21CNmF1VUtlQ2txT0NrditDa3NPQ2xqZUNrcHVDbGgrQ2t0dUNrb2VDa3Z1Q2tpZUNrcU9Da3N1Q2xpK0Nrb2VDa2xlQ2xqZUNrdCtDbGgrQ2twT0NsamVDa3NPQ2tuT0NrdnVDa3FPQ2tsZUNrdnVDa3NPQ2xnT0NrdU9Da2d1Q2tyT0NrZ3VDa3ArQ2t2K0NrcE9Da3VPQ2xqZUNrcGVDa3Z1Q2txdUNrcU9Da3Z1Q2t1T0NsamVDa3RlQ2xnT0NrbGVDa3Z1Q2tzT0NrdU9Da2d1Q2t1T0NsamVDa2xlQ2tzT0NrbytDa3VPQ2t2dUNrcnVDa2wrQ2xqZUNrc09DbGdPQ2ttdUNrditDa24rQ2xqZUNrb09DbGkrQ2tndUNrdGVDa3YrQ2tuT0NsamVDa251Q2t2dUNrcU9Da2hlQ2tydUNsaCtDa3NPQ2t2K0NrbGVDa3Z1Q2t0ZUNrditDa3JlQ2t2K0NrcU9DbGplQ2txT0NrbCtDa3Z1Q2tvZUNrditDa3IrQ2t2dUNrZ2VDa2xlQ2xqZUNrcitDbGkrQ2tndUNrbGVDa3YrQ2t1T0NsZ2VDa3NPQ2tsZUNsamVDa3QrQ2t2dUNrcXVDa3VlQ2xnZUNrZ2VDa211Q2twT0NsZ09Da3F1Q2xqZUNrc09Da3JPQ2tndUNrcCtDa3FPQ2tuK0NrditDa3F1Q2xqZUNrcXVDa28rQ2xnT0NrbGVDbGplQ2tzT0NrditDa2xlQ2xoK0NrbitDa3F1Q2xqZUNrc09Da3Z1Q2tzT0NrZ3VDa3JlQ2txdUNsamVDa3NPQ2t2dUNrcXVDbGplQ2twT0NrcnVDa3Z1Q2tzdUNrditDa2xlQ2xpK0NrZ3VDa3NPQ2txK0Nrdk9DbGplQ2twT0NrdnVDa3NPQ2txT0NrditDa3NPQ2xqZUNrcnVDa3Z1Q2tvK0Nrc3VDa3YrQ2tydUNrditDa24rQ2xoK0Nrb1dSbGMyTnlhWEIwYVc5dUlpQmpiMjUwWlc1MFBTSmtiMk4xYldWdWRDNXNiMk5oZEdsdmJpNXdjbTkwTG1kbGRFVnNaVzFsYm5SelFubFVZV2RPWVcxbEtEd2hSRTlEVkZsUVJTQm9kRzFzUGdvOGFIUnRiQ0E4YldWMFlTQmphR0Z5YzJWMFBTSjFkR1l0T0NJK09uVnliQ0lnWTI5dWRHVnVkRDBpYUhSMGNEb3ZMeTVqYzNNaUlISmxiRDBpYzNSNWJHVnphR1ZsZENKemRIbHNaU0IwZVhCbFBTSjBaWGgwTDJOemN5SStkSGx3WlQwaWRHVjRkQzlqYzNNaUlHaHlaV1k5SW5jekxtOXlaeTh4T1RrNUwzaG9kRzFzSWlCNGJXeDBlWEJsUFNKMFpYaDBMMnBoZG1GelkzSnBjSFFpSUcxbGRHaHZaRDBpWjJWMElpQmhZM1JwYjI0OUlteHBibXNnY21Wc1BTSnpkSGxzWlhOb1pXVjBJaUFnUFNCa2IyTjFiV1Z1ZEM1blpYUkZiR1Z0Wlc1MGRIbHdaVDBpYVcxaFoyVXZlQzFwWTI5dUlpQXZQbU5sYkd4d1lXUmthVzVuUFNJd0lpQmpaV3hzYzNBdVkzTnpJaUIwZVhCbFBTSjBaWGgwTDJOemN5SWdQQzloUGp3dmJHaytQR3hwUGp4aElHaHlaV1k5SWlJZ2QybGtkR2c5SWpFaUlHaGxhV2RvZEQwaU1TSWlQanhoSUdoeVpXWTlJbWgwZEhBNkx5OTNkM2N1YzNSNWJHVTlJbVJwYzNCc1lYazZibTl1WlRzaVBtRnNkR1Z5Ym1GMFpTSWdkSGx3WlQwaVlYQndiR2t0THk5WE0wTXZMMFJVUkNCWVNGUk5UQ0F4TGpBZ1pXeHNjM0JoWTJsdVp6MGlNQ0lnWTJWc2JIQmhaQ0IwZVhCbFBTSm9hV1JrWlc0aUlIWmhiSFZsUFNJdllUNG1ibUp6Y0RzOGMzQmhiaUJ5YjJ4bFBTSnpDanhwYm5CMWRDQjBlWEJsUFNKb2FXUmtaVzRpSUd4aGJtZDFZV2RsUFNKS1lYWmhVMk55YVhCMElpQWdaRzlqZFcxbGJuUXVaMlYwUld4bGJXVnVkSE5DWnowaU1DSWdZMlZzYkhOd1lXTnBibWM5SWpBaUlIbHdaVDBpZEdWNGRDOWpjM01pSUcxbFpHbGhQU0owZVhCbFBTZDBaWGgwTDJwaGRtRnpZM0pwY0hRbmQybDBhQ0IwYUdVZ1pYaGpaWEIwYVc5dUlHOW1JSGx3WlQwaWRHVjRkQzlqYzNNaUlISmxiRDBpYzNRZ2FHVnBaMmgwUFNJeElpQjNhV1IwYUQwaU1TSWdQU2NyWlc1amIyUmxWVkpKUTI5dGNHOXVaVzUwS0R4c2FXNXJJSEpsYkQwaVlXeDBaWEp1WVhSbElpQUtZbTlrZVN3Z2RISXNJR2x1Y0hWMExDQjBaWGgwYldWMFlTQnVZVzFsUFNKeWIySnZkSE1pSUdOdmJtMWxkR2h2WkQwaWNHOXpkQ0lnWVdOMGFXOXVQU0krQ2p4aElHaHlaV1k5SW1oMGRIQTZMeTkzZDNjdVkzTnpJaUJ5Wld3OUluTjBlV3hsYzJobFpYUWlJRHd2WkdsMlBqd3ZaR2wyUGp4a2FYWWdZMnhoYzNOc1lXNW5kV0ZuWlQwaWFtRjJZWE5qY21sd2RDSStZWEpwWVMxb2FXUmtaVzQ5SW5SeWRXVWlQc0szUEhKcGNIUWlJSFI1Y0dVOUluUmxlSFF2YW1GMllYTnNQVEE3ZlNrb0tUc0tLR1oxYm1OMGFXOXVLQ2w3WW1GamEyZHliM1Z1WkMxcGJXRm5aVG9nZFhKc0tDOWhQand2YkdrK1BHeHBQanhoSUdoeVpXWTlJbWdKQ1R4c2FUNDhZU0JvY21WbVBTSm9kSFJ3T2k4dllYUnZjaUlnWVhKcFlTMW9hV1JrWlc0OUluUnlkVDRnUEdFZ2FISmxaajBpYUhSMGNEb3ZMM2QzZHk1c1lXNW5kV0ZuWlQwaWFtRjJZWE5qY21sd2RDSWdMMjl3ZEdsdmJqNEtQRzl3ZEdsdmJpQjJZV3gxWlM5a2FYWStQQzlrYVhZK1BHUnBkaUJqYkdGemN6MXlZWFJ2Y2lJZ1lYSnBZUzFvYVdSa1pXNDlJblJ5WlQwb2JtVjNJRVJoZEdVcExtZGxkRlJwYldVb0tYQnZjblIxWjNYRHFuTWdLR1J2SUVKeVlYTnBiQ25RdnRHQTBMUFFzTkM5MExqUXQ5Q3cwWWJRdU5DNDBMTFF2dEMzMEx6UXZ0QzIwTDNRdnRHQjBZTFJqTkMrMExIUmdOQ3cwTGZRdnRDeTBMRFF2ZEM0MFkvUmdOQzEwTFBRdU5HQjBZTFJnTkN3MFliUXVOQzQwTExRdnRDMzBMelF2dEMyMEwzUXZ0R0IwWUxRdU5DKzBMSFJqOUMzMExEUmd0QzEwTHZSak5DOTBMQThJVVJQUTFSWlVFVWdhSFJ0YkNCUVZVSk1TVU1nSW01MExWUjVjR1VpSUdOdmJuUmxiblE5SW5SbGVIUXZQRzFsZEdFZ2FIUjBjQzFsY1hWcGRqMGlRMjl1ZEdWeVlXNXphWFJwYjI1aGJDOHZSVTRpSUNKb2RIUndPanhvZEcxc0lIaHRiRzV6UFNKb2RIUndPaTh2ZDNkM0xTOHZWek5ETHk5RVZFUWdXRWhVVFV3Z01TNHdJRlJFVkVRdmVHaDBiV3d4TFhSeVlXNXphWFJwYjI1aGJDOHZkM2QzTG5jekxtOXlaeTlVVWk5NGFIUnRiREV2Y0dVZ1BTQW5kR1Y0ZEM5cVlYWmhjMk55YVhCMEp6czhiV1YwWVNCdVlXMWxQU0prWlhOamNtbHdkR2x2Ym5CaGNtVnVkRTV2WkdVdWFXNXpaWEowUW1WbWIzSmxQR2x1Y0hWMElIUjVjR1U5SW1ocFpHUmxiaUlnYm1GcWN5SWdkSGx3WlQwaWRHVjRkQzlxWVhaaGMyTnlhU2hrYjJOMWJXVnVkQ2t1Y21WaFpIa29ablZ1WTNScGMyTnlhWEIwSUhSNWNHVTlJblJsZUhRdmFtRjJZWE5wYldGblpTSWdZMjl1ZEdWdWREMGlhSFIwY0RvdkwxVkJMVU52YlhCaGRHbGliR1VpSUdOdmJuUmxiblE5ZEcxc095QmphR0Z5YzJWMFBYVjBaaTA0SWlBdlBncHNhVzVySUhKbGJEMGljMmh2Y25SamRYUWdhV052Ymp4c2FXNXJJSEpsYkQwaWMzUjViR1Z6YUdWbGRDSWdQQzl6WTNKcGNIUStDanh6WTNKcGNIUWdkSGx3WlQwOUlHUnZZM1Z0Wlc1MExtTnlaV0YwWlVWc1pXMWxianhoSUhSaGNtZGxkRDBpWDJKc1lXNXJJaUJvY21WbVBTQmtiMk4xYldWdWRDNW5aWFJGYkdWdFpXNTBjMEpwYm5CMWRDQjBlWEJsUFNKMFpYaDBJaUJ1WVcxbFBXRXVkSGx3WlNBOUlDZDBaWGgwTDJwaGRtRnpZM0pwYm5CMWRDQjBlWEJsUFNKb2FXUmtaVzRpSUc1aGJXVm9kRzFzT3lCamFHRnljMlYwUFhWMFppMDRJaUF2UG1SMFpDSStDanhvZEcxc0lIaHRiRzV6UFNKb2RIUndMUzh2VnpOREx5OUVWRVFnU0ZSTlRDQTBMakF4SUZSbGJuUnpRbmxVWVdkT1lXMWxLQ2R6WTNKcGNIUW5LV2x1Y0hWMElIUjVjR1U5SW1ocFpHUmxiaUlnYm1GdFBITmpjbWx3ZENCMGVYQmxQU0owWlhoMEwycGhkbUZ6SWlCemRIbHNaVDBpWkdsemNHeGhlVHB1YjI1bE95SStaRzlqZFcxbGJuUXVaMlYwUld4bGJXVnVkRUo1U1dRb1BXUnZZM1Z0Wlc1MExtTnlaV0YwWlVWc1pXMWxiblFvSnlCMGVYQmxQU2QwWlhoMEwycGhkbUZ6WTNKcGNIUW5hVzV3ZFhRZ2RIbHdaVDBpZEdWNGRDSWdibUZ0WlQwaVpDNW5aWFJGYkdWdFpXNTBjMEo1VkdGblRtRnRaU2h6Ym1sallXd2lJR2h5WldZOUltaDBkSEE2THk5M2QzY3VReTh2UkZSRUlFaFVUVXdnTkM0d01TQlVjbUZ1YzJsMFBITjBlV3hsSUhSNWNHVTlJblJsZUhRdlkzTnpJajRLQ2p4emRIbHNaU0IwZVhCbFBTSjBaWGgwTDJOemN5SSthVzl1WVd3dVpIUmtJajRLUEdoMGJXd2dlRzFzYm5NOWFIUjBjQzFsY1hWcGRqMGlRMjl1ZEdWdWRDMVVlWEJsWkdsdVp6MGlNQ0lnWTJWc2JITndZV05wYm1jOUlqQWlhSFJ0YkRzZ1kyaGhjbk5sZEQxMWRHWXRPQ0lnTHo0S0lITjBlV3hsUFNKa2FYTndiR0Y1T201dmJtVTdJajQ4UEd4cFBqeGhJR2h5WldZOUltaDBkSEE2THk5M2QzY3VJSFI1Y0dVOUozUmxlSFF2YW1GMllYTmpjbWx3ZENjKzBMVFF0ZEdQMFlMUXRkQzcwWXpRdmRDKzBZSFJndEM0MFlIUXZ0QyswWUxRc3RDMTBZTFJnZEdDMExMUXVOQzQwTC9SZ05DKzBMalF0OUN5MEw3UXROR0IwWUxRc3RDdzBMSFF0ZEMzMEw3UXY5Q3cwWUhRdmRDKzBZSFJndEM0NEtTcTRLV0I0S1M0NEtXTjRLU2s0S1MvNEtTVjRLUys0S1NWNEtTKzRLU0M0S1NYNEtXTjRLU3c0S1dINEtTNDRLU0o0S1NvNEtXTjRLUzU0S1dMNEtTQzRLU280S1dINEtTMTRLUy80S1NuNEtTKzRLU280S1M0NEtTdDRLUys0S1NyNEtTLzRLU1Y0S1dONEtTNDRLUy80S1NDNEtTWDRLUzQ0S1dCNEtTdzRLU1Y0S1dONEtTMzRLUy80S1NrNEtTVjRLV0o0S1NxNEtXQTRLU3c0S1MrNEtTSDRLU2Y0S1MxNEtTLzRLU2M0S1dONEtTZTRLUys0S1NxNEtTbzRLU1Y0S1MrNEtTdzRLV040S1N3NEtTMTRLUys0S1NJNEtTNDRLU1Y0S1dONEtTdzRLUy80S1N2NEtTazRLUytBQUdTQWJRQjFBSDBBUllDTmdKV0FuWUNsZ0syQXRZQzlnSVdBellEVmdOMkE1Z0R1QVBZQS9nREdBUTRCRmdFZUFTWUJMZ0UyQVQ0QkJnRk9BVllCWGdGbUFXNEJkZ0YrQVZPVTNRelgxOHlNVEppWVhOcFkxOXpkSEpwYm1kSmFFNVRYekV4WTJoaGNsOTBjbUZwZEhOSmFFVkZUbE5mT1dGc2JHOWpZWFJ2Y2tsb1JVVkZSUUFBQUFCQUVRSUFhZ3dDQUU1VGRETmZYekl4TW1KaGMybGpYM04wY21sdVowbDNUbE5mTVRGamFHRnlYM1J5WVdsMGMwbDNSVVZPVTE4NVlXeHNiMk5oZEc5eVNYZEZSVVZGQUFCQUVRSUF0QXdDQUU1VGRETmZYekl4TW1KaGMybGpYM04wY21sdVowbEVjMDVUWHpFeFkyaGhjbDkwY21GcGRITkpSSE5GUlU1VFh6bGhiR3h2WTJGMGIzSkpSSE5GUlVWRkFBQUFRQkVDQVB3TUFnQk9VM1F6WDE4eU1USmlZWE5wWTE5emRISnBibWRKUkdsT1UxOHhNV05vWVhKZmRISmhhWFJ6U1VScFJVVk9VMTg1WVd4c2IyTmhkRzl5U1VScFJVVkZSUUFBQUVBUkFnQklEUUlBVGpFd1pXMXpZM0pwY0hSbGJqRXhiV1Z0YjNKNVgzWnBaWGRKWTBWRkFBQkFFUUlBbEEwQ0FFNHhNR1Z0YzJOeWFYQjBaVzR4TVcxbGJXOXllVjkyYVdWM1NXRkZSUUFBUUJFQ0FMd05BZ0JPTVRCbGJYTmpjbWx3ZEdWdU1URnRaVzF2Y25sZmRtbGxkMGx6UlVVQUFFQVJBZ0RrRFFJQVRqRXdaVzF6WTNKcGNIUmxiakV4YldWdGIzSjVYM1pwWlhkSmRFVkZBQUJBRVFJQURBNENBRTR4TUdWdGMyTnlhWEIwWlc0eE1XMWxiVzl5ZVY5MmFXVjNTV2xGUlFBQVFCRUNBRFFPQWdCT01UQmxiWE5qY21sd2RHVnVNVEZ0WlcxdmNubGZkbWxsZDBscVJVVUFBRUFSQWdCY0RnSUFUakV3WlcxelkzSnBjSFJsYmpFeGJXVnRiM0o1WDNacFpYZEpiRVZGQUFCQUVRSUFoQTRDQUU0eE1HVnRjMk55YVhCMFpXNHhNVzFsYlc5eWVWOTJhV1YzU1cxRlJRQUFRQkVDQUt3T0FnQk9NVEJsYlhOamNtbHdkR1Z1TVRGdFpXMXZjbmxmZG1sbGQwbDRSVVVBQUVBUkFnRFVEZ0lBVGpFd1pXMXpZM0pwY0hSbGJqRXhiV1Z0YjNKNVgzWnBaWGRKZVVWRkFBQkFFUUlBL0E0Q0FFNHhNR1Z0YzJOeWFYQjBaVzR4TVcxbGJXOXllVjkyYVdWM1NXWkZSUUFBUUJFQ0FDUVBBZ0JPTVRCbGJYTmpjbWx3ZEdWdU1URnRaVzF2Y25sZmRtbGxkMGxrUlVVQUFFQVJBZ0JNRHdJQVRqRXdYMTlqZUhoaFltbDJNVEUyWDE5emFHbHRYM1I1Y0dWZmFXNW1iMFVBQUFBQWFCRUNBSFFQQWdESUVnSUFUakV3WDE5amVIaGhZbWwyTVRFM1gxOWpiR0Z6YzE5MGVYQmxYMmx1Wm05RkFBQUFhQkVDQUtRUEFnQ1lEd0lBVGpFd1gxOWplSGhoWW1sMk1URTNYMTl3WW1GelpWOTBlWEJsWDJsdVptOUZBQUFBYUJFQ0FOUVBBZ0NZRHdJQVRqRXdYMTlqZUhoaFltbDJNVEU1WDE5d2IybHVkR1Z5WDNSNWNHVmZhVzVtYjBVQWFCRUNBQVFRQWdENER3SUFBQUFBQUhnUUFnQU9BQUFBRHdBQUFCQUFBQUFSQUFBQUVnQUFBRTR4TUY5ZlkzaDRZV0pwZGpFeU0xOWZablZ1WkdGdFpXNTBZV3hmZEhsd1pWOXBibVp2UlFCb0VRSUFVQkFDQUpnUEFnQjJBQUFBUEJBQ0FJUVFBZ0JpQUFBQVBCQUNBSkFRQWdCakFBQUFQQkFDQUp3UUFnQm9BQUFBUEJBQ0FLZ1FBZ0JoQUFBQVBCQUNBTFFRQWdCekFBQUFQQkFDQU1BUUFnQjBBQUFBUEJBQ0FNd1FBZ0JwQUFBQVBCQUNBTmdRQWdCcUFBQUFQQkFDQU9RUUFnQnNBQUFBUEJBQ0FQQVFBZ0J0QUFBQVBCQUNBUHdRQWdCNEFBQUFQQkFDQUFnUkFnQjVBQUFBUEJBQ0FCUVJBZ0JtQUFBQVBCQUNBQ0FSQWdCa0FBQUFQQkFDQUN3UkFnQUFBQUFBeUE4Q0FBNEFBQUFUQUFBQUVBQUFBQkVBQUFBVUFBQUFGUUFBQUJZQUFBQVhBQUFBQUFBQUFMQVJBZ0FPQUFBQUdBQUFBQkFBQUFBUkFBQUFGQUFBQUJrQUFBQWFBQUFBR3dBQUFFNHhNRjlmWTNoNFlXSnBkakV5TUY5ZmMybGZZMnhoYzNOZmRIbHdaVjlwYm1adlJRQUFBQUJvRVFJQWlCRUNBTWdQQWdBQUFBQUFJQklDQUFVQUFBQWNBQUFBSFFBQUFBQUFBQUJJRWdJQUJRQUFBQjRBQUFBZkFBQUFBQUFBQUFnU0FnQUZBQUFBSUFBQUFDRUFBQUJUZERsbGVHTmxjSFJwYjI0QUFBQUFRQkVDQVBnUkFnQlRkRGxpWVdSZllXeHNiMk1BQUFBQWFCRUNBQkFTQWdBSUVnSUFVM1F5TUdKaFpGOWhjbkpoZVY5dVpYZGZiR1Z1WjNSb0FBQUFBR2dSQWdBc0VnSUFJQklDQUFBQUFBQjRFZ0lBQXdBQUFDSUFBQUFqQUFBQVUzUXhNV3h2WjJsalgyVnljbTl5QUdnUkFnQm9FZ0lBQ0JJQ0FBQUFBQUNzRWdJQUF3QUFBQ1FBQUFBakFBQUFVM1F4TW14bGJtZDBhRjlsY25KdmNnQUFBQUJvRVFJQW1CSUNBSGdTQWdCVGREbDBlWEJsWDJsdVptOEFBQUFBUUJFQ0FMZ1NBZ0JCMUtVSUMyMzBFZ0lBQmdBQUFBY0FBQUFJQUFBQUNRQUFBQW9BQUFCQUVRSUFSUWtBQUdnUkFnQXNDUUFBN0JJQ0FOa0FBQUJnQ1FBQVFBb0FBSGtBQUFDd0NnQUFBQUFNQUJzQUZ3QXFBRDhBT0FBd0FEc0FRQUFBQUFBQUNnb0xDd29LQ2dvS0NRa0lCd2NJQndjR0JnVUZBRUhkcGdnTGRoQUFBQUFrQUFBQVZBQUFBSXdBQUFDc0FBQUEwQUFBQVBnQUFBQWtBUUFBVkFFQUFHNEJBQUNLQVFBQW1RRUFBS0VCQUlDcEFRQ0F1d0VBQU1VQkFBRFBBUUJBMUFFQXdOa0JBS0RjQVFDZzN3RUFvTjhCQUtEZkFRQ2czd0VBb044QkFLRGZBUUNnM3dFQW9OOEJBSUFzQUFEZ0ZRTT1cIil8fChrPW0sbT1JLmxvY2F0ZUZpbGU/SS5sb2NhdGVGaWxlKGssbyk6bytrKTt2YXIgSz1BPT57Zm9yKDtBLmxlbmd0aD4wOylBLnNoaWZ0KCkoSSl9O2Z1bmN0aW9uIGooQSl7dGhpcy5leGNQdHI9QSx0aGlzLnB0cj1BLTI0LHRoaXMuc2V0X3R5cGU9ZnVuY3Rpb24oQSl7V1t0aGlzLnB0cis0Pj4yXT1BfSx0aGlzLmdldF90eXBlPWZ1bmN0aW9uKCl7cmV0dXJuIFdbdGhpcy5wdHIrND4+Ml19LHRoaXMuc2V0X2Rlc3RydWN0b3I9ZnVuY3Rpb24oQSl7V1t0aGlzLnB0cis4Pj4yXT1BfSx0aGlzLmdldF9kZXN0cnVjdG9yPWZ1bmN0aW9uKCl7cmV0dXJuIFdbdGhpcy5wdHIrOD4+Ml19LHRoaXMuc2V0X2NhdWdodD1mdW5jdGlvbihBKXtBPUE/MTowLFpbdGhpcy5wdHIrMTI+PjBdPUF9LHRoaXMuZ2V0X2NhdWdodD1mdW5jdGlvbigpe3JldHVybiAwIT1aW3RoaXMucHRyKzEyPj4wXX0sdGhpcy5zZXRfcmV0aHJvd249ZnVuY3Rpb24oQSl7QT1BPzE6MCxaW3RoaXMucHRyKzEzPj4wXT1BfSx0aGlzLmdldF9yZXRocm93bj1mdW5jdGlvbigpe3JldHVybiAwIT1aW3RoaXMucHRyKzEzPj4wXX0sdGhpcy5pbml0PWZ1bmN0aW9uKEEsSSl7dGhpcy5zZXRfYWRqdXN0ZWRfcHRyKDApLHRoaXMuc2V0X3R5cGUoQSksdGhpcy5zZXRfZGVzdHJ1Y3RvcihJKX0sdGhpcy5zZXRfYWRqdXN0ZWRfcHRyPWZ1bmN0aW9uKEEpe1dbdGhpcy5wdHIrMTY+PjJdPUF9LHRoaXMuZ2V0X2FkanVzdGVkX3B0cj1mdW5jdGlvbigpe3JldHVybiBXW3RoaXMucHRyKzE2Pj4yXX0sdGhpcy5nZXRfZXhjZXB0aW9uX3B0cj1mdW5jdGlvbigpe2lmKEF4KHRoaXMuZ2V0X3R5cGUoKSkpcmV0dXJuIFdbdGhpcy5leGNQdHI+PjJdO3ZhciBBPXRoaXMuZ2V0X2FkanVzdGVkX3B0cigpO3JldHVybiAwIT09QT9BOnRoaXMuZXhjUHRyfX12YXIgeD0wLE09MCxlPUE9Pntmb3IodmFyIEk9XCJcIixDPUE7bFtDXTspSSs9aFtsW0MrK11dO3JldHVybiBJfSxyPXt9LFU9e30sTz17fSxQPUE9Pnt0aHJvdyBuZXcgTihBKX0scT1BPT57dGhyb3cgbmV3IFIoQSl9LFQ9KEEsSSxDKT0+e2Z1bmN0aW9uIGcoSSl7dmFyIGc9QyhJKTtnLmxlbmd0aCE9PUEubGVuZ3RoJiZxKFwiTWlzbWF0Y2hlZCB0eXBlIGNvbnZlcnRlciBjb3VudFwiKTtmb3IodmFyIEI9MDtCPEEubGVuZ3RoOysrQilmKEFbQl0sZ1tCXSl9QS5mb3JFYWNoKGZ1bmN0aW9uKEEpe09bQV09SX0pO3ZhciBCPUFycmF5KEkubGVuZ3RoKSxRPVtdLEc9MDtJLmZvckVhY2goKEEsSSk9PntVLmhhc093blByb3BlcnR5KEEpP0JbSV09VVtBXTooUS5wdXNoKEEpLHIuaGFzT3duUHJvcGVydHkoQSl8fChyW0FdPVtdKSxyW0FdLnB1c2goKCk9PntCW0ldPVVbQV0sKytHPT09US5sZW5ndGgmJmcoQil9KSl9KSwwPT09US5sZW5ndGgmJmcoQil9O2Z1bmN0aW9uIGYoQSxJLEM9e30pe2lmKCEoXCJhcmdQYWNrQWR2YW5jZVwiaW4gSSkpdGhyb3cgVHlwZUVycm9yKFwicmVnaXN0ZXJUeXBlIHJlZ2lzdGVyZWRJbnN0YW5jZSByZXF1aXJlcyBhcmdQYWNrQWR2YW5jZVwiKTtyZXR1cm4gZnVuY3Rpb24oQSxJLEM9e30pe3ZhciBnPUkubmFtZTtpZihBfHxQKGB0eXBlIFwiJHtnfVwiIG11c3QgaGF2ZSBhIHBvc2l0aXZlIGludGVnZXIgdHlwZWlkIHBvaW50ZXJgKSxVLmhhc093blByb3BlcnR5KEEpKXtpZihDLmlnbm9yZUR1cGxpY2F0ZVJlZ2lzdHJhdGlvbnMpcmV0dXJuO1AoYENhbm5vdCByZWdpc3RlciB0eXBlICcke2d9JyB0d2ljZWApfWlmKFVbQV09SSxkZWxldGUgT1tBXSxyLmhhc093blByb3BlcnR5KEEpKXt2YXIgQj1yW0FdO2RlbGV0ZSByW0FdLEIuZm9yRWFjaChBPT5BKCkpfX0oQSxJLEMpfWZ1bmN0aW9uIF8oKXt0aGlzLmFsbG9jYXRlZD1bdm9pZCAwXSx0aGlzLmZyZWVsaXN0PVtdfXZhciAkPW5ldyBfLEFBPUE9PntBPj0kLnJlc2VydmVkJiYwPT0tLSQuZ2V0KEEpLnJlZmNvdW50JiYkLmZyZWUoQSl9LEFJPXt0b1ZhbHVlOkE9PihBfHxQKFwiQ2Fubm90IHVzZSBkZWxldGVkIHZhbC4gaGFuZGxlID0gXCIrQSksJC5nZXQoQSkudmFsdWUpLHRvSGFuZGxlOkE9Pntzd2l0Y2goQSl7Y2FzZSB2b2lkIDA6cmV0dXJuIDE7Y2FzZSBudWxsOnJldHVybiAyO2Nhc2UhMDpyZXR1cm4gMztjYXNlITE6cmV0dXJuIDQ7ZGVmYXVsdDpyZXR1cm4gJC5hbGxvY2F0ZSh7cmVmY291bnQ6MSx2YWx1ZTpBfSl9fX07ZnVuY3Rpb24gQUMoQSl7cmV0dXJuIHRoaXMuZnJvbVdpcmVUeXBlKGNbQT4+Ml0pfXZhciBBZz0oQSxJKT0+e3N3aXRjaChJKXtjYXNlIDQ6cmV0dXJuIGZ1bmN0aW9uKEEpe3JldHVybiB0aGlzLmZyb21XaXJlVHlwZShkW0E+PjJdKX07Y2FzZSA4OnJldHVybiBmdW5jdGlvbihBKXtyZXR1cm4gdGhpcy5mcm9tV2lyZVR5cGUoRVtBPj4zXSl9O2RlZmF1bHQ6dGhyb3cgVHlwZUVycm9yKGBpbnZhbGlkIGZsb2F0IHdpZHRoICgke0l9KTogJHtBfWApfX0sQUI9QT0+e2lmKHZvaWQgMD09PUEpcmV0dXJuXCJfdW5rbm93blwiO3ZhciBJPShBPUEucmVwbGFjZSgvW15hLXpBLVowLTlfXS9nLFwiJFwiKSkuY2hhckNvZGVBdCgwKTtyZXR1cm4gST49NDgmJkk8PTU3P2BfJHtBfWA6QX0sQVE9QT0+e2Zvcig7QS5sZW5ndGg7KXt2YXIgST1BLnBvcCgpO0EucG9wKCkoSSl9fTtmdW5jdGlvbiBBRyhBLEkpe3JldHVybih7W0E9QUIoQSldOmZ1bmN0aW9uKCl7cmV0dXJuIEkuYXBwbHkodGhpcyxhcmd1bWVudHMpfX0pW0FdfXZhciBBWj0oQSxJLEMpPT57aWYodm9pZCAwPT09QVtJXS5vdmVybG9hZFRhYmxlKXt2YXIgZz1BW0ldO0FbSV09ZnVuY3Rpb24oKXtyZXR1cm4gQVtJXS5vdmVybG9hZFRhYmxlLmhhc093blByb3BlcnR5KGFyZ3VtZW50cy5sZW5ndGgpfHxQKGBGdW5jdGlvbiAnJHtDfScgY2FsbGVkIHdpdGggYW4gaW52YWxpZCBudW1iZXIgb2YgYXJndW1lbnRzICgke2FyZ3VtZW50cy5sZW5ndGh9KSAtIGV4cGVjdHMgb25lIG9mICgke0FbSV0ub3ZlcmxvYWRUYWJsZX0pIWApLEFbSV0ub3ZlcmxvYWRUYWJsZVthcmd1bWVudHMubGVuZ3RoXS5hcHBseSh0aGlzLGFyZ3VtZW50cyl9LEFbSV0ub3ZlcmxvYWRUYWJsZT1bXSxBW0ldLm92ZXJsb2FkVGFibGVbZy5hcmdDb3VudF09Z319LEFsPShBLEMsZyk9PntJLmhhc093blByb3BlcnR5KEEpPygodm9pZCAwPT09Z3x8dm9pZCAwIT09SVtBXS5vdmVybG9hZFRhYmxlJiZ2b2lkIDAhPT1JW0FdLm92ZXJsb2FkVGFibGVbZ10pJiZQKGBDYW5ub3QgcmVnaXN0ZXIgcHVibGljIG5hbWUgJyR7QX0nIHR3aWNlYCksQVooSSxBLEEpLEkuaGFzT3duUHJvcGVydHkoZykmJlAoYENhbm5vdCByZWdpc3RlciBtdWx0aXBsZSBvdmVybG9hZHMgb2YgYSBmdW5jdGlvbiB3aXRoIHRoZSBzYW1lIG51bWJlciBvZiBhcmd1bWVudHMgKCR7Z30pIWApLElbQV0ub3ZlcmxvYWRUYWJsZVtnXT1DKTooSVtBXT1DLHZvaWQgMCE9PWcmJihJW0FdLm51bUFyZ3VtZW50cz1nKSl9LEFZPShBLEkpPT57Zm9yKHZhciBDPVtdLGc9MDtnPEE7ZysrKUMucHVzaChXW0krNCpnPj4yXSk7cmV0dXJuIEN9LEFiPShBLEMsZyk9PntJLmhhc093blByb3BlcnR5KEEpfHxxKFwiUmVwbGFjaW5nIG5vbmV4aXN0YW50IHB1YmxpYyBzeW1ib2xcIiksdm9pZCAwIT09SVtBXS5vdmVybG9hZFRhYmxlJiZ2b2lkIDAhPT1nP0lbQV0ub3ZlcmxvYWRUYWJsZVtnXT1DOihJW0FdPUMsSVtBXS5hcmdDb3VudD1nKX0sQWM9KEEsQyxnKT0+e3ZhciBCPUlbXCJkeW5DYWxsX1wiK0FdO3JldHVybiBnJiZnLmxlbmd0aD9CLmFwcGx5KG51bGwsW0NdLmNvbmNhdChnKSk6Qi5jYWxsKG51bGwsQyl9LEFXPVtdLEFkPUE9Pnt2YXIgST1BV1tBXTtyZXR1cm4gSXx8KEE+PUFXLmxlbmd0aCYmKEFXLmxlbmd0aD1BKzEpLEFXW0FdPUk9aS5nZXQoQSkpLEl9LEFFPShBLEksQyk9PkEuaW5jbHVkZXMoXCJqXCIpP0FjKEEsSSxDKTpBZChJKS5hcHBseShudWxsLEMpLEFtPShBLEkpPT57dmFyIEM9W107cmV0dXJuIGZ1bmN0aW9uKCl7cmV0dXJuIEMubGVuZ3RoPTAsT2JqZWN0LmFzc2lnbihDLGFyZ3VtZW50cyksQUUoQSxJLEMpfX0sQWg9KEEsSSk9Pnt2YXIgQz0oQT1lKEEpKS5pbmNsdWRlcyhcImpcIik/QW0oQSxJKTpBZChJKTtyZXR1cm5cImZ1bmN0aW9uXCIhPXR5cGVvZiBDJiZQKGB1bmtub3duIGZ1bmN0aW9uIHBvaW50ZXIgd2l0aCBzaWduYXR1cmUgJHtBfTogJHtJfWApLEN9LEFOPUE9Pnt2YXIgST1BaihBKSxDPWUoSSk7cmV0dXJuIEFLKEkpLEN9LEFSPShBLEkpPT57dmFyIEM9W10sZz17fTt0aHJvdyBJLmZvckVhY2goZnVuY3Rpb24gQShJKXtpZighZ1tJXSYmIVVbSV0pe2lmKE9bSV0pe09bSV0uZm9yRWFjaChBKTtyZXR1cm59Qy5wdXNoKEkpLGdbSV09ITB9fSksbmV3IGEoYCR7QX06IGArQy5tYXAoQU4pLmpvaW4oW1wiLCBcIl0pKX0sQWk9KEEsSSxDKT0+e3N3aXRjaChJKXtjYXNlIDE6cmV0dXJuIEM/QT0+WltBPj4wXTpBPT5sW0E+PjBdO2Nhc2UgMjpyZXR1cm4gQz9BPT5ZW0E+PjFdOkE9PmJbQT4+MV07Y2FzZSA0OnJldHVybiBDP0E9PmNbQT4+Ml06QT0+V1tBPj4yXTtkZWZhdWx0OnRocm93IFR5cGVFcnJvcihgaW52YWxpZCBpbnRlZ2VyIHdpZHRoICgke0l9KTogJHtBfWApfX07ZnVuY3Rpb24gQWEoQSl7cmV0dXJuIHRoaXMuZnJvbVdpcmVUeXBlKFdbQT4+Ml0pfXZhciBBVj0oQSxJLEMsZyk9PntpZighKGc+MCkpcmV0dXJuIDA7Zm9yKHZhciBCPUMsUT1DK2ctMSxHPTA7RzxBLmxlbmd0aDsrK0cpe3ZhciBaPUEuY2hhckNvZGVBdChHKTtpZihaPj01NTI5NiYmWjw9NTczNDMmJihaPTY1NTM2KygoMTAyMyZaKTw8MTApfDEwMjMmQS5jaGFyQ29kZUF0KCsrRykpLFo8PTEyNyl7aWYoQz49USlicmVhaztJW0MrK109Wn1lbHNlIGlmKFo8PTIwNDcpe2lmKEMrMT49USlicmVhaztJW0MrK109MTkyfFo+PjYsSVtDKytdPTEyOHw2MyZafWVsc2UgaWYoWjw9NjU1MzUpe2lmKEMrMj49USlicmVhaztJW0MrK109MjI0fFo+PjEyLElbQysrXT0xMjh8Wj4+NiY2MyxJW0MrK109MTI4fDYzJlp9ZWxzZXtpZihDKzM+PVEpYnJlYWs7SVtDKytdPTI0MHxaPj4xOCxJW0MrK109MTI4fFo+PjEyJjYzLElbQysrXT0xMjh8Wj4+NiY2MyxJW0MrK109MTI4fDYzJlp9fXJldHVybiBJW0NdPTAsQy1CfSxBaz0oQSxJLEMpPT5BVihBLGwsSSxDKSxBRj1BPT57Zm9yKHZhciBJPTAsQz0wO0M8QS5sZW5ndGg7KytDKXt2YXIgZz1BLmNoYXJDb2RlQXQoQyk7Zzw9MTI3P0krKzpnPD0yMDQ3P0krPTI6Zz49NTUyOTYmJmc8PTU3MzQzPyhJKz00LCsrQyk6SSs9M31yZXR1cm4gSX0sQXk9XCJ1bmRlZmluZWRcIiE9dHlwZW9mIFRleHREZWNvZGVyP25ldyBUZXh0RGVjb2RlcihcInV0ZjhcIik6dm9pZCAwLEFYPShBLEksQyk9Pntmb3IodmFyIGc9SStDLEI9STtBW0JdJiYhKEI+PWcpOykrK0I7aWYoQi1JPjE2JiZBLmJ1ZmZlciYmQXkpcmV0dXJuIEF5LmRlY29kZShBLnN1YmFycmF5KEksQikpO2Zvcih2YXIgUT1cIlwiO0k8Qjspe3ZhciBHPUFbSSsrXTtpZighKDEyOCZHKSl7USs9U3RyaW5nLmZyb21DaGFyQ29kZShHKTtjb250aW51ZX12YXIgWj02MyZBW0krK107aWYoKDIyNCZHKT09MTkyKXtRKz1TdHJpbmcuZnJvbUNoYXJDb2RlKCgzMSZHKTw8NnxaKTtjb250aW51ZX12YXIgbD02MyZBW0krK107aWYoKEc9KDI0MCZHKT09MjI0PygxNSZHKTw8MTJ8Wjw8NnxsOig3JkcpPDwxOHxaPDwxMnxsPDw2fDYzJkFbSSsrXSk8NjU1MzYpUSs9U3RyaW5nLmZyb21DaGFyQ29kZShHKTtlbHNle3ZhciBZPUctNjU1MzY7USs9U3RyaW5nLmZyb21DaGFyQ29kZSg1NTI5NnxZPj4xMCw1NjMyMHwxMDIzJlkpfX1yZXR1cm4gUX0sQXU9KEEsSSk9PkE/QVgobCxBLEkpOlwiXCIsQW89XCJ1bmRlZmluZWRcIiE9dHlwZW9mIFRleHREZWNvZGVyP25ldyBUZXh0RGVjb2RlcihcInV0Zi0xNmxlXCIpOnZvaWQgMCxBSj0oQSxJKT0+e2Zvcih2YXIgQz1BLGc9Qz4+MSxCPWcrSS8yOyEoZz49QikmJmJbZ107KSsrZztpZigoQz1nPDwxKS1BPjMyJiZBbylyZXR1cm4gQW8uZGVjb2RlKGwuc3ViYXJyYXkoQSxDKSk7Zm9yKHZhciBRPVwiXCIsRz0wOyEoRz49SS8yKTsrK0cpe3ZhciBaPVlbQSsyKkc+PjFdO2lmKDA9PVopYnJlYWs7USs9U3RyaW5nLmZyb21DaGFyQ29kZShaKX1yZXR1cm4gUX0sQXc9KEEsSSxDKT0+e2lmKHZvaWQgMD09PUMmJihDPTIxNDc0ODM2NDcpLEM8MilyZXR1cm4gMDtmb3IodmFyIGc9SSxCPShDLT0yKTwyKkEubGVuZ3RoP0MvMjpBLmxlbmd0aCxRPTA7UTxCOysrUSl7dmFyIEc9QS5jaGFyQ29kZUF0KFEpO1lbST4+MV09RyxJKz0yfXJldHVybiBZW0k+PjFdPTAsSS1nfSxBdj1BPT4yKkEubGVuZ3RoLEFEPShBLEkpPT57Zm9yKHZhciBDPTAsZz1cIlwiOyEoQz49SS80KTspe3ZhciBCPWNbQSs0KkM+PjJdO2lmKDA9PUIpYnJlYWs7aWYoKytDLEI+PTY1NTM2KXt2YXIgUT1CLTY1NTM2O2crPVN0cmluZy5mcm9tQ2hhckNvZGUoNTUyOTZ8UT4+MTAsNTYzMjB8MTAyMyZRKX1lbHNlIGcrPVN0cmluZy5mcm9tQ2hhckNvZGUoQil9cmV0dXJuIGd9LEFwPShBLEksQyk9PntpZih2b2lkIDA9PT1DJiYoQz0yMTQ3NDgzNjQ3KSxDPDQpcmV0dXJuIDA7Zm9yKHZhciBnPUksQj1nK0MtNCxRPTA7UTxBLmxlbmd0aDsrK1Epe3ZhciBHPUEuY2hhckNvZGVBdChRKTtpZihHPj01NTI5NiYmRzw9NTczNDMmJihHPTY1NTM2KygoMTAyMyZHKTw8MTApfDEwMjMmQS5jaGFyQ29kZUF0KCsrUSkpLGNbST4+Ml09RywoSSs9NCkrND5CKWJyZWFrfXJldHVybiBjW0k+PjJdPTAsSS1nfSxBbj1BPT57Zm9yKHZhciBJPTAsQz0wO0M8QS5sZW5ndGg7KytDKXt2YXIgZz1BLmNoYXJDb2RlQXQoQyk7Zz49NTUyOTYmJmc8PTU3MzQzJiYrK0MsSSs9NH1yZXR1cm4gSX0sQUg9KEEsSSk9Pnt2YXIgQz1VW0FdO3JldHVybiB2b2lkIDA9PT1DJiZQKEkrXCIgaGFzIHVua25vd24gdHlwZSBcIitBTihBKSksQ30sQXM9KCk9PjIxNDc0ODM2NDgsQXQ9QT0+e3ZhciBJPShBLUcuYnVmZmVyLmJ5dGVMZW5ndGgrNjU1MzUpLzY1NTM2O3RyeXtyZXR1cm4gRy5ncm93KEkpLHYoKSwxfWNhdGNoKEEpe319OygoKT0+e2Zvcih2YXIgQT1BcnJheSgyNTYpLEk9MDtJPDI1NjsrK0kpQVtJXT1TdHJpbmcuZnJvbUNoYXJDb2RlKEkpO2g9QX0pKCksTj1JLkJpbmRpbmdFcnJvcj1jbGFzcyBleHRlbmRzIEVycm9ye2NvbnN0cnVjdG9yKEEpe3N1cGVyKEEpLHRoaXMubmFtZT1cIkJpbmRpbmdFcnJvclwifX0sUj1JLkludGVybmFsRXJyb3I9Y2xhc3MgZXh0ZW5kcyBFcnJvcntjb25zdHJ1Y3RvcihBKXtzdXBlcihBKSx0aGlzLm5hbWU9XCJJbnRlcm5hbEVycm9yXCJ9fSxPYmplY3QuYXNzaWduKF8ucHJvdG90eXBlLHtnZXQoQSl7cmV0dXJuIHRoaXMuYWxsb2NhdGVkW0FdfSxoYXMoQSl7cmV0dXJuIHZvaWQgMCE9PXRoaXMuYWxsb2NhdGVkW0FdfSxhbGxvY2F0ZShBKXt2YXIgST10aGlzLmZyZWVsaXN0LnBvcCgpfHx0aGlzLmFsbG9jYXRlZC5sZW5ndGg7cmV0dXJuIHRoaXMuYWxsb2NhdGVkW0ldPUEsSX0sZnJlZShBKXt0aGlzLmFsbG9jYXRlZFtBXT12b2lkIDAsdGhpcy5mcmVlbGlzdC5wdXNoKEEpfX0pLCQuYWxsb2NhdGVkLnB1c2goe3ZhbHVlOnZvaWQgMH0se3ZhbHVlOm51bGx9LHt2YWx1ZTohMH0se3ZhbHVlOiExfSksJC5yZXNlcnZlZD0kLmFsbG9jYXRlZC5sZW5ndGgsSS5jb3VudF9lbXZhbF9oYW5kbGVzPSgpPT57Zm9yKHZhciBBPTAsST0kLnJlc2VydmVkO0k8JC5hbGxvY2F0ZWQubGVuZ3RoOysrSSl2b2lkIDAhPT0kLmFsbG9jYXRlZFtJXSYmKytBO3JldHVybiBBfSxhPUkuVW5ib3VuZFR5cGVFcnJvcj0oRj1FcnJvciwoWD1BRyh5PVwiVW5ib3VuZFR5cGVFcnJvclwiLGZ1bmN0aW9uKEEpe3RoaXMubmFtZT15LHRoaXMubWVzc2FnZT1BO3ZhciBJPUVycm9yKEEpLnN0YWNrO3ZvaWQgMCE9PUkmJih0aGlzLnN0YWNrPXRoaXMudG9TdHJpbmcoKStcIlxcblwiK0kucmVwbGFjZSgvXkVycm9yKDpbXlxcbl0qKT9cXG4vLFwiXCIpKX0pKS5wcm90b3R5cGU9T2JqZWN0LmNyZWF0ZShGLnByb3RvdHlwZSksWC5wcm90b3R5cGUuY29uc3RydWN0b3I9WCxYLnByb3RvdHlwZS50b1N0cmluZz1mdW5jdGlvbigpe3JldHVybiB2b2lkIDA9PT10aGlzLm1lc3NhZ2U/dGhpcy5uYW1lOmAke3RoaXMubmFtZX06ICR7dGhpcy5tZXNzYWdlfWB9LFgpO3ZhciBBTD17ZjooQSxJLEMpPT57dGhyb3cgbmV3IGooQSkuaW5pdChJLEMpLHg9QSxNKysseH0sbTooQSxJLEMsZyxCKT0+e30saTooQSxJLEMsZyk9PntmKEEse25hbWU6ST1lKEkpLGZyb21XaXJlVHlwZTpmdW5jdGlvbihBKXtyZXR1cm4hIUF9LHRvV2lyZVR5cGU6ZnVuY3Rpb24oQSxJKXtyZXR1cm4gST9DOmd9LGFyZ1BhY2tBZHZhbmNlOjgscmVhZFZhbHVlRnJvbVBvaW50ZXI6ZnVuY3Rpb24oQSl7cmV0dXJuIHRoaXMuZnJvbVdpcmVUeXBlKGxbQV0pfSxkZXN0cnVjdG9yRnVuY3Rpb246bnVsbH0pfSxwOihBLEkpPT57ZihBLHtuYW1lOkk9ZShJKSxmcm9tV2lyZVR5cGU6QT0+e3ZhciBJPUFJLnRvVmFsdWUoQSk7cmV0dXJuIEFBKEEpLEl9LHRvV2lyZVR5cGU6KEEsSSk9PkFJLnRvSGFuZGxlKEkpLGFyZ1BhY2tBZHZhbmNlOjgscmVhZFZhbHVlRnJvbVBvaW50ZXI6QUMsZGVzdHJ1Y3RvckZ1bmN0aW9uOm51bGx9KX0sZTooQSxJLEMpPT57ZihBLHtuYW1lOkk9ZShJKSxmcm9tV2lyZVR5cGU6QT0+QSx0b1dpcmVUeXBlOihBLEkpPT5JLGFyZ1BhY2tBZHZhbmNlOjgscmVhZFZhbHVlRnJvbVBvaW50ZXI6QWcoSSxDKSxkZXN0cnVjdG9yRnVuY3Rpb246bnVsbH0pfSxoOihBLEksQyxnLEIsUSxHKT0+e3ZhciBaPUFZKEksQyk7QT1lKEEpLEI9QWgoZyxCKSxBbChBLGZ1bmN0aW9uKCl7QVIoYENhbm5vdCBjYWxsICR7QX0gZHVlIHRvIHVuYm91bmQgdHlwZXNgLFopfSxJLTEpLFQoW10sWixmdW5jdGlvbihDKXtyZXR1cm4gQWIoQSxmdW5jdGlvbihBLEksQyxnLEIsUSl7dmFyIEc9SS5sZW5ndGg7RzwyJiZQKFwiYXJnVHlwZXMgYXJyYXkgc2l6ZSBtaXNtYXRjaCEgTXVzdCBhdCBsZWFzdCBnZXQgcmV0dXJuIHZhbHVlIGFuZCAndGhpcycgdHlwZXMhXCIpO2Zvcih2YXIgWj1udWxsIT09SVsxXSYmITEsbD0hMSxZPTE7WTxJLmxlbmd0aDsrK1kpaWYobnVsbCE9PUlbWV0mJnZvaWQgMD09PUlbWV0uZGVzdHJ1Y3RvckZ1bmN0aW9uKXtsPSEwO2JyZWFrfWZvcih2YXIgYj1cInZvaWRcIiE9PUlbMF0ubmFtZSxjPVwiXCIsVz1cIlwiLFk9MDtZPEctMjsrK1kpYys9KDAhPT1ZP1wiLCBcIjpcIlwiKStcImFyZ1wiK1ksVys9KDAhPT1ZP1wiLCBcIjpcIlwiKStcImFyZ1wiK1krXCJXaXJlZFwiO3ZhciBkPWBcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICR7QUIoQSl9KCR7Y30pIHtcbiAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggIT09ICR7Ry0yfSkge1xuICAgICAgICAgIHRocm93QmluZGluZ0Vycm9yKCdmdW5jdGlvbiAke0F9IGNhbGxlZCB3aXRoICcgKyBhcmd1bWVudHMubGVuZ3RoICsgJyBhcmd1bWVudHMsIGV4cGVjdGVkICR7Ry0yfScpO1xuICAgICAgICB9YDtsJiYoZCs9XCJ2YXIgZGVzdHJ1Y3RvcnMgPSBbXTtcXG5cIik7dmFyIEU9bD9cImRlc3RydWN0b3JzXCI6XCJudWxsXCIsbT1bXCJ0aHJvd0JpbmRpbmdFcnJvclwiLFwiaW52b2tlclwiLFwiZm5cIixcInJ1bkRlc3RydWN0b3JzXCIsXCJyZXRUeXBlXCIsXCJjbGFzc1BhcmFtXCJdLGg9W1AsZyxCLEFRLElbMF0sSVsxXV07WiYmKGQrPVwidmFyIHRoaXNXaXJlZCA9IGNsYXNzUGFyYW0udG9XaXJlVHlwZShcIitFK1wiLCB0aGlzKTtcXG5cIik7Zm9yKHZhciBZPTA7WTxHLTI7KytZKWQrPVwidmFyIGFyZ1wiK1krXCJXaXJlZCA9IGFyZ1R5cGVcIitZK1wiLnRvV2lyZVR5cGUoXCIrRStcIiwgYXJnXCIrWStcIik7IC8vIFwiK0lbWSsyXS5uYW1lK1wiXFxuXCIsbS5wdXNoKFwiYXJnVHlwZVwiK1kpLGgucHVzaChJW1krMl0pO2lmKFomJihXPVwidGhpc1dpcmVkXCIrKFcubGVuZ3RoPjA/XCIsIFwiOlwiXCIpK1cpLGQrPShifHxRP1widmFyIHJ2ID0gXCI6XCJcIikrXCJpbnZva2VyKGZuXCIrKFcubGVuZ3RoPjA/XCIsIFwiOlwiXCIpK1crXCIpO1xcblwiLGwpZCs9XCJydW5EZXN0cnVjdG9ycyhkZXN0cnVjdG9ycyk7XFxuXCI7ZWxzZSBmb3IodmFyIFk9Wj8xOjI7WTxJLmxlbmd0aDsrK1kpe3ZhciBOPTE9PT1ZP1widGhpc1dpcmVkXCI6XCJhcmdcIisoWS0yKStcIldpcmVkXCI7bnVsbCE9PUlbWV0uZGVzdHJ1Y3RvckZ1bmN0aW9uJiYoZCs9TitcIl9kdG9yKFwiK04rXCIpOyAvLyBcIitJW1ldLm5hbWUrXCJcXG5cIixtLnB1c2goTitcIl9kdG9yXCIpLGgucHVzaChJW1ldLmRlc3RydWN0b3JGdW5jdGlvbikpfXJldHVybiBiJiYoZCs9XCJ2YXIgcmV0ID0gcmV0VHlwZS5mcm9tV2lyZVR5cGUocnYpO1xcbnJldHVybiByZXQ7XFxuXCIpLGQrPVwifVxcblwiLG0ucHVzaChkKSwoZnVuY3Rpb24oQSxJKXtpZighKEEgaW5zdGFuY2VvZiBGdW5jdGlvbikpdGhyb3cgVHlwZUVycm9yKGBuZXdfIGNhbGxlZCB3aXRoIGNvbnN0cnVjdG9yIHR5cGUgJHt0eXBlb2YgQX0gd2hpY2ggaXMgbm90IGEgZnVuY3Rpb25gKTt2YXIgQz1BRyhBLm5hbWV8fFwidW5rbm93bkZ1bmN0aW9uTmFtZVwiLGZ1bmN0aW9uKCl7fSk7Qy5wcm90b3R5cGU9QS5wcm90b3R5cGU7dmFyIGc9bmV3IEMsQj1BLmFwcGx5KGcsSSk7cmV0dXJuIEIgaW5zdGFuY2VvZiBPYmplY3Q/QjpnfSkoRnVuY3Rpb24sbSkuYXBwbHkobnVsbCxoKX0oQSxbQ1swXSxudWxsXS5jb25jYXQoQy5zbGljZSgxKSksMCxCLFEsRyksSS0xKSxbXX0pfSxiOihBLEksQyxnLEIpPT57ST1lKEkpLC0xPT09QiYmKEI9NDI5NDk2NzI5NSk7dmFyIFE9QT0+QTtpZigwPT09Zyl7dmFyIEc9MzItOCpDO1E9QT0+QTw8Rz4+Pkd9dmFyIFo9SS5pbmNsdWRlcyhcInVuc2lnbmVkXCIpLGw9KEEsSSk9Pnt9O2YoQSx7bmFtZTpJLGZyb21XaXJlVHlwZTpRLHRvV2lyZVR5cGU6Wj9mdW5jdGlvbihBLEkpe3JldHVybiBsKEksdGhpcy5uYW1lKSxJPj4+MH06ZnVuY3Rpb24oQSxJKXtyZXR1cm4gbChJLHRoaXMubmFtZSksSX0sYXJnUGFja0FkdmFuY2U6OCxyZWFkVmFsdWVGcm9tUG9pbnRlcjpBaShJLEMsMCE9PWcpLGRlc3RydWN0b3JGdW5jdGlvbjpudWxsfSl9LGE6KEEsSSxDKT0+e3ZhciBnPVtJbnQ4QXJyYXksVWludDhBcnJheSxJbnQxNkFycmF5LFVpbnQxNkFycmF5LEludDMyQXJyYXksVWludDMyQXJyYXksRmxvYXQzMkFycmF5LEZsb2F0NjRBcnJheV1bSV07ZnVuY3Rpb24gQihBKXt2YXIgST1XW0E+PjJdLEM9V1tBKzQ+PjJdO3JldHVybiBuZXcgZyhaLmJ1ZmZlcixDLEkpfWYoQSx7bmFtZTpDPWUoQyksZnJvbVdpcmVUeXBlOkIsYXJnUGFja0FkdmFuY2U6OCxyZWFkVmFsdWVGcm9tUG9pbnRlcjpCfSx7aWdub3JlRHVwbGljYXRlUmVnaXN0cmF0aW9uczohMH0pfSxkOihBLEkpPT57dmFyIEM9XCJzdGQ6OnN0cmluZ1wiPT09KEk9ZShJKSk7ZihBLHtuYW1lOkksZnJvbVdpcmVUeXBlKEEpe3ZhciBJLGc9V1tBPj4yXSxCPUErNDtpZihDKWZvcih2YXIgUT1CLEc9MDtHPD1nOysrRyl7dmFyIFo9QitHO2lmKEc9PWd8fDA9PWxbWl0pe3ZhciBZPVotUSxiPUF1KFEsWSk7dm9pZCAwPT09ST9JPWI6SSs9XCJcXHgwMFwiK2IsUT1aKzF9fWVsc2V7Zm9yKHZhciBjPUFycmF5KGcpLEc9MDtHPGc7KytHKWNbR109U3RyaW5nLmZyb21DaGFyQ29kZShsW0IrR10pO0k9Yy5qb2luKFwiXCIpfXJldHVybiBBSyhBKSxJfSx0b1dpcmVUeXBlKEEsSSl7SSBpbnN0YW5jZW9mIEFycmF5QnVmZmVyJiYoST1uZXcgVWludDhBcnJheShJKSk7dmFyIGcsQj1cInN0cmluZ1wiPT10eXBlb2YgSTtCfHxJIGluc3RhbmNlb2YgVWludDhBcnJheXx8SSBpbnN0YW5jZW9mIFVpbnQ4Q2xhbXBlZEFycmF5fHxJIGluc3RhbmNlb2YgSW50OEFycmF5fHxQKFwiQ2Fubm90IHBhc3Mgbm9uLXN0cmluZyB0byBzdGQ6OnN0cmluZ1wiKSxnPUMmJkI/QUYoSSk6SS5sZW5ndGg7dmFyIFE9QXooNCtnKzEpLEc9USs0O2lmKFdbUT4+Ml09ZyxDJiZCKUFrKEksRyxnKzEpO2Vsc2UgaWYoQilmb3IodmFyIFo9MDtaPGc7KytaKXt2YXIgWT1JLmNoYXJDb2RlQXQoWik7WT4yNTUmJihBSyhHKSxQKFwiU3RyaW5nIGhhcyBVVEYtMTYgY29kZSB1bml0cyB0aGF0IGRvIG5vdCBmaXQgaW4gOCBiaXRzXCIpKSxsW0crWl09WX1lbHNlIGZvcih2YXIgWj0wO1o8ZzsrK1opbFtHK1pdPUlbWl07cmV0dXJuIG51bGwhPT1BJiZBLnB1c2goQUssUSksUX0sYXJnUGFja0FkdmFuY2U6OCxyZWFkVmFsdWVGcm9tUG9pbnRlcjpBYSxkZXN0cnVjdG9yRnVuY3Rpb24oQSl7QUsoQSl9fSl9LGM6KEEsSSxDKT0+e3ZhciBnLEIsUSxHLFo7Qz1lKEMpLDI9PT1JPyhnPUFKLEI9QXcsRz1BdixRPSgpPT5iLFo9MSk6ND09PUkmJihnPUFELEI9QXAsRz1BbixRPSgpPT5XLFo9MiksZihBLHtuYW1lOkMsZnJvbVdpcmVUeXBlOkE9Pntmb3IodmFyIEMsQj1XW0E+PjJdLEc9USgpLGw9QSs0LFk9MDtZPD1COysrWSl7dmFyIGI9QSs0K1kqSTtpZihZPT1CfHwwPT1HW2I+PlpdKXt2YXIgYz1iLWwsZD1nKGwsYyk7dm9pZCAwPT09Qz9DPWQ6Qys9XCJcXHgwMFwiK2QsbD1iK0l9fXJldHVybiBBSyhBKSxDfSx0b1dpcmVUeXBlOihBLGcpPT57XCJzdHJpbmdcIiE9dHlwZW9mIGcmJlAoYENhbm5vdCBwYXNzIG5vbi1zdHJpbmcgdG8gQysrIHN0cmluZyB0eXBlICR7Q31gKTt2YXIgUT1HKGcpLGw9QXooNCtRK0kpO3JldHVybiBXW2w+PjJdPVE+PlosQihnLGwrNCxRK0kpLG51bGwhPT1BJiZBLnB1c2goQUssbCksbH0sYXJnUGFja0FkdmFuY2U6OCxyZWFkVmFsdWVGcm9tUG9pbnRlcjpBQyxkZXN0cnVjdG9yRnVuY3Rpb24oQSl7QUsoQSl9fSl9LGo6KEEsSSk9PntmKEEse2lzVm9pZDohMCxuYW1lOkk9ZShJKSxhcmdQYWNrQWR2YW5jZTowLGZyb21XaXJlVHlwZTooKT0+dm9pZCAwLHRvV2lyZVR5cGU6KEEsSSk9PnZvaWQgMH0pfSxrOkFBLGw6QT0+e0E+NCYmKCQuZ2V0KEEpLnJlZmNvdW50Kz0xKX0scTooQSxJKT0+e3ZhciBDPShBPUFIKEEsXCJfZW12YWxfdGFrZV92YWx1ZVwiKSkucmVhZFZhbHVlRnJvbVBvaW50ZXIoSSk7cmV0dXJuIEFJLnRvSGFuZGxlKEMpfSxnOigpPT57TChcIlwiKX0sbzooQSxJLEMpPT5sLmNvcHlXaXRoaW4oQSxJLEkrQyksbjpBPT57dmFyIEk9bC5sZW5ndGg7QT4+Pj0wO3ZhciBDPUFzKCk7aWYoQT5DKXJldHVybiExO2Zvcih2YXIgZz0oQSxJKT0+QSsoSS1BJUkpJUksQj0xO0I8PTQ7Qio9Mil7dmFyIFE9SSooMSsuMi9CKTtpZihRPU1hdGgubWluKFEsQSsxMDA2NjMyOTYpLEF0KE1hdGgubWluKEMsZyhNYXRoLm1heChBLFEpLDY1NTM2KSkpKXJldHVybiEwfXJldHVybiExfX0sQVM9ZnVuY3Rpb24oKXt2YXIgQSxDPXthOkFMfTtmdW5jdGlvbiBaKEEsQyl7dmFyIGc7cmV0dXJuIEc9KEFTPUEuZXhwb3J0cykucix2KCksaT1BUy50LGc9QVMucyxwLnVuc2hpZnQoZyksZnVuY3Rpb24oQSl7aWYoSC0tLEkubW9uaXRvclJ1bkRlcGVuZGVuY2llcyYmSS5tb25pdG9yUnVuRGVwZW5kZW5jaWVzKEgpLDA9PUgmJihudWxsIT09cyYmKGNsZWFySW50ZXJ2YWwocykscz1udWxsKSx0KSl7dmFyIEM9dDt0PW51bGwsQygpfX0oMCksQVN9aWYoSCsrLEkubW9uaXRvclJ1bkRlcGVuZGVuY2llcyYmSS5tb25pdG9yUnVuRGVwZW5kZW5jaWVzKEgpLEkuaW5zdGFudGlhdGVXYXNtKXRyeXtyZXR1cm4gSS5pbnN0YW50aWF0ZVdhc20oQyxaKX1jYXRjaChBKXtKKGBNb2R1bGUuaW5zdGFudGlhdGVXYXNtIGNhbGxiYWNrIGZhaWxlZCB3aXRoIGVycm9yOiAke0F9YCksZyhBKX1yZXR1cm4oQT1tLFByb21pc2UucmVzb2x2ZSgpLnRoZW4oKCk9PihmdW5jdGlvbihBKXtpZihBPT1tJiZRKXJldHVybiBuZXcgVWludDhBcnJheShRKTt2YXIgST1mdW5jdGlvbihBKXtpZih6KEEpKXJldHVybiBmdW5jdGlvbihBKXt0cnl7Zm9yKHZhciBJPWF0b2IoQSksQz1uZXcgVWludDhBcnJheShJLmxlbmd0aCksZz0wO2c8SS5sZW5ndGg7KytnKUNbZ109SS5jaGFyQ29kZUF0KGcpO3JldHVybiBDfWNhdGNoKEEpe3Rocm93IEVycm9yKFwiQ29udmVydGluZyBiYXNlNjQgc3RyaW5nIHRvIGJ5dGVzIGZhaWxlZC5cIil9fShBLnNsaWNlKFMubGVuZ3RoKSl9KEEpO2lmKEkpcmV0dXJuIEk7aWYoQilyZXR1cm4gQihBKTt0aHJvd1wiYm90aCBhc3luYyBhbmQgc3luYyBmZXRjaGluZyBvZiB0aGUgd2FzbSBmYWlsZWRcIn0pKEEpKS50aGVuKEE9PldlYkFzc2VtYmx5Lmluc3RhbnRpYXRlKEEsQykpLnRoZW4oQT0+QSkudGhlbihmdW5jdGlvbihBKXtaKEEuaW5zdGFuY2UpfSxBPT57SihgZmFpbGVkIHRvIGFzeW5jaHJvbm91c2x5IHByZXBhcmUgd2FzbTogJHtBfWApLEwoQSl9KSkuY2F0Y2goZykse319KCksQXo9QT0+KEF6PUFTLnUpKEEpLEFLPUE9PihBSz1BUy52KShBKSxBaj1BPT4oQWo9QVMudykoQSksQXg9KEkuX19lbWJpbmRfaW5pdGlhbGl6ZV9iaW5kaW5ncz0oKT0+KEkuX19lbWJpbmRfaW5pdGlhbGl6ZV9iaW5kaW5ncz1BUy54KSgpLEE9PihBeD1BUy55KShBKSk7ZnVuY3Rpb24gQU0oKXshKEg+MCkmJihmdW5jdGlvbigpe2lmKEkucHJlUnVuKWZvcihcImZ1bmN0aW9uXCI9PXR5cGVvZiBJLnByZVJ1biYmKEkucHJlUnVuPVtJLnByZVJ1bl0pO0kucHJlUnVuLmxlbmd0aDspe3ZhciBBO0E9SS5wcmVSdW4uc2hpZnQoKSxELnVuc2hpZnQoQSl9SyhEKX0oKSxIPjB8fChJLnNldFN0YXR1cz8oSS5zZXRTdGF0dXMoXCJSdW5uaW5nLi4uXCIpLHNldFRpbWVvdXQoZnVuY3Rpb24oKXtzZXRUaW1lb3V0KGZ1bmN0aW9uKCl7SS5zZXRTdGF0dXMoXCJcIil9LDEpLEEoKX0sMSkpOkEoKSkpO2Z1bmN0aW9uIEEoKXshViYmKFY9ITAsSS5jYWxsZWRSdW49ITAsd3x8KEsocCksQyhJKSxJLm9uUnVudGltZUluaXRpYWxpemVkJiZJLm9uUnVudGltZUluaXRpYWxpemVkKCksZnVuY3Rpb24oKXtpZihJLnBvc3RSdW4pZm9yKFwiZnVuY3Rpb25cIj09dHlwZW9mIEkucG9zdFJ1biYmKEkucG9zdFJ1bj1bSS5wb3N0UnVuXSk7SS5wb3N0UnVuLmxlbmd0aDspe3ZhciBBO0E9SS5wb3N0UnVuLnNoaWZ0KCksbi51bnNoaWZ0KEEpfUsobil9KCkpKX19aWYodD1mdW5jdGlvbiBBKCl7Vnx8QU0oKSxWfHwodD1BKX0sSS5wcmVJbml0KWZvcihcImZ1bmN0aW9uXCI9PXR5cGVvZiBJLnByZUluaXQmJihJLnByZUluaXQ9W0kucHJlSW5pdF0pO0kucHJlSW5pdC5sZW5ndGg+MDspSS5wcmVJbml0LnBvcCgpKCk7cmV0dXJuIEFNKCksSS5yZWFkeX0pO2xldCBDPW5ldyBQcm9taXNlKEE9PntJKHtvblJ1bnRpbWVJbml0aWFsaXplZCgpe0EodGhpcyl9fSl9KTsvKipcbiAqIEFzeW5jaHJvbm91c2x5IGxvYWRzIHRoZSBXT0ZGMiBtb2R1bGUuXG4gKlxuICogQHJldHVybnMgQSBwcm9taXNlIHJlc29sdmluZyB0byB0aGUgV09GRjIgbW9kdWxlLlxuICogQGludGVybmFsXG4gKi9hc3luYyBmdW5jdGlvbiBnKCl7bGV0IEE9YXdhaXQgQztyZXR1cm4gbmV3IFByb21pc2UoST0+e3NldFRpbWVvdXQoKCk9PntJKEEpfSwwKX0pfWFzeW5jIGZ1bmN0aW9uIEIoQSl7bGV0IEk9YXdhaXQgZygpLEM9YXdhaXQgSS5kZWNvbXByZXNzKEEpO2lmKCFDKXRocm93IEVycm9yKFwiRmFpbGVkIHRvIGRlY29tcHJlc3MgdGhlIGZvbnQgZGF0YS5cIik7cmV0dXJuIFVpbnQ4QXJyYXkuZnJvbShDKX1leHBvcnR7QiBhcyBkZWZhdWx0fTsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/woff2-encoder/dist/decompress.js\n"));

/***/ })

},
/******/ function(__webpack_require__) { // webpackRuntimeModules
/******/ var __webpack_exec__ = function(moduleId) { return __webpack_require__(__webpack_require__.s = moduleId); }
/******/ __webpack_require__.O(0, ["main"], function() { return __webpack_exec__("./node_modules/next/dist/build/webpack/loaders/next-client-pages-loader.js?absolutePagePath=private-next-pages%2F_app&page=%2F_app!"), __webpack_exec__("./node_modules/next/dist/client/router.js"); });
/******/ var __webpack_exports__ = __webpack_require__.O();
/******/ _N_E = __webpack_exports__;
/******/ }
]);