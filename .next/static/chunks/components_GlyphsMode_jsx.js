/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunk_N_E"] = self["webpackChunk_N_E"] || []).push([["components_GlyphsMode_jsx"],{

/***/ "./node_modules/lodash.debounce/index.js":
/*!***********************************************!*\
  !*** ./node_modules/lodash.debounce/index.js ***!
  \***********************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("/**\n * lodash (Custom Build) <https://lodash.com/>\n * Build: `lodash modularize exports=\"npm\" -o ./`\n * Copyright jQuery Foundation and other contributors <https://jquery.org/>\n * Released under MIT license <https://lodash.com/license>\n * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>\n * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors\n */\n\n/** Used as the `TypeError` message for \"Functions\" methods. */\nvar FUNC_ERROR_TEXT = 'Expected a function';\n\n/** Used as references for various `Number` constants. */\nvar NAN = 0 / 0;\n\n/** `Object#toString` result references. */\nvar symbolTag = '[object Symbol]';\n\n/** Used to match leading and trailing whitespace. */\nvar reTrim = /^\\s+|\\s+$/g;\n\n/** Used to detect bad signed hexadecimal string values. */\nvar reIsBadHex = /^[-+]0x[0-9a-f]+$/i;\n\n/** Used to detect binary string values. */\nvar reIsBinary = /^0b[01]+$/i;\n\n/** Used to detect octal string values. */\nvar reIsOctal = /^0o[0-7]+$/i;\n\n/** Built-in method references without a dependency on `root`. */\nvar freeParseInt = parseInt;\n\n/** Detect free variable `global` from Node.js. */\nvar freeGlobal = typeof __webpack_require__.g == 'object' && __webpack_require__.g && __webpack_require__.g.Object === Object && __webpack_require__.g;\n\n/** Detect free variable `self`. */\nvar freeSelf = typeof self == 'object' && self && self.Object === Object && self;\n\n/** Used as a reference to the global object. */\nvar root = freeGlobal || freeSelf || Function('return this')();\n\n/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/**\n * Used to resolve the\n * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)\n * of values.\n */\nvar objectToString = objectProto.toString;\n\n/* Built-in method references for those with the same name as other `lodash` methods. */\nvar nativeMax = Math.max,\n    nativeMin = Math.min;\n\n/**\n * Gets the timestamp of the number of milliseconds that have elapsed since\n * the Unix epoch (1 January 1970 00:00:00 UTC).\n *\n * @static\n * @memberOf _\n * @since 2.4.0\n * @category Date\n * @returns {number} Returns the timestamp.\n * @example\n *\n * _.defer(function(stamp) {\n *   console.log(_.now() - stamp);\n * }, _.now());\n * // => Logs the number of milliseconds it took for the deferred invocation.\n */\nvar now = function() {\n  return root.Date.now();\n};\n\n/**\n * Creates a debounced function that delays invoking `func` until after `wait`\n * milliseconds have elapsed since the last time the debounced function was\n * invoked. The debounced function comes with a `cancel` method to cancel\n * delayed `func` invocations and a `flush` method to immediately invoke them.\n * Provide `options` to indicate whether `func` should be invoked on the\n * leading and/or trailing edge of the `wait` timeout. The `func` is invoked\n * with the last arguments provided to the debounced function. Subsequent\n * calls to the debounced function return the result of the last `func`\n * invocation.\n *\n * **Note:** If `leading` and `trailing` options are `true`, `func` is\n * invoked on the trailing edge of the timeout only if the debounced function\n * is invoked more than once during the `wait` timeout.\n *\n * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred\n * until to the next tick, similar to `setTimeout` with a timeout of `0`.\n *\n * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)\n * for details over the differences between `_.debounce` and `_.throttle`.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Function\n * @param {Function} func The function to debounce.\n * @param {number} [wait=0] The number of milliseconds to delay.\n * @param {Object} [options={}] The options object.\n * @param {boolean} [options.leading=false]\n *  Specify invoking on the leading edge of the timeout.\n * @param {number} [options.maxWait]\n *  The maximum time `func` is allowed to be delayed before it's invoked.\n * @param {boolean} [options.trailing=true]\n *  Specify invoking on the trailing edge of the timeout.\n * @returns {Function} Returns the new debounced function.\n * @example\n *\n * // Avoid costly calculations while the window size is in flux.\n * jQuery(window).on('resize', _.debounce(calculateLayout, 150));\n *\n * // Invoke `sendMail` when clicked, debouncing subsequent calls.\n * jQuery(element).on('click', _.debounce(sendMail, 300, {\n *   'leading': true,\n *   'trailing': false\n * }));\n *\n * // Ensure `batchLog` is invoked once after 1 second of debounced calls.\n * var debounced = _.debounce(batchLog, 250, { 'maxWait': 1000 });\n * var source = new EventSource('/stream');\n * jQuery(source).on('message', debounced);\n *\n * // Cancel the trailing debounced invocation.\n * jQuery(window).on('popstate', debounced.cancel);\n */\nfunction debounce(func, wait, options) {\n  var lastArgs,\n      lastThis,\n      maxWait,\n      result,\n      timerId,\n      lastCallTime,\n      lastInvokeTime = 0,\n      leading = false,\n      maxing = false,\n      trailing = true;\n\n  if (typeof func != 'function') {\n    throw new TypeError(FUNC_ERROR_TEXT);\n  }\n  wait = toNumber(wait) || 0;\n  if (isObject(options)) {\n    leading = !!options.leading;\n    maxing = 'maxWait' in options;\n    maxWait = maxing ? nativeMax(toNumber(options.maxWait) || 0, wait) : maxWait;\n    trailing = 'trailing' in options ? !!options.trailing : trailing;\n  }\n\n  function invokeFunc(time) {\n    var args = lastArgs,\n        thisArg = lastThis;\n\n    lastArgs = lastThis = undefined;\n    lastInvokeTime = time;\n    result = func.apply(thisArg, args);\n    return result;\n  }\n\n  function leadingEdge(time) {\n    // Reset any `maxWait` timer.\n    lastInvokeTime = time;\n    // Start the timer for the trailing edge.\n    timerId = setTimeout(timerExpired, wait);\n    // Invoke the leading edge.\n    return leading ? invokeFunc(time) : result;\n  }\n\n  function remainingWait(time) {\n    var timeSinceLastCall = time - lastCallTime,\n        timeSinceLastInvoke = time - lastInvokeTime,\n        result = wait - timeSinceLastCall;\n\n    return maxing ? nativeMin(result, maxWait - timeSinceLastInvoke) : result;\n  }\n\n  function shouldInvoke(time) {\n    var timeSinceLastCall = time - lastCallTime,\n        timeSinceLastInvoke = time - lastInvokeTime;\n\n    // Either this is the first call, activity has stopped and we're at the\n    // trailing edge, the system time has gone backwards and we're treating\n    // it as the trailing edge, or we've hit the `maxWait` limit.\n    return (lastCallTime === undefined || (timeSinceLastCall >= wait) ||\n      (timeSinceLastCall < 0) || (maxing && timeSinceLastInvoke >= maxWait));\n  }\n\n  function timerExpired() {\n    var time = now();\n    if (shouldInvoke(time)) {\n      return trailingEdge(time);\n    }\n    // Restart the timer.\n    timerId = setTimeout(timerExpired, remainingWait(time));\n  }\n\n  function trailingEdge(time) {\n    timerId = undefined;\n\n    // Only invoke if we have `lastArgs` which means `func` has been\n    // debounced at least once.\n    if (trailing && lastArgs) {\n      return invokeFunc(time);\n    }\n    lastArgs = lastThis = undefined;\n    return result;\n  }\n\n  function cancel() {\n    if (timerId !== undefined) {\n      clearTimeout(timerId);\n    }\n    lastInvokeTime = 0;\n    lastArgs = lastCallTime = lastThis = timerId = undefined;\n  }\n\n  function flush() {\n    return timerId === undefined ? result : trailingEdge(now());\n  }\n\n  function debounced() {\n    var time = now(),\n        isInvoking = shouldInvoke(time);\n\n    lastArgs = arguments;\n    lastThis = this;\n    lastCallTime = time;\n\n    if (isInvoking) {\n      if (timerId === undefined) {\n        return leadingEdge(lastCallTime);\n      }\n      if (maxing) {\n        // Handle invocations in a tight loop.\n        timerId = setTimeout(timerExpired, wait);\n        return invokeFunc(lastCallTime);\n      }\n    }\n    if (timerId === undefined) {\n      timerId = setTimeout(timerExpired, wait);\n    }\n    return result;\n  }\n  debounced.cancel = cancel;\n  debounced.flush = flush;\n  return debounced;\n}\n\n/**\n * Checks if `value` is the\n * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)\n * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an object, else `false`.\n * @example\n *\n * _.isObject({});\n * // => true\n *\n * _.isObject([1, 2, 3]);\n * // => true\n *\n * _.isObject(_.noop);\n * // => true\n *\n * _.isObject(null);\n * // => false\n */\nfunction isObject(value) {\n  var type = typeof value;\n  return !!value && (type == 'object' || type == 'function');\n}\n\n/**\n * Checks if `value` is object-like. A value is object-like if it's not `null`\n * and has a `typeof` result of \"object\".\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is object-like, else `false`.\n * @example\n *\n * _.isObjectLike({});\n * // => true\n *\n * _.isObjectLike([1, 2, 3]);\n * // => true\n *\n * _.isObjectLike(_.noop);\n * // => false\n *\n * _.isObjectLike(null);\n * // => false\n */\nfunction isObjectLike(value) {\n  return !!value && typeof value == 'object';\n}\n\n/**\n * Checks if `value` is classified as a `Symbol` primitive or object.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.\n * @example\n *\n * _.isSymbol(Symbol.iterator);\n * // => true\n *\n * _.isSymbol('abc');\n * // => false\n */\nfunction isSymbol(value) {\n  return typeof value == 'symbol' ||\n    (isObjectLike(value) && objectToString.call(value) == symbolTag);\n}\n\n/**\n * Converts `value` to a number.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to process.\n * @returns {number} Returns the number.\n * @example\n *\n * _.toNumber(3.2);\n * // => 3.2\n *\n * _.toNumber(Number.MIN_VALUE);\n * // => 5e-324\n *\n * _.toNumber(Infinity);\n * // => Infinity\n *\n * _.toNumber('3.2');\n * // => 3.2\n */\nfunction toNumber(value) {\n  if (typeof value == 'number') {\n    return value;\n  }\n  if (isSymbol(value)) {\n    return NAN;\n  }\n  if (isObject(value)) {\n    var other = typeof value.valueOf == 'function' ? value.valueOf() : value;\n    value = isObject(other) ? (other + '') : other;\n  }\n  if (typeof value != 'string') {\n    return value === 0 ? value : +value;\n  }\n  value = value.replace(reTrim, '');\n  var isBinary = reIsBinary.test(value);\n  return (isBinary || reIsOctal.test(value))\n    ? freeParseInt(value.slice(2), isBinary ? 2 : 8)\n    : (reIsBadHex.test(value) ? NAN : +value);\n}\n\nmodule.exports = debounce;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbG9kYXNoLmRlYm91bmNlL2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0Esd0JBQXdCLHFCQUFNLGdCQUFnQixxQkFBTSxJQUFJLHFCQUFNLHNCQUFzQixxQkFBTTs7QUFFMUY7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFVBQVU7QUFDckIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUSxXQUFXO0FBQzlCLFdBQVcsU0FBUztBQUNwQjtBQUNBLFdBQVcsUUFBUTtBQUNuQjtBQUNBLFdBQVcsU0FBUztBQUNwQjtBQUNBLGFBQWEsVUFBVTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLCtDQUErQyxpQkFBaUI7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEdBQUc7QUFDZCxhQUFhLFNBQVM7QUFDdEI7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsR0FBRztBQUNkLGFBQWEsU0FBUztBQUN0QjtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEdBQUc7QUFDZCxhQUFhLFNBQVM7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxHQUFHO0FBQ2QsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9sb2Rhc2guZGVib3VuY2UvaW5kZXguanM/ODlhOCJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIGxvZGFzaCAoQ3VzdG9tIEJ1aWxkKSA8aHR0cHM6Ly9sb2Rhc2guY29tLz5cbiAqIEJ1aWxkOiBgbG9kYXNoIG1vZHVsYXJpemUgZXhwb3J0cz1cIm5wbVwiIC1vIC4vYFxuICogQ29weXJpZ2h0IGpRdWVyeSBGb3VuZGF0aW9uIGFuZCBvdGhlciBjb250cmlidXRvcnMgPGh0dHBzOi8vanF1ZXJ5Lm9yZy8+XG4gKiBSZWxlYXNlZCB1bmRlciBNSVQgbGljZW5zZSA8aHR0cHM6Ly9sb2Rhc2guY29tL2xpY2Vuc2U+XG4gKiBCYXNlZCBvbiBVbmRlcnNjb3JlLmpzIDEuOC4zIDxodHRwOi8vdW5kZXJzY29yZWpzLm9yZy9MSUNFTlNFPlxuICogQ29weXJpZ2h0IEplcmVteSBBc2hrZW5hcywgRG9jdW1lbnRDbG91ZCBhbmQgSW52ZXN0aWdhdGl2ZSBSZXBvcnRlcnMgJiBFZGl0b3JzXG4gKi9cblxuLyoqIFVzZWQgYXMgdGhlIGBUeXBlRXJyb3JgIG1lc3NhZ2UgZm9yIFwiRnVuY3Rpb25zXCIgbWV0aG9kcy4gKi9cbnZhciBGVU5DX0VSUk9SX1RFWFQgPSAnRXhwZWN0ZWQgYSBmdW5jdGlvbic7XG5cbi8qKiBVc2VkIGFzIHJlZmVyZW5jZXMgZm9yIHZhcmlvdXMgYE51bWJlcmAgY29uc3RhbnRzLiAqL1xudmFyIE5BTiA9IDAgLyAwO1xuXG4vKiogYE9iamVjdCN0b1N0cmluZ2AgcmVzdWx0IHJlZmVyZW5jZXMuICovXG52YXIgc3ltYm9sVGFnID0gJ1tvYmplY3QgU3ltYm9sXSc7XG5cbi8qKiBVc2VkIHRvIG1hdGNoIGxlYWRpbmcgYW5kIHRyYWlsaW5nIHdoaXRlc3BhY2UuICovXG52YXIgcmVUcmltID0gL15cXHMrfFxccyskL2c7XG5cbi8qKiBVc2VkIHRvIGRldGVjdCBiYWQgc2lnbmVkIGhleGFkZWNpbWFsIHN0cmluZyB2YWx1ZXMuICovXG52YXIgcmVJc0JhZEhleCA9IC9eWy0rXTB4WzAtOWEtZl0rJC9pO1xuXG4vKiogVXNlZCB0byBkZXRlY3QgYmluYXJ5IHN0cmluZyB2YWx1ZXMuICovXG52YXIgcmVJc0JpbmFyeSA9IC9eMGJbMDFdKyQvaTtcblxuLyoqIFVzZWQgdG8gZGV0ZWN0IG9jdGFsIHN0cmluZyB2YWx1ZXMuICovXG52YXIgcmVJc09jdGFsID0gL14wb1swLTddKyQvaTtcblxuLyoqIEJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzIHdpdGhvdXQgYSBkZXBlbmRlbmN5IG9uIGByb290YC4gKi9cbnZhciBmcmVlUGFyc2VJbnQgPSBwYXJzZUludDtcblxuLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBnbG9iYWxgIGZyb20gTm9kZS5qcy4gKi9cbnZhciBmcmVlR2xvYmFsID0gdHlwZW9mIGdsb2JhbCA9PSAnb2JqZWN0JyAmJiBnbG9iYWwgJiYgZ2xvYmFsLk9iamVjdCA9PT0gT2JqZWN0ICYmIGdsb2JhbDtcblxuLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBzZWxmYC4gKi9cbnZhciBmcmVlU2VsZiA9IHR5cGVvZiBzZWxmID09ICdvYmplY3QnICYmIHNlbGYgJiYgc2VsZi5PYmplY3QgPT09IE9iamVjdCAmJiBzZWxmO1xuXG4vKiogVXNlZCBhcyBhIHJlZmVyZW5jZSB0byB0aGUgZ2xvYmFsIG9iamVjdC4gKi9cbnZhciByb290ID0gZnJlZUdsb2JhbCB8fCBmcmVlU2VsZiB8fCBGdW5jdGlvbigncmV0dXJuIHRoaXMnKSgpO1xuXG4vKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKipcbiAqIFVzZWQgdG8gcmVzb2x2ZSB0aGVcbiAqIFtgdG9TdHJpbmdUYWdgXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1vYmplY3QucHJvdG90eXBlLnRvc3RyaW5nKVxuICogb2YgdmFsdWVzLlxuICovXG52YXIgb2JqZWN0VG9TdHJpbmcgPSBvYmplY3RQcm90by50b1N0cmluZztcblxuLyogQnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMgZm9yIHRob3NlIHdpdGggdGhlIHNhbWUgbmFtZSBhcyBvdGhlciBgbG9kYXNoYCBtZXRob2RzLiAqL1xudmFyIG5hdGl2ZU1heCA9IE1hdGgubWF4LFxuICAgIG5hdGl2ZU1pbiA9IE1hdGgubWluO1xuXG4vKipcbiAqIEdldHMgdGhlIHRpbWVzdGFtcCBvZiB0aGUgbnVtYmVyIG9mIG1pbGxpc2Vjb25kcyB0aGF0IGhhdmUgZWxhcHNlZCBzaW5jZVxuICogdGhlIFVuaXggZXBvY2ggKDEgSmFudWFyeSAxOTcwIDAwOjAwOjAwIFVUQykuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAyLjQuMFxuICogQGNhdGVnb3J5IERhdGVcbiAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIHRpbWVzdGFtcC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5kZWZlcihmdW5jdGlvbihzdGFtcCkge1xuICogICBjb25zb2xlLmxvZyhfLm5vdygpIC0gc3RhbXApO1xuICogfSwgXy5ub3coKSk7XG4gKiAvLyA9PiBMb2dzIHRoZSBudW1iZXIgb2YgbWlsbGlzZWNvbmRzIGl0IHRvb2sgZm9yIHRoZSBkZWZlcnJlZCBpbnZvY2F0aW9uLlxuICovXG52YXIgbm93ID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiByb290LkRhdGUubm93KCk7XG59O1xuXG4vKipcbiAqIENyZWF0ZXMgYSBkZWJvdW5jZWQgZnVuY3Rpb24gdGhhdCBkZWxheXMgaW52b2tpbmcgYGZ1bmNgIHVudGlsIGFmdGVyIGB3YWl0YFxuICogbWlsbGlzZWNvbmRzIGhhdmUgZWxhcHNlZCBzaW5jZSB0aGUgbGFzdCB0aW1lIHRoZSBkZWJvdW5jZWQgZnVuY3Rpb24gd2FzXG4gKiBpbnZva2VkLiBUaGUgZGVib3VuY2VkIGZ1bmN0aW9uIGNvbWVzIHdpdGggYSBgY2FuY2VsYCBtZXRob2QgdG8gY2FuY2VsXG4gKiBkZWxheWVkIGBmdW5jYCBpbnZvY2F0aW9ucyBhbmQgYSBgZmx1c2hgIG1ldGhvZCB0byBpbW1lZGlhdGVseSBpbnZva2UgdGhlbS5cbiAqIFByb3ZpZGUgYG9wdGlvbnNgIHRvIGluZGljYXRlIHdoZXRoZXIgYGZ1bmNgIHNob3VsZCBiZSBpbnZva2VkIG9uIHRoZVxuICogbGVhZGluZyBhbmQvb3IgdHJhaWxpbmcgZWRnZSBvZiB0aGUgYHdhaXRgIHRpbWVvdXQuIFRoZSBgZnVuY2AgaXMgaW52b2tlZFxuICogd2l0aCB0aGUgbGFzdCBhcmd1bWVudHMgcHJvdmlkZWQgdG8gdGhlIGRlYm91bmNlZCBmdW5jdGlvbi4gU3Vic2VxdWVudFxuICogY2FsbHMgdG8gdGhlIGRlYm91bmNlZCBmdW5jdGlvbiByZXR1cm4gdGhlIHJlc3VsdCBvZiB0aGUgbGFzdCBgZnVuY2BcbiAqIGludm9jYXRpb24uXG4gKlxuICogKipOb3RlOioqIElmIGBsZWFkaW5nYCBhbmQgYHRyYWlsaW5nYCBvcHRpb25zIGFyZSBgdHJ1ZWAsIGBmdW5jYCBpc1xuICogaW52b2tlZCBvbiB0aGUgdHJhaWxpbmcgZWRnZSBvZiB0aGUgdGltZW91dCBvbmx5IGlmIHRoZSBkZWJvdW5jZWQgZnVuY3Rpb25cbiAqIGlzIGludm9rZWQgbW9yZSB0aGFuIG9uY2UgZHVyaW5nIHRoZSBgd2FpdGAgdGltZW91dC5cbiAqXG4gKiBJZiBgd2FpdGAgaXMgYDBgIGFuZCBgbGVhZGluZ2AgaXMgYGZhbHNlYCwgYGZ1bmNgIGludm9jYXRpb24gaXMgZGVmZXJyZWRcbiAqIHVudGlsIHRvIHRoZSBuZXh0IHRpY2ssIHNpbWlsYXIgdG8gYHNldFRpbWVvdXRgIHdpdGggYSB0aW1lb3V0IG9mIGAwYC5cbiAqXG4gKiBTZWUgW0RhdmlkIENvcmJhY2hvJ3MgYXJ0aWNsZV0oaHR0cHM6Ly9jc3MtdHJpY2tzLmNvbS9kZWJvdW5jaW5nLXRocm90dGxpbmctZXhwbGFpbmVkLWV4YW1wbGVzLylcbiAqIGZvciBkZXRhaWxzIG92ZXIgdGhlIGRpZmZlcmVuY2VzIGJldHdlZW4gYF8uZGVib3VuY2VgIGFuZCBgXy50aHJvdHRsZWAuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAwLjEuMFxuICogQGNhdGVnb3J5IEZ1bmN0aW9uXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBkZWJvdW5jZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbd2FpdD0wXSBUaGUgbnVtYmVyIG9mIG1pbGxpc2Vjb25kcyB0byBkZWxheS5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9ucz17fV0gVGhlIG9wdGlvbnMgb2JqZWN0LlxuICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5sZWFkaW5nPWZhbHNlXVxuICogIFNwZWNpZnkgaW52b2tpbmcgb24gdGhlIGxlYWRpbmcgZWRnZSBvZiB0aGUgdGltZW91dC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0aW9ucy5tYXhXYWl0XVxuICogIFRoZSBtYXhpbXVtIHRpbWUgYGZ1bmNgIGlzIGFsbG93ZWQgdG8gYmUgZGVsYXllZCBiZWZvcmUgaXQncyBpbnZva2VkLlxuICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy50cmFpbGluZz10cnVlXVxuICogIFNwZWNpZnkgaW52b2tpbmcgb24gdGhlIHRyYWlsaW5nIGVkZ2Ugb2YgdGhlIHRpbWVvdXQuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBkZWJvdW5jZWQgZnVuY3Rpb24uXG4gKiBAZXhhbXBsZVxuICpcbiAqIC8vIEF2b2lkIGNvc3RseSBjYWxjdWxhdGlvbnMgd2hpbGUgdGhlIHdpbmRvdyBzaXplIGlzIGluIGZsdXguXG4gKiBqUXVlcnkod2luZG93KS5vbigncmVzaXplJywgXy5kZWJvdW5jZShjYWxjdWxhdGVMYXlvdXQsIDE1MCkpO1xuICpcbiAqIC8vIEludm9rZSBgc2VuZE1haWxgIHdoZW4gY2xpY2tlZCwgZGVib3VuY2luZyBzdWJzZXF1ZW50IGNhbGxzLlxuICogalF1ZXJ5KGVsZW1lbnQpLm9uKCdjbGljaycsIF8uZGVib3VuY2Uoc2VuZE1haWwsIDMwMCwge1xuICogICAnbGVhZGluZyc6IHRydWUsXG4gKiAgICd0cmFpbGluZyc6IGZhbHNlXG4gKiB9KSk7XG4gKlxuICogLy8gRW5zdXJlIGBiYXRjaExvZ2AgaXMgaW52b2tlZCBvbmNlIGFmdGVyIDEgc2Vjb25kIG9mIGRlYm91bmNlZCBjYWxscy5cbiAqIHZhciBkZWJvdW5jZWQgPSBfLmRlYm91bmNlKGJhdGNoTG9nLCAyNTAsIHsgJ21heFdhaXQnOiAxMDAwIH0pO1xuICogdmFyIHNvdXJjZSA9IG5ldyBFdmVudFNvdXJjZSgnL3N0cmVhbScpO1xuICogalF1ZXJ5KHNvdXJjZSkub24oJ21lc3NhZ2UnLCBkZWJvdW5jZWQpO1xuICpcbiAqIC8vIENhbmNlbCB0aGUgdHJhaWxpbmcgZGVib3VuY2VkIGludm9jYXRpb24uXG4gKiBqUXVlcnkod2luZG93KS5vbigncG9wc3RhdGUnLCBkZWJvdW5jZWQuY2FuY2VsKTtcbiAqL1xuZnVuY3Rpb24gZGVib3VuY2UoZnVuYywgd2FpdCwgb3B0aW9ucykge1xuICB2YXIgbGFzdEFyZ3MsXG4gICAgICBsYXN0VGhpcyxcbiAgICAgIG1heFdhaXQsXG4gICAgICByZXN1bHQsXG4gICAgICB0aW1lcklkLFxuICAgICAgbGFzdENhbGxUaW1lLFxuICAgICAgbGFzdEludm9rZVRpbWUgPSAwLFxuICAgICAgbGVhZGluZyA9IGZhbHNlLFxuICAgICAgbWF4aW5nID0gZmFsc2UsXG4gICAgICB0cmFpbGluZyA9IHRydWU7XG5cbiAgaWYgKHR5cGVvZiBmdW5jICE9ICdmdW5jdGlvbicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKEZVTkNfRVJST1JfVEVYVCk7XG4gIH1cbiAgd2FpdCA9IHRvTnVtYmVyKHdhaXQpIHx8IDA7XG4gIGlmIChpc09iamVjdChvcHRpb25zKSkge1xuICAgIGxlYWRpbmcgPSAhIW9wdGlvbnMubGVhZGluZztcbiAgICBtYXhpbmcgPSAnbWF4V2FpdCcgaW4gb3B0aW9ucztcbiAgICBtYXhXYWl0ID0gbWF4aW5nID8gbmF0aXZlTWF4KHRvTnVtYmVyKG9wdGlvbnMubWF4V2FpdCkgfHwgMCwgd2FpdCkgOiBtYXhXYWl0O1xuICAgIHRyYWlsaW5nID0gJ3RyYWlsaW5nJyBpbiBvcHRpb25zID8gISFvcHRpb25zLnRyYWlsaW5nIDogdHJhaWxpbmc7XG4gIH1cblxuICBmdW5jdGlvbiBpbnZva2VGdW5jKHRpbWUpIHtcbiAgICB2YXIgYXJncyA9IGxhc3RBcmdzLFxuICAgICAgICB0aGlzQXJnID0gbGFzdFRoaXM7XG5cbiAgICBsYXN0QXJncyA9IGxhc3RUaGlzID0gdW5kZWZpbmVkO1xuICAgIGxhc3RJbnZva2VUaW1lID0gdGltZTtcbiAgICByZXN1bHQgPSBmdW5jLmFwcGx5KHRoaXNBcmcsIGFyZ3MpO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICBmdW5jdGlvbiBsZWFkaW5nRWRnZSh0aW1lKSB7XG4gICAgLy8gUmVzZXQgYW55IGBtYXhXYWl0YCB0aW1lci5cbiAgICBsYXN0SW52b2tlVGltZSA9IHRpbWU7XG4gICAgLy8gU3RhcnQgdGhlIHRpbWVyIGZvciB0aGUgdHJhaWxpbmcgZWRnZS5cbiAgICB0aW1lcklkID0gc2V0VGltZW91dCh0aW1lckV4cGlyZWQsIHdhaXQpO1xuICAgIC8vIEludm9rZSB0aGUgbGVhZGluZyBlZGdlLlxuICAgIHJldHVybiBsZWFkaW5nID8gaW52b2tlRnVuYyh0aW1lKSA6IHJlc3VsdDtcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlbWFpbmluZ1dhaXQodGltZSkge1xuICAgIHZhciB0aW1lU2luY2VMYXN0Q2FsbCA9IHRpbWUgLSBsYXN0Q2FsbFRpbWUsXG4gICAgICAgIHRpbWVTaW5jZUxhc3RJbnZva2UgPSB0aW1lIC0gbGFzdEludm9rZVRpbWUsXG4gICAgICAgIHJlc3VsdCA9IHdhaXQgLSB0aW1lU2luY2VMYXN0Q2FsbDtcblxuICAgIHJldHVybiBtYXhpbmcgPyBuYXRpdmVNaW4ocmVzdWx0LCBtYXhXYWl0IC0gdGltZVNpbmNlTGFzdEludm9rZSkgOiByZXN1bHQ7XG4gIH1cblxuICBmdW5jdGlvbiBzaG91bGRJbnZva2UodGltZSkge1xuICAgIHZhciB0aW1lU2luY2VMYXN0Q2FsbCA9IHRpbWUgLSBsYXN0Q2FsbFRpbWUsXG4gICAgICAgIHRpbWVTaW5jZUxhc3RJbnZva2UgPSB0aW1lIC0gbGFzdEludm9rZVRpbWU7XG5cbiAgICAvLyBFaXRoZXIgdGhpcyBpcyB0aGUgZmlyc3QgY2FsbCwgYWN0aXZpdHkgaGFzIHN0b3BwZWQgYW5kIHdlJ3JlIGF0IHRoZVxuICAgIC8vIHRyYWlsaW5nIGVkZ2UsIHRoZSBzeXN0ZW0gdGltZSBoYXMgZ29uZSBiYWNrd2FyZHMgYW5kIHdlJ3JlIHRyZWF0aW5nXG4gICAgLy8gaXQgYXMgdGhlIHRyYWlsaW5nIGVkZ2UsIG9yIHdlJ3ZlIGhpdCB0aGUgYG1heFdhaXRgIGxpbWl0LlxuICAgIHJldHVybiAobGFzdENhbGxUaW1lID09PSB1bmRlZmluZWQgfHwgKHRpbWVTaW5jZUxhc3RDYWxsID49IHdhaXQpIHx8XG4gICAgICAodGltZVNpbmNlTGFzdENhbGwgPCAwKSB8fCAobWF4aW5nICYmIHRpbWVTaW5jZUxhc3RJbnZva2UgPj0gbWF4V2FpdCkpO1xuICB9XG5cbiAgZnVuY3Rpb24gdGltZXJFeHBpcmVkKCkge1xuICAgIHZhciB0aW1lID0gbm93KCk7XG4gICAgaWYgKHNob3VsZEludm9rZSh0aW1lKSkge1xuICAgICAgcmV0dXJuIHRyYWlsaW5nRWRnZSh0aW1lKTtcbiAgICB9XG4gICAgLy8gUmVzdGFydCB0aGUgdGltZXIuXG4gICAgdGltZXJJZCA9IHNldFRpbWVvdXQodGltZXJFeHBpcmVkLCByZW1haW5pbmdXYWl0KHRpbWUpKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHRyYWlsaW5nRWRnZSh0aW1lKSB7XG4gICAgdGltZXJJZCA9IHVuZGVmaW5lZDtcblxuICAgIC8vIE9ubHkgaW52b2tlIGlmIHdlIGhhdmUgYGxhc3RBcmdzYCB3aGljaCBtZWFucyBgZnVuY2AgaGFzIGJlZW5cbiAgICAvLyBkZWJvdW5jZWQgYXQgbGVhc3Qgb25jZS5cbiAgICBpZiAodHJhaWxpbmcgJiYgbGFzdEFyZ3MpIHtcbiAgICAgIHJldHVybiBpbnZva2VGdW5jKHRpbWUpO1xuICAgIH1cbiAgICBsYXN0QXJncyA9IGxhc3RUaGlzID0gdW5kZWZpbmVkO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICBmdW5jdGlvbiBjYW5jZWwoKSB7XG4gICAgaWYgKHRpbWVySWQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgY2xlYXJUaW1lb3V0KHRpbWVySWQpO1xuICAgIH1cbiAgICBsYXN0SW52b2tlVGltZSA9IDA7XG4gICAgbGFzdEFyZ3MgPSBsYXN0Q2FsbFRpbWUgPSBsYXN0VGhpcyA9IHRpbWVySWQgPSB1bmRlZmluZWQ7XG4gIH1cblxuICBmdW5jdGlvbiBmbHVzaCgpIHtcbiAgICByZXR1cm4gdGltZXJJZCA9PT0gdW5kZWZpbmVkID8gcmVzdWx0IDogdHJhaWxpbmdFZGdlKG5vdygpKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGRlYm91bmNlZCgpIHtcbiAgICB2YXIgdGltZSA9IG5vdygpLFxuICAgICAgICBpc0ludm9raW5nID0gc2hvdWxkSW52b2tlKHRpbWUpO1xuXG4gICAgbGFzdEFyZ3MgPSBhcmd1bWVudHM7XG4gICAgbGFzdFRoaXMgPSB0aGlzO1xuICAgIGxhc3RDYWxsVGltZSA9IHRpbWU7XG5cbiAgICBpZiAoaXNJbnZva2luZykge1xuICAgICAgaWYgKHRpbWVySWQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gbGVhZGluZ0VkZ2UobGFzdENhbGxUaW1lKTtcbiAgICAgIH1cbiAgICAgIGlmIChtYXhpbmcpIHtcbiAgICAgICAgLy8gSGFuZGxlIGludm9jYXRpb25zIGluIGEgdGlnaHQgbG9vcC5cbiAgICAgICAgdGltZXJJZCA9IHNldFRpbWVvdXQodGltZXJFeHBpcmVkLCB3YWl0KTtcbiAgICAgICAgcmV0dXJuIGludm9rZUZ1bmMobGFzdENhbGxUaW1lKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHRpbWVySWQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgdGltZXJJZCA9IHNldFRpbWVvdXQodGltZXJFeHBpcmVkLCB3YWl0KTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuICBkZWJvdW5jZWQuY2FuY2VsID0gY2FuY2VsO1xuICBkZWJvdW5jZWQuZmx1c2ggPSBmbHVzaDtcbiAgcmV0dXJuIGRlYm91bmNlZDtcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyB0aGVcbiAqIFtsYW5ndWFnZSB0eXBlXShodHRwOi8vd3d3LmVjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtZWNtYXNjcmlwdC1sYW5ndWFnZS10eXBlcylcbiAqIG9mIGBPYmplY3RgLiAoZS5nLiBhcnJheXMsIGZ1bmN0aW9ucywgb2JqZWN0cywgcmVnZXhlcywgYG5ldyBOdW1iZXIoMClgLCBhbmQgYG5ldyBTdHJpbmcoJycpYClcbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuMS4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhbiBvYmplY3QsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc09iamVjdCh7fSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc09iamVjdChbMSwgMiwgM10pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNPYmplY3QoXy5ub29wKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzT2JqZWN0KG51bGwpO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNPYmplY3QodmFsdWUpIHtcbiAgdmFyIHR5cGUgPSB0eXBlb2YgdmFsdWU7XG4gIHJldHVybiAhIXZhbHVlICYmICh0eXBlID09ICdvYmplY3QnIHx8IHR5cGUgPT0gJ2Z1bmN0aW9uJyk7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgb2JqZWN0LWxpa2UuIEEgdmFsdWUgaXMgb2JqZWN0LWxpa2UgaWYgaXQncyBub3QgYG51bGxgXG4gKiBhbmQgaGFzIGEgYHR5cGVvZmAgcmVzdWx0IG9mIFwib2JqZWN0XCIuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgb2JqZWN0LWxpa2UsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc09iamVjdExpa2Uoe30pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNPYmplY3RMaWtlKFsxLCAyLCAzXSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc09iamVjdExpa2UoXy5ub29wKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5pc09iamVjdExpa2UobnVsbCk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc09iamVjdExpa2UodmFsdWUpIHtcbiAgcmV0dXJuICEhdmFsdWUgJiYgdHlwZW9mIHZhbHVlID09ICdvYmplY3QnO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGNsYXNzaWZpZWQgYXMgYSBgU3ltYm9sYCBwcmltaXRpdmUgb3Igb2JqZWN0LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4wLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgc3ltYm9sLCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNTeW1ib2woU3ltYm9sLml0ZXJhdG9yKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzU3ltYm9sKCdhYmMnKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzU3ltYm9sKHZhbHVlKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsdWUgPT0gJ3N5bWJvbCcgfHxcbiAgICAoaXNPYmplY3RMaWtlKHZhbHVlKSAmJiBvYmplY3RUb1N0cmluZy5jYWxsKHZhbHVlKSA9PSBzeW1ib2xUYWcpO1xufVxuXG4vKipcbiAqIENvbnZlcnRzIGB2YWx1ZWAgdG8gYSBudW1iZXIuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHByb2Nlc3MuXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBudW1iZXIuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8udG9OdW1iZXIoMy4yKTtcbiAqIC8vID0+IDMuMlxuICpcbiAqIF8udG9OdW1iZXIoTnVtYmVyLk1JTl9WQUxVRSk7XG4gKiAvLyA9PiA1ZS0zMjRcbiAqXG4gKiBfLnRvTnVtYmVyKEluZmluaXR5KTtcbiAqIC8vID0+IEluZmluaXR5XG4gKlxuICogXy50b051bWJlcignMy4yJyk7XG4gKiAvLyA9PiAzLjJcbiAqL1xuZnVuY3Rpb24gdG9OdW1iZXIodmFsdWUpIHtcbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PSAnbnVtYmVyJykge1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuICBpZiAoaXNTeW1ib2wodmFsdWUpKSB7XG4gICAgcmV0dXJuIE5BTjtcbiAgfVxuICBpZiAoaXNPYmplY3QodmFsdWUpKSB7XG4gICAgdmFyIG90aGVyID0gdHlwZW9mIHZhbHVlLnZhbHVlT2YgPT0gJ2Z1bmN0aW9uJyA/IHZhbHVlLnZhbHVlT2YoKSA6IHZhbHVlO1xuICAgIHZhbHVlID0gaXNPYmplY3Qob3RoZXIpID8gKG90aGVyICsgJycpIDogb3RoZXI7XG4gIH1cbiAgaWYgKHR5cGVvZiB2YWx1ZSAhPSAnc3RyaW5nJykge1xuICAgIHJldHVybiB2YWx1ZSA9PT0gMCA/IHZhbHVlIDogK3ZhbHVlO1xuICB9XG4gIHZhbHVlID0gdmFsdWUucmVwbGFjZShyZVRyaW0sICcnKTtcbiAgdmFyIGlzQmluYXJ5ID0gcmVJc0JpbmFyeS50ZXN0KHZhbHVlKTtcbiAgcmV0dXJuIChpc0JpbmFyeSB8fCByZUlzT2N0YWwudGVzdCh2YWx1ZSkpXG4gICAgPyBmcmVlUGFyc2VJbnQodmFsdWUuc2xpY2UoMiksIGlzQmluYXJ5ID8gMiA6IDgpXG4gICAgOiAocmVJc0JhZEhleC50ZXN0KHZhbHVlKSA/IE5BTiA6ICt2YWx1ZSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZGVib3VuY2U7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/lodash.debounce/index.js\n"));

/***/ }),

/***/ "./components/GlyphsMode.jsx":
/*!***********************************!*\
  !*** ./components/GlyphsMode.jsx ***!
  \***********************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"./node_modules/react/jsx-dev-runtime.js\");\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"./node_modules/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var react_toastify__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! react-toastify */ \"./node_modules/react-toastify/dist/index.mjs\");\n/* harmony import */ var react_virtuoso__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! react-virtuoso */ \"./node_modules/react-virtuoso/dist/index.mjs\");\n/* harmony import */ var lodash_debounce__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! lodash.debounce */ \"./node_modules/lodash.debounce/index.js\");\n/* harmony import */ var lodash_debounce__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(lodash_debounce__WEBPACK_IMPORTED_MODULE_3__);\n/* harmony import */ var _utils_fontParser__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../utils/fontParser */ \"./utils/fontParser.js\");\n/* harmony import */ var _contexts_SettingsContext__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../contexts/SettingsContext */ \"./contexts/SettingsContext.js\");\n/* harmony import */ var _contexts_FontContext__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../contexts/FontContext */ \"./contexts/FontContext.js\");\n\nvar _s = $RefreshSig$();\n\n\n\n\n\n\n\n// Инициализируем глобальный кэш для глифов, чтобы не загружать их повторно\nconst glyphDataCache = new Map();\n/**\n * Компонент для режима отображения глифов шрифта\n * \n * @param {Object} props - Свойства компонента\n * @param {Object} props.selectedFont - Выбранный шрифт\n * @param {string} props.fontFamily - Семейство шрифтов\n * @param {Object} props.glyphDisplayStyle - Стили для отображения глифов\n * @param {boolean} props.isActive - Активен ли режим глифов\n */ function GlyphsMode(param) {\n    let { selectedFont, fontFamily, glyphDisplayStyle, isActive = true } = param;\n    _s();\n    const { fontSize } = (0,_contexts_SettingsContext__WEBPACK_IMPORTED_MODULE_5__.useSettings)();\n    const { getFontFamily, getVariationSettings } = (0,_contexts_FontContext__WEBPACK_IMPORTED_MODULE_6__.useFontContext)();\n    const { settings, glyphSettings } = (0,_contexts_SettingsContext__WEBPACK_IMPORTED_MODULE_5__.useSettings)();\n    // ОТЛАДКА: Детальные логи для глифов\n    console.log(\"[GlyphsMode] ДЕТАЛЬНАЯ ОТЛАДКА:\", {\n        selectedFont: selectedFont === null || selectedFont === void 0 ? void 0 : selectedFont.name,\n        isVariableFont: selectedFont === null || selectedFont === void 0 ? void 0 : selectedFont.isVariableFont,\n        fontFamily,\n        glyphDisplayStyle,\n        fontSize,\n        selectedFont_id: selectedFont === null || selectedFont === void 0 ? void 0 : selectedFont.id,\n        selectedFont_fontFamily: selectedFont === null || selectedFont === void 0 ? void 0 : selectedFont.fontFamily\n    });\n    // console.log(\"GlyphsMode - Selected Font:\", selectedFont); // Удаляем закомментированный лог\n    // console.log(\"GlyphsMode - Settings:\", settings); // Удаляем закомментированный лог\n    // console.log(\"GlyphsMode - Glyph Settings:\", glyphSettings); // Удаляем закомментированный лог\n    try {\n        // Состояние и ref для загрузки глифов\n        const [glyphsLoaded, setGlyphsLoaded] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false);\n        const [glyphsData, setGlyphsData] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null);\n        const [glyphErrors, setGlyphErrors] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)([]); // <<< Новое состояние для ошибок\n        const isLoadingGlyphs = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(false);\n        // Ref для отслеживания текущего запроса, чтобы предотвратить race condition\n        const currentLoadId = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n        // Оборачиваем loadGlyphs в useCallback, чтобы ссылка на функцию была стабильной\n        const loadGlyphsCallback = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)(async (currentAttemptLoadId, fontToLoad, attemptFontId)=>{\n            // Проверяем, не отменен ли этот запрос (т.е. начался ли новый)\n            if (currentAttemptLoadId !== currentLoadId.current) {\n                return;\n            }\n            try {\n                // Сбрасываем состояние только если этот запрос все еще актуален\n                if (currentAttemptLoadId === currentLoadId.current) {\n                    setGlyphsLoaded(false);\n                    setGlyphsData(null);\n                    setGlyphErrors([]); // <<< Сбрасываем ошибки\n                }\n                // Проверяем кэш\n                if (glyphDataCache.has(attemptFontId)) {\n                    const cachedData = glyphDataCache.get(attemptFontId);\n                    if (currentAttemptLoadId === currentLoadId.current) {\n                        setGlyphsData(cachedData);\n                        setGlyphsLoaded(true);\n                        setGlyphErrors(cachedData.errors || []); // <<< Загружаем ошибки из кэша\n                        isLoadingGlyphs.current = false;\n                        if (!(cachedData === null || cachedData === void 0 ? void 0 : cachedData.allGlyphs)) {\n                            console.warn(\"Cached glyph data is missing 'allGlyphs'.\");\n                        }\n                    }\n                    return;\n                }\n                const data = await (0,_utils_fontParser__WEBPACK_IMPORTED_MODULE_4__.getGlyphDataForFont)(fontToLoad); // Используем переданный fontToLoad\n                // СНОВА проверяем, актуален ли запрос ПЕРЕД установкой состояния\n                if (currentAttemptLoadId !== currentLoadId.current) {\n                    return;\n                }\n                if (!data || !Array.isArray(data.allGlyphs)) {\n                    throw new Error(\"Получены некорректные данные глифов (отсутствует allGlyphs).\");\n                }\n                glyphDataCache.set(attemptFontId, data); // Используем attemptFontId для кэша\n                setGlyphsData(data);\n                setGlyphsLoaded(true);\n                setGlyphErrors(data.errors || []); // <<< Сохраняем ошибки\n                isLoadingGlyphs.current = false;\n            } catch (error) {\n                console.error(\"[GlyphsMode Debounced] Ошибка при загрузке глифов:\", error);\n                react_toastify__WEBPACK_IMPORTED_MODULE_2__.toast.error(\"Не удалось загрузить данные глифов: \".concat(error.message));\n                if (currentAttemptLoadId === currentLoadId.current) {\n                    setGlyphsData(null);\n                    setGlyphsLoaded(false);\n                    setGlyphErrors([]); // <<< Сбрасываем ошибки при ошибке\n                    isLoadingGlyphs.current = false;\n                }\n            }\n        }, []); // Пустой массив зависимостей для useCallback\n        // Создаем мемоизированную debounced-версию\n        const debouncedLoadGlyphs = (0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)(()=>{\n            return lodash_debounce__WEBPACK_IMPORTED_MODULE_3___default()(loadGlyphsCallback, 200); // Задержка 200ms\n        }, [\n            loadGlyphsCallback\n        ]);\n        // Единый useEffect для загрузки и сброса состояния глифов\n        (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n            if (!isActive) {\n                return;\n            }\n            const fontId = selectedFont === null || selectedFont === void 0 ? void 0 : selectedFont.id;\n            const fontSource = selectedFont === null || selectedFont === void 0 ? void 0 : selectedFont.source;\n            const loadId = Math.random().toString(36).substring(2, 10);\n            currentLoadId.current = loadId;\n            const resetState = function() {\n                let logMessage = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : \"Resetting glyph state\";\n                // console.log(`[GlyphsMode useEffect] ${logMessage} - Load ID: ${loadId}`); // Удаляем лог\n                setGlyphsLoaded(false);\n                setGlyphsData(null);\n                setGlyphErrors([]); // <<< Сброс ошибок\n                isLoadingGlyphs.current = false; // Сбрасываем флаг загрузки\n            };\n            // --- Проверки перед загрузкой --- \n            if (!selectedFont) {\n                resetState(\"No font selected, resetting state.\");\n                return;\n            }\n            // !!! ДОБАВЛЕНА ПРОВЕРКА на selectedFont.file !!!\n            if (!selectedFont.file || !(selectedFont.file instanceof Blob)) {\n                resetState(\"Invalid font file for \".concat(selectedFont.name, \", resetting state.\"));\n                console.warn(\"[GlyphsMode] Attempted to load glyphs for \".concat(selectedFont.name, \" without a valid file object.\"));\n                return;\n            }\n            if (fontSource === \"google\") {\n                if (!glyphsData && !isLoadingGlyphs.current) {\n                    react_toastify__WEBPACK_IMPORTED_MODULE_2__.toast.info(\"Просмотр глифов пока недоступен для Google Fonts.\");\n                }\n                resetState(\"Google Font selected, resetting state.\");\n                return;\n            }\n            // --- Запуск загрузки через debounce ---\n            const isDataLoadedInState = glyphsLoaded && glyphsData && glyphsData.allGlyphs;\n            if (!isDataLoadedInState) {\n                // console.log(`[GlyphsMode useEffect] Data not loaded, calling debouncedLoadGlyphs. Load ID: ${loadId}`); // Удаляем лог\n                // Устанавливаем флаг загрузки ПЕРЕД вызовом debounced функции\n                isLoadingGlyphs.current = true;\n                // Вызываем debounced-функцию, передавая необходимые параметры\n                debouncedLoadGlyphs(loadId, selectedFont, fontId);\n            } else {\n                // console.log(`[GlyphsMode useEffect] Data already loaded or loading. Load ID: ${loadId}`); // Удаляем лог\n                // Если данные уже загружены, но флаг загрузки все еще стоит (маловероятно, но возможно)\n                if (isLoadingGlyphs.current) {\n                    // console.log(`[GlyphsMode useEffect] Resetting isLoadingGlyphs flag. Load ID: ${loadId}`); // Удаляем лог\n                    isLoadingGlyphs.current = false;\n                }\n            }\n            // Функция очистки для useEffect\n            return ()=>{\n                // console.log(`[GlyphsMode useEffect Cleanup] Cancelling debounced call if any. Load ID: ${loadId}`); // Удаляем лог\n                // Отменяем любые отложенные вызовы debouncedLoadGlyphs\n                debouncedLoadGlyphs.cancel();\n            // Сбрасываем currentLoadId, чтобы будущие колбэки от этого useEffect не выполнились\n            // currentLoadId.current = null; // Не сбрасываем здесь, чтобы обработать последний актуальный вызов\n            };\n        }, [\n            selectedFont,\n            isActive,\n            debouncedLoadGlyphs\n        ]); // Добавляем selectedFont и debouncedLoadGlyphs в зависимости\n        // Стили для отображения увеличенного глифа в модальном окне\n        const largeGlyphStyle = (0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)(()=>{\n            // Используем fontSize из useSettings вместо selectedFontSize\n            const baseSize = fontSize || 40; // Используем fontSize, fallback 40\n            const modalFontSize = Math.max(80, Math.min(200, baseSize * 2.5));\n            return {\n                fontFamily: fontFamily ? fontFamily.includes(\"'\") ? fontFamily : \"'\".concat(fontFamily, \"'\") : \"inherit\",\n                fontSize: \"\".concat(modalFontSize, \"px\"),\n                lineHeight: 1,\n                ...glyphDisplayStyle || {}\n            };\n        }, [\n            fontFamily,\n            glyphDisplayStyle,\n            fontSize\n        ]);\n        // Функция копирования символа в буфер обмена (остается)\n        const copyToClipboard = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)(function(text) {\n            let type = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : \"Символ\";\n            if (!text) {\n                return;\n            }\n            navigator.clipboard.writeText(text).then(()=>{\n                react_toastify__WEBPACK_IMPORTED_MODULE_2__.toast.success(\"\".concat(type, ' \"').concat(text, '\" скопирован'));\n            }).catch((err)=>{\n                console.error(\"Не удалось скопировать: \", err);\n                react_toastify__WEBPACK_IMPORTED_MODULE_2__.toast.error(\"Не удалось скопировать \".concat(type.toLowerCase()));\n            });\n        }, []);\n        // --- Логика для отображения ВСЕХ глифов ---\n        // Обновляем useMemo для использования glyphsData.allGlyphs\n        const displayableGlyphs = (0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)(()=>{\n            // Используем allGlyphs БЕЗ дополнительной фильтрации .notdef\n            return (glyphsData === null || glyphsData === void 0 ? void 0 : glyphsData.allGlyphs) || [];\n        }, [\n            glyphsData\n        ]);\n        // Хелперы для получения имени и Unicode\n        // Обновляем для использования glyphsData.names и glyphsData.unicodes\n        const getGlyphName = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)((glyph)=>{\n            var _glyphsData_names;\n            // Сначала пробуем из карты names, потом из самого объекта glyph\n            return (glyphsData === null || glyphsData === void 0 ? void 0 : (_glyphsData_names = glyphsData.names) === null || _glyphsData_names === void 0 ? void 0 : _glyphsData_names[glyph === null || glyph === void 0 ? void 0 : glyph.id]) || (glyph === null || glyph === void 0 ? void 0 : glyph.name) || \"Glyph \".concat(glyph === null || glyph === void 0 ? void 0 : glyph.id);\n        }, [\n            glyphsData\n        ]);\n        const getGlyphUnicode = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)((glyph)=>{\n            var _glyphsData_unicodes;\n            // Сначала пробуем из карты unicodes, потом из самого объекта glyph\n            const unicodeValue = glyphsData === null || glyphsData === void 0 ? void 0 : (_glyphsData_unicodes = glyphsData.unicodes) === null || _glyphsData_unicodes === void 0 ? void 0 : _glyphsData_unicodes[glyph === null || glyph === void 0 ? void 0 : glyph.id];\n            if (unicodeValue) return unicodeValue;\n            // Запасной вариант - форматируем из glyph.unicode\n            if (glyph === null || glyph === void 0 ? void 0 : glyph.unicode) {\n                return \"U+\".concat(glyph.unicode.toString(16).toUpperCase().padStart(4, \"0\"));\n            }\n            return \"\"; // Возвращаем пустую строку, если Unicode нет\n        }, [\n            glyphsData\n        ]);\n        // Состояние для модального окна (остается)\n        const [selectedGlyph, setSelectedGlyph] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null);\n        // Условие отображения загрузчика\n        if (isLoadingGlyphs.current) {\n            return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                className: \"p-8 text-center text-blue-600\",\n                children: \"Загрузка данных глифов...\"\n            }, void 0, false, {\n                fileName: \"/Users/igormocalov/Desktop/Font/components/GlyphsMode.jsx\",\n                lineNumber: 249,\n                columnNumber: 15\n            }, this);\n        }\n        // Сообщение, если шрифт - Google Font (проверяется после isLoading)\n        if ((selectedFont === null || selectedFont === void 0 ? void 0 : selectedFont.source) === \"google\") {\n            return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                className: \"p-8 text-center text-gray-500\",\n                children: \"Просмотр глифов недоступен для шрифтов Google.\"\n            }, void 0, false, {\n                fileName: \"/Users/igormocalov/Desktop/Font/components/GlyphsMode.jsx\",\n                lineNumber: 254,\n                columnNumber: 16\n            }, this);\n        }\n        // Условие отображения ошибки или отсутствия данных (после попытки загрузки и не Google Font)\n        if (!glyphsLoaded || !glyphsData || displayableGlyphs.length === 0) {\n            // Не показываем ошибку, если isLoadingGlyphs все еще true\n            if (isLoadingGlyphs.current) return null;\n            return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                className: \"p-8 text-center text-gray-500\",\n                children: [\n                    'Нет данных о глифах для шрифта \"',\n                    (selectedFont === null || selectedFont === void 0 ? void 0 : selectedFont.name) || \"Неизвестный\",\n                    '\" или не удалось их загрузить. Проверьте консоль на наличие ошибок.'\n                ]\n            }, void 0, true, {\n                fileName: \"/Users/igormocalov/Desktop/Font/components/GlyphsMode.jsx\",\n                lineNumber: 262,\n                columnNumber: 11\n            }, this);\n        }\n        // --- Отображение информации об ошибках --- */\n        if (glyphErrors.length > 0) {\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                className: \"mb-4 p-3 bg-yellow-100 border border-yellow-300 text-yellow-800 text-xs rounded\",\n                children: [\n                    \"При обработке шрифта возникло \",\n                    glyphErrors.length,\n                    \" ошибок. Некоторые глифы могут отображаться некорректно.\"\n                ]\n            }, void 0, true, {\n                fileName: \"/Users/igormocalov/Desktop/Font/components/GlyphsMode.jsx\",\n                lineNumber: 271,\n                columnNumber: 7\n            }, this);\n        }\n        // Основной рендер (остается почти без изменений, но использует обновленные хелперы)\n        return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n            className: \"p-8\",\n            children: [\n                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"p\", {\n                    className: \"text-sm text-gray-600 mb-2\",\n                    children: [\n                        \"Найдено \",\n                        displayableGlyphs.length,\n                        \" глифов.\"\n                    ]\n                }, void 0, true, {\n                    fileName: \"/Users/igormocalov/Desktop/Font/components/GlyphsMode.jsx\",\n                    lineNumber: 282,\n                    columnNumber: 9\n                }, this),\n                glyphErrors.length > 0 && /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                    className: \"mb-4 p-3 bg-yellow-100 border border-yellow-300 text-yellow-800 text-xs rounded\",\n                    children: [\n                        \"При обработке шрифта возникло \",\n                        glyphErrors.length,\n                        \" ошибок. Некоторые глифы могут отображаться некорректно.\"\n                    ]\n                }, void 0, true, {\n                    fileName: \"/Users/igormocalov/Desktop/Font/components/GlyphsMode.jsx\",\n                    lineNumber: 286,\n                    columnNumber: 11\n                }, this),\n                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(react_virtuoso__WEBPACK_IMPORTED_MODULE_7__.VirtuosoGrid, {\n                    style: {\n                        height: \"calc(100vh - 120px)\"\n                    },\n                    totalCount: displayableGlyphs.length,\n                    components: {\n                        // Компонент, к которому будут применены стили сетки\n                        List: /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_1___default().forwardRef((param, ref)=>{\n                            let { style, children, ...props } = param;\n                            return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                ref: ref,\n                                ...props,\n                                style: style,\n                                className: \"grid grid-cols-2 sm:grid-cols-4 md:grid-cols-6 lg:grid-cols-8 xl:grid-cols-10 gap-3 mt-6\",\n                                children: children\n                            }, void 0, false, {\n                                fileName: \"/Users/igormocalov/Desktop/Font/components/GlyphsMode.jsx\",\n                                lineNumber: 301,\n                                columnNumber: 15\n                            }, void 0);\n                        })\n                    },\n                    itemContent: (index)=>{\n                        // Получаем глиф по индексу\n                        const glyph = displayableGlyphs[index];\n                        if (!glyph) return null; // На всякий случай\n                        // --- Обновленная логика получения символа (остается та же) ---\n                        let char = null;\n                        let isPrintable = false;\n                        if (glyph.unicode) {\n                            try {\n                                const potentialChar = String.fromCodePoint(glyph.unicode);\n                                if (potentialChar && potentialChar.trim() !== \"\" && !RegExp(\"[\\\\p{C}]\", \"u\").test(potentialChar)) {\n                                    char = potentialChar;\n                                    isPrintable = true;\n                                }\n                            } catch (e) {}\n                        }\n                        if (!isPrintable && glyph.unicodes && glyph.unicodes.length > 0) {\n                            for (const codePoint of glyph.unicodes){\n                                try {\n                                    const potentialChar = String.fromCodePoint(codePoint);\n                                    if (potentialChar && potentialChar.trim() !== \"\" && !RegExp(\"[\\\\p{C}]\", \"u\").test(potentialChar)) {\n                                        char = potentialChar;\n                                        isPrintable = true;\n                                        break;\n                                    }\n                                } catch (e) {}\n                            }\n                        }\n                        // --- Конец обновленной логики ---\n                        const glyphName = getGlyphName(glyph);\n                        const glyphUnicodeStr = getGlyphUnicode(glyph);\n                        // Возвращаем JSX для одного глифа (тот же, что был внутри .map)\n                        return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                            className: \"bg-white h-full rounded-md overflow-hidden border border-gray-200 hover:border-blue-400 hover:shadow-md transition-all cursor-pointer flex flex-col\",\n                            onClick: ()=>setSelectedGlyph(glyph),\n                            title: \"Нажмите, чтобы увидеть детали глифа \".concat(glyphName),\n                            children: [\n                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                    className: \"text-center p-4 flex-grow flex items-center justify-center\",\n                                    style: (()=>{\n                                        const finalStyle = {\n                                            fontSize: \"\".concat(fontSize, \"px\"),\n                                            fontFamily: fontFamily || \"inherit\",\n                                            ...glyphDisplayStyle\n                                        };\n                                        // Логируем стили только для первого глифа (чтобы не спамить)\n                                        if (index === 0) {\n                                            console.log(\"[GlyphsMode] СТИЛИ ГЛИФА #0:\", {\n                                                fontSize: finalStyle.fontSize,\n                                                fontFamily: finalStyle.fontFamily,\n                                                fontVariationSettings: finalStyle.fontVariationSettings,\n                                                fontWeight: finalStyle.fontWeight,\n                                                fontStyle: finalStyle.fontStyle,\n                                                fullStyle: finalStyle\n                                            });\n                                        }\n                                        return finalStyle;\n                                    })(),\n                                    children: isPrintable ? char : /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"span\", {\n                                        className: \"text-gray-400 text-sm\",\n                                        children: \"(no char)\"\n                                    }, void 0, false, {\n                                        fileName: \"/Users/igormocalov/Desktop/Font/components/GlyphsMode.jsx\",\n                                        lineNumber: 381,\n                                        columnNumber: 41\n                                    }, void 0)\n                                }, void 0, false, {\n                                    fileName: \"/Users/igormocalov/Desktop/Font/components/GlyphsMode.jsx\",\n                                    lineNumber: 357,\n                                    columnNumber: 17\n                                }, void 0),\n                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                    className: \"bg-gray-50 p-2 text-[10px]\",\n                                    children: [\n                                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                            className: \"text-gray-700 text-center truncate w-full font-medium\",\n                                            title: glyphName,\n                                            children: glyphName\n                                        }, void 0, false, {\n                                            fileName: \"/Users/igormocalov/Desktop/Font/components/GlyphsMode.jsx\",\n                                            lineNumber: 384,\n                                            columnNumber: 19\n                                        }, void 0),\n                                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                            className: \"text-gray-500 text-center\",\n                                            children: glyphUnicodeStr || \"-\"\n                                        }, void 0, false, {\n                                            fileName: \"/Users/igormocalov/Desktop/Font/components/GlyphsMode.jsx\",\n                                            lineNumber: 387,\n                                            columnNumber: 19\n                                        }, void 0),\n                                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                            className: \"flex justify-center gap-1 mt-1\",\n                                            children: [\n                                                isPrintable && /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"button\", {\n                                                    onClick: (e)=>{\n                                                        e.stopPropagation();\n                                                        copyToClipboard(char, \"Символ\");\n                                                    },\n                                                    className: \"text-[8px] px-1 py-0.5 bg-blue-100 hover:bg-blue-200 text-blue-700 rounded\",\n                                                    title: \"Копировать символ\",\n                                                    children: \"Char\"\n                                                }, void 0, false, {\n                                                    fileName: \"/Users/igormocalov/Desktop/Font/components/GlyphsMode.jsx\",\n                                                    lineNumber: 392,\n                                                    columnNumber: 24\n                                                }, void 0),\n                                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"button\", {\n                                                    onClick: (e)=>{\n                                                        e.stopPropagation();\n                                                        copyToClipboard(glyphName, \"Имя\");\n                                                    },\n                                                    className: \"text-[8px] px-1 py-0.5 bg-gray-100 hover:bg-gray-200 text-gray-700 rounded\",\n                                                    title: \"Копировать имя\",\n                                                    children: \"Name\"\n                                                }, void 0, false, {\n                                                    fileName: \"/Users/igormocalov/Desktop/Font/components/GlyphsMode.jsx\",\n                                                    lineNumber: 400,\n                                                    columnNumber: 21\n                                                }, void 0),\n                                                glyphUnicodeStr && /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"button\", {\n                                                    onClick: (e)=>{\n                                                        e.stopPropagation();\n                                                        copyToClipboard(glyphUnicodeStr, \"Unicode\");\n                                                    },\n                                                    className: \"text-[8px] px-1 py-0.5 bg-gray-100 hover:bg-gray-200 text-gray-700 rounded\",\n                                                    title: \"Копировать Unicode\",\n                                                    children: \"Unicode\"\n                                                }, void 0, false, {\n                                                    fileName: \"/Users/igormocalov/Desktop/Font/components/GlyphsMode.jsx\",\n                                                    lineNumber: 408,\n                                                    columnNumber: 24\n                                                }, void 0)\n                                            ]\n                                        }, void 0, true, {\n                                            fileName: \"/Users/igormocalov/Desktop/Font/components/GlyphsMode.jsx\",\n                                            lineNumber: 390,\n                                            columnNumber: 19\n                                        }, void 0)\n                                    ]\n                                }, void 0, true, {\n                                    fileName: \"/Users/igormocalov/Desktop/Font/components/GlyphsMode.jsx\",\n                                    lineNumber: 383,\n                                    columnNumber: 17\n                                }, void 0)\n                            ]\n                        }, glyph.id, true, {\n                            fileName: \"/Users/igormocalov/Desktop/Font/components/GlyphsMode.jsx\",\n                            lineNumber: 351,\n                            columnNumber: 15\n                        }, void 0);\n                    }\n                }, void 0, false, {\n                    fileName: \"/Users/igormocalov/Desktop/Font/components/GlyphsMode.jsx\",\n                    lineNumber: 295,\n                    columnNumber: 9\n                }, this),\n                selectedGlyph && /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                    className: \"fixed inset-0 bg-black bg-opacity-60 flex items-center justify-center z-50 p-4\",\n                    onClick: ()=>setSelectedGlyph(null),\n                    children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                        className: \"bg-white p-6 sm:p-8 rounded-lg shadow-xl max-w-md w-full relative\",\n                        onClick: (e)=>e.stopPropagation(),\n                        children: [\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"button\", {\n                                onClick: ()=>setSelectedGlyph(null),\n                                className: \"absolute top-2 right-3 text-gray-400 hover:text-gray-700 text-3xl font-light leading-none\",\n                                \"aria-label\": \"Закрыть\",\n                                children: \"\\xd7\"\n                            }, void 0, false, {\n                                fileName: \"/Users/igormocalov/Desktop/Font/components/GlyphsMode.jsx\",\n                                lineNumber: 434,\n                                columnNumber: 15\n                            }, this),\n                            (()=>{\n                                var _glyphsData_advanceWidths;\n                                const name = getGlyphName(selectedGlyph);\n                                const unicodeStr = getGlyphUnicode(selectedGlyph);\n                                const advanceWidth = glyphsData === null || glyphsData === void 0 ? void 0 : (_glyphsData_advanceWidths = glyphsData.advanceWidths) === null || _glyphsData_advanceWidths === void 0 ? void 0 : _glyphsData_advanceWidths[selectedGlyph.id];\n                                // --- Обновленная логика получения символа для модального окна ---\n                                let char = null;\n                                let isPrintable = false;\n                                // 1. Пробуем основной unicode\n                                if (selectedGlyph.unicode) {\n                                    try {\n                                        const potentialChar = String.fromCodePoint(selectedGlyph.unicode);\n                                        if (potentialChar && potentialChar.trim() !== \"\" && !RegExp(\"[\\\\p{C}]\", \"u\").test(potentialChar)) {\n                                            char = potentialChar;\n                                            isPrintable = true;\n                                        }\n                                    } catch (e) {}\n                                }\n                                // 2. Если не получилось, пробуем массив unicodes\n                                if (!isPrintable && selectedGlyph.unicodes && selectedGlyph.unicodes.length > 0) {\n                                    for (const codePoint of selectedGlyph.unicodes){\n                                        try {\n                                            const potentialChar = String.fromCodePoint(codePoint);\n                                            if (potentialChar && potentialChar.trim() !== \"\" && !RegExp(\"[\\\\p{C}]\", \"u\").test(potentialChar)) {\n                                                char = potentialChar;\n                                                isPrintable = true;\n                                                break;\n                                            }\n                                        } catch (e) {}\n                                    }\n                                }\n                                // --- Конец обновленной логики ---\n                                return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.Fragment, {\n                                    children: [\n                                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"h3\", {\n                                            className: \"text-xl font-semibold mb-4 text-gray-800 truncate\",\n                                            title: name,\n                                            children: [\n                                                \"Детали глифа: \",\n                                                name\n                                            ]\n                                        }, void 0, true, {\n                                            fileName: \"/Users/igormocalov/Desktop/Font/components/GlyphsMode.jsx\",\n                                            lineNumber: 479,\n                                            columnNumber: 27\n                                        }, this),\n                                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                            className: \"text-center mb-6 p-4 bg-gray-50 rounded\",\n                                            style: largeGlyphStyle,\n                                            children: isPrintable ? char : /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"span\", {\n                                                className: \"text-gray-400 text-xl\",\n                                                children: \"(no char)\"\n                                            }, void 0, false, {\n                                                fileName: \"/Users/igormocalov/Desktop/Font/components/GlyphsMode.jsx\",\n                                                lineNumber: 483,\n                                                columnNumber: 53\n                                            }, this)\n                                        }, void 0, false, {\n                                            fileName: \"/Users/igormocalov/Desktop/Font/components/GlyphsMode.jsx\",\n                                            lineNumber: 482,\n                                            columnNumber: 27\n                                        }, this),\n                                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                            className: \"space-y-2 text-sm text-gray-700\",\n                                            children: [\n                                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"p\", {\n                                                    children: [\n                                                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"strong\", {\n                                                            children: \"Имя:\"\n                                                        }, void 0, false, {\n                                                            fileName: \"/Users/igormocalov/Desktop/Font/components/GlyphsMode.jsx\",\n                                                            lineNumber: 486,\n                                                            columnNumber: 34\n                                                        }, this),\n                                                        \" \",\n                                                        name\n                                                    ]\n                                                }, void 0, true, {\n                                                    fileName: \"/Users/igormocalov/Desktop/Font/components/GlyphsMode.jsx\",\n                                                    lineNumber: 486,\n                                                    columnNumber: 31\n                                                }, this),\n                                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"p\", {\n                                                    children: [\n                                                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"strong\", {\n                                                            children: \"Unicode:\"\n                                                        }, void 0, false, {\n                                                            fileName: \"/Users/igormocalov/Desktop/Font/components/GlyphsMode.jsx\",\n                                                            lineNumber: 487,\n                                                            columnNumber: 34\n                                                        }, this),\n                                                        \" \",\n                                                        unicodeStr || \"N/A\"\n                                                    ]\n                                                }, void 0, true, {\n                                                    fileName: \"/Users/igormocalov/Desktop/Font/components/GlyphsMode.jsx\",\n                                                    lineNumber: 487,\n                                                    columnNumber: 31\n                                                }, this),\n                                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"p\", {\n                                                    children: [\n                                                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"strong\", {\n                                                            children: \"ID (индекс):\"\n                                                        }, void 0, false, {\n                                                            fileName: \"/Users/igormocalov/Desktop/Font/components/GlyphsMode.jsx\",\n                                                            lineNumber: 488,\n                                                            columnNumber: 34\n                                                        }, this),\n                                                        \" \",\n                                                        selectedGlyph.id\n                                                    ]\n                                                }, void 0, true, {\n                                                    fileName: \"/Users/igormocalov/Desktop/Font/components/GlyphsMode.jsx\",\n                                                    lineNumber: 488,\n                                                    columnNumber: 31\n                                                }, this),\n                                                advanceWidth !== undefined && /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"p\", {\n                                                    children: [\n                                                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"strong\", {\n                                                            children: \"Ширина (advanceWidth):\"\n                                                        }, void 0, false, {\n                                                            fileName: \"/Users/igormocalov/Desktop/Font/components/GlyphsMode.jsx\",\n                                                            lineNumber: 490,\n                                                            columnNumber: 38\n                                                        }, this),\n                                                        \" \",\n                                                        advanceWidth\n                                                    ]\n                                                }, void 0, true, {\n                                                    fileName: \"/Users/igormocalov/Desktop/Font/components/GlyphsMode.jsx\",\n                                                    lineNumber: 490,\n                                                    columnNumber: 35\n                                                }, this),\n                                                selectedGlyph.unicodes && selectedGlyph.unicodes.length > 1 && /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"p\", {\n                                                    children: [\n                                                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"strong\", {\n                                                            children: \"Другие Unicode:\"\n                                                        }, void 0, false, {\n                                                            fileName: \"/Users/igormocalov/Desktop/Font/components/GlyphsMode.jsx\",\n                                                            lineNumber: 493,\n                                                            columnNumber: 38\n                                                        }, this),\n                                                        \" \",\n                                                        selectedGlyph.unicodes.filter((u)=>u !== selectedGlyph.unicode).map((u)=>\"U+\".concat(u.toString(16).toUpperCase().padStart(4, \"0\"))).join(\", \")\n                                                    ]\n                                                }, void 0, true, {\n                                                    fileName: \"/Users/igormocalov/Desktop/Font/components/GlyphsMode.jsx\",\n                                                    lineNumber: 493,\n                                                    columnNumber: 35\n                                                }, this)\n                                            ]\n                                        }, void 0, true, {\n                                            fileName: \"/Users/igormocalov/Desktop/Font/components/GlyphsMode.jsx\",\n                                            lineNumber: 485,\n                                            columnNumber: 27\n                                        }, this),\n                                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                            className: \"mt-6 flex flex-wrap justify-end gap-2\",\n                                            children: [\n                                                isPrintable && /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"button\", {\n                                                    onClick: ()=>copyToClipboard(char, \"Символ\"),\n                                                    className: \"px-3 py-1.5 bg-blue-500 text-white rounded hover:bg-blue-600 text-sm shadow-sm\",\n                                                    children: \"Копировать символ\"\n                                                }, void 0, false, {\n                                                    fileName: \"/Users/igormocalov/Desktop/Font/components/GlyphsMode.jsx\",\n                                                    lineNumber: 498,\n                                                    columnNumber: 35\n                                                }, this),\n                                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"button\", {\n                                                    onClick: ()=>copyToClipboard(name, \"Имя\"),\n                                                    className: \"px-3 py-1.5 bg-gray-200 text-gray-800 rounded hover:bg-gray-300 text-sm shadow-sm\",\n                                                    children: \"Копировать имя\"\n                                                }, void 0, false, {\n                                                    fileName: \"/Users/igormocalov/Desktop/Font/components/GlyphsMode.jsx\",\n                                                    lineNumber: 500,\n                                                    columnNumber: 31\n                                                }, this),\n                                                unicodeStr && /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"button\", {\n                                                    onClick: ()=>copyToClipboard(unicodeStr, \"Unicode\"),\n                                                    className: \"px-3 py-1.5 bg-gray-200 text-gray-800 rounded hover:bg-gray-300 text-sm shadow-sm\",\n                                                    children: \"Копировать Unicode\"\n                                                }, void 0, false, {\n                                                    fileName: \"/Users/igormocalov/Desktop/Font/components/GlyphsMode.jsx\",\n                                                    lineNumber: 502,\n                                                    columnNumber: 35\n                                                }, this)\n                                            ]\n                                        }, void 0, true, {\n                                            fileName: \"/Users/igormocalov/Desktop/Font/components/GlyphsMode.jsx\",\n                                            lineNumber: 496,\n                                            columnNumber: 27\n                                        }, this)\n                                    ]\n                                }, void 0, true);\n                            })()\n                        ]\n                    }, void 0, true, {\n                        fileName: \"/Users/igormocalov/Desktop/Font/components/GlyphsMode.jsx\",\n                        lineNumber: 430,\n                        columnNumber: 13\n                    }, this)\n                }, void 0, false, {\n                    fileName: \"/Users/igormocalov/Desktop/Font/components/GlyphsMode.jsx\",\n                    lineNumber: 426,\n                    columnNumber: 11\n                }, this)\n            ]\n        }, void 0, true, {\n            fileName: \"/Users/igormocalov/Desktop/Font/components/GlyphsMode.jsx\",\n            lineNumber: 281,\n            columnNumber: 7\n        }, this);\n    } catch (error) {\n        console.error(\"[GlyphsMode] Render error caught:\", error);\n        // Возвращаем простой fallback UI при ошибке рендера\n        return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n            className: \"p-8 text-center text-red-600 bg-red-50 border border-red-200 rounded\",\n            children: [\n                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"p\", {\n                    className: \"font-bold mb-2\",\n                    children: \"Ошибка рендеринга в компоненте GlyphsMode.\"\n                }, void 0, false, {\n                    fileName: \"/Users/igormocalov/Desktop/Font/components/GlyphsMode.jsx\",\n                    lineNumber: 518,\n                    columnNumber: 13\n                }, this),\n                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"p\", {\n                    className: \"text-sm\",\n                    children: \"Пожалуйста, проверьте консоль для деталей.\"\n                }, void 0, false, {\n                    fileName: \"/Users/igormocalov/Desktop/Font/components/GlyphsMode.jsx\",\n                    lineNumber: 519,\n                    columnNumber: 13\n                }, this)\n            ]\n        }, void 0, true, {\n            fileName: \"/Users/igormocalov/Desktop/Font/components/GlyphsMode.jsx\",\n            lineNumber: 517,\n            columnNumber: 9\n        }, this);\n    }\n}\n_s(GlyphsMode, \"74909OSDt7rW/fbY4uOJy5mZ/6c=\", false, function() {\n    return [\n        _contexts_SettingsContext__WEBPACK_IMPORTED_MODULE_5__.useSettings,\n        _contexts_FontContext__WEBPACK_IMPORTED_MODULE_6__.useFontContext,\n        _contexts_SettingsContext__WEBPACK_IMPORTED_MODULE_5__.useSettings\n    ];\n});\n_c = GlyphsMode;\n/* harmony default export */ __webpack_exports__[\"default\"] = (GlyphsMode);\nvar _c;\n$RefreshReg$(_c, \"GlyphsMode\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QyxNQUFNO29EQUFXZCxXQUFVOzhEQUFpRjs7Ozs7OzhEQUV2Siw4REFBQ2lDO29EQUFPUixTQUFTLElBQU1qRCxnQkFBZ0J0RCxNQUFNO29EQUFROEUsV0FBVTs4REFBb0Y7Ozs7OztnREFDbEpvQyw0QkFDRyw4REFBQ0g7b0RBQU9SLFNBQVMsSUFBTWpELGdCQUFnQjRELFlBQVk7b0RBQVlwQyxXQUFVOzhEQUFvRjs7Ozs7Ozs7Ozs7Ozs7NEJBS2pMOzs7Ozs7Ozs7Ozs7Ozs7Ozs7SUFNWixFQUFFLE9BQU9qRCxPQUFPO1FBQ2QvQixRQUFRK0IsS0FBSyxDQUFDLHFDQUFxQ0E7UUFDbkQsb0RBQW9EO1FBQ3BELHFCQUNJLDhEQUFDZ0Q7WUFBSUMsV0FBVTs7OEJBQ1gsOERBQUNFO29CQUFFRixXQUFVOzhCQUFpQjs7Ozs7OzhCQUM5Qiw4REFBQ0U7b0JBQUVGLFdBQVU7OEJBQVU7Ozs7Ozs7Ozs7OztJQUdqQztBQUNGO0dBdGZTMUY7O1FBTWNKLGtFQUFXQTtRQUNnQkMsaUVBQWNBO1FBQzFCRCxrRUFBV0E7OztLQVJ4Q0k7QUF3ZlQsK0RBQWVBLFVBQVVBLEVBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vY29tcG9uZW50cy9HbHlwaHNNb2RlLmpzeD9lMGFmIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBSZWFjdCwgeyB1c2VTdGF0ZSwgdXNlQ2FsbGJhY2ssIHVzZU1lbW8sIHVzZUVmZmVjdCwgdXNlUmVmIH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IHsgdG9hc3QgfSBmcm9tICdyZWFjdC10b2FzdGlmeSc7XG5pbXBvcnQgeyBWaXJ0dW9zb0dyaWQgfSBmcm9tICdyZWFjdC12aXJ0dW9zbyc7XG5pbXBvcnQgZGVib3VuY2UgZnJvbSAnbG9kYXNoLmRlYm91bmNlJztcbmltcG9ydCB7IGdldEdseXBoRGF0YUZvckZvbnQgfSBmcm9tICcuLi91dGlscy9mb250UGFyc2VyJztcbmltcG9ydCB7IHVzZVNldHRpbmdzIH0gZnJvbSAnLi4vY29udGV4dHMvU2V0dGluZ3NDb250ZXh0JztcbmltcG9ydCB7IHVzZUZvbnRDb250ZXh0IH0gZnJvbSAnLi4vY29udGV4dHMvRm9udENvbnRleHQnO1xuXG4vLyDQmNC90LjRhtC40LDQu9C40LfQuNGA0YPQtdC8INCz0LvQvtCx0LDQu9GM0L3Ri9C5INC60Y3RiCDQtNC70Y8g0LPQu9C40YTQvtCyLCDRh9GC0L7QsdGLINC90LUg0LfQsNCz0YDRg9C20LDRgtGMINC40YUg0L/QvtCy0YLQvtGA0L3QvlxuY29uc3QgZ2x5cGhEYXRhQ2FjaGUgPSBuZXcgTWFwKCk7XG5cbi8qKlxuICog0JrQvtC80L/QvtC90LXQvdGCINC00LvRjyDRgNC10LbQuNC80LAg0L7RgtC+0LHRgNCw0LbQtdC90LjRjyDQs9C70LjRhNC+0LIg0YjRgNC40YTRgtCwXG4gKiBcbiAqIEBwYXJhbSB7T2JqZWN0fSBwcm9wcyAtINCh0LLQvtC50YHRgtCy0LAg0LrQvtC80L/QvtC90LXQvdGC0LBcbiAqIEBwYXJhbSB7T2JqZWN0fSBwcm9wcy5zZWxlY3RlZEZvbnQgLSDQktGL0LHRgNCw0L3QvdGL0Lkg0YjRgNC40YTRglxuICogQHBhcmFtIHtzdHJpbmd9IHByb3BzLmZvbnRGYW1pbHkgLSDQodC10LzQtdC50YHRgtCy0L4g0YjRgNC40YTRgtC+0LJcbiAqIEBwYXJhbSB7T2JqZWN0fSBwcm9wcy5nbHlwaERpc3BsYXlTdHlsZSAtINCh0YLQuNC70Lgg0LTQu9GPINC+0YLQvtCx0YDQsNC20LXQvdC40Y8g0LPQu9C40YTQvtCyXG4gKiBAcGFyYW0ge2Jvb2xlYW59IHByb3BzLmlzQWN0aXZlIC0g0JDQutGC0LjQstC10L0g0LvQuCDRgNC10LbQuNC8INCz0LvQuNGE0L7QslxuICovXG5mdW5jdGlvbiBHbHlwaHNNb2RlKHtcbiAgc2VsZWN0ZWRGb250LFxuICBmb250RmFtaWx5LFxuICBnbHlwaERpc3BsYXlTdHlsZSxcbiAgaXNBY3RpdmUgPSB0cnVlLCAvLyDQn9C+INGD0LzQvtC70YfQsNC90LjRjiDQsNC60YLQuNCy0LXQvVxufSkge1xuICBjb25zdCB7IGZvbnRTaXplIH0gPSB1c2VTZXR0aW5ncygpO1xuICBjb25zdCB7IGdldEZvbnRGYW1pbHksIGdldFZhcmlhdGlvblNldHRpbmdzIH0gPSB1c2VGb250Q29udGV4dCgpO1xuICBjb25zdCB7IHNldHRpbmdzLCBnbHlwaFNldHRpbmdzIH0gPSB1c2VTZXR0aW5ncygpO1xuXG4gIC8vINCe0KLQm9CQ0JTQmtCQOiDQlNC10YLQsNC70YzQvdGL0LUg0LvQvtCz0Lgg0LTQu9GPINCz0LvQuNGE0L7QslxuICBjb25zb2xlLmxvZygnW0dseXBoc01vZGVdINCU0JXQotCQ0JvQrNCd0JDQryDQntCi0JvQkNCU0JrQkDonLCB7XG4gICAgc2VsZWN0ZWRGb250OiBzZWxlY3RlZEZvbnQ/Lm5hbWUsXG4gICAgaXNWYXJpYWJsZUZvbnQ6IHNlbGVjdGVkRm9udD8uaXNWYXJpYWJsZUZvbnQsXG4gICAgZm9udEZhbWlseSxcbiAgICBnbHlwaERpc3BsYXlTdHlsZSxcbiAgICBmb250U2l6ZSxcbiAgICBzZWxlY3RlZEZvbnRfaWQ6IHNlbGVjdGVkRm9udD8uaWQsXG4gICAgc2VsZWN0ZWRGb250X2ZvbnRGYW1pbHk6IHNlbGVjdGVkRm9udD8uZm9udEZhbWlseVxuICB9KTtcblxuICAvLyBjb25zb2xlLmxvZyhcIkdseXBoc01vZGUgLSBTZWxlY3RlZCBGb250OlwiLCBzZWxlY3RlZEZvbnQpOyAvLyDQo9C00LDQu9GP0LXQvCDQt9Cw0LrQvtC80LzQtdC90YLQuNGA0L7QstCw0L3QvdGL0Lkg0LvQvtCzXG4gIC8vIGNvbnNvbGUubG9nKFwiR2x5cGhzTW9kZSAtIFNldHRpbmdzOlwiLCBzZXR0aW5ncyk7IC8vINCj0LTQsNC70Y/QtdC8INC30LDQutC+0LzQvNC10L3RgtC40YDQvtCy0LDQvdC90YvQuSDQu9C+0LNcbiAgLy8gY29uc29sZS5sb2coXCJHbHlwaHNNb2RlIC0gR2x5cGggU2V0dGluZ3M6XCIsIGdseXBoU2V0dGluZ3MpOyAvLyDQo9C00LDQu9GP0LXQvCDQt9Cw0LrQvtC80LzQtdC90YLQuNGA0L7QstCw0L3QvdGL0Lkg0LvQvtCzXG5cbiAgdHJ5IHtcbiAgICAvLyDQodC+0YHRgtC+0Y/QvdC40LUg0LggcmVmINC00LvRjyDQt9Cw0LPRgNGD0LfQutC4INCz0LvQuNGE0L7QslxuICAgIGNvbnN0IFtnbHlwaHNMb2FkZWQsIHNldEdseXBoc0xvYWRlZF0gPSB1c2VTdGF0ZShmYWxzZSk7XG4gICAgY29uc3QgW2dseXBoc0RhdGEsIHNldEdseXBoc0RhdGFdID0gdXNlU3RhdGUobnVsbCk7XG4gICAgY29uc3QgW2dseXBoRXJyb3JzLCBzZXRHbHlwaEVycm9yc10gPSB1c2VTdGF0ZShbXSk7IC8vIDw8PCDQndC+0LLQvtC1INGB0L7RgdGC0L7Rj9C90LjQtSDQtNC70Y8g0L7RiNC40LHQvtC6XG4gICAgY29uc3QgaXNMb2FkaW5nR2x5cGhzID0gdXNlUmVmKGZhbHNlKTtcbiAgICAvLyBSZWYg0LTQu9GPINC+0YLRgdC70LXQttC40LLQsNC90LjRjyDRgtC10LrRg9GJ0LXQs9C+INC30LDQv9GA0L7RgdCwLCDRh9GC0L7QsdGLINC/0YDQtdC00L7RgtCy0YDQsNGC0LjRgtGMIHJhY2UgY29uZGl0aW9uXG4gICAgY29uc3QgY3VycmVudExvYWRJZCA9IHVzZVJlZihudWxsKTtcblxuICAgIC8vINCe0LHQvtGA0LDRh9C40LLQsNC10LwgbG9hZEdseXBocyDQsiB1c2VDYWxsYmFjaywg0YfRgtC+0LHRiyDRgdGB0YvQu9C60LAg0L3QsCDRhNGD0L3QutGG0LjRjiDQsdGL0LvQsCDRgdGC0LDQsdC40LvRjNC90L7QuVxuICAgIGNvbnN0IGxvYWRHbHlwaHNDYWxsYmFjayA9IHVzZUNhbGxiYWNrKGFzeW5jIChjdXJyZW50QXR0ZW1wdExvYWRJZCwgZm9udFRvTG9hZCwgYXR0ZW1wdEZvbnRJZCkgPT4ge1xuICAgICAgLy8g0J/RgNC+0LLQtdGA0Y/QtdC8LCDQvdC1INC+0YLQvNC10L3QtdC9INC70Lgg0Y3RgtC+0YIg0LfQsNC/0YDQvtGBICjRgi7QtS4g0L3QsNGH0LDQu9GB0Y8g0LvQuCDQvdC+0LLRi9C5KVxuICAgICAgaWYgKGN1cnJlbnRBdHRlbXB0TG9hZElkICE9PSBjdXJyZW50TG9hZElkLmN1cnJlbnQpIHtcbiAgICAgICAgICByZXR1cm47IFxuICAgICAgfVxuICAgICAgXG4gICAgICB0cnkge1xuICAgICAgICAvLyDQodCx0YDQsNGB0YvQstCw0LXQvCDRgdC+0YHRgtC+0Y/QvdC40LUg0YLQvtC70YzQutC+INC10YHQu9C4INGN0YLQvtGCINC30LDQv9GA0L7RgSDQstGB0LUg0LXRidC1INCw0LrRgtGD0LDQu9C10L1cbiAgICAgICAgaWYgKGN1cnJlbnRBdHRlbXB0TG9hZElkID09PSBjdXJyZW50TG9hZElkLmN1cnJlbnQpIHtcbiAgICAgICAgICAgc2V0R2x5cGhzTG9hZGVkKGZhbHNlKTtcbiAgICAgICAgICAgc2V0R2x5cGhzRGF0YShudWxsKTtcbiAgICAgICAgICAgc2V0R2x5cGhFcnJvcnMoW10pOyAvLyA8PDwg0KHQsdGA0LDRgdGL0LLQsNC10Lwg0L7RiNC40LHQutC4XG4gICAgICAgIH1cblxuICAgICAgICAvLyDQn9GA0L7QstC10YDRj9C10Lwg0LrRjdGIXG4gICAgICAgIGlmIChnbHlwaERhdGFDYWNoZS5oYXMoYXR0ZW1wdEZvbnRJZCkpIHtcbiAgICAgICAgICBjb25zdCBjYWNoZWREYXRhID0gZ2x5cGhEYXRhQ2FjaGUuZ2V0KGF0dGVtcHRGb250SWQpO1xuICAgICAgICAgIGlmIChjdXJyZW50QXR0ZW1wdExvYWRJZCA9PT0gY3VycmVudExvYWRJZC5jdXJyZW50KSB7XG4gICAgICAgICAgICAgIHNldEdseXBoc0RhdGEoY2FjaGVkRGF0YSk7XG4gICAgICAgICAgICAgIHNldEdseXBoc0xvYWRlZCh0cnVlKTtcbiAgICAgICAgICAgICAgc2V0R2x5cGhFcnJvcnMoY2FjaGVkRGF0YS5lcnJvcnMgfHwgW10pOyAvLyA8PDwg0JfQsNCz0YDRg9C20LDQtdC8INC+0YjQuNCx0LrQuCDQuNC3INC60Y3RiNCwXG4gICAgICAgICAgICAgIGlzTG9hZGluZ0dseXBocy5jdXJyZW50ID0gZmFsc2U7IFxuICAgICAgICAgICAgICBpZiAoIWNhY2hlZERhdGE/LmFsbEdseXBocykge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybihcIkNhY2hlZCBnbHlwaCBkYXRhIGlzIG1pc3NpbmcgJ2FsbEdseXBocycuXCIpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGRhdGEgPSBhd2FpdCBnZXRHbHlwaERhdGFGb3JGb250KGZvbnRUb0xvYWQpOyAvLyDQmNGB0L/QvtC70YzQt9GD0LXQvCDQv9C10YDQtdC00LDQvdC90YvQuSBmb250VG9Mb2FkXG5cbiAgICAgICAgLy8g0KHQndCe0JLQkCDQv9GA0L7QstC10YDRj9C10LwsINCw0LrRgtGD0LDQu9C10L0g0LvQuCDQt9Cw0L/RgNC+0YEg0J/QldCg0JXQlCDRg9GB0YLQsNC90L7QstC60L7QuSDRgdC+0YHRgtC+0Y/QvdC40Y9cbiAgICAgICAgaWYgKGN1cnJlbnRBdHRlbXB0TG9hZElkICE9PSBjdXJyZW50TG9hZElkLmN1cnJlbnQpIHtcbiAgICAgICAgICAgIHJldHVybjsgXG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIWRhdGEgfHwgIUFycmF5LmlzQXJyYXkoZGF0YS5hbGxHbHlwaHMpKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwi0J/QvtC70YPRh9C10L3RiyDQvdC10LrQvtGA0YDQtdC60YLQvdGL0LUg0LTQsNC90L3Ri9C1INCz0LvQuNGE0L7QsiAo0L7RgtGB0YPRgtGB0YLQstGD0LXRgiBhbGxHbHlwaHMpLlwiKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGdseXBoRGF0YUNhY2hlLnNldChhdHRlbXB0Rm9udElkLCBkYXRhKTsgLy8g0JjRgdC/0L7Qu9GM0LfRg9C10LwgYXR0ZW1wdEZvbnRJZCDQtNC70Y8g0LrRjdGI0LBcbiAgICAgICAgc2V0R2x5cGhzRGF0YShkYXRhKTtcbiAgICAgICAgc2V0R2x5cGhzTG9hZGVkKHRydWUpO1xuICAgICAgICBzZXRHbHlwaEVycm9ycyhkYXRhLmVycm9ycyB8fCBbXSk7IC8vIDw8PCDQodC+0YXRgNCw0L3Rj9C10Lwg0L7RiNC40LHQutC4XG4gICAgICAgIGlzTG9hZGluZ0dseXBocy5jdXJyZW50ID0gZmFsc2U7IFxuXG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICBjb25zb2xlLmVycm9yKCdbR2x5cGhzTW9kZSBEZWJvdW5jZWRdINCe0YjQuNCx0LrQsCDQv9GA0Lgg0LfQsNCz0YDRg9C30LrQtSDQs9C70LjRhNC+0LI6JywgZXJyb3IpO1xuICAgICAgICB0b2FzdC5lcnJvcihg0J3QtSDRg9C00LDQu9C+0YHRjCDQt9Cw0LPRgNGD0LfQuNGC0Ywg0LTQsNC90L3Ri9C1INCz0LvQuNGE0L7QsjogJHtlcnJvci5tZXNzYWdlfWApO1xuICAgICAgICBpZiAoY3VycmVudEF0dGVtcHRMb2FkSWQgPT09IGN1cnJlbnRMb2FkSWQuY3VycmVudCkge1xuICAgICAgICAgICAgc2V0R2x5cGhzRGF0YShudWxsKTtcbiAgICAgICAgICAgIHNldEdseXBoc0xvYWRlZChmYWxzZSk7XG4gICAgICAgICAgICBzZXRHbHlwaEVycm9ycyhbXSk7IC8vIDw8PCDQodCx0YDQsNGB0YvQstCw0LXQvCDQvtGI0LjQsdC60Lgg0L/RgNC4INC+0YjQuNCx0LrQtVxuICAgICAgICAgICAgaXNMb2FkaW5nR2x5cGhzLmN1cnJlbnQgPSBmYWxzZTsgXG4gICAgICAgIH1cbiAgICAgIH0gXG4gICAgfSwgW10pOyAvLyDQn9GD0YHRgtC+0Lkg0LzQsNGB0YHQuNCyINC30LDQstC40YHQuNC80L7RgdGC0LXQuSDQtNC70Y8gdXNlQ2FsbGJhY2tcblxuICAgIC8vINCh0L7Qt9C00LDQtdC8INC80LXQvNC+0LjQt9C40YDQvtCy0LDQvdC90YPRjiBkZWJvdW5jZWQt0LLQtdGA0YHQuNGOXG4gICAgY29uc3QgZGVib3VuY2VkTG9hZEdseXBocyA9IHVzZU1lbW8oKCkgPT4ge1xuICAgICAgICByZXR1cm4gZGVib3VuY2UobG9hZEdseXBoc0NhbGxiYWNrLCAyMDApOyAvLyDQl9Cw0LTQtdGA0LbQutCwIDIwMG1zXG4gICAgfSwgW2xvYWRHbHlwaHNDYWxsYmFja10pO1xuXG4gICAgLy8g0JXQtNC40L3Ri9C5IHVzZUVmZmVjdCDQtNC70Y8g0LfQsNCz0YDRg9C30LrQuCDQuCDRgdCx0YDQvtGB0LAg0YHQvtGB0YLQvtGP0L3QuNGPINCz0LvQuNGE0L7QslxuICAgIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICBpZiAoIWlzQWN0aXZlKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgY29uc3QgZm9udElkID0gc2VsZWN0ZWRGb250Py5pZDtcbiAgICAgIGNvbnN0IGZvbnRTb3VyY2UgPSBzZWxlY3RlZEZvbnQ/LnNvdXJjZTtcbiAgICAgIGNvbnN0IGxvYWRJZCA9IE1hdGgucmFuZG9tKCkudG9TdHJpbmcoMzYpLnN1YnN0cmluZygyLCAxMCk7XG4gICAgICBjdXJyZW50TG9hZElkLmN1cnJlbnQgPSBsb2FkSWQ7IFxuXG4gICAgICBjb25zdCByZXNldFN0YXRlID0gKGxvZ01lc3NhZ2UgPSBcIlJlc2V0dGluZyBnbHlwaCBzdGF0ZVwiKSA9PiB7XG4gICAgICAgIC8vIGNvbnNvbGUubG9nKGBbR2x5cGhzTW9kZSB1c2VFZmZlY3RdICR7bG9nTWVzc2FnZX0gLSBMb2FkIElEOiAke2xvYWRJZH1gKTsgLy8g0KPQtNCw0LvRj9C10Lwg0LvQvtCzXG4gICAgICAgIHNldEdseXBoc0xvYWRlZChmYWxzZSk7XG4gICAgICAgIHNldEdseXBoc0RhdGEobnVsbCk7XG4gICAgICAgIHNldEdseXBoRXJyb3JzKFtdKTsgLy8gPDw8INCh0LHRgNC+0YEg0L7RiNC40LHQvtC6XG4gICAgICAgIGlzTG9hZGluZ0dseXBocy5jdXJyZW50ID0gZmFsc2U7IC8vINCh0LHRgNCw0YHRi9Cy0LDQtdC8INGE0LvQsNCzINC30LDQs9GA0YPQt9C60LhcbiAgICAgIH07XG5cbiAgICAgIC8vIC0tLSDQn9GA0L7QstC10YDQutC4INC/0LXRgNC10LQg0LfQsNCz0YDRg9C30LrQvtC5IC0tLSBcbiAgICAgIGlmICghc2VsZWN0ZWRGb250KSB7XG4gICAgICAgIHJlc2V0U3RhdGUoXCJObyBmb250IHNlbGVjdGVkLCByZXNldHRpbmcgc3RhdGUuXCIpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBcbiAgICAgIC8vICEhISDQlNCe0JHQkNCS0JvQldCd0JAg0J/QoNCe0JLQldCg0JrQkCDQvdCwIHNlbGVjdGVkRm9udC5maWxlICEhIVxuICAgICAgaWYgKCFzZWxlY3RlZEZvbnQuZmlsZSB8fCAhKHNlbGVjdGVkRm9udC5maWxlIGluc3RhbmNlb2YgQmxvYikpIHtcbiAgICAgICAgcmVzZXRTdGF0ZShgSW52YWxpZCBmb250IGZpbGUgZm9yICR7c2VsZWN0ZWRGb250Lm5hbWV9LCByZXNldHRpbmcgc3RhdGUuYCk7XG4gICAgICAgIGNvbnNvbGUud2FybihgW0dseXBoc01vZGVdIEF0dGVtcHRlZCB0byBsb2FkIGdseXBocyBmb3IgJHtzZWxlY3RlZEZvbnQubmFtZX0gd2l0aG91dCBhIHZhbGlkIGZpbGUgb2JqZWN0LmApO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGlmIChmb250U291cmNlID09PSAnZ29vZ2xlJykge1xuICAgICAgICBpZiAoIWdseXBoc0RhdGEgJiYgIWlzTG9hZGluZ0dseXBocy5jdXJyZW50KSB7XG4gICAgICAgICAgdG9hc3QuaW5mbyhcItCf0YDQvtGB0LzQvtGC0YAg0LPQu9C40YTQvtCyINC/0L7QutCwINC90LXQtNC+0YHRgtGD0L/QtdC9INC00LvRjyBHb29nbGUgRm9udHMuXCIpO1xuICAgICAgICB9XG4gICAgICAgIHJlc2V0U3RhdGUoXCJHb29nbGUgRm9udCBzZWxlY3RlZCwgcmVzZXR0aW5nIHN0YXRlLlwiKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICAvLyAtLS0g0JfQsNC/0YPRgdC6INC30LDQs9GA0YPQt9C60Lgg0YfQtdGA0LXQtyBkZWJvdW5jZSAtLS1cbiAgICAgIGNvbnN0IGlzRGF0YUxvYWRlZEluU3RhdGUgPSBnbHlwaHNMb2FkZWQgJiYgZ2x5cGhzRGF0YSAmJiBnbHlwaHNEYXRhLmFsbEdseXBocztcblxuICAgICAgaWYgKCFpc0RhdGFMb2FkZWRJblN0YXRlKSB7XG4gICAgICAgIC8vIGNvbnNvbGUubG9nKGBbR2x5cGhzTW9kZSB1c2VFZmZlY3RdIERhdGEgbm90IGxvYWRlZCwgY2FsbGluZyBkZWJvdW5jZWRMb2FkR2x5cGhzLiBMb2FkIElEOiAke2xvYWRJZH1gKTsgLy8g0KPQtNCw0LvRj9C10Lwg0LvQvtCzXG4gICAgICAgIC8vINCj0YHRgtCw0L3QsNCy0LvQuNCy0LDQtdC8INGE0LvQsNCzINC30LDQs9GA0YPQt9C60Lgg0J/QldCg0JXQlCDQstGL0LfQvtCy0L7QvCBkZWJvdW5jZWQg0YTRg9C90LrRhtC40LhcbiAgICAgICAgaXNMb2FkaW5nR2x5cGhzLmN1cnJlbnQgPSB0cnVlO1xuICAgICAgICAvLyDQktGL0LfRi9Cy0LDQtdC8IGRlYm91bmNlZC3RhNGD0L3QutGG0LjRjiwg0L/QtdGA0LXQtNCw0LLQsNGPINC90LXQvtCx0YXQvtC00LjQvNGL0LUg0L/QsNGA0LDQvNC10YLRgNGLXG4gICAgICAgIGRlYm91bmNlZExvYWRHbHlwaHMobG9hZElkLCBzZWxlY3RlZEZvbnQsIGZvbnRJZCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBjb25zb2xlLmxvZyhgW0dseXBoc01vZGUgdXNlRWZmZWN0XSBEYXRhIGFscmVhZHkgbG9hZGVkIG9yIGxvYWRpbmcuIExvYWQgSUQ6ICR7bG9hZElkfWApOyAvLyDQo9C00LDQu9GP0LXQvCDQu9C+0LNcbiAgICAgICAgLy8g0JXRgdC70Lgg0LTQsNC90L3Ri9C1INGD0LbQtSDQt9Cw0LPRgNGD0LbQtdC90YssINC90L4g0YTQu9Cw0LMg0LfQsNCz0YDRg9C30LrQuCDQstGB0LUg0LXRidC1INGB0YLQvtC40YIgKNC80LDQu9C+0LLQtdGA0L7Rj9GC0L3Qviwg0L3QviDQstC+0LfQvNC+0LbQvdC+KVxuICAgICAgICBpZiAoaXNMb2FkaW5nR2x5cGhzLmN1cnJlbnQpIHtcbiAgICAgICAgICAgICAvLyBjb25zb2xlLmxvZyhgW0dseXBoc01vZGUgdXNlRWZmZWN0XSBSZXNldHRpbmcgaXNMb2FkaW5nR2x5cGhzIGZsYWcuIExvYWQgSUQ6ICR7bG9hZElkfWApOyAvLyDQo9C00LDQu9GP0LXQvCDQu9C+0LNcbiAgICAgICAgICAgICBpc0xvYWRpbmdHbHlwaHMuY3VycmVudCA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vINCk0YPQvdC60YbQuNGPINC+0YfQuNGB0YLQutC4INC00LvRjyB1c2VFZmZlY3RcbiAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgICAgLy8gY29uc29sZS5sb2coYFtHbHlwaHNNb2RlIHVzZUVmZmVjdCBDbGVhbnVwXSBDYW5jZWxsaW5nIGRlYm91bmNlZCBjYWxsIGlmIGFueS4gTG9hZCBJRDogJHtsb2FkSWR9YCk7IC8vINCj0LTQsNC70Y/QtdC8INC70L7Qs1xuICAgICAgICAgIC8vINCe0YLQvNC10L3Rj9C10Lwg0LvRjtCx0YvQtSDQvtGC0LvQvtC20LXQvdC90YvQtSDQstGL0LfQvtCy0YsgZGVib3VuY2VkTG9hZEdseXBoc1xuICAgICAgICAgIGRlYm91bmNlZExvYWRHbHlwaHMuY2FuY2VsKCk7XG4gICAgICAgICAgLy8g0KHQsdGA0LDRgdGL0LLQsNC10LwgY3VycmVudExvYWRJZCwg0YfRgtC+0LHRiyDQsdGD0LTRg9GJ0LjQtSDQutC+0LvQsdGN0LrQuCDQvtGCINGN0YLQvtCz0L4gdXNlRWZmZWN0INC90LUg0LLRi9C/0L7Qu9C90LjQu9C40YHRjFxuICAgICAgICAgIC8vIGN1cnJlbnRMb2FkSWQuY3VycmVudCA9IG51bGw7IC8vINCd0LUg0YHQsdGA0LDRgdGL0LLQsNC10Lwg0LfQtNC10YHRjCwg0YfRgtC+0LHRiyDQvtCx0YDQsNCx0L7RgtCw0YLRjCDQv9C+0YHQu9C10LTQvdC40Lkg0LDQutGC0YPQsNC70YzQvdGL0Lkg0LLRi9C30L7QslxuICAgICAgfTtcblxuICAgIH0sIFtzZWxlY3RlZEZvbnQsIGlzQWN0aXZlLCBkZWJvdW5jZWRMb2FkR2x5cGhzXSk7IC8vINCU0L7QsdCw0LLQu9GP0LXQvCBzZWxlY3RlZEZvbnQg0LggZGVib3VuY2VkTG9hZEdseXBocyDQsiDQt9Cw0LLQuNGB0LjQvNC+0YHRgtC4XG5cbiAgICAvLyDQodGC0LjQu9C4INC00LvRjyDQvtGC0L7QsdGA0LDQttC10L3QuNGPINGD0LLQtdC70LjRh9C10L3QvdC+0LPQviDQs9C70LjRhNCwINCyINC80L7QtNCw0LvRjNC90L7QvCDQvtC60L3QtVxuICAgIGNvbnN0IGxhcmdlR2x5cGhTdHlsZSA9IHVzZU1lbW8oKCkgPT4ge1xuICAgICAgLy8g0JjRgdC/0L7Qu9GM0LfRg9C10LwgZm9udFNpemUg0LjQtyB1c2VTZXR0aW5ncyDQstC80LXRgdGC0L4gc2VsZWN0ZWRGb250U2l6ZVxuICAgICAgY29uc3QgYmFzZVNpemUgPSBmb250U2l6ZSB8fCA0MDsgLy8g0JjRgdC/0L7Qu9GM0LfRg9C10LwgZm9udFNpemUsIGZhbGxiYWNrIDQwXG4gICAgICBjb25zdCBtb2RhbEZvbnRTaXplID0gTWF0aC5tYXgoODAsIE1hdGgubWluKDIwMCwgYmFzZVNpemUgKiAyLjUpKTtcbiAgICAgIFxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgZm9udEZhbWlseTogZm9udEZhbWlseSA/IFxuICAgICAgICAgIChmb250RmFtaWx5LmluY2x1ZGVzKFwiJ1wiKSA/IGZvbnRGYW1pbHkgOiBgJyR7Zm9udEZhbWlseX0nYCkgOiBcbiAgICAgICAgICAnaW5oZXJpdCcsXG4gICAgICAgIGZvbnRTaXplOiBgJHttb2RhbEZvbnRTaXplfXB4YCwgXG4gICAgICAgIGxpbmVIZWlnaHQ6IDEsIFxuICAgICAgICAuLi4oZ2x5cGhEaXNwbGF5U3R5bGUgfHwge30pXG4gICAgICB9O1xuICAgIH0sIFtmb250RmFtaWx5LCBnbHlwaERpc3BsYXlTdHlsZSwgZm9udFNpemVdKTtcblxuICAgIC8vINCk0YPQvdC60YbQuNGPINC60L7Qv9C40YDQvtCy0LDQvdC40Y8g0YHQuNC80LLQvtC70LAg0LIg0LHRg9GE0LXRgCDQvtCx0LzQtdC90LAgKNC+0YHRgtCw0LXRgtGB0Y8pXG4gICAgY29uc3QgY29weVRvQ2xpcGJvYXJkID0gdXNlQ2FsbGJhY2soKHRleHQsIHR5cGUgPSAn0KHQuNC80LLQvtC7JykgPT4ge1xuICAgICAgaWYgKCF0ZXh0KSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgbmF2aWdhdG9yLmNsaXBib2FyZC53cml0ZVRleHQodGV4dClcbiAgICAgICAgLnRoZW4oKCkgPT4ge1xuICAgICAgICAgIHRvYXN0LnN1Y2Nlc3MoYCR7dHlwZX0gXCIke3RleHR9XCIg0YHQutC+0L/QuNGA0L7QstCw0L1gKTtcbiAgICAgICAgfSlcbiAgICAgICAgLmNhdGNoKGVyciA9PiB7XG4gICAgICAgICAgY29uc29sZS5lcnJvcign0J3QtSDRg9C00LDQu9C+0YHRjCDRgdC60L7Qv9C40YDQvtCy0LDRgtGMOiAnLCBlcnIpO1xuICAgICAgICAgIHRvYXN0LmVycm9yKGDQndC1INGD0LTQsNC70L7RgdGMINGB0LrQvtC/0LjRgNC+0LLQsNGC0YwgJHt0eXBlLnRvTG93ZXJDYXNlKCl9YCk7XG4gICAgICAgIH0pO1xuICAgIH0sIFtdKTtcblxuICAgIC8vIC0tLSDQm9C+0LPQuNC60LAg0LTQu9GPINC+0YLQvtCx0YDQsNC20LXQvdC40Y8g0JLQodCV0KUg0LPQu9C40YTQvtCyIC0tLVxuICAgIC8vINCe0LHQvdC+0LLQu9GP0LXQvCB1c2VNZW1vINC00LvRjyDQuNGB0L/QvtC70YzQt9C+0LLQsNC90LjRjyBnbHlwaHNEYXRhLmFsbEdseXBoc1xuICAgIGNvbnN0IGRpc3BsYXlhYmxlR2x5cGhzID0gdXNlTWVtbygoKSA9PiB7XG4gICAgICAvLyDQmNGB0L/QvtC70YzQt9GD0LXQvCBhbGxHbHlwaHMg0JHQldCXINC00L7Qv9C+0LvQvdC40YLQtdC70YzQvdC+0Lkg0YTQuNC70YzRgtGA0LDRhtC40LggLm5vdGRlZlxuICAgICAgcmV0dXJuIGdseXBoc0RhdGE/LmFsbEdseXBocyB8fCBbXTtcbiAgICB9LCBbZ2x5cGhzRGF0YV0pO1xuXG4gICAgLy8g0KXQtdC70L/QtdGA0Ysg0LTQu9GPINC/0L7Qu9GD0YfQtdC90LjRjyDQuNC80LXQvdC4INC4IFVuaWNvZGVcbiAgICAvLyDQntCx0L3QvtCy0LvRj9C10Lwg0LTQu9GPINC40YHQv9C+0LvRjNC30L7QstCw0L3QuNGPIGdseXBoc0RhdGEubmFtZXMg0LggZ2x5cGhzRGF0YS51bmljb2Rlc1xuICAgIGNvbnN0IGdldEdseXBoTmFtZSA9IHVzZUNhbGxiYWNrKChnbHlwaCkgPT4ge1xuICAgICAgLy8g0KHQvdCw0YfQsNC70LAg0L/RgNC+0LHRg9C10Lwg0LjQtyDQutCw0YDRgtGLIG5hbWVzLCDQv9C+0YLQvtC8INC40Lcg0YHQsNC80L7Qs9C+INC+0LHRitC10LrRgtCwIGdseXBoXG4gICAgICByZXR1cm4gZ2x5cGhzRGF0YT8ubmFtZXM/LltnbHlwaD8uaWRdIHx8IGdseXBoPy5uYW1lIHx8IGBHbHlwaCAke2dseXBoPy5pZH1gO1xuICAgIH0sIFtnbHlwaHNEYXRhXSk7XG5cbiAgICBjb25zdCBnZXRHbHlwaFVuaWNvZGUgPSB1c2VDYWxsYmFjaygoZ2x5cGgpID0+IHtcbiAgICAgIC8vINCh0L3QsNGH0LDQu9CwINC/0YDQvtCx0YPQtdC8INC40Lcg0LrQsNGA0YLRiyB1bmljb2Rlcywg0L/QvtGC0L7QvCDQuNC3INGB0LDQvNC+0LPQviDQvtCx0YrQtdC60YLQsCBnbHlwaFxuICAgICAgY29uc3QgdW5pY29kZVZhbHVlID0gZ2x5cGhzRGF0YT8udW5pY29kZXM/LltnbHlwaD8uaWRdO1xuICAgICAgaWYgKHVuaWNvZGVWYWx1ZSkgcmV0dXJuIHVuaWNvZGVWYWx1ZTtcbiAgICAgIC8vINCX0LDQv9Cw0YHQvdC+0Lkg0LLQsNGA0LjQsNC90YIgLSDRhNC+0YDQvNCw0YLQuNGA0YPQtdC8INC40LcgZ2x5cGgudW5pY29kZVxuICAgICAgaWYgKGdseXBoPy51bmljb2RlKSB7XG4gICAgICAgICByZXR1cm4gYFUrJHtnbHlwaC51bmljb2RlLnRvU3RyaW5nKDE2KS50b1VwcGVyQ2FzZSgpLnBhZFN0YXJ0KDQsICcwJyl9YDtcbiAgICAgIH1cbiAgICAgIHJldHVybiAnJzsgLy8g0JLQvtC30LLRgNCw0YnQsNC10Lwg0L/Rg9GB0YLRg9GOINGB0YLRgNC+0LrRgywg0LXRgdC70LggVW5pY29kZSDQvdC10YJcbiAgICB9LCBbZ2x5cGhzRGF0YV0pO1xuXG4gICAgLy8g0KHQvtGB0YLQvtGP0L3QuNC1INC00LvRjyDQvNC+0LTQsNC70YzQvdC+0LPQviDQvtC60L3QsCAo0L7RgdGC0LDQtdGC0YHRjylcbiAgICBjb25zdCBbc2VsZWN0ZWRHbHlwaCwgc2V0U2VsZWN0ZWRHbHlwaF0gPSB1c2VTdGF0ZShudWxsKTtcblxuICAgIC8vINCj0YHQu9C+0LLQuNC1INC+0YLQvtCx0YDQsNC20LXQvdC40Y8g0LfQsNCz0YDRg9C30YfQuNC60LBcbiAgICBpZiAoaXNMb2FkaW5nR2x5cGhzLmN1cnJlbnQpIHtcbiAgICAgICByZXR1cm4gPGRpdiBjbGFzc05hbWU9XCJwLTggdGV4dC1jZW50ZXIgdGV4dC1ibHVlLTYwMFwiPtCX0LDQs9GA0YPQt9C60LAg0LTQsNC90L3Ri9GFINCz0LvQuNGE0L7Qsi4uLjwvZGl2PjtcbiAgICB9XG4gICAgICBcbiAgICAvLyDQodC+0L7QsdGJ0LXQvdC40LUsINC10YHQu9C4INGI0YDQuNGE0YIgLSBHb29nbGUgRm9udCAo0L/RgNC+0LLQtdGA0Y/QtdGC0YHRjyDQv9C+0YHQu9C1IGlzTG9hZGluZylcbiAgICBpZiAoc2VsZWN0ZWRGb250Py5zb3VyY2UgPT09ICdnb29nbGUnKSB7XG4gICAgICAgIHJldHVybiA8ZGl2IGNsYXNzTmFtZT1cInAtOCB0ZXh0LWNlbnRlciB0ZXh0LWdyYXktNTAwXCI+0J/RgNC+0YHQvNC+0YLRgCDQs9C70LjRhNC+0LIg0L3QtdC00L7RgdGC0YPQv9C10L0g0LTQu9GPINGI0YDQuNGE0YLQvtCyIEdvb2dsZS48L2Rpdj47XG4gICAgfVxuXG4gICAgLy8g0KPRgdC70L7QstC40LUg0L7RgtC+0LHRgNCw0LbQtdC90LjRjyDQvtGI0LjQsdC60Lgg0LjQu9C4INC+0YLRgdGD0YLRgdGC0LLQuNGPINC00LDQvdC90YvRhSAo0L/QvtGB0LvQtSDQv9C+0L/Ri9GC0LrQuCDQt9Cw0LPRgNGD0LfQutC4INC4INC90LUgR29vZ2xlIEZvbnQpXG4gICAgaWYgKCFnbHlwaHNMb2FkZWQgfHwgIWdseXBoc0RhdGEgfHwgZGlzcGxheWFibGVHbHlwaHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAvLyDQndC1INC/0L7QutCw0LfRi9Cy0LDQtdC8INC+0YjQuNCx0LrRgywg0LXRgdC70LggaXNMb2FkaW5nR2x5cGhzINCy0YHQtSDQtdGJ0LUgdHJ1ZVxuICAgICAgaWYgKGlzTG9hZGluZ0dseXBocy5jdXJyZW50KSByZXR1cm4gbnVsbDsgXG4gICAgICByZXR1cm4gKFxuICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwicC04IHRleHQtY2VudGVyIHRleHQtZ3JheS01MDBcIj5cbiAgICAgICAgICAgICAg0J3QtdGCINC00LDQvdC90YvRhSDQviDQs9C70LjRhNCw0YUg0LTQu9GPINGI0YDQuNGE0YLQsCBcIntzZWxlY3RlZEZvbnQ/Lm5hbWUgfHwgJ9Cd0LXQuNC30LLQtdGB0YLQvdGL0LknfVwiIFxuICAgICAgICAgICAgICDQuNC70Lgg0L3QtSDRg9C00LDQu9C+0YHRjCDQuNGFINC30LDQs9GA0YPQt9C40YLRjC4g0J/RgNC+0LLQtdGA0YzRgtC1INC60L7QvdGB0L7Qu9GMINC90LAg0L3QsNC70LjRh9C40LUg0L7RiNC40LHQvtC6LlxuICAgICAgICAgIDwvZGl2PlxuICAgICAgKTtcbiAgICB9XG5cbiAgICAvLyAtLS0g0J7RgtC+0LHRgNCw0LbQtdC90LjQtSDQuNC90YTQvtGA0LzQsNGG0LjQuCDQvtCxINC+0YjQuNCx0LrQsNGFIC0tLSAqL1xuICAgIGlmIChnbHlwaEVycm9ycy5sZW5ndGggPiAwKSB7XG4gICAgICA8ZGl2IGNsYXNzTmFtZT1cIm1iLTQgcC0zIGJnLXllbGxvdy0xMDAgYm9yZGVyIGJvcmRlci15ZWxsb3ctMzAwIHRleHQteWVsbG93LTgwMCB0ZXh0LXhzIHJvdW5kZWRcIj5cbiAgICAgICAg0J/RgNC4INC+0LHRgNCw0LHQvtGC0LrQtSDRiNGA0LjRhNGC0LAg0LLQvtC30L3QuNC60LvQviB7Z2x5cGhFcnJvcnMubGVuZ3RofSDQvtGI0LjQsdC+0LouIFxuICAgICAgICDQndC10LrQvtGC0L7RgNGL0LUg0LPQu9C40YTRiyDQvNC+0LPRg9GCINC+0YLQvtCx0YDQsNC20LDRgtGM0YHRjyDQvdC10LrQvtGA0YDQtdC60YLQvdC+LlxuICAgICAgICB7Lyog0JzQvtC20L3QviDQtNC+0LHQsNCy0LjRgtGMINC60L3QvtC/0LrRgyDQtNC70Y8g0L/RgNC+0YHQvNC+0YLRgNCwINC00LXRgtCw0LvQtdC5ICovfVxuICAgICAgICB7LyogPGJ1dHRvbiBvbkNsaWNrPXsoKSA9PiBjb25zb2xlLmxvZygnR2x5cGggRXJyb3JzOicsIGdseXBoRXJyb3JzKX0gY2xhc3NOYW1lPVwibWwtMiB1bmRlcmxpbmVcIj7QlNC10YLQsNC70Lg8L2J1dHRvbj4gKi99XG4gICAgICA8L2Rpdj5cbiAgICB9XG5cbiAgICAvLyDQntGB0L3QvtCy0L3QvtC5INGA0LXQvdC00LXRgCAo0L7RgdGC0LDQtdGC0YHRjyDQv9C+0YfRgtC4INCx0LXQtyDQuNC30LzQtdC90LXQvdC40LksINC90L4g0LjRgdC/0L7Qu9GM0LfRg9C10YIg0L7QsdC90L7QstC70LXQvdC90YvQtSDRhdC10LvQv9C10YDRiylcbiAgICByZXR1cm4gKFxuICAgICAgPGRpdiBjbGFzc05hbWU9XCJwLThcIj5cbiAgICAgICAgPHAgY2xhc3NOYW1lPVwidGV4dC1zbSB0ZXh0LWdyYXktNjAwIG1iLTJcIj7QndCw0LnQtNC10L3QviB7ZGlzcGxheWFibGVHbHlwaHMubGVuZ3RofSDQs9C70LjRhNC+0LIuPC9wPlxuICAgICAgICBcbiAgICAgICAgey8qIC0tLSDQntGC0L7QsdGA0LDQttC10L3QuNC1INC40L3RhNC+0YDQvNCw0YbQuNC4INC+0LEg0L7RiNC40LHQutCw0YUgLS0tICovfVxuICAgICAgICB7Z2x5cGhFcnJvcnMubGVuZ3RoID4gMCAmJiAoXG4gICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJtYi00IHAtMyBiZy15ZWxsb3ctMTAwIGJvcmRlciBib3JkZXIteWVsbG93LTMwMCB0ZXh0LXllbGxvdy04MDAgdGV4dC14cyByb3VuZGVkXCI+XG4gICAgICAgICAgICDQn9GA0Lgg0L7QsdGA0LDQsdC+0YLQutC1INGI0YDQuNGE0YLQsCDQstC+0LfQvdC40LrQu9C+IHtnbHlwaEVycm9ycy5sZW5ndGh9INC+0YjQuNCx0L7Qui4gXG4gICAgICAgICAgICDQndC10LrQvtGC0L7RgNGL0LUg0LPQu9C40YTRiyDQvNC+0LPRg9GCINC+0YLQvtCx0YDQsNC20LDRgtGM0YHRjyDQvdC10LrQvtGA0YDQtdC60YLQvdC+LlxuICAgICAgICAgICAgey8qINCc0L7QttC90L4g0LTQvtCx0LDQstC40YLRjCDQutC90L7Qv9C60YMg0LTQu9GPINC/0YDQvtGB0LzQvtGC0YDQsCDQtNC10YLQsNC70LXQuSAqL31cbiAgICAgICAgICAgIHsvKiA8YnV0dG9uIG9uQ2xpY2s9eygpID0+IGNvbnNvbGUubG9nKCdHbHlwaCBFcnJvcnM6JywgZ2x5cGhFcnJvcnMpfSBjbGFzc05hbWU9XCJtbC0yIHVuZGVybGluZVwiPtCU0LXRgtCw0LvQuDwvYnV0dG9uPiAqL31cbiAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgKX1cbiAgICAgICAgXG4gICAgICAgIHsvKiAtLS0g0JjRgdC/0L7Qu9GM0LfRg9C10LwgVmlydHVvc29HcmlkIC0tLSAqL31cbiAgICAgICAgPFZpcnR1b3NvR3JpZFxuICAgICAgICAgIHN0eWxlPXt7IGhlaWdodDogJ2NhbGMoMTAwdmggLSAxMjBweCknIH19IC8vINCf0YDQuNC80LXRgDog0JfQsNC00LDQtdC8INCy0YvRgdC+0YLRgyDQutC+0L3RgtC10LnQvdC10YDQsCDQtNC70Y8g0YHQutGA0L7Qu9C70LjQvdCz0LBcbiAgICAgICAgICB0b3RhbENvdW50PXtkaXNwbGF5YWJsZUdseXBocy5sZW5ndGh9XG4gICAgICAgICAgY29tcG9uZW50cz17e1xuICAgICAgICAgICAgLy8g0JrQvtC80L/QvtC90LXQvdGCLCDQuiDQutC+0YLQvtGA0L7QvNGDINCx0YPQtNGD0YIg0L/RgNC40LzQtdC90LXQvdGLINGB0YLQuNC70Lgg0YHQtdGC0LrQuFxuICAgICAgICAgICAgTGlzdDogUmVhY3QuZm9yd2FyZFJlZigoeyBzdHlsZSwgY2hpbGRyZW4sIC4uLnByb3BzIH0sIHJlZikgPT4gKFxuICAgICAgICAgICAgICA8ZGl2XG4gICAgICAgICAgICAgICAgcmVmPXtyZWZ9XG4gICAgICAgICAgICAgICAgey4uLnByb3BzfVxuICAgICAgICAgICAgICAgIHN0eWxlPXtzdHlsZX0gLy8gVmlydHVvc28g0L/QtdGA0LXQtNCw0LXRgiDQvdC10L7QsdGF0L7QtNC40LzRi9C1INGB0YLQuNC70Lgg0LTQu9GPINCy0L3Rg9GC0YDQtdC90L3QtdCz0L4g0LrQvtC90YLQtdC50L3QtdGA0LBcbiAgICAgICAgICAgICAgICBjbGFzc05hbWU9XCJncmlkIGdyaWQtY29scy0yIHNtOmdyaWQtY29scy00IG1kOmdyaWQtY29scy02IGxnOmdyaWQtY29scy04IHhsOmdyaWQtY29scy0xMCBnYXAtMyBtdC02XCJcbiAgICAgICAgICAgICAgPlxuICAgICAgICAgICAgICAgIHtjaGlsZHJlbn1cbiAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICApKSxcbiAgICAgICAgICAgIC8vINCa0L7QvNC/0L7QvdC10L3RgiDQtNC70Y8g0L7QsdC10YDRgtC60Lgg0LrQsNC20LTQvtCz0L4g0Y3Qu9C10LzQtdC90YLQsCAo0LXRgdC70Lgg0L3Rg9C20L3Qviwg0LzQvtC20L3QviDQvtGB0YLQsNCy0LjRgtGMIGRpdiDQv9C+INGD0LzQvtC70YfQsNC90LjRjilcbiAgICAgICAgICAgIC8vIEl0ZW06ICh7IGNoaWxkcmVuLCAuLi5wcm9wcyB9KSA9PiA8ZGl2IHsuLi5wcm9wc30+e2NoaWxkcmVufTwvZGl2PixcbiAgICAgICAgICB9fVxuICAgICAgICAgIGl0ZW1Db250ZW50PXsoaW5kZXgpID0+IHtcbiAgICAgICAgICAgIC8vINCf0L7Qu9GD0YfQsNC10Lwg0LPQu9C40YQg0L/QviDQuNC90LTQtdC60YHRg1xuICAgICAgICAgICAgY29uc3QgZ2x5cGggPSBkaXNwbGF5YWJsZUdseXBoc1tpbmRleF07XG4gICAgICAgICAgICBpZiAoIWdseXBoKSByZXR1cm4gbnVsbDsgLy8g0J3QsCDQstGB0Y/QutC40Lkg0YHQu9GD0YfQsNC5XG5cbiAgICAgICAgICAgIC8vIC0tLSDQntCx0L3QvtCy0LvQtdC90L3QsNGPINC70L7Qs9C40LrQsCDQv9C+0LvRg9GH0LXQvdC40Y8g0YHQuNC80LLQvtC70LAgKNC+0YHRgtCw0LXRgtGB0Y8g0YLQsCDQttC1KSAtLS1cbiAgICAgICAgICAgIGxldCBjaGFyID0gbnVsbDtcbiAgICAgICAgICAgIGxldCBpc1ByaW50YWJsZSA9IGZhbHNlO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICBpZiAoZ2x5cGgudW5pY29kZSkge1xuICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHBvdGVudGlhbENoYXIgPSBTdHJpbmcuZnJvbUNvZGVQb2ludChnbHlwaC51bmljb2RlKTtcbiAgICAgICAgICAgICAgICBpZiAocG90ZW50aWFsQ2hhciAmJiBwb3RlbnRpYWxDaGFyLnRyaW0oKSAhPT0gJycgJiYgIS9bXFxwe0N9XS91LnRlc3QocG90ZW50aWFsQ2hhcikpIHsgXG4gICAgICAgICAgICAgICAgICBjaGFyID0gcG90ZW50aWFsQ2hhcjtcbiAgICAgICAgICAgICAgICAgIGlzUHJpbnRhYmxlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHsgLyogSWdub3JlIGludmFsaWQgY29kZSBwb2ludHMgKi8gfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgXG4gICAgICAgICAgICBpZiAoIWlzUHJpbnRhYmxlICYmIGdseXBoLnVuaWNvZGVzICYmIGdseXBoLnVuaWNvZGVzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgZm9yIChjb25zdCBjb2RlUG9pbnQgb2YgZ2x5cGgudW5pY29kZXMpIHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgY29uc3QgcG90ZW50aWFsQ2hhciA9IFN0cmluZy5mcm9tQ29kZVBvaW50KGNvZGVQb2ludCk7XG4gICAgICAgICAgICAgICAgICAgaWYgKHBvdGVudGlhbENoYXIgJiYgcG90ZW50aWFsQ2hhci50cmltKCkgIT09ICcnICYmICEvW1xccHtDfV0vdS50ZXN0KHBvdGVudGlhbENoYXIpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNoYXIgPSBwb3RlbnRpYWxDaGFyO1xuICAgICAgICAgICAgICAgICAgICBpc1ByaW50YWJsZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrOyBcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGNhdGNoIChlKSB7IC8qIElnbm9yZSBpbnZhbGlkIGNvZGUgcG9pbnRzICovIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gLS0tINCa0L7QvdC10YYg0L7QsdC90L7QstC70LXQvdC90L7QuSDQu9C+0LPQuNC60LggLS0tXG4gICAgICAgICAgICAgIFxuICAgICAgICAgICAgY29uc3QgZ2x5cGhOYW1lID0gZ2V0R2x5cGhOYW1lKGdseXBoKTtcbiAgICAgICAgICAgIGNvbnN0IGdseXBoVW5pY29kZVN0ciA9IGdldEdseXBoVW5pY29kZShnbHlwaCk7XG5cbiAgICAgICAgICAgIC8vINCS0L7Qt9Cy0YDQsNGJ0LDQtdC8IEpTWCDQtNC70Y8g0L7QtNC90L7Qs9C+INCz0LvQuNGE0LAgKNGC0L7RgiDQttC1LCDRh9GC0L4g0LHRi9C7INCy0L3Rg9GC0YDQuCAubWFwKVxuICAgICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgICAgPGRpdlxuICAgICAgICAgICAgICAgIGtleT17Z2x5cGguaWR9IC8vINCa0LvRjtGHINGC0LXQv9C10YDRjCDQt9C00LXRgdGMINC90LUg0YLQsNC6INC60YDQuNGC0LjRh9C10L0sINC90L4g0L7RgdGC0LDQstC40LxcbiAgICAgICAgICAgICAgICBjbGFzc05hbWU9XCJiZy13aGl0ZSBoLWZ1bGwgcm91bmRlZC1tZCBvdmVyZmxvdy1oaWRkZW4gYm9yZGVyIGJvcmRlci1ncmF5LTIwMCBob3Zlcjpib3JkZXItYmx1ZS00MDAgaG92ZXI6c2hhZG93LW1kIHRyYW5zaXRpb24tYWxsIGN1cnNvci1wb2ludGVyIGZsZXggZmxleC1jb2xcIlxuICAgICAgICAgICAgICAgIG9uQ2xpY2s9eygpID0+IHNldFNlbGVjdGVkR2x5cGgoZ2x5cGgpfVxuICAgICAgICAgICAgICAgIHRpdGxlPXtg0J3QsNC20LzQuNGC0LUsINGH0YLQvtCx0Ysg0YPQstC40LTQtdGC0Ywg0LTQtdGC0LDQu9C4INCz0LvQuNGE0LAgJHtnbHlwaE5hbWV9YH1cbiAgICAgICAgICAgICAgPlxuICAgICAgICAgICAgICAgIDxkaXYgXG4gICAgICAgICAgICAgICAgICBjbGFzc05hbWU9XCJ0ZXh0LWNlbnRlciBwLTQgZmxleC1ncm93IGZsZXggaXRlbXMtY2VudGVyIGp1c3RpZnktY2VudGVyXCIgXG4gICAgICAgICAgICAgICAgICBzdHlsZT17KCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZmluYWxTdHlsZSA9IHsgXG4gICAgICAgICAgICAgICAgICAgICAgZm9udFNpemU6IGAke2ZvbnRTaXplfXB4YCxcbiAgICAgICAgICAgICAgICAgICAgICBmb250RmFtaWx5OiBmb250RmFtaWx5IHx8ICdpbmhlcml0JywgXG4gICAgICAgICAgICAgICAgICAgICAgLi4uZ2x5cGhEaXNwbGF5U3R5bGUgXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAvLyDQm9C+0LPQuNGA0YPQtdC8INGB0YLQuNC70Lgg0YLQvtC70YzQutC+INC00LvRjyDQv9C10YDQstC+0LPQviDQs9C70LjRhNCwICjRh9GC0L7QsdGLINC90LUg0YHQv9Cw0LzQuNGC0YwpXG4gICAgICAgICAgICAgICAgICAgIGlmIChpbmRleCA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCdbR2x5cGhzTW9kZV0g0KHQotCY0JvQmCDQk9Cb0JjQpNCQICMwOicsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvbnRTaXplOiBmaW5hbFN0eWxlLmZvbnRTaXplLFxuICAgICAgICAgICAgICAgICAgICAgICAgZm9udEZhbWlseTogZmluYWxTdHlsZS5mb250RmFtaWx5LFxuICAgICAgICAgICAgICAgICAgICAgICAgZm9udFZhcmlhdGlvblNldHRpbmdzOiBmaW5hbFN0eWxlLmZvbnRWYXJpYXRpb25TZXR0aW5ncyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvbnRXZWlnaHQ6IGZpbmFsU3R5bGUuZm9udFdlaWdodCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvbnRTdHlsZTogZmluYWxTdHlsZS5mb250U3R5bGUsXG4gICAgICAgICAgICAgICAgICAgICAgICBmdWxsU3R5bGU6IGZpbmFsU3R5bGVcbiAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZpbmFsU3R5bGU7XG4gICAgICAgICAgICAgICAgICB9KSgpfVxuICAgICAgICAgICAgICAgID5cbiAgICAgICAgICAgICAgICAgIHtpc1ByaW50YWJsZSA/IGNoYXIgOiA8c3BhbiBjbGFzc05hbWU9XCJ0ZXh0LWdyYXktNDAwIHRleHQtc21cIj4obm8gY2hhcik8L3NwYW4+fVxuICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwiYmctZ3JheS01MCBwLTIgdGV4dC1bMTBweF1cIj5cbiAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwidGV4dC1ncmF5LTcwMCB0ZXh0LWNlbnRlciB0cnVuY2F0ZSB3LWZ1bGwgZm9udC1tZWRpdW1cIiB0aXRsZT17Z2x5cGhOYW1lfT5cbiAgICAgICAgICAgICAgICAgICAge2dseXBoTmFtZX1cbiAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwidGV4dC1ncmF5LTUwMCB0ZXh0LWNlbnRlclwiPlxuICAgICAgICAgICAgICAgICAgICB7Z2x5cGhVbmljb2RlU3RyIHx8ICctJ31cbiAgICAgICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImZsZXgganVzdGlmeS1jZW50ZXIgZ2FwLTEgbXQtMVwiPlxuICAgICAgICAgICAgICAgICAgICB7aXNQcmludGFibGUgJiYgKFxuICAgICAgICAgICAgICAgICAgICAgICA8YnV0dG9uXG4gICAgICAgICAgICAgICAgICAgICAgICAgb25DbGljaz17KGUpID0+IHsgZS5zdG9wUHJvcGFnYXRpb24oKTsgY29weVRvQ2xpcGJvYXJkKGNoYXIsICfQodC40LzQstC+0LsnKTsgfX1cbiAgICAgICAgICAgICAgICAgICAgICAgICBjbGFzc05hbWU9XCJ0ZXh0LVs4cHhdIHB4LTEgcHktMC41IGJnLWJsdWUtMTAwIGhvdmVyOmJnLWJsdWUtMjAwIHRleHQtYmx1ZS03MDAgcm91bmRlZFwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgdGl0bGU9XCLQmtC+0L/QuNGA0L7QstCw0YLRjCDRgdC40LzQstC+0LtcIlxuICAgICAgICAgICAgICAgICAgICAgICA+XG4gICAgICAgICAgICAgICAgICAgICAgICAgQ2hhclxuICAgICAgICAgICAgICAgICAgICAgICA8L2J1dHRvbj5cbiAgICAgICAgICAgICAgICAgICAgKX1cbiAgICAgICAgICAgICAgICAgICAgPGJ1dHRvblxuICAgICAgICAgICAgICAgICAgICAgIG9uQ2xpY2s9eyhlKSA9PiB7IGUuc3RvcFByb3BhZ2F0aW9uKCk7IGNvcHlUb0NsaXBib2FyZChnbHlwaE5hbWUsICfQmNC80Y8nKTsgfX1cbiAgICAgICAgICAgICAgICAgICAgICBjbGFzc05hbWU9XCJ0ZXh0LVs4cHhdIHB4LTEgcHktMC41IGJnLWdyYXktMTAwIGhvdmVyOmJnLWdyYXktMjAwIHRleHQtZ3JheS03MDAgcm91bmRlZFwiXG4gICAgICAgICAgICAgICAgICAgICAgdGl0bGU9XCLQmtC+0L/QuNGA0L7QstCw0YLRjCDQuNC80Y9cIlxuICAgICAgICAgICAgICAgICAgICAgPlxuICAgICAgICAgICAgICAgICAgICAgICBOYW1lXG4gICAgICAgICAgICAgICAgICAgICA8L2J1dHRvbj5cbiAgICAgICAgICAgICAgICAgICAgIHtnbHlwaFVuaWNvZGVTdHIgJiYgKFxuICAgICAgICAgICAgICAgICAgICAgICA8YnV0dG9uXG4gICAgICAgICAgICAgICAgICAgICAgICAgb25DbGljaz17KGUpID0+IHsgZS5zdG9wUHJvcGFnYXRpb24oKTsgY29weVRvQ2xpcGJvYXJkKGdseXBoVW5pY29kZVN0ciwgJ1VuaWNvZGUnKTsgfX1cbiAgICAgICAgICAgICAgICAgICAgICAgICBjbGFzc05hbWU9XCJ0ZXh0LVs4cHhdIHB4LTEgcHktMC41IGJnLWdyYXktMTAwIGhvdmVyOmJnLWdyYXktMjAwIHRleHQtZ3JheS03MDAgcm91bmRlZFwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgdGl0bGU9XCLQmtC+0L/QuNGA0L7QstCw0YLRjCBVbmljb2RlXCJcbiAgICAgICAgICAgICAgICAgICAgICAgID5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgVW5pY29kZVxuICAgICAgICAgICAgICAgICAgICAgICAgPC9idXR0b24+XG4gICAgICAgICAgICAgICAgICAgICAgKX1cbiAgICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9fVxuICAgICAgICAvPlxuICAgICAgICB7LyogLS0tINCa0L7QvdC10YYgVmlydHVvc29HcmlkIC0tLSAqL31cblxuICAgICAgICB7Lyog0JzQvtC00LDQu9GM0L3QvtC1INC+0LrQvdC+ICjQvtGB0YLQsNC10YLRgdGPINCx0LXQtyDQuNC30LzQtdC90LXQvdC40LkpICovfVxuICAgICAgICB7c2VsZWN0ZWRHbHlwaCAmJiAoXG4gICAgICAgICAgPGRpdiBcbiAgICAgICAgICAgICAgY2xhc3NOYW1lPVwiZml4ZWQgaW5zZXQtMCBiZy1ibGFjayBiZy1vcGFjaXR5LTYwIGZsZXggaXRlbXMtY2VudGVyIGp1c3RpZnktY2VudGVyIHotNTAgcC00XCIgXG4gICAgICAgICAgICAgIG9uQ2xpY2s9eygpID0+IHNldFNlbGVjdGVkR2x5cGgobnVsbCl9XG4gICAgICAgICAgPlxuICAgICAgICAgICAgPGRpdiBcbiAgICAgICAgICAgICAgY2xhc3NOYW1lPVwiYmctd2hpdGUgcC02IHNtOnAtOCByb3VuZGVkLWxnIHNoYWRvdy14bCBtYXgtdy1tZCB3LWZ1bGwgcmVsYXRpdmVcIiBcbiAgICAgICAgICAgICAgb25DbGljaz17ZSA9PiBlLnN0b3BQcm9wYWdhdGlvbigpfVxuICAgICAgICAgICAgPlxuICAgICAgICAgICAgICA8YnV0dG9uIFxuICAgICAgICAgICAgICAgICAgb25DbGljaz17KCkgPT4gc2V0U2VsZWN0ZWRHbHlwaChudWxsKX0gXG4gICAgICAgICAgICAgICAgICBjbGFzc05hbWU9XCJhYnNvbHV0ZSB0b3AtMiByaWdodC0zIHRleHQtZ3JheS00MDAgaG92ZXI6dGV4dC1ncmF5LTcwMCB0ZXh0LTN4bCBmb250LWxpZ2h0IGxlYWRpbmctbm9uZVwiXG4gICAgICAgICAgICAgICAgICBhcmlhLWxhYmVsPVwi0JfQsNC60YDRi9GC0YxcIlxuICAgICAgICAgICAgICA+XG4gICAgICAgICAgICAgICAgICAmdGltZXM7XG4gICAgICAgICAgICAgIDwvYnV0dG9uPlxuICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgeygoKSA9PiB7IC8vINCY0YHQv9C+0LvRjNC30YPQtdC8IElJRkUg0LTQu9GPINC/0L7Qu9GD0YfQtdC90LjRjyDQt9C90LDRh9C10L3QuNC5INC+0LTQuNC9INGA0LDQt1xuICAgICAgICAgICAgICAgICAgY29uc3QgbmFtZSA9IGdldEdseXBoTmFtZShzZWxlY3RlZEdseXBoKTtcbiAgICAgICAgICAgICAgICAgIGNvbnN0IHVuaWNvZGVTdHIgPSBnZXRHbHlwaFVuaWNvZGUoc2VsZWN0ZWRHbHlwaCk7XG4gICAgICAgICAgICAgICAgICBjb25zdCBhZHZhbmNlV2lkdGggPSBnbHlwaHNEYXRhPy5hZHZhbmNlV2lkdGhzPy5bc2VsZWN0ZWRHbHlwaC5pZF07XG4gICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgIC8vIC0tLSDQntCx0L3QvtCy0LvQtdC90L3QsNGPINC70L7Qs9C40LrQsCDQv9C+0LvRg9GH0LXQvdC40Y8g0YHQuNC80LLQvtC70LAg0LTQu9GPINC80L7QtNCw0LvRjNC90L7Qs9C+INC+0LrQvdCwIC0tLVxuICAgICAgICAgICAgICAgICAgbGV0IGNoYXIgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgbGV0IGlzUHJpbnRhYmxlID0gZmFsc2U7XG5cbiAgICAgICAgICAgICAgICAgIC8vIDEuINCf0YDQvtCx0YPQtdC8INC+0YHQvdC+0LLQvdC+0LkgdW5pY29kZVxuICAgICAgICAgICAgICAgICAgaWYgKHNlbGVjdGVkR2x5cGgudW5pY29kZSkge1xuICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHBvdGVudGlhbENoYXIgPSBTdHJpbmcuZnJvbUNvZGVQb2ludChzZWxlY3RlZEdseXBoLnVuaWNvZGUpO1xuICAgICAgICAgICAgICAgICAgICAgIGlmIChwb3RlbnRpYWxDaGFyICYmIHBvdGVudGlhbENoYXIudHJpbSgpICE9PSAnJyAmJiAhL1tcXHB7Q31dL3UudGVzdChwb3RlbnRpYWxDaGFyKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2hhciA9IHBvdGVudGlhbENoYXI7XG4gICAgICAgICAgICAgICAgICAgICAgICBpc1ByaW50YWJsZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9IGNhdGNoIChlKSB7fVxuICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAvLyAyLiDQldGB0LvQuCDQvdC1INC/0L7Qu9GD0YfQuNC70L7RgdGMLCDQv9GA0L7QsdGD0LXQvCDQvNCw0YHRgdC40LIgdW5pY29kZXNcbiAgICAgICAgICAgICAgICAgIGlmICghaXNQcmludGFibGUgJiYgc2VsZWN0ZWRHbHlwaC51bmljb2RlcyAmJiBzZWxlY3RlZEdseXBoLnVuaWNvZGVzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChjb25zdCBjb2RlUG9pbnQgb2Ygc2VsZWN0ZWRHbHlwaC51bmljb2Rlcykge1xuICAgICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBwb3RlbnRpYWxDaGFyID0gU3RyaW5nLmZyb21Db2RlUG9pbnQoY29kZVBvaW50KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocG90ZW50aWFsQ2hhciAmJiBwb3RlbnRpYWxDaGFyLnRyaW0oKSAhPT0gJycgJiYgIS9bXFxwe0N9XS91LnRlc3QocG90ZW50aWFsQ2hhcikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgY2hhciA9IHBvdGVudGlhbENoYXI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIGlzUHJpbnRhYmxlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7IFxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHt9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAvLyAtLS0g0JrQvtC90LXRhiDQvtCx0L3QvtCy0LvQtdC90L3QvtC5INC70L7Qs9C40LrQuCAtLS1cblxuICAgICAgICAgICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgICAgICAgICAgICA8PlxuICAgICAgICAgICAgICAgICAgICAgICAgICA8aDMgY2xhc3NOYW1lPVwidGV4dC14bCBmb250LXNlbWlib2xkIG1iLTQgdGV4dC1ncmF5LTgwMCB0cnVuY2F0ZVwiIHRpdGxlPXtuYW1lfT5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgINCU0LXRgtCw0LvQuCDQs9C70LjRhNCwOiB7bmFtZX1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgPC9oMz5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJ0ZXh0LWNlbnRlciBtYi02IHAtNCBiZy1ncmF5LTUwIHJvdW5kZWRcIiBzdHlsZT17bGFyZ2VHbHlwaFN0eWxlfT5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtpc1ByaW50YWJsZSA/IGNoYXIgOiA8c3BhbiBjbGFzc05hbWU9XCJ0ZXh0LWdyYXktNDAwIHRleHQteGxcIj4obm8gY2hhcik8L3NwYW4+fVxuICAgICAgICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJzcGFjZS15LTIgdGV4dC1zbSB0ZXh0LWdyYXktNzAwXCI+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8cD48c3Ryb25nPtCY0LzRjzo8L3N0cm9uZz4ge25hbWV9PC9wPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPHA+PHN0cm9uZz5Vbmljb2RlOjwvc3Ryb25nPiB7dW5pY29kZVN0ciB8fCAnTi9BJ308L3A+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8cD48c3Ryb25nPklEICjQuNC90LTQtdC60YEpOjwvc3Ryb25nPiB7c2VsZWN0ZWRHbHlwaC5pZH08L3A+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7YWR2YW5jZVdpZHRoICE9PSB1bmRlZmluZWQgJiYgKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxwPjxzdHJvbmc+0KjQuNGA0LjQvdCwIChhZHZhbmNlV2lkdGgpOjwvc3Ryb25nPiB7YWR2YW5jZVdpZHRofTwvcD5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICl9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7c2VsZWN0ZWRHbHlwaC51bmljb2RlcyAmJiBzZWxlY3RlZEdseXBoLnVuaWNvZGVzLmxlbmd0aCA+IDEgJiYgKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxwPjxzdHJvbmc+0JTRgNGD0LPQuNC1IFVuaWNvZGU6PC9zdHJvbmc+IHtzZWxlY3RlZEdseXBoLnVuaWNvZGVzLmZpbHRlcih1ID0+IHUgIT09IHNlbGVjdGVkR2x5cGgudW5pY29kZSkubWFwKHUgPT4gYFUrJHt1LnRvU3RyaW5nKDE2KS50b1VwcGVyQ2FzZSgpLnBhZFN0YXJ0KDQsJzAnKX1gKS5qb2luKCcsICcpfTwvcD5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICl9XG4gICAgICAgICAgICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cIm10LTYgZmxleCBmbGV4LXdyYXAganVzdGlmeS1lbmQgZ2FwLTJcIj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtpc1ByaW50YWJsZSAmJiAoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGJ1dHRvbiBvbkNsaWNrPXsoKSA9PiBjb3B5VG9DbGlwYm9hcmQoY2hhciwgJ9Ch0LjQvNCy0L7QuycpfSBjbGFzc05hbWU9XCJweC0zIHB5LTEuNSBiZy1ibHVlLTUwMCB0ZXh0LXdoaXRlIHJvdW5kZWQgaG92ZXI6YmctYmx1ZS02MDAgdGV4dC1zbSBzaGFkb3ctc21cIj7QmtC+0L/QuNGA0L7QstCw0YLRjCDRgdC40LzQstC+0Ls8L2J1dHRvbj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICl9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8YnV0dG9uIG9uQ2xpY2s9eygpID0+IGNvcHlUb0NsaXBib2FyZChuYW1lLCAn0JjQvNGPJyl9IGNsYXNzTmFtZT1cInB4LTMgcHktMS41IGJnLWdyYXktMjAwIHRleHQtZ3JheS04MDAgcm91bmRlZCBob3ZlcjpiZy1ncmF5LTMwMCB0ZXh0LXNtIHNoYWRvdy1zbVwiPtCa0L7Qv9C40YDQvtCy0LDRgtGMINC40LzRjzwvYnV0dG9uPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAge3VuaWNvZGVTdHIgJiYgKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxidXR0b24gb25DbGljaz17KCkgPT4gY29weVRvQ2xpcGJvYXJkKHVuaWNvZGVTdHIsICdVbmljb2RlJyl9IGNsYXNzTmFtZT1cInB4LTMgcHktMS41IGJnLWdyYXktMjAwIHRleHQtZ3JheS04MDAgcm91bmRlZCBob3ZlcjpiZy1ncmF5LTMwMCB0ZXh0LXNtIHNoYWRvdy1zbVwiPtCa0L7Qv9C40YDQvtCy0LDRgtGMIFVuaWNvZGU8L2J1dHRvbj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICl9XG4gICAgICAgICAgICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgICAgICAgICAgIDwvPlxuICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgfSkoKX1cbiAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICA8L2Rpdj5cbiAgICAgICAgKX1cbiAgICAgIDwvZGl2PlxuICAgICk7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgY29uc29sZS5lcnJvcihcIltHbHlwaHNNb2RlXSBSZW5kZXIgZXJyb3IgY2F1Z2h0OlwiLCBlcnJvcik7XG4gICAgLy8g0JLQvtC30LLRgNCw0YnQsNC10Lwg0L/RgNC+0YHRgtC+0LkgZmFsbGJhY2sgVUkg0L/RgNC4INC+0YjQuNCx0LrQtSDRgNC10L3QtNC10YDQsFxuICAgIHJldHVybiAoXG4gICAgICAgIDxkaXYgY2xhc3NOYW1lPVwicC04IHRleHQtY2VudGVyIHRleHQtcmVkLTYwMCBiZy1yZWQtNTAgYm9yZGVyIGJvcmRlci1yZWQtMjAwIHJvdW5kZWRcIj5cbiAgICAgICAgICAgIDxwIGNsYXNzTmFtZT1cImZvbnQtYm9sZCBtYi0yXCI+0J7RiNC40LHQutCwINGA0LXQvdC00LXRgNC40L3Qs9CwINCyINC60L7QvNC/0L7QvdC10L3RgtC1IEdseXBoc01vZGUuPC9wPlxuICAgICAgICAgICAgPHAgY2xhc3NOYW1lPVwidGV4dC1zbVwiPtCf0L7QttCw0LvRg9C50YHRgtCwLCDQv9GA0L7QstC10YDRjNGC0LUg0LrQvtC90YHQvtC70Ywg0LTQu9GPINC00LXRgtCw0LvQtdC5LjwvcD5cbiAgICAgICAgPC9kaXY+XG4gICAgKTtcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBHbHlwaHNNb2RlOyAiXSwibmFtZXMiOlsiUmVhY3QiLCJ1c2VTdGF0ZSIsInVzZUNhbGxiYWNrIiwidXNlTWVtbyIsInVzZUVmZmVjdCIsInVzZVJlZiIsInRvYXN0IiwiVmlydHVvc29HcmlkIiwiZGVib3VuY2UiLCJnZXRHbHlwaERhdGFGb3JGb250IiwidXNlU2V0dGluZ3MiLCJ1c2VGb250Q29udGV4dCIsImdseXBoRGF0YUNhY2hlIiwiTWFwIiwiR2x5cGhzTW9kZSIsInNlbGVjdGVkRm9udCIsImZvbnRGYW1pbHkiLCJnbHlwaERpc3BsYXlTdHlsZSIsImlzQWN0aXZlIiwiZm9udFNpemUiLCJnZXRGb250RmFtaWx5IiwiZ2V0VmFyaWF0aW9uU2V0dGluZ3MiLCJzZXR0aW5ncyIsImdseXBoU2V0dGluZ3MiLCJjb25zb2xlIiwibG9nIiwibmFtZSIsImlzVmFyaWFibGVGb250Iiwic2VsZWN0ZWRGb250X2lkIiwiaWQiLCJzZWxlY3RlZEZvbnRfZm9udEZhbWlseSIsImdseXBoc0xvYWRlZCIsInNldEdseXBoc0xvYWRlZCIsImdseXBoc0RhdGEiLCJzZXRHbHlwaHNEYXRhIiwiZ2x5cGhFcnJvcnMiLCJzZXRHbHlwaEVycm9ycyIsImlzTG9hZGluZ0dseXBocyIsImN1cnJlbnRMb2FkSWQiLCJsb2FkR2x5cGhzQ2FsbGJhY2siLCJjdXJyZW50QXR0ZW1wdExvYWRJZCIsImZvbnRUb0xvYWQiLCJhdHRlbXB0Rm9udElkIiwiY3VycmVudCIsImhhcyIsImNhY2hlZERhdGEiLCJnZXQiLCJlcnJvcnMiLCJhbGxHbHlwaHMiLCJ3YXJuIiwiZGF0YSIsIkFycmF5IiwiaXNBcnJheSIsIkVycm9yIiwic2V0IiwiZXJyb3IiLCJtZXNzYWdlIiwiZGVib3VuY2VkTG9hZEdseXBocyIsImZvbnRJZCIsImZvbnRTb3VyY2UiLCJzb3VyY2UiLCJsb2FkSWQiLCJNYXRoIiwicmFuZG9tIiwidG9TdHJpbmciLCJzdWJzdHJpbmciLCJyZXNldFN0YXRlIiwibG9nTWVzc2FnZSIsImZpbGUiLCJCbG9iIiwiaW5mbyIsImlzRGF0YUxvYWRlZEluU3RhdGUiLCJjYW5jZWwiLCJsYXJnZUdseXBoU3R5bGUiLCJiYXNlU2l6ZSIsIm1vZGFsRm9udFNpemUiLCJtYXgiLCJtaW4iLCJpbmNsdWRlcyIsImxpbmVIZWlnaHQiLCJjb3B5VG9DbGlwYm9hcmQiLCJ0ZXh0IiwidHlwZSIsIm5hdmlnYXRvciIsImNsaXBib2FyZCIsIndyaXRlVGV4dCIsInRoZW4iLCJzdWNjZXNzIiwiY2F0Y2giLCJlcnIiLCJ0b0xvd2VyQ2FzZSIsImRpc3BsYXlhYmxlR2x5cGhzIiwiZ2V0R2x5cGhOYW1lIiwiZ2x5cGgiLCJuYW1lcyIsImdldEdseXBoVW5pY29kZSIsInVuaWNvZGVWYWx1ZSIsInVuaWNvZGVzIiwidW5pY29kZSIsInRvVXBwZXJDYXNlIiwicGFkU3RhcnQiLCJzZWxlY3RlZEdseXBoIiwic2V0U2VsZWN0ZWRHbHlwaCIsImRpdiIsImNsYXNzTmFtZSIsImxlbmd0aCIsInAiLCJzdHlsZSIsImhlaWdodCIsInRvdGFsQ291bnQiLCJjb21wb25lbnRzIiwiTGlzdCIsImZvcndhcmRSZWYiLCJyZWYiLCJjaGlsZHJlbiIsInByb3BzIiwiaXRlbUNvbnRlbnQiLCJpbmRleCIsImNoYXIiLCJpc1ByaW50YWJsZSIsInBvdGVudGlhbENoYXIiLCJTdHJpbmciLCJmcm9tQ29kZVBvaW50IiwidHJpbSIsInRlc3QiLCJlIiwiY29kZVBvaW50IiwiZ2x5cGhOYW1lIiwiZ2x5cGhVbmljb2RlU3RyIiwib25DbGljayIsInRpdGxlIiwiZmluYWxTdHlsZSIsImZvbnRWYXJpYXRpb25TZXR0aW5ncyIsImZvbnRXZWlnaHQiLCJmb250U3R5bGUiLCJmdWxsU3R5bGUiLCJzcGFuIiwiYnV0dG9uIiwic3RvcFByb3BhZ2F0aW9uIiwiYXJpYS1sYWJlbCIsInVuaWNvZGVTdHIiLCJhZHZhbmNlV2lkdGgiLCJhZHZhbmNlV2lkdGhzIiwiaDMiLCJzdHJvbmciLCJ1bmRlZmluZWQiLCJmaWx0ZXIiLCJ1IiwibWFwIiwiam9pbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./components/GlyphsMode.jsx\n"));

/***/ }),

/***/ "./node_modules/react-virtuoso/dist/index.mjs":
/*!****************************************************!*\
  !*** ./node_modules/react-virtuoso/dist/index.mjs ***!
  \****************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   GroupedVirtuoso: function() { return /* binding */ jr; },\n/* harmony export */   LogLevel: function() { return /* binding */ ht; },\n/* harmony export */   TableVirtuoso: function() { return /* binding */ qr; },\n/* harmony export */   Virtuoso: function() { return /* binding */ Kr; },\n/* harmony export */   VirtuosoGrid: function() { return /* binding */ Yr; },\n/* harmony export */   VirtuosoGridMockContext: function() { return /* binding */ Yn; },\n/* harmony export */   VirtuosoMockContext: function() { return /* binding */ Re; }\n/* harmony export */ });\n/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-runtime */ \"./node_modules/react/jsx-runtime.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"./node_modules/react/index.js\");\n/* harmony import */ var react_dom__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! react-dom */ \"./node_modules/react-dom/index.js\");\n\n\n\nconst we = 0, zt = 1, qt = 2, En = 4;\nfunction ln(t) {\n  return () => t;\n}\nfunction co(t) {\n  t();\n}\nfunction ne(t, e) {\n  return (n) => t(e(n));\n}\nfunction cn(t, e) {\n  return () => t(e);\n}\nfunction kn(t, e) {\n  return (n) => t(e, n);\n}\nfunction Me(t) {\n  return t !== void 0;\n}\nfunction uo(...t) {\n  return () => {\n    t.map(co);\n  };\n}\nfunction Yt() {\n}\nfunction ye(t, e) {\n  return e(t), t;\n}\nfunction ao(t, e) {\n  return e(t);\n}\nfunction X(...t) {\n  return t;\n}\nfunction K(t, e) {\n  return t(zt, e);\n}\nfunction W(t, e) {\n  t(we, e);\n}\nfunction We(t) {\n  t(qt);\n}\nfunction lt(t) {\n  return t(En);\n}\nfunction F(t, e) {\n  return K(t, kn(e, we));\n}\nfunction Rt(t, e) {\n  const n = t(zt, (o) => {\n    n(), e(o);\n  });\n  return n;\n}\nfunction un(t) {\n  let e, n;\n  return (o) => (r) => {\n    e = r, n && clearTimeout(n), n = setTimeout(() => {\n      o(e);\n    }, t);\n  };\n}\nfunction Bn(t, e) {\n  return t === e;\n}\nfunction Y(t = Bn) {\n  let e;\n  return (n) => (o) => {\n    t(e, o) || (e = o, n(o));\n  };\n}\nfunction P(t) {\n  return (e) => (n) => {\n    t(n) && e(n);\n  };\n}\nfunction E(t) {\n  return (e) => ne(e, t);\n}\nfunction vt(t) {\n  return (e) => () => {\n    e(t);\n  };\n}\nfunction x(t, ...e) {\n  const n = fo(...e);\n  return (o, r) => {\n    switch (o) {\n      case qt:\n        We(t);\n        return;\n      case zt:\n        return K(t, n(r));\n    }\n  };\n}\nfunction bt(t, e) {\n  return (n) => (o) => {\n    n(e = t(e, o));\n  };\n}\nfunction jt(t) {\n  return (e) => (n) => {\n    t > 0 ? t-- : e(n);\n  };\n}\nfunction Lt(t) {\n  let e = null, n;\n  return (o) => (r) => {\n    e = r, !n && (n = setTimeout(() => {\n      n = void 0, o(e);\n    }, t));\n  };\n}\nfunction G(...t) {\n  const e = new Array(t.length);\n  let n = 0, o = null;\n  const r = Math.pow(2, t.length) - 1;\n  return t.forEach((s, i) => {\n    const l = Math.pow(2, i);\n    K(s, (c) => {\n      const u = n;\n      n = n | l, e[i] = c, u !== r && n === r && o && (o(), o = null);\n    });\n  }), (s) => (i) => {\n    const l = () => {\n      s([i].concat(e));\n    };\n    n === r ? l() : o = l;\n  };\n}\nfunction fo(...t) {\n  return (e) => t.reduceRight(ao, e);\n}\nfunction mo(t) {\n  let e, n;\n  const o = () => e == null ? void 0 : e();\n  return function(r, s) {\n    switch (r) {\n      case zt:\n        return s ? n === s ? void 0 : (o(), n = s, e = K(t, s), e) : (o(), Yt);\n      case qt:\n        o(), n = null;\n        return;\n    }\n  };\n}\nfunction y(t) {\n  let e = t;\n  const n = $();\n  return (o, r) => {\n    switch (o) {\n      case we:\n        e = r;\n        break;\n      case zt: {\n        r(e);\n        break;\n      }\n      case En:\n        return e;\n    }\n    return n(o, r);\n  };\n}\nfunction ct(t, e) {\n  return ye(y(e), (n) => F(t, n));\n}\nfunction $() {\n  const t = [];\n  return (e, n) => {\n    switch (e) {\n      case we:\n        t.slice().forEach((o) => {\n          o(n);\n        });\n        return;\n      case qt:\n        t.splice(0, t.length);\n        return;\n      case zt:\n        return t.push(n), () => {\n          const o = t.indexOf(n);\n          o > -1 && t.splice(o, 1);\n        };\n    }\n  };\n}\nfunction pt(t) {\n  return ye($(), (e) => F(t, e));\n}\nfunction U(t, e = [], { singleton: n } = { singleton: !0 }) {\n  return {\n    constructor: t,\n    dependencies: e,\n    id: po(),\n    singleton: n\n  };\n}\nconst po = () => Symbol();\nfunction ho(t) {\n  const e = /* @__PURE__ */ new Map(), n = ({ constructor: o, dependencies: r, id: s, singleton: i }) => {\n    if (i && e.has(s))\n      return e.get(s);\n    const l = o(r.map((c) => n(c)));\n    return i && e.set(s, l), l;\n  };\n  return n(t);\n}\nfunction rt(...t) {\n  const e = $(), n = new Array(t.length);\n  let o = 0;\n  const r = Math.pow(2, t.length) - 1;\n  return t.forEach((s, i) => {\n    const l = Math.pow(2, i);\n    K(s, (c) => {\n      n[i] = c, o = o | l, o === r && W(e, n);\n    });\n  }), function(s, i) {\n    switch (s) {\n      case qt: {\n        We(e);\n        return;\n      }\n      case zt:\n        return o === r && i(n), K(e, i);\n    }\n  };\n}\nfunction A(t, e = Bn) {\n  return x(t, Y(e));\n}\nfunction an(...t) {\n  return function(e, n) {\n    switch (e) {\n      case qt:\n        return;\n      case zt:\n        return uo(...t.map((o) => K(o, n)));\n    }\n  };\n}\nvar ht = /* @__PURE__ */ ((t) => (t[t.DEBUG = 0] = \"DEBUG\", t[t.INFO = 1] = \"INFO\", t[t.WARN = 2] = \"WARN\", t[t.ERROR = 3] = \"ERROR\", t))(ht || {});\nconst go = {\n  0: \"debug\",\n  3: \"error\",\n  1: \"log\",\n  2: \"warn\"\n}, Io = () => typeof globalThis > \"u\" ? window : globalThis, Vt = U(\n  () => {\n    const t = y(\n      3\n      /* ERROR */\n    );\n    return {\n      log: y((n, o, r = 1) => {\n        var i;\n        const s = (i = Io().VIRTUOSO_LOG_LEVEL) != null ? i : lt(t);\n        r >= s && console[go[r]](\n          \"%creact-virtuoso: %c%s %o\",\n          \"color: #0253b3; font-weight: bold\",\n          \"color: initial\",\n          n,\n          o\n        );\n      }),\n      logLevel: t\n    };\n  },\n  [],\n  { singleton: !0 }\n);\nfunction Ht(t, e, n) {\n  return _e(t, e, n).callbackRef;\n}\nfunction _e(t, e, n) {\n  const o = react__WEBPACK_IMPORTED_MODULE_1__.useRef(null);\n  let r = (s) => {\n  };\n  if (typeof ResizeObserver < \"u\") {\n    const s = react__WEBPACK_IMPORTED_MODULE_1__.useMemo(() => new ResizeObserver((i) => {\n      const l = () => {\n        const c = i[0].target;\n        c.offsetParent !== null && t(c);\n      };\n      n ? l() : requestAnimationFrame(l);\n    }), [t]);\n    r = (i) => {\n      i && e ? (s.observe(i), o.current = i) : (o.current && s.unobserve(o.current), o.current = null);\n    };\n  }\n  return { callbackRef: r, ref: o };\n}\nfunction On(t, e, n, o, r, s, i, l, c) {\n  const u = react__WEBPACK_IMPORTED_MODULE_1__.useCallback(\n    (f) => {\n      const S = So(f.children, e, l ? \"offsetWidth\" : \"offsetHeight\", r);\n      let p = f.parentElement;\n      for (; !p.dataset.virtuosoScroller; )\n        p = p.parentElement;\n      const m = p.lastElementChild.dataset.viewportType === \"window\";\n      let w;\n      m && (w = p.ownerDocument.defaultView);\n      const I = i ? l ? i.scrollLeft : i.scrollTop : m ? l ? w.scrollX || w.document.documentElement.scrollLeft : w.scrollY || w.document.documentElement.scrollTop : l ? p.scrollLeft : p.scrollTop, C = i ? l ? i.scrollWidth : i.scrollHeight : m ? l ? w.document.documentElement.scrollWidth : w.document.documentElement.scrollHeight : l ? p.scrollWidth : p.scrollHeight, g = i ? l ? i.offsetWidth : i.offsetHeight : m ? l ? w.innerWidth : w.innerHeight : l ? p.offsetWidth : p.offsetHeight;\n      o({\n        scrollHeight: C,\n        scrollTop: Math.max(I, 0),\n        viewportHeight: g\n      }), s == null || s(\n        l ? dn(\"column-gap\", getComputedStyle(f).columnGap, r) : dn(\"row-gap\", getComputedStyle(f).rowGap, r)\n      ), S !== null && t(S);\n    },\n    [t, e, r, s, i, o]\n  );\n  return _e(u, n, c);\n}\nfunction So(t, e, n, o) {\n  const r = t.length;\n  if (r === 0)\n    return null;\n  const s = [];\n  for (let i = 0; i < r; i++) {\n    const l = t.item(i);\n    if (l.dataset.index === void 0)\n      continue;\n    const c = parseInt(l.dataset.index), u = parseFloat(l.dataset.knownSize), f = e(l, n);\n    if (f === 0 && o(\"Zero-sized element, this should not happen\", { child: l }, ht.ERROR), f === u)\n      continue;\n    const S = s[s.length - 1];\n    s.length === 0 || S.size !== f || S.endIndex !== c - 1 ? s.push({ endIndex: c, size: f, startIndex: c }) : s[s.length - 1].endIndex++;\n  }\n  return s;\n}\nfunction dn(t, e, n) {\n  return e !== \"normal\" && !(e != null && e.endsWith(\"px\")) && n(`${t} was not resolved to pixel value correctly`, e, ht.WARN), e === \"normal\" ? 0 : parseInt(e != null ? e : \"0\", 10);\n}\nfunction Ge(t, e, n) {\n  const o = react__WEBPACK_IMPORTED_MODULE_1__.useRef(null), r = react__WEBPACK_IMPORTED_MODULE_1__.useCallback(\n    (c) => {\n      if (!(c != null && c.offsetParent))\n        return;\n      const u = c.getBoundingClientRect(), f = u.width;\n      let S, p;\n      if (e) {\n        const m = e.getBoundingClientRect(), w = u.top - m.top;\n        p = m.height - Math.max(0, w), S = w + e.scrollTop;\n      } else {\n        const m = i.current.ownerDocument.defaultView;\n        p = m.innerHeight - Math.max(0, u.top), S = u.top + m.scrollY;\n      }\n      o.current = {\n        offsetTop: S,\n        visibleHeight: p,\n        visibleWidth: f\n      }, t(o.current);\n    },\n    [t, e]\n  ), { callbackRef: s, ref: i } = _e(r, !0, n), l = react__WEBPACK_IMPORTED_MODULE_1__.useCallback(() => {\n    r(i.current);\n  }, [r, i]);\n  return react__WEBPACK_IMPORTED_MODULE_1__.useEffect(() => {\n    var c;\n    if (e) {\n      e.addEventListener(\"scroll\", l);\n      const u = new ResizeObserver(() => {\n        requestAnimationFrame(l);\n      });\n      return u.observe(e), () => {\n        e.removeEventListener(\"scroll\", l), u.unobserve(e);\n      };\n    } else {\n      const u = (c = i.current) == null ? void 0 : c.ownerDocument.defaultView;\n      return u == null || u.addEventListener(\"scroll\", l), u == null || u.addEventListener(\"resize\", l), () => {\n        u == null || u.removeEventListener(\"scroll\", l), u == null || u.removeEventListener(\"resize\", l);\n      };\n    }\n  }, [l, e]), s;\n}\nconst at = U(\n  () => {\n    const t = $(), e = $(), n = y(0), o = $(), r = y(0), s = $(), i = $(), l = y(0), c = y(0), u = y(0), f = y(0), S = $(), p = $(), m = y(!1), w = y(!1), I = y(!1);\n    return F(\n      x(\n        t,\n        E(({ scrollTop: C }) => C)\n      ),\n      e\n    ), F(\n      x(\n        t,\n        E(({ scrollHeight: C }) => C)\n      ),\n      i\n    ), F(e, r), {\n      deviation: n,\n      fixedFooterHeight: u,\n      fixedHeaderHeight: c,\n      footerHeight: f,\n      headerHeight: l,\n      horizontalDirection: w,\n      scrollBy: p,\n      // input\n      scrollContainerState: t,\n      scrollHeight: i,\n      scrollingInProgress: m,\n      // signals\n      scrollTo: S,\n      scrollTop: e,\n      skipAnimationFrameInResizeObserver: I,\n      smoothScrollTargetReached: o,\n      // state\n      statefulScrollTop: r,\n      viewportHeight: s\n    };\n  },\n  [],\n  { singleton: !0 }\n), oe = { lvl: 0 };\nfunction Fn(t, e) {\n  const n = t.length;\n  if (n === 0)\n    return [];\n  let { index: o, value: r } = e(t[0]);\n  const s = [];\n  for (let i = 1; i < n; i++) {\n    const { index: l, value: c } = e(t[i]);\n    s.push({ end: l - 1, start: o, value: r }), o = l, r = c;\n  }\n  return s.push({ end: 1 / 0, start: o, value: r }), s;\n}\nfunction j(t) {\n  return t === oe;\n}\nfunction re(t, e) {\n  if (!j(t))\n    return e === t.k ? t.v : e < t.k ? re(t.l, e) : re(t.r, e);\n}\nfunction Ct(t, e, n = \"k\") {\n  if (j(t))\n    return [-1 / 0, void 0];\n  if (Number(t[n]) === e)\n    return [t.k, t.v];\n  if (Number(t[n]) < e) {\n    const o = Ct(t.r, e, n);\n    return o[0] === -1 / 0 ? [t.k, t.v] : o;\n  }\n  return Ct(t.l, e, n);\n}\nfunction mt(t, e, n) {\n  return j(t) ? Vn(e, n, 1) : e === t.k ? ot(t, { k: e, v: n }) : e < t.k ? fn(ot(t, { l: mt(t.l, e, n) })) : fn(ot(t, { r: mt(t.r, e, n) }));\n}\nfunction Ut() {\n  return oe;\n}\nfunction ve(t, e, n) {\n  if (j(t))\n    return [];\n  const o = Ct(t, e)[0];\n  return xo(ze(t, o, n));\n}\nfunction Le(t, e) {\n  if (j(t)) return oe;\n  const { k: n, l: o, r } = t;\n  if (e === n) {\n    if (j(o))\n      return r;\n    if (j(r))\n      return o;\n    {\n      const [s, i] = zn(o);\n      return ge(ot(t, { k: s, l: Ln(o), v: i }));\n    }\n  } else return e < n ? ge(ot(t, { l: Le(o, e) })) : ge(ot(t, { r: Le(r, e) }));\n}\nfunction _t(t) {\n  return j(t) ? [] : [..._t(t.l), { k: t.k, v: t.v }, ..._t(t.r)];\n}\nfunction ze(t, e, n) {\n  if (j(t))\n    return [];\n  const { k: o, l: r, r: s, v: i } = t;\n  let l = [];\n  return o > e && (l = l.concat(ze(r, e, n))), o >= e && o <= n && l.push({ k: o, v: i }), o <= n && (l = l.concat(ze(s, e, n))), l;\n}\nfunction ge(t) {\n  const { l: e, lvl: n, r: o } = t;\n  if (o.lvl >= n - 1 && e.lvl >= n - 1)\n    return t;\n  if (n > o.lvl + 1) {\n    if (Ee(e))\n      return Pn(ot(t, { lvl: n - 1 }));\n    if (!j(e) && !j(e.r))\n      return ot(e.r, {\n        l: ot(e, { r: e.r.l }),\n        lvl: n,\n        r: ot(t, {\n          l: e.r.r,\n          lvl: n - 1\n        })\n      });\n    throw new Error(\"Unexpected empty nodes\");\n  } else {\n    if (Ee(t))\n      return Ve(ot(t, { lvl: n - 1 }));\n    if (!j(o) && !j(o.l)) {\n      const r = o.l, s = Ee(r) ? o.lvl - 1 : o.lvl;\n      return ot(r, {\n        l: ot(t, {\n          lvl: n - 1,\n          r: r.l\n        }),\n        lvl: r.lvl + 1,\n        r: Ve(ot(o, { l: r.r, lvl: s }))\n      });\n    } else\n      throw new Error(\"Unexpected empty nodes\");\n  }\n}\nfunction ot(t, e) {\n  return Vn(\n    e.k !== void 0 ? e.k : t.k,\n    e.v !== void 0 ? e.v : t.v,\n    e.lvl !== void 0 ? e.lvl : t.lvl,\n    e.l !== void 0 ? e.l : t.l,\n    e.r !== void 0 ? e.r : t.r\n  );\n}\nfunction Ln(t) {\n  return j(t.r) ? t.l : ge(ot(t, { r: Ln(t.r) }));\n}\nfunction Ee(t) {\n  return j(t) || t.lvl > t.r.lvl;\n}\nfunction zn(t) {\n  return j(t.r) ? [t.k, t.v] : zn(t.r);\n}\nfunction Vn(t, e, n, o = oe, r = oe) {\n  return { k: t, l: o, lvl: n, r, v: e };\n}\nfunction fn(t) {\n  return Ve(Pn(t));\n}\nfunction Pn(t) {\n  const { l: e } = t;\n  return !j(e) && e.lvl === t.lvl ? ot(e, { r: ot(t, { l: e.r }) }) : t;\n}\nfunction Ve(t) {\n  const { lvl: e, r: n } = t;\n  return !j(n) && !j(n.r) && n.lvl === e && n.r.lvl === e ? ot(n, { l: ot(t, { r: n.l }), lvl: e + 1 }) : t;\n}\nfunction xo(t) {\n  return Fn(t, ({ k: e, v: n }) => ({ index: e, value: n }));\n}\nfunction An(t, e) {\n  return !!(t && t.startIndex === e.startIndex && t.endIndex === e.endIndex);\n}\nfunction se(t, e) {\n  return !!(t && t[0] === e[0] && t[1] === e[1]);\n}\nconst Ne = U(\n  () => ({ recalcInProgress: y(!1) }),\n  [],\n  { singleton: !0 }\n);\nfunction Mn(t, e, n) {\n  return t[Se(t, e, n)];\n}\nfunction Se(t, e, n, o = 0) {\n  let r = t.length - 1;\n  for (; o <= r; ) {\n    const s = Math.floor((o + r) / 2), i = t[s], l = n(i, e);\n    if (l === 0)\n      return s;\n    if (l === -1) {\n      if (r - o < 2)\n        return s - 1;\n      r = s - 1;\n    } else {\n      if (r === o)\n        return s;\n      o = s + 1;\n    }\n  }\n  throw new Error(`Failed binary finding record in array - ${t.join(\",\")}, searched for ${e}`);\n}\nfunction To(t, e, n, o) {\n  const r = Se(t, e, o), s = Se(t, n, o, r);\n  return t.slice(r, s + 1);\n}\nfunction wt(t, e) {\n  return Math.round(t.getBoundingClientRect()[e]);\n}\nfunction be(t) {\n  return !j(t.groupOffsetTree);\n}\nfunction De({ index: t }, e) {\n  return e === t ? 0 : e < t ? -1 : 1;\n}\nfunction Co() {\n  return {\n    groupIndices: [],\n    groupOffsetTree: Ut(),\n    lastIndex: 0,\n    lastOffset: 0,\n    lastSize: 0,\n    offsetTree: [],\n    sizeTree: Ut()\n  };\n}\nfunction wo(t, e) {\n  let n = j(t) ? 0 : 1 / 0;\n  for (const o of e) {\n    const { endIndex: r, size: s, startIndex: i } = o;\n    if (n = Math.min(n, i), j(t)) {\n      t = mt(t, 0, s);\n      continue;\n    }\n    const l = ve(t, i - 1, r + 1);\n    if (l.some(ko(o)))\n      continue;\n    let c = !1, u = !1;\n    for (const { end: f, start: S, value: p } of l)\n      c ? (r >= S || s === p) && (t = Le(t, S)) : (u = p !== s, c = !0), f > r && r >= S && p !== s && (t = mt(t, r + 1, p));\n    u && (t = mt(t, i, s));\n  }\n  return [t, n];\n}\nfunction yo(t) {\n  return typeof t.groupIndex < \"u\";\n}\nfunction vo({ offset: t }, e) {\n  return e === t ? 0 : e < t ? -1 : 1;\n}\nfunction ie(t, e, n) {\n  if (e.length === 0)\n    return 0;\n  const { index: o, offset: r, size: s } = Mn(e, t, De), i = t - o, l = s * i + (i - 1) * n + r;\n  return l > 0 ? l + n : l;\n}\nfunction Wn(t, e) {\n  if (!be(e))\n    return t;\n  let n = 0;\n  for (; e.groupIndices[n] <= t + n; )\n    n++;\n  return t + n;\n}\nfunction _n(t, e, n) {\n  if (yo(t))\n    return e.groupIndices[t.groupIndex] + 1;\n  {\n    const o = t.index === \"LAST\" ? n : t.index;\n    let r = Wn(o, e);\n    return r = Math.max(0, r, Math.min(n, r)), r;\n  }\n}\nfunction bo(t, e, n, o = 0) {\n  return o > 0 && (e = Math.max(e, Mn(t, o, De).offset)), Fn(To(t, e, n, vo), Eo);\n}\nfunction Ro(t, [e, n, o, r]) {\n  e.length > 0 && o(\"received item sizes\", e, ht.DEBUG);\n  const s = t.sizeTree;\n  let i = s, l = 0;\n  if (n.length > 0 && j(s) && e.length === 2) {\n    const p = e[0].size, m = e[1].size;\n    i = n.reduce((w, I) => mt(mt(w, I, p), I + 1, m), i);\n  } else\n    [i, l] = wo(i, e);\n  if (i === s)\n    return t;\n  const { lastIndex: c, lastOffset: u, lastSize: f, offsetTree: S } = Pe(t.offsetTree, l, i, r);\n  return {\n    groupIndices: n,\n    groupOffsetTree: n.reduce((p, m) => mt(p, m, ie(m, S, r)), Ut()),\n    lastIndex: c,\n    lastOffset: u,\n    lastSize: f,\n    offsetTree: S,\n    sizeTree: i\n  };\n}\nfunction Ho(t) {\n  return _t(t).map(({ k: e, v: n }, o, r) => {\n    const s = r[o + 1];\n    return { endIndex: s ? s.k - 1 : 1 / 0, size: n, startIndex: e };\n  });\n}\nfunction mn(t, e) {\n  let n = 0, o = 0;\n  for (; n < t; )\n    n += e[o + 1] - e[o] - 1, o++;\n  return o - (n === t ? 0 : 1);\n}\nfunction Pe(t, e, n, o) {\n  let r = t, s = 0, i = 0, l = 0, c = 0;\n  if (e !== 0) {\n    c = Se(r, e - 1, De), l = r[c].offset;\n    const f = Ct(n, e - 1);\n    s = f[0], i = f[1], r.length && r[c].size === Ct(n, e)[1] && (c -= 1), r = r.slice(0, c + 1);\n  } else\n    r = [];\n  for (const { start: u, value: f } of ve(n, e, 1 / 0)) {\n    const S = u - s, p = S * i + l + S * o;\n    r.push({\n      index: u,\n      offset: p,\n      size: f\n    }), s = u, l = p, i = f;\n  }\n  return {\n    lastIndex: s,\n    lastOffset: l,\n    lastSize: i,\n    offsetTree: r\n  };\n}\nfunction Eo(t) {\n  return { index: t.index, value: t };\n}\nfunction ko(t) {\n  const { endIndex: e, size: n, startIndex: o } = t;\n  return (r) => r.start === o && (r.end === e || r.end === 1 / 0) && r.value === n;\n}\nconst Bo = {\n  offsetHeight: \"height\",\n  offsetWidth: \"width\"\n}, Et = U(\n  ([{ log: t }, { recalcInProgress: e }]) => {\n    const n = $(), o = $(), r = ct(o, 0), s = $(), i = $(), l = y(0), c = y([]), u = y(void 0), f = y(void 0), S = y((h, d) => wt(h, Bo[d])), p = y(void 0), m = y(0), w = Co(), I = ct(\n      x(n, G(c, t, m), bt(Ro, w), Y()),\n      w\n    ), C = ct(\n      x(\n        c,\n        Y(),\n        bt((h, d) => ({ current: d, prev: h.current }), {\n          current: [],\n          prev: []\n        }),\n        E(({ prev: h }) => h)\n      ),\n      []\n    );\n    F(\n      x(\n        c,\n        P((h) => h.length > 0),\n        G(I, m),\n        E(([h, d, R]) => {\n          const B = h.reduce((O, L, V) => mt(O, L, ie(L, d.offsetTree, R) || V), Ut());\n          return {\n            ...d,\n            groupIndices: h,\n            groupOffsetTree: B\n          };\n        })\n      ),\n      I\n    ), F(\n      x(\n        o,\n        G(I),\n        P(([h, { lastIndex: d }]) => h < d),\n        E(([h, { lastIndex: d, lastSize: R }]) => [\n          {\n            endIndex: d,\n            size: R,\n            startIndex: h\n          }\n        ])\n      ),\n      n\n    ), F(u, f);\n    const g = ct(\n      x(\n        u,\n        E((h) => h === void 0)\n      ),\n      !0\n    );\n    F(\n      x(\n        f,\n        P((h) => h !== void 0 && j(lt(I).sizeTree)),\n        E((h) => [{ endIndex: 0, size: h, startIndex: 0 }])\n      ),\n      n\n    );\n    const a = pt(\n      x(\n        n,\n        G(I),\n        bt(\n          ({ sizes: h }, [d, R]) => ({\n            changed: R !== h,\n            sizes: R\n          }),\n          { changed: !1, sizes: w }\n        ),\n        E((h) => h.changed)\n      )\n    );\n    K(\n      x(\n        l,\n        bt(\n          (h, d) => ({ diff: h.prev - d, prev: d }),\n          { diff: 0, prev: 0 }\n        ),\n        E((h) => h.diff)\n      ),\n      (h) => {\n        const { groupIndices: d } = lt(I);\n        if (h > 0)\n          W(e, !0), W(s, h + mn(h, d));\n        else if (h < 0) {\n          const R = lt(C);\n          R.length > 0 && (h -= mn(-h, R)), W(i, h);\n        }\n      }\n    ), K(x(l, G(t)), ([h, d]) => {\n      h < 0 && d(\n        \"`firstItemIndex` prop should not be set to less than zero. If you don't know the total count, just use a very high value\",\n        { firstItemIndex: l },\n        ht.ERROR\n      );\n    });\n    const T = pt(s);\n    F(\n      x(\n        s,\n        G(I),\n        E(([h, d]) => {\n          const R = d.groupIndices.length > 0, B = [], O = d.lastSize;\n          if (R) {\n            const L = re(d.sizeTree, 0);\n            let V = 0, D = 0;\n            for (; V < h; ) {\n              const k = d.groupIndices[D], q = d.groupIndices.length === D + 1 ? 1 / 0 : d.groupIndices[D + 1] - k - 1;\n              B.push({\n                endIndex: k,\n                size: L,\n                startIndex: k\n              }), B.push({\n                endIndex: k + 1 + q - 1,\n                size: O,\n                startIndex: k + 1\n              }), D++, V += q + 1;\n            }\n            const J = _t(d.sizeTree);\n            return V !== h && J.shift(), J.reduce(\n              (k, { k: q, v: st }) => {\n                let dt = k.ranges;\n                return k.prevSize !== 0 && (dt = [\n                  ...k.ranges,\n                  {\n                    endIndex: q + h - 1,\n                    size: k.prevSize,\n                    startIndex: k.prevIndex\n                  }\n                ]), {\n                  prevIndex: q + h,\n                  prevSize: st,\n                  ranges: dt\n                };\n              },\n              {\n                prevIndex: h,\n                prevSize: 0,\n                ranges: B\n              }\n            ).ranges;\n          }\n          return _t(d.sizeTree).reduce(\n            (L, { k: V, v: D }) => ({\n              prevIndex: V + h,\n              prevSize: D,\n              ranges: [...L.ranges, { endIndex: V + h - 1, size: L.prevSize, startIndex: L.prevIndex }]\n            }),\n            {\n              prevIndex: 0,\n              prevSize: O,\n              ranges: []\n            }\n          ).ranges;\n        })\n      ),\n      n\n    );\n    const b = pt(\n      x(\n        i,\n        G(I, m),\n        E(([h, { offsetTree: d }, R]) => {\n          const B = -h;\n          return ie(B, d, R);\n        })\n      )\n    );\n    return F(\n      x(\n        i,\n        G(I, m),\n        E(([h, d, R]) => {\n          if (d.groupIndices.length > 0) {\n            if (j(d.sizeTree))\n              return d;\n            let O = Ut();\n            const L = lt(C);\n            let V = 0, D = 0, J = 0;\n            for (; V < -h; ) {\n              J = L[D];\n              const k = L[D + 1] - J - 1;\n              D++, V += k + 1;\n            }\n            if (O = _t(d.sizeTree).reduce((k, { k: q, v: st }) => mt(k, Math.max(0, q + h), st), O), V !== -h) {\n              const k = re(d.sizeTree, J);\n              O = mt(O, 0, k);\n              const q = Ct(d.sizeTree, -h + 1)[1];\n              O = mt(O, 1, q);\n            }\n            return {\n              ...d,\n              sizeTree: O,\n              ...Pe(d.offsetTree, 0, O, R)\n            };\n          } else {\n            const O = _t(d.sizeTree).reduce((L, { k: V, v: D }) => mt(L, Math.max(0, V + h), D), Ut());\n            return {\n              ...d,\n              sizeTree: O,\n              ...Pe(d.offsetTree, 0, O, R)\n            };\n          }\n        })\n      ),\n      I\n    ), {\n      beforeUnshiftWith: T,\n      // input\n      data: p,\n      defaultItemSize: f,\n      firstItemIndex: l,\n      fixedItemSize: u,\n      gap: m,\n      groupIndices: c,\n      itemSize: S,\n      listRefresh: a,\n      shiftWith: i,\n      shiftWithOffset: b,\n      sizeRanges: n,\n      // output\n      sizes: I,\n      statefulTotalCount: r,\n      totalCount: o,\n      trackItemSizes: g,\n      unshiftWith: s\n    };\n  },\n  X(Vt, Ne),\n  { singleton: !0 }\n);\nfunction Oo(t) {\n  return t.reduce(\n    (e, n) => (e.groupIndices.push(e.totalCount), e.totalCount += n + 1, e),\n    {\n      groupIndices: [],\n      totalCount: 0\n    }\n  );\n}\nconst Gn = U(\n  ([{ groupIndices: t, sizes: e, totalCount: n }, { headerHeight: o, scrollTop: r }]) => {\n    const s = $(), i = $(), l = pt(x(s, E(Oo)));\n    return F(\n      x(\n        l,\n        E((c) => c.totalCount)\n      ),\n      n\n    ), F(\n      x(\n        l,\n        E((c) => c.groupIndices)\n      ),\n      t\n    ), F(\n      x(\n        rt(r, e, o),\n        P(([c, u]) => be(u)),\n        E(([c, u, f]) => Ct(u.groupOffsetTree, Math.max(c - f, 0), \"v\")[0]),\n        Y(),\n        E((c) => [c])\n      ),\n      i\n    ), { groupCounts: s, topItemsIndexes: i };\n  },\n  X(Et, at)\n), Pt = U(\n  ([{ log: t }]) => {\n    const e = y(!1), n = pt(\n      x(\n        e,\n        P((o) => o),\n        Y()\n      )\n    );\n    return K(e, (o) => {\n      o && lt(t)(\"props updated\", {}, ht.DEBUG);\n    }), { didMount: n, propsReady: e };\n  },\n  X(Vt),\n  { singleton: !0 }\n), Fo = typeof document < \"u\" && \"scrollBehavior\" in document.documentElement.style;\nfunction Nn(t) {\n  const e = typeof t == \"number\" ? { index: t } : t;\n  return e.align || (e.align = \"start\"), (!e.behavior || !Fo) && (e.behavior = \"auto\"), e.offset || (e.offset = 0), e;\n}\nconst ce = U(\n  ([\n    { gap: t, listRefresh: e, sizes: n, totalCount: o },\n    {\n      fixedFooterHeight: r,\n      fixedHeaderHeight: s,\n      footerHeight: i,\n      headerHeight: l,\n      scrollingInProgress: c,\n      scrollTo: u,\n      smoothScrollTargetReached: f,\n      viewportHeight: S\n    },\n    { log: p }\n  ]) => {\n    const m = $(), w = $(), I = y(0);\n    let C = null, g = null, a = null;\n    function T() {\n      C && (C(), C = null), a && (a(), a = null), g && (clearTimeout(g), g = null), W(c, !1);\n    }\n    return F(\n      x(\n        m,\n        G(n, S, o, I, l, i, p),\n        G(t, s, r),\n        E(\n          ([\n            [b, h, d, R, B, O, L, V],\n            D,\n            J,\n            nt\n          ]) => {\n            const k = Nn(b), { align: q, behavior: st, offset: dt } = k, St = R - 1, ft = _n(k, h, St);\n            let ut = ie(ft, h.offsetTree, D) + O;\n            q === \"end\" ? (ut += J + Ct(h.sizeTree, ft)[1] - d + nt, ft === St && (ut += L)) : q === \"center\" ? ut += (J + Ct(h.sizeTree, ft)[1] - d + nt) / 2 : ut -= B, dt && (ut += dt);\n            const At = (xt) => {\n              T(), xt ? (V(\"retrying to scroll to\", { location: b }, ht.DEBUG), W(m, b)) : (W(w, !0), V(\"list did not change, scroll successful\", {}, ht.DEBUG));\n            };\n            if (T(), st === \"smooth\") {\n              let xt = !1;\n              a = K(e, (Xt) => {\n                xt = xt || Xt;\n              }), C = Rt(f, () => {\n                At(xt);\n              });\n            } else\n              C = Rt(x(e, Lo(150)), At);\n            return g = setTimeout(() => {\n              T();\n            }, 1200), W(c, !0), V(\"scrolling from index to\", { behavior: st, index: ft, top: ut }, ht.DEBUG), { behavior: st, top: ut };\n          }\n        )\n      ),\n      u\n    ), {\n      scrollTargetReached: w,\n      scrollToIndex: m,\n      topListHeight: I\n    };\n  },\n  X(Et, at, Vt),\n  { singleton: !0 }\n);\nfunction Lo(t) {\n  return (e) => {\n    const n = setTimeout(() => {\n      e(!1);\n    }, t);\n    return (o) => {\n      o && (e(!0), clearTimeout(n));\n    };\n  };\n}\nfunction $e(t, e) {\n  t == 0 ? e() : requestAnimationFrame(() => {\n    $e(t - 1, e);\n  });\n}\nfunction Ue(t, e) {\n  const n = e - 1;\n  return typeof t == \"number\" ? t : t.index === \"LAST\" ? n : t.index;\n}\nconst ue = U(\n  ([{ defaultItemSize: t, listRefresh: e, sizes: n }, { scrollTop: o }, { scrollTargetReached: r, scrollToIndex: s }, { didMount: i }]) => {\n    const l = y(!0), c = y(0), u = y(!0);\n    return F(\n      x(\n        i,\n        G(c),\n        P(([f, S]) => !!S),\n        vt(!1)\n      ),\n      l\n    ), F(\n      x(\n        i,\n        G(c),\n        P(([f, S]) => !!S),\n        vt(!1)\n      ),\n      u\n    ), K(\n      x(\n        rt(e, i),\n        G(l, n, t, u),\n        P(([[, f], S, { sizeTree: p }, m, w]) => f && (!j(p) || Me(m)) && !S && !w),\n        G(c)\n      ),\n      ([, f]) => {\n        Rt(r, () => {\n          W(u, !0);\n        }), $e(4, () => {\n          Rt(o, () => {\n            W(l, !0);\n          }), W(s, f);\n        });\n      }\n    ), {\n      initialItemFinalLocationReached: u,\n      initialTopMostItemIndex: c,\n      scrolledToInitialItem: l\n    };\n  },\n  X(Et, at, ce, Pt),\n  { singleton: !0 }\n);\nfunction Dn(t, e) {\n  return Math.abs(t - e) < 1.01;\n}\nconst le = \"up\", te = \"down\", zo = \"none\", Vo = {\n  atBottom: !1,\n  notAtBottomBecause: \"NOT_SHOWING_LAST_ITEM\",\n  state: {\n    offsetBottom: 0,\n    scrollHeight: 0,\n    scrollTop: 0,\n    viewportHeight: 0\n  }\n}, Po = 0, ae = U(([{ footerHeight: t, headerHeight: e, scrollBy: n, scrollContainerState: o, scrollTop: r, viewportHeight: s }]) => {\n  const i = y(!1), l = y(!0), c = $(), u = $(), f = y(4), S = y(Po), p = ct(\n    x(\n      an(x(A(r), jt(1), vt(!0)), x(A(r), jt(1), vt(!1), un(100))),\n      Y()\n    ),\n    !1\n  ), m = ct(\n    x(an(x(n, vt(!0)), x(n, vt(!1), un(200))), Y()),\n    !1\n  );\n  F(\n    x(\n      rt(A(r), A(S)),\n      E(([a, T]) => a <= T),\n      Y()\n    ),\n    l\n  ), F(x(l, Lt(50)), u);\n  const w = pt(\n    x(\n      rt(o, A(s), A(e), A(t), A(f)),\n      bt((a, [{ scrollHeight: T, scrollTop: b }, h, d, R, B]) => {\n        const O = b + h - T > -B, L = {\n          scrollHeight: T,\n          scrollTop: b,\n          viewportHeight: h\n        };\n        if (O) {\n          let D, J;\n          return b > a.state.scrollTop ? (D = \"SCROLLED_DOWN\", J = a.state.scrollTop - b) : (D = \"SIZE_DECREASED\", J = a.state.scrollTop - b || a.scrollTopDelta), {\n            atBottom: !0,\n            atBottomBecause: D,\n            scrollTopDelta: J,\n            state: L\n          };\n        }\n        let V;\n        return L.scrollHeight > a.state.scrollHeight ? V = \"SIZE_INCREASED\" : h < a.state.viewportHeight ? V = \"VIEWPORT_HEIGHT_DECREASING\" : b < a.state.scrollTop ? V = \"SCROLLING_UPWARDS\" : V = \"NOT_FULLY_SCROLLED_TO_LAST_ITEM_BOTTOM\", {\n          atBottom: !1,\n          notAtBottomBecause: V,\n          state: L\n        };\n      }, Vo),\n      Y((a, T) => a && a.atBottom === T.atBottom)\n    )\n  ), I = ct(\n    x(\n      o,\n      bt(\n        (a, { scrollHeight: T, scrollTop: b, viewportHeight: h }) => {\n          if (Dn(a.scrollHeight, T))\n            return {\n              changed: !1,\n              jump: 0,\n              scrollHeight: T,\n              scrollTop: b\n            };\n          {\n            const d = T - (b + h) < 1;\n            return a.scrollTop !== b && d ? {\n              changed: !0,\n              jump: a.scrollTop - b,\n              scrollHeight: T,\n              scrollTop: b\n            } : {\n              changed: !0,\n              jump: 0,\n              scrollHeight: T,\n              scrollTop: b\n            };\n          }\n        },\n        { changed: !1, jump: 0, scrollHeight: 0, scrollTop: 0 }\n      ),\n      P((a) => a.changed),\n      E((a) => a.jump)\n    ),\n    0\n  );\n  F(\n    x(\n      w,\n      E((a) => a.atBottom)\n    ),\n    i\n  ), F(x(i, Lt(50)), c);\n  const C = y(te);\n  F(\n    x(\n      o,\n      E(({ scrollTop: a }) => a),\n      Y(),\n      bt(\n        (a, T) => lt(m) ? { direction: a.direction, prevScrollTop: T } : { direction: T < a.prevScrollTop ? le : te, prevScrollTop: T },\n        { direction: te, prevScrollTop: 0 }\n      ),\n      E((a) => a.direction)\n    ),\n    C\n  ), F(x(o, Lt(50), vt(zo)), C);\n  const g = y(0);\n  return F(\n    x(\n      p,\n      P((a) => !a),\n      vt(0)\n    ),\n    g\n  ), F(\n    x(\n      r,\n      Lt(100),\n      G(p),\n      P(([a, T]) => !!T),\n      bt(([a, T], [b]) => [T, b], [0, 0]),\n      E(([a, T]) => T - a)\n    ),\n    g\n  ), {\n    atBottomState: w,\n    atBottomStateChange: c,\n    atBottomThreshold: f,\n    atTopStateChange: u,\n    atTopThreshold: S,\n    isAtBottom: i,\n    isAtTop: l,\n    isScrolling: p,\n    lastJumpDueToItemResize: I,\n    scrollDirection: C,\n    scrollVelocity: g\n  };\n}, X(at)), xe = \"top\", Te = \"bottom\", pn = \"none\";\nfunction hn(t, e, n) {\n  return typeof t == \"number\" ? n === le && e === xe || n === te && e === Te ? t : 0 : n === le ? e === xe ? t.main : t.reverse : e === Te ? t.main : t.reverse;\n}\nfunction gn(t, e) {\n  var n;\n  return typeof t == \"number\" ? t : (n = t[e]) != null ? n : 0;\n}\nconst Ke = U(\n  ([{ deviation: t, fixedHeaderHeight: e, headerHeight: n, scrollTop: o, viewportHeight: r }]) => {\n    const s = $(), i = y(0), l = y(0), c = y(0), u = ct(\n      x(\n        rt(\n          A(o),\n          A(r),\n          A(n),\n          A(s, se),\n          A(c),\n          A(i),\n          A(e),\n          A(t),\n          A(l)\n        ),\n        E(\n          ([\n            f,\n            S,\n            p,\n            [m, w],\n            I,\n            C,\n            g,\n            a,\n            T\n          ]) => {\n            const b = f - a, h = C + g, d = Math.max(p - b, 0);\n            let R = pn;\n            const B = gn(T, xe), O = gn(T, Te);\n            return m -= a, m += p + g, w += p + g, w -= a, m > f + h - B && (R = le), w < f - d + S + O && (R = te), R !== pn ? [\n              Math.max(b - p - hn(I, xe, R) - B, 0),\n              b - d - g + S + hn(I, Te, R) + O\n            ] : null;\n          }\n        ),\n        P((f) => f != null),\n        Y(se)\n      ),\n      [0, 0]\n    );\n    return {\n      increaseViewportBy: l,\n      // input\n      listBoundary: s,\n      overscan: c,\n      topListHeight: i,\n      // output\n      visibleRange: u\n    };\n  },\n  X(at),\n  { singleton: !0 }\n);\nfunction Ao(t, e, n) {\n  if (be(e)) {\n    const o = Wn(t, e);\n    return [\n      { index: Ct(e.groupOffsetTree, o)[0], offset: 0, size: 0 },\n      { data: n == null ? void 0 : n[0], index: o, offset: 0, size: 0 }\n    ];\n  }\n  return [{ data: n == null ? void 0 : n[0], index: t, offset: 0, size: 0 }];\n}\nconst ke = {\n  bottom: 0,\n  firstItemIndex: 0,\n  items: [],\n  offsetBottom: 0,\n  offsetTop: 0,\n  top: 0,\n  topItems: [],\n  topListHeight: 0,\n  totalCount: 0\n};\nfunction Ie(t, e, n, o, r, s) {\n  const { lastIndex: i, lastOffset: l, lastSize: c } = r;\n  let u = 0, f = 0;\n  if (t.length > 0) {\n    u = t[0].offset;\n    const I = t[t.length - 1];\n    f = I.offset + I.size;\n  }\n  const S = n - i, p = l + S * c + (S - 1) * o, m = u, w = p - f;\n  return {\n    bottom: f,\n    firstItemIndex: s,\n    items: In(t, r, s),\n    offsetBottom: w,\n    offsetTop: u,\n    top: m,\n    topItems: In(e, r, s),\n    topListHeight: e.reduce((I, C) => C.size + I, 0),\n    totalCount: n\n  };\n}\nfunction $n(t, e, n, o, r, s) {\n  let i = 0;\n  if (n.groupIndices.length > 0)\n    for (const f of n.groupIndices) {\n      if (f - i >= t)\n        break;\n      i++;\n    }\n  const l = t + i, c = Ue(e, l), u = Array.from({ length: l }).map((f, S) => ({\n    data: s[S + c],\n    index: S + c,\n    offset: 0,\n    size: 0\n  }));\n  return Ie(u, [], l, r, n, o);\n}\nfunction In(t, e, n) {\n  if (t.length === 0)\n    return [];\n  if (!be(e))\n    return t.map((u) => ({ ...u, index: u.index + n, originalIndex: u.index }));\n  const o = t[0].index, r = t[t.length - 1].index, s = [], i = ve(e.groupOffsetTree, o, r);\n  let l, c = 0;\n  for (const u of t) {\n    (!l || l.end < u.index) && (l = i.shift(), c = e.groupIndices.indexOf(l.start));\n    let f;\n    u.index === l.start ? f = {\n      index: c,\n      type: \"group\"\n    } : f = {\n      groupIndex: c,\n      index: u.index - (c + 1) + n\n    }, s.push({\n      ...f,\n      data: u.data,\n      offset: u.offset,\n      originalIndex: u.index,\n      size: u.size\n    });\n  }\n  return s;\n}\nconst Gt = U(\n  ([\n    { data: t, firstItemIndex: e, gap: n, sizes: o, totalCount: r },\n    s,\n    { listBoundary: i, topListHeight: l, visibleRange: c },\n    { initialTopMostItemIndex: u, scrolledToInitialItem: f },\n    { topListHeight: S },\n    p,\n    { didMount: m },\n    { recalcInProgress: w }\n  ]) => {\n    const I = y([]), C = y(0), g = $();\n    F(s.topItemsIndexes, I);\n    const a = ct(\n      x(\n        rt(\n          m,\n          w,\n          A(c, se),\n          A(r),\n          A(o),\n          A(u),\n          f,\n          A(I),\n          A(e),\n          A(n),\n          t\n        ),\n        P(([d, R, , B, , , , , , , O]) => {\n          const L = O && O.length !== B;\n          return d && !R && !L;\n        }),\n        E(\n          ([\n            ,\n            ,\n            [d, R],\n            B,\n            O,\n            L,\n            V,\n            D,\n            J,\n            nt,\n            k\n          ]) => {\n            const q = O, { offsetTree: st, sizeTree: dt } = q, St = lt(C);\n            if (B === 0)\n              return { ...ke, totalCount: B };\n            if (d === 0 && R === 0)\n              return St === 0 ? { ...ke, totalCount: B } : $n(St, L, O, J, nt, k || []);\n            if (j(dt))\n              return St > 0 ? null : Ie(\n                Ao(Ue(L, B), q, k),\n                [],\n                B,\n                nt,\n                q,\n                J\n              );\n            const ft = [];\n            if (D.length > 0) {\n              const Mt = D[0], yt = D[D.length - 1];\n              let kt = 0;\n              for (const v of ve(dt, Mt, yt)) {\n                const N = v.value, Q = Math.max(v.start, Mt), it = Math.min(v.end, yt);\n                for (let tt = Q; tt <= it; tt++)\n                  ft.push({ data: k == null ? void 0 : k[tt], index: tt, offset: kt, size: N }), kt += N;\n              }\n            }\n            if (!V)\n              return Ie([], ft, B, nt, q, J);\n            const ut = D.length > 0 ? D[D.length - 1] + 1 : 0, At = bo(st, d, R, ut);\n            if (At.length === 0)\n              return null;\n            const xt = B - 1, Xt = ye([], (Mt) => {\n              for (const yt of At) {\n                const kt = yt.value;\n                let v = kt.offset, N = yt.start;\n                const Q = kt.size;\n                if (kt.offset < d) {\n                  N += Math.floor((d - kt.offset + nt) / (Q + nt));\n                  const tt = N - yt.start;\n                  v += tt * Q + tt * nt;\n                }\n                N < ut && (v += (ut - N) * Q, N = ut);\n                const it = Math.min(yt.end, xt);\n                for (let tt = N; tt <= it && !(v >= R); tt++)\n                  Mt.push({ data: k == null ? void 0 : k[tt], index: tt, offset: v, size: Q }), v += Q + nt;\n              }\n            });\n            return Ie(Xt, ft, B, nt, q, J);\n          }\n        ),\n        //@ts-expect-error filter needs to be fixed\n        P((d) => d !== null),\n        Y()\n      ),\n      ke\n    );\n    F(\n      x(\n        t,\n        P(Me),\n        E((d) => d == null ? void 0 : d.length)\n      ),\n      r\n    ), F(\n      x(\n        a,\n        E((d) => d.topListHeight)\n      ),\n      S\n    ), F(S, l), F(\n      x(\n        a,\n        E((d) => [d.top, d.bottom])\n      ),\n      i\n    ), F(\n      x(\n        a,\n        E((d) => d.items)\n      ),\n      g\n    );\n    const T = pt(\n      x(\n        a,\n        P(({ items: d }) => d.length > 0),\n        G(r, t),\n        P(([{ items: d }, R]) => d[d.length - 1].originalIndex === R - 1),\n        E(([, d, R]) => [d - 1, R]),\n        Y(se),\n        E(([d]) => d)\n      )\n    ), b = pt(\n      x(\n        a,\n        Lt(200),\n        P(({ items: d, topItems: R }) => d.length > 0 && d[0].originalIndex === R.length),\n        E(({ items: d }) => d[0].index),\n        Y()\n      )\n    ), h = pt(\n      x(\n        a,\n        P(({ items: d }) => d.length > 0),\n        E(({ items: d }) => {\n          let R = 0, B = d.length - 1;\n          for (; d[R].type === \"group\" && R < B; )\n            R++;\n          for (; d[B].type === \"group\" && B > R; )\n            B--;\n          return {\n            endIndex: d[B].index,\n            startIndex: d[R].index\n          };\n        }),\n        Y(An)\n      )\n    );\n    return { endReached: T, initialItemCount: C, itemsRendered: g, listState: a, rangeChanged: h, startReached: b, topItemsIndexes: I, ...p };\n  },\n  X(\n    Et,\n    Gn,\n    Ke,\n    ue,\n    ce,\n    ae,\n    Pt,\n    Ne\n  ),\n  { singleton: !0 }\n), Un = U(\n  ([{ fixedFooterHeight: t, fixedHeaderHeight: e, footerHeight: n, headerHeight: o }, { listState: r }]) => {\n    const s = $(), i = ct(\n      x(\n        rt(n, t, o, e, r),\n        E(([l, c, u, f, S]) => l + c + u + f + S.offsetBottom + S.bottom)\n      ),\n      0\n    );\n    return F(A(i), s), { totalListHeight: i, totalListHeightChanged: s };\n  },\n  X(at, Gt),\n  { singleton: !0 }\n), Mo = U(\n  ([{ viewportHeight: t }, { totalListHeight: e }]) => {\n    const n = y(!1), o = ct(\n      x(\n        rt(n, t, e),\n        P(([r]) => r),\n        E(([, r, s]) => Math.max(0, r - s)),\n        Lt(0),\n        Y()\n      ),\n      0\n    );\n    return { alignToBottom: n, paddingTopAddition: o };\n  },\n  X(at, Un),\n  { singleton: !0 }\n);\nfunction Sn(t) {\n  return t ? t === \"smooth\" ? \"smooth\" : \"auto\" : !1;\n}\nconst Wo = (t, e) => typeof t == \"function\" ? Sn(t(e)) : e && Sn(t), _o = U(\n  ([\n    { listRefresh: t, totalCount: e },\n    { atBottomState: n, isAtBottom: o },\n    { scrollToIndex: r },\n    { scrolledToInitialItem: s },\n    { didMount: i, propsReady: l },\n    { log: c },\n    { scrollingInProgress: u }\n  ]) => {\n    const f = y(!1), S = $();\n    let p = null;\n    function m(I) {\n      W(r, {\n        align: \"end\",\n        behavior: I,\n        index: \"LAST\"\n      });\n    }\n    K(\n      x(\n        rt(x(A(e), jt(1)), i),\n        G(A(f), o, s, u),\n        E(([[I, C], g, a, T, b]) => {\n          let h = C && T, d = \"auto\";\n          return h && (d = Wo(g, a || b), h = h && !!d), { followOutputBehavior: d, shouldFollow: h, totalCount: I };\n        }),\n        P(({ shouldFollow: I }) => I)\n      ),\n      ({ followOutputBehavior: I, totalCount: C }) => {\n        p && (p(), p = null), p = Rt(t, () => {\n          lt(c)(\"following output to \", { totalCount: C }, ht.DEBUG), m(I), p = null;\n        });\n      }\n    );\n    function w(I) {\n      const C = Rt(n, (g) => {\n        I && !g.atBottom && g.notAtBottomBecause === \"SIZE_INCREASED\" && !p && (lt(c)(\"scrolling to bottom due to increased size\", {}, ht.DEBUG), m(\"auto\"));\n      });\n      setTimeout(C, 100);\n    }\n    return K(\n      x(\n        rt(A(f), e, l),\n        P(([I, , C]) => I && C),\n        bt(\n          ({ value: I }, [, C]) => ({ refreshed: I === C, value: C }),\n          { refreshed: !1, value: 0 }\n        ),\n        P(({ refreshed: I }) => I),\n        G(f, e)\n      ),\n      ([, I]) => {\n        lt(s) && w(I !== !1);\n      }\n    ), K(S, () => {\n      w(lt(f) !== !1);\n    }), K(rt(A(f), n), ([I, C]) => {\n      I && !C.atBottom && C.notAtBottomBecause === \"VIEWPORT_HEIGHT_DECREASING\" && m(\"auto\");\n    }), { autoscrollToBottom: S, followOutput: f };\n  },\n  X(Et, ae, ce, ue, Pt, Vt, at)\n), Go = U(\n  ([{ data: t, firstItemIndex: e, gap: n, sizes: o }, { initialTopMostItemIndex: r }, { initialItemCount: s, listState: i }, { didMount: l }]) => (F(\n    x(\n      l,\n      G(s),\n      P(([, c]) => c !== 0),\n      G(r, o, e, n, t),\n      E(([[, c], u, f, S, p, m = []]) => $n(c, u, f, S, p, m))\n    ),\n    i\n  ), {}),\n  X(Et, ue, Gt, Pt),\n  { singleton: !0 }\n), No = U(\n  ([{ didMount: t }, { scrollTo: e }, { listState: n }]) => {\n    const o = y(0);\n    return K(\n      x(\n        t,\n        G(o),\n        P(([, r]) => r !== 0),\n        E(([, r]) => ({ top: r }))\n      ),\n      (r) => {\n        Rt(\n          x(\n            n,\n            jt(1),\n            P((s) => s.items.length > 1)\n          ),\n          () => {\n            requestAnimationFrame(() => {\n              W(e, r);\n            });\n          }\n        );\n      }\n    ), {\n      initialScrollTop: o\n    };\n  },\n  X(Pt, at, Gt),\n  { singleton: !0 }\n), Do = ({\n  itemBottom: t,\n  itemTop: e,\n  locationParams: { align: n, behavior: o, ...r },\n  viewportBottom: s,\n  viewportTop: i\n}) => e < i ? { ...r, align: n != null ? n : \"start\", behavior: o } : t > s ? { ...r, align: n != null ? n : \"end\", behavior: o } : null, $o = U(\n  ([\n    { gap: t, sizes: e, totalCount: n },\n    { fixedFooterHeight: o, fixedHeaderHeight: r, headerHeight: s, scrollingInProgress: i, scrollTop: l, viewportHeight: c },\n    { scrollToIndex: u }\n  ]) => {\n    const f = $();\n    return F(\n      x(\n        f,\n        G(e, c, n, s, r, o, l),\n        G(t),\n        E(([[S, p, m, w, I, C, g, a], T]) => {\n          const { align: b, behavior: h, calculateViewLocation: d = Do, done: R, ...B } = S, O = _n(S, p, w - 1), L = ie(O, p.offsetTree, T) + I + C, V = L + Ct(p.sizeTree, O)[1], D = a + C, J = a + m - g, nt = d({\n            itemBottom: V,\n            itemTop: L,\n            locationParams: { align: b, behavior: h, ...B },\n            viewportBottom: J,\n            viewportTop: D\n          });\n          return nt ? R && Rt(\n            x(\n              i,\n              P((k) => !k),\n              // skips the initial publish of false, and the cleanup call.\n              // but if scrollingInProgress is true, we skip the initial publish.\n              jt(lt(i) ? 1 : 2)\n            ),\n            R\n          ) : R && R(), nt;\n        }),\n        P((S) => S !== null)\n      ),\n      u\n    ), {\n      scrollIntoView: f\n    };\n  },\n  X(Et, at, ce, Gt, Vt),\n  { singleton: !0 }\n), Kn = U(\n  ([{ scrollVelocity: t }]) => {\n    const e = y(!1), n = $(), o = y(!1);\n    return F(\n      x(\n        t,\n        G(o, e, n),\n        P(([r, s]) => !!s),\n        E(([r, s, i, l]) => {\n          const { enter: c, exit: u } = s;\n          if (i) {\n            if (u(r, l))\n              return !1;\n          } else if (c(r, l))\n            return !0;\n          return i;\n        }),\n        Y()\n      ),\n      e\n    ), K(\n      x(rt(e, t, n), G(o)),\n      ([[r, s, i], l]) => {\n        r && l && l.change && l.change(s, i);\n      }\n    ), { isSeeking: e, scrollSeekConfiguration: o, scrollSeekRangeChanged: n, scrollVelocity: t };\n  },\n  X(ae),\n  { singleton: !0 }\n), je = U(([{ scrollContainerState: t, scrollTo: e }]) => {\n  const n = $(), o = $(), r = $(), s = y(!1), i = y(void 0);\n  return F(\n    x(\n      rt(n, o),\n      E(([{ scrollHeight: l, scrollTop: c, viewportHeight: u }, { offsetTop: f }]) => ({\n        scrollHeight: l,\n        scrollTop: Math.max(0, c - f),\n        viewportHeight: u\n      }))\n    ),\n    t\n  ), F(\n    x(\n      e,\n      G(o),\n      E(([l, { offsetTop: c }]) => ({\n        ...l,\n        top: l.top + c\n      }))\n    ),\n    r\n  ), {\n    customScrollParent: i,\n    // config\n    useWindowScroll: s,\n    // input\n    windowScrollContainerState: n,\n    // signals\n    windowScrollTo: r,\n    windowViewportRect: o\n  };\n}, X(at)), Uo = U(\n  ([\n    { sizeRanges: t, sizes: e },\n    { headerHeight: n, scrollTop: o },\n    { initialTopMostItemIndex: r },\n    { didMount: s },\n    { useWindowScroll: i, windowScrollContainerState: l, windowViewportRect: c }\n  ]) => {\n    const u = $(), f = y(void 0), S = y(null), p = y(null);\n    return F(l, S), F(c, p), K(\n      x(\n        u,\n        G(e, o, i, S, p, n)\n      ),\n      ([m, w, I, C, g, a, T]) => {\n        const b = Ho(w.sizeTree);\n        C && g !== null && a !== null && (I = g.scrollTop - a.offsetTop), I -= T, m({ ranges: b, scrollTop: I });\n      }\n    ), F(x(f, P(Me), E(Ko)), r), F(\n      x(\n        s,\n        G(f),\n        P(([, m]) => m !== void 0),\n        Y(),\n        E(([, m]) => m.ranges)\n      ),\n      t\n    ), {\n      getState: u,\n      restoreStateFrom: f\n    };\n  },\n  X(Et, at, ue, Pt, je)\n);\nfunction Ko(t) {\n  return { align: \"start\", index: 0, offset: t.scrollTop };\n}\nconst jo = U(([{ topItemsIndexes: t }]) => {\n  const e = y(0);\n  return F(\n    x(\n      e,\n      P((n) => n >= 0),\n      E((n) => Array.from({ length: n }).map((o, r) => r))\n    ),\n    t\n  ), { topItemCount: e };\n}, X(Gt));\nfunction jn(t) {\n  let e = !1, n;\n  return () => (e || (e = !0, n = t()), n);\n}\nconst qo = jn(() => /iP(ad|od|hone)/i.test(navigator.userAgent) && /WebKit/i.test(navigator.userAgent)), Yo = U(\n  ([\n    { deviation: t, scrollBy: e, scrollingInProgress: n, scrollTop: o },\n    { isAtBottom: r, isScrolling: s, lastJumpDueToItemResize: i, scrollDirection: l },\n    { listState: c },\n    { beforeUnshiftWith: u, gap: f, shiftWithOffset: S, sizes: p },\n    { log: m },\n    { recalcInProgress: w }\n  ]) => {\n    const I = pt(\n      x(\n        c,\n        G(i),\n        bt(\n          ([, g, a, T], [{ bottom: b, items: h, offsetBottom: d, totalCount: R }, B]) => {\n            const O = b + d;\n            let L = 0;\n            return a === R && g.length > 0 && h.length > 0 && (h[0].originalIndex === 0 && g[0].originalIndex === 0 || (L = O - T, L !== 0 && (L += B))), [L, h, R, O];\n          },\n          [0, [], 0, 0]\n        ),\n        P(([g]) => g !== 0),\n        G(o, l, n, r, m, w),\n        P(([, g, a, T, , , b]) => !b && !T && g !== 0 && a === le),\n        E(([[g], , , , , a]) => (a(\"Upward scrolling compensation\", { amount: g }, ht.DEBUG), g))\n      )\n    );\n    function C(g) {\n      g > 0 ? (W(e, { behavior: \"auto\", top: -g }), W(t, 0)) : (W(t, 0), W(e, { behavior: \"auto\", top: -g }));\n    }\n    return K(x(I, G(t, s)), ([g, a, T]) => {\n      T && qo() ? W(t, a - g) : C(-g);\n    }), K(\n      x(\n        rt(ct(s, !1), t, w),\n        P(([g, a, T]) => !g && !T && a !== 0),\n        E(([g, a]) => a),\n        Lt(1)\n      ),\n      C\n    ), F(\n      x(\n        S,\n        E((g) => ({ top: -g }))\n      ),\n      e\n    ), K(\n      x(\n        u,\n        G(p, f),\n        E(([g, { groupIndices: a, lastSize: T, sizeTree: b }, h]) => {\n          function d(R) {\n            return R * (T + h);\n          }\n          if (a.length === 0)\n            return d(g);\n          {\n            let R = 0;\n            const B = re(b, 0);\n            let O = 0, L = 0;\n            for (; O < g; ) {\n              O++, R += B;\n              let V = a.length === L + 1 ? 1 / 0 : a[L + 1] - a[L] - 1;\n              O + V > g && (R -= B, V = g - O + 1), O += V, R += d(V), L++;\n            }\n            return R;\n          }\n        })\n      ),\n      (g) => {\n        W(t, g), requestAnimationFrame(() => {\n          W(e, { top: g }), requestAnimationFrame(() => {\n            W(t, 0), W(w, !1);\n          });\n        });\n      }\n    ), { deviation: t };\n  },\n  X(at, ae, Gt, Et, Vt, Ne)\n), Zo = U(\n  ([\n    t,\n    e,\n    n,\n    o,\n    r,\n    s,\n    i,\n    l,\n    c,\n    u\n  ]) => ({\n    ...t,\n    ...e,\n    ...n,\n    ...o,\n    ...r,\n    ...s,\n    ...i,\n    ...l,\n    ...c,\n    ...u\n  }),\n  X(\n    Ke,\n    Go,\n    Pt,\n    Kn,\n    Un,\n    No,\n    Mo,\n    je,\n    $o,\n    Vt\n  )\n), qn = U(\n  ([\n    {\n      data: t,\n      defaultItemSize: e,\n      firstItemIndex: n,\n      fixedItemSize: o,\n      gap: r,\n      groupIndices: s,\n      itemSize: i,\n      sizeRanges: l,\n      sizes: c,\n      statefulTotalCount: u,\n      totalCount: f,\n      trackItemSizes: S\n    },\n    { initialItemFinalLocationReached: p, initialTopMostItemIndex: m, scrolledToInitialItem: w },\n    I,\n    C,\n    g,\n    { listState: a, topItemsIndexes: T, ...b },\n    { scrollToIndex: h },\n    d,\n    { topItemCount: R },\n    { groupCounts: B },\n    O\n  ]) => (F(b.rangeChanged, O.scrollSeekRangeChanged), F(\n    x(\n      O.windowViewportRect,\n      E((L) => L.visibleHeight)\n    ),\n    I.viewportHeight\n  ), {\n    data: t,\n    defaultItemHeight: e,\n    firstItemIndex: n,\n    fixedItemHeight: o,\n    gap: r,\n    groupCounts: B,\n    initialItemFinalLocationReached: p,\n    initialTopMostItemIndex: m,\n    scrolledToInitialItem: w,\n    sizeRanges: l,\n    topItemCount: R,\n    topItemsIndexes: T,\n    // input\n    totalCount: f,\n    ...g,\n    groupIndices: s,\n    itemSize: i,\n    listState: a,\n    scrollToIndex: h,\n    // output\n    statefulTotalCount: u,\n    trackItemSizes: S,\n    // exported from stateFlagsSystem\n    ...b,\n    // the bag of IO from featureGroup1System\n    ...O,\n    ...I,\n    sizes: c,\n    ...C\n  }),\n  X(\n    Et,\n    ue,\n    at,\n    Uo,\n    _o,\n    Gt,\n    ce,\n    Yo,\n    jo,\n    Gn,\n    Zo\n  )\n);\nfunction Xo(t, e) {\n  const n = {}, o = {};\n  let r = 0;\n  const s = t.length;\n  for (; r < s; )\n    o[t[r]] = 1, r += 1;\n  for (const i in e)\n    Object.hasOwn(o, i) || (n[i] = e[i]);\n  return n;\n}\nconst pe = typeof document < \"u\" ? react__WEBPACK_IMPORTED_MODULE_1__.useLayoutEffect : react__WEBPACK_IMPORTED_MODULE_1__.useEffect;\nfunction qe(t, e, n) {\n  const o = Object.keys(e.required || {}), r = Object.keys(e.optional || {}), s = Object.keys(e.methods || {}), i = Object.keys(e.events || {}), l = react__WEBPACK_IMPORTED_MODULE_1__.createContext({});\n  function c(g, a) {\n    g.propsReady && W(g.propsReady, !1);\n    for (const T of o) {\n      const b = g[e.required[T]];\n      W(b, a[T]);\n    }\n    for (const T of r)\n      if (T in a) {\n        const b = g[e.optional[T]];\n        W(b, a[T]);\n      }\n    g.propsReady && W(g.propsReady, !0);\n  }\n  function u(g) {\n    return s.reduce((a, T) => (a[T] = (b) => {\n      const h = g[e.methods[T]];\n      W(h, b);\n    }, a), {});\n  }\n  function f(g) {\n    return i.reduce((a, T) => (a[T] = mo(g[e.events[T]]), a), {});\n  }\n  const S = react__WEBPACK_IMPORTED_MODULE_1__.forwardRef((g, a) => {\n    const { children: T, ...b } = g, [h] = react__WEBPACK_IMPORTED_MODULE_1__.useState(() => ye(ho(t), (B) => {\n      c(B, b);\n    })), [d] = react__WEBPACK_IMPORTED_MODULE_1__.useState(cn(f, h));\n    pe(() => {\n      for (const B of i)\n        B in b && K(d[B], b[B]);\n      return () => {\n        Object.values(d).map(We);\n      };\n    }, [b, d, h]), pe(() => {\n      c(h, b);\n    }), react__WEBPACK_IMPORTED_MODULE_1__.useImperativeHandle(a, ln(u(h)));\n    const R = n;\n    return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(l.Provider, { value: h, children: n ? /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(R, { ...Xo([...o, ...r, ...i], b), children: T }) : T });\n  }), p = (g) => react__WEBPACK_IMPORTED_MODULE_1__.useCallback(kn(W, react__WEBPACK_IMPORTED_MODULE_1__.useContext(l)[g]), [g]), m = (g) => {\n    const T = react__WEBPACK_IMPORTED_MODULE_1__.useContext(l)[g], b = react__WEBPACK_IMPORTED_MODULE_1__.useCallback(\n      (h) => K(T, h),\n      [T]\n    );\n    return react__WEBPACK_IMPORTED_MODULE_1__.useSyncExternalStore(\n      b,\n      () => lt(T),\n      () => lt(T)\n    );\n  }, w = (g) => {\n    const T = react__WEBPACK_IMPORTED_MODULE_1__.useContext(l)[g], [b, h] = react__WEBPACK_IMPORTED_MODULE_1__.useState(cn(lt, T));\n    return pe(\n      () => K(T, (d) => {\n        d !== b && h(ln(d));\n      }),\n      [T, b]\n    ), b;\n  }, I = react__WEBPACK_IMPORTED_MODULE_1__.version.startsWith(\"18\") ? m : w;\n  return {\n    Component: S,\n    useEmitter: (g, a) => {\n      const b = react__WEBPACK_IMPORTED_MODULE_1__.useContext(l)[g];\n      pe(() => K(b, a), [a, b]);\n    },\n    useEmitterValue: I,\n    usePublisher: p\n  };\n}\nconst Re = react__WEBPACK_IMPORTED_MODULE_1__.createContext(void 0), Yn = react__WEBPACK_IMPORTED_MODULE_1__.createContext(void 0), Zn = typeof document < \"u\" ? react__WEBPACK_IMPORTED_MODULE_1__.useLayoutEffect : react__WEBPACK_IMPORTED_MODULE_1__.useEffect;\nfunction Be(t) {\n  return \"self\" in t;\n}\nfunction Jo(t) {\n  return \"body\" in t;\n}\nfunction Xn(t, e, n, o = Yt, r, s) {\n  const i = react__WEBPACK_IMPORTED_MODULE_1__.useRef(null), l = react__WEBPACK_IMPORTED_MODULE_1__.useRef(null), c = react__WEBPACK_IMPORTED_MODULE_1__.useRef(null), u = react__WEBPACK_IMPORTED_MODULE_1__.useCallback(\n    (p) => {\n      let m, w, I;\n      const C = p.target;\n      if (Jo(C) || Be(C)) {\n        const a = Be(C) ? C : C.defaultView;\n        I = s ? a.scrollX : a.scrollY, m = s ? a.document.documentElement.scrollWidth : a.document.documentElement.scrollHeight, w = s ? a.innerWidth : a.innerHeight;\n      } else\n        I = s ? C.scrollLeft : C.scrollTop, m = s ? C.scrollWidth : C.scrollHeight, w = s ? C.offsetWidth : C.offsetHeight;\n      const g = () => {\n        t({\n          scrollHeight: m,\n          scrollTop: Math.max(I, 0),\n          viewportHeight: w\n        });\n      };\n      p.suppressFlushSync ? g() : react_dom__WEBPACK_IMPORTED_MODULE_2__.flushSync(g), l.current !== null && (I === l.current || I <= 0 || I === m - w) && (l.current = null, e(!0), c.current && (clearTimeout(c.current), c.current = null));\n    },\n    [t, e]\n  );\n  react__WEBPACK_IMPORTED_MODULE_1__.useEffect(() => {\n    const p = r || i.current;\n    return o(r || i.current), u({ suppressFlushSync: !0, target: p }), p.addEventListener(\"scroll\", u, { passive: !0 }), () => {\n      o(null), p.removeEventListener(\"scroll\", u);\n    };\n  }, [i, u, n, o, r]);\n  function f(p) {\n    const m = i.current;\n    if (!m || (s ? \"offsetWidth\" in m && m.offsetWidth === 0 : \"offsetHeight\" in m && m.offsetHeight === 0))\n      return;\n    const w = p.behavior === \"smooth\";\n    let I, C, g;\n    Be(m) ? (C = Math.max(\n      wt(m.document.documentElement, s ? \"width\" : \"height\"),\n      s ? m.document.documentElement.scrollWidth : m.document.documentElement.scrollHeight\n    ), I = s ? m.innerWidth : m.innerHeight, g = s ? window.scrollX : window.scrollY) : (C = m[s ? \"scrollWidth\" : \"scrollHeight\"], I = wt(m, s ? \"width\" : \"height\"), g = m[s ? \"scrollLeft\" : \"scrollTop\"]);\n    const a = C - I;\n    if (p.top = Math.ceil(Math.max(Math.min(a, p.top), 0)), Dn(I, C) || p.top === g) {\n      t({ scrollHeight: C, scrollTop: g, viewportHeight: I }), w && e(!0);\n      return;\n    }\n    w ? (l.current = p.top, c.current && clearTimeout(c.current), c.current = setTimeout(() => {\n      c.current = null, l.current = null, e(!0);\n    }, 1e3)) : l.current = null, s && (p = { behavior: p.behavior, left: p.top }), m.scrollTo(p);\n  }\n  function S(p) {\n    s && (p = { behavior: p.behavior, left: p.top }), i.current.scrollBy(p);\n  }\n  return { scrollByCallback: S, scrollerRef: i, scrollToCallback: f };\n}\nconst Oe = \"-webkit-sticky\", xn = \"sticky\", Jn = jn(() => {\n  if (typeof document > \"u\")\n    return xn;\n  const t = document.createElement(\"div\");\n  return t.style.position = Oe, t.style.position === Oe ? Oe : xn;\n});\nfunction Ye(t) {\n  return t;\n}\nconst Qo = /* @__PURE__ */ U(() => {\n  const t = y((c) => `Item ${c}`), e = y(null), n = y((c) => `Group ${c}`), o = y({}), r = y(Ye), s = y(\"div\"), i = y(Yt), l = (c, u = null) => ct(\n    x(\n      o,\n      E((f) => f[c]),\n      Y()\n    ),\n    u\n  );\n  return {\n    components: o,\n    computeItemKey: r,\n    context: e,\n    EmptyPlaceholder: l(\"EmptyPlaceholder\"),\n    FooterComponent: l(\"Footer\"),\n    GroupComponent: l(\"Group\", \"div\"),\n    groupContent: n,\n    HeaderComponent: l(\"Header\"),\n    HeaderFooterTag: s,\n    ItemComponent: l(\"Item\", \"div\"),\n    itemContent: t,\n    ListComponent: l(\"List\", \"div\"),\n    ScrollerComponent: l(\"Scroller\", \"div\"),\n    scrollerRef: i,\n    ScrollSeekPlaceholder: l(\"ScrollSeekPlaceholder\"),\n    TopItemListComponent: l(\"TopItemList\")\n  };\n}), tr = /* @__PURE__ */ U(\n  ([t, e]) => ({ ...t, ...e }),\n  X(qn, Qo)\n), er = ({ height: t }) => /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"div\", { style: { height: t } }), nr = { overflowAnchor: \"none\", position: Jn(), zIndex: 1 }, Qn = { overflowAnchor: \"none\" }, or = { ...Qn, display: \"inline-block\", height: \"100%\" }, Tn = /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_1__.memo(function({ showTopList: e = !1 }) {\n  const n = M(\"listState\"), o = gt(\"sizeRanges\"), r = M(\"useWindowScroll\"), s = M(\"customScrollParent\"), i = gt(\"windowScrollContainerState\"), l = gt(\"scrollContainerState\"), c = s || r ? i : l, u = M(\"itemContent\"), f = M(\"context\"), S = M(\"groupContent\"), p = M(\"trackItemSizes\"), m = M(\"itemSize\"), w = M(\"log\"), I = gt(\"gap\"), C = M(\"horizontalDirection\"), { callbackRef: g } = On(\n    o,\n    m,\n    p,\n    e ? Yt : c,\n    w,\n    I,\n    s,\n    C,\n    M(\"skipAnimationFrameInResizeObserver\")\n  ), [a, T] = react__WEBPACK_IMPORTED_MODULE_1__.useState(0);\n  Je(\"deviation\", (k) => {\n    a !== k && T(k);\n  });\n  const b = M(\"EmptyPlaceholder\"), h = M(\"ScrollSeekPlaceholder\") || er, d = M(\"ListComponent\"), R = M(\"ItemComponent\"), B = M(\"GroupComponent\"), O = M(\"computeItemKey\"), L = M(\"isSeeking\"), V = M(\"groupIndices\").length > 0, D = M(\"alignToBottom\"), J = M(\"initialItemFinalLocationReached\"), nt = e ? {} : {\n    boxSizing: \"border-box\",\n    ...C ? {\n      display: \"inline-block\",\n      height: \"100%\",\n      marginLeft: a !== 0 ? a : D ? \"auto\" : 0,\n      paddingLeft: n.offsetTop,\n      paddingRight: n.offsetBottom,\n      whiteSpace: \"nowrap\"\n    } : {\n      marginTop: a !== 0 ? a : D ? \"auto\" : 0,\n      paddingBottom: n.offsetBottom,\n      paddingTop: n.offsetTop\n    },\n    ...J ? {} : { visibility: \"hidden\" }\n  };\n  return !e && n.totalCount === 0 && b ? /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(b, { ...Z(b, f) }) : /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\n    d,\n    {\n      ...Z(d, f),\n      \"data-testid\": e ? \"virtuoso-top-item-list\" : \"virtuoso-item-list\",\n      ref: g,\n      style: nt,\n      children: (e ? n.topItems : n.items).map((k) => {\n        const q = k.originalIndex, st = O(q + n.firstItemIndex, k.data, f);\n        return L ? /* @__PURE__ */ (0,react__WEBPACK_IMPORTED_MODULE_1__.createElement)(\n          h,\n          {\n            ...Z(h, f),\n            height: k.size,\n            index: k.index,\n            key: st,\n            type: k.type || \"item\",\n            ...k.type === \"group\" ? {} : { groupIndex: k.groupIndex }\n          }\n        ) : k.type === \"group\" ? /* @__PURE__ */ (0,react__WEBPACK_IMPORTED_MODULE_1__.createElement)(\n          B,\n          {\n            ...Z(B, f),\n            \"data-index\": q,\n            \"data-item-index\": k.index,\n            \"data-known-size\": k.size,\n            key: st,\n            style: nr\n          },\n          S(k.index, f)\n        ) : /* @__PURE__ */ (0,react__WEBPACK_IMPORTED_MODULE_1__.createElement)(\n          R,\n          {\n            ...Z(R, f),\n            ...to(R, k.data),\n            \"data-index\": q,\n            \"data-item-group-index\": k.groupIndex,\n            \"data-item-index\": k.index,\n            \"data-known-size\": k.size,\n            key: st,\n            style: C ? or : Qn\n          },\n          V ? u(k.index, k.groupIndex, k.data, f) : u(k.index, k.data, f)\n        );\n      })\n    }\n  );\n}), rr = {\n  height: \"100%\",\n  outline: \"none\",\n  overflowY: \"auto\",\n  position: \"relative\",\n  WebkitOverflowScrolling: \"touch\"\n}, sr = {\n  outline: \"none\",\n  overflowX: \"auto\",\n  position: \"relative\"\n}, Zt = (t) => ({\n  height: \"100%\",\n  position: \"absolute\",\n  top: 0,\n  width: \"100%\",\n  ...t ? { display: \"flex\", flexDirection: \"column\" } : {}\n}), ir = {\n  position: Jn(),\n  top: 0,\n  width: \"100%\",\n  zIndex: 1\n};\nfunction Z(t, e) {\n  if (typeof t != \"string\")\n    return { context: e };\n}\nfunction to(t, e) {\n  return { item: typeof t == \"string\" ? void 0 : e };\n}\nconst lr = /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_1__.memo(function() {\n  const e = M(\"HeaderComponent\"), n = gt(\"headerHeight\"), o = M(\"HeaderFooterTag\"), r = Ht(\n    react__WEBPACK_IMPORTED_MODULE_1__.useMemo(\n      () => (i) => {\n        n(wt(i, \"height\"));\n      },\n      [n]\n    ),\n    !0,\n    M(\"skipAnimationFrameInResizeObserver\")\n  ), s = M(\"context\");\n  return e ? /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(o, { ref: r, children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(e, { ...Z(e, s) }) }) : null;\n}), cr = /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_1__.memo(function() {\n  const e = M(\"FooterComponent\"), n = gt(\"footerHeight\"), o = M(\"HeaderFooterTag\"), r = Ht(\n    react__WEBPACK_IMPORTED_MODULE_1__.useMemo(\n      () => (i) => {\n        n(wt(i, \"height\"));\n      },\n      [n]\n    ),\n    !0,\n    M(\"skipAnimationFrameInResizeObserver\")\n  ), s = M(\"context\");\n  return e ? /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(o, { ref: r, children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(e, { ...Z(e, s) }) }) : null;\n});\nfunction Ze({ useEmitter: t, useEmitterValue: e, usePublisher: n }) {\n  return react__WEBPACK_IMPORTED_MODULE_1__.memo(function({ children: s, style: i, ...l }) {\n    const c = n(\"scrollContainerState\"), u = e(\"ScrollerComponent\"), f = n(\"smoothScrollTargetReached\"), S = e(\"scrollerRef\"), p = e(\"context\"), m = e(\"horizontalDirection\") || !1, { scrollByCallback: w, scrollerRef: I, scrollToCallback: C } = Xn(\n      c,\n      f,\n      u,\n      S,\n      void 0,\n      m\n    );\n    return t(\"scrollTo\", C), t(\"scrollBy\", w), /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\n      u,\n      {\n        \"data-testid\": \"virtuoso-scroller\",\n        \"data-virtuoso-scroller\": !0,\n        ref: I,\n        style: { ...m ? sr : rr, ...i },\n        tabIndex: 0,\n        ...l,\n        ...Z(u, p),\n        children: s\n      }\n    );\n  });\n}\nfunction Xe({ useEmitter: t, useEmitterValue: e, usePublisher: n }) {\n  return react__WEBPACK_IMPORTED_MODULE_1__.memo(function({ children: s, style: i, ...l }) {\n    const c = n(\"windowScrollContainerState\"), u = e(\"ScrollerComponent\"), f = n(\"smoothScrollTargetReached\"), S = e(\"totalListHeight\"), p = e(\"deviation\"), m = e(\"customScrollParent\"), w = e(\"context\"), I = react__WEBPACK_IMPORTED_MODULE_1__.useRef(null), C = e(\"scrollerRef\"), { scrollByCallback: g, scrollerRef: a, scrollToCallback: T } = Xn(\n      c,\n      f,\n      u,\n      C,\n      m\n    );\n    return Zn(() => {\n      var b;\n      return a.current = m || ((b = I.current) == null ? void 0 : b.ownerDocument.defaultView), () => {\n        a.current = null;\n      };\n    }, [a, m]), t(\"windowScrollTo\", T), t(\"scrollBy\", g), /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\n      u,\n      {\n        ref: I,\n        \"data-virtuoso-scroller\": !0,\n        style: { position: \"relative\", ...i, ...S !== 0 ? { height: S + p } : {} },\n        ...l,\n        ...Z(u, w),\n        children: s\n      }\n    );\n  });\n}\nconst ur = ({ children: t }) => {\n  const e = react__WEBPACK_IMPORTED_MODULE_1__.useContext(Re), n = gt(\"viewportHeight\"), o = gt(\"fixedItemHeight\"), r = M(\"alignToBottom\"), s = M(\"horizontalDirection\"), i = react__WEBPACK_IMPORTED_MODULE_1__.useMemo(\n    () => ne(n, (c) => wt(c, s ? \"width\" : \"height\")),\n    [n, s]\n  ), l = Ht(i, !0, M(\"skipAnimationFrameInResizeObserver\"));\n  return react__WEBPACK_IMPORTED_MODULE_1__.useEffect(() => {\n    e && (n(e.viewportHeight), o(e.itemHeight));\n  }, [e, n, o]), /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"div\", { \"data-viewport-type\": \"element\", ref: l, style: Zt(r), children: t });\n}, ar = ({ children: t }) => {\n  const e = react__WEBPACK_IMPORTED_MODULE_1__.useContext(Re), n = gt(\"windowViewportRect\"), o = gt(\"fixedItemHeight\"), r = M(\"customScrollParent\"), s = Ge(\n    n,\n    r,\n    M(\"skipAnimationFrameInResizeObserver\")\n  ), i = M(\"alignToBottom\");\n  return react__WEBPACK_IMPORTED_MODULE_1__.useEffect(() => {\n    e && (o(e.itemHeight), n({ offsetTop: 0, visibleHeight: e.viewportHeight, visibleWidth: 100 }));\n  }, [e, n, o]), /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"div\", { \"data-viewport-type\": \"window\", ref: s, style: Zt(i), children: t });\n}, dr = ({ children: t }) => {\n  const e = M(\"TopItemListComponent\") || \"div\", n = M(\"headerHeight\"), o = { ...ir, marginTop: `${n}px` }, r = M(\"context\");\n  return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(e, { style: o, ...Z(e, r), children: t });\n}, fr = /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_1__.memo(function(e) {\n  const n = M(\"useWindowScroll\"), o = M(\"topItemsIndexes\").length > 0, r = M(\"customScrollParent\"), s = M(\"context\"), i = r || n ? pr : mr, l = r || n ? ar : ur;\n  return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(i, { ...e, ...Z(i, s), children: [\n    o && /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(dr, { children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(Tn, { showTopList: !0 }) }),\n    /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(l, { children: [\n      /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(lr, {}),\n      /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(Tn, {}),\n      /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(cr, {})\n    ] })\n  ] });\n}), {\n  Component: eo,\n  useEmitter: Je,\n  useEmitterValue: M,\n  usePublisher: gt\n} = /* @__PURE__ */ qe(\n  tr,\n  {\n    events: {\n      atBottomStateChange: \"atBottomStateChange\",\n      atTopStateChange: \"atTopStateChange\",\n      endReached: \"endReached\",\n      groupIndices: \"groupIndices\",\n      isScrolling: \"isScrolling\",\n      itemsRendered: \"itemsRendered\",\n      rangeChanged: \"rangeChanged\",\n      startReached: \"startReached\",\n      totalListHeightChanged: \"totalListHeightChanged\"\n    },\n    methods: {\n      autoscrollToBottom: \"autoscrollToBottom\",\n      getState: \"getState\",\n      scrollBy: \"scrollBy\",\n      scrollIntoView: \"scrollIntoView\",\n      scrollTo: \"scrollTo\",\n      scrollToIndex: \"scrollToIndex\"\n    },\n    optional: {\n      alignToBottom: \"alignToBottom\",\n      atBottomThreshold: \"atBottomThreshold\",\n      atTopThreshold: \"atTopThreshold\",\n      components: \"components\",\n      computeItemKey: \"computeItemKey\",\n      context: \"context\",\n      customScrollParent: \"customScrollParent\",\n      data: \"data\",\n      defaultItemHeight: \"defaultItemHeight\",\n      firstItemIndex: \"firstItemIndex\",\n      fixedItemHeight: \"fixedItemHeight\",\n      followOutput: \"followOutput\",\n      groupContent: \"groupContent\",\n      groupCounts: \"groupCounts\",\n      headerFooterTag: \"HeaderFooterTag\",\n      horizontalDirection: \"horizontalDirection\",\n      increaseViewportBy: \"increaseViewportBy\",\n      initialItemCount: \"initialItemCount\",\n      initialScrollTop: \"initialScrollTop\",\n      initialTopMostItemIndex: \"initialTopMostItemIndex\",\n      itemContent: \"itemContent\",\n      itemSize: \"itemSize\",\n      logLevel: \"logLevel\",\n      overscan: \"overscan\",\n      restoreStateFrom: \"restoreStateFrom\",\n      scrollerRef: \"scrollerRef\",\n      scrollSeekConfiguration: \"scrollSeekConfiguration\",\n      skipAnimationFrameInResizeObserver: \"skipAnimationFrameInResizeObserver\",\n      topItemCount: \"topItemCount\",\n      totalCount: \"totalCount\",\n      useWindowScroll: \"useWindowScroll\"\n    },\n    required: {}\n  },\n  fr\n), mr = /* @__PURE__ */ Ze({ useEmitter: Je, useEmitterValue: M, usePublisher: gt }), pr = /* @__PURE__ */ Xe({ useEmitter: Je, useEmitterValue: M, usePublisher: gt }), Kr = eo, jr = eo, hr = /* @__PURE__ */ U(() => {\n  const t = y((c) => /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(\"td\", { children: [\n    \"Item $\",\n    c\n  ] })), e = y(null), n = y(null), o = y(null), r = y({}), s = y(Ye), i = y(Yt), l = (c, u = null) => ct(\n    x(\n      r,\n      E((f) => f[c]),\n      Y()\n    ),\n    u\n  );\n  return {\n    components: r,\n    computeItemKey: s,\n    context: e,\n    EmptyPlaceholder: l(\"EmptyPlaceholder\"),\n    FillerRow: l(\"FillerRow\"),\n    fixedFooterContent: o,\n    fixedHeaderContent: n,\n    itemContent: t,\n    ScrollerComponent: l(\"Scroller\", \"div\"),\n    scrollerRef: i,\n    ScrollSeekPlaceholder: l(\"ScrollSeekPlaceholder\"),\n    TableBodyComponent: l(\"TableBody\", \"tbody\"),\n    TableComponent: l(\"Table\", \"table\"),\n    TableFooterComponent: l(\"TableFoot\", \"tfoot\"),\n    TableHeadComponent: l(\"TableHead\", \"thead\"),\n    TableRowComponent: l(\"TableRow\", \"tr\")\n  };\n}), gr = /* @__PURE__ */ U(\n  ([t, e]) => ({ ...t, ...e }),\n  X(qn, hr)\n), Ir = ({ height: t }) => /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"tr\", { children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"td\", { style: { height: t } }) }), Sr = ({ height: t }) => /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"tr\", { children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"td\", { style: { border: 0, height: t, padding: 0 } }) }), xr = { overflowAnchor: \"none\" }, Cn = /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_1__.memo(function({ showTopList: e = !1 }) {\n  const n = _(\"listState\"), o = _(\"computeItemKey\"), r = _(\"firstItemIndex\"), s = _(\"isSeeking\"), i = _(\"ScrollSeekPlaceholder\") || Ir, l = _(\"context\"), c = _(\"TableRowComponent\"), u = _(\"fixedHeaderHeight\"), f = _(\"itemContent\"), S = (e ? n.topItems : []).reduce((m, w, I) => (I === 0 ? m.push(w.size) : m.push(m[I - 1] + w.size), m), []), p = (e ? n.topItems : n.items).map((m) => {\n    const w = m.originalIndex, I = o(w + r, m.data, l), C = e ? w === 0 ? 0 : S[w - 1] : 0;\n    return s ? /* @__PURE__ */ (0,react__WEBPACK_IMPORTED_MODULE_1__.createElement)(\n      i,\n      {\n        ...Z(i, l),\n        height: m.size,\n        index: m.index,\n        key: I,\n        type: m.type || \"item\"\n      }\n    ) : /* @__PURE__ */ (0,react__WEBPACK_IMPORTED_MODULE_1__.createElement)(\n      c,\n      {\n        ...Z(c, l),\n        ...to(c, m.data),\n        \"data-index\": w,\n        \"data-item-index\": m.index,\n        \"data-known-size\": m.size,\n        key: I,\n        style: e ? { overflowAnchor: \"none\", position: \"sticky\", top: u + C, zIndex: 2 } : xr\n      },\n      f(m.index, m.data, l)\n    );\n  });\n  return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.Fragment, { children: p });\n}), Tr = /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_1__.memo(function() {\n  const e = _(\"listState\"), n = _(\"topItemsIndexes\").length > 0, o = Tt(\"sizeRanges\"), r = _(\"useWindowScroll\"), s = _(\"customScrollParent\"), i = Tt(\"windowScrollContainerState\"), l = Tt(\"scrollContainerState\"), c = s || r ? i : l, u = _(\"trackItemSizes\"), f = _(\"itemSize\"), S = _(\"log\"), { callbackRef: p, ref: m } = On(\n    o,\n    f,\n    u,\n    c,\n    S,\n    void 0,\n    s,\n    !1,\n    _(\"skipAnimationFrameInResizeObserver\")\n  ), [w, I] = react__WEBPACK_IMPORTED_MODULE_1__.useState(0);\n  Qe(\"deviation\", (V) => {\n    w !== V && (m.current.style.marginTop = `${V}px`, I(V));\n  });\n  const C = _(\"EmptyPlaceholder\"), g = _(\"FillerRow\") || Sr, a = _(\"TableBodyComponent\"), T = _(\"paddingTopAddition\"), b = _(\"statefulTotalCount\"), h = _(\"context\");\n  if (b === 0 && C)\n    return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(C, { ...Z(C, h) });\n  const d = (n ? e.topItems : []).reduce((V, D) => V + D.size, 0), R = e.offsetTop + T + w - d, B = e.offsetBottom, O = R > 0 ? /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(g, { context: h, height: R }, \"padding-top\") : null, L = B > 0 ? /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(g, { context: h, height: B }, \"padding-bottom\") : null;\n  return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(a, { \"data-testid\": \"virtuoso-item-list\", ref: p, ...Z(a, h), children: [\n    O,\n    n && /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(Cn, { showTopList: !0 }),\n    /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(Cn, {}),\n    L\n  ] });\n}), Cr = ({ children: t }) => {\n  const e = react__WEBPACK_IMPORTED_MODULE_1__.useContext(Re), n = Tt(\"viewportHeight\"), o = Tt(\"fixedItemHeight\"), r = Ht(\n    react__WEBPACK_IMPORTED_MODULE_1__.useMemo(() => ne(n, (s) => wt(s, \"height\")), [n]),\n    !0,\n    _(\"skipAnimationFrameInResizeObserver\")\n  );\n  return react__WEBPACK_IMPORTED_MODULE_1__.useEffect(() => {\n    e && (n(e.viewportHeight), o(e.itemHeight));\n  }, [e, n, o]), /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"div\", { \"data-viewport-type\": \"element\", ref: r, style: Zt(!1), children: t });\n}, wr = ({ children: t }) => {\n  const e = react__WEBPACK_IMPORTED_MODULE_1__.useContext(Re), n = Tt(\"windowViewportRect\"), o = Tt(\"fixedItemHeight\"), r = _(\"customScrollParent\"), s = Ge(\n    n,\n    r,\n    _(\"skipAnimationFrameInResizeObserver\")\n  );\n  return react__WEBPACK_IMPORTED_MODULE_1__.useEffect(() => {\n    e && (o(e.itemHeight), n({ offsetTop: 0, visibleHeight: e.viewportHeight, visibleWidth: 100 }));\n  }, [e, n, o]), /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"div\", { \"data-viewport-type\": \"window\", ref: s, style: Zt(!1), children: t });\n}, yr = /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_1__.memo(function(e) {\n  const n = _(\"useWindowScroll\"), o = _(\"customScrollParent\"), r = Tt(\"fixedHeaderHeight\"), s = Tt(\"fixedFooterHeight\"), i = _(\"fixedHeaderContent\"), l = _(\"fixedFooterContent\"), c = _(\"context\"), u = Ht(\n    react__WEBPACK_IMPORTED_MODULE_1__.useMemo(() => ne(r, (a) => wt(a, \"height\")), [r]),\n    !0,\n    _(\"skipAnimationFrameInResizeObserver\")\n  ), f = Ht(\n    react__WEBPACK_IMPORTED_MODULE_1__.useMemo(() => ne(s, (a) => wt(a, \"height\")), [s]),\n    !0,\n    _(\"skipAnimationFrameInResizeObserver\")\n  ), S = o || n ? Rr : br, p = o || n ? wr : Cr, m = _(\"TableComponent\"), w = _(\"TableHeadComponent\"), I = _(\"TableFooterComponent\"), C = i ? /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\n    w,\n    {\n      ref: u,\n      style: { position: \"sticky\", top: 0, zIndex: 2 },\n      ...Z(w, c),\n      children: i()\n    },\n    \"TableHead\"\n  ) : null, g = l ? /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\n    I,\n    {\n      ref: f,\n      style: { bottom: 0, position: \"sticky\", zIndex: 1 },\n      ...Z(I, c),\n      children: l()\n    },\n    \"TableFoot\"\n  ) : null;\n  return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(S, { ...e, ...Z(S, c), children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(p, { children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(m, { style: { borderSpacing: 0, overflowAnchor: \"none\" }, ...Z(m, c), children: [\n    C,\n    /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(Tr, {}, \"TableBody\"),\n    g\n  ] }) }) });\n}), {\n  Component: vr,\n  useEmitter: Qe,\n  useEmitterValue: _,\n  usePublisher: Tt\n} = /* @__PURE__ */ qe(\n  gr,\n  {\n    events: {\n      atBottomStateChange: \"atBottomStateChange\",\n      atTopStateChange: \"atTopStateChange\",\n      endReached: \"endReached\",\n      groupIndices: \"groupIndices\",\n      isScrolling: \"isScrolling\",\n      itemsRendered: \"itemsRendered\",\n      rangeChanged: \"rangeChanged\",\n      startReached: \"startReached\",\n      totalListHeightChanged: \"totalListHeightChanged\"\n    },\n    methods: {\n      getState: \"getState\",\n      scrollBy: \"scrollBy\",\n      scrollIntoView: \"scrollIntoView\",\n      scrollTo: \"scrollTo\",\n      scrollToIndex: \"scrollToIndex\"\n    },\n    optional: {\n      alignToBottom: \"alignToBottom\",\n      atBottomThreshold: \"atBottomThreshold\",\n      atTopThreshold: \"atTopThreshold\",\n      components: \"components\",\n      computeItemKey: \"computeItemKey\",\n      context: \"context\",\n      customScrollParent: \"customScrollParent\",\n      data: \"data\",\n      defaultItemHeight: \"defaultItemHeight\",\n      firstItemIndex: \"firstItemIndex\",\n      fixedFooterContent: \"fixedFooterContent\",\n      fixedHeaderContent: \"fixedHeaderContent\",\n      fixedItemHeight: \"fixedItemHeight\",\n      followOutput: \"followOutput\",\n      groupCounts: \"groupCounts\",\n      increaseViewportBy: \"increaseViewportBy\",\n      initialItemCount: \"initialItemCount\",\n      initialScrollTop: \"initialScrollTop\",\n      initialTopMostItemIndex: \"initialTopMostItemIndex\",\n      itemContent: \"itemContent\",\n      itemSize: \"itemSize\",\n      logLevel: \"logLevel\",\n      overscan: \"overscan\",\n      restoreStateFrom: \"restoreStateFrom\",\n      scrollerRef: \"scrollerRef\",\n      scrollSeekConfiguration: \"scrollSeekConfiguration\",\n      topItemCount: \"topItemCount\",\n      totalCount: \"totalCount\",\n      useWindowScroll: \"useWindowScroll\"\n    },\n    required: {}\n  },\n  yr\n), br = /* @__PURE__ */ Ze({ useEmitter: Qe, useEmitterValue: _, usePublisher: Tt }), Rr = /* @__PURE__ */ Xe({ useEmitter: Qe, useEmitterValue: _, usePublisher: Tt }), qr = vr, wn = {\n  bottom: 0,\n  itemHeight: 0,\n  items: [],\n  itemWidth: 0,\n  offsetBottom: 0,\n  offsetTop: 0,\n  top: 0\n}, Hr = {\n  bottom: 0,\n  itemHeight: 0,\n  items: [{ index: 0 }],\n  itemWidth: 0,\n  offsetBottom: 0,\n  offsetTop: 0,\n  top: 0\n}, { ceil: yn, floor: Ce, max: ee, min: Fe, round: vn } = Math;\nfunction bn(t, e, n) {\n  return Array.from({ length: e - t + 1 }).map((o, r) => ({ data: n === null ? null : n[r + t], index: r + t }));\n}\nfunction Er(t) {\n  return {\n    ...Hr,\n    items: t\n  };\n}\nfunction he(t, e) {\n  return t && t.width === e.width && t.height === e.height;\n}\nfunction kr(t, e) {\n  return t && t.column === e.column && t.row === e.row;\n}\nconst Br = /* @__PURE__ */ U(\n  ([\n    { increaseViewportBy: t, listBoundary: e, overscan: n, visibleRange: o },\n    { footerHeight: r, headerHeight: s, scrollBy: i, scrollContainerState: l, scrollTo: c, scrollTop: u, smoothScrollTargetReached: f, viewportHeight: S },\n    p,\n    m,\n    { didMount: w, propsReady: I },\n    { customScrollParent: C, useWindowScroll: g, windowScrollContainerState: a, windowScrollTo: T, windowViewportRect: b },\n    h\n  ]) => {\n    const d = y(0), R = y(0), B = y(wn), O = y({ height: 0, width: 0 }), L = y({ height: 0, width: 0 }), V = $(), D = $(), J = y(0), nt = y(null), k = y({ column: 0, row: 0 }), q = $(), st = $(), dt = y(!1), St = y(0), ft = y(!0), ut = y(!1), At = y(!1);\n    K(\n      x(\n        w,\n        G(St),\n        P(([v, N]) => !!N)\n      ),\n      () => {\n        W(ft, !1);\n      }\n    ), K(\n      x(\n        rt(w, ft, L, O, St, ut),\n        P(([v, N, Q, it, , tt]) => v && !N && Q.height !== 0 && it.height !== 0 && !tt)\n      ),\n      ([, , , , v]) => {\n        W(ut, !0), $e(1, () => {\n          W(V, v);\n        }), Rt(x(u), () => {\n          W(e, [0, 0]), W(ft, !0);\n        });\n      }\n    ), F(\n      x(\n        st,\n        P((v) => v != null && v.scrollTop > 0),\n        vt(0)\n      ),\n      R\n    ), K(\n      x(\n        w,\n        G(st),\n        P(([, v]) => v != null)\n      ),\n      ([, v]) => {\n        v && (W(O, v.viewport), W(L, v.item), W(k, v.gap), v.scrollTop > 0 && (W(dt, !0), Rt(x(u, jt(1)), (N) => {\n          W(dt, !1);\n        }), W(c, { top: v.scrollTop })));\n      }\n    ), F(\n      x(\n        O,\n        E(({ height: v }) => v)\n      ),\n      S\n    ), F(\n      x(\n        rt(\n          A(O, he),\n          A(L, he),\n          A(k, (v, N) => v && v.column === N.column && v.row === N.row),\n          A(u)\n        ),\n        E(([v, N, Q, it]) => ({\n          gap: Q,\n          item: N,\n          scrollTop: it,\n          viewport: v\n        }))\n      ),\n      q\n    ), F(\n      x(\n        rt(\n          A(d),\n          o,\n          A(k, kr),\n          A(L, he),\n          A(O, he),\n          A(nt),\n          A(R),\n          A(dt),\n          A(ft),\n          A(St)\n        ),\n        P(([, , , , , , , v]) => !v),\n        E(\n          ([\n            v,\n            [N, Q],\n            it,\n            tt,\n            Bt,\n            Jt,\n            Nt,\n            ,\n            de,\n            Ot\n          ]) => {\n            const { column: Ft, row: Qt } = it, { height: fe, width: He } = tt, { width: tn } = Bt;\n            if (Nt === 0 && (v === 0 || tn === 0))\n              return wn;\n            if (He === 0) {\n              const sn = Ue(Ot, v), so = sn + Math.max(Nt - 1, 0);\n              return Er(bn(sn, so, Jt));\n            }\n            const me = no(tn, He, Ft);\n            let Dt, Wt;\n            de ? N === 0 && Q === 0 && Nt > 0 ? (Dt = 0, Wt = Nt - 1) : (Dt = me * Ce((N + Qt) / (fe + Qt)), Wt = me * yn((Q + Qt) / (fe + Qt)) - 1, Wt = Fe(v - 1, ee(Wt, me - 1)), Dt = Fe(Wt, ee(0, Dt))) : (Dt = 0, Wt = -1);\n            const en = bn(Dt, Wt, Jt), { bottom: nn, top: on } = Rn(Bt, it, tt, en), rn = yn(v / me), ro = rn * fe + (rn - 1) * Qt - nn;\n            return { bottom: nn, itemHeight: fe, items: en, itemWidth: He, offsetBottom: ro, offsetTop: on, top: on };\n          }\n        )\n      ),\n      B\n    ), F(\n      x(\n        nt,\n        P((v) => v !== null),\n        E((v) => v.length)\n      ),\n      d\n    ), F(\n      x(\n        rt(O, L, B, k),\n        P(([v, N, { items: Q }]) => Q.length > 0 && N.height !== 0 && v.height !== 0),\n        E(([v, N, { items: Q }, it]) => {\n          const { bottom: tt, top: Bt } = Rn(v, it, N, Q);\n          return [Bt, tt];\n        }),\n        Y(se)\n      ),\n      e\n    );\n    const xt = y(!1);\n    F(\n      x(\n        u,\n        G(xt),\n        E(([v, N]) => N || v !== 0)\n      ),\n      xt\n    );\n    const Xt = pt(\n      x(\n        rt(B, d),\n        P(([{ items: v }]) => v.length > 0),\n        G(xt),\n        P(([[v, N], Q]) => {\n          const tt = v.items[v.items.length - 1].index === N - 1;\n          return (Q || v.bottom > 0 && v.itemHeight > 0 && v.offsetBottom === 0 && v.items.length === N) && tt;\n        }),\n        E(([[, v]]) => v - 1),\n        Y()\n      )\n    ), Mt = pt(\n      x(\n        A(B),\n        P(({ items: v }) => v.length > 0 && v[0].index === 0),\n        vt(0),\n        Y()\n      )\n    ), yt = pt(\n      x(\n        A(B),\n        G(dt),\n        P(([{ items: v }, N]) => v.length > 0 && !N),\n        E(([{ items: v }]) => ({\n          endIndex: v[v.length - 1].index,\n          startIndex: v[0].index\n        })),\n        Y(An),\n        Lt(0)\n      )\n    );\n    F(yt, m.scrollSeekRangeChanged), F(\n      x(\n        V,\n        G(O, L, d, k),\n        E(([v, N, Q, it, tt]) => {\n          const Bt = Nn(v), { align: Jt, behavior: Nt, offset: de } = Bt;\n          let Ot = Bt.index;\n          Ot === \"LAST\" && (Ot = it - 1), Ot = ee(0, Ot, Fe(it - 1, Ot));\n          let Ft = Ae(N, tt, Q, Ot);\n          return Jt === \"end\" ? Ft = vn(Ft - N.height + Q.height) : Jt === \"center\" && (Ft = vn(Ft - N.height / 2 + Q.height / 2)), de && (Ft += de), { behavior: Nt, top: Ft };\n        })\n      ),\n      c\n    );\n    const kt = ct(\n      x(\n        B,\n        E((v) => v.offsetBottom + v.bottom)\n      ),\n      0\n    );\n    return F(\n      x(\n        b,\n        E((v) => ({ height: v.visibleHeight, width: v.visibleWidth }))\n      ),\n      O\n    ), {\n      customScrollParent: C,\n      // input\n      data: nt,\n      deviation: J,\n      footerHeight: r,\n      gap: k,\n      headerHeight: s,\n      increaseViewportBy: t,\n      initialItemCount: R,\n      itemDimensions: L,\n      overscan: n,\n      restoreStateFrom: st,\n      scrollBy: i,\n      scrollContainerState: l,\n      scrollHeight: D,\n      scrollTo: c,\n      scrollToIndex: V,\n      scrollTop: u,\n      smoothScrollTargetReached: f,\n      totalCount: d,\n      useWindowScroll: g,\n      viewportDimensions: O,\n      windowScrollContainerState: a,\n      windowScrollTo: T,\n      windowViewportRect: b,\n      ...m,\n      // output\n      gridState: B,\n      horizontalDirection: At,\n      initialTopMostItemIndex: St,\n      totalListHeight: kt,\n      ...p,\n      endReached: Xt,\n      propsReady: I,\n      rangeChanged: yt,\n      startReached: Mt,\n      stateChanged: q,\n      stateRestoreInProgress: dt,\n      ...h\n    };\n  },\n  X(Ke, at, ae, Kn, Pt, je, Vt)\n);\nfunction no(t, e, n) {\n  return ee(1, Ce((t + n) / (Ce(e) + n)));\n}\nfunction Rn(t, e, n, o) {\n  const { height: r } = n;\n  if (r === void 0 || o.length === 0)\n    return { bottom: 0, top: 0 };\n  const s = Ae(t, e, n, o[0].index);\n  return { bottom: Ae(t, e, n, o[o.length - 1].index) + r, top: s };\n}\nfunction Ae(t, e, n, o) {\n  const r = no(t.width, n.width, e.column), s = Ce(o / r), i = s * n.height + ee(0, s - 1) * e.row;\n  return i > 0 ? i + e.row : i;\n}\nconst Or = /* @__PURE__ */ U(() => {\n  const t = y((S) => `Item ${S}`), e = y({}), n = y(null), o = y(\"virtuoso-grid-item\"), r = y(\"virtuoso-grid-list\"), s = y(Ye), i = y(\"div\"), l = y(Yt), c = (S, p = null) => ct(\n    x(\n      e,\n      E((m) => m[S]),\n      Y()\n    ),\n    p\n  ), u = y(!1), f = y(!1);\n  return F(A(f), u), {\n    components: e,\n    computeItemKey: s,\n    context: n,\n    FooterComponent: c(\"Footer\"),\n    HeaderComponent: c(\"Header\"),\n    headerFooterTag: i,\n    itemClassName: o,\n    ItemComponent: c(\"Item\", \"div\"),\n    itemContent: t,\n    listClassName: r,\n    ListComponent: c(\"List\", \"div\"),\n    readyStateChanged: u,\n    reportReadyState: f,\n    ScrollerComponent: c(\"Scroller\", \"div\"),\n    scrollerRef: l,\n    ScrollSeekPlaceholder: c(\"ScrollSeekPlaceholder\", \"div\")\n  };\n}), Fr = /* @__PURE__ */ U(\n  ([t, e]) => ({ ...t, ...e }),\n  X(Br, Or)\n), Lr = /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_1__.memo(function() {\n  const e = et(\"gridState\"), n = et(\"listClassName\"), o = et(\"itemClassName\"), r = et(\"itemContent\"), s = et(\"computeItemKey\"), i = et(\"isSeeking\"), l = It(\"scrollHeight\"), c = et(\"ItemComponent\"), u = et(\"ListComponent\"), f = et(\"ScrollSeekPlaceholder\"), S = et(\"context\"), p = It(\"itemDimensions\"), m = It(\"gap\"), w = et(\"log\"), I = et(\"stateRestoreInProgress\"), C = It(\"reportReadyState\"), g = Ht(\n    react__WEBPACK_IMPORTED_MODULE_1__.useMemo(\n      () => (a) => {\n        const T = a.parentElement.parentElement.scrollHeight;\n        l(T);\n        const b = a.firstChild;\n        if (b) {\n          const { height: h, width: d } = b.getBoundingClientRect();\n          p({ height: h, width: d });\n        }\n        m({\n          column: Hn(\"column-gap\", getComputedStyle(a).columnGap, w),\n          row: Hn(\"row-gap\", getComputedStyle(a).rowGap, w)\n        });\n      },\n      [l, p, m, w]\n    ),\n    !0,\n    !1\n  );\n  return Zn(() => {\n    e.itemHeight > 0 && e.itemWidth > 0 && C(!0);\n  }, [e]), I ? null : /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\n    u,\n    {\n      className: n,\n      ref: g,\n      ...Z(u, S),\n      \"data-testid\": \"virtuoso-item-list\",\n      style: { paddingBottom: e.offsetBottom, paddingTop: e.offsetTop },\n      children: e.items.map((a) => {\n        const T = s(a.index, a.data, S);\n        return i ? /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\n          f,\n          {\n            ...Z(f, S),\n            height: e.itemHeight,\n            index: a.index,\n            width: e.itemWidth\n          },\n          T\n        ) : /* @__PURE__ */ (0,react__WEBPACK_IMPORTED_MODULE_1__.createElement)(\n          c,\n          {\n            ...Z(c, S),\n            className: o,\n            \"data-index\": a.index,\n            key: T\n          },\n          r(a.index, a.data, S)\n        );\n      })\n    }\n  );\n}), zr = react__WEBPACK_IMPORTED_MODULE_1__.memo(function() {\n  const e = et(\"HeaderComponent\"), n = It(\"headerHeight\"), o = et(\"headerFooterTag\"), r = Ht(\n    react__WEBPACK_IMPORTED_MODULE_1__.useMemo(\n      () => (i) => {\n        n(wt(i, \"height\"));\n      },\n      [n]\n    ),\n    !0,\n    !1\n  ), s = et(\"context\");\n  return e ? /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(o, { ref: r, children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(e, { ...Z(e, s) }) }) : null;\n}), Vr = react__WEBPACK_IMPORTED_MODULE_1__.memo(function() {\n  const e = et(\"FooterComponent\"), n = It(\"footerHeight\"), o = et(\"headerFooterTag\"), r = Ht(\n    react__WEBPACK_IMPORTED_MODULE_1__.useMemo(\n      () => (i) => {\n        n(wt(i, \"height\"));\n      },\n      [n]\n    ),\n    !0,\n    !1\n  ), s = et(\"context\");\n  return e ? /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(o, { ref: r, children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(e, { ...Z(e, s) }) }) : null;\n}), Pr = ({ children: t }) => {\n  const e = react__WEBPACK_IMPORTED_MODULE_1__.useContext(Yn), n = It(\"itemDimensions\"), o = It(\"viewportDimensions\"), r = Ht(\n    react__WEBPACK_IMPORTED_MODULE_1__.useMemo(\n      () => (s) => {\n        o(s.getBoundingClientRect());\n      },\n      [o]\n    ),\n    !0,\n    !1\n  );\n  return react__WEBPACK_IMPORTED_MODULE_1__.useEffect(() => {\n    e && (o({ height: e.viewportHeight, width: e.viewportWidth }), n({ height: e.itemHeight, width: e.itemWidth }));\n  }, [e, o, n]), /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"div\", { ref: r, style: Zt(!1), children: t });\n}, Ar = ({ children: t }) => {\n  const e = react__WEBPACK_IMPORTED_MODULE_1__.useContext(Yn), n = It(\"windowViewportRect\"), o = It(\"itemDimensions\"), r = et(\"customScrollParent\"), s = Ge(n, r, !1);\n  return react__WEBPACK_IMPORTED_MODULE_1__.useEffect(() => {\n    e && (o({ height: e.itemHeight, width: e.itemWidth }), n({ offsetTop: 0, visibleHeight: e.viewportHeight, visibleWidth: e.viewportWidth }));\n  }, [e, n, o]), /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"div\", { ref: s, style: Zt(!1), children: t });\n}, Mr = /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_1__.memo(function({ ...e }) {\n  const n = et(\"useWindowScroll\"), o = et(\"customScrollParent\"), r = o || n ? Gr : _r, s = o || n ? Ar : Pr, i = et(\"context\");\n  return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(r, { ...e, ...Z(r, i), children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(s, { children: [\n    /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(zr, {}),\n    /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(Lr, {}),\n    /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(Vr, {})\n  ] }) });\n}), {\n  Component: Wr,\n  useEmitter: oo,\n  useEmitterValue: et,\n  usePublisher: It\n} = /* @__PURE__ */ qe(\n  Fr,\n  {\n    events: {\n      atBottomStateChange: \"atBottomStateChange\",\n      atTopStateChange: \"atTopStateChange\",\n      endReached: \"endReached\",\n      isScrolling: \"isScrolling\",\n      rangeChanged: \"rangeChanged\",\n      readyStateChanged: \"readyStateChanged\",\n      startReached: \"startReached\",\n      stateChanged: \"stateChanged\"\n    },\n    methods: {\n      scrollBy: \"scrollBy\",\n      scrollTo: \"scrollTo\",\n      scrollToIndex: \"scrollToIndex\"\n    },\n    optional: {\n      components: \"components\",\n      computeItemKey: \"computeItemKey\",\n      context: \"context\",\n      customScrollParent: \"customScrollParent\",\n      data: \"data\",\n      headerFooterTag: \"headerFooterTag\",\n      increaseViewportBy: \"increaseViewportBy\",\n      initialItemCount: \"initialItemCount\",\n      initialTopMostItemIndex: \"initialTopMostItemIndex\",\n      itemClassName: \"itemClassName\",\n      itemContent: \"itemContent\",\n      listClassName: \"listClassName\",\n      logLevel: \"logLevel\",\n      overscan: \"overscan\",\n      restoreStateFrom: \"restoreStateFrom\",\n      scrollerRef: \"scrollerRef\",\n      scrollSeekConfiguration: \"scrollSeekConfiguration\",\n      totalCount: \"totalCount\",\n      useWindowScroll: \"useWindowScroll\"\n    }\n  },\n  Mr\n), _r = /* @__PURE__ */ Ze({ useEmitter: oo, useEmitterValue: et, usePublisher: It }), Gr = /* @__PURE__ */ Xe({ useEmitter: oo, useEmitterValue: et, usePublisher: It });\nfunction Hn(t, e, n) {\n  return e !== \"normal\" && !(e != null && e.endsWith(\"px\")) && n(`${t} was not resolved to pixel value correctly`, e, ht.WARN), e === \"normal\" ? 0 : parseInt(e != null ? e : \"0\", 10);\n}\nconst Yr = Wr;\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcmVhY3QtdmlydHVvc28vZGlzdC9pbmRleC5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7OztBQUF5RTtBQUMxQjtBQUNwQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixlQUFlLElBQUksZUFBZTtBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsc0RBQXNEO0FBQ3BHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtKQUFrSjtBQUNsSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSx5Q0FBUTtBQUNwQjtBQUNBO0FBQ0E7QUFDQSxjQUFjLDBDQUFTO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBLFlBQVksOENBQWE7QUFDekI7QUFDQTtBQUNBO0FBQ0EsYUFBYSw2QkFBNkI7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLE9BQU87QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxRUFBcUUsVUFBVTtBQUMvRTtBQUNBO0FBQ0Esc0VBQXNFLHFDQUFxQztBQUMzRztBQUNBO0FBQ0E7QUFDQTtBQUNBLG9FQUFvRSxHQUFHO0FBQ3ZFO0FBQ0E7QUFDQSxZQUFZLHlDQUFRLFlBQVksOENBQWE7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQSxPQUFPLHlCQUF5QixvQkFBb0IsOENBQWE7QUFDakU7QUFDQSxHQUFHO0FBQ0gsU0FBUyw0Q0FBVztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxjQUFjO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLGlCQUFpQjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsSUFBSTtBQUNKLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEscUJBQXFCO0FBQzdCO0FBQ0Esa0JBQWtCLE9BQU87QUFDekIsWUFBWSxxQkFBcUI7QUFDakMsYUFBYSxnQ0FBZ0M7QUFDN0M7QUFDQSxrQkFBa0IsZ0NBQWdDO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrREFBa0QsWUFBWSx5QkFBeUIsa0JBQWtCLGdCQUFnQixrQkFBa0I7QUFDM0k7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSxnQkFBZ0I7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0Isc0JBQXNCO0FBQzlDO0FBQ0EsSUFBSSwrQkFBK0IsYUFBYSxnQkFBZ0IsYUFBYTtBQUM3RTtBQUNBO0FBQ0Esb0NBQW9DLGdCQUFnQjtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUseUJBQXlCO0FBQ25DO0FBQ0EsNEVBQTRFLFlBQVk7QUFDeEY7QUFDQTtBQUNBLFVBQVUscUJBQXFCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLFlBQVk7QUFDcEM7QUFDQTtBQUNBLG1CQUFtQixVQUFVO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBLElBQUk7QUFDSjtBQUNBLHdCQUF3QixZQUFZO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLHNCQUFzQixnQkFBZ0I7QUFDdEMsT0FBTztBQUNQLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyxZQUFZO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsT0FBTztBQUNqQiw0Q0FBNEMsV0FBVyxRQUFRLEdBQUc7QUFDbEU7QUFDQTtBQUNBLFVBQVUsZUFBZTtBQUN6QixvRUFBb0UsV0FBVyxRQUFRLGVBQWU7QUFDdEc7QUFDQTtBQUNBLGtCQUFrQixZQUFZLFFBQVEsb0JBQW9CO0FBQzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLHlCQUF5QjtBQUNwQztBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLFFBQVE7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZEQUE2RCxZQUFZLGlCQUFpQixFQUFFO0FBQzVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLFVBQVU7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLHNDQUFzQztBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLDZCQUE2QjtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxXQUFXO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLCtCQUErQjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLDRCQUE0QjtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQSxVQUFVLDBEQUEwRDtBQUNwRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLFlBQVk7QUFDbEM7QUFDQSxhQUFhO0FBQ2IsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLFNBQVMsT0FBTztBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxlQUFlLHFCQUFxQjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0EsVUFBVSxzQ0FBc0M7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRCxNQUFNLFFBQVEsSUFBSSxxQkFBcUI7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsNkJBQTZCO0FBQ3JEO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsYUFBYSxTQUFTO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsY0FBYztBQUMvQixpQkFBaUIsMkJBQTJCO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IscUNBQXFDO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFVBQVU7QUFDdkI7QUFDQTtBQUNBLFdBQVc7QUFDWCxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QiwyQkFBMkI7QUFDbEQsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLGtCQUFrQjtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsbUJBQW1CO0FBQzdCO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsT0FBTztBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsYUFBYTtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLFlBQVk7QUFDOUI7QUFDQTtBQUNBLHNDQUFzQyxnRUFBZ0U7QUFDdEcsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixlQUFlO0FBQ2hDO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsUUFBUTtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRCxhQUFhO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaLGtEQUFrRCxZQUFZO0FBQzlEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNLDBDQUEwQyxJQUFJLCtCQUErQjtBQUNuRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxHQUFHO0FBQ0g7QUFDQTtBQUNBLE1BQU0sUUFBUTtBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0M7QUFDcEMsS0FBSyxLQUFLO0FBQ1YsR0FBRztBQUNIO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxxQ0FBcUMsV0FBVztBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU0saURBQWlEO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLHFDQUFxQztBQUNwRTtBQUNBO0FBQ0E7QUFDQSxzREFBc0QsYUFBYSxpRkFBaUY7QUFDcEo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBLGVBQWU7QUFDZixjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0EsYUFBYSxrREFBa0Qsa0NBQWtDLGVBQWU7QUFDaEg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNLDhDQUE4QyxJQUFJLGNBQWMsSUFBSSwwQ0FBMEMsSUFBSSxhQUFhO0FBQ3JJO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixhQUFhO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFdBQVc7QUFDWCxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxxQkFBcUIseUdBQXlHO0FBQy9IO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQiwrQkFBK0I7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLGtEQUFrRDtBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsY0FBYztBQUN6QjtBQUNBO0FBQ0EsNEJBQTRCLDJDQUEyQyxJQUFJLDREQUE0RDtBQUN2SSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNLHNGQUFzRjtBQUM1RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsd0RBQXdEO0FBQ2hFLFFBQVE7QUFDUjtBQUNBO0FBQ0EsWUFBWSwrREFBK0Q7QUFDM0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLDJDQUEyQztBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrREFBa0QsV0FBVztBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsa0RBQWtEO0FBQzdFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNLDZEQUE2RDtBQUNuRTtBQUNBLE1BQU0sb0RBQW9EO0FBQzFELE1BQU0sc0RBQXNEO0FBQzVELE1BQU0sa0JBQWtCO0FBQ3hCO0FBQ0EsTUFBTSxhQUFhO0FBQ25CLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQiwrQkFBK0I7QUFDMUQ7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQSxrQ0FBa0MsdUJBQXVCO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyxVQUFVO0FBQzNDLDRCQUE0QixrRUFBa0U7QUFDOUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsdUJBQXVCO0FBQ3hELDRCQUE0QixpRUFBaUU7QUFDN0Y7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsVUFBVTtBQUN2QjtBQUNBLGNBQWMsVUFBVTtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSx1QkFBdUI7QUFDcEMsYUFBYSxVQUFVO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFVBQVU7QUFDdkIsYUFBYSxVQUFVO0FBQ3ZCO0FBQ0EsaUJBQWlCLGdDQUFnQztBQUNqRDtBQUNBLGlCQUFpQixnQ0FBZ0M7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsTUFBTSw4RUFBOEUsSUFBSSxjQUFjO0FBQ3RHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCLEdBQUc7QUFDSDtBQUNBLElBQUk7QUFDSjtBQUNBLE1BQU0sbUJBQW1CLElBQUksb0JBQW9CO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLEdBQUc7QUFDSDtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNLCtCQUErQjtBQUNyQyxNQUFNLGlDQUFpQztBQUN2QyxNQUFNLGtCQUFrQjtBQUN4QixNQUFNLDBCQUEwQjtBQUNoQyxNQUFNLDRCQUE0QjtBQUNsQyxNQUFNLFFBQVE7QUFDZCxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJEQUEyRDtBQUMzRCxTQUFTO0FBQ1QsYUFBYSxpQkFBaUI7QUFDOUI7QUFDQSxTQUFTLHdDQUF3QztBQUNqRDtBQUNBLDBDQUEwQyxlQUFlO0FBQ3pELFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFJQUFxSTtBQUNySSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFVBQVUsZUFBZSw4QkFBOEI7QUFDcEUsWUFBWTtBQUNaO0FBQ0EsYUFBYSxjQUFjO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSyxLQUFLO0FBQ1YsR0FBRztBQUNIO0FBQ0E7QUFDQSxNQUFNLDhDQUE4QyxJQUFJLDRCQUE0QixJQUFJLG1DQUFtQyxJQUFJLGFBQWE7QUFDNUk7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLElBQUk7QUFDSjtBQUNBLE1BQU0sYUFBYSxJQUFJLGFBQWEsSUFBSSxjQUFjO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixRQUFRO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQiw2QkFBNkI7QUFDakQ7QUFDQTtBQUNBLENBQUMsZUFBZSxvREFBb0QsWUFBWSxrREFBa0Q7QUFDbEk7QUFDQSxNQUFNLGlDQUFpQztBQUN2QyxNQUFNLHNIQUFzSDtBQUM1SCxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixzRUFBc0U7QUFDeEY7QUFDQTtBQUNBLDhCQUE4Qiw2QkFBNkI7QUFDM0Q7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxJQUFJO0FBQ0o7QUFDQSxNQUFNLG1CQUFtQjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixvQkFBb0I7QUFDdEM7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxHQUFHO0FBQ0g7QUFDQSxJQUFJO0FBQ0osY0FBYyxzQ0FBc0M7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLGtEQUFrRCxJQUFJLGNBQWM7QUFDaEY7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsY0FBYztBQUM3QjtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBLE1BQU0seUJBQXlCO0FBQy9CLE1BQU0sK0JBQStCO0FBQ3JDLE1BQU0sNEJBQTRCO0FBQ2xDLE1BQU0sYUFBYTtBQUNuQixNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0ZBQXNGLHlCQUF5QjtBQUMvRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBLGlCQUFpQixvQkFBb0I7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixXQUFXO0FBQ3ZDO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU0saUVBQWlFO0FBQ3ZFLE1BQU0sK0VBQStFO0FBQ3JGLE1BQU0sY0FBYztBQUNwQixNQUFNLDREQUE0RDtBQUNsRSxNQUFNLFFBQVE7QUFDZCxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLHFEQUFxRDtBQUNoRjtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNFQUFzRSxXQUFXO0FBQ2pGO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQiwyQkFBMkIsK0JBQStCLDJCQUEyQjtBQUMzRztBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsU0FBUztBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsMkNBQTJDO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixPQUFPO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsUUFBUTtBQUN6QjtBQUNBLFdBQVc7QUFDWCxTQUFTO0FBQ1Q7QUFDQSxTQUFTO0FBQ1QsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsTUFBTSwwRkFBMEY7QUFDaEc7QUFDQTtBQUNBO0FBQ0EsTUFBTSx3Q0FBd0M7QUFDOUMsTUFBTSxrQkFBa0I7QUFDeEI7QUFDQSxNQUFNLGlCQUFpQjtBQUN2QixNQUFNLGdCQUFnQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBLFNBQVMsT0FBTztBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLGtEQUFpQixHQUFHLDRDQUFXO0FBQ2xFO0FBQ0Esd0NBQXdDLG1DQUFtQyxrQ0FBa0MsaUNBQWlDLE9BQU8sZ0RBQWUsR0FBRztBQUN2SztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSyxRQUFRO0FBQ2I7QUFDQTtBQUNBLGdFQUFnRTtBQUNoRTtBQUNBLFlBQVksNkNBQVk7QUFDeEIsWUFBWSxvQkFBb0IsV0FBVywyQ0FBVTtBQUNyRDtBQUNBLEtBQUssVUFBVSwyQ0FBVTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLLEdBQUcsc0RBQXFCO0FBQzdCO0FBQ0EsMkJBQTJCLHNEQUFDLGVBQWUsd0NBQXdDLHNEQUFDLE1BQU0sMkNBQTJDLE9BQU87QUFDNUksR0FBRyxjQUFjLDhDQUFhLE9BQU8sNkNBQVk7QUFDakQsY0FBYyw2Q0FBWSxZQUFZLDhDQUFhO0FBQ25EO0FBQ0E7QUFDQTtBQUNBLFdBQVcsdURBQXNCO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILGNBQWMsNkNBQVksaUJBQWlCLDJDQUFVO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsR0FBRyxNQUFNLDBDQUFTO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQiw2Q0FBWTtBQUM1QjtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsZ0RBQWUsZUFBZSxnREFBZSx1Q0FBdUMsa0RBQWlCLEdBQUcsNENBQVc7QUFDOUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLHlDQUFRLFlBQVkseUNBQVEsWUFBWSx5Q0FBUSxZQUFZLDhDQUFhO0FBQ3JGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxrQ0FBa0MsZ0RBQVk7QUFDOUMsS0FBSztBQUNMO0FBQ0E7QUFDQSxFQUFFLDRDQUFXO0FBQ2I7QUFDQSxrQ0FBa0Msa0NBQWtDLHFDQUFxQyxhQUFhO0FBQ3RIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSxrREFBa0Q7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLLHdDQUF3QyxtQ0FBbUM7QUFDaEY7QUFDQTtBQUNBLGdCQUFnQixtQ0FBbUM7QUFDbkQ7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLEVBQUUsdUNBQXVDLEVBQUUsWUFBWTtBQUNwRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRCxpQkFBaUIsWUFBWTtBQUM3QjtBQUNBLFdBQVcsV0FBVyxxQkFBcUIsc0RBQUMsVUFBVSxTQUFTLGFBQWEsVUFBVSxtREFBbUQsU0FBUyx3QkFBd0IsU0FBUyxnREFBZ0QsdUJBQXVCLHVDQUFNLFlBQVkscUJBQXFCO0FBQ2pTLDJXQUEyVyxpQkFBaUI7QUFDNVg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYywyQ0FBVTtBQUN4QjtBQUNBO0FBQ0EsR0FBRztBQUNILCtTQUErUztBQUMvUztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxjQUFjLElBQUk7QUFDbEI7QUFDQSx5REFBeUQsc0RBQUMsTUFBTSxZQUFZLG9CQUFvQixzREFBQztBQUNqRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLG9EQUFFO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDLElBQUk7QUFDM0M7QUFDQSxpREFBaUQsb0RBQUU7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBLDRCQUE0QixvREFBRTtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLDJDQUEyQztBQUN0RCxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBLDJCQUEyQix1Q0FBTTtBQUNqQztBQUNBLElBQUksMENBQVM7QUFDYjtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsc0RBQUMsTUFBTSxrQ0FBa0Msc0RBQUMsTUFBTSxZQUFZLEdBQUc7QUFDNUYsQ0FBQyx3QkFBd0IsdUNBQU07QUFDL0I7QUFDQSxJQUFJLDBDQUFTO0FBQ2I7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLHNEQUFDLE1BQU0sa0NBQWtDLHNEQUFDLE1BQU0sWUFBWSxHQUFHO0FBQzVGLENBQUM7QUFDRCxjQUFjLG9EQUFvRDtBQUNsRSxTQUFTLHVDQUFNLFlBQVksNkJBQTZCO0FBQ3hELHVMQUF1TCwyREFBMkQ7QUFDbFA7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrREFBK0Qsc0RBQUM7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixzQkFBc0I7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsY0FBYyxvREFBb0Q7QUFDbEUsU0FBUyx1Q0FBTSxZQUFZLDZCQUE2QjtBQUN4RCxnTkFBZ04seUNBQVEsZ0NBQWdDLDJEQUEyRDtBQUNuVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSyxxRUFBcUUsc0RBQUM7QUFDM0U7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsMkNBQTJDLGdCQUFnQixNQUFNO0FBQ2xGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxjQUFjLGFBQWE7QUFDM0IsWUFBWSw2Q0FBWSxxSEFBcUgsMENBQVM7QUFDdEo7QUFDQTtBQUNBO0FBQ0EsU0FBUyw0Q0FBVztBQUNwQjtBQUNBLEdBQUcsOEJBQThCLHNEQUFDLFVBQVUsb0VBQW9FO0FBQ2hILENBQUMsVUFBVSxhQUFhO0FBQ3hCLFlBQVksNkNBQVk7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLDRDQUFXO0FBQ3BCLCtCQUErQixrRUFBa0U7QUFDakcsR0FBRyw4QkFBOEIsc0RBQUMsVUFBVSxtRUFBbUU7QUFDL0csQ0FBQyxVQUFVLGFBQWE7QUFDeEIsNkVBQTZFLHFCQUFxQixFQUFFLEtBQUs7QUFDekcseUJBQXlCLHNEQUFDLE1BQU0sbUNBQW1DO0FBQ25FLENBQUMsdUJBQXVCLHVDQUFNO0FBQzlCO0FBQ0EseUJBQXlCLHVEQUFFLE1BQU07QUFDakMseUJBQXlCLHNEQUFDLE9BQU8sMEJBQTBCLHNEQUFDLE9BQU8saUJBQWlCLEdBQUc7QUFDdkYsb0JBQW9CLHVEQUFFLE1BQU07QUFDNUIsc0JBQXNCLHNEQUFDLE9BQU87QUFDOUIsc0JBQXNCLHNEQUFDLE9BQU87QUFDOUIsc0JBQXNCLHNEQUFDLE9BQU87QUFDOUIsT0FBTztBQUNQLEtBQUs7QUFDTCxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxHQUFHO0FBQ0g7QUFDQSw2QkFBNkIsc0RBQXNELDZCQUE2QixzREFBc0Q7QUFDdEsscUNBQXFDLHVEQUFFLFNBQVM7QUFDaEQ7QUFDQTtBQUNBLEtBQUssbURBQW1EO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNELGlCQUFpQixZQUFZO0FBQzdCO0FBQ0EsV0FBVyxXQUFXLHFCQUFxQixzREFBQyxTQUFTLDBCQUEwQixzREFBQyxTQUFTLFNBQVMsYUFBYSxHQUFHLFdBQVcsV0FBVyxxQkFBcUIsc0RBQUMsU0FBUywwQkFBMEIsc0RBQUMsU0FBUyxTQUFTLG9DQUFvQyxHQUFHLFVBQVUsd0JBQXdCLHVCQUF1Qix1Q0FBTSxZQUFZLHFCQUFxQjtBQUMzVjtBQUNBO0FBQ0EsK0JBQStCLG9EQUFFO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0Isb0RBQUU7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixvRUFBb0U7QUFDekYsT0FBTztBQUNQO0FBQ0E7QUFDQSxHQUFHO0FBQ0gseUJBQXlCLHNEQUFDLENBQUMsdURBQUUsSUFBSSxhQUFhO0FBQzlDLENBQUMsd0JBQXdCLHVDQUFNO0FBQy9CLG9TQUFvUyx5QkFBeUI7QUFDN1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYywyQ0FBVTtBQUN4QjtBQUNBLCtDQUErQyxFQUFFO0FBQ2pELEdBQUc7QUFDSDtBQUNBO0FBQ0EsMkJBQTJCLHNEQUFDLE1BQU0sWUFBWTtBQUM5QyxnSkFBZ0osc0RBQUMsTUFBTSx1QkFBdUIscURBQXFELHNEQUFDLE1BQU0sdUJBQXVCO0FBQ2pRLHlCQUF5Qix1REFBRSxNQUFNO0FBQ2pDO0FBQ0EseUJBQXlCLHNEQUFDLE9BQU8saUJBQWlCO0FBQ2xELG9CQUFvQixzREFBQyxPQUFPO0FBQzVCO0FBQ0EsS0FBSztBQUNMLENBQUMsV0FBVyxhQUFhO0FBQ3pCLFlBQVksNkNBQVk7QUFDeEIsSUFBSSwwQ0FBUztBQUNiO0FBQ0E7QUFDQTtBQUNBLFNBQVMsNENBQVc7QUFDcEI7QUFDQSxHQUFHLDhCQUE4QixzREFBQyxVQUFVLHFFQUFxRTtBQUNqSCxDQUFDLFVBQVUsYUFBYTtBQUN4QixZQUFZLDZDQUFZO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUyw0Q0FBVztBQUNwQiwrQkFBK0Isa0VBQWtFO0FBQ2pHLEdBQUcsOEJBQThCLHNEQUFDLFVBQVUsb0VBQW9FO0FBQ2hILENBQUMsdUJBQXVCLHVDQUFNO0FBQzlCO0FBQ0EsSUFBSSwwQ0FBUztBQUNiO0FBQ0E7QUFDQTtBQUNBLElBQUksMENBQVM7QUFDYjtBQUNBO0FBQ0EsOEpBQThKLHNEQUFDO0FBQy9KO0FBQ0E7QUFDQTtBQUNBLGVBQWUsdUNBQXVDO0FBQ3REO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxvQ0FBb0Msc0RBQUM7QUFDckM7QUFDQTtBQUNBO0FBQ0EsZUFBZSwwQ0FBMEM7QUFDekQ7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EseUJBQXlCLHNEQUFDLE1BQU0sNENBQTRDLHNEQUFDLE1BQU0sMEJBQTBCLHVEQUFFLE1BQU0sU0FBUywwQ0FBMEM7QUFDeEs7QUFDQSxvQkFBb0Isc0RBQUMsT0FBTztBQUM1QjtBQUNBLEtBQUssR0FBRyxHQUFHO0FBQ1gsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsR0FBRztBQUNIO0FBQ0EsNkJBQTZCLHNEQUFzRCw2QkFBNkIsc0RBQXNEO0FBQ3RLO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxZQUFZLFVBQVU7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLElBQUksbURBQW1EO0FBQ3hEO0FBQ0Esc0JBQXNCLG1CQUFtQixtQkFBbUIsa0RBQWtEO0FBQzlHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU0sc0VBQXNFO0FBQzVFLE1BQU0sb0pBQW9KO0FBQzFKO0FBQ0E7QUFDQSxNQUFNLDRCQUE0QjtBQUNsQyxNQUFNLG9IQUFvSDtBQUMxSDtBQUNBO0FBQ0EsaURBQWlELHFCQUFxQixXQUFXLHFCQUFxQixxREFBcUQsbUJBQW1CO0FBQzlLO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVMsVUFBVSxrQkFBa0I7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFdBQVc7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixzQkFBc0IsUUFBUSx3QkFBd0IsUUFBUSxZQUFZO0FBQzlGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QyxzQkFBc0I7QUFDL0QscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsVUFBVTtBQUM5QixvQkFBb0IsVUFBVTtBQUM5QixrQkFBa0Isc0JBQXNCO0FBQ3hDO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxVQUFVO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsVUFBVTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsVUFBVTtBQUN4QixjQUFjLFVBQVU7QUFDeEI7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsc0NBQXNDO0FBQ3BFO0FBQ0E7QUFDQTtBQUNBLHdKQUF3SjtBQUN4SixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsZ0RBQWdEO0FBQ3BFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsWUFBWTtBQUN0QjtBQUNBLGFBQWE7QUFDYjtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsRUFBRSxZQUFZO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNELGlCQUFpQixZQUFZO0FBQzdCO0FBQ0Esd0JBQXdCLHVDQUFNO0FBQzlCO0FBQ0EsSUFBSSwwQ0FBUztBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0Isc0JBQXNCO0FBQ3hDLGNBQWMscUJBQXFCO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUcsbUNBQW1DLHNEQUFDO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsd0RBQXdEO0FBQ3ZFO0FBQ0E7QUFDQSxtQ0FBbUMsc0RBQUM7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0EsNEJBQTRCLG9EQUFFO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxDQUFDLFFBQVEsdUNBQU07QUFDZjtBQUNBLElBQUksMENBQVM7QUFDYjtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsc0RBQUMsTUFBTSxrQ0FBa0Msc0RBQUMsTUFBTSxZQUFZLEdBQUc7QUFDNUYsQ0FBQyxRQUFRLHVDQUFNO0FBQ2Y7QUFDQSxJQUFJLDBDQUFTO0FBQ2I7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLHNEQUFDLE1BQU0sa0NBQWtDLHNEQUFDLE1BQU0sWUFBWSxHQUFHO0FBQzVGLENBQUMsV0FBVyxhQUFhO0FBQ3pCLFlBQVksNkNBQVk7QUFDeEIsSUFBSSwwQ0FBUztBQUNiO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVMsNENBQVc7QUFDcEIsY0FBYyxrREFBa0QsT0FBTywwQ0FBMEM7QUFDakgsR0FBRyw4QkFBOEIsc0RBQUMsVUFBVSxvQ0FBb0M7QUFDaEYsQ0FBQyxVQUFVLGFBQWE7QUFDeEIsWUFBWSw2Q0FBWTtBQUN4QixTQUFTLDRDQUFXO0FBQ3BCLGNBQWMsMENBQTBDLE9BQU8sOEVBQThFO0FBQzdJLEdBQUcsOEJBQThCLHNEQUFDLFVBQVUsb0NBQW9DO0FBQ2hGLENBQUMsdUJBQXVCLHVDQUFNLFlBQVksTUFBTTtBQUNoRDtBQUNBLHlCQUF5QixzREFBQyxNQUFNLDRDQUE0Qyx1REFBRSxNQUFNO0FBQ3BGLG9CQUFvQixzREFBQyxPQUFPO0FBQzVCLG9CQUFvQixzREFBQyxPQUFPO0FBQzVCLG9CQUFvQixzREFBQyxPQUFPO0FBQzVCLEtBQUssR0FBRztBQUNSLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLDZCQUE2Qix1REFBdUQsNkJBQTZCLHVEQUF1RDtBQUN4SztBQUNBLG9FQUFvRSxHQUFHO0FBQ3ZFO0FBQ0E7QUFTRSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvcmVhY3QtdmlydHVvc28vZGlzdC9pbmRleC5tanM/YjY2MSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBqc3ggYXMgeiwganN4cyBhcyBLdCwgRnJhZ21lbnQgYXMgaW8gfSBmcm9tIFwicmVhY3QvanN4LXJ1bnRpbWVcIjtcbmltcG9ydCBILCB7IGNyZWF0ZUVsZW1lbnQgYXMgJHQgfSBmcm9tIFwicmVhY3RcIjtcbmltcG9ydCBsbyBmcm9tIFwicmVhY3QtZG9tXCI7XG5jb25zdCB3ZSA9IDAsIHp0ID0gMSwgcXQgPSAyLCBFbiA9IDQ7XG5mdW5jdGlvbiBsbih0KSB7XG4gIHJldHVybiAoKSA9PiB0O1xufVxuZnVuY3Rpb24gY28odCkge1xuICB0KCk7XG59XG5mdW5jdGlvbiBuZSh0LCBlKSB7XG4gIHJldHVybiAobikgPT4gdChlKG4pKTtcbn1cbmZ1bmN0aW9uIGNuKHQsIGUpIHtcbiAgcmV0dXJuICgpID0+IHQoZSk7XG59XG5mdW5jdGlvbiBrbih0LCBlKSB7XG4gIHJldHVybiAobikgPT4gdChlLCBuKTtcbn1cbmZ1bmN0aW9uIE1lKHQpIHtcbiAgcmV0dXJuIHQgIT09IHZvaWQgMDtcbn1cbmZ1bmN0aW9uIHVvKC4uLnQpIHtcbiAgcmV0dXJuICgpID0+IHtcbiAgICB0Lm1hcChjbyk7XG4gIH07XG59XG5mdW5jdGlvbiBZdCgpIHtcbn1cbmZ1bmN0aW9uIHllKHQsIGUpIHtcbiAgcmV0dXJuIGUodCksIHQ7XG59XG5mdW5jdGlvbiBhbyh0LCBlKSB7XG4gIHJldHVybiBlKHQpO1xufVxuZnVuY3Rpb24gWCguLi50KSB7XG4gIHJldHVybiB0O1xufVxuZnVuY3Rpb24gSyh0LCBlKSB7XG4gIHJldHVybiB0KHp0LCBlKTtcbn1cbmZ1bmN0aW9uIFcodCwgZSkge1xuICB0KHdlLCBlKTtcbn1cbmZ1bmN0aW9uIFdlKHQpIHtcbiAgdChxdCk7XG59XG5mdW5jdGlvbiBsdCh0KSB7XG4gIHJldHVybiB0KEVuKTtcbn1cbmZ1bmN0aW9uIEYodCwgZSkge1xuICByZXR1cm4gSyh0LCBrbihlLCB3ZSkpO1xufVxuZnVuY3Rpb24gUnQodCwgZSkge1xuICBjb25zdCBuID0gdCh6dCwgKG8pID0+IHtcbiAgICBuKCksIGUobyk7XG4gIH0pO1xuICByZXR1cm4gbjtcbn1cbmZ1bmN0aW9uIHVuKHQpIHtcbiAgbGV0IGUsIG47XG4gIHJldHVybiAobykgPT4gKHIpID0+IHtcbiAgICBlID0gciwgbiAmJiBjbGVhclRpbWVvdXQobiksIG4gPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIG8oZSk7XG4gICAgfSwgdCk7XG4gIH07XG59XG5mdW5jdGlvbiBCbih0LCBlKSB7XG4gIHJldHVybiB0ID09PSBlO1xufVxuZnVuY3Rpb24gWSh0ID0gQm4pIHtcbiAgbGV0IGU7XG4gIHJldHVybiAobikgPT4gKG8pID0+IHtcbiAgICB0KGUsIG8pIHx8IChlID0gbywgbihvKSk7XG4gIH07XG59XG5mdW5jdGlvbiBQKHQpIHtcbiAgcmV0dXJuIChlKSA9PiAobikgPT4ge1xuICAgIHQobikgJiYgZShuKTtcbiAgfTtcbn1cbmZ1bmN0aW9uIEUodCkge1xuICByZXR1cm4gKGUpID0+IG5lKGUsIHQpO1xufVxuZnVuY3Rpb24gdnQodCkge1xuICByZXR1cm4gKGUpID0+ICgpID0+IHtcbiAgICBlKHQpO1xuICB9O1xufVxuZnVuY3Rpb24geCh0LCAuLi5lKSB7XG4gIGNvbnN0IG4gPSBmbyguLi5lKTtcbiAgcmV0dXJuIChvLCByKSA9PiB7XG4gICAgc3dpdGNoIChvKSB7XG4gICAgICBjYXNlIHF0OlxuICAgICAgICBXZSh0KTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgY2FzZSB6dDpcbiAgICAgICAgcmV0dXJuIEsodCwgbihyKSk7XG4gICAgfVxuICB9O1xufVxuZnVuY3Rpb24gYnQodCwgZSkge1xuICByZXR1cm4gKG4pID0+IChvKSA9PiB7XG4gICAgbihlID0gdChlLCBvKSk7XG4gIH07XG59XG5mdW5jdGlvbiBqdCh0KSB7XG4gIHJldHVybiAoZSkgPT4gKG4pID0+IHtcbiAgICB0ID4gMCA/IHQtLSA6IGUobik7XG4gIH07XG59XG5mdW5jdGlvbiBMdCh0KSB7XG4gIGxldCBlID0gbnVsbCwgbjtcbiAgcmV0dXJuIChvKSA9PiAocikgPT4ge1xuICAgIGUgPSByLCAhbiAmJiAobiA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgbiA9IHZvaWQgMCwgbyhlKTtcbiAgICB9LCB0KSk7XG4gIH07XG59XG5mdW5jdGlvbiBHKC4uLnQpIHtcbiAgY29uc3QgZSA9IG5ldyBBcnJheSh0Lmxlbmd0aCk7XG4gIGxldCBuID0gMCwgbyA9IG51bGw7XG4gIGNvbnN0IHIgPSBNYXRoLnBvdygyLCB0Lmxlbmd0aCkgLSAxO1xuICByZXR1cm4gdC5mb3JFYWNoKChzLCBpKSA9PiB7XG4gICAgY29uc3QgbCA9IE1hdGgucG93KDIsIGkpO1xuICAgIEsocywgKGMpID0+IHtcbiAgICAgIGNvbnN0IHUgPSBuO1xuICAgICAgbiA9IG4gfCBsLCBlW2ldID0gYywgdSAhPT0gciAmJiBuID09PSByICYmIG8gJiYgKG8oKSwgbyA9IG51bGwpO1xuICAgIH0pO1xuICB9KSwgKHMpID0+IChpKSA9PiB7XG4gICAgY29uc3QgbCA9ICgpID0+IHtcbiAgICAgIHMoW2ldLmNvbmNhdChlKSk7XG4gICAgfTtcbiAgICBuID09PSByID8gbCgpIDogbyA9IGw7XG4gIH07XG59XG5mdW5jdGlvbiBmbyguLi50KSB7XG4gIHJldHVybiAoZSkgPT4gdC5yZWR1Y2VSaWdodChhbywgZSk7XG59XG5mdW5jdGlvbiBtbyh0KSB7XG4gIGxldCBlLCBuO1xuICBjb25zdCBvID0gKCkgPT4gZSA9PSBudWxsID8gdm9pZCAwIDogZSgpO1xuICByZXR1cm4gZnVuY3Rpb24ociwgcykge1xuICAgIHN3aXRjaCAocikge1xuICAgICAgY2FzZSB6dDpcbiAgICAgICAgcmV0dXJuIHMgPyBuID09PSBzID8gdm9pZCAwIDogKG8oKSwgbiA9IHMsIGUgPSBLKHQsIHMpLCBlKSA6IChvKCksIFl0KTtcbiAgICAgIGNhc2UgcXQ6XG4gICAgICAgIG8oKSwgbiA9IG51bGw7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gIH07XG59XG5mdW5jdGlvbiB5KHQpIHtcbiAgbGV0IGUgPSB0O1xuICBjb25zdCBuID0gJCgpO1xuICByZXR1cm4gKG8sIHIpID0+IHtcbiAgICBzd2l0Y2ggKG8pIHtcbiAgICAgIGNhc2Ugd2U6XG4gICAgICAgIGUgPSByO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgenQ6IHtcbiAgICAgICAgcihlKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBjYXNlIEVuOlxuICAgICAgICByZXR1cm4gZTtcbiAgICB9XG4gICAgcmV0dXJuIG4obywgcik7XG4gIH07XG59XG5mdW5jdGlvbiBjdCh0LCBlKSB7XG4gIHJldHVybiB5ZSh5KGUpLCAobikgPT4gRih0LCBuKSk7XG59XG5mdW5jdGlvbiAkKCkge1xuICBjb25zdCB0ID0gW107XG4gIHJldHVybiAoZSwgbikgPT4ge1xuICAgIHN3aXRjaCAoZSkge1xuICAgICAgY2FzZSB3ZTpcbiAgICAgICAgdC5zbGljZSgpLmZvckVhY2goKG8pID0+IHtcbiAgICAgICAgICBvKG4pO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgY2FzZSBxdDpcbiAgICAgICAgdC5zcGxpY2UoMCwgdC5sZW5ndGgpO1xuICAgICAgICByZXR1cm47XG4gICAgICBjYXNlIHp0OlxuICAgICAgICByZXR1cm4gdC5wdXNoKG4pLCAoKSA9PiB7XG4gICAgICAgICAgY29uc3QgbyA9IHQuaW5kZXhPZihuKTtcbiAgICAgICAgICBvID4gLTEgJiYgdC5zcGxpY2UobywgMSk7XG4gICAgICAgIH07XG4gICAgfVxuICB9O1xufVxuZnVuY3Rpb24gcHQodCkge1xuICByZXR1cm4geWUoJCgpLCAoZSkgPT4gRih0LCBlKSk7XG59XG5mdW5jdGlvbiBVKHQsIGUgPSBbXSwgeyBzaW5nbGV0b246IG4gfSA9IHsgc2luZ2xldG9uOiAhMCB9KSB7XG4gIHJldHVybiB7XG4gICAgY29uc3RydWN0b3I6IHQsXG4gICAgZGVwZW5kZW5jaWVzOiBlLFxuICAgIGlkOiBwbygpLFxuICAgIHNpbmdsZXRvbjogblxuICB9O1xufVxuY29uc3QgcG8gPSAoKSA9PiBTeW1ib2woKTtcbmZ1bmN0aW9uIGhvKHQpIHtcbiAgY29uc3QgZSA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCksIG4gPSAoeyBjb25zdHJ1Y3RvcjogbywgZGVwZW5kZW5jaWVzOiByLCBpZDogcywgc2luZ2xldG9uOiBpIH0pID0+IHtcbiAgICBpZiAoaSAmJiBlLmhhcyhzKSlcbiAgICAgIHJldHVybiBlLmdldChzKTtcbiAgICBjb25zdCBsID0gbyhyLm1hcCgoYykgPT4gbihjKSkpO1xuICAgIHJldHVybiBpICYmIGUuc2V0KHMsIGwpLCBsO1xuICB9O1xuICByZXR1cm4gbih0KTtcbn1cbmZ1bmN0aW9uIHJ0KC4uLnQpIHtcbiAgY29uc3QgZSA9ICQoKSwgbiA9IG5ldyBBcnJheSh0Lmxlbmd0aCk7XG4gIGxldCBvID0gMDtcbiAgY29uc3QgciA9IE1hdGgucG93KDIsIHQubGVuZ3RoKSAtIDE7XG4gIHJldHVybiB0LmZvckVhY2goKHMsIGkpID0+IHtcbiAgICBjb25zdCBsID0gTWF0aC5wb3coMiwgaSk7XG4gICAgSyhzLCAoYykgPT4ge1xuICAgICAgbltpXSA9IGMsIG8gPSBvIHwgbCwgbyA9PT0gciAmJiBXKGUsIG4pO1xuICAgIH0pO1xuICB9KSwgZnVuY3Rpb24ocywgaSkge1xuICAgIHN3aXRjaCAocykge1xuICAgICAgY2FzZSBxdDoge1xuICAgICAgICBXZShlKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY2FzZSB6dDpcbiAgICAgICAgcmV0dXJuIG8gPT09IHIgJiYgaShuKSwgSyhlLCBpKTtcbiAgICB9XG4gIH07XG59XG5mdW5jdGlvbiBBKHQsIGUgPSBCbikge1xuICByZXR1cm4geCh0LCBZKGUpKTtcbn1cbmZ1bmN0aW9uIGFuKC4uLnQpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKGUsIG4pIHtcbiAgICBzd2l0Y2ggKGUpIHtcbiAgICAgIGNhc2UgcXQ6XG4gICAgICAgIHJldHVybjtcbiAgICAgIGNhc2UgenQ6XG4gICAgICAgIHJldHVybiB1byguLi50Lm1hcCgobykgPT4gSyhvLCBuKSkpO1xuICAgIH1cbiAgfTtcbn1cbnZhciBodCA9IC8qIEBfX1BVUkVfXyAqLyAoKHQpID0+ICh0W3QuREVCVUcgPSAwXSA9IFwiREVCVUdcIiwgdFt0LklORk8gPSAxXSA9IFwiSU5GT1wiLCB0W3QuV0FSTiA9IDJdID0gXCJXQVJOXCIsIHRbdC5FUlJPUiA9IDNdID0gXCJFUlJPUlwiLCB0KSkoaHQgfHwge30pO1xuY29uc3QgZ28gPSB7XG4gIDA6IFwiZGVidWdcIixcbiAgMzogXCJlcnJvclwiLFxuICAxOiBcImxvZ1wiLFxuICAyOiBcIndhcm5cIlxufSwgSW8gPSAoKSA9PiB0eXBlb2YgZ2xvYmFsVGhpcyA+IFwidVwiID8gd2luZG93IDogZ2xvYmFsVGhpcywgVnQgPSBVKFxuICAoKSA9PiB7XG4gICAgY29uc3QgdCA9IHkoXG4gICAgICAzXG4gICAgICAvKiBFUlJPUiAqL1xuICAgICk7XG4gICAgcmV0dXJuIHtcbiAgICAgIGxvZzogeSgobiwgbywgciA9IDEpID0+IHtcbiAgICAgICAgdmFyIGk7XG4gICAgICAgIGNvbnN0IHMgPSAoaSA9IElvKCkuVklSVFVPU09fTE9HX0xFVkVMKSAhPSBudWxsID8gaSA6IGx0KHQpO1xuICAgICAgICByID49IHMgJiYgY29uc29sZVtnb1tyXV0oXG4gICAgICAgICAgXCIlY3JlYWN0LXZpcnR1b3NvOiAlYyVzICVvXCIsXG4gICAgICAgICAgXCJjb2xvcjogIzAyNTNiMzsgZm9udC13ZWlnaHQ6IGJvbGRcIixcbiAgICAgICAgICBcImNvbG9yOiBpbml0aWFsXCIsXG4gICAgICAgICAgbixcbiAgICAgICAgICBvXG4gICAgICAgICk7XG4gICAgICB9KSxcbiAgICAgIGxvZ0xldmVsOiB0XG4gICAgfTtcbiAgfSxcbiAgW10sXG4gIHsgc2luZ2xldG9uOiAhMCB9XG4pO1xuZnVuY3Rpb24gSHQodCwgZSwgbikge1xuICByZXR1cm4gX2UodCwgZSwgbikuY2FsbGJhY2tSZWY7XG59XG5mdW5jdGlvbiBfZSh0LCBlLCBuKSB7XG4gIGNvbnN0IG8gPSBILnVzZVJlZihudWxsKTtcbiAgbGV0IHIgPSAocykgPT4ge1xuICB9O1xuICBpZiAodHlwZW9mIFJlc2l6ZU9ic2VydmVyIDwgXCJ1XCIpIHtcbiAgICBjb25zdCBzID0gSC51c2VNZW1vKCgpID0+IG5ldyBSZXNpemVPYnNlcnZlcigoaSkgPT4ge1xuICAgICAgY29uc3QgbCA9ICgpID0+IHtcbiAgICAgICAgY29uc3QgYyA9IGlbMF0udGFyZ2V0O1xuICAgICAgICBjLm9mZnNldFBhcmVudCAhPT0gbnVsbCAmJiB0KGMpO1xuICAgICAgfTtcbiAgICAgIG4gPyBsKCkgOiByZXF1ZXN0QW5pbWF0aW9uRnJhbWUobCk7XG4gICAgfSksIFt0XSk7XG4gICAgciA9IChpKSA9PiB7XG4gICAgICBpICYmIGUgPyAocy5vYnNlcnZlKGkpLCBvLmN1cnJlbnQgPSBpKSA6IChvLmN1cnJlbnQgJiYgcy51bm9ic2VydmUoby5jdXJyZW50KSwgby5jdXJyZW50ID0gbnVsbCk7XG4gICAgfTtcbiAgfVxuICByZXR1cm4geyBjYWxsYmFja1JlZjogciwgcmVmOiBvIH07XG59XG5mdW5jdGlvbiBPbih0LCBlLCBuLCBvLCByLCBzLCBpLCBsLCBjKSB7XG4gIGNvbnN0IHUgPSBILnVzZUNhbGxiYWNrKFxuICAgIChmKSA9PiB7XG4gICAgICBjb25zdCBTID0gU28oZi5jaGlsZHJlbiwgZSwgbCA/IFwib2Zmc2V0V2lkdGhcIiA6IFwib2Zmc2V0SGVpZ2h0XCIsIHIpO1xuICAgICAgbGV0IHAgPSBmLnBhcmVudEVsZW1lbnQ7XG4gICAgICBmb3IgKDsgIXAuZGF0YXNldC52aXJ0dW9zb1Njcm9sbGVyOyApXG4gICAgICAgIHAgPSBwLnBhcmVudEVsZW1lbnQ7XG4gICAgICBjb25zdCBtID0gcC5sYXN0RWxlbWVudENoaWxkLmRhdGFzZXQudmlld3BvcnRUeXBlID09PSBcIndpbmRvd1wiO1xuICAgICAgbGV0IHc7XG4gICAgICBtICYmICh3ID0gcC5vd25lckRvY3VtZW50LmRlZmF1bHRWaWV3KTtcbiAgICAgIGNvbnN0IEkgPSBpID8gbCA/IGkuc2Nyb2xsTGVmdCA6IGkuc2Nyb2xsVG9wIDogbSA/IGwgPyB3LnNjcm9sbFggfHwgdy5kb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc2Nyb2xsTGVmdCA6IHcuc2Nyb2xsWSB8fCB3LmRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zY3JvbGxUb3AgOiBsID8gcC5zY3JvbGxMZWZ0IDogcC5zY3JvbGxUb3AsIEMgPSBpID8gbCA/IGkuc2Nyb2xsV2lkdGggOiBpLnNjcm9sbEhlaWdodCA6IG0gPyBsID8gdy5kb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc2Nyb2xsV2lkdGggOiB3LmRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zY3JvbGxIZWlnaHQgOiBsID8gcC5zY3JvbGxXaWR0aCA6IHAuc2Nyb2xsSGVpZ2h0LCBnID0gaSA/IGwgPyBpLm9mZnNldFdpZHRoIDogaS5vZmZzZXRIZWlnaHQgOiBtID8gbCA/IHcuaW5uZXJXaWR0aCA6IHcuaW5uZXJIZWlnaHQgOiBsID8gcC5vZmZzZXRXaWR0aCA6IHAub2Zmc2V0SGVpZ2h0O1xuICAgICAgbyh7XG4gICAgICAgIHNjcm9sbEhlaWdodDogQyxcbiAgICAgICAgc2Nyb2xsVG9wOiBNYXRoLm1heChJLCAwKSxcbiAgICAgICAgdmlld3BvcnRIZWlnaHQ6IGdcbiAgICAgIH0pLCBzID09IG51bGwgfHwgcyhcbiAgICAgICAgbCA/IGRuKFwiY29sdW1uLWdhcFwiLCBnZXRDb21wdXRlZFN0eWxlKGYpLmNvbHVtbkdhcCwgcikgOiBkbihcInJvdy1nYXBcIiwgZ2V0Q29tcHV0ZWRTdHlsZShmKS5yb3dHYXAsIHIpXG4gICAgICApLCBTICE9PSBudWxsICYmIHQoUyk7XG4gICAgfSxcbiAgICBbdCwgZSwgciwgcywgaSwgb11cbiAgKTtcbiAgcmV0dXJuIF9lKHUsIG4sIGMpO1xufVxuZnVuY3Rpb24gU28odCwgZSwgbiwgbykge1xuICBjb25zdCByID0gdC5sZW5ndGg7XG4gIGlmIChyID09PSAwKVxuICAgIHJldHVybiBudWxsO1xuICBjb25zdCBzID0gW107XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgcjsgaSsrKSB7XG4gICAgY29uc3QgbCA9IHQuaXRlbShpKTtcbiAgICBpZiAobC5kYXRhc2V0LmluZGV4ID09PSB2b2lkIDApXG4gICAgICBjb250aW51ZTtcbiAgICBjb25zdCBjID0gcGFyc2VJbnQobC5kYXRhc2V0LmluZGV4KSwgdSA9IHBhcnNlRmxvYXQobC5kYXRhc2V0Lmtub3duU2l6ZSksIGYgPSBlKGwsIG4pO1xuICAgIGlmIChmID09PSAwICYmIG8oXCJaZXJvLXNpemVkIGVsZW1lbnQsIHRoaXMgc2hvdWxkIG5vdCBoYXBwZW5cIiwgeyBjaGlsZDogbCB9LCBodC5FUlJPUiksIGYgPT09IHUpXG4gICAgICBjb250aW51ZTtcbiAgICBjb25zdCBTID0gc1tzLmxlbmd0aCAtIDFdO1xuICAgIHMubGVuZ3RoID09PSAwIHx8IFMuc2l6ZSAhPT0gZiB8fCBTLmVuZEluZGV4ICE9PSBjIC0gMSA/IHMucHVzaCh7IGVuZEluZGV4OiBjLCBzaXplOiBmLCBzdGFydEluZGV4OiBjIH0pIDogc1tzLmxlbmd0aCAtIDFdLmVuZEluZGV4Kys7XG4gIH1cbiAgcmV0dXJuIHM7XG59XG5mdW5jdGlvbiBkbih0LCBlLCBuKSB7XG4gIHJldHVybiBlICE9PSBcIm5vcm1hbFwiICYmICEoZSAhPSBudWxsICYmIGUuZW5kc1dpdGgoXCJweFwiKSkgJiYgbihgJHt0fSB3YXMgbm90IHJlc29sdmVkIHRvIHBpeGVsIHZhbHVlIGNvcnJlY3RseWAsIGUsIGh0LldBUk4pLCBlID09PSBcIm5vcm1hbFwiID8gMCA6IHBhcnNlSW50KGUgIT0gbnVsbCA/IGUgOiBcIjBcIiwgMTApO1xufVxuZnVuY3Rpb24gR2UodCwgZSwgbikge1xuICBjb25zdCBvID0gSC51c2VSZWYobnVsbCksIHIgPSBILnVzZUNhbGxiYWNrKFxuICAgIChjKSA9PiB7XG4gICAgICBpZiAoIShjICE9IG51bGwgJiYgYy5vZmZzZXRQYXJlbnQpKVxuICAgICAgICByZXR1cm47XG4gICAgICBjb25zdCB1ID0gYy5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSwgZiA9IHUud2lkdGg7XG4gICAgICBsZXQgUywgcDtcbiAgICAgIGlmIChlKSB7XG4gICAgICAgIGNvbnN0IG0gPSBlLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLCB3ID0gdS50b3AgLSBtLnRvcDtcbiAgICAgICAgcCA9IG0uaGVpZ2h0IC0gTWF0aC5tYXgoMCwgdyksIFMgPSB3ICsgZS5zY3JvbGxUb3A7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCBtID0gaS5jdXJyZW50Lm93bmVyRG9jdW1lbnQuZGVmYXVsdFZpZXc7XG4gICAgICAgIHAgPSBtLmlubmVySGVpZ2h0IC0gTWF0aC5tYXgoMCwgdS50b3ApLCBTID0gdS50b3AgKyBtLnNjcm9sbFk7XG4gICAgICB9XG4gICAgICBvLmN1cnJlbnQgPSB7XG4gICAgICAgIG9mZnNldFRvcDogUyxcbiAgICAgICAgdmlzaWJsZUhlaWdodDogcCxcbiAgICAgICAgdmlzaWJsZVdpZHRoOiBmXG4gICAgICB9LCB0KG8uY3VycmVudCk7XG4gICAgfSxcbiAgICBbdCwgZV1cbiAgKSwgeyBjYWxsYmFja1JlZjogcywgcmVmOiBpIH0gPSBfZShyLCAhMCwgbiksIGwgPSBILnVzZUNhbGxiYWNrKCgpID0+IHtcbiAgICByKGkuY3VycmVudCk7XG4gIH0sIFtyLCBpXSk7XG4gIHJldHVybiBILnVzZUVmZmVjdCgoKSA9PiB7XG4gICAgdmFyIGM7XG4gICAgaWYgKGUpIHtcbiAgICAgIGUuYWRkRXZlbnRMaXN0ZW5lcihcInNjcm9sbFwiLCBsKTtcbiAgICAgIGNvbnN0IHUgPSBuZXcgUmVzaXplT2JzZXJ2ZXIoKCkgPT4ge1xuICAgICAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUobCk7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiB1Lm9ic2VydmUoZSksICgpID0+IHtcbiAgICAgICAgZS5yZW1vdmVFdmVudExpc3RlbmVyKFwic2Nyb2xsXCIsIGwpLCB1LnVub2JzZXJ2ZShlKTtcbiAgICAgIH07XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IHUgPSAoYyA9IGkuY3VycmVudCkgPT0gbnVsbCA/IHZvaWQgMCA6IGMub3duZXJEb2N1bWVudC5kZWZhdWx0VmlldztcbiAgICAgIHJldHVybiB1ID09IG51bGwgfHwgdS5hZGRFdmVudExpc3RlbmVyKFwic2Nyb2xsXCIsIGwpLCB1ID09IG51bGwgfHwgdS5hZGRFdmVudExpc3RlbmVyKFwicmVzaXplXCIsIGwpLCAoKSA9PiB7XG4gICAgICAgIHUgPT0gbnVsbCB8fCB1LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJzY3JvbGxcIiwgbCksIHUgPT0gbnVsbCB8fCB1LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJyZXNpemVcIiwgbCk7XG4gICAgICB9O1xuICAgIH1cbiAgfSwgW2wsIGVdKSwgcztcbn1cbmNvbnN0IGF0ID0gVShcbiAgKCkgPT4ge1xuICAgIGNvbnN0IHQgPSAkKCksIGUgPSAkKCksIG4gPSB5KDApLCBvID0gJCgpLCByID0geSgwKSwgcyA9ICQoKSwgaSA9ICQoKSwgbCA9IHkoMCksIGMgPSB5KDApLCB1ID0geSgwKSwgZiA9IHkoMCksIFMgPSAkKCksIHAgPSAkKCksIG0gPSB5KCExKSwgdyA9IHkoITEpLCBJID0geSghMSk7XG4gICAgcmV0dXJuIEYoXG4gICAgICB4KFxuICAgICAgICB0LFxuICAgICAgICBFKCh7IHNjcm9sbFRvcDogQyB9KSA9PiBDKVxuICAgICAgKSxcbiAgICAgIGVcbiAgICApLCBGKFxuICAgICAgeChcbiAgICAgICAgdCxcbiAgICAgICAgRSgoeyBzY3JvbGxIZWlnaHQ6IEMgfSkgPT4gQylcbiAgICAgICksXG4gICAgICBpXG4gICAgKSwgRihlLCByKSwge1xuICAgICAgZGV2aWF0aW9uOiBuLFxuICAgICAgZml4ZWRGb290ZXJIZWlnaHQ6IHUsXG4gICAgICBmaXhlZEhlYWRlckhlaWdodDogYyxcbiAgICAgIGZvb3RlckhlaWdodDogZixcbiAgICAgIGhlYWRlckhlaWdodDogbCxcbiAgICAgIGhvcml6b250YWxEaXJlY3Rpb246IHcsXG4gICAgICBzY3JvbGxCeTogcCxcbiAgICAgIC8vIGlucHV0XG4gICAgICBzY3JvbGxDb250YWluZXJTdGF0ZTogdCxcbiAgICAgIHNjcm9sbEhlaWdodDogaSxcbiAgICAgIHNjcm9sbGluZ0luUHJvZ3Jlc3M6IG0sXG4gICAgICAvLyBzaWduYWxzXG4gICAgICBzY3JvbGxUbzogUyxcbiAgICAgIHNjcm9sbFRvcDogZSxcbiAgICAgIHNraXBBbmltYXRpb25GcmFtZUluUmVzaXplT2JzZXJ2ZXI6IEksXG4gICAgICBzbW9vdGhTY3JvbGxUYXJnZXRSZWFjaGVkOiBvLFxuICAgICAgLy8gc3RhdGVcbiAgICAgIHN0YXRlZnVsU2Nyb2xsVG9wOiByLFxuICAgICAgdmlld3BvcnRIZWlnaHQ6IHNcbiAgICB9O1xuICB9LFxuICBbXSxcbiAgeyBzaW5nbGV0b246ICEwIH1cbiksIG9lID0geyBsdmw6IDAgfTtcbmZ1bmN0aW9uIEZuKHQsIGUpIHtcbiAgY29uc3QgbiA9IHQubGVuZ3RoO1xuICBpZiAobiA9PT0gMClcbiAgICByZXR1cm4gW107XG4gIGxldCB7IGluZGV4OiBvLCB2YWx1ZTogciB9ID0gZSh0WzBdKTtcbiAgY29uc3QgcyA9IFtdO1xuICBmb3IgKGxldCBpID0gMTsgaSA8IG47IGkrKykge1xuICAgIGNvbnN0IHsgaW5kZXg6IGwsIHZhbHVlOiBjIH0gPSBlKHRbaV0pO1xuICAgIHMucHVzaCh7IGVuZDogbCAtIDEsIHN0YXJ0OiBvLCB2YWx1ZTogciB9KSwgbyA9IGwsIHIgPSBjO1xuICB9XG4gIHJldHVybiBzLnB1c2goeyBlbmQ6IDEgLyAwLCBzdGFydDogbywgdmFsdWU6IHIgfSksIHM7XG59XG5mdW5jdGlvbiBqKHQpIHtcbiAgcmV0dXJuIHQgPT09IG9lO1xufVxuZnVuY3Rpb24gcmUodCwgZSkge1xuICBpZiAoIWoodCkpXG4gICAgcmV0dXJuIGUgPT09IHQuayA/IHQudiA6IGUgPCB0LmsgPyByZSh0LmwsIGUpIDogcmUodC5yLCBlKTtcbn1cbmZ1bmN0aW9uIEN0KHQsIGUsIG4gPSBcImtcIikge1xuICBpZiAoaih0KSlcbiAgICByZXR1cm4gWy0xIC8gMCwgdm9pZCAwXTtcbiAgaWYgKE51bWJlcih0W25dKSA9PT0gZSlcbiAgICByZXR1cm4gW3QuaywgdC52XTtcbiAgaWYgKE51bWJlcih0W25dKSA8IGUpIHtcbiAgICBjb25zdCBvID0gQ3QodC5yLCBlLCBuKTtcbiAgICByZXR1cm4gb1swXSA9PT0gLTEgLyAwID8gW3QuaywgdC52XSA6IG87XG4gIH1cbiAgcmV0dXJuIEN0KHQubCwgZSwgbik7XG59XG5mdW5jdGlvbiBtdCh0LCBlLCBuKSB7XG4gIHJldHVybiBqKHQpID8gVm4oZSwgbiwgMSkgOiBlID09PSB0LmsgPyBvdCh0LCB7IGs6IGUsIHY6IG4gfSkgOiBlIDwgdC5rID8gZm4ob3QodCwgeyBsOiBtdCh0LmwsIGUsIG4pIH0pKSA6IGZuKG90KHQsIHsgcjogbXQodC5yLCBlLCBuKSB9KSk7XG59XG5mdW5jdGlvbiBVdCgpIHtcbiAgcmV0dXJuIG9lO1xufVxuZnVuY3Rpb24gdmUodCwgZSwgbikge1xuICBpZiAoaih0KSlcbiAgICByZXR1cm4gW107XG4gIGNvbnN0IG8gPSBDdCh0LCBlKVswXTtcbiAgcmV0dXJuIHhvKHplKHQsIG8sIG4pKTtcbn1cbmZ1bmN0aW9uIExlKHQsIGUpIHtcbiAgaWYgKGoodCkpIHJldHVybiBvZTtcbiAgY29uc3QgeyBrOiBuLCBsOiBvLCByIH0gPSB0O1xuICBpZiAoZSA9PT0gbikge1xuICAgIGlmIChqKG8pKVxuICAgICAgcmV0dXJuIHI7XG4gICAgaWYgKGoocikpXG4gICAgICByZXR1cm4gbztcbiAgICB7XG4gICAgICBjb25zdCBbcywgaV0gPSB6bihvKTtcbiAgICAgIHJldHVybiBnZShvdCh0LCB7IGs6IHMsIGw6IExuKG8pLCB2OiBpIH0pKTtcbiAgICB9XG4gIH0gZWxzZSByZXR1cm4gZSA8IG4gPyBnZShvdCh0LCB7IGw6IExlKG8sIGUpIH0pKSA6IGdlKG90KHQsIHsgcjogTGUociwgZSkgfSkpO1xufVxuZnVuY3Rpb24gX3QodCkge1xuICByZXR1cm4gaih0KSA/IFtdIDogWy4uLl90KHQubCksIHsgazogdC5rLCB2OiB0LnYgfSwgLi4uX3QodC5yKV07XG59XG5mdW5jdGlvbiB6ZSh0LCBlLCBuKSB7XG4gIGlmIChqKHQpKVxuICAgIHJldHVybiBbXTtcbiAgY29uc3QgeyBrOiBvLCBsOiByLCByOiBzLCB2OiBpIH0gPSB0O1xuICBsZXQgbCA9IFtdO1xuICByZXR1cm4gbyA+IGUgJiYgKGwgPSBsLmNvbmNhdCh6ZShyLCBlLCBuKSkpLCBvID49IGUgJiYgbyA8PSBuICYmIGwucHVzaCh7IGs6IG8sIHY6IGkgfSksIG8gPD0gbiAmJiAobCA9IGwuY29uY2F0KHplKHMsIGUsIG4pKSksIGw7XG59XG5mdW5jdGlvbiBnZSh0KSB7XG4gIGNvbnN0IHsgbDogZSwgbHZsOiBuLCByOiBvIH0gPSB0O1xuICBpZiAoby5sdmwgPj0gbiAtIDEgJiYgZS5sdmwgPj0gbiAtIDEpXG4gICAgcmV0dXJuIHQ7XG4gIGlmIChuID4gby5sdmwgKyAxKSB7XG4gICAgaWYgKEVlKGUpKVxuICAgICAgcmV0dXJuIFBuKG90KHQsIHsgbHZsOiBuIC0gMSB9KSk7XG4gICAgaWYgKCFqKGUpICYmICFqKGUucikpXG4gICAgICByZXR1cm4gb3QoZS5yLCB7XG4gICAgICAgIGw6IG90KGUsIHsgcjogZS5yLmwgfSksXG4gICAgICAgIGx2bDogbixcbiAgICAgICAgcjogb3QodCwge1xuICAgICAgICAgIGw6IGUuci5yLFxuICAgICAgICAgIGx2bDogbiAtIDFcbiAgICAgICAgfSlcbiAgICAgIH0pO1xuICAgIHRocm93IG5ldyBFcnJvcihcIlVuZXhwZWN0ZWQgZW1wdHkgbm9kZXNcIik7XG4gIH0gZWxzZSB7XG4gICAgaWYgKEVlKHQpKVxuICAgICAgcmV0dXJuIFZlKG90KHQsIHsgbHZsOiBuIC0gMSB9KSk7XG4gICAgaWYgKCFqKG8pICYmICFqKG8ubCkpIHtcbiAgICAgIGNvbnN0IHIgPSBvLmwsIHMgPSBFZShyKSA/IG8ubHZsIC0gMSA6IG8ubHZsO1xuICAgICAgcmV0dXJuIG90KHIsIHtcbiAgICAgICAgbDogb3QodCwge1xuICAgICAgICAgIGx2bDogbiAtIDEsXG4gICAgICAgICAgcjogci5sXG4gICAgICAgIH0pLFxuICAgICAgICBsdmw6IHIubHZsICsgMSxcbiAgICAgICAgcjogVmUob3QobywgeyBsOiByLnIsIGx2bDogcyB9KSlcbiAgICAgIH0pO1xuICAgIH0gZWxzZVxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5leHBlY3RlZCBlbXB0eSBub2Rlc1wiKTtcbiAgfVxufVxuZnVuY3Rpb24gb3QodCwgZSkge1xuICByZXR1cm4gVm4oXG4gICAgZS5rICE9PSB2b2lkIDAgPyBlLmsgOiB0LmssXG4gICAgZS52ICE9PSB2b2lkIDAgPyBlLnYgOiB0LnYsXG4gICAgZS5sdmwgIT09IHZvaWQgMCA/IGUubHZsIDogdC5sdmwsXG4gICAgZS5sICE9PSB2b2lkIDAgPyBlLmwgOiB0LmwsXG4gICAgZS5yICE9PSB2b2lkIDAgPyBlLnIgOiB0LnJcbiAgKTtcbn1cbmZ1bmN0aW9uIExuKHQpIHtcbiAgcmV0dXJuIGoodC5yKSA/IHQubCA6IGdlKG90KHQsIHsgcjogTG4odC5yKSB9KSk7XG59XG5mdW5jdGlvbiBFZSh0KSB7XG4gIHJldHVybiBqKHQpIHx8IHQubHZsID4gdC5yLmx2bDtcbn1cbmZ1bmN0aW9uIHpuKHQpIHtcbiAgcmV0dXJuIGoodC5yKSA/IFt0LmssIHQudl0gOiB6bih0LnIpO1xufVxuZnVuY3Rpb24gVm4odCwgZSwgbiwgbyA9IG9lLCByID0gb2UpIHtcbiAgcmV0dXJuIHsgazogdCwgbDogbywgbHZsOiBuLCByLCB2OiBlIH07XG59XG5mdW5jdGlvbiBmbih0KSB7XG4gIHJldHVybiBWZShQbih0KSk7XG59XG5mdW5jdGlvbiBQbih0KSB7XG4gIGNvbnN0IHsgbDogZSB9ID0gdDtcbiAgcmV0dXJuICFqKGUpICYmIGUubHZsID09PSB0Lmx2bCA/IG90KGUsIHsgcjogb3QodCwgeyBsOiBlLnIgfSkgfSkgOiB0O1xufVxuZnVuY3Rpb24gVmUodCkge1xuICBjb25zdCB7IGx2bDogZSwgcjogbiB9ID0gdDtcbiAgcmV0dXJuICFqKG4pICYmICFqKG4ucikgJiYgbi5sdmwgPT09IGUgJiYgbi5yLmx2bCA9PT0gZSA/IG90KG4sIHsgbDogb3QodCwgeyByOiBuLmwgfSksIGx2bDogZSArIDEgfSkgOiB0O1xufVxuZnVuY3Rpb24geG8odCkge1xuICByZXR1cm4gRm4odCwgKHsgazogZSwgdjogbiB9KSA9PiAoeyBpbmRleDogZSwgdmFsdWU6IG4gfSkpO1xufVxuZnVuY3Rpb24gQW4odCwgZSkge1xuICByZXR1cm4gISEodCAmJiB0LnN0YXJ0SW5kZXggPT09IGUuc3RhcnRJbmRleCAmJiB0LmVuZEluZGV4ID09PSBlLmVuZEluZGV4KTtcbn1cbmZ1bmN0aW9uIHNlKHQsIGUpIHtcbiAgcmV0dXJuICEhKHQgJiYgdFswXSA9PT0gZVswXSAmJiB0WzFdID09PSBlWzFdKTtcbn1cbmNvbnN0IE5lID0gVShcbiAgKCkgPT4gKHsgcmVjYWxjSW5Qcm9ncmVzczogeSghMSkgfSksXG4gIFtdLFxuICB7IHNpbmdsZXRvbjogITAgfVxuKTtcbmZ1bmN0aW9uIE1uKHQsIGUsIG4pIHtcbiAgcmV0dXJuIHRbU2UodCwgZSwgbildO1xufVxuZnVuY3Rpb24gU2UodCwgZSwgbiwgbyA9IDApIHtcbiAgbGV0IHIgPSB0Lmxlbmd0aCAtIDE7XG4gIGZvciAoOyBvIDw9IHI7ICkge1xuICAgIGNvbnN0IHMgPSBNYXRoLmZsb29yKChvICsgcikgLyAyKSwgaSA9IHRbc10sIGwgPSBuKGksIGUpO1xuICAgIGlmIChsID09PSAwKVxuICAgICAgcmV0dXJuIHM7XG4gICAgaWYgKGwgPT09IC0xKSB7XG4gICAgICBpZiAociAtIG8gPCAyKVxuICAgICAgICByZXR1cm4gcyAtIDE7XG4gICAgICByID0gcyAtIDE7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChyID09PSBvKVxuICAgICAgICByZXR1cm4gcztcbiAgICAgIG8gPSBzICsgMTtcbiAgICB9XG4gIH1cbiAgdGhyb3cgbmV3IEVycm9yKGBGYWlsZWQgYmluYXJ5IGZpbmRpbmcgcmVjb3JkIGluIGFycmF5IC0gJHt0LmpvaW4oXCIsXCIpfSwgc2VhcmNoZWQgZm9yICR7ZX1gKTtcbn1cbmZ1bmN0aW9uIFRvKHQsIGUsIG4sIG8pIHtcbiAgY29uc3QgciA9IFNlKHQsIGUsIG8pLCBzID0gU2UodCwgbiwgbywgcik7XG4gIHJldHVybiB0LnNsaWNlKHIsIHMgKyAxKTtcbn1cbmZ1bmN0aW9uIHd0KHQsIGUpIHtcbiAgcmV0dXJuIE1hdGgucm91bmQodC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKVtlXSk7XG59XG5mdW5jdGlvbiBiZSh0KSB7XG4gIHJldHVybiAhaih0Lmdyb3VwT2Zmc2V0VHJlZSk7XG59XG5mdW5jdGlvbiBEZSh7IGluZGV4OiB0IH0sIGUpIHtcbiAgcmV0dXJuIGUgPT09IHQgPyAwIDogZSA8IHQgPyAtMSA6IDE7XG59XG5mdW5jdGlvbiBDbygpIHtcbiAgcmV0dXJuIHtcbiAgICBncm91cEluZGljZXM6IFtdLFxuICAgIGdyb3VwT2Zmc2V0VHJlZTogVXQoKSxcbiAgICBsYXN0SW5kZXg6IDAsXG4gICAgbGFzdE9mZnNldDogMCxcbiAgICBsYXN0U2l6ZTogMCxcbiAgICBvZmZzZXRUcmVlOiBbXSxcbiAgICBzaXplVHJlZTogVXQoKVxuICB9O1xufVxuZnVuY3Rpb24gd28odCwgZSkge1xuICBsZXQgbiA9IGoodCkgPyAwIDogMSAvIDA7XG4gIGZvciAoY29uc3QgbyBvZiBlKSB7XG4gICAgY29uc3QgeyBlbmRJbmRleDogciwgc2l6ZTogcywgc3RhcnRJbmRleDogaSB9ID0gbztcbiAgICBpZiAobiA9IE1hdGgubWluKG4sIGkpLCBqKHQpKSB7XG4gICAgICB0ID0gbXQodCwgMCwgcyk7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgY29uc3QgbCA9IHZlKHQsIGkgLSAxLCByICsgMSk7XG4gICAgaWYgKGwuc29tZShrbyhvKSkpXG4gICAgICBjb250aW51ZTtcbiAgICBsZXQgYyA9ICExLCB1ID0gITE7XG4gICAgZm9yIChjb25zdCB7IGVuZDogZiwgc3RhcnQ6IFMsIHZhbHVlOiBwIH0gb2YgbClcbiAgICAgIGMgPyAociA+PSBTIHx8IHMgPT09IHApICYmICh0ID0gTGUodCwgUykpIDogKHUgPSBwICE9PSBzLCBjID0gITApLCBmID4gciAmJiByID49IFMgJiYgcCAhPT0gcyAmJiAodCA9IG10KHQsIHIgKyAxLCBwKSk7XG4gICAgdSAmJiAodCA9IG10KHQsIGksIHMpKTtcbiAgfVxuICByZXR1cm4gW3QsIG5dO1xufVxuZnVuY3Rpb24geW8odCkge1xuICByZXR1cm4gdHlwZW9mIHQuZ3JvdXBJbmRleCA8IFwidVwiO1xufVxuZnVuY3Rpb24gdm8oeyBvZmZzZXQ6IHQgfSwgZSkge1xuICByZXR1cm4gZSA9PT0gdCA/IDAgOiBlIDwgdCA/IC0xIDogMTtcbn1cbmZ1bmN0aW9uIGllKHQsIGUsIG4pIHtcbiAgaWYgKGUubGVuZ3RoID09PSAwKVxuICAgIHJldHVybiAwO1xuICBjb25zdCB7IGluZGV4OiBvLCBvZmZzZXQ6IHIsIHNpemU6IHMgfSA9IE1uKGUsIHQsIERlKSwgaSA9IHQgLSBvLCBsID0gcyAqIGkgKyAoaSAtIDEpICogbiArIHI7XG4gIHJldHVybiBsID4gMCA/IGwgKyBuIDogbDtcbn1cbmZ1bmN0aW9uIFduKHQsIGUpIHtcbiAgaWYgKCFiZShlKSlcbiAgICByZXR1cm4gdDtcbiAgbGV0IG4gPSAwO1xuICBmb3IgKDsgZS5ncm91cEluZGljZXNbbl0gPD0gdCArIG47IClcbiAgICBuKys7XG4gIHJldHVybiB0ICsgbjtcbn1cbmZ1bmN0aW9uIF9uKHQsIGUsIG4pIHtcbiAgaWYgKHlvKHQpKVxuICAgIHJldHVybiBlLmdyb3VwSW5kaWNlc1t0Lmdyb3VwSW5kZXhdICsgMTtcbiAge1xuICAgIGNvbnN0IG8gPSB0LmluZGV4ID09PSBcIkxBU1RcIiA/IG4gOiB0LmluZGV4O1xuICAgIGxldCByID0gV24obywgZSk7XG4gICAgcmV0dXJuIHIgPSBNYXRoLm1heCgwLCByLCBNYXRoLm1pbihuLCByKSksIHI7XG4gIH1cbn1cbmZ1bmN0aW9uIGJvKHQsIGUsIG4sIG8gPSAwKSB7XG4gIHJldHVybiBvID4gMCAmJiAoZSA9IE1hdGgubWF4KGUsIE1uKHQsIG8sIERlKS5vZmZzZXQpKSwgRm4oVG8odCwgZSwgbiwgdm8pLCBFbyk7XG59XG5mdW5jdGlvbiBSbyh0LCBbZSwgbiwgbywgcl0pIHtcbiAgZS5sZW5ndGggPiAwICYmIG8oXCJyZWNlaXZlZCBpdGVtIHNpemVzXCIsIGUsIGh0LkRFQlVHKTtcbiAgY29uc3QgcyA9IHQuc2l6ZVRyZWU7XG4gIGxldCBpID0gcywgbCA9IDA7XG4gIGlmIChuLmxlbmd0aCA+IDAgJiYgaihzKSAmJiBlLmxlbmd0aCA9PT0gMikge1xuICAgIGNvbnN0IHAgPSBlWzBdLnNpemUsIG0gPSBlWzFdLnNpemU7XG4gICAgaSA9IG4ucmVkdWNlKCh3LCBJKSA9PiBtdChtdCh3LCBJLCBwKSwgSSArIDEsIG0pLCBpKTtcbiAgfSBlbHNlXG4gICAgW2ksIGxdID0gd28oaSwgZSk7XG4gIGlmIChpID09PSBzKVxuICAgIHJldHVybiB0O1xuICBjb25zdCB7IGxhc3RJbmRleDogYywgbGFzdE9mZnNldDogdSwgbGFzdFNpemU6IGYsIG9mZnNldFRyZWU6IFMgfSA9IFBlKHQub2Zmc2V0VHJlZSwgbCwgaSwgcik7XG4gIHJldHVybiB7XG4gICAgZ3JvdXBJbmRpY2VzOiBuLFxuICAgIGdyb3VwT2Zmc2V0VHJlZTogbi5yZWR1Y2UoKHAsIG0pID0+IG10KHAsIG0sIGllKG0sIFMsIHIpKSwgVXQoKSksXG4gICAgbGFzdEluZGV4OiBjLFxuICAgIGxhc3RPZmZzZXQ6IHUsXG4gICAgbGFzdFNpemU6IGYsXG4gICAgb2Zmc2V0VHJlZTogUyxcbiAgICBzaXplVHJlZTogaVxuICB9O1xufVxuZnVuY3Rpb24gSG8odCkge1xuICByZXR1cm4gX3QodCkubWFwKCh7IGs6IGUsIHY6IG4gfSwgbywgcikgPT4ge1xuICAgIGNvbnN0IHMgPSByW28gKyAxXTtcbiAgICByZXR1cm4geyBlbmRJbmRleDogcyA/IHMuayAtIDEgOiAxIC8gMCwgc2l6ZTogbiwgc3RhcnRJbmRleDogZSB9O1xuICB9KTtcbn1cbmZ1bmN0aW9uIG1uKHQsIGUpIHtcbiAgbGV0IG4gPSAwLCBvID0gMDtcbiAgZm9yICg7IG4gPCB0OyApXG4gICAgbiArPSBlW28gKyAxXSAtIGVbb10gLSAxLCBvKys7XG4gIHJldHVybiBvIC0gKG4gPT09IHQgPyAwIDogMSk7XG59XG5mdW5jdGlvbiBQZSh0LCBlLCBuLCBvKSB7XG4gIGxldCByID0gdCwgcyA9IDAsIGkgPSAwLCBsID0gMCwgYyA9IDA7XG4gIGlmIChlICE9PSAwKSB7XG4gICAgYyA9IFNlKHIsIGUgLSAxLCBEZSksIGwgPSByW2NdLm9mZnNldDtcbiAgICBjb25zdCBmID0gQ3QobiwgZSAtIDEpO1xuICAgIHMgPSBmWzBdLCBpID0gZlsxXSwgci5sZW5ndGggJiYgcltjXS5zaXplID09PSBDdChuLCBlKVsxXSAmJiAoYyAtPSAxKSwgciA9IHIuc2xpY2UoMCwgYyArIDEpO1xuICB9IGVsc2VcbiAgICByID0gW107XG4gIGZvciAoY29uc3QgeyBzdGFydDogdSwgdmFsdWU6IGYgfSBvZiB2ZShuLCBlLCAxIC8gMCkpIHtcbiAgICBjb25zdCBTID0gdSAtIHMsIHAgPSBTICogaSArIGwgKyBTICogbztcbiAgICByLnB1c2goe1xuICAgICAgaW5kZXg6IHUsXG4gICAgICBvZmZzZXQ6IHAsXG4gICAgICBzaXplOiBmXG4gICAgfSksIHMgPSB1LCBsID0gcCwgaSA9IGY7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBsYXN0SW5kZXg6IHMsXG4gICAgbGFzdE9mZnNldDogbCxcbiAgICBsYXN0U2l6ZTogaSxcbiAgICBvZmZzZXRUcmVlOiByXG4gIH07XG59XG5mdW5jdGlvbiBFbyh0KSB7XG4gIHJldHVybiB7IGluZGV4OiB0LmluZGV4LCB2YWx1ZTogdCB9O1xufVxuZnVuY3Rpb24ga28odCkge1xuICBjb25zdCB7IGVuZEluZGV4OiBlLCBzaXplOiBuLCBzdGFydEluZGV4OiBvIH0gPSB0O1xuICByZXR1cm4gKHIpID0+IHIuc3RhcnQgPT09IG8gJiYgKHIuZW5kID09PSBlIHx8IHIuZW5kID09PSAxIC8gMCkgJiYgci52YWx1ZSA9PT0gbjtcbn1cbmNvbnN0IEJvID0ge1xuICBvZmZzZXRIZWlnaHQ6IFwiaGVpZ2h0XCIsXG4gIG9mZnNldFdpZHRoOiBcIndpZHRoXCJcbn0sIEV0ID0gVShcbiAgKFt7IGxvZzogdCB9LCB7IHJlY2FsY0luUHJvZ3Jlc3M6IGUgfV0pID0+IHtcbiAgICBjb25zdCBuID0gJCgpLCBvID0gJCgpLCByID0gY3QobywgMCksIHMgPSAkKCksIGkgPSAkKCksIGwgPSB5KDApLCBjID0geShbXSksIHUgPSB5KHZvaWQgMCksIGYgPSB5KHZvaWQgMCksIFMgPSB5KChoLCBkKSA9PiB3dChoLCBCb1tkXSkpLCBwID0geSh2b2lkIDApLCBtID0geSgwKSwgdyA9IENvKCksIEkgPSBjdChcbiAgICAgIHgobiwgRyhjLCB0LCBtKSwgYnQoUm8sIHcpLCBZKCkpLFxuICAgICAgd1xuICAgICksIEMgPSBjdChcbiAgICAgIHgoXG4gICAgICAgIGMsXG4gICAgICAgIFkoKSxcbiAgICAgICAgYnQoKGgsIGQpID0+ICh7IGN1cnJlbnQ6IGQsIHByZXY6IGguY3VycmVudCB9KSwge1xuICAgICAgICAgIGN1cnJlbnQ6IFtdLFxuICAgICAgICAgIHByZXY6IFtdXG4gICAgICAgIH0pLFxuICAgICAgICBFKCh7IHByZXY6IGggfSkgPT4gaClcbiAgICAgICksXG4gICAgICBbXVxuICAgICk7XG4gICAgRihcbiAgICAgIHgoXG4gICAgICAgIGMsXG4gICAgICAgIFAoKGgpID0+IGgubGVuZ3RoID4gMCksXG4gICAgICAgIEcoSSwgbSksXG4gICAgICAgIEUoKFtoLCBkLCBSXSkgPT4ge1xuICAgICAgICAgIGNvbnN0IEIgPSBoLnJlZHVjZSgoTywgTCwgVikgPT4gbXQoTywgTCwgaWUoTCwgZC5vZmZzZXRUcmVlLCBSKSB8fCBWKSwgVXQoKSk7XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIC4uLmQsXG4gICAgICAgICAgICBncm91cEluZGljZXM6IGgsXG4gICAgICAgICAgICBncm91cE9mZnNldFRyZWU6IEJcbiAgICAgICAgICB9O1xuICAgICAgICB9KVxuICAgICAgKSxcbiAgICAgIElcbiAgICApLCBGKFxuICAgICAgeChcbiAgICAgICAgbyxcbiAgICAgICAgRyhJKSxcbiAgICAgICAgUCgoW2gsIHsgbGFzdEluZGV4OiBkIH1dKSA9PiBoIDwgZCksXG4gICAgICAgIEUoKFtoLCB7IGxhc3RJbmRleDogZCwgbGFzdFNpemU6IFIgfV0pID0+IFtcbiAgICAgICAgICB7XG4gICAgICAgICAgICBlbmRJbmRleDogZCxcbiAgICAgICAgICAgIHNpemU6IFIsXG4gICAgICAgICAgICBzdGFydEluZGV4OiBoXG4gICAgICAgICAgfVxuICAgICAgICBdKVxuICAgICAgKSxcbiAgICAgIG5cbiAgICApLCBGKHUsIGYpO1xuICAgIGNvbnN0IGcgPSBjdChcbiAgICAgIHgoXG4gICAgICAgIHUsXG4gICAgICAgIEUoKGgpID0+IGggPT09IHZvaWQgMClcbiAgICAgICksXG4gICAgICAhMFxuICAgICk7XG4gICAgRihcbiAgICAgIHgoXG4gICAgICAgIGYsXG4gICAgICAgIFAoKGgpID0+IGggIT09IHZvaWQgMCAmJiBqKGx0KEkpLnNpemVUcmVlKSksXG4gICAgICAgIEUoKGgpID0+IFt7IGVuZEluZGV4OiAwLCBzaXplOiBoLCBzdGFydEluZGV4OiAwIH1dKVxuICAgICAgKSxcbiAgICAgIG5cbiAgICApO1xuICAgIGNvbnN0IGEgPSBwdChcbiAgICAgIHgoXG4gICAgICAgIG4sXG4gICAgICAgIEcoSSksXG4gICAgICAgIGJ0KFxuICAgICAgICAgICh7IHNpemVzOiBoIH0sIFtkLCBSXSkgPT4gKHtcbiAgICAgICAgICAgIGNoYW5nZWQ6IFIgIT09IGgsXG4gICAgICAgICAgICBzaXplczogUlxuICAgICAgICAgIH0pLFxuICAgICAgICAgIHsgY2hhbmdlZDogITEsIHNpemVzOiB3IH1cbiAgICAgICAgKSxcbiAgICAgICAgRSgoaCkgPT4gaC5jaGFuZ2VkKVxuICAgICAgKVxuICAgICk7XG4gICAgSyhcbiAgICAgIHgoXG4gICAgICAgIGwsXG4gICAgICAgIGJ0KFxuICAgICAgICAgIChoLCBkKSA9PiAoeyBkaWZmOiBoLnByZXYgLSBkLCBwcmV2OiBkIH0pLFxuICAgICAgICAgIHsgZGlmZjogMCwgcHJldjogMCB9XG4gICAgICAgICksXG4gICAgICAgIEUoKGgpID0+IGguZGlmZilcbiAgICAgICksXG4gICAgICAoaCkgPT4ge1xuICAgICAgICBjb25zdCB7IGdyb3VwSW5kaWNlczogZCB9ID0gbHQoSSk7XG4gICAgICAgIGlmIChoID4gMClcbiAgICAgICAgICBXKGUsICEwKSwgVyhzLCBoICsgbW4oaCwgZCkpO1xuICAgICAgICBlbHNlIGlmIChoIDwgMCkge1xuICAgICAgICAgIGNvbnN0IFIgPSBsdChDKTtcbiAgICAgICAgICBSLmxlbmd0aCA+IDAgJiYgKGggLT0gbW4oLWgsIFIpKSwgVyhpLCBoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICksIEsoeChsLCBHKHQpKSwgKFtoLCBkXSkgPT4ge1xuICAgICAgaCA8IDAgJiYgZChcbiAgICAgICAgXCJgZmlyc3RJdGVtSW5kZXhgIHByb3Agc2hvdWxkIG5vdCBiZSBzZXQgdG8gbGVzcyB0aGFuIHplcm8uIElmIHlvdSBkb24ndCBrbm93IHRoZSB0b3RhbCBjb3VudCwganVzdCB1c2UgYSB2ZXJ5IGhpZ2ggdmFsdWVcIixcbiAgICAgICAgeyBmaXJzdEl0ZW1JbmRleDogbCB9LFxuICAgICAgICBodC5FUlJPUlxuICAgICAgKTtcbiAgICB9KTtcbiAgICBjb25zdCBUID0gcHQocyk7XG4gICAgRihcbiAgICAgIHgoXG4gICAgICAgIHMsXG4gICAgICAgIEcoSSksXG4gICAgICAgIEUoKFtoLCBkXSkgPT4ge1xuICAgICAgICAgIGNvbnN0IFIgPSBkLmdyb3VwSW5kaWNlcy5sZW5ndGggPiAwLCBCID0gW10sIE8gPSBkLmxhc3RTaXplO1xuICAgICAgICAgIGlmIChSKSB7XG4gICAgICAgICAgICBjb25zdCBMID0gcmUoZC5zaXplVHJlZSwgMCk7XG4gICAgICAgICAgICBsZXQgViA9IDAsIEQgPSAwO1xuICAgICAgICAgICAgZm9yICg7IFYgPCBoOyApIHtcbiAgICAgICAgICAgICAgY29uc3QgayA9IGQuZ3JvdXBJbmRpY2VzW0RdLCBxID0gZC5ncm91cEluZGljZXMubGVuZ3RoID09PSBEICsgMSA/IDEgLyAwIDogZC5ncm91cEluZGljZXNbRCArIDFdIC0gayAtIDE7XG4gICAgICAgICAgICAgIEIucHVzaCh7XG4gICAgICAgICAgICAgICAgZW5kSW5kZXg6IGssXG4gICAgICAgICAgICAgICAgc2l6ZTogTCxcbiAgICAgICAgICAgICAgICBzdGFydEluZGV4OiBrXG4gICAgICAgICAgICAgIH0pLCBCLnB1c2goe1xuICAgICAgICAgICAgICAgIGVuZEluZGV4OiBrICsgMSArIHEgLSAxLFxuICAgICAgICAgICAgICAgIHNpemU6IE8sXG4gICAgICAgICAgICAgICAgc3RhcnRJbmRleDogayArIDFcbiAgICAgICAgICAgICAgfSksIEQrKywgViArPSBxICsgMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IEogPSBfdChkLnNpemVUcmVlKTtcbiAgICAgICAgICAgIHJldHVybiBWICE9PSBoICYmIEouc2hpZnQoKSwgSi5yZWR1Y2UoXG4gICAgICAgICAgICAgIChrLCB7IGs6IHEsIHY6IHN0IH0pID0+IHtcbiAgICAgICAgICAgICAgICBsZXQgZHQgPSBrLnJhbmdlcztcbiAgICAgICAgICAgICAgICByZXR1cm4gay5wcmV2U2l6ZSAhPT0gMCAmJiAoZHQgPSBbXG4gICAgICAgICAgICAgICAgICAuLi5rLnJhbmdlcyxcbiAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgZW5kSW5kZXg6IHEgKyBoIC0gMSxcbiAgICAgICAgICAgICAgICAgICAgc2l6ZTogay5wcmV2U2l6ZSxcbiAgICAgICAgICAgICAgICAgICAgc3RhcnRJbmRleDogay5wcmV2SW5kZXhcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBdKSwge1xuICAgICAgICAgICAgICAgICAgcHJldkluZGV4OiBxICsgaCxcbiAgICAgICAgICAgICAgICAgIHByZXZTaXplOiBzdCxcbiAgICAgICAgICAgICAgICAgIHJhbmdlczogZHRcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgcHJldkluZGV4OiBoLFxuICAgICAgICAgICAgICAgIHByZXZTaXplOiAwLFxuICAgICAgICAgICAgICAgIHJhbmdlczogQlxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICApLnJhbmdlcztcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIF90KGQuc2l6ZVRyZWUpLnJlZHVjZShcbiAgICAgICAgICAgIChMLCB7IGs6IFYsIHY6IEQgfSkgPT4gKHtcbiAgICAgICAgICAgICAgcHJldkluZGV4OiBWICsgaCxcbiAgICAgICAgICAgICAgcHJldlNpemU6IEQsXG4gICAgICAgICAgICAgIHJhbmdlczogWy4uLkwucmFuZ2VzLCB7IGVuZEluZGV4OiBWICsgaCAtIDEsIHNpemU6IEwucHJldlNpemUsIHN0YXJ0SW5kZXg6IEwucHJldkluZGV4IH1dXG4gICAgICAgICAgICB9KSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgcHJldkluZGV4OiAwLFxuICAgICAgICAgICAgICBwcmV2U2l6ZTogTyxcbiAgICAgICAgICAgICAgcmFuZ2VzOiBbXVxuICAgICAgICAgICAgfVxuICAgICAgICAgICkucmFuZ2VzO1xuICAgICAgICB9KVxuICAgICAgKSxcbiAgICAgIG5cbiAgICApO1xuICAgIGNvbnN0IGIgPSBwdChcbiAgICAgIHgoXG4gICAgICAgIGksXG4gICAgICAgIEcoSSwgbSksXG4gICAgICAgIEUoKFtoLCB7IG9mZnNldFRyZWU6IGQgfSwgUl0pID0+IHtcbiAgICAgICAgICBjb25zdCBCID0gLWg7XG4gICAgICAgICAgcmV0dXJuIGllKEIsIGQsIFIpO1xuICAgICAgICB9KVxuICAgICAgKVxuICAgICk7XG4gICAgcmV0dXJuIEYoXG4gICAgICB4KFxuICAgICAgICBpLFxuICAgICAgICBHKEksIG0pLFxuICAgICAgICBFKChbaCwgZCwgUl0pID0+IHtcbiAgICAgICAgICBpZiAoZC5ncm91cEluZGljZXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgaWYgKGooZC5zaXplVHJlZSkpXG4gICAgICAgICAgICAgIHJldHVybiBkO1xuICAgICAgICAgICAgbGV0IE8gPSBVdCgpO1xuICAgICAgICAgICAgY29uc3QgTCA9IGx0KEMpO1xuICAgICAgICAgICAgbGV0IFYgPSAwLCBEID0gMCwgSiA9IDA7XG4gICAgICAgICAgICBmb3IgKDsgViA8IC1oOyApIHtcbiAgICAgICAgICAgICAgSiA9IExbRF07XG4gICAgICAgICAgICAgIGNvbnN0IGsgPSBMW0QgKyAxXSAtIEogLSAxO1xuICAgICAgICAgICAgICBEKyssIFYgKz0gayArIDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoTyA9IF90KGQuc2l6ZVRyZWUpLnJlZHVjZSgoaywgeyBrOiBxLCB2OiBzdCB9KSA9PiBtdChrLCBNYXRoLm1heCgwLCBxICsgaCksIHN0KSwgTyksIFYgIT09IC1oKSB7XG4gICAgICAgICAgICAgIGNvbnN0IGsgPSByZShkLnNpemVUcmVlLCBKKTtcbiAgICAgICAgICAgICAgTyA9IG10KE8sIDAsIGspO1xuICAgICAgICAgICAgICBjb25zdCBxID0gQ3QoZC5zaXplVHJlZSwgLWggKyAxKVsxXTtcbiAgICAgICAgICAgICAgTyA9IG10KE8sIDEsIHEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgLi4uZCxcbiAgICAgICAgICAgICAgc2l6ZVRyZWU6IE8sXG4gICAgICAgICAgICAgIC4uLlBlKGQub2Zmc2V0VHJlZSwgMCwgTywgUilcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IE8gPSBfdChkLnNpemVUcmVlKS5yZWR1Y2UoKEwsIHsgazogViwgdjogRCB9KSA9PiBtdChMLCBNYXRoLm1heCgwLCBWICsgaCksIEQpLCBVdCgpKTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgIC4uLmQsXG4gICAgICAgICAgICAgIHNpemVUcmVlOiBPLFxuICAgICAgICAgICAgICAuLi5QZShkLm9mZnNldFRyZWUsIDAsIE8sIFIpXG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH1cbiAgICAgICAgfSlcbiAgICAgICksXG4gICAgICBJXG4gICAgKSwge1xuICAgICAgYmVmb3JlVW5zaGlmdFdpdGg6IFQsXG4gICAgICAvLyBpbnB1dFxuICAgICAgZGF0YTogcCxcbiAgICAgIGRlZmF1bHRJdGVtU2l6ZTogZixcbiAgICAgIGZpcnN0SXRlbUluZGV4OiBsLFxuICAgICAgZml4ZWRJdGVtU2l6ZTogdSxcbiAgICAgIGdhcDogbSxcbiAgICAgIGdyb3VwSW5kaWNlczogYyxcbiAgICAgIGl0ZW1TaXplOiBTLFxuICAgICAgbGlzdFJlZnJlc2g6IGEsXG4gICAgICBzaGlmdFdpdGg6IGksXG4gICAgICBzaGlmdFdpdGhPZmZzZXQ6IGIsXG4gICAgICBzaXplUmFuZ2VzOiBuLFxuICAgICAgLy8gb3V0cHV0XG4gICAgICBzaXplczogSSxcbiAgICAgIHN0YXRlZnVsVG90YWxDb3VudDogcixcbiAgICAgIHRvdGFsQ291bnQ6IG8sXG4gICAgICB0cmFja0l0ZW1TaXplczogZyxcbiAgICAgIHVuc2hpZnRXaXRoOiBzXG4gICAgfTtcbiAgfSxcbiAgWChWdCwgTmUpLFxuICB7IHNpbmdsZXRvbjogITAgfVxuKTtcbmZ1bmN0aW9uIE9vKHQpIHtcbiAgcmV0dXJuIHQucmVkdWNlKFxuICAgIChlLCBuKSA9PiAoZS5ncm91cEluZGljZXMucHVzaChlLnRvdGFsQ291bnQpLCBlLnRvdGFsQ291bnQgKz0gbiArIDEsIGUpLFxuICAgIHtcbiAgICAgIGdyb3VwSW5kaWNlczogW10sXG4gICAgICB0b3RhbENvdW50OiAwXG4gICAgfVxuICApO1xufVxuY29uc3QgR24gPSBVKFxuICAoW3sgZ3JvdXBJbmRpY2VzOiB0LCBzaXplczogZSwgdG90YWxDb3VudDogbiB9LCB7IGhlYWRlckhlaWdodDogbywgc2Nyb2xsVG9wOiByIH1dKSA9PiB7XG4gICAgY29uc3QgcyA9ICQoKSwgaSA9ICQoKSwgbCA9IHB0KHgocywgRShPbykpKTtcbiAgICByZXR1cm4gRihcbiAgICAgIHgoXG4gICAgICAgIGwsXG4gICAgICAgIEUoKGMpID0+IGMudG90YWxDb3VudClcbiAgICAgICksXG4gICAgICBuXG4gICAgKSwgRihcbiAgICAgIHgoXG4gICAgICAgIGwsXG4gICAgICAgIEUoKGMpID0+IGMuZ3JvdXBJbmRpY2VzKVxuICAgICAgKSxcbiAgICAgIHRcbiAgICApLCBGKFxuICAgICAgeChcbiAgICAgICAgcnQociwgZSwgbyksXG4gICAgICAgIFAoKFtjLCB1XSkgPT4gYmUodSkpLFxuICAgICAgICBFKChbYywgdSwgZl0pID0+IEN0KHUuZ3JvdXBPZmZzZXRUcmVlLCBNYXRoLm1heChjIC0gZiwgMCksIFwidlwiKVswXSksXG4gICAgICAgIFkoKSxcbiAgICAgICAgRSgoYykgPT4gW2NdKVxuICAgICAgKSxcbiAgICAgIGlcbiAgICApLCB7IGdyb3VwQ291bnRzOiBzLCB0b3BJdGVtc0luZGV4ZXM6IGkgfTtcbiAgfSxcbiAgWChFdCwgYXQpXG4pLCBQdCA9IFUoXG4gIChbeyBsb2c6IHQgfV0pID0+IHtcbiAgICBjb25zdCBlID0geSghMSksIG4gPSBwdChcbiAgICAgIHgoXG4gICAgICAgIGUsXG4gICAgICAgIFAoKG8pID0+IG8pLFxuICAgICAgICBZKClcbiAgICAgIClcbiAgICApO1xuICAgIHJldHVybiBLKGUsIChvKSA9PiB7XG4gICAgICBvICYmIGx0KHQpKFwicHJvcHMgdXBkYXRlZFwiLCB7fSwgaHQuREVCVUcpO1xuICAgIH0pLCB7IGRpZE1vdW50OiBuLCBwcm9wc1JlYWR5OiBlIH07XG4gIH0sXG4gIFgoVnQpLFxuICB7IHNpbmdsZXRvbjogITAgfVxuKSwgRm8gPSB0eXBlb2YgZG9jdW1lbnQgPCBcInVcIiAmJiBcInNjcm9sbEJlaGF2aW9yXCIgaW4gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnN0eWxlO1xuZnVuY3Rpb24gTm4odCkge1xuICBjb25zdCBlID0gdHlwZW9mIHQgPT0gXCJudW1iZXJcIiA/IHsgaW5kZXg6IHQgfSA6IHQ7XG4gIHJldHVybiBlLmFsaWduIHx8IChlLmFsaWduID0gXCJzdGFydFwiKSwgKCFlLmJlaGF2aW9yIHx8ICFGbykgJiYgKGUuYmVoYXZpb3IgPSBcImF1dG9cIiksIGUub2Zmc2V0IHx8IChlLm9mZnNldCA9IDApLCBlO1xufVxuY29uc3QgY2UgPSBVKFxuICAoW1xuICAgIHsgZ2FwOiB0LCBsaXN0UmVmcmVzaDogZSwgc2l6ZXM6IG4sIHRvdGFsQ291bnQ6IG8gfSxcbiAgICB7XG4gICAgICBmaXhlZEZvb3RlckhlaWdodDogcixcbiAgICAgIGZpeGVkSGVhZGVySGVpZ2h0OiBzLFxuICAgICAgZm9vdGVySGVpZ2h0OiBpLFxuICAgICAgaGVhZGVySGVpZ2h0OiBsLFxuICAgICAgc2Nyb2xsaW5nSW5Qcm9ncmVzczogYyxcbiAgICAgIHNjcm9sbFRvOiB1LFxuICAgICAgc21vb3RoU2Nyb2xsVGFyZ2V0UmVhY2hlZDogZixcbiAgICAgIHZpZXdwb3J0SGVpZ2h0OiBTXG4gICAgfSxcbiAgICB7IGxvZzogcCB9XG4gIF0pID0+IHtcbiAgICBjb25zdCBtID0gJCgpLCB3ID0gJCgpLCBJID0geSgwKTtcbiAgICBsZXQgQyA9IG51bGwsIGcgPSBudWxsLCBhID0gbnVsbDtcbiAgICBmdW5jdGlvbiBUKCkge1xuICAgICAgQyAmJiAoQygpLCBDID0gbnVsbCksIGEgJiYgKGEoKSwgYSA9IG51bGwpLCBnICYmIChjbGVhclRpbWVvdXQoZyksIGcgPSBudWxsKSwgVyhjLCAhMSk7XG4gICAgfVxuICAgIHJldHVybiBGKFxuICAgICAgeChcbiAgICAgICAgbSxcbiAgICAgICAgRyhuLCBTLCBvLCBJLCBsLCBpLCBwKSxcbiAgICAgICAgRyh0LCBzLCByKSxcbiAgICAgICAgRShcbiAgICAgICAgICAoW1xuICAgICAgICAgICAgW2IsIGgsIGQsIFIsIEIsIE8sIEwsIFZdLFxuICAgICAgICAgICAgRCxcbiAgICAgICAgICAgIEosXG4gICAgICAgICAgICBudFxuICAgICAgICAgIF0pID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGsgPSBObihiKSwgeyBhbGlnbjogcSwgYmVoYXZpb3I6IHN0LCBvZmZzZXQ6IGR0IH0gPSBrLCBTdCA9IFIgLSAxLCBmdCA9IF9uKGssIGgsIFN0KTtcbiAgICAgICAgICAgIGxldCB1dCA9IGllKGZ0LCBoLm9mZnNldFRyZWUsIEQpICsgTztcbiAgICAgICAgICAgIHEgPT09IFwiZW5kXCIgPyAodXQgKz0gSiArIEN0KGguc2l6ZVRyZWUsIGZ0KVsxXSAtIGQgKyBudCwgZnQgPT09IFN0ICYmICh1dCArPSBMKSkgOiBxID09PSBcImNlbnRlclwiID8gdXQgKz0gKEogKyBDdChoLnNpemVUcmVlLCBmdClbMV0gLSBkICsgbnQpIC8gMiA6IHV0IC09IEIsIGR0ICYmICh1dCArPSBkdCk7XG4gICAgICAgICAgICBjb25zdCBBdCA9ICh4dCkgPT4ge1xuICAgICAgICAgICAgICBUKCksIHh0ID8gKFYoXCJyZXRyeWluZyB0byBzY3JvbGwgdG9cIiwgeyBsb2NhdGlvbjogYiB9LCBodC5ERUJVRyksIFcobSwgYikpIDogKFcodywgITApLCBWKFwibGlzdCBkaWQgbm90IGNoYW5nZSwgc2Nyb2xsIHN1Y2Nlc3NmdWxcIiwge30sIGh0LkRFQlVHKSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgaWYgKFQoKSwgc3QgPT09IFwic21vb3RoXCIpIHtcbiAgICAgICAgICAgICAgbGV0IHh0ID0gITE7XG4gICAgICAgICAgICAgIGEgPSBLKGUsIChYdCkgPT4ge1xuICAgICAgICAgICAgICAgIHh0ID0geHQgfHwgWHQ7XG4gICAgICAgICAgICAgIH0pLCBDID0gUnQoZiwgKCkgPT4ge1xuICAgICAgICAgICAgICAgIEF0KHh0KTtcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9IGVsc2VcbiAgICAgICAgICAgICAgQyA9IFJ0KHgoZSwgTG8oMTUwKSksIEF0KTtcbiAgICAgICAgICAgIHJldHVybiBnID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICAgIFQoKTtcbiAgICAgICAgICAgIH0sIDEyMDApLCBXKGMsICEwKSwgVihcInNjcm9sbGluZyBmcm9tIGluZGV4IHRvXCIsIHsgYmVoYXZpb3I6IHN0LCBpbmRleDogZnQsIHRvcDogdXQgfSwgaHQuREVCVUcpLCB7IGJlaGF2aW9yOiBzdCwgdG9wOiB1dCB9O1xuICAgICAgICAgIH1cbiAgICAgICAgKVxuICAgICAgKSxcbiAgICAgIHVcbiAgICApLCB7XG4gICAgICBzY3JvbGxUYXJnZXRSZWFjaGVkOiB3LFxuICAgICAgc2Nyb2xsVG9JbmRleDogbSxcbiAgICAgIHRvcExpc3RIZWlnaHQ6IElcbiAgICB9O1xuICB9LFxuICBYKEV0LCBhdCwgVnQpLFxuICB7IHNpbmdsZXRvbjogITAgfVxuKTtcbmZ1bmN0aW9uIExvKHQpIHtcbiAgcmV0dXJuIChlKSA9PiB7XG4gICAgY29uc3QgbiA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgZSghMSk7XG4gICAgfSwgdCk7XG4gICAgcmV0dXJuIChvKSA9PiB7XG4gICAgICBvICYmIChlKCEwKSwgY2xlYXJUaW1lb3V0KG4pKTtcbiAgICB9O1xuICB9O1xufVxuZnVuY3Rpb24gJGUodCwgZSkge1xuICB0ID09IDAgPyBlKCkgOiByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCkgPT4ge1xuICAgICRlKHQgLSAxLCBlKTtcbiAgfSk7XG59XG5mdW5jdGlvbiBVZSh0LCBlKSB7XG4gIGNvbnN0IG4gPSBlIC0gMTtcbiAgcmV0dXJuIHR5cGVvZiB0ID09IFwibnVtYmVyXCIgPyB0IDogdC5pbmRleCA9PT0gXCJMQVNUXCIgPyBuIDogdC5pbmRleDtcbn1cbmNvbnN0IHVlID0gVShcbiAgKFt7IGRlZmF1bHRJdGVtU2l6ZTogdCwgbGlzdFJlZnJlc2g6IGUsIHNpemVzOiBuIH0sIHsgc2Nyb2xsVG9wOiBvIH0sIHsgc2Nyb2xsVGFyZ2V0UmVhY2hlZDogciwgc2Nyb2xsVG9JbmRleDogcyB9LCB7IGRpZE1vdW50OiBpIH1dKSA9PiB7XG4gICAgY29uc3QgbCA9IHkoITApLCBjID0geSgwKSwgdSA9IHkoITApO1xuICAgIHJldHVybiBGKFxuICAgICAgeChcbiAgICAgICAgaSxcbiAgICAgICAgRyhjKSxcbiAgICAgICAgUCgoW2YsIFNdKSA9PiAhIVMpLFxuICAgICAgICB2dCghMSlcbiAgICAgICksXG4gICAgICBsXG4gICAgKSwgRihcbiAgICAgIHgoXG4gICAgICAgIGksXG4gICAgICAgIEcoYyksXG4gICAgICAgIFAoKFtmLCBTXSkgPT4gISFTKSxcbiAgICAgICAgdnQoITEpXG4gICAgICApLFxuICAgICAgdVxuICAgICksIEsoXG4gICAgICB4KFxuICAgICAgICBydChlLCBpKSxcbiAgICAgICAgRyhsLCBuLCB0LCB1KSxcbiAgICAgICAgUCgoW1ssIGZdLCBTLCB7IHNpemVUcmVlOiBwIH0sIG0sIHddKSA9PiBmICYmICghaihwKSB8fCBNZShtKSkgJiYgIVMgJiYgIXcpLFxuICAgICAgICBHKGMpXG4gICAgICApLFxuICAgICAgKFssIGZdKSA9PiB7XG4gICAgICAgIFJ0KHIsICgpID0+IHtcbiAgICAgICAgICBXKHUsICEwKTtcbiAgICAgICAgfSksICRlKDQsICgpID0+IHtcbiAgICAgICAgICBSdChvLCAoKSA9PiB7XG4gICAgICAgICAgICBXKGwsICEwKTtcbiAgICAgICAgICB9KSwgVyhzLCBmKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgKSwge1xuICAgICAgaW5pdGlhbEl0ZW1GaW5hbExvY2F0aW9uUmVhY2hlZDogdSxcbiAgICAgIGluaXRpYWxUb3BNb3N0SXRlbUluZGV4OiBjLFxuICAgICAgc2Nyb2xsZWRUb0luaXRpYWxJdGVtOiBsXG4gICAgfTtcbiAgfSxcbiAgWChFdCwgYXQsIGNlLCBQdCksXG4gIHsgc2luZ2xldG9uOiAhMCB9XG4pO1xuZnVuY3Rpb24gRG4odCwgZSkge1xuICByZXR1cm4gTWF0aC5hYnModCAtIGUpIDwgMS4wMTtcbn1cbmNvbnN0IGxlID0gXCJ1cFwiLCB0ZSA9IFwiZG93blwiLCB6byA9IFwibm9uZVwiLCBWbyA9IHtcbiAgYXRCb3R0b206ICExLFxuICBub3RBdEJvdHRvbUJlY2F1c2U6IFwiTk9UX1NIT1dJTkdfTEFTVF9JVEVNXCIsXG4gIHN0YXRlOiB7XG4gICAgb2Zmc2V0Qm90dG9tOiAwLFxuICAgIHNjcm9sbEhlaWdodDogMCxcbiAgICBzY3JvbGxUb3A6IDAsXG4gICAgdmlld3BvcnRIZWlnaHQ6IDBcbiAgfVxufSwgUG8gPSAwLCBhZSA9IFUoKFt7IGZvb3RlckhlaWdodDogdCwgaGVhZGVySGVpZ2h0OiBlLCBzY3JvbGxCeTogbiwgc2Nyb2xsQ29udGFpbmVyU3RhdGU6IG8sIHNjcm9sbFRvcDogciwgdmlld3BvcnRIZWlnaHQ6IHMgfV0pID0+IHtcbiAgY29uc3QgaSA9IHkoITEpLCBsID0geSghMCksIGMgPSAkKCksIHUgPSAkKCksIGYgPSB5KDQpLCBTID0geShQbyksIHAgPSBjdChcbiAgICB4KFxuICAgICAgYW4oeChBKHIpLCBqdCgxKSwgdnQoITApKSwgeChBKHIpLCBqdCgxKSwgdnQoITEpLCB1bigxMDApKSksXG4gICAgICBZKClcbiAgICApLFxuICAgICExXG4gICksIG0gPSBjdChcbiAgICB4KGFuKHgobiwgdnQoITApKSwgeChuLCB2dCghMSksIHVuKDIwMCkpKSwgWSgpKSxcbiAgICAhMVxuICApO1xuICBGKFxuICAgIHgoXG4gICAgICBydChBKHIpLCBBKFMpKSxcbiAgICAgIEUoKFthLCBUXSkgPT4gYSA8PSBUKSxcbiAgICAgIFkoKVxuICAgICksXG4gICAgbFxuICApLCBGKHgobCwgTHQoNTApKSwgdSk7XG4gIGNvbnN0IHcgPSBwdChcbiAgICB4KFxuICAgICAgcnQobywgQShzKSwgQShlKSwgQSh0KSwgQShmKSksXG4gICAgICBidCgoYSwgW3sgc2Nyb2xsSGVpZ2h0OiBULCBzY3JvbGxUb3A6IGIgfSwgaCwgZCwgUiwgQl0pID0+IHtcbiAgICAgICAgY29uc3QgTyA9IGIgKyBoIC0gVCA+IC1CLCBMID0ge1xuICAgICAgICAgIHNjcm9sbEhlaWdodDogVCxcbiAgICAgICAgICBzY3JvbGxUb3A6IGIsXG4gICAgICAgICAgdmlld3BvcnRIZWlnaHQ6IGhcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKE8pIHtcbiAgICAgICAgICBsZXQgRCwgSjtcbiAgICAgICAgICByZXR1cm4gYiA+IGEuc3RhdGUuc2Nyb2xsVG9wID8gKEQgPSBcIlNDUk9MTEVEX0RPV05cIiwgSiA9IGEuc3RhdGUuc2Nyb2xsVG9wIC0gYikgOiAoRCA9IFwiU0laRV9ERUNSRUFTRURcIiwgSiA9IGEuc3RhdGUuc2Nyb2xsVG9wIC0gYiB8fCBhLnNjcm9sbFRvcERlbHRhKSwge1xuICAgICAgICAgICAgYXRCb3R0b206ICEwLFxuICAgICAgICAgICAgYXRCb3R0b21CZWNhdXNlOiBELFxuICAgICAgICAgICAgc2Nyb2xsVG9wRGVsdGE6IEosXG4gICAgICAgICAgICBzdGF0ZTogTFxuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgbGV0IFY7XG4gICAgICAgIHJldHVybiBMLnNjcm9sbEhlaWdodCA+IGEuc3RhdGUuc2Nyb2xsSGVpZ2h0ID8gViA9IFwiU0laRV9JTkNSRUFTRURcIiA6IGggPCBhLnN0YXRlLnZpZXdwb3J0SGVpZ2h0ID8gViA9IFwiVklFV1BPUlRfSEVJR0hUX0RFQ1JFQVNJTkdcIiA6IGIgPCBhLnN0YXRlLnNjcm9sbFRvcCA/IFYgPSBcIlNDUk9MTElOR19VUFdBUkRTXCIgOiBWID0gXCJOT1RfRlVMTFlfU0NST0xMRURfVE9fTEFTVF9JVEVNX0JPVFRPTVwiLCB7XG4gICAgICAgICAgYXRCb3R0b206ICExLFxuICAgICAgICAgIG5vdEF0Qm90dG9tQmVjYXVzZTogVixcbiAgICAgICAgICBzdGF0ZTogTFxuICAgICAgICB9O1xuICAgICAgfSwgVm8pLFxuICAgICAgWSgoYSwgVCkgPT4gYSAmJiBhLmF0Qm90dG9tID09PSBULmF0Qm90dG9tKVxuICAgIClcbiAgKSwgSSA9IGN0KFxuICAgIHgoXG4gICAgICBvLFxuICAgICAgYnQoXG4gICAgICAgIChhLCB7IHNjcm9sbEhlaWdodDogVCwgc2Nyb2xsVG9wOiBiLCB2aWV3cG9ydEhlaWdodDogaCB9KSA9PiB7XG4gICAgICAgICAgaWYgKERuKGEuc2Nyb2xsSGVpZ2h0LCBUKSlcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgIGNoYW5nZWQ6ICExLFxuICAgICAgICAgICAgICBqdW1wOiAwLFxuICAgICAgICAgICAgICBzY3JvbGxIZWlnaHQ6IFQsXG4gICAgICAgICAgICAgIHNjcm9sbFRvcDogYlxuICAgICAgICAgICAgfTtcbiAgICAgICAgICB7XG4gICAgICAgICAgICBjb25zdCBkID0gVCAtIChiICsgaCkgPCAxO1xuICAgICAgICAgICAgcmV0dXJuIGEuc2Nyb2xsVG9wICE9PSBiICYmIGQgPyB7XG4gICAgICAgICAgICAgIGNoYW5nZWQ6ICEwLFxuICAgICAgICAgICAgICBqdW1wOiBhLnNjcm9sbFRvcCAtIGIsXG4gICAgICAgICAgICAgIHNjcm9sbEhlaWdodDogVCxcbiAgICAgICAgICAgICAgc2Nyb2xsVG9wOiBiXG4gICAgICAgICAgICB9IDoge1xuICAgICAgICAgICAgICBjaGFuZ2VkOiAhMCxcbiAgICAgICAgICAgICAganVtcDogMCxcbiAgICAgICAgICAgICAgc2Nyb2xsSGVpZ2h0OiBULFxuICAgICAgICAgICAgICBzY3JvbGxUb3A6IGJcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB7IGNoYW5nZWQ6ICExLCBqdW1wOiAwLCBzY3JvbGxIZWlnaHQ6IDAsIHNjcm9sbFRvcDogMCB9XG4gICAgICApLFxuICAgICAgUCgoYSkgPT4gYS5jaGFuZ2VkKSxcbiAgICAgIEUoKGEpID0+IGEuanVtcClcbiAgICApLFxuICAgIDBcbiAgKTtcbiAgRihcbiAgICB4KFxuICAgICAgdyxcbiAgICAgIEUoKGEpID0+IGEuYXRCb3R0b20pXG4gICAgKSxcbiAgICBpXG4gICksIEYoeChpLCBMdCg1MCkpLCBjKTtcbiAgY29uc3QgQyA9IHkodGUpO1xuICBGKFxuICAgIHgoXG4gICAgICBvLFxuICAgICAgRSgoeyBzY3JvbGxUb3A6IGEgfSkgPT4gYSksXG4gICAgICBZKCksXG4gICAgICBidChcbiAgICAgICAgKGEsIFQpID0+IGx0KG0pID8geyBkaXJlY3Rpb246IGEuZGlyZWN0aW9uLCBwcmV2U2Nyb2xsVG9wOiBUIH0gOiB7IGRpcmVjdGlvbjogVCA8IGEucHJldlNjcm9sbFRvcCA/IGxlIDogdGUsIHByZXZTY3JvbGxUb3A6IFQgfSxcbiAgICAgICAgeyBkaXJlY3Rpb246IHRlLCBwcmV2U2Nyb2xsVG9wOiAwIH1cbiAgICAgICksXG4gICAgICBFKChhKSA9PiBhLmRpcmVjdGlvbilcbiAgICApLFxuICAgIENcbiAgKSwgRih4KG8sIEx0KDUwKSwgdnQoem8pKSwgQyk7XG4gIGNvbnN0IGcgPSB5KDApO1xuICByZXR1cm4gRihcbiAgICB4KFxuICAgICAgcCxcbiAgICAgIFAoKGEpID0+ICFhKSxcbiAgICAgIHZ0KDApXG4gICAgKSxcbiAgICBnXG4gICksIEYoXG4gICAgeChcbiAgICAgIHIsXG4gICAgICBMdCgxMDApLFxuICAgICAgRyhwKSxcbiAgICAgIFAoKFthLCBUXSkgPT4gISFUKSxcbiAgICAgIGJ0KChbYSwgVF0sIFtiXSkgPT4gW1QsIGJdLCBbMCwgMF0pLFxuICAgICAgRSgoW2EsIFRdKSA9PiBUIC0gYSlcbiAgICApLFxuICAgIGdcbiAgKSwge1xuICAgIGF0Qm90dG9tU3RhdGU6IHcsXG4gICAgYXRCb3R0b21TdGF0ZUNoYW5nZTogYyxcbiAgICBhdEJvdHRvbVRocmVzaG9sZDogZixcbiAgICBhdFRvcFN0YXRlQ2hhbmdlOiB1LFxuICAgIGF0VG9wVGhyZXNob2xkOiBTLFxuICAgIGlzQXRCb3R0b206IGksXG4gICAgaXNBdFRvcDogbCxcbiAgICBpc1Njcm9sbGluZzogcCxcbiAgICBsYXN0SnVtcER1ZVRvSXRlbVJlc2l6ZTogSSxcbiAgICBzY3JvbGxEaXJlY3Rpb246IEMsXG4gICAgc2Nyb2xsVmVsb2NpdHk6IGdcbiAgfTtcbn0sIFgoYXQpKSwgeGUgPSBcInRvcFwiLCBUZSA9IFwiYm90dG9tXCIsIHBuID0gXCJub25lXCI7XG5mdW5jdGlvbiBobih0LCBlLCBuKSB7XG4gIHJldHVybiB0eXBlb2YgdCA9PSBcIm51bWJlclwiID8gbiA9PT0gbGUgJiYgZSA9PT0geGUgfHwgbiA9PT0gdGUgJiYgZSA9PT0gVGUgPyB0IDogMCA6IG4gPT09IGxlID8gZSA9PT0geGUgPyB0Lm1haW4gOiB0LnJldmVyc2UgOiBlID09PSBUZSA/IHQubWFpbiA6IHQucmV2ZXJzZTtcbn1cbmZ1bmN0aW9uIGduKHQsIGUpIHtcbiAgdmFyIG47XG4gIHJldHVybiB0eXBlb2YgdCA9PSBcIm51bWJlclwiID8gdCA6IChuID0gdFtlXSkgIT0gbnVsbCA/IG4gOiAwO1xufVxuY29uc3QgS2UgPSBVKFxuICAoW3sgZGV2aWF0aW9uOiB0LCBmaXhlZEhlYWRlckhlaWdodDogZSwgaGVhZGVySGVpZ2h0OiBuLCBzY3JvbGxUb3A6IG8sIHZpZXdwb3J0SGVpZ2h0OiByIH1dKSA9PiB7XG4gICAgY29uc3QgcyA9ICQoKSwgaSA9IHkoMCksIGwgPSB5KDApLCBjID0geSgwKSwgdSA9IGN0KFxuICAgICAgeChcbiAgICAgICAgcnQoXG4gICAgICAgICAgQShvKSxcbiAgICAgICAgICBBKHIpLFxuICAgICAgICAgIEEobiksXG4gICAgICAgICAgQShzLCBzZSksXG4gICAgICAgICAgQShjKSxcbiAgICAgICAgICBBKGkpLFxuICAgICAgICAgIEEoZSksXG4gICAgICAgICAgQSh0KSxcbiAgICAgICAgICBBKGwpXG4gICAgICAgICksXG4gICAgICAgIEUoXG4gICAgICAgICAgKFtcbiAgICAgICAgICAgIGYsXG4gICAgICAgICAgICBTLFxuICAgICAgICAgICAgcCxcbiAgICAgICAgICAgIFttLCB3XSxcbiAgICAgICAgICAgIEksXG4gICAgICAgICAgICBDLFxuICAgICAgICAgICAgZyxcbiAgICAgICAgICAgIGEsXG4gICAgICAgICAgICBUXG4gICAgICAgICAgXSkgPT4ge1xuICAgICAgICAgICAgY29uc3QgYiA9IGYgLSBhLCBoID0gQyArIGcsIGQgPSBNYXRoLm1heChwIC0gYiwgMCk7XG4gICAgICAgICAgICBsZXQgUiA9IHBuO1xuICAgICAgICAgICAgY29uc3QgQiA9IGduKFQsIHhlKSwgTyA9IGduKFQsIFRlKTtcbiAgICAgICAgICAgIHJldHVybiBtIC09IGEsIG0gKz0gcCArIGcsIHcgKz0gcCArIGcsIHcgLT0gYSwgbSA+IGYgKyBoIC0gQiAmJiAoUiA9IGxlKSwgdyA8IGYgLSBkICsgUyArIE8gJiYgKFIgPSB0ZSksIFIgIT09IHBuID8gW1xuICAgICAgICAgICAgICBNYXRoLm1heChiIC0gcCAtIGhuKEksIHhlLCBSKSAtIEIsIDApLFxuICAgICAgICAgICAgICBiIC0gZCAtIGcgKyBTICsgaG4oSSwgVGUsIFIpICsgT1xuICAgICAgICAgICAgXSA6IG51bGw7XG4gICAgICAgICAgfVxuICAgICAgICApLFxuICAgICAgICBQKChmKSA9PiBmICE9IG51bGwpLFxuICAgICAgICBZKHNlKVxuICAgICAgKSxcbiAgICAgIFswLCAwXVxuICAgICk7XG4gICAgcmV0dXJuIHtcbiAgICAgIGluY3JlYXNlVmlld3BvcnRCeTogbCxcbiAgICAgIC8vIGlucHV0XG4gICAgICBsaXN0Qm91bmRhcnk6IHMsXG4gICAgICBvdmVyc2NhbjogYyxcbiAgICAgIHRvcExpc3RIZWlnaHQ6IGksXG4gICAgICAvLyBvdXRwdXRcbiAgICAgIHZpc2libGVSYW5nZTogdVxuICAgIH07XG4gIH0sXG4gIFgoYXQpLFxuICB7IHNpbmdsZXRvbjogITAgfVxuKTtcbmZ1bmN0aW9uIEFvKHQsIGUsIG4pIHtcbiAgaWYgKGJlKGUpKSB7XG4gICAgY29uc3QgbyA9IFduKHQsIGUpO1xuICAgIHJldHVybiBbXG4gICAgICB7IGluZGV4OiBDdChlLmdyb3VwT2Zmc2V0VHJlZSwgbylbMF0sIG9mZnNldDogMCwgc2l6ZTogMCB9LFxuICAgICAgeyBkYXRhOiBuID09IG51bGwgPyB2b2lkIDAgOiBuWzBdLCBpbmRleDogbywgb2Zmc2V0OiAwLCBzaXplOiAwIH1cbiAgICBdO1xuICB9XG4gIHJldHVybiBbeyBkYXRhOiBuID09IG51bGwgPyB2b2lkIDAgOiBuWzBdLCBpbmRleDogdCwgb2Zmc2V0OiAwLCBzaXplOiAwIH1dO1xufVxuY29uc3Qga2UgPSB7XG4gIGJvdHRvbTogMCxcbiAgZmlyc3RJdGVtSW5kZXg6IDAsXG4gIGl0ZW1zOiBbXSxcbiAgb2Zmc2V0Qm90dG9tOiAwLFxuICBvZmZzZXRUb3A6IDAsXG4gIHRvcDogMCxcbiAgdG9wSXRlbXM6IFtdLFxuICB0b3BMaXN0SGVpZ2h0OiAwLFxuICB0b3RhbENvdW50OiAwXG59O1xuZnVuY3Rpb24gSWUodCwgZSwgbiwgbywgciwgcykge1xuICBjb25zdCB7IGxhc3RJbmRleDogaSwgbGFzdE9mZnNldDogbCwgbGFzdFNpemU6IGMgfSA9IHI7XG4gIGxldCB1ID0gMCwgZiA9IDA7XG4gIGlmICh0Lmxlbmd0aCA+IDApIHtcbiAgICB1ID0gdFswXS5vZmZzZXQ7XG4gICAgY29uc3QgSSA9IHRbdC5sZW5ndGggLSAxXTtcbiAgICBmID0gSS5vZmZzZXQgKyBJLnNpemU7XG4gIH1cbiAgY29uc3QgUyA9IG4gLSBpLCBwID0gbCArIFMgKiBjICsgKFMgLSAxKSAqIG8sIG0gPSB1LCB3ID0gcCAtIGY7XG4gIHJldHVybiB7XG4gICAgYm90dG9tOiBmLFxuICAgIGZpcnN0SXRlbUluZGV4OiBzLFxuICAgIGl0ZW1zOiBJbih0LCByLCBzKSxcbiAgICBvZmZzZXRCb3R0b206IHcsXG4gICAgb2Zmc2V0VG9wOiB1LFxuICAgIHRvcDogbSxcbiAgICB0b3BJdGVtczogSW4oZSwgciwgcyksXG4gICAgdG9wTGlzdEhlaWdodDogZS5yZWR1Y2UoKEksIEMpID0+IEMuc2l6ZSArIEksIDApLFxuICAgIHRvdGFsQ291bnQ6IG5cbiAgfTtcbn1cbmZ1bmN0aW9uICRuKHQsIGUsIG4sIG8sIHIsIHMpIHtcbiAgbGV0IGkgPSAwO1xuICBpZiAobi5ncm91cEluZGljZXMubGVuZ3RoID4gMClcbiAgICBmb3IgKGNvbnN0IGYgb2Ygbi5ncm91cEluZGljZXMpIHtcbiAgICAgIGlmIChmIC0gaSA+PSB0KVxuICAgICAgICBicmVhaztcbiAgICAgIGkrKztcbiAgICB9XG4gIGNvbnN0IGwgPSB0ICsgaSwgYyA9IFVlKGUsIGwpLCB1ID0gQXJyYXkuZnJvbSh7IGxlbmd0aDogbCB9KS5tYXAoKGYsIFMpID0+ICh7XG4gICAgZGF0YTogc1tTICsgY10sXG4gICAgaW5kZXg6IFMgKyBjLFxuICAgIG9mZnNldDogMCxcbiAgICBzaXplOiAwXG4gIH0pKTtcbiAgcmV0dXJuIEllKHUsIFtdLCBsLCByLCBuLCBvKTtcbn1cbmZ1bmN0aW9uIEluKHQsIGUsIG4pIHtcbiAgaWYgKHQubGVuZ3RoID09PSAwKVxuICAgIHJldHVybiBbXTtcbiAgaWYgKCFiZShlKSlcbiAgICByZXR1cm4gdC5tYXAoKHUpID0+ICh7IC4uLnUsIGluZGV4OiB1LmluZGV4ICsgbiwgb3JpZ2luYWxJbmRleDogdS5pbmRleCB9KSk7XG4gIGNvbnN0IG8gPSB0WzBdLmluZGV4LCByID0gdFt0Lmxlbmd0aCAtIDFdLmluZGV4LCBzID0gW10sIGkgPSB2ZShlLmdyb3VwT2Zmc2V0VHJlZSwgbywgcik7XG4gIGxldCBsLCBjID0gMDtcbiAgZm9yIChjb25zdCB1IG9mIHQpIHtcbiAgICAoIWwgfHwgbC5lbmQgPCB1LmluZGV4KSAmJiAobCA9IGkuc2hpZnQoKSwgYyA9IGUuZ3JvdXBJbmRpY2VzLmluZGV4T2YobC5zdGFydCkpO1xuICAgIGxldCBmO1xuICAgIHUuaW5kZXggPT09IGwuc3RhcnQgPyBmID0ge1xuICAgICAgaW5kZXg6IGMsXG4gICAgICB0eXBlOiBcImdyb3VwXCJcbiAgICB9IDogZiA9IHtcbiAgICAgIGdyb3VwSW5kZXg6IGMsXG4gICAgICBpbmRleDogdS5pbmRleCAtIChjICsgMSkgKyBuXG4gICAgfSwgcy5wdXNoKHtcbiAgICAgIC4uLmYsXG4gICAgICBkYXRhOiB1LmRhdGEsXG4gICAgICBvZmZzZXQ6IHUub2Zmc2V0LFxuICAgICAgb3JpZ2luYWxJbmRleDogdS5pbmRleCxcbiAgICAgIHNpemU6IHUuc2l6ZVxuICAgIH0pO1xuICB9XG4gIHJldHVybiBzO1xufVxuY29uc3QgR3QgPSBVKFxuICAoW1xuICAgIHsgZGF0YTogdCwgZmlyc3RJdGVtSW5kZXg6IGUsIGdhcDogbiwgc2l6ZXM6IG8sIHRvdGFsQ291bnQ6IHIgfSxcbiAgICBzLFxuICAgIHsgbGlzdEJvdW5kYXJ5OiBpLCB0b3BMaXN0SGVpZ2h0OiBsLCB2aXNpYmxlUmFuZ2U6IGMgfSxcbiAgICB7IGluaXRpYWxUb3BNb3N0SXRlbUluZGV4OiB1LCBzY3JvbGxlZFRvSW5pdGlhbEl0ZW06IGYgfSxcbiAgICB7IHRvcExpc3RIZWlnaHQ6IFMgfSxcbiAgICBwLFxuICAgIHsgZGlkTW91bnQ6IG0gfSxcbiAgICB7IHJlY2FsY0luUHJvZ3Jlc3M6IHcgfVxuICBdKSA9PiB7XG4gICAgY29uc3QgSSA9IHkoW10pLCBDID0geSgwKSwgZyA9ICQoKTtcbiAgICBGKHMudG9wSXRlbXNJbmRleGVzLCBJKTtcbiAgICBjb25zdCBhID0gY3QoXG4gICAgICB4KFxuICAgICAgICBydChcbiAgICAgICAgICBtLFxuICAgICAgICAgIHcsXG4gICAgICAgICAgQShjLCBzZSksXG4gICAgICAgICAgQShyKSxcbiAgICAgICAgICBBKG8pLFxuICAgICAgICAgIEEodSksXG4gICAgICAgICAgZixcbiAgICAgICAgICBBKEkpLFxuICAgICAgICAgIEEoZSksXG4gICAgICAgICAgQShuKSxcbiAgICAgICAgICB0XG4gICAgICAgICksXG4gICAgICAgIFAoKFtkLCBSLCAsIEIsICwgLCAsICwgLCAsIE9dKSA9PiB7XG4gICAgICAgICAgY29uc3QgTCA9IE8gJiYgTy5sZW5ndGggIT09IEI7XG4gICAgICAgICAgcmV0dXJuIGQgJiYgIVIgJiYgIUw7XG4gICAgICAgIH0pLFxuICAgICAgICBFKFxuICAgICAgICAgIChbXG4gICAgICAgICAgICAsXG4gICAgICAgICAgICAsXG4gICAgICAgICAgICBbZCwgUl0sXG4gICAgICAgICAgICBCLFxuICAgICAgICAgICAgTyxcbiAgICAgICAgICAgIEwsXG4gICAgICAgICAgICBWLFxuICAgICAgICAgICAgRCxcbiAgICAgICAgICAgIEosXG4gICAgICAgICAgICBudCxcbiAgICAgICAgICAgIGtcbiAgICAgICAgICBdKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBxID0gTywgeyBvZmZzZXRUcmVlOiBzdCwgc2l6ZVRyZWU6IGR0IH0gPSBxLCBTdCA9IGx0KEMpO1xuICAgICAgICAgICAgaWYgKEIgPT09IDApXG4gICAgICAgICAgICAgIHJldHVybiB7IC4uLmtlLCB0b3RhbENvdW50OiBCIH07XG4gICAgICAgICAgICBpZiAoZCA9PT0gMCAmJiBSID09PSAwKVxuICAgICAgICAgICAgICByZXR1cm4gU3QgPT09IDAgPyB7IC4uLmtlLCB0b3RhbENvdW50OiBCIH0gOiAkbihTdCwgTCwgTywgSiwgbnQsIGsgfHwgW10pO1xuICAgICAgICAgICAgaWYgKGooZHQpKVxuICAgICAgICAgICAgICByZXR1cm4gU3QgPiAwID8gbnVsbCA6IEllKFxuICAgICAgICAgICAgICAgIEFvKFVlKEwsIEIpLCBxLCBrKSxcbiAgICAgICAgICAgICAgICBbXSxcbiAgICAgICAgICAgICAgICBCLFxuICAgICAgICAgICAgICAgIG50LFxuICAgICAgICAgICAgICAgIHEsXG4gICAgICAgICAgICAgICAgSlxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgY29uc3QgZnQgPSBbXTtcbiAgICAgICAgICAgIGlmIChELmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgY29uc3QgTXQgPSBEWzBdLCB5dCA9IERbRC5sZW5ndGggLSAxXTtcbiAgICAgICAgICAgICAgbGV0IGt0ID0gMDtcbiAgICAgICAgICAgICAgZm9yIChjb25zdCB2IG9mIHZlKGR0LCBNdCwgeXQpKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgTiA9IHYudmFsdWUsIFEgPSBNYXRoLm1heCh2LnN0YXJ0LCBNdCksIGl0ID0gTWF0aC5taW4odi5lbmQsIHl0KTtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCB0dCA9IFE7IHR0IDw9IGl0OyB0dCsrKVxuICAgICAgICAgICAgICAgICAgZnQucHVzaCh7IGRhdGE6IGsgPT0gbnVsbCA/IHZvaWQgMCA6IGtbdHRdLCBpbmRleDogdHQsIG9mZnNldDoga3QsIHNpemU6IE4gfSksIGt0ICs9IE47XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghVilcbiAgICAgICAgICAgICAgcmV0dXJuIEllKFtdLCBmdCwgQiwgbnQsIHEsIEopO1xuICAgICAgICAgICAgY29uc3QgdXQgPSBELmxlbmd0aCA+IDAgPyBEW0QubGVuZ3RoIC0gMV0gKyAxIDogMCwgQXQgPSBibyhzdCwgZCwgUiwgdXQpO1xuICAgICAgICAgICAgaWYgKEF0Lmxlbmd0aCA9PT0gMClcbiAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICBjb25zdCB4dCA9IEIgLSAxLCBYdCA9IHllKFtdLCAoTXQpID0+IHtcbiAgICAgICAgICAgICAgZm9yIChjb25zdCB5dCBvZiBBdCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGt0ID0geXQudmFsdWU7XG4gICAgICAgICAgICAgICAgbGV0IHYgPSBrdC5vZmZzZXQsIE4gPSB5dC5zdGFydDtcbiAgICAgICAgICAgICAgICBjb25zdCBRID0ga3Quc2l6ZTtcbiAgICAgICAgICAgICAgICBpZiAoa3Qub2Zmc2V0IDwgZCkge1xuICAgICAgICAgICAgICAgICAgTiArPSBNYXRoLmZsb29yKChkIC0ga3Qub2Zmc2V0ICsgbnQpIC8gKFEgKyBudCkpO1xuICAgICAgICAgICAgICAgICAgY29uc3QgdHQgPSBOIC0geXQuc3RhcnQ7XG4gICAgICAgICAgICAgICAgICB2ICs9IHR0ICogUSArIHR0ICogbnQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIE4gPCB1dCAmJiAodiArPSAodXQgLSBOKSAqIFEsIE4gPSB1dCk7XG4gICAgICAgICAgICAgICAgY29uc3QgaXQgPSBNYXRoLm1pbih5dC5lbmQsIHh0KTtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCB0dCA9IE47IHR0IDw9IGl0ICYmICEodiA+PSBSKTsgdHQrKylcbiAgICAgICAgICAgICAgICAgIE10LnB1c2goeyBkYXRhOiBrID09IG51bGwgPyB2b2lkIDAgOiBrW3R0XSwgaW5kZXg6IHR0LCBvZmZzZXQ6IHYsIHNpemU6IFEgfSksIHYgKz0gUSArIG50O1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBJZShYdCwgZnQsIEIsIG50LCBxLCBKKTtcbiAgICAgICAgICB9XG4gICAgICAgICksXG4gICAgICAgIC8vQHRzLWV4cGVjdC1lcnJvciBmaWx0ZXIgbmVlZHMgdG8gYmUgZml4ZWRcbiAgICAgICAgUCgoZCkgPT4gZCAhPT0gbnVsbCksXG4gICAgICAgIFkoKVxuICAgICAgKSxcbiAgICAgIGtlXG4gICAgKTtcbiAgICBGKFxuICAgICAgeChcbiAgICAgICAgdCxcbiAgICAgICAgUChNZSksXG4gICAgICAgIEUoKGQpID0+IGQgPT0gbnVsbCA/IHZvaWQgMCA6IGQubGVuZ3RoKVxuICAgICAgKSxcbiAgICAgIHJcbiAgICApLCBGKFxuICAgICAgeChcbiAgICAgICAgYSxcbiAgICAgICAgRSgoZCkgPT4gZC50b3BMaXN0SGVpZ2h0KVxuICAgICAgKSxcbiAgICAgIFNcbiAgICApLCBGKFMsIGwpLCBGKFxuICAgICAgeChcbiAgICAgICAgYSxcbiAgICAgICAgRSgoZCkgPT4gW2QudG9wLCBkLmJvdHRvbV0pXG4gICAgICApLFxuICAgICAgaVxuICAgICksIEYoXG4gICAgICB4KFxuICAgICAgICBhLFxuICAgICAgICBFKChkKSA9PiBkLml0ZW1zKVxuICAgICAgKSxcbiAgICAgIGdcbiAgICApO1xuICAgIGNvbnN0IFQgPSBwdChcbiAgICAgIHgoXG4gICAgICAgIGEsXG4gICAgICAgIFAoKHsgaXRlbXM6IGQgfSkgPT4gZC5sZW5ndGggPiAwKSxcbiAgICAgICAgRyhyLCB0KSxcbiAgICAgICAgUCgoW3sgaXRlbXM6IGQgfSwgUl0pID0+IGRbZC5sZW5ndGggLSAxXS5vcmlnaW5hbEluZGV4ID09PSBSIC0gMSksXG4gICAgICAgIEUoKFssIGQsIFJdKSA9PiBbZCAtIDEsIFJdKSxcbiAgICAgICAgWShzZSksXG4gICAgICAgIEUoKFtkXSkgPT4gZClcbiAgICAgIClcbiAgICApLCBiID0gcHQoXG4gICAgICB4KFxuICAgICAgICBhLFxuICAgICAgICBMdCgyMDApLFxuICAgICAgICBQKCh7IGl0ZW1zOiBkLCB0b3BJdGVtczogUiB9KSA9PiBkLmxlbmd0aCA+IDAgJiYgZFswXS5vcmlnaW5hbEluZGV4ID09PSBSLmxlbmd0aCksXG4gICAgICAgIEUoKHsgaXRlbXM6IGQgfSkgPT4gZFswXS5pbmRleCksXG4gICAgICAgIFkoKVxuICAgICAgKVxuICAgICksIGggPSBwdChcbiAgICAgIHgoXG4gICAgICAgIGEsXG4gICAgICAgIFAoKHsgaXRlbXM6IGQgfSkgPT4gZC5sZW5ndGggPiAwKSxcbiAgICAgICAgRSgoeyBpdGVtczogZCB9KSA9PiB7XG4gICAgICAgICAgbGV0IFIgPSAwLCBCID0gZC5sZW5ndGggLSAxO1xuICAgICAgICAgIGZvciAoOyBkW1JdLnR5cGUgPT09IFwiZ3JvdXBcIiAmJiBSIDwgQjsgKVxuICAgICAgICAgICAgUisrO1xuICAgICAgICAgIGZvciAoOyBkW0JdLnR5cGUgPT09IFwiZ3JvdXBcIiAmJiBCID4gUjsgKVxuICAgICAgICAgICAgQi0tO1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBlbmRJbmRleDogZFtCXS5pbmRleCxcbiAgICAgICAgICAgIHN0YXJ0SW5kZXg6IGRbUl0uaW5kZXhcbiAgICAgICAgICB9O1xuICAgICAgICB9KSxcbiAgICAgICAgWShBbilcbiAgICAgIClcbiAgICApO1xuICAgIHJldHVybiB7IGVuZFJlYWNoZWQ6IFQsIGluaXRpYWxJdGVtQ291bnQ6IEMsIGl0ZW1zUmVuZGVyZWQ6IGcsIGxpc3RTdGF0ZTogYSwgcmFuZ2VDaGFuZ2VkOiBoLCBzdGFydFJlYWNoZWQ6IGIsIHRvcEl0ZW1zSW5kZXhlczogSSwgLi4ucCB9O1xuICB9LFxuICBYKFxuICAgIEV0LFxuICAgIEduLFxuICAgIEtlLFxuICAgIHVlLFxuICAgIGNlLFxuICAgIGFlLFxuICAgIFB0LFxuICAgIE5lXG4gICksXG4gIHsgc2luZ2xldG9uOiAhMCB9XG4pLCBVbiA9IFUoXG4gIChbeyBmaXhlZEZvb3RlckhlaWdodDogdCwgZml4ZWRIZWFkZXJIZWlnaHQ6IGUsIGZvb3RlckhlaWdodDogbiwgaGVhZGVySGVpZ2h0OiBvIH0sIHsgbGlzdFN0YXRlOiByIH1dKSA9PiB7XG4gICAgY29uc3QgcyA9ICQoKSwgaSA9IGN0KFxuICAgICAgeChcbiAgICAgICAgcnQobiwgdCwgbywgZSwgciksXG4gICAgICAgIEUoKFtsLCBjLCB1LCBmLCBTXSkgPT4gbCArIGMgKyB1ICsgZiArIFMub2Zmc2V0Qm90dG9tICsgUy5ib3R0b20pXG4gICAgICApLFxuICAgICAgMFxuICAgICk7XG4gICAgcmV0dXJuIEYoQShpKSwgcyksIHsgdG90YWxMaXN0SGVpZ2h0OiBpLCB0b3RhbExpc3RIZWlnaHRDaGFuZ2VkOiBzIH07XG4gIH0sXG4gIFgoYXQsIEd0KSxcbiAgeyBzaW5nbGV0b246ICEwIH1cbiksIE1vID0gVShcbiAgKFt7IHZpZXdwb3J0SGVpZ2h0OiB0IH0sIHsgdG90YWxMaXN0SGVpZ2h0OiBlIH1dKSA9PiB7XG4gICAgY29uc3QgbiA9IHkoITEpLCBvID0gY3QoXG4gICAgICB4KFxuICAgICAgICBydChuLCB0LCBlKSxcbiAgICAgICAgUCgoW3JdKSA9PiByKSxcbiAgICAgICAgRSgoWywgciwgc10pID0+IE1hdGgubWF4KDAsIHIgLSBzKSksXG4gICAgICAgIEx0KDApLFxuICAgICAgICBZKClcbiAgICAgICksXG4gICAgICAwXG4gICAgKTtcbiAgICByZXR1cm4geyBhbGlnblRvQm90dG9tOiBuLCBwYWRkaW5nVG9wQWRkaXRpb246IG8gfTtcbiAgfSxcbiAgWChhdCwgVW4pLFxuICB7IHNpbmdsZXRvbjogITAgfVxuKTtcbmZ1bmN0aW9uIFNuKHQpIHtcbiAgcmV0dXJuIHQgPyB0ID09PSBcInNtb290aFwiID8gXCJzbW9vdGhcIiA6IFwiYXV0b1wiIDogITE7XG59XG5jb25zdCBXbyA9ICh0LCBlKSA9PiB0eXBlb2YgdCA9PSBcImZ1bmN0aW9uXCIgPyBTbih0KGUpKSA6IGUgJiYgU24odCksIF9vID0gVShcbiAgKFtcbiAgICB7IGxpc3RSZWZyZXNoOiB0LCB0b3RhbENvdW50OiBlIH0sXG4gICAgeyBhdEJvdHRvbVN0YXRlOiBuLCBpc0F0Qm90dG9tOiBvIH0sXG4gICAgeyBzY3JvbGxUb0luZGV4OiByIH0sXG4gICAgeyBzY3JvbGxlZFRvSW5pdGlhbEl0ZW06IHMgfSxcbiAgICB7IGRpZE1vdW50OiBpLCBwcm9wc1JlYWR5OiBsIH0sXG4gICAgeyBsb2c6IGMgfSxcbiAgICB7IHNjcm9sbGluZ0luUHJvZ3Jlc3M6IHUgfVxuICBdKSA9PiB7XG4gICAgY29uc3QgZiA9IHkoITEpLCBTID0gJCgpO1xuICAgIGxldCBwID0gbnVsbDtcbiAgICBmdW5jdGlvbiBtKEkpIHtcbiAgICAgIFcociwge1xuICAgICAgICBhbGlnbjogXCJlbmRcIixcbiAgICAgICAgYmVoYXZpb3I6IEksXG4gICAgICAgIGluZGV4OiBcIkxBU1RcIlxuICAgICAgfSk7XG4gICAgfVxuICAgIEsoXG4gICAgICB4KFxuICAgICAgICBydCh4KEEoZSksIGp0KDEpKSwgaSksXG4gICAgICAgIEcoQShmKSwgbywgcywgdSksXG4gICAgICAgIEUoKFtbSSwgQ10sIGcsIGEsIFQsIGJdKSA9PiB7XG4gICAgICAgICAgbGV0IGggPSBDICYmIFQsIGQgPSBcImF1dG9cIjtcbiAgICAgICAgICByZXR1cm4gaCAmJiAoZCA9IFdvKGcsIGEgfHwgYiksIGggPSBoICYmICEhZCksIHsgZm9sbG93T3V0cHV0QmVoYXZpb3I6IGQsIHNob3VsZEZvbGxvdzogaCwgdG90YWxDb3VudDogSSB9O1xuICAgICAgICB9KSxcbiAgICAgICAgUCgoeyBzaG91bGRGb2xsb3c6IEkgfSkgPT4gSSlcbiAgICAgICksXG4gICAgICAoeyBmb2xsb3dPdXRwdXRCZWhhdmlvcjogSSwgdG90YWxDb3VudDogQyB9KSA9PiB7XG4gICAgICAgIHAgJiYgKHAoKSwgcCA9IG51bGwpLCBwID0gUnQodCwgKCkgPT4ge1xuICAgICAgICAgIGx0KGMpKFwiZm9sbG93aW5nIG91dHB1dCB0byBcIiwgeyB0b3RhbENvdW50OiBDIH0sIGh0LkRFQlVHKSwgbShJKSwgcCA9IG51bGw7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICk7XG4gICAgZnVuY3Rpb24gdyhJKSB7XG4gICAgICBjb25zdCBDID0gUnQobiwgKGcpID0+IHtcbiAgICAgICAgSSAmJiAhZy5hdEJvdHRvbSAmJiBnLm5vdEF0Qm90dG9tQmVjYXVzZSA9PT0gXCJTSVpFX0lOQ1JFQVNFRFwiICYmICFwICYmIChsdChjKShcInNjcm9sbGluZyB0byBib3R0b20gZHVlIHRvIGluY3JlYXNlZCBzaXplXCIsIHt9LCBodC5ERUJVRyksIG0oXCJhdXRvXCIpKTtcbiAgICAgIH0pO1xuICAgICAgc2V0VGltZW91dChDLCAxMDApO1xuICAgIH1cbiAgICByZXR1cm4gSyhcbiAgICAgIHgoXG4gICAgICAgIHJ0KEEoZiksIGUsIGwpLFxuICAgICAgICBQKChbSSwgLCBDXSkgPT4gSSAmJiBDKSxcbiAgICAgICAgYnQoXG4gICAgICAgICAgKHsgdmFsdWU6IEkgfSwgWywgQ10pID0+ICh7IHJlZnJlc2hlZDogSSA9PT0gQywgdmFsdWU6IEMgfSksXG4gICAgICAgICAgeyByZWZyZXNoZWQ6ICExLCB2YWx1ZTogMCB9XG4gICAgICAgICksXG4gICAgICAgIFAoKHsgcmVmcmVzaGVkOiBJIH0pID0+IEkpLFxuICAgICAgICBHKGYsIGUpXG4gICAgICApLFxuICAgICAgKFssIEldKSA9PiB7XG4gICAgICAgIGx0KHMpICYmIHcoSSAhPT0gITEpO1xuICAgICAgfVxuICAgICksIEsoUywgKCkgPT4ge1xuICAgICAgdyhsdChmKSAhPT0gITEpO1xuICAgIH0pLCBLKHJ0KEEoZiksIG4pLCAoW0ksIENdKSA9PiB7XG4gICAgICBJICYmICFDLmF0Qm90dG9tICYmIEMubm90QXRCb3R0b21CZWNhdXNlID09PSBcIlZJRVdQT1JUX0hFSUdIVF9ERUNSRUFTSU5HXCIgJiYgbShcImF1dG9cIik7XG4gICAgfSksIHsgYXV0b3Njcm9sbFRvQm90dG9tOiBTLCBmb2xsb3dPdXRwdXQ6IGYgfTtcbiAgfSxcbiAgWChFdCwgYWUsIGNlLCB1ZSwgUHQsIFZ0LCBhdClcbiksIEdvID0gVShcbiAgKFt7IGRhdGE6IHQsIGZpcnN0SXRlbUluZGV4OiBlLCBnYXA6IG4sIHNpemVzOiBvIH0sIHsgaW5pdGlhbFRvcE1vc3RJdGVtSW5kZXg6IHIgfSwgeyBpbml0aWFsSXRlbUNvdW50OiBzLCBsaXN0U3RhdGU6IGkgfSwgeyBkaWRNb3VudDogbCB9XSkgPT4gKEYoXG4gICAgeChcbiAgICAgIGwsXG4gICAgICBHKHMpLFxuICAgICAgUCgoWywgY10pID0+IGMgIT09IDApLFxuICAgICAgRyhyLCBvLCBlLCBuLCB0KSxcbiAgICAgIEUoKFtbLCBjXSwgdSwgZiwgUywgcCwgbSA9IFtdXSkgPT4gJG4oYywgdSwgZiwgUywgcCwgbSkpXG4gICAgKSxcbiAgICBpXG4gICksIHt9KSxcbiAgWChFdCwgdWUsIEd0LCBQdCksXG4gIHsgc2luZ2xldG9uOiAhMCB9XG4pLCBObyA9IFUoXG4gIChbeyBkaWRNb3VudDogdCB9LCB7IHNjcm9sbFRvOiBlIH0sIHsgbGlzdFN0YXRlOiBuIH1dKSA9PiB7XG4gICAgY29uc3QgbyA9IHkoMCk7XG4gICAgcmV0dXJuIEsoXG4gICAgICB4KFxuICAgICAgICB0LFxuICAgICAgICBHKG8pLFxuICAgICAgICBQKChbLCByXSkgPT4gciAhPT0gMCksXG4gICAgICAgIEUoKFssIHJdKSA9PiAoeyB0b3A6IHIgfSkpXG4gICAgICApLFxuICAgICAgKHIpID0+IHtcbiAgICAgICAgUnQoXG4gICAgICAgICAgeChcbiAgICAgICAgICAgIG4sXG4gICAgICAgICAgICBqdCgxKSxcbiAgICAgICAgICAgIFAoKHMpID0+IHMuaXRlbXMubGVuZ3RoID4gMSlcbiAgICAgICAgICApLFxuICAgICAgICAgICgpID0+IHtcbiAgICAgICAgICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZSgoKSA9PiB7XG4gICAgICAgICAgICAgIFcoZSwgcik7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgICk7XG4gICAgICB9XG4gICAgKSwge1xuICAgICAgaW5pdGlhbFNjcm9sbFRvcDogb1xuICAgIH07XG4gIH0sXG4gIFgoUHQsIGF0LCBHdCksXG4gIHsgc2luZ2xldG9uOiAhMCB9XG4pLCBEbyA9ICh7XG4gIGl0ZW1Cb3R0b206IHQsXG4gIGl0ZW1Ub3A6IGUsXG4gIGxvY2F0aW9uUGFyYW1zOiB7IGFsaWduOiBuLCBiZWhhdmlvcjogbywgLi4uciB9LFxuICB2aWV3cG9ydEJvdHRvbTogcyxcbiAgdmlld3BvcnRUb3A6IGlcbn0pID0+IGUgPCBpID8geyAuLi5yLCBhbGlnbjogbiAhPSBudWxsID8gbiA6IFwic3RhcnRcIiwgYmVoYXZpb3I6IG8gfSA6IHQgPiBzID8geyAuLi5yLCBhbGlnbjogbiAhPSBudWxsID8gbiA6IFwiZW5kXCIsIGJlaGF2aW9yOiBvIH0gOiBudWxsLCAkbyA9IFUoXG4gIChbXG4gICAgeyBnYXA6IHQsIHNpemVzOiBlLCB0b3RhbENvdW50OiBuIH0sXG4gICAgeyBmaXhlZEZvb3RlckhlaWdodDogbywgZml4ZWRIZWFkZXJIZWlnaHQ6IHIsIGhlYWRlckhlaWdodDogcywgc2Nyb2xsaW5nSW5Qcm9ncmVzczogaSwgc2Nyb2xsVG9wOiBsLCB2aWV3cG9ydEhlaWdodDogYyB9LFxuICAgIHsgc2Nyb2xsVG9JbmRleDogdSB9XG4gIF0pID0+IHtcbiAgICBjb25zdCBmID0gJCgpO1xuICAgIHJldHVybiBGKFxuICAgICAgeChcbiAgICAgICAgZixcbiAgICAgICAgRyhlLCBjLCBuLCBzLCByLCBvLCBsKSxcbiAgICAgICAgRyh0KSxcbiAgICAgICAgRSgoW1tTLCBwLCBtLCB3LCBJLCBDLCBnLCBhXSwgVF0pID0+IHtcbiAgICAgICAgICBjb25zdCB7IGFsaWduOiBiLCBiZWhhdmlvcjogaCwgY2FsY3VsYXRlVmlld0xvY2F0aW9uOiBkID0gRG8sIGRvbmU6IFIsIC4uLkIgfSA9IFMsIE8gPSBfbihTLCBwLCB3IC0gMSksIEwgPSBpZShPLCBwLm9mZnNldFRyZWUsIFQpICsgSSArIEMsIFYgPSBMICsgQ3QocC5zaXplVHJlZSwgTylbMV0sIEQgPSBhICsgQywgSiA9IGEgKyBtIC0gZywgbnQgPSBkKHtcbiAgICAgICAgICAgIGl0ZW1Cb3R0b206IFYsXG4gICAgICAgICAgICBpdGVtVG9wOiBMLFxuICAgICAgICAgICAgbG9jYXRpb25QYXJhbXM6IHsgYWxpZ246IGIsIGJlaGF2aW9yOiBoLCAuLi5CIH0sXG4gICAgICAgICAgICB2aWV3cG9ydEJvdHRvbTogSixcbiAgICAgICAgICAgIHZpZXdwb3J0VG9wOiBEXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgcmV0dXJuIG50ID8gUiAmJiBSdChcbiAgICAgICAgICAgIHgoXG4gICAgICAgICAgICAgIGksXG4gICAgICAgICAgICAgIFAoKGspID0+ICFrKSxcbiAgICAgICAgICAgICAgLy8gc2tpcHMgdGhlIGluaXRpYWwgcHVibGlzaCBvZiBmYWxzZSwgYW5kIHRoZSBjbGVhbnVwIGNhbGwuXG4gICAgICAgICAgICAgIC8vIGJ1dCBpZiBzY3JvbGxpbmdJblByb2dyZXNzIGlzIHRydWUsIHdlIHNraXAgdGhlIGluaXRpYWwgcHVibGlzaC5cbiAgICAgICAgICAgICAganQobHQoaSkgPyAxIDogMilcbiAgICAgICAgICAgICksXG4gICAgICAgICAgICBSXG4gICAgICAgICAgKSA6IFIgJiYgUigpLCBudDtcbiAgICAgICAgfSksXG4gICAgICAgIFAoKFMpID0+IFMgIT09IG51bGwpXG4gICAgICApLFxuICAgICAgdVxuICAgICksIHtcbiAgICAgIHNjcm9sbEludG9WaWV3OiBmXG4gICAgfTtcbiAgfSxcbiAgWChFdCwgYXQsIGNlLCBHdCwgVnQpLFxuICB7IHNpbmdsZXRvbjogITAgfVxuKSwgS24gPSBVKFxuICAoW3sgc2Nyb2xsVmVsb2NpdHk6IHQgfV0pID0+IHtcbiAgICBjb25zdCBlID0geSghMSksIG4gPSAkKCksIG8gPSB5KCExKTtcbiAgICByZXR1cm4gRihcbiAgICAgIHgoXG4gICAgICAgIHQsXG4gICAgICAgIEcobywgZSwgbiksXG4gICAgICAgIFAoKFtyLCBzXSkgPT4gISFzKSxcbiAgICAgICAgRSgoW3IsIHMsIGksIGxdKSA9PiB7XG4gICAgICAgICAgY29uc3QgeyBlbnRlcjogYywgZXhpdDogdSB9ID0gcztcbiAgICAgICAgICBpZiAoaSkge1xuICAgICAgICAgICAgaWYgKHUociwgbCkpXG4gICAgICAgICAgICAgIHJldHVybiAhMTtcbiAgICAgICAgICB9IGVsc2UgaWYgKGMociwgbCkpXG4gICAgICAgICAgICByZXR1cm4gITA7XG4gICAgICAgICAgcmV0dXJuIGk7XG4gICAgICAgIH0pLFxuICAgICAgICBZKClcbiAgICAgICksXG4gICAgICBlXG4gICAgKSwgSyhcbiAgICAgIHgocnQoZSwgdCwgbiksIEcobykpLFxuICAgICAgKFtbciwgcywgaV0sIGxdKSA9PiB7XG4gICAgICAgIHIgJiYgbCAmJiBsLmNoYW5nZSAmJiBsLmNoYW5nZShzLCBpKTtcbiAgICAgIH1cbiAgICApLCB7IGlzU2Vla2luZzogZSwgc2Nyb2xsU2Vla0NvbmZpZ3VyYXRpb246IG8sIHNjcm9sbFNlZWtSYW5nZUNoYW5nZWQ6IG4sIHNjcm9sbFZlbG9jaXR5OiB0IH07XG4gIH0sXG4gIFgoYWUpLFxuICB7IHNpbmdsZXRvbjogITAgfVxuKSwgamUgPSBVKChbeyBzY3JvbGxDb250YWluZXJTdGF0ZTogdCwgc2Nyb2xsVG86IGUgfV0pID0+IHtcbiAgY29uc3QgbiA9ICQoKSwgbyA9ICQoKSwgciA9ICQoKSwgcyA9IHkoITEpLCBpID0geSh2b2lkIDApO1xuICByZXR1cm4gRihcbiAgICB4KFxuICAgICAgcnQobiwgbyksXG4gICAgICBFKChbeyBzY3JvbGxIZWlnaHQ6IGwsIHNjcm9sbFRvcDogYywgdmlld3BvcnRIZWlnaHQ6IHUgfSwgeyBvZmZzZXRUb3A6IGYgfV0pID0+ICh7XG4gICAgICAgIHNjcm9sbEhlaWdodDogbCxcbiAgICAgICAgc2Nyb2xsVG9wOiBNYXRoLm1heCgwLCBjIC0gZiksXG4gICAgICAgIHZpZXdwb3J0SGVpZ2h0OiB1XG4gICAgICB9KSlcbiAgICApLFxuICAgIHRcbiAgKSwgRihcbiAgICB4KFxuICAgICAgZSxcbiAgICAgIEcobyksXG4gICAgICBFKChbbCwgeyBvZmZzZXRUb3A6IGMgfV0pID0+ICh7XG4gICAgICAgIC4uLmwsXG4gICAgICAgIHRvcDogbC50b3AgKyBjXG4gICAgICB9KSlcbiAgICApLFxuICAgIHJcbiAgKSwge1xuICAgIGN1c3RvbVNjcm9sbFBhcmVudDogaSxcbiAgICAvLyBjb25maWdcbiAgICB1c2VXaW5kb3dTY3JvbGw6IHMsXG4gICAgLy8gaW5wdXRcbiAgICB3aW5kb3dTY3JvbGxDb250YWluZXJTdGF0ZTogbixcbiAgICAvLyBzaWduYWxzXG4gICAgd2luZG93U2Nyb2xsVG86IHIsXG4gICAgd2luZG93Vmlld3BvcnRSZWN0OiBvXG4gIH07XG59LCBYKGF0KSksIFVvID0gVShcbiAgKFtcbiAgICB7IHNpemVSYW5nZXM6IHQsIHNpemVzOiBlIH0sXG4gICAgeyBoZWFkZXJIZWlnaHQ6IG4sIHNjcm9sbFRvcDogbyB9LFxuICAgIHsgaW5pdGlhbFRvcE1vc3RJdGVtSW5kZXg6IHIgfSxcbiAgICB7IGRpZE1vdW50OiBzIH0sXG4gICAgeyB1c2VXaW5kb3dTY3JvbGw6IGksIHdpbmRvd1Njcm9sbENvbnRhaW5lclN0YXRlOiBsLCB3aW5kb3dWaWV3cG9ydFJlY3Q6IGMgfVxuICBdKSA9PiB7XG4gICAgY29uc3QgdSA9ICQoKSwgZiA9IHkodm9pZCAwKSwgUyA9IHkobnVsbCksIHAgPSB5KG51bGwpO1xuICAgIHJldHVybiBGKGwsIFMpLCBGKGMsIHApLCBLKFxuICAgICAgeChcbiAgICAgICAgdSxcbiAgICAgICAgRyhlLCBvLCBpLCBTLCBwLCBuKVxuICAgICAgKSxcbiAgICAgIChbbSwgdywgSSwgQywgZywgYSwgVF0pID0+IHtcbiAgICAgICAgY29uc3QgYiA9IEhvKHcuc2l6ZVRyZWUpO1xuICAgICAgICBDICYmIGcgIT09IG51bGwgJiYgYSAhPT0gbnVsbCAmJiAoSSA9IGcuc2Nyb2xsVG9wIC0gYS5vZmZzZXRUb3ApLCBJIC09IFQsIG0oeyByYW5nZXM6IGIsIHNjcm9sbFRvcDogSSB9KTtcbiAgICAgIH1cbiAgICApLCBGKHgoZiwgUChNZSksIEUoS28pKSwgciksIEYoXG4gICAgICB4KFxuICAgICAgICBzLFxuICAgICAgICBHKGYpLFxuICAgICAgICBQKChbLCBtXSkgPT4gbSAhPT0gdm9pZCAwKSxcbiAgICAgICAgWSgpLFxuICAgICAgICBFKChbLCBtXSkgPT4gbS5yYW5nZXMpXG4gICAgICApLFxuICAgICAgdFxuICAgICksIHtcbiAgICAgIGdldFN0YXRlOiB1LFxuICAgICAgcmVzdG9yZVN0YXRlRnJvbTogZlxuICAgIH07XG4gIH0sXG4gIFgoRXQsIGF0LCB1ZSwgUHQsIGplKVxuKTtcbmZ1bmN0aW9uIEtvKHQpIHtcbiAgcmV0dXJuIHsgYWxpZ246IFwic3RhcnRcIiwgaW5kZXg6IDAsIG9mZnNldDogdC5zY3JvbGxUb3AgfTtcbn1cbmNvbnN0IGpvID0gVSgoW3sgdG9wSXRlbXNJbmRleGVzOiB0IH1dKSA9PiB7XG4gIGNvbnN0IGUgPSB5KDApO1xuICByZXR1cm4gRihcbiAgICB4KFxuICAgICAgZSxcbiAgICAgIFAoKG4pID0+IG4gPj0gMCksXG4gICAgICBFKChuKSA9PiBBcnJheS5mcm9tKHsgbGVuZ3RoOiBuIH0pLm1hcCgobywgcikgPT4gcikpXG4gICAgKSxcbiAgICB0XG4gICksIHsgdG9wSXRlbUNvdW50OiBlIH07XG59LCBYKEd0KSk7XG5mdW5jdGlvbiBqbih0KSB7XG4gIGxldCBlID0gITEsIG47XG4gIHJldHVybiAoKSA9PiAoZSB8fCAoZSA9ICEwLCBuID0gdCgpKSwgbik7XG59XG5jb25zdCBxbyA9IGpuKCgpID0+IC9pUChhZHxvZHxob25lKS9pLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCkgJiYgL1dlYktpdC9pLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCkpLCBZbyA9IFUoXG4gIChbXG4gICAgeyBkZXZpYXRpb246IHQsIHNjcm9sbEJ5OiBlLCBzY3JvbGxpbmdJblByb2dyZXNzOiBuLCBzY3JvbGxUb3A6IG8gfSxcbiAgICB7IGlzQXRCb3R0b206IHIsIGlzU2Nyb2xsaW5nOiBzLCBsYXN0SnVtcER1ZVRvSXRlbVJlc2l6ZTogaSwgc2Nyb2xsRGlyZWN0aW9uOiBsIH0sXG4gICAgeyBsaXN0U3RhdGU6IGMgfSxcbiAgICB7IGJlZm9yZVVuc2hpZnRXaXRoOiB1LCBnYXA6IGYsIHNoaWZ0V2l0aE9mZnNldDogUywgc2l6ZXM6IHAgfSxcbiAgICB7IGxvZzogbSB9LFxuICAgIHsgcmVjYWxjSW5Qcm9ncmVzczogdyB9XG4gIF0pID0+IHtcbiAgICBjb25zdCBJID0gcHQoXG4gICAgICB4KFxuICAgICAgICBjLFxuICAgICAgICBHKGkpLFxuICAgICAgICBidChcbiAgICAgICAgICAoWywgZywgYSwgVF0sIFt7IGJvdHRvbTogYiwgaXRlbXM6IGgsIG9mZnNldEJvdHRvbTogZCwgdG90YWxDb3VudDogUiB9LCBCXSkgPT4ge1xuICAgICAgICAgICAgY29uc3QgTyA9IGIgKyBkO1xuICAgICAgICAgICAgbGV0IEwgPSAwO1xuICAgICAgICAgICAgcmV0dXJuIGEgPT09IFIgJiYgZy5sZW5ndGggPiAwICYmIGgubGVuZ3RoID4gMCAmJiAoaFswXS5vcmlnaW5hbEluZGV4ID09PSAwICYmIGdbMF0ub3JpZ2luYWxJbmRleCA9PT0gMCB8fCAoTCA9IE8gLSBULCBMICE9PSAwICYmIChMICs9IEIpKSksIFtMLCBoLCBSLCBPXTtcbiAgICAgICAgICB9LFxuICAgICAgICAgIFswLCBbXSwgMCwgMF1cbiAgICAgICAgKSxcbiAgICAgICAgUCgoW2ddKSA9PiBnICE9PSAwKSxcbiAgICAgICAgRyhvLCBsLCBuLCByLCBtLCB3KSxcbiAgICAgICAgUCgoWywgZywgYSwgVCwgLCAsIGJdKSA9PiAhYiAmJiAhVCAmJiBnICE9PSAwICYmIGEgPT09IGxlKSxcbiAgICAgICAgRSgoW1tnXSwgLCAsICwgLCBhXSkgPT4gKGEoXCJVcHdhcmQgc2Nyb2xsaW5nIGNvbXBlbnNhdGlvblwiLCB7IGFtb3VudDogZyB9LCBodC5ERUJVRyksIGcpKVxuICAgICAgKVxuICAgICk7XG4gICAgZnVuY3Rpb24gQyhnKSB7XG4gICAgICBnID4gMCA/IChXKGUsIHsgYmVoYXZpb3I6IFwiYXV0b1wiLCB0b3A6IC1nIH0pLCBXKHQsIDApKSA6IChXKHQsIDApLCBXKGUsIHsgYmVoYXZpb3I6IFwiYXV0b1wiLCB0b3A6IC1nIH0pKTtcbiAgICB9XG4gICAgcmV0dXJuIEsoeChJLCBHKHQsIHMpKSwgKFtnLCBhLCBUXSkgPT4ge1xuICAgICAgVCAmJiBxbygpID8gVyh0LCBhIC0gZykgOiBDKC1nKTtcbiAgICB9KSwgSyhcbiAgICAgIHgoXG4gICAgICAgIHJ0KGN0KHMsICExKSwgdCwgdyksXG4gICAgICAgIFAoKFtnLCBhLCBUXSkgPT4gIWcgJiYgIVQgJiYgYSAhPT0gMCksXG4gICAgICAgIEUoKFtnLCBhXSkgPT4gYSksXG4gICAgICAgIEx0KDEpXG4gICAgICApLFxuICAgICAgQ1xuICAgICksIEYoXG4gICAgICB4KFxuICAgICAgICBTLFxuICAgICAgICBFKChnKSA9PiAoeyB0b3A6IC1nIH0pKVxuICAgICAgKSxcbiAgICAgIGVcbiAgICApLCBLKFxuICAgICAgeChcbiAgICAgICAgdSxcbiAgICAgICAgRyhwLCBmKSxcbiAgICAgICAgRSgoW2csIHsgZ3JvdXBJbmRpY2VzOiBhLCBsYXN0U2l6ZTogVCwgc2l6ZVRyZWU6IGIgfSwgaF0pID0+IHtcbiAgICAgICAgICBmdW5jdGlvbiBkKFIpIHtcbiAgICAgICAgICAgIHJldHVybiBSICogKFQgKyBoKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGEubGVuZ3RoID09PSAwKVxuICAgICAgICAgICAgcmV0dXJuIGQoZyk7XG4gICAgICAgICAge1xuICAgICAgICAgICAgbGV0IFIgPSAwO1xuICAgICAgICAgICAgY29uc3QgQiA9IHJlKGIsIDApO1xuICAgICAgICAgICAgbGV0IE8gPSAwLCBMID0gMDtcbiAgICAgICAgICAgIGZvciAoOyBPIDwgZzsgKSB7XG4gICAgICAgICAgICAgIE8rKywgUiArPSBCO1xuICAgICAgICAgICAgICBsZXQgViA9IGEubGVuZ3RoID09PSBMICsgMSA/IDEgLyAwIDogYVtMICsgMV0gLSBhW0xdIC0gMTtcbiAgICAgICAgICAgICAgTyArIFYgPiBnICYmIChSIC09IEIsIFYgPSBnIC0gTyArIDEpLCBPICs9IFYsIFIgKz0gZChWKSwgTCsrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIFI7XG4gICAgICAgICAgfVxuICAgICAgICB9KVxuICAgICAgKSxcbiAgICAgIChnKSA9PiB7XG4gICAgICAgIFcodCwgZyksIHJlcXVlc3RBbmltYXRpb25GcmFtZSgoKSA9PiB7XG4gICAgICAgICAgVyhlLCB7IHRvcDogZyB9KSwgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+IHtcbiAgICAgICAgICAgIFcodCwgMCksIFcodywgITEpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICApLCB7IGRldmlhdGlvbjogdCB9O1xuICB9LFxuICBYKGF0LCBhZSwgR3QsIEV0LCBWdCwgTmUpXG4pLCBabyA9IFUoXG4gIChbXG4gICAgdCxcbiAgICBlLFxuICAgIG4sXG4gICAgbyxcbiAgICByLFxuICAgIHMsXG4gICAgaSxcbiAgICBsLFxuICAgIGMsXG4gICAgdVxuICBdKSA9PiAoe1xuICAgIC4uLnQsXG4gICAgLi4uZSxcbiAgICAuLi5uLFxuICAgIC4uLm8sXG4gICAgLi4ucixcbiAgICAuLi5zLFxuICAgIC4uLmksXG4gICAgLi4ubCxcbiAgICAuLi5jLFxuICAgIC4uLnVcbiAgfSksXG4gIFgoXG4gICAgS2UsXG4gICAgR28sXG4gICAgUHQsXG4gICAgS24sXG4gICAgVW4sXG4gICAgTm8sXG4gICAgTW8sXG4gICAgamUsXG4gICAgJG8sXG4gICAgVnRcbiAgKVxuKSwgcW4gPSBVKFxuICAoW1xuICAgIHtcbiAgICAgIGRhdGE6IHQsXG4gICAgICBkZWZhdWx0SXRlbVNpemU6IGUsXG4gICAgICBmaXJzdEl0ZW1JbmRleDogbixcbiAgICAgIGZpeGVkSXRlbVNpemU6IG8sXG4gICAgICBnYXA6IHIsXG4gICAgICBncm91cEluZGljZXM6IHMsXG4gICAgICBpdGVtU2l6ZTogaSxcbiAgICAgIHNpemVSYW5nZXM6IGwsXG4gICAgICBzaXplczogYyxcbiAgICAgIHN0YXRlZnVsVG90YWxDb3VudDogdSxcbiAgICAgIHRvdGFsQ291bnQ6IGYsXG4gICAgICB0cmFja0l0ZW1TaXplczogU1xuICAgIH0sXG4gICAgeyBpbml0aWFsSXRlbUZpbmFsTG9jYXRpb25SZWFjaGVkOiBwLCBpbml0aWFsVG9wTW9zdEl0ZW1JbmRleDogbSwgc2Nyb2xsZWRUb0luaXRpYWxJdGVtOiB3IH0sXG4gICAgSSxcbiAgICBDLFxuICAgIGcsXG4gICAgeyBsaXN0U3RhdGU6IGEsIHRvcEl0ZW1zSW5kZXhlczogVCwgLi4uYiB9LFxuICAgIHsgc2Nyb2xsVG9JbmRleDogaCB9LFxuICAgIGQsXG4gICAgeyB0b3BJdGVtQ291bnQ6IFIgfSxcbiAgICB7IGdyb3VwQ291bnRzOiBCIH0sXG4gICAgT1xuICBdKSA9PiAoRihiLnJhbmdlQ2hhbmdlZCwgTy5zY3JvbGxTZWVrUmFuZ2VDaGFuZ2VkKSwgRihcbiAgICB4KFxuICAgICAgTy53aW5kb3dWaWV3cG9ydFJlY3QsXG4gICAgICBFKChMKSA9PiBMLnZpc2libGVIZWlnaHQpXG4gICAgKSxcbiAgICBJLnZpZXdwb3J0SGVpZ2h0XG4gICksIHtcbiAgICBkYXRhOiB0LFxuICAgIGRlZmF1bHRJdGVtSGVpZ2h0OiBlLFxuICAgIGZpcnN0SXRlbUluZGV4OiBuLFxuICAgIGZpeGVkSXRlbUhlaWdodDogbyxcbiAgICBnYXA6IHIsXG4gICAgZ3JvdXBDb3VudHM6IEIsXG4gICAgaW5pdGlhbEl0ZW1GaW5hbExvY2F0aW9uUmVhY2hlZDogcCxcbiAgICBpbml0aWFsVG9wTW9zdEl0ZW1JbmRleDogbSxcbiAgICBzY3JvbGxlZFRvSW5pdGlhbEl0ZW06IHcsXG4gICAgc2l6ZVJhbmdlczogbCxcbiAgICB0b3BJdGVtQ291bnQ6IFIsXG4gICAgdG9wSXRlbXNJbmRleGVzOiBULFxuICAgIC8vIGlucHV0XG4gICAgdG90YWxDb3VudDogZixcbiAgICAuLi5nLFxuICAgIGdyb3VwSW5kaWNlczogcyxcbiAgICBpdGVtU2l6ZTogaSxcbiAgICBsaXN0U3RhdGU6IGEsXG4gICAgc2Nyb2xsVG9JbmRleDogaCxcbiAgICAvLyBvdXRwdXRcbiAgICBzdGF0ZWZ1bFRvdGFsQ291bnQ6IHUsXG4gICAgdHJhY2tJdGVtU2l6ZXM6IFMsXG4gICAgLy8gZXhwb3J0ZWQgZnJvbSBzdGF0ZUZsYWdzU3lzdGVtXG4gICAgLi4uYixcbiAgICAvLyB0aGUgYmFnIG9mIElPIGZyb20gZmVhdHVyZUdyb3VwMVN5c3RlbVxuICAgIC4uLk8sXG4gICAgLi4uSSxcbiAgICBzaXplczogYyxcbiAgICAuLi5DXG4gIH0pLFxuICBYKFxuICAgIEV0LFxuICAgIHVlLFxuICAgIGF0LFxuICAgIFVvLFxuICAgIF9vLFxuICAgIEd0LFxuICAgIGNlLFxuICAgIFlvLFxuICAgIGpvLFxuICAgIEduLFxuICAgIFpvXG4gIClcbik7XG5mdW5jdGlvbiBYbyh0LCBlKSB7XG4gIGNvbnN0IG4gPSB7fSwgbyA9IHt9O1xuICBsZXQgciA9IDA7XG4gIGNvbnN0IHMgPSB0Lmxlbmd0aDtcbiAgZm9yICg7IHIgPCBzOyApXG4gICAgb1t0W3JdXSA9IDEsIHIgKz0gMTtcbiAgZm9yIChjb25zdCBpIGluIGUpXG4gICAgT2JqZWN0Lmhhc093bihvLCBpKSB8fCAobltpXSA9IGVbaV0pO1xuICByZXR1cm4gbjtcbn1cbmNvbnN0IHBlID0gdHlwZW9mIGRvY3VtZW50IDwgXCJ1XCIgPyBILnVzZUxheW91dEVmZmVjdCA6IEgudXNlRWZmZWN0O1xuZnVuY3Rpb24gcWUodCwgZSwgbikge1xuICBjb25zdCBvID0gT2JqZWN0LmtleXMoZS5yZXF1aXJlZCB8fCB7fSksIHIgPSBPYmplY3Qua2V5cyhlLm9wdGlvbmFsIHx8IHt9KSwgcyA9IE9iamVjdC5rZXlzKGUubWV0aG9kcyB8fCB7fSksIGkgPSBPYmplY3Qua2V5cyhlLmV2ZW50cyB8fCB7fSksIGwgPSBILmNyZWF0ZUNvbnRleHQoe30pO1xuICBmdW5jdGlvbiBjKGcsIGEpIHtcbiAgICBnLnByb3BzUmVhZHkgJiYgVyhnLnByb3BzUmVhZHksICExKTtcbiAgICBmb3IgKGNvbnN0IFQgb2Ygbykge1xuICAgICAgY29uc3QgYiA9IGdbZS5yZXF1aXJlZFtUXV07XG4gICAgICBXKGIsIGFbVF0pO1xuICAgIH1cbiAgICBmb3IgKGNvbnN0IFQgb2YgcilcbiAgICAgIGlmIChUIGluIGEpIHtcbiAgICAgICAgY29uc3QgYiA9IGdbZS5vcHRpb25hbFtUXV07XG4gICAgICAgIFcoYiwgYVtUXSk7XG4gICAgICB9XG4gICAgZy5wcm9wc1JlYWR5ICYmIFcoZy5wcm9wc1JlYWR5LCAhMCk7XG4gIH1cbiAgZnVuY3Rpb24gdShnKSB7XG4gICAgcmV0dXJuIHMucmVkdWNlKChhLCBUKSA9PiAoYVtUXSA9IChiKSA9PiB7XG4gICAgICBjb25zdCBoID0gZ1tlLm1ldGhvZHNbVF1dO1xuICAgICAgVyhoLCBiKTtcbiAgICB9LCBhKSwge30pO1xuICB9XG4gIGZ1bmN0aW9uIGYoZykge1xuICAgIHJldHVybiBpLnJlZHVjZSgoYSwgVCkgPT4gKGFbVF0gPSBtbyhnW2UuZXZlbnRzW1RdXSksIGEpLCB7fSk7XG4gIH1cbiAgY29uc3QgUyA9IEguZm9yd2FyZFJlZigoZywgYSkgPT4ge1xuICAgIGNvbnN0IHsgY2hpbGRyZW46IFQsIC4uLmIgfSA9IGcsIFtoXSA9IEgudXNlU3RhdGUoKCkgPT4geWUoaG8odCksIChCKSA9PiB7XG4gICAgICBjKEIsIGIpO1xuICAgIH0pKSwgW2RdID0gSC51c2VTdGF0ZShjbihmLCBoKSk7XG4gICAgcGUoKCkgPT4ge1xuICAgICAgZm9yIChjb25zdCBCIG9mIGkpXG4gICAgICAgIEIgaW4gYiAmJiBLKGRbQl0sIGJbQl0pO1xuICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgT2JqZWN0LnZhbHVlcyhkKS5tYXAoV2UpO1xuICAgICAgfTtcbiAgICB9LCBbYiwgZCwgaF0pLCBwZSgoKSA9PiB7XG4gICAgICBjKGgsIGIpO1xuICAgIH0pLCBILnVzZUltcGVyYXRpdmVIYW5kbGUoYSwgbG4odShoKSkpO1xuICAgIGNvbnN0IFIgPSBuO1xuICAgIHJldHVybiAvKiBAX19QVVJFX18gKi8geihsLlByb3ZpZGVyLCB7IHZhbHVlOiBoLCBjaGlsZHJlbjogbiA/IC8qIEBfX1BVUkVfXyAqLyB6KFIsIHsgLi4uWG8oWy4uLm8sIC4uLnIsIC4uLmldLCBiKSwgY2hpbGRyZW46IFQgfSkgOiBUIH0pO1xuICB9KSwgcCA9IChnKSA9PiBILnVzZUNhbGxiYWNrKGtuKFcsIEgudXNlQ29udGV4dChsKVtnXSksIFtnXSksIG0gPSAoZykgPT4ge1xuICAgIGNvbnN0IFQgPSBILnVzZUNvbnRleHQobClbZ10sIGIgPSBILnVzZUNhbGxiYWNrKFxuICAgICAgKGgpID0+IEsoVCwgaCksXG4gICAgICBbVF1cbiAgICApO1xuICAgIHJldHVybiBILnVzZVN5bmNFeHRlcm5hbFN0b3JlKFxuICAgICAgYixcbiAgICAgICgpID0+IGx0KFQpLFxuICAgICAgKCkgPT4gbHQoVClcbiAgICApO1xuICB9LCB3ID0gKGcpID0+IHtcbiAgICBjb25zdCBUID0gSC51c2VDb250ZXh0KGwpW2ddLCBbYiwgaF0gPSBILnVzZVN0YXRlKGNuKGx0LCBUKSk7XG4gICAgcmV0dXJuIHBlKFxuICAgICAgKCkgPT4gSyhULCAoZCkgPT4ge1xuICAgICAgICBkICE9PSBiICYmIGgobG4oZCkpO1xuICAgICAgfSksXG4gICAgICBbVCwgYl1cbiAgICApLCBiO1xuICB9LCBJID0gSC52ZXJzaW9uLnN0YXJ0c1dpdGgoXCIxOFwiKSA/IG0gOiB3O1xuICByZXR1cm4ge1xuICAgIENvbXBvbmVudDogUyxcbiAgICB1c2VFbWl0dGVyOiAoZywgYSkgPT4ge1xuICAgICAgY29uc3QgYiA9IEgudXNlQ29udGV4dChsKVtnXTtcbiAgICAgIHBlKCgpID0+IEsoYiwgYSksIFthLCBiXSk7XG4gICAgfSxcbiAgICB1c2VFbWl0dGVyVmFsdWU6IEksXG4gICAgdXNlUHVibGlzaGVyOiBwXG4gIH07XG59XG5jb25zdCBSZSA9IEguY3JlYXRlQ29udGV4dCh2b2lkIDApLCBZbiA9IEguY3JlYXRlQ29udGV4dCh2b2lkIDApLCBabiA9IHR5cGVvZiBkb2N1bWVudCA8IFwidVwiID8gSC51c2VMYXlvdXRFZmZlY3QgOiBILnVzZUVmZmVjdDtcbmZ1bmN0aW9uIEJlKHQpIHtcbiAgcmV0dXJuIFwic2VsZlwiIGluIHQ7XG59XG5mdW5jdGlvbiBKbyh0KSB7XG4gIHJldHVybiBcImJvZHlcIiBpbiB0O1xufVxuZnVuY3Rpb24gWG4odCwgZSwgbiwgbyA9IFl0LCByLCBzKSB7XG4gIGNvbnN0IGkgPSBILnVzZVJlZihudWxsKSwgbCA9IEgudXNlUmVmKG51bGwpLCBjID0gSC51c2VSZWYobnVsbCksIHUgPSBILnVzZUNhbGxiYWNrKFxuICAgIChwKSA9PiB7XG4gICAgICBsZXQgbSwgdywgSTtcbiAgICAgIGNvbnN0IEMgPSBwLnRhcmdldDtcbiAgICAgIGlmIChKbyhDKSB8fCBCZShDKSkge1xuICAgICAgICBjb25zdCBhID0gQmUoQykgPyBDIDogQy5kZWZhdWx0VmlldztcbiAgICAgICAgSSA9IHMgPyBhLnNjcm9sbFggOiBhLnNjcm9sbFksIG0gPSBzID8gYS5kb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc2Nyb2xsV2lkdGggOiBhLmRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zY3JvbGxIZWlnaHQsIHcgPSBzID8gYS5pbm5lcldpZHRoIDogYS5pbm5lckhlaWdodDtcbiAgICAgIH0gZWxzZVxuICAgICAgICBJID0gcyA/IEMuc2Nyb2xsTGVmdCA6IEMuc2Nyb2xsVG9wLCBtID0gcyA/IEMuc2Nyb2xsV2lkdGggOiBDLnNjcm9sbEhlaWdodCwgdyA9IHMgPyBDLm9mZnNldFdpZHRoIDogQy5vZmZzZXRIZWlnaHQ7XG4gICAgICBjb25zdCBnID0gKCkgPT4ge1xuICAgICAgICB0KHtcbiAgICAgICAgICBzY3JvbGxIZWlnaHQ6IG0sXG4gICAgICAgICAgc2Nyb2xsVG9wOiBNYXRoLm1heChJLCAwKSxcbiAgICAgICAgICB2aWV3cG9ydEhlaWdodDogd1xuICAgICAgICB9KTtcbiAgICAgIH07XG4gICAgICBwLnN1cHByZXNzRmx1c2hTeW5jID8gZygpIDogbG8uZmx1c2hTeW5jKGcpLCBsLmN1cnJlbnQgIT09IG51bGwgJiYgKEkgPT09IGwuY3VycmVudCB8fCBJIDw9IDAgfHwgSSA9PT0gbSAtIHcpICYmIChsLmN1cnJlbnQgPSBudWxsLCBlKCEwKSwgYy5jdXJyZW50ICYmIChjbGVhclRpbWVvdXQoYy5jdXJyZW50KSwgYy5jdXJyZW50ID0gbnVsbCkpO1xuICAgIH0sXG4gICAgW3QsIGVdXG4gICk7XG4gIEgudXNlRWZmZWN0KCgpID0+IHtcbiAgICBjb25zdCBwID0gciB8fCBpLmN1cnJlbnQ7XG4gICAgcmV0dXJuIG8ociB8fCBpLmN1cnJlbnQpLCB1KHsgc3VwcHJlc3NGbHVzaFN5bmM6ICEwLCB0YXJnZXQ6IHAgfSksIHAuYWRkRXZlbnRMaXN0ZW5lcihcInNjcm9sbFwiLCB1LCB7IHBhc3NpdmU6ICEwIH0pLCAoKSA9PiB7XG4gICAgICBvKG51bGwpLCBwLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJzY3JvbGxcIiwgdSk7XG4gICAgfTtcbiAgfSwgW2ksIHUsIG4sIG8sIHJdKTtcbiAgZnVuY3Rpb24gZihwKSB7XG4gICAgY29uc3QgbSA9IGkuY3VycmVudDtcbiAgICBpZiAoIW0gfHwgKHMgPyBcIm9mZnNldFdpZHRoXCIgaW4gbSAmJiBtLm9mZnNldFdpZHRoID09PSAwIDogXCJvZmZzZXRIZWlnaHRcIiBpbiBtICYmIG0ub2Zmc2V0SGVpZ2h0ID09PSAwKSlcbiAgICAgIHJldHVybjtcbiAgICBjb25zdCB3ID0gcC5iZWhhdmlvciA9PT0gXCJzbW9vdGhcIjtcbiAgICBsZXQgSSwgQywgZztcbiAgICBCZShtKSA/IChDID0gTWF0aC5tYXgoXG4gICAgICB3dChtLmRvY3VtZW50LmRvY3VtZW50RWxlbWVudCwgcyA/IFwid2lkdGhcIiA6IFwiaGVpZ2h0XCIpLFxuICAgICAgcyA/IG0uZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnNjcm9sbFdpZHRoIDogbS5kb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc2Nyb2xsSGVpZ2h0XG4gICAgKSwgSSA9IHMgPyBtLmlubmVyV2lkdGggOiBtLmlubmVySGVpZ2h0LCBnID0gcyA/IHdpbmRvdy5zY3JvbGxYIDogd2luZG93LnNjcm9sbFkpIDogKEMgPSBtW3MgPyBcInNjcm9sbFdpZHRoXCIgOiBcInNjcm9sbEhlaWdodFwiXSwgSSA9IHd0KG0sIHMgPyBcIndpZHRoXCIgOiBcImhlaWdodFwiKSwgZyA9IG1bcyA/IFwic2Nyb2xsTGVmdFwiIDogXCJzY3JvbGxUb3BcIl0pO1xuICAgIGNvbnN0IGEgPSBDIC0gSTtcbiAgICBpZiAocC50b3AgPSBNYXRoLmNlaWwoTWF0aC5tYXgoTWF0aC5taW4oYSwgcC50b3ApLCAwKSksIERuKEksIEMpIHx8IHAudG9wID09PSBnKSB7XG4gICAgICB0KHsgc2Nyb2xsSGVpZ2h0OiBDLCBzY3JvbGxUb3A6IGcsIHZpZXdwb3J0SGVpZ2h0OiBJIH0pLCB3ICYmIGUoITApO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB3ID8gKGwuY3VycmVudCA9IHAudG9wLCBjLmN1cnJlbnQgJiYgY2xlYXJUaW1lb3V0KGMuY3VycmVudCksIGMuY3VycmVudCA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgYy5jdXJyZW50ID0gbnVsbCwgbC5jdXJyZW50ID0gbnVsbCwgZSghMCk7XG4gICAgfSwgMWUzKSkgOiBsLmN1cnJlbnQgPSBudWxsLCBzICYmIChwID0geyBiZWhhdmlvcjogcC5iZWhhdmlvciwgbGVmdDogcC50b3AgfSksIG0uc2Nyb2xsVG8ocCk7XG4gIH1cbiAgZnVuY3Rpb24gUyhwKSB7XG4gICAgcyAmJiAocCA9IHsgYmVoYXZpb3I6IHAuYmVoYXZpb3IsIGxlZnQ6IHAudG9wIH0pLCBpLmN1cnJlbnQuc2Nyb2xsQnkocCk7XG4gIH1cbiAgcmV0dXJuIHsgc2Nyb2xsQnlDYWxsYmFjazogUywgc2Nyb2xsZXJSZWY6IGksIHNjcm9sbFRvQ2FsbGJhY2s6IGYgfTtcbn1cbmNvbnN0IE9lID0gXCItd2Via2l0LXN0aWNreVwiLCB4biA9IFwic3RpY2t5XCIsIEpuID0gam4oKCkgPT4ge1xuICBpZiAodHlwZW9mIGRvY3VtZW50ID4gXCJ1XCIpXG4gICAgcmV0dXJuIHhuO1xuICBjb25zdCB0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgcmV0dXJuIHQuc3R5bGUucG9zaXRpb24gPSBPZSwgdC5zdHlsZS5wb3NpdGlvbiA9PT0gT2UgPyBPZSA6IHhuO1xufSk7XG5mdW5jdGlvbiBZZSh0KSB7XG4gIHJldHVybiB0O1xufVxuY29uc3QgUW8gPSAvKiBAX19QVVJFX18gKi8gVSgoKSA9PiB7XG4gIGNvbnN0IHQgPSB5KChjKSA9PiBgSXRlbSAke2N9YCksIGUgPSB5KG51bGwpLCBuID0geSgoYykgPT4gYEdyb3VwICR7Y31gKSwgbyA9IHkoe30pLCByID0geShZZSksIHMgPSB5KFwiZGl2XCIpLCBpID0geShZdCksIGwgPSAoYywgdSA9IG51bGwpID0+IGN0KFxuICAgIHgoXG4gICAgICBvLFxuICAgICAgRSgoZikgPT4gZltjXSksXG4gICAgICBZKClcbiAgICApLFxuICAgIHVcbiAgKTtcbiAgcmV0dXJuIHtcbiAgICBjb21wb25lbnRzOiBvLFxuICAgIGNvbXB1dGVJdGVtS2V5OiByLFxuICAgIGNvbnRleHQ6IGUsXG4gICAgRW1wdHlQbGFjZWhvbGRlcjogbChcIkVtcHR5UGxhY2Vob2xkZXJcIiksXG4gICAgRm9vdGVyQ29tcG9uZW50OiBsKFwiRm9vdGVyXCIpLFxuICAgIEdyb3VwQ29tcG9uZW50OiBsKFwiR3JvdXBcIiwgXCJkaXZcIiksXG4gICAgZ3JvdXBDb250ZW50OiBuLFxuICAgIEhlYWRlckNvbXBvbmVudDogbChcIkhlYWRlclwiKSxcbiAgICBIZWFkZXJGb290ZXJUYWc6IHMsXG4gICAgSXRlbUNvbXBvbmVudDogbChcIkl0ZW1cIiwgXCJkaXZcIiksXG4gICAgaXRlbUNvbnRlbnQ6IHQsXG4gICAgTGlzdENvbXBvbmVudDogbChcIkxpc3RcIiwgXCJkaXZcIiksXG4gICAgU2Nyb2xsZXJDb21wb25lbnQ6IGwoXCJTY3JvbGxlclwiLCBcImRpdlwiKSxcbiAgICBzY3JvbGxlclJlZjogaSxcbiAgICBTY3JvbGxTZWVrUGxhY2Vob2xkZXI6IGwoXCJTY3JvbGxTZWVrUGxhY2Vob2xkZXJcIiksXG4gICAgVG9wSXRlbUxpc3RDb21wb25lbnQ6IGwoXCJUb3BJdGVtTGlzdFwiKVxuICB9O1xufSksIHRyID0gLyogQF9fUFVSRV9fICovIFUoXG4gIChbdCwgZV0pID0+ICh7IC4uLnQsIC4uLmUgfSksXG4gIFgocW4sIFFvKVxuKSwgZXIgPSAoeyBoZWlnaHQ6IHQgfSkgPT4gLyogQF9fUFVSRV9fICovIHooXCJkaXZcIiwgeyBzdHlsZTogeyBoZWlnaHQ6IHQgfSB9KSwgbnIgPSB7IG92ZXJmbG93QW5jaG9yOiBcIm5vbmVcIiwgcG9zaXRpb246IEpuKCksIHpJbmRleDogMSB9LCBRbiA9IHsgb3ZlcmZsb3dBbmNob3I6IFwibm9uZVwiIH0sIG9yID0geyAuLi5RbiwgZGlzcGxheTogXCJpbmxpbmUtYmxvY2tcIiwgaGVpZ2h0OiBcIjEwMCVcIiB9LCBUbiA9IC8qIEBfX1BVUkVfXyAqLyBILm1lbW8oZnVuY3Rpb24oeyBzaG93VG9wTGlzdDogZSA9ICExIH0pIHtcbiAgY29uc3QgbiA9IE0oXCJsaXN0U3RhdGVcIiksIG8gPSBndChcInNpemVSYW5nZXNcIiksIHIgPSBNKFwidXNlV2luZG93U2Nyb2xsXCIpLCBzID0gTShcImN1c3RvbVNjcm9sbFBhcmVudFwiKSwgaSA9IGd0KFwid2luZG93U2Nyb2xsQ29udGFpbmVyU3RhdGVcIiksIGwgPSBndChcInNjcm9sbENvbnRhaW5lclN0YXRlXCIpLCBjID0gcyB8fCByID8gaSA6IGwsIHUgPSBNKFwiaXRlbUNvbnRlbnRcIiksIGYgPSBNKFwiY29udGV4dFwiKSwgUyA9IE0oXCJncm91cENvbnRlbnRcIiksIHAgPSBNKFwidHJhY2tJdGVtU2l6ZXNcIiksIG0gPSBNKFwiaXRlbVNpemVcIiksIHcgPSBNKFwibG9nXCIpLCBJID0gZ3QoXCJnYXBcIiksIEMgPSBNKFwiaG9yaXpvbnRhbERpcmVjdGlvblwiKSwgeyBjYWxsYmFja1JlZjogZyB9ID0gT24oXG4gICAgbyxcbiAgICBtLFxuICAgIHAsXG4gICAgZSA/IFl0IDogYyxcbiAgICB3LFxuICAgIEksXG4gICAgcyxcbiAgICBDLFxuICAgIE0oXCJza2lwQW5pbWF0aW9uRnJhbWVJblJlc2l6ZU9ic2VydmVyXCIpXG4gICksIFthLCBUXSA9IEgudXNlU3RhdGUoMCk7XG4gIEplKFwiZGV2aWF0aW9uXCIsIChrKSA9PiB7XG4gICAgYSAhPT0gayAmJiBUKGspO1xuICB9KTtcbiAgY29uc3QgYiA9IE0oXCJFbXB0eVBsYWNlaG9sZGVyXCIpLCBoID0gTShcIlNjcm9sbFNlZWtQbGFjZWhvbGRlclwiKSB8fCBlciwgZCA9IE0oXCJMaXN0Q29tcG9uZW50XCIpLCBSID0gTShcIkl0ZW1Db21wb25lbnRcIiksIEIgPSBNKFwiR3JvdXBDb21wb25lbnRcIiksIE8gPSBNKFwiY29tcHV0ZUl0ZW1LZXlcIiksIEwgPSBNKFwiaXNTZWVraW5nXCIpLCBWID0gTShcImdyb3VwSW5kaWNlc1wiKS5sZW5ndGggPiAwLCBEID0gTShcImFsaWduVG9Cb3R0b21cIiksIEogPSBNKFwiaW5pdGlhbEl0ZW1GaW5hbExvY2F0aW9uUmVhY2hlZFwiKSwgbnQgPSBlID8ge30gOiB7XG4gICAgYm94U2l6aW5nOiBcImJvcmRlci1ib3hcIixcbiAgICAuLi5DID8ge1xuICAgICAgZGlzcGxheTogXCJpbmxpbmUtYmxvY2tcIixcbiAgICAgIGhlaWdodDogXCIxMDAlXCIsXG4gICAgICBtYXJnaW5MZWZ0OiBhICE9PSAwID8gYSA6IEQgPyBcImF1dG9cIiA6IDAsXG4gICAgICBwYWRkaW5nTGVmdDogbi5vZmZzZXRUb3AsXG4gICAgICBwYWRkaW5nUmlnaHQ6IG4ub2Zmc2V0Qm90dG9tLFxuICAgICAgd2hpdGVTcGFjZTogXCJub3dyYXBcIlxuICAgIH0gOiB7XG4gICAgICBtYXJnaW5Ub3A6IGEgIT09IDAgPyBhIDogRCA/IFwiYXV0b1wiIDogMCxcbiAgICAgIHBhZGRpbmdCb3R0b206IG4ub2Zmc2V0Qm90dG9tLFxuICAgICAgcGFkZGluZ1RvcDogbi5vZmZzZXRUb3BcbiAgICB9LFxuICAgIC4uLkogPyB7fSA6IHsgdmlzaWJpbGl0eTogXCJoaWRkZW5cIiB9XG4gIH07XG4gIHJldHVybiAhZSAmJiBuLnRvdGFsQ291bnQgPT09IDAgJiYgYiA/IC8qIEBfX1BVUkVfXyAqLyB6KGIsIHsgLi4uWihiLCBmKSB9KSA6IC8qIEBfX1BVUkVfXyAqLyB6KFxuICAgIGQsXG4gICAge1xuICAgICAgLi4uWihkLCBmKSxcbiAgICAgIFwiZGF0YS10ZXN0aWRcIjogZSA/IFwidmlydHVvc28tdG9wLWl0ZW0tbGlzdFwiIDogXCJ2aXJ0dW9zby1pdGVtLWxpc3RcIixcbiAgICAgIHJlZjogZyxcbiAgICAgIHN0eWxlOiBudCxcbiAgICAgIGNoaWxkcmVuOiAoZSA/IG4udG9wSXRlbXMgOiBuLml0ZW1zKS5tYXAoKGspID0+IHtcbiAgICAgICAgY29uc3QgcSA9IGsub3JpZ2luYWxJbmRleCwgc3QgPSBPKHEgKyBuLmZpcnN0SXRlbUluZGV4LCBrLmRhdGEsIGYpO1xuICAgICAgICByZXR1cm4gTCA/IC8qIEBfX1BVUkVfXyAqLyAkdChcbiAgICAgICAgICBoLFxuICAgICAgICAgIHtcbiAgICAgICAgICAgIC4uLlooaCwgZiksXG4gICAgICAgICAgICBoZWlnaHQ6IGsuc2l6ZSxcbiAgICAgICAgICAgIGluZGV4OiBrLmluZGV4LFxuICAgICAgICAgICAga2V5OiBzdCxcbiAgICAgICAgICAgIHR5cGU6IGsudHlwZSB8fCBcIml0ZW1cIixcbiAgICAgICAgICAgIC4uLmsudHlwZSA9PT0gXCJncm91cFwiID8ge30gOiB7IGdyb3VwSW5kZXg6IGsuZ3JvdXBJbmRleCB9XG4gICAgICAgICAgfVxuICAgICAgICApIDogay50eXBlID09PSBcImdyb3VwXCIgPyAvKiBAX19QVVJFX18gKi8gJHQoXG4gICAgICAgICAgQixcbiAgICAgICAgICB7XG4gICAgICAgICAgICAuLi5aKEIsIGYpLFxuICAgICAgICAgICAgXCJkYXRhLWluZGV4XCI6IHEsXG4gICAgICAgICAgICBcImRhdGEtaXRlbS1pbmRleFwiOiBrLmluZGV4LFxuICAgICAgICAgICAgXCJkYXRhLWtub3duLXNpemVcIjogay5zaXplLFxuICAgICAgICAgICAga2V5OiBzdCxcbiAgICAgICAgICAgIHN0eWxlOiBuclxuICAgICAgICAgIH0sXG4gICAgICAgICAgUyhrLmluZGV4LCBmKVxuICAgICAgICApIDogLyogQF9fUFVSRV9fICovICR0KFxuICAgICAgICAgIFIsXG4gICAgICAgICAge1xuICAgICAgICAgICAgLi4uWihSLCBmKSxcbiAgICAgICAgICAgIC4uLnRvKFIsIGsuZGF0YSksXG4gICAgICAgICAgICBcImRhdGEtaW5kZXhcIjogcSxcbiAgICAgICAgICAgIFwiZGF0YS1pdGVtLWdyb3VwLWluZGV4XCI6IGsuZ3JvdXBJbmRleCxcbiAgICAgICAgICAgIFwiZGF0YS1pdGVtLWluZGV4XCI6IGsuaW5kZXgsXG4gICAgICAgICAgICBcImRhdGEta25vd24tc2l6ZVwiOiBrLnNpemUsXG4gICAgICAgICAgICBrZXk6IHN0LFxuICAgICAgICAgICAgc3R5bGU6IEMgPyBvciA6IFFuXG4gICAgICAgICAgfSxcbiAgICAgICAgICBWID8gdShrLmluZGV4LCBrLmdyb3VwSW5kZXgsIGsuZGF0YSwgZikgOiB1KGsuaW5kZXgsIGsuZGF0YSwgZilcbiAgICAgICAgKTtcbiAgICAgIH0pXG4gICAgfVxuICApO1xufSksIHJyID0ge1xuICBoZWlnaHQ6IFwiMTAwJVwiLFxuICBvdXRsaW5lOiBcIm5vbmVcIixcbiAgb3ZlcmZsb3dZOiBcImF1dG9cIixcbiAgcG9zaXRpb246IFwicmVsYXRpdmVcIixcbiAgV2Via2l0T3ZlcmZsb3dTY3JvbGxpbmc6IFwidG91Y2hcIlxufSwgc3IgPSB7XG4gIG91dGxpbmU6IFwibm9uZVwiLFxuICBvdmVyZmxvd1g6IFwiYXV0b1wiLFxuICBwb3NpdGlvbjogXCJyZWxhdGl2ZVwiXG59LCBadCA9ICh0KSA9PiAoe1xuICBoZWlnaHQ6IFwiMTAwJVwiLFxuICBwb3NpdGlvbjogXCJhYnNvbHV0ZVwiLFxuICB0b3A6IDAsXG4gIHdpZHRoOiBcIjEwMCVcIixcbiAgLi4udCA/IHsgZGlzcGxheTogXCJmbGV4XCIsIGZsZXhEaXJlY3Rpb246IFwiY29sdW1uXCIgfSA6IHt9XG59KSwgaXIgPSB7XG4gIHBvc2l0aW9uOiBKbigpLFxuICB0b3A6IDAsXG4gIHdpZHRoOiBcIjEwMCVcIixcbiAgekluZGV4OiAxXG59O1xuZnVuY3Rpb24gWih0LCBlKSB7XG4gIGlmICh0eXBlb2YgdCAhPSBcInN0cmluZ1wiKVxuICAgIHJldHVybiB7IGNvbnRleHQ6IGUgfTtcbn1cbmZ1bmN0aW9uIHRvKHQsIGUpIHtcbiAgcmV0dXJuIHsgaXRlbTogdHlwZW9mIHQgPT0gXCJzdHJpbmdcIiA/IHZvaWQgMCA6IGUgfTtcbn1cbmNvbnN0IGxyID0gLyogQF9fUFVSRV9fICovIEgubWVtbyhmdW5jdGlvbigpIHtcbiAgY29uc3QgZSA9IE0oXCJIZWFkZXJDb21wb25lbnRcIiksIG4gPSBndChcImhlYWRlckhlaWdodFwiKSwgbyA9IE0oXCJIZWFkZXJGb290ZXJUYWdcIiksIHIgPSBIdChcbiAgICBILnVzZU1lbW8oXG4gICAgICAoKSA9PiAoaSkgPT4ge1xuICAgICAgICBuKHd0KGksIFwiaGVpZ2h0XCIpKTtcbiAgICAgIH0sXG4gICAgICBbbl1cbiAgICApLFxuICAgICEwLFxuICAgIE0oXCJza2lwQW5pbWF0aW9uRnJhbWVJblJlc2l6ZU9ic2VydmVyXCIpXG4gICksIHMgPSBNKFwiY29udGV4dFwiKTtcbiAgcmV0dXJuIGUgPyAvKiBAX19QVVJFX18gKi8geihvLCB7IHJlZjogciwgY2hpbGRyZW46IC8qIEBfX1BVUkVfXyAqLyB6KGUsIHsgLi4uWihlLCBzKSB9KSB9KSA6IG51bGw7XG59KSwgY3IgPSAvKiBAX19QVVJFX18gKi8gSC5tZW1vKGZ1bmN0aW9uKCkge1xuICBjb25zdCBlID0gTShcIkZvb3RlckNvbXBvbmVudFwiKSwgbiA9IGd0KFwiZm9vdGVySGVpZ2h0XCIpLCBvID0gTShcIkhlYWRlckZvb3RlclRhZ1wiKSwgciA9IEh0KFxuICAgIEgudXNlTWVtbyhcbiAgICAgICgpID0+IChpKSA9PiB7XG4gICAgICAgIG4od3QoaSwgXCJoZWlnaHRcIikpO1xuICAgICAgfSxcbiAgICAgIFtuXVxuICAgICksXG4gICAgITAsXG4gICAgTShcInNraXBBbmltYXRpb25GcmFtZUluUmVzaXplT2JzZXJ2ZXJcIilcbiAgKSwgcyA9IE0oXCJjb250ZXh0XCIpO1xuICByZXR1cm4gZSA/IC8qIEBfX1BVUkVfXyAqLyB6KG8sIHsgcmVmOiByLCBjaGlsZHJlbjogLyogQF9fUFVSRV9fICovIHooZSwgeyAuLi5aKGUsIHMpIH0pIH0pIDogbnVsbDtcbn0pO1xuZnVuY3Rpb24gWmUoeyB1c2VFbWl0dGVyOiB0LCB1c2VFbWl0dGVyVmFsdWU6IGUsIHVzZVB1Ymxpc2hlcjogbiB9KSB7XG4gIHJldHVybiBILm1lbW8oZnVuY3Rpb24oeyBjaGlsZHJlbjogcywgc3R5bGU6IGksIC4uLmwgfSkge1xuICAgIGNvbnN0IGMgPSBuKFwic2Nyb2xsQ29udGFpbmVyU3RhdGVcIiksIHUgPSBlKFwiU2Nyb2xsZXJDb21wb25lbnRcIiksIGYgPSBuKFwic21vb3RoU2Nyb2xsVGFyZ2V0UmVhY2hlZFwiKSwgUyA9IGUoXCJzY3JvbGxlclJlZlwiKSwgcCA9IGUoXCJjb250ZXh0XCIpLCBtID0gZShcImhvcml6b250YWxEaXJlY3Rpb25cIikgfHwgITEsIHsgc2Nyb2xsQnlDYWxsYmFjazogdywgc2Nyb2xsZXJSZWY6IEksIHNjcm9sbFRvQ2FsbGJhY2s6IEMgfSA9IFhuKFxuICAgICAgYyxcbiAgICAgIGYsXG4gICAgICB1LFxuICAgICAgUyxcbiAgICAgIHZvaWQgMCxcbiAgICAgIG1cbiAgICApO1xuICAgIHJldHVybiB0KFwic2Nyb2xsVG9cIiwgQyksIHQoXCJzY3JvbGxCeVwiLCB3KSwgLyogQF9fUFVSRV9fICovIHooXG4gICAgICB1LFxuICAgICAge1xuICAgICAgICBcImRhdGEtdGVzdGlkXCI6IFwidmlydHVvc28tc2Nyb2xsZXJcIixcbiAgICAgICAgXCJkYXRhLXZpcnR1b3NvLXNjcm9sbGVyXCI6ICEwLFxuICAgICAgICByZWY6IEksXG4gICAgICAgIHN0eWxlOiB7IC4uLm0gPyBzciA6IHJyLCAuLi5pIH0sXG4gICAgICAgIHRhYkluZGV4OiAwLFxuICAgICAgICAuLi5sLFxuICAgICAgICAuLi5aKHUsIHApLFxuICAgICAgICBjaGlsZHJlbjogc1xuICAgICAgfVxuICAgICk7XG4gIH0pO1xufVxuZnVuY3Rpb24gWGUoeyB1c2VFbWl0dGVyOiB0LCB1c2VFbWl0dGVyVmFsdWU6IGUsIHVzZVB1Ymxpc2hlcjogbiB9KSB7XG4gIHJldHVybiBILm1lbW8oZnVuY3Rpb24oeyBjaGlsZHJlbjogcywgc3R5bGU6IGksIC4uLmwgfSkge1xuICAgIGNvbnN0IGMgPSBuKFwid2luZG93U2Nyb2xsQ29udGFpbmVyU3RhdGVcIiksIHUgPSBlKFwiU2Nyb2xsZXJDb21wb25lbnRcIiksIGYgPSBuKFwic21vb3RoU2Nyb2xsVGFyZ2V0UmVhY2hlZFwiKSwgUyA9IGUoXCJ0b3RhbExpc3RIZWlnaHRcIiksIHAgPSBlKFwiZGV2aWF0aW9uXCIpLCBtID0gZShcImN1c3RvbVNjcm9sbFBhcmVudFwiKSwgdyA9IGUoXCJjb250ZXh0XCIpLCBJID0gSC51c2VSZWYobnVsbCksIEMgPSBlKFwic2Nyb2xsZXJSZWZcIiksIHsgc2Nyb2xsQnlDYWxsYmFjazogZywgc2Nyb2xsZXJSZWY6IGEsIHNjcm9sbFRvQ2FsbGJhY2s6IFQgfSA9IFhuKFxuICAgICAgYyxcbiAgICAgIGYsXG4gICAgICB1LFxuICAgICAgQyxcbiAgICAgIG1cbiAgICApO1xuICAgIHJldHVybiBabigoKSA9PiB7XG4gICAgICB2YXIgYjtcbiAgICAgIHJldHVybiBhLmN1cnJlbnQgPSBtIHx8ICgoYiA9IEkuY3VycmVudCkgPT0gbnVsbCA/IHZvaWQgMCA6IGIub3duZXJEb2N1bWVudC5kZWZhdWx0VmlldyksICgpID0+IHtcbiAgICAgICAgYS5jdXJyZW50ID0gbnVsbDtcbiAgICAgIH07XG4gICAgfSwgW2EsIG1dKSwgdChcIndpbmRvd1Njcm9sbFRvXCIsIFQpLCB0KFwic2Nyb2xsQnlcIiwgZyksIC8qIEBfX1BVUkVfXyAqLyB6KFxuICAgICAgdSxcbiAgICAgIHtcbiAgICAgICAgcmVmOiBJLFxuICAgICAgICBcImRhdGEtdmlydHVvc28tc2Nyb2xsZXJcIjogITAsXG4gICAgICAgIHN0eWxlOiB7IHBvc2l0aW9uOiBcInJlbGF0aXZlXCIsIC4uLmksIC4uLlMgIT09IDAgPyB7IGhlaWdodDogUyArIHAgfSA6IHt9IH0sXG4gICAgICAgIC4uLmwsXG4gICAgICAgIC4uLloodSwgdyksXG4gICAgICAgIGNoaWxkcmVuOiBzXG4gICAgICB9XG4gICAgKTtcbiAgfSk7XG59XG5jb25zdCB1ciA9ICh7IGNoaWxkcmVuOiB0IH0pID0+IHtcbiAgY29uc3QgZSA9IEgudXNlQ29udGV4dChSZSksIG4gPSBndChcInZpZXdwb3J0SGVpZ2h0XCIpLCBvID0gZ3QoXCJmaXhlZEl0ZW1IZWlnaHRcIiksIHIgPSBNKFwiYWxpZ25Ub0JvdHRvbVwiKSwgcyA9IE0oXCJob3Jpem9udGFsRGlyZWN0aW9uXCIpLCBpID0gSC51c2VNZW1vKFxuICAgICgpID0+IG5lKG4sIChjKSA9PiB3dChjLCBzID8gXCJ3aWR0aFwiIDogXCJoZWlnaHRcIikpLFxuICAgIFtuLCBzXVxuICApLCBsID0gSHQoaSwgITAsIE0oXCJza2lwQW5pbWF0aW9uRnJhbWVJblJlc2l6ZU9ic2VydmVyXCIpKTtcbiAgcmV0dXJuIEgudXNlRWZmZWN0KCgpID0+IHtcbiAgICBlICYmIChuKGUudmlld3BvcnRIZWlnaHQpLCBvKGUuaXRlbUhlaWdodCkpO1xuICB9LCBbZSwgbiwgb10pLCAvKiBAX19QVVJFX18gKi8geihcImRpdlwiLCB7IFwiZGF0YS12aWV3cG9ydC10eXBlXCI6IFwiZWxlbWVudFwiLCByZWY6IGwsIHN0eWxlOiBadChyKSwgY2hpbGRyZW46IHQgfSk7XG59LCBhciA9ICh7IGNoaWxkcmVuOiB0IH0pID0+IHtcbiAgY29uc3QgZSA9IEgudXNlQ29udGV4dChSZSksIG4gPSBndChcIndpbmRvd1ZpZXdwb3J0UmVjdFwiKSwgbyA9IGd0KFwiZml4ZWRJdGVtSGVpZ2h0XCIpLCByID0gTShcImN1c3RvbVNjcm9sbFBhcmVudFwiKSwgcyA9IEdlKFxuICAgIG4sXG4gICAgcixcbiAgICBNKFwic2tpcEFuaW1hdGlvbkZyYW1lSW5SZXNpemVPYnNlcnZlclwiKVxuICApLCBpID0gTShcImFsaWduVG9Cb3R0b21cIik7XG4gIHJldHVybiBILnVzZUVmZmVjdCgoKSA9PiB7XG4gICAgZSAmJiAobyhlLml0ZW1IZWlnaHQpLCBuKHsgb2Zmc2V0VG9wOiAwLCB2aXNpYmxlSGVpZ2h0OiBlLnZpZXdwb3J0SGVpZ2h0LCB2aXNpYmxlV2lkdGg6IDEwMCB9KSk7XG4gIH0sIFtlLCBuLCBvXSksIC8qIEBfX1BVUkVfXyAqLyB6KFwiZGl2XCIsIHsgXCJkYXRhLXZpZXdwb3J0LXR5cGVcIjogXCJ3aW5kb3dcIiwgcmVmOiBzLCBzdHlsZTogWnQoaSksIGNoaWxkcmVuOiB0IH0pO1xufSwgZHIgPSAoeyBjaGlsZHJlbjogdCB9KSA9PiB7XG4gIGNvbnN0IGUgPSBNKFwiVG9wSXRlbUxpc3RDb21wb25lbnRcIikgfHwgXCJkaXZcIiwgbiA9IE0oXCJoZWFkZXJIZWlnaHRcIiksIG8gPSB7IC4uLmlyLCBtYXJnaW5Ub3A6IGAke259cHhgIH0sIHIgPSBNKFwiY29udGV4dFwiKTtcbiAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyB6KGUsIHsgc3R5bGU6IG8sIC4uLlooZSwgciksIGNoaWxkcmVuOiB0IH0pO1xufSwgZnIgPSAvKiBAX19QVVJFX18gKi8gSC5tZW1vKGZ1bmN0aW9uKGUpIHtcbiAgY29uc3QgbiA9IE0oXCJ1c2VXaW5kb3dTY3JvbGxcIiksIG8gPSBNKFwidG9wSXRlbXNJbmRleGVzXCIpLmxlbmd0aCA+IDAsIHIgPSBNKFwiY3VzdG9tU2Nyb2xsUGFyZW50XCIpLCBzID0gTShcImNvbnRleHRcIiksIGkgPSByIHx8IG4gPyBwciA6IG1yLCBsID0gciB8fCBuID8gYXIgOiB1cjtcbiAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBLdChpLCB7IC4uLmUsIC4uLlooaSwgcyksIGNoaWxkcmVuOiBbXG4gICAgbyAmJiAvKiBAX19QVVJFX18gKi8geihkciwgeyBjaGlsZHJlbjogLyogQF9fUFVSRV9fICovIHooVG4sIHsgc2hvd1RvcExpc3Q6ICEwIH0pIH0pLFxuICAgIC8qIEBfX1BVUkVfXyAqLyBLdChsLCB7IGNoaWxkcmVuOiBbXG4gICAgICAvKiBAX19QVVJFX18gKi8geihsciwge30pLFxuICAgICAgLyogQF9fUFVSRV9fICovIHooVG4sIHt9KSxcbiAgICAgIC8qIEBfX1BVUkVfXyAqLyB6KGNyLCB7fSlcbiAgICBdIH0pXG4gIF0gfSk7XG59KSwge1xuICBDb21wb25lbnQ6IGVvLFxuICB1c2VFbWl0dGVyOiBKZSxcbiAgdXNlRW1pdHRlclZhbHVlOiBNLFxuICB1c2VQdWJsaXNoZXI6IGd0XG59ID0gLyogQF9fUFVSRV9fICovIHFlKFxuICB0cixcbiAge1xuICAgIGV2ZW50czoge1xuICAgICAgYXRCb3R0b21TdGF0ZUNoYW5nZTogXCJhdEJvdHRvbVN0YXRlQ2hhbmdlXCIsXG4gICAgICBhdFRvcFN0YXRlQ2hhbmdlOiBcImF0VG9wU3RhdGVDaGFuZ2VcIixcbiAgICAgIGVuZFJlYWNoZWQ6IFwiZW5kUmVhY2hlZFwiLFxuICAgICAgZ3JvdXBJbmRpY2VzOiBcImdyb3VwSW5kaWNlc1wiLFxuICAgICAgaXNTY3JvbGxpbmc6IFwiaXNTY3JvbGxpbmdcIixcbiAgICAgIGl0ZW1zUmVuZGVyZWQ6IFwiaXRlbXNSZW5kZXJlZFwiLFxuICAgICAgcmFuZ2VDaGFuZ2VkOiBcInJhbmdlQ2hhbmdlZFwiLFxuICAgICAgc3RhcnRSZWFjaGVkOiBcInN0YXJ0UmVhY2hlZFwiLFxuICAgICAgdG90YWxMaXN0SGVpZ2h0Q2hhbmdlZDogXCJ0b3RhbExpc3RIZWlnaHRDaGFuZ2VkXCJcbiAgICB9LFxuICAgIG1ldGhvZHM6IHtcbiAgICAgIGF1dG9zY3JvbGxUb0JvdHRvbTogXCJhdXRvc2Nyb2xsVG9Cb3R0b21cIixcbiAgICAgIGdldFN0YXRlOiBcImdldFN0YXRlXCIsXG4gICAgICBzY3JvbGxCeTogXCJzY3JvbGxCeVwiLFxuICAgICAgc2Nyb2xsSW50b1ZpZXc6IFwic2Nyb2xsSW50b1ZpZXdcIixcbiAgICAgIHNjcm9sbFRvOiBcInNjcm9sbFRvXCIsXG4gICAgICBzY3JvbGxUb0luZGV4OiBcInNjcm9sbFRvSW5kZXhcIlxuICAgIH0sXG4gICAgb3B0aW9uYWw6IHtcbiAgICAgIGFsaWduVG9Cb3R0b206IFwiYWxpZ25Ub0JvdHRvbVwiLFxuICAgICAgYXRCb3R0b21UaHJlc2hvbGQ6IFwiYXRCb3R0b21UaHJlc2hvbGRcIixcbiAgICAgIGF0VG9wVGhyZXNob2xkOiBcImF0VG9wVGhyZXNob2xkXCIsXG4gICAgICBjb21wb25lbnRzOiBcImNvbXBvbmVudHNcIixcbiAgICAgIGNvbXB1dGVJdGVtS2V5OiBcImNvbXB1dGVJdGVtS2V5XCIsXG4gICAgICBjb250ZXh0OiBcImNvbnRleHRcIixcbiAgICAgIGN1c3RvbVNjcm9sbFBhcmVudDogXCJjdXN0b21TY3JvbGxQYXJlbnRcIixcbiAgICAgIGRhdGE6IFwiZGF0YVwiLFxuICAgICAgZGVmYXVsdEl0ZW1IZWlnaHQ6IFwiZGVmYXVsdEl0ZW1IZWlnaHRcIixcbiAgICAgIGZpcnN0SXRlbUluZGV4OiBcImZpcnN0SXRlbUluZGV4XCIsXG4gICAgICBmaXhlZEl0ZW1IZWlnaHQ6IFwiZml4ZWRJdGVtSGVpZ2h0XCIsXG4gICAgICBmb2xsb3dPdXRwdXQ6IFwiZm9sbG93T3V0cHV0XCIsXG4gICAgICBncm91cENvbnRlbnQ6IFwiZ3JvdXBDb250ZW50XCIsXG4gICAgICBncm91cENvdW50czogXCJncm91cENvdW50c1wiLFxuICAgICAgaGVhZGVyRm9vdGVyVGFnOiBcIkhlYWRlckZvb3RlclRhZ1wiLFxuICAgICAgaG9yaXpvbnRhbERpcmVjdGlvbjogXCJob3Jpem9udGFsRGlyZWN0aW9uXCIsXG4gICAgICBpbmNyZWFzZVZpZXdwb3J0Qnk6IFwiaW5jcmVhc2VWaWV3cG9ydEJ5XCIsXG4gICAgICBpbml0aWFsSXRlbUNvdW50OiBcImluaXRpYWxJdGVtQ291bnRcIixcbiAgICAgIGluaXRpYWxTY3JvbGxUb3A6IFwiaW5pdGlhbFNjcm9sbFRvcFwiLFxuICAgICAgaW5pdGlhbFRvcE1vc3RJdGVtSW5kZXg6IFwiaW5pdGlhbFRvcE1vc3RJdGVtSW5kZXhcIixcbiAgICAgIGl0ZW1Db250ZW50OiBcIml0ZW1Db250ZW50XCIsXG4gICAgICBpdGVtU2l6ZTogXCJpdGVtU2l6ZVwiLFxuICAgICAgbG9nTGV2ZWw6IFwibG9nTGV2ZWxcIixcbiAgICAgIG92ZXJzY2FuOiBcIm92ZXJzY2FuXCIsXG4gICAgICByZXN0b3JlU3RhdGVGcm9tOiBcInJlc3RvcmVTdGF0ZUZyb21cIixcbiAgICAgIHNjcm9sbGVyUmVmOiBcInNjcm9sbGVyUmVmXCIsXG4gICAgICBzY3JvbGxTZWVrQ29uZmlndXJhdGlvbjogXCJzY3JvbGxTZWVrQ29uZmlndXJhdGlvblwiLFxuICAgICAgc2tpcEFuaW1hdGlvbkZyYW1lSW5SZXNpemVPYnNlcnZlcjogXCJza2lwQW5pbWF0aW9uRnJhbWVJblJlc2l6ZU9ic2VydmVyXCIsXG4gICAgICB0b3BJdGVtQ291bnQ6IFwidG9wSXRlbUNvdW50XCIsXG4gICAgICB0b3RhbENvdW50OiBcInRvdGFsQ291bnRcIixcbiAgICAgIHVzZVdpbmRvd1Njcm9sbDogXCJ1c2VXaW5kb3dTY3JvbGxcIlxuICAgIH0sXG4gICAgcmVxdWlyZWQ6IHt9XG4gIH0sXG4gIGZyXG4pLCBtciA9IC8qIEBfX1BVUkVfXyAqLyBaZSh7IHVzZUVtaXR0ZXI6IEplLCB1c2VFbWl0dGVyVmFsdWU6IE0sIHVzZVB1Ymxpc2hlcjogZ3QgfSksIHByID0gLyogQF9fUFVSRV9fICovIFhlKHsgdXNlRW1pdHRlcjogSmUsIHVzZUVtaXR0ZXJWYWx1ZTogTSwgdXNlUHVibGlzaGVyOiBndCB9KSwgS3IgPSBlbywganIgPSBlbywgaHIgPSAvKiBAX19QVVJFX18gKi8gVSgoKSA9PiB7XG4gIGNvbnN0IHQgPSB5KChjKSA9PiAvKiBAX19QVVJFX18gKi8gS3QoXCJ0ZFwiLCB7IGNoaWxkcmVuOiBbXG4gICAgXCJJdGVtICRcIixcbiAgICBjXG4gIF0gfSkpLCBlID0geShudWxsKSwgbiA9IHkobnVsbCksIG8gPSB5KG51bGwpLCByID0geSh7fSksIHMgPSB5KFllKSwgaSA9IHkoWXQpLCBsID0gKGMsIHUgPSBudWxsKSA9PiBjdChcbiAgICB4KFxuICAgICAgcixcbiAgICAgIEUoKGYpID0+IGZbY10pLFxuICAgICAgWSgpXG4gICAgKSxcbiAgICB1XG4gICk7XG4gIHJldHVybiB7XG4gICAgY29tcG9uZW50czogcixcbiAgICBjb21wdXRlSXRlbUtleTogcyxcbiAgICBjb250ZXh0OiBlLFxuICAgIEVtcHR5UGxhY2Vob2xkZXI6IGwoXCJFbXB0eVBsYWNlaG9sZGVyXCIpLFxuICAgIEZpbGxlclJvdzogbChcIkZpbGxlclJvd1wiKSxcbiAgICBmaXhlZEZvb3RlckNvbnRlbnQ6IG8sXG4gICAgZml4ZWRIZWFkZXJDb250ZW50OiBuLFxuICAgIGl0ZW1Db250ZW50OiB0LFxuICAgIFNjcm9sbGVyQ29tcG9uZW50OiBsKFwiU2Nyb2xsZXJcIiwgXCJkaXZcIiksXG4gICAgc2Nyb2xsZXJSZWY6IGksXG4gICAgU2Nyb2xsU2Vla1BsYWNlaG9sZGVyOiBsKFwiU2Nyb2xsU2Vla1BsYWNlaG9sZGVyXCIpLFxuICAgIFRhYmxlQm9keUNvbXBvbmVudDogbChcIlRhYmxlQm9keVwiLCBcInRib2R5XCIpLFxuICAgIFRhYmxlQ29tcG9uZW50OiBsKFwiVGFibGVcIiwgXCJ0YWJsZVwiKSxcbiAgICBUYWJsZUZvb3RlckNvbXBvbmVudDogbChcIlRhYmxlRm9vdFwiLCBcInRmb290XCIpLFxuICAgIFRhYmxlSGVhZENvbXBvbmVudDogbChcIlRhYmxlSGVhZFwiLCBcInRoZWFkXCIpLFxuICAgIFRhYmxlUm93Q29tcG9uZW50OiBsKFwiVGFibGVSb3dcIiwgXCJ0clwiKVxuICB9O1xufSksIGdyID0gLyogQF9fUFVSRV9fICovIFUoXG4gIChbdCwgZV0pID0+ICh7IC4uLnQsIC4uLmUgfSksXG4gIFgocW4sIGhyKVxuKSwgSXIgPSAoeyBoZWlnaHQ6IHQgfSkgPT4gLyogQF9fUFVSRV9fICovIHooXCJ0clwiLCB7IGNoaWxkcmVuOiAvKiBAX19QVVJFX18gKi8geihcInRkXCIsIHsgc3R5bGU6IHsgaGVpZ2h0OiB0IH0gfSkgfSksIFNyID0gKHsgaGVpZ2h0OiB0IH0pID0+IC8qIEBfX1BVUkVfXyAqLyB6KFwidHJcIiwgeyBjaGlsZHJlbjogLyogQF9fUFVSRV9fICovIHooXCJ0ZFwiLCB7IHN0eWxlOiB7IGJvcmRlcjogMCwgaGVpZ2h0OiB0LCBwYWRkaW5nOiAwIH0gfSkgfSksIHhyID0geyBvdmVyZmxvd0FuY2hvcjogXCJub25lXCIgfSwgQ24gPSAvKiBAX19QVVJFX18gKi8gSC5tZW1vKGZ1bmN0aW9uKHsgc2hvd1RvcExpc3Q6IGUgPSAhMSB9KSB7XG4gIGNvbnN0IG4gPSBfKFwibGlzdFN0YXRlXCIpLCBvID0gXyhcImNvbXB1dGVJdGVtS2V5XCIpLCByID0gXyhcImZpcnN0SXRlbUluZGV4XCIpLCBzID0gXyhcImlzU2Vla2luZ1wiKSwgaSA9IF8oXCJTY3JvbGxTZWVrUGxhY2Vob2xkZXJcIikgfHwgSXIsIGwgPSBfKFwiY29udGV4dFwiKSwgYyA9IF8oXCJUYWJsZVJvd0NvbXBvbmVudFwiKSwgdSA9IF8oXCJmaXhlZEhlYWRlckhlaWdodFwiKSwgZiA9IF8oXCJpdGVtQ29udGVudFwiKSwgUyA9IChlID8gbi50b3BJdGVtcyA6IFtdKS5yZWR1Y2UoKG0sIHcsIEkpID0+IChJID09PSAwID8gbS5wdXNoKHcuc2l6ZSkgOiBtLnB1c2gobVtJIC0gMV0gKyB3LnNpemUpLCBtKSwgW10pLCBwID0gKGUgPyBuLnRvcEl0ZW1zIDogbi5pdGVtcykubWFwKChtKSA9PiB7XG4gICAgY29uc3QgdyA9IG0ub3JpZ2luYWxJbmRleCwgSSA9IG8odyArIHIsIG0uZGF0YSwgbCksIEMgPSBlID8gdyA9PT0gMCA/IDAgOiBTW3cgLSAxXSA6IDA7XG4gICAgcmV0dXJuIHMgPyAvKiBAX19QVVJFX18gKi8gJHQoXG4gICAgICBpLFxuICAgICAge1xuICAgICAgICAuLi5aKGksIGwpLFxuICAgICAgICBoZWlnaHQ6IG0uc2l6ZSxcbiAgICAgICAgaW5kZXg6IG0uaW5kZXgsXG4gICAgICAgIGtleTogSSxcbiAgICAgICAgdHlwZTogbS50eXBlIHx8IFwiaXRlbVwiXG4gICAgICB9XG4gICAgKSA6IC8qIEBfX1BVUkVfXyAqLyAkdChcbiAgICAgIGMsXG4gICAgICB7XG4gICAgICAgIC4uLlooYywgbCksXG4gICAgICAgIC4uLnRvKGMsIG0uZGF0YSksXG4gICAgICAgIFwiZGF0YS1pbmRleFwiOiB3LFxuICAgICAgICBcImRhdGEtaXRlbS1pbmRleFwiOiBtLmluZGV4LFxuICAgICAgICBcImRhdGEta25vd24tc2l6ZVwiOiBtLnNpemUsXG4gICAgICAgIGtleTogSSxcbiAgICAgICAgc3R5bGU6IGUgPyB7IG92ZXJmbG93QW5jaG9yOiBcIm5vbmVcIiwgcG9zaXRpb246IFwic3RpY2t5XCIsIHRvcDogdSArIEMsIHpJbmRleDogMiB9IDogeHJcbiAgICAgIH0sXG4gICAgICBmKG0uaW5kZXgsIG0uZGF0YSwgbClcbiAgICApO1xuICB9KTtcbiAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyB6KGlvLCB7IGNoaWxkcmVuOiBwIH0pO1xufSksIFRyID0gLyogQF9fUFVSRV9fICovIEgubWVtbyhmdW5jdGlvbigpIHtcbiAgY29uc3QgZSA9IF8oXCJsaXN0U3RhdGVcIiksIG4gPSBfKFwidG9wSXRlbXNJbmRleGVzXCIpLmxlbmd0aCA+IDAsIG8gPSBUdChcInNpemVSYW5nZXNcIiksIHIgPSBfKFwidXNlV2luZG93U2Nyb2xsXCIpLCBzID0gXyhcImN1c3RvbVNjcm9sbFBhcmVudFwiKSwgaSA9IFR0KFwid2luZG93U2Nyb2xsQ29udGFpbmVyU3RhdGVcIiksIGwgPSBUdChcInNjcm9sbENvbnRhaW5lclN0YXRlXCIpLCBjID0gcyB8fCByID8gaSA6IGwsIHUgPSBfKFwidHJhY2tJdGVtU2l6ZXNcIiksIGYgPSBfKFwiaXRlbVNpemVcIiksIFMgPSBfKFwibG9nXCIpLCB7IGNhbGxiYWNrUmVmOiBwLCByZWY6IG0gfSA9IE9uKFxuICAgIG8sXG4gICAgZixcbiAgICB1LFxuICAgIGMsXG4gICAgUyxcbiAgICB2b2lkIDAsXG4gICAgcyxcbiAgICAhMSxcbiAgICBfKFwic2tpcEFuaW1hdGlvbkZyYW1lSW5SZXNpemVPYnNlcnZlclwiKVxuICApLCBbdywgSV0gPSBILnVzZVN0YXRlKDApO1xuICBRZShcImRldmlhdGlvblwiLCAoVikgPT4ge1xuICAgIHcgIT09IFYgJiYgKG0uY3VycmVudC5zdHlsZS5tYXJnaW5Ub3AgPSBgJHtWfXB4YCwgSShWKSk7XG4gIH0pO1xuICBjb25zdCBDID0gXyhcIkVtcHR5UGxhY2Vob2xkZXJcIiksIGcgPSBfKFwiRmlsbGVyUm93XCIpIHx8IFNyLCBhID0gXyhcIlRhYmxlQm9keUNvbXBvbmVudFwiKSwgVCA9IF8oXCJwYWRkaW5nVG9wQWRkaXRpb25cIiksIGIgPSBfKFwic3RhdGVmdWxUb3RhbENvdW50XCIpLCBoID0gXyhcImNvbnRleHRcIik7XG4gIGlmIChiID09PSAwICYmIEMpXG4gICAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyB6KEMsIHsgLi4uWihDLCBoKSB9KTtcbiAgY29uc3QgZCA9IChuID8gZS50b3BJdGVtcyA6IFtdKS5yZWR1Y2UoKFYsIEQpID0+IFYgKyBELnNpemUsIDApLCBSID0gZS5vZmZzZXRUb3AgKyBUICsgdyAtIGQsIEIgPSBlLm9mZnNldEJvdHRvbSwgTyA9IFIgPiAwID8gLyogQF9fUFVSRV9fICovIHooZywgeyBjb250ZXh0OiBoLCBoZWlnaHQ6IFIgfSwgXCJwYWRkaW5nLXRvcFwiKSA6IG51bGwsIEwgPSBCID4gMCA/IC8qIEBfX1BVUkVfXyAqLyB6KGcsIHsgY29udGV4dDogaCwgaGVpZ2h0OiBCIH0sIFwicGFkZGluZy1ib3R0b21cIikgOiBudWxsO1xuICByZXR1cm4gLyogQF9fUFVSRV9fICovIEt0KGEsIHsgXCJkYXRhLXRlc3RpZFwiOiBcInZpcnR1b3NvLWl0ZW0tbGlzdFwiLCByZWY6IHAsIC4uLlooYSwgaCksIGNoaWxkcmVuOiBbXG4gICAgTyxcbiAgICBuICYmIC8qIEBfX1BVUkVfXyAqLyB6KENuLCB7IHNob3dUb3BMaXN0OiAhMCB9KSxcbiAgICAvKiBAX19QVVJFX18gKi8geihDbiwge30pLFxuICAgIExcbiAgXSB9KTtcbn0pLCBDciA9ICh7IGNoaWxkcmVuOiB0IH0pID0+IHtcbiAgY29uc3QgZSA9IEgudXNlQ29udGV4dChSZSksIG4gPSBUdChcInZpZXdwb3J0SGVpZ2h0XCIpLCBvID0gVHQoXCJmaXhlZEl0ZW1IZWlnaHRcIiksIHIgPSBIdChcbiAgICBILnVzZU1lbW8oKCkgPT4gbmUobiwgKHMpID0+IHd0KHMsIFwiaGVpZ2h0XCIpKSwgW25dKSxcbiAgICAhMCxcbiAgICBfKFwic2tpcEFuaW1hdGlvbkZyYW1lSW5SZXNpemVPYnNlcnZlclwiKVxuICApO1xuICByZXR1cm4gSC51c2VFZmZlY3QoKCkgPT4ge1xuICAgIGUgJiYgKG4oZS52aWV3cG9ydEhlaWdodCksIG8oZS5pdGVtSGVpZ2h0KSk7XG4gIH0sIFtlLCBuLCBvXSksIC8qIEBfX1BVUkVfXyAqLyB6KFwiZGl2XCIsIHsgXCJkYXRhLXZpZXdwb3J0LXR5cGVcIjogXCJlbGVtZW50XCIsIHJlZjogciwgc3R5bGU6IFp0KCExKSwgY2hpbGRyZW46IHQgfSk7XG59LCB3ciA9ICh7IGNoaWxkcmVuOiB0IH0pID0+IHtcbiAgY29uc3QgZSA9IEgudXNlQ29udGV4dChSZSksIG4gPSBUdChcIndpbmRvd1ZpZXdwb3J0UmVjdFwiKSwgbyA9IFR0KFwiZml4ZWRJdGVtSGVpZ2h0XCIpLCByID0gXyhcImN1c3RvbVNjcm9sbFBhcmVudFwiKSwgcyA9IEdlKFxuICAgIG4sXG4gICAgcixcbiAgICBfKFwic2tpcEFuaW1hdGlvbkZyYW1lSW5SZXNpemVPYnNlcnZlclwiKVxuICApO1xuICByZXR1cm4gSC51c2VFZmZlY3QoKCkgPT4ge1xuICAgIGUgJiYgKG8oZS5pdGVtSGVpZ2h0KSwgbih7IG9mZnNldFRvcDogMCwgdmlzaWJsZUhlaWdodDogZS52aWV3cG9ydEhlaWdodCwgdmlzaWJsZVdpZHRoOiAxMDAgfSkpO1xuICB9LCBbZSwgbiwgb10pLCAvKiBAX19QVVJFX18gKi8geihcImRpdlwiLCB7IFwiZGF0YS12aWV3cG9ydC10eXBlXCI6IFwid2luZG93XCIsIHJlZjogcywgc3R5bGU6IFp0KCExKSwgY2hpbGRyZW46IHQgfSk7XG59LCB5ciA9IC8qIEBfX1BVUkVfXyAqLyBILm1lbW8oZnVuY3Rpb24oZSkge1xuICBjb25zdCBuID0gXyhcInVzZVdpbmRvd1Njcm9sbFwiKSwgbyA9IF8oXCJjdXN0b21TY3JvbGxQYXJlbnRcIiksIHIgPSBUdChcImZpeGVkSGVhZGVySGVpZ2h0XCIpLCBzID0gVHQoXCJmaXhlZEZvb3RlckhlaWdodFwiKSwgaSA9IF8oXCJmaXhlZEhlYWRlckNvbnRlbnRcIiksIGwgPSBfKFwiZml4ZWRGb290ZXJDb250ZW50XCIpLCBjID0gXyhcImNvbnRleHRcIiksIHUgPSBIdChcbiAgICBILnVzZU1lbW8oKCkgPT4gbmUociwgKGEpID0+IHd0KGEsIFwiaGVpZ2h0XCIpKSwgW3JdKSxcbiAgICAhMCxcbiAgICBfKFwic2tpcEFuaW1hdGlvbkZyYW1lSW5SZXNpemVPYnNlcnZlclwiKVxuICApLCBmID0gSHQoXG4gICAgSC51c2VNZW1vKCgpID0+IG5lKHMsIChhKSA9PiB3dChhLCBcImhlaWdodFwiKSksIFtzXSksXG4gICAgITAsXG4gICAgXyhcInNraXBBbmltYXRpb25GcmFtZUluUmVzaXplT2JzZXJ2ZXJcIilcbiAgKSwgUyA9IG8gfHwgbiA/IFJyIDogYnIsIHAgPSBvIHx8IG4gPyB3ciA6IENyLCBtID0gXyhcIlRhYmxlQ29tcG9uZW50XCIpLCB3ID0gXyhcIlRhYmxlSGVhZENvbXBvbmVudFwiKSwgSSA9IF8oXCJUYWJsZUZvb3RlckNvbXBvbmVudFwiKSwgQyA9IGkgPyAvKiBAX19QVVJFX18gKi8geihcbiAgICB3LFxuICAgIHtcbiAgICAgIHJlZjogdSxcbiAgICAgIHN0eWxlOiB7IHBvc2l0aW9uOiBcInN0aWNreVwiLCB0b3A6IDAsIHpJbmRleDogMiB9LFxuICAgICAgLi4uWih3LCBjKSxcbiAgICAgIGNoaWxkcmVuOiBpKClcbiAgICB9LFxuICAgIFwiVGFibGVIZWFkXCJcbiAgKSA6IG51bGwsIGcgPSBsID8gLyogQF9fUFVSRV9fICovIHooXG4gICAgSSxcbiAgICB7XG4gICAgICByZWY6IGYsXG4gICAgICBzdHlsZTogeyBib3R0b206IDAsIHBvc2l0aW9uOiBcInN0aWNreVwiLCB6SW5kZXg6IDEgfSxcbiAgICAgIC4uLlooSSwgYyksXG4gICAgICBjaGlsZHJlbjogbCgpXG4gICAgfSxcbiAgICBcIlRhYmxlRm9vdFwiXG4gICkgOiBudWxsO1xuICByZXR1cm4gLyogQF9fUFVSRV9fICovIHooUywgeyAuLi5lLCAuLi5aKFMsIGMpLCBjaGlsZHJlbjogLyogQF9fUFVSRV9fICovIHoocCwgeyBjaGlsZHJlbjogLyogQF9fUFVSRV9fICovIEt0KG0sIHsgc3R5bGU6IHsgYm9yZGVyU3BhY2luZzogMCwgb3ZlcmZsb3dBbmNob3I6IFwibm9uZVwiIH0sIC4uLloobSwgYyksIGNoaWxkcmVuOiBbXG4gICAgQyxcbiAgICAvKiBAX19QVVJFX18gKi8geihUciwge30sIFwiVGFibGVCb2R5XCIpLFxuICAgIGdcbiAgXSB9KSB9KSB9KTtcbn0pLCB7XG4gIENvbXBvbmVudDogdnIsXG4gIHVzZUVtaXR0ZXI6IFFlLFxuICB1c2VFbWl0dGVyVmFsdWU6IF8sXG4gIHVzZVB1Ymxpc2hlcjogVHRcbn0gPSAvKiBAX19QVVJFX18gKi8gcWUoXG4gIGdyLFxuICB7XG4gICAgZXZlbnRzOiB7XG4gICAgICBhdEJvdHRvbVN0YXRlQ2hhbmdlOiBcImF0Qm90dG9tU3RhdGVDaGFuZ2VcIixcbiAgICAgIGF0VG9wU3RhdGVDaGFuZ2U6IFwiYXRUb3BTdGF0ZUNoYW5nZVwiLFxuICAgICAgZW5kUmVhY2hlZDogXCJlbmRSZWFjaGVkXCIsXG4gICAgICBncm91cEluZGljZXM6IFwiZ3JvdXBJbmRpY2VzXCIsXG4gICAgICBpc1Njcm9sbGluZzogXCJpc1Njcm9sbGluZ1wiLFxuICAgICAgaXRlbXNSZW5kZXJlZDogXCJpdGVtc1JlbmRlcmVkXCIsXG4gICAgICByYW5nZUNoYW5nZWQ6IFwicmFuZ2VDaGFuZ2VkXCIsXG4gICAgICBzdGFydFJlYWNoZWQ6IFwic3RhcnRSZWFjaGVkXCIsXG4gICAgICB0b3RhbExpc3RIZWlnaHRDaGFuZ2VkOiBcInRvdGFsTGlzdEhlaWdodENoYW5nZWRcIlxuICAgIH0sXG4gICAgbWV0aG9kczoge1xuICAgICAgZ2V0U3RhdGU6IFwiZ2V0U3RhdGVcIixcbiAgICAgIHNjcm9sbEJ5OiBcInNjcm9sbEJ5XCIsXG4gICAgICBzY3JvbGxJbnRvVmlldzogXCJzY3JvbGxJbnRvVmlld1wiLFxuICAgICAgc2Nyb2xsVG86IFwic2Nyb2xsVG9cIixcbiAgICAgIHNjcm9sbFRvSW5kZXg6IFwic2Nyb2xsVG9JbmRleFwiXG4gICAgfSxcbiAgICBvcHRpb25hbDoge1xuICAgICAgYWxpZ25Ub0JvdHRvbTogXCJhbGlnblRvQm90dG9tXCIsXG4gICAgICBhdEJvdHRvbVRocmVzaG9sZDogXCJhdEJvdHRvbVRocmVzaG9sZFwiLFxuICAgICAgYXRUb3BUaHJlc2hvbGQ6IFwiYXRUb3BUaHJlc2hvbGRcIixcbiAgICAgIGNvbXBvbmVudHM6IFwiY29tcG9uZW50c1wiLFxuICAgICAgY29tcHV0ZUl0ZW1LZXk6IFwiY29tcHV0ZUl0ZW1LZXlcIixcbiAgICAgIGNvbnRleHQ6IFwiY29udGV4dFwiLFxuICAgICAgY3VzdG9tU2Nyb2xsUGFyZW50OiBcImN1c3RvbVNjcm9sbFBhcmVudFwiLFxuICAgICAgZGF0YTogXCJkYXRhXCIsXG4gICAgICBkZWZhdWx0SXRlbUhlaWdodDogXCJkZWZhdWx0SXRlbUhlaWdodFwiLFxuICAgICAgZmlyc3RJdGVtSW5kZXg6IFwiZmlyc3RJdGVtSW5kZXhcIixcbiAgICAgIGZpeGVkRm9vdGVyQ29udGVudDogXCJmaXhlZEZvb3RlckNvbnRlbnRcIixcbiAgICAgIGZpeGVkSGVhZGVyQ29udGVudDogXCJmaXhlZEhlYWRlckNvbnRlbnRcIixcbiAgICAgIGZpeGVkSXRlbUhlaWdodDogXCJmaXhlZEl0ZW1IZWlnaHRcIixcbiAgICAgIGZvbGxvd091dHB1dDogXCJmb2xsb3dPdXRwdXRcIixcbiAgICAgIGdyb3VwQ291bnRzOiBcImdyb3VwQ291bnRzXCIsXG4gICAgICBpbmNyZWFzZVZpZXdwb3J0Qnk6IFwiaW5jcmVhc2VWaWV3cG9ydEJ5XCIsXG4gICAgICBpbml0aWFsSXRlbUNvdW50OiBcImluaXRpYWxJdGVtQ291bnRcIixcbiAgICAgIGluaXRpYWxTY3JvbGxUb3A6IFwiaW5pdGlhbFNjcm9sbFRvcFwiLFxuICAgICAgaW5pdGlhbFRvcE1vc3RJdGVtSW5kZXg6IFwiaW5pdGlhbFRvcE1vc3RJdGVtSW5kZXhcIixcbiAgICAgIGl0ZW1Db250ZW50OiBcIml0ZW1Db250ZW50XCIsXG4gICAgICBpdGVtU2l6ZTogXCJpdGVtU2l6ZVwiLFxuICAgICAgbG9nTGV2ZWw6IFwibG9nTGV2ZWxcIixcbiAgICAgIG92ZXJzY2FuOiBcIm92ZXJzY2FuXCIsXG4gICAgICByZXN0b3JlU3RhdGVGcm9tOiBcInJlc3RvcmVTdGF0ZUZyb21cIixcbiAgICAgIHNjcm9sbGVyUmVmOiBcInNjcm9sbGVyUmVmXCIsXG4gICAgICBzY3JvbGxTZWVrQ29uZmlndXJhdGlvbjogXCJzY3JvbGxTZWVrQ29uZmlndXJhdGlvblwiLFxuICAgICAgdG9wSXRlbUNvdW50OiBcInRvcEl0ZW1Db3VudFwiLFxuICAgICAgdG90YWxDb3VudDogXCJ0b3RhbENvdW50XCIsXG4gICAgICB1c2VXaW5kb3dTY3JvbGw6IFwidXNlV2luZG93U2Nyb2xsXCJcbiAgICB9LFxuICAgIHJlcXVpcmVkOiB7fVxuICB9LFxuICB5clxuKSwgYnIgPSAvKiBAX19QVVJFX18gKi8gWmUoeyB1c2VFbWl0dGVyOiBRZSwgdXNlRW1pdHRlclZhbHVlOiBfLCB1c2VQdWJsaXNoZXI6IFR0IH0pLCBSciA9IC8qIEBfX1BVUkVfXyAqLyBYZSh7IHVzZUVtaXR0ZXI6IFFlLCB1c2VFbWl0dGVyVmFsdWU6IF8sIHVzZVB1Ymxpc2hlcjogVHQgfSksIHFyID0gdnIsIHduID0ge1xuICBib3R0b206IDAsXG4gIGl0ZW1IZWlnaHQ6IDAsXG4gIGl0ZW1zOiBbXSxcbiAgaXRlbVdpZHRoOiAwLFxuICBvZmZzZXRCb3R0b206IDAsXG4gIG9mZnNldFRvcDogMCxcbiAgdG9wOiAwXG59LCBIciA9IHtcbiAgYm90dG9tOiAwLFxuICBpdGVtSGVpZ2h0OiAwLFxuICBpdGVtczogW3sgaW5kZXg6IDAgfV0sXG4gIGl0ZW1XaWR0aDogMCxcbiAgb2Zmc2V0Qm90dG9tOiAwLFxuICBvZmZzZXRUb3A6IDAsXG4gIHRvcDogMFxufSwgeyBjZWlsOiB5biwgZmxvb3I6IENlLCBtYXg6IGVlLCBtaW46IEZlLCByb3VuZDogdm4gfSA9IE1hdGg7XG5mdW5jdGlvbiBibih0LCBlLCBuKSB7XG4gIHJldHVybiBBcnJheS5mcm9tKHsgbGVuZ3RoOiBlIC0gdCArIDEgfSkubWFwKChvLCByKSA9PiAoeyBkYXRhOiBuID09PSBudWxsID8gbnVsbCA6IG5bciArIHRdLCBpbmRleDogciArIHQgfSkpO1xufVxuZnVuY3Rpb24gRXIodCkge1xuICByZXR1cm4ge1xuICAgIC4uLkhyLFxuICAgIGl0ZW1zOiB0XG4gIH07XG59XG5mdW5jdGlvbiBoZSh0LCBlKSB7XG4gIHJldHVybiB0ICYmIHQud2lkdGggPT09IGUud2lkdGggJiYgdC5oZWlnaHQgPT09IGUuaGVpZ2h0O1xufVxuZnVuY3Rpb24ga3IodCwgZSkge1xuICByZXR1cm4gdCAmJiB0LmNvbHVtbiA9PT0gZS5jb2x1bW4gJiYgdC5yb3cgPT09IGUucm93O1xufVxuY29uc3QgQnIgPSAvKiBAX19QVVJFX18gKi8gVShcbiAgKFtcbiAgICB7IGluY3JlYXNlVmlld3BvcnRCeTogdCwgbGlzdEJvdW5kYXJ5OiBlLCBvdmVyc2NhbjogbiwgdmlzaWJsZVJhbmdlOiBvIH0sXG4gICAgeyBmb290ZXJIZWlnaHQ6IHIsIGhlYWRlckhlaWdodDogcywgc2Nyb2xsQnk6IGksIHNjcm9sbENvbnRhaW5lclN0YXRlOiBsLCBzY3JvbGxUbzogYywgc2Nyb2xsVG9wOiB1LCBzbW9vdGhTY3JvbGxUYXJnZXRSZWFjaGVkOiBmLCB2aWV3cG9ydEhlaWdodDogUyB9LFxuICAgIHAsXG4gICAgbSxcbiAgICB7IGRpZE1vdW50OiB3LCBwcm9wc1JlYWR5OiBJIH0sXG4gICAgeyBjdXN0b21TY3JvbGxQYXJlbnQ6IEMsIHVzZVdpbmRvd1Njcm9sbDogZywgd2luZG93U2Nyb2xsQ29udGFpbmVyU3RhdGU6IGEsIHdpbmRvd1Njcm9sbFRvOiBULCB3aW5kb3dWaWV3cG9ydFJlY3Q6IGIgfSxcbiAgICBoXG4gIF0pID0+IHtcbiAgICBjb25zdCBkID0geSgwKSwgUiA9IHkoMCksIEIgPSB5KHduKSwgTyA9IHkoeyBoZWlnaHQ6IDAsIHdpZHRoOiAwIH0pLCBMID0geSh7IGhlaWdodDogMCwgd2lkdGg6IDAgfSksIFYgPSAkKCksIEQgPSAkKCksIEogPSB5KDApLCBudCA9IHkobnVsbCksIGsgPSB5KHsgY29sdW1uOiAwLCByb3c6IDAgfSksIHEgPSAkKCksIHN0ID0gJCgpLCBkdCA9IHkoITEpLCBTdCA9IHkoMCksIGZ0ID0geSghMCksIHV0ID0geSghMSksIEF0ID0geSghMSk7XG4gICAgSyhcbiAgICAgIHgoXG4gICAgICAgIHcsXG4gICAgICAgIEcoU3QpLFxuICAgICAgICBQKChbdiwgTl0pID0+ICEhTilcbiAgICAgICksXG4gICAgICAoKSA9PiB7XG4gICAgICAgIFcoZnQsICExKTtcbiAgICAgIH1cbiAgICApLCBLKFxuICAgICAgeChcbiAgICAgICAgcnQodywgZnQsIEwsIE8sIFN0LCB1dCksXG4gICAgICAgIFAoKFt2LCBOLCBRLCBpdCwgLCB0dF0pID0+IHYgJiYgIU4gJiYgUS5oZWlnaHQgIT09IDAgJiYgaXQuaGVpZ2h0ICE9PSAwICYmICF0dClcbiAgICAgICksXG4gICAgICAoWywgLCAsICwgdl0pID0+IHtcbiAgICAgICAgVyh1dCwgITApLCAkZSgxLCAoKSA9PiB7XG4gICAgICAgICAgVyhWLCB2KTtcbiAgICAgICAgfSksIFJ0KHgodSksICgpID0+IHtcbiAgICAgICAgICBXKGUsIFswLCAwXSksIFcoZnQsICEwKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgKSwgRihcbiAgICAgIHgoXG4gICAgICAgIHN0LFxuICAgICAgICBQKCh2KSA9PiB2ICE9IG51bGwgJiYgdi5zY3JvbGxUb3AgPiAwKSxcbiAgICAgICAgdnQoMClcbiAgICAgICksXG4gICAgICBSXG4gICAgKSwgSyhcbiAgICAgIHgoXG4gICAgICAgIHcsXG4gICAgICAgIEcoc3QpLFxuICAgICAgICBQKChbLCB2XSkgPT4gdiAhPSBudWxsKVxuICAgICAgKSxcbiAgICAgIChbLCB2XSkgPT4ge1xuICAgICAgICB2ICYmIChXKE8sIHYudmlld3BvcnQpLCBXKEwsIHYuaXRlbSksIFcoaywgdi5nYXApLCB2LnNjcm9sbFRvcCA+IDAgJiYgKFcoZHQsICEwKSwgUnQoeCh1LCBqdCgxKSksIChOKSA9PiB7XG4gICAgICAgICAgVyhkdCwgITEpO1xuICAgICAgICB9KSwgVyhjLCB7IHRvcDogdi5zY3JvbGxUb3AgfSkpKTtcbiAgICAgIH1cbiAgICApLCBGKFxuICAgICAgeChcbiAgICAgICAgTyxcbiAgICAgICAgRSgoeyBoZWlnaHQ6IHYgfSkgPT4gdilcbiAgICAgICksXG4gICAgICBTXG4gICAgKSwgRihcbiAgICAgIHgoXG4gICAgICAgIHJ0KFxuICAgICAgICAgIEEoTywgaGUpLFxuICAgICAgICAgIEEoTCwgaGUpLFxuICAgICAgICAgIEEoaywgKHYsIE4pID0+IHYgJiYgdi5jb2x1bW4gPT09IE4uY29sdW1uICYmIHYucm93ID09PSBOLnJvdyksXG4gICAgICAgICAgQSh1KVxuICAgICAgICApLFxuICAgICAgICBFKChbdiwgTiwgUSwgaXRdKSA9PiAoe1xuICAgICAgICAgIGdhcDogUSxcbiAgICAgICAgICBpdGVtOiBOLFxuICAgICAgICAgIHNjcm9sbFRvcDogaXQsXG4gICAgICAgICAgdmlld3BvcnQ6IHZcbiAgICAgICAgfSkpXG4gICAgICApLFxuICAgICAgcVxuICAgICksIEYoXG4gICAgICB4KFxuICAgICAgICBydChcbiAgICAgICAgICBBKGQpLFxuICAgICAgICAgIG8sXG4gICAgICAgICAgQShrLCBrciksXG4gICAgICAgICAgQShMLCBoZSksXG4gICAgICAgICAgQShPLCBoZSksXG4gICAgICAgICAgQShudCksXG4gICAgICAgICAgQShSKSxcbiAgICAgICAgICBBKGR0KSxcbiAgICAgICAgICBBKGZ0KSxcbiAgICAgICAgICBBKFN0KVxuICAgICAgICApLFxuICAgICAgICBQKChbLCAsICwgLCAsICwgLCB2XSkgPT4gIXYpLFxuICAgICAgICBFKFxuICAgICAgICAgIChbXG4gICAgICAgICAgICB2LFxuICAgICAgICAgICAgW04sIFFdLFxuICAgICAgICAgICAgaXQsXG4gICAgICAgICAgICB0dCxcbiAgICAgICAgICAgIEJ0LFxuICAgICAgICAgICAgSnQsXG4gICAgICAgICAgICBOdCxcbiAgICAgICAgICAgICxcbiAgICAgICAgICAgIGRlLFxuICAgICAgICAgICAgT3RcbiAgICAgICAgICBdKSA9PiB7XG4gICAgICAgICAgICBjb25zdCB7IGNvbHVtbjogRnQsIHJvdzogUXQgfSA9IGl0LCB7IGhlaWdodDogZmUsIHdpZHRoOiBIZSB9ID0gdHQsIHsgd2lkdGg6IHRuIH0gPSBCdDtcbiAgICAgICAgICAgIGlmIChOdCA9PT0gMCAmJiAodiA9PT0gMCB8fCB0biA9PT0gMCkpXG4gICAgICAgICAgICAgIHJldHVybiB3bjtcbiAgICAgICAgICAgIGlmIChIZSA9PT0gMCkge1xuICAgICAgICAgICAgICBjb25zdCBzbiA9IFVlKE90LCB2KSwgc28gPSBzbiArIE1hdGgubWF4KE50IC0gMSwgMCk7XG4gICAgICAgICAgICAgIHJldHVybiBFcihibihzbiwgc28sIEp0KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBtZSA9IG5vKHRuLCBIZSwgRnQpO1xuICAgICAgICAgICAgbGV0IER0LCBXdDtcbiAgICAgICAgICAgIGRlID8gTiA9PT0gMCAmJiBRID09PSAwICYmIE50ID4gMCA/IChEdCA9IDAsIFd0ID0gTnQgLSAxKSA6IChEdCA9IG1lICogQ2UoKE4gKyBRdCkgLyAoZmUgKyBRdCkpLCBXdCA9IG1lICogeW4oKFEgKyBRdCkgLyAoZmUgKyBRdCkpIC0gMSwgV3QgPSBGZSh2IC0gMSwgZWUoV3QsIG1lIC0gMSkpLCBEdCA9IEZlKFd0LCBlZSgwLCBEdCkpKSA6IChEdCA9IDAsIFd0ID0gLTEpO1xuICAgICAgICAgICAgY29uc3QgZW4gPSBibihEdCwgV3QsIEp0KSwgeyBib3R0b206IG5uLCB0b3A6IG9uIH0gPSBSbihCdCwgaXQsIHR0LCBlbiksIHJuID0geW4odiAvIG1lKSwgcm8gPSBybiAqIGZlICsgKHJuIC0gMSkgKiBRdCAtIG5uO1xuICAgICAgICAgICAgcmV0dXJuIHsgYm90dG9tOiBubiwgaXRlbUhlaWdodDogZmUsIGl0ZW1zOiBlbiwgaXRlbVdpZHRoOiBIZSwgb2Zmc2V0Qm90dG9tOiBybywgb2Zmc2V0VG9wOiBvbiwgdG9wOiBvbiB9O1xuICAgICAgICAgIH1cbiAgICAgICAgKVxuICAgICAgKSxcbiAgICAgIEJcbiAgICApLCBGKFxuICAgICAgeChcbiAgICAgICAgbnQsXG4gICAgICAgIFAoKHYpID0+IHYgIT09IG51bGwpLFxuICAgICAgICBFKCh2KSA9PiB2Lmxlbmd0aClcbiAgICAgICksXG4gICAgICBkXG4gICAgKSwgRihcbiAgICAgIHgoXG4gICAgICAgIHJ0KE8sIEwsIEIsIGspLFxuICAgICAgICBQKChbdiwgTiwgeyBpdGVtczogUSB9XSkgPT4gUS5sZW5ndGggPiAwICYmIE4uaGVpZ2h0ICE9PSAwICYmIHYuaGVpZ2h0ICE9PSAwKSxcbiAgICAgICAgRSgoW3YsIE4sIHsgaXRlbXM6IFEgfSwgaXRdKSA9PiB7XG4gICAgICAgICAgY29uc3QgeyBib3R0b206IHR0LCB0b3A6IEJ0IH0gPSBSbih2LCBpdCwgTiwgUSk7XG4gICAgICAgICAgcmV0dXJuIFtCdCwgdHRdO1xuICAgICAgICB9KSxcbiAgICAgICAgWShzZSlcbiAgICAgICksXG4gICAgICBlXG4gICAgKTtcbiAgICBjb25zdCB4dCA9IHkoITEpO1xuICAgIEYoXG4gICAgICB4KFxuICAgICAgICB1LFxuICAgICAgICBHKHh0KSxcbiAgICAgICAgRSgoW3YsIE5dKSA9PiBOIHx8IHYgIT09IDApXG4gICAgICApLFxuICAgICAgeHRcbiAgICApO1xuICAgIGNvbnN0IFh0ID0gcHQoXG4gICAgICB4KFxuICAgICAgICBydChCLCBkKSxcbiAgICAgICAgUCgoW3sgaXRlbXM6IHYgfV0pID0+IHYubGVuZ3RoID4gMCksXG4gICAgICAgIEcoeHQpLFxuICAgICAgICBQKChbW3YsIE5dLCBRXSkgPT4ge1xuICAgICAgICAgIGNvbnN0IHR0ID0gdi5pdGVtc1t2Lml0ZW1zLmxlbmd0aCAtIDFdLmluZGV4ID09PSBOIC0gMTtcbiAgICAgICAgICByZXR1cm4gKFEgfHwgdi5ib3R0b20gPiAwICYmIHYuaXRlbUhlaWdodCA+IDAgJiYgdi5vZmZzZXRCb3R0b20gPT09IDAgJiYgdi5pdGVtcy5sZW5ndGggPT09IE4pICYmIHR0O1xuICAgICAgICB9KSxcbiAgICAgICAgRSgoW1ssIHZdXSkgPT4gdiAtIDEpLFxuICAgICAgICBZKClcbiAgICAgIClcbiAgICApLCBNdCA9IHB0KFxuICAgICAgeChcbiAgICAgICAgQShCKSxcbiAgICAgICAgUCgoeyBpdGVtczogdiB9KSA9PiB2Lmxlbmd0aCA+IDAgJiYgdlswXS5pbmRleCA9PT0gMCksXG4gICAgICAgIHZ0KDApLFxuICAgICAgICBZKClcbiAgICAgIClcbiAgICApLCB5dCA9IHB0KFxuICAgICAgeChcbiAgICAgICAgQShCKSxcbiAgICAgICAgRyhkdCksXG4gICAgICAgIFAoKFt7IGl0ZW1zOiB2IH0sIE5dKSA9PiB2Lmxlbmd0aCA+IDAgJiYgIU4pLFxuICAgICAgICBFKChbeyBpdGVtczogdiB9XSkgPT4gKHtcbiAgICAgICAgICBlbmRJbmRleDogdlt2Lmxlbmd0aCAtIDFdLmluZGV4LFxuICAgICAgICAgIHN0YXJ0SW5kZXg6IHZbMF0uaW5kZXhcbiAgICAgICAgfSkpLFxuICAgICAgICBZKEFuKSxcbiAgICAgICAgTHQoMClcbiAgICAgIClcbiAgICApO1xuICAgIEYoeXQsIG0uc2Nyb2xsU2Vla1JhbmdlQ2hhbmdlZCksIEYoXG4gICAgICB4KFxuICAgICAgICBWLFxuICAgICAgICBHKE8sIEwsIGQsIGspLFxuICAgICAgICBFKChbdiwgTiwgUSwgaXQsIHR0XSkgPT4ge1xuICAgICAgICAgIGNvbnN0IEJ0ID0gTm4odiksIHsgYWxpZ246IEp0LCBiZWhhdmlvcjogTnQsIG9mZnNldDogZGUgfSA9IEJ0O1xuICAgICAgICAgIGxldCBPdCA9IEJ0LmluZGV4O1xuICAgICAgICAgIE90ID09PSBcIkxBU1RcIiAmJiAoT3QgPSBpdCAtIDEpLCBPdCA9IGVlKDAsIE90LCBGZShpdCAtIDEsIE90KSk7XG4gICAgICAgICAgbGV0IEZ0ID0gQWUoTiwgdHQsIFEsIE90KTtcbiAgICAgICAgICByZXR1cm4gSnQgPT09IFwiZW5kXCIgPyBGdCA9IHZuKEZ0IC0gTi5oZWlnaHQgKyBRLmhlaWdodCkgOiBKdCA9PT0gXCJjZW50ZXJcIiAmJiAoRnQgPSB2bihGdCAtIE4uaGVpZ2h0IC8gMiArIFEuaGVpZ2h0IC8gMikpLCBkZSAmJiAoRnQgKz0gZGUpLCB7IGJlaGF2aW9yOiBOdCwgdG9wOiBGdCB9O1xuICAgICAgICB9KVxuICAgICAgKSxcbiAgICAgIGNcbiAgICApO1xuICAgIGNvbnN0IGt0ID0gY3QoXG4gICAgICB4KFxuICAgICAgICBCLFxuICAgICAgICBFKCh2KSA9PiB2Lm9mZnNldEJvdHRvbSArIHYuYm90dG9tKVxuICAgICAgKSxcbiAgICAgIDBcbiAgICApO1xuICAgIHJldHVybiBGKFxuICAgICAgeChcbiAgICAgICAgYixcbiAgICAgICAgRSgodikgPT4gKHsgaGVpZ2h0OiB2LnZpc2libGVIZWlnaHQsIHdpZHRoOiB2LnZpc2libGVXaWR0aCB9KSlcbiAgICAgICksXG4gICAgICBPXG4gICAgKSwge1xuICAgICAgY3VzdG9tU2Nyb2xsUGFyZW50OiBDLFxuICAgICAgLy8gaW5wdXRcbiAgICAgIGRhdGE6IG50LFxuICAgICAgZGV2aWF0aW9uOiBKLFxuICAgICAgZm9vdGVySGVpZ2h0OiByLFxuICAgICAgZ2FwOiBrLFxuICAgICAgaGVhZGVySGVpZ2h0OiBzLFxuICAgICAgaW5jcmVhc2VWaWV3cG9ydEJ5OiB0LFxuICAgICAgaW5pdGlhbEl0ZW1Db3VudDogUixcbiAgICAgIGl0ZW1EaW1lbnNpb25zOiBMLFxuICAgICAgb3ZlcnNjYW46IG4sXG4gICAgICByZXN0b3JlU3RhdGVGcm9tOiBzdCxcbiAgICAgIHNjcm9sbEJ5OiBpLFxuICAgICAgc2Nyb2xsQ29udGFpbmVyU3RhdGU6IGwsXG4gICAgICBzY3JvbGxIZWlnaHQ6IEQsXG4gICAgICBzY3JvbGxUbzogYyxcbiAgICAgIHNjcm9sbFRvSW5kZXg6IFYsXG4gICAgICBzY3JvbGxUb3A6IHUsXG4gICAgICBzbW9vdGhTY3JvbGxUYXJnZXRSZWFjaGVkOiBmLFxuICAgICAgdG90YWxDb3VudDogZCxcbiAgICAgIHVzZVdpbmRvd1Njcm9sbDogZyxcbiAgICAgIHZpZXdwb3J0RGltZW5zaW9uczogTyxcbiAgICAgIHdpbmRvd1Njcm9sbENvbnRhaW5lclN0YXRlOiBhLFxuICAgICAgd2luZG93U2Nyb2xsVG86IFQsXG4gICAgICB3aW5kb3dWaWV3cG9ydFJlY3Q6IGIsXG4gICAgICAuLi5tLFxuICAgICAgLy8gb3V0cHV0XG4gICAgICBncmlkU3RhdGU6IEIsXG4gICAgICBob3Jpem9udGFsRGlyZWN0aW9uOiBBdCxcbiAgICAgIGluaXRpYWxUb3BNb3N0SXRlbUluZGV4OiBTdCxcbiAgICAgIHRvdGFsTGlzdEhlaWdodDoga3QsXG4gICAgICAuLi5wLFxuICAgICAgZW5kUmVhY2hlZDogWHQsXG4gICAgICBwcm9wc1JlYWR5OiBJLFxuICAgICAgcmFuZ2VDaGFuZ2VkOiB5dCxcbiAgICAgIHN0YXJ0UmVhY2hlZDogTXQsXG4gICAgICBzdGF0ZUNoYW5nZWQ6IHEsXG4gICAgICBzdGF0ZVJlc3RvcmVJblByb2dyZXNzOiBkdCxcbiAgICAgIC4uLmhcbiAgICB9O1xuICB9LFxuICBYKEtlLCBhdCwgYWUsIEtuLCBQdCwgamUsIFZ0KVxuKTtcbmZ1bmN0aW9uIG5vKHQsIGUsIG4pIHtcbiAgcmV0dXJuIGVlKDEsIENlKCh0ICsgbikgLyAoQ2UoZSkgKyBuKSkpO1xufVxuZnVuY3Rpb24gUm4odCwgZSwgbiwgbykge1xuICBjb25zdCB7IGhlaWdodDogciB9ID0gbjtcbiAgaWYgKHIgPT09IHZvaWQgMCB8fCBvLmxlbmd0aCA9PT0gMClcbiAgICByZXR1cm4geyBib3R0b206IDAsIHRvcDogMCB9O1xuICBjb25zdCBzID0gQWUodCwgZSwgbiwgb1swXS5pbmRleCk7XG4gIHJldHVybiB7IGJvdHRvbTogQWUodCwgZSwgbiwgb1tvLmxlbmd0aCAtIDFdLmluZGV4KSArIHIsIHRvcDogcyB9O1xufVxuZnVuY3Rpb24gQWUodCwgZSwgbiwgbykge1xuICBjb25zdCByID0gbm8odC53aWR0aCwgbi53aWR0aCwgZS5jb2x1bW4pLCBzID0gQ2UobyAvIHIpLCBpID0gcyAqIG4uaGVpZ2h0ICsgZWUoMCwgcyAtIDEpICogZS5yb3c7XG4gIHJldHVybiBpID4gMCA/IGkgKyBlLnJvdyA6IGk7XG59XG5jb25zdCBPciA9IC8qIEBfX1BVUkVfXyAqLyBVKCgpID0+IHtcbiAgY29uc3QgdCA9IHkoKFMpID0+IGBJdGVtICR7U31gKSwgZSA9IHkoe30pLCBuID0geShudWxsKSwgbyA9IHkoXCJ2aXJ0dW9zby1ncmlkLWl0ZW1cIiksIHIgPSB5KFwidmlydHVvc28tZ3JpZC1saXN0XCIpLCBzID0geShZZSksIGkgPSB5KFwiZGl2XCIpLCBsID0geShZdCksIGMgPSAoUywgcCA9IG51bGwpID0+IGN0KFxuICAgIHgoXG4gICAgICBlLFxuICAgICAgRSgobSkgPT4gbVtTXSksXG4gICAgICBZKClcbiAgICApLFxuICAgIHBcbiAgKSwgdSA9IHkoITEpLCBmID0geSghMSk7XG4gIHJldHVybiBGKEEoZiksIHUpLCB7XG4gICAgY29tcG9uZW50czogZSxcbiAgICBjb21wdXRlSXRlbUtleTogcyxcbiAgICBjb250ZXh0OiBuLFxuICAgIEZvb3RlckNvbXBvbmVudDogYyhcIkZvb3RlclwiKSxcbiAgICBIZWFkZXJDb21wb25lbnQ6IGMoXCJIZWFkZXJcIiksXG4gICAgaGVhZGVyRm9vdGVyVGFnOiBpLFxuICAgIGl0ZW1DbGFzc05hbWU6IG8sXG4gICAgSXRlbUNvbXBvbmVudDogYyhcIkl0ZW1cIiwgXCJkaXZcIiksXG4gICAgaXRlbUNvbnRlbnQ6IHQsXG4gICAgbGlzdENsYXNzTmFtZTogcixcbiAgICBMaXN0Q29tcG9uZW50OiBjKFwiTGlzdFwiLCBcImRpdlwiKSxcbiAgICByZWFkeVN0YXRlQ2hhbmdlZDogdSxcbiAgICByZXBvcnRSZWFkeVN0YXRlOiBmLFxuICAgIFNjcm9sbGVyQ29tcG9uZW50OiBjKFwiU2Nyb2xsZXJcIiwgXCJkaXZcIiksXG4gICAgc2Nyb2xsZXJSZWY6IGwsXG4gICAgU2Nyb2xsU2Vla1BsYWNlaG9sZGVyOiBjKFwiU2Nyb2xsU2Vla1BsYWNlaG9sZGVyXCIsIFwiZGl2XCIpXG4gIH07XG59KSwgRnIgPSAvKiBAX19QVVJFX18gKi8gVShcbiAgKFt0LCBlXSkgPT4gKHsgLi4udCwgLi4uZSB9KSxcbiAgWChCciwgT3IpXG4pLCBMciA9IC8qIEBfX1BVUkVfXyAqLyBILm1lbW8oZnVuY3Rpb24oKSB7XG4gIGNvbnN0IGUgPSBldChcImdyaWRTdGF0ZVwiKSwgbiA9IGV0KFwibGlzdENsYXNzTmFtZVwiKSwgbyA9IGV0KFwiaXRlbUNsYXNzTmFtZVwiKSwgciA9IGV0KFwiaXRlbUNvbnRlbnRcIiksIHMgPSBldChcImNvbXB1dGVJdGVtS2V5XCIpLCBpID0gZXQoXCJpc1NlZWtpbmdcIiksIGwgPSBJdChcInNjcm9sbEhlaWdodFwiKSwgYyA9IGV0KFwiSXRlbUNvbXBvbmVudFwiKSwgdSA9IGV0KFwiTGlzdENvbXBvbmVudFwiKSwgZiA9IGV0KFwiU2Nyb2xsU2Vla1BsYWNlaG9sZGVyXCIpLCBTID0gZXQoXCJjb250ZXh0XCIpLCBwID0gSXQoXCJpdGVtRGltZW5zaW9uc1wiKSwgbSA9IEl0KFwiZ2FwXCIpLCB3ID0gZXQoXCJsb2dcIiksIEkgPSBldChcInN0YXRlUmVzdG9yZUluUHJvZ3Jlc3NcIiksIEMgPSBJdChcInJlcG9ydFJlYWR5U3RhdGVcIiksIGcgPSBIdChcbiAgICBILnVzZU1lbW8oXG4gICAgICAoKSA9PiAoYSkgPT4ge1xuICAgICAgICBjb25zdCBUID0gYS5wYXJlbnRFbGVtZW50LnBhcmVudEVsZW1lbnQuc2Nyb2xsSGVpZ2h0O1xuICAgICAgICBsKFQpO1xuICAgICAgICBjb25zdCBiID0gYS5maXJzdENoaWxkO1xuICAgICAgICBpZiAoYikge1xuICAgICAgICAgIGNvbnN0IHsgaGVpZ2h0OiBoLCB3aWR0aDogZCB9ID0gYi5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgICBwKHsgaGVpZ2h0OiBoLCB3aWR0aDogZCB9KTtcbiAgICAgICAgfVxuICAgICAgICBtKHtcbiAgICAgICAgICBjb2x1bW46IEhuKFwiY29sdW1uLWdhcFwiLCBnZXRDb21wdXRlZFN0eWxlKGEpLmNvbHVtbkdhcCwgdyksXG4gICAgICAgICAgcm93OiBIbihcInJvdy1nYXBcIiwgZ2V0Q29tcHV0ZWRTdHlsZShhKS5yb3dHYXAsIHcpXG4gICAgICAgIH0pO1xuICAgICAgfSxcbiAgICAgIFtsLCBwLCBtLCB3XVxuICAgICksXG4gICAgITAsXG4gICAgITFcbiAgKTtcbiAgcmV0dXJuIFpuKCgpID0+IHtcbiAgICBlLml0ZW1IZWlnaHQgPiAwICYmIGUuaXRlbVdpZHRoID4gMCAmJiBDKCEwKTtcbiAgfSwgW2VdKSwgSSA/IG51bGwgOiAvKiBAX19QVVJFX18gKi8geihcbiAgICB1LFxuICAgIHtcbiAgICAgIGNsYXNzTmFtZTogbixcbiAgICAgIHJlZjogZyxcbiAgICAgIC4uLloodSwgUyksXG4gICAgICBcImRhdGEtdGVzdGlkXCI6IFwidmlydHVvc28taXRlbS1saXN0XCIsXG4gICAgICBzdHlsZTogeyBwYWRkaW5nQm90dG9tOiBlLm9mZnNldEJvdHRvbSwgcGFkZGluZ1RvcDogZS5vZmZzZXRUb3AgfSxcbiAgICAgIGNoaWxkcmVuOiBlLml0ZW1zLm1hcCgoYSkgPT4ge1xuICAgICAgICBjb25zdCBUID0gcyhhLmluZGV4LCBhLmRhdGEsIFMpO1xuICAgICAgICByZXR1cm4gaSA/IC8qIEBfX1BVUkVfXyAqLyB6KFxuICAgICAgICAgIGYsXG4gICAgICAgICAge1xuICAgICAgICAgICAgLi4uWihmLCBTKSxcbiAgICAgICAgICAgIGhlaWdodDogZS5pdGVtSGVpZ2h0LFxuICAgICAgICAgICAgaW5kZXg6IGEuaW5kZXgsXG4gICAgICAgICAgICB3aWR0aDogZS5pdGVtV2lkdGhcbiAgICAgICAgICB9LFxuICAgICAgICAgIFRcbiAgICAgICAgKSA6IC8qIEBfX1BVUkVfXyAqLyAkdChcbiAgICAgICAgICBjLFxuICAgICAgICAgIHtcbiAgICAgICAgICAgIC4uLlooYywgUyksXG4gICAgICAgICAgICBjbGFzc05hbWU6IG8sXG4gICAgICAgICAgICBcImRhdGEtaW5kZXhcIjogYS5pbmRleCxcbiAgICAgICAgICAgIGtleTogVFxuICAgICAgICAgIH0sXG4gICAgICAgICAgcihhLmluZGV4LCBhLmRhdGEsIFMpXG4gICAgICAgICk7XG4gICAgICB9KVxuICAgIH1cbiAgKTtcbn0pLCB6ciA9IEgubWVtbyhmdW5jdGlvbigpIHtcbiAgY29uc3QgZSA9IGV0KFwiSGVhZGVyQ29tcG9uZW50XCIpLCBuID0gSXQoXCJoZWFkZXJIZWlnaHRcIiksIG8gPSBldChcImhlYWRlckZvb3RlclRhZ1wiKSwgciA9IEh0KFxuICAgIEgudXNlTWVtbyhcbiAgICAgICgpID0+IChpKSA9PiB7XG4gICAgICAgIG4od3QoaSwgXCJoZWlnaHRcIikpO1xuICAgICAgfSxcbiAgICAgIFtuXVxuICAgICksXG4gICAgITAsXG4gICAgITFcbiAgKSwgcyA9IGV0KFwiY29udGV4dFwiKTtcbiAgcmV0dXJuIGUgPyAvKiBAX19QVVJFX18gKi8geihvLCB7IHJlZjogciwgY2hpbGRyZW46IC8qIEBfX1BVUkVfXyAqLyB6KGUsIHsgLi4uWihlLCBzKSB9KSB9KSA6IG51bGw7XG59KSwgVnIgPSBILm1lbW8oZnVuY3Rpb24oKSB7XG4gIGNvbnN0IGUgPSBldChcIkZvb3RlckNvbXBvbmVudFwiKSwgbiA9IEl0KFwiZm9vdGVySGVpZ2h0XCIpLCBvID0gZXQoXCJoZWFkZXJGb290ZXJUYWdcIiksIHIgPSBIdChcbiAgICBILnVzZU1lbW8oXG4gICAgICAoKSA9PiAoaSkgPT4ge1xuICAgICAgICBuKHd0KGksIFwiaGVpZ2h0XCIpKTtcbiAgICAgIH0sXG4gICAgICBbbl1cbiAgICApLFxuICAgICEwLFxuICAgICExXG4gICksIHMgPSBldChcImNvbnRleHRcIik7XG4gIHJldHVybiBlID8gLyogQF9fUFVSRV9fICovIHoobywgeyByZWY6IHIsIGNoaWxkcmVuOiAvKiBAX19QVVJFX18gKi8geihlLCB7IC4uLlooZSwgcykgfSkgfSkgOiBudWxsO1xufSksIFByID0gKHsgY2hpbGRyZW46IHQgfSkgPT4ge1xuICBjb25zdCBlID0gSC51c2VDb250ZXh0KFluKSwgbiA9IEl0KFwiaXRlbURpbWVuc2lvbnNcIiksIG8gPSBJdChcInZpZXdwb3J0RGltZW5zaW9uc1wiKSwgciA9IEh0KFxuICAgIEgudXNlTWVtbyhcbiAgICAgICgpID0+IChzKSA9PiB7XG4gICAgICAgIG8ocy5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSk7XG4gICAgICB9LFxuICAgICAgW29dXG4gICAgKSxcbiAgICAhMCxcbiAgICAhMVxuICApO1xuICByZXR1cm4gSC51c2VFZmZlY3QoKCkgPT4ge1xuICAgIGUgJiYgKG8oeyBoZWlnaHQ6IGUudmlld3BvcnRIZWlnaHQsIHdpZHRoOiBlLnZpZXdwb3J0V2lkdGggfSksIG4oeyBoZWlnaHQ6IGUuaXRlbUhlaWdodCwgd2lkdGg6IGUuaXRlbVdpZHRoIH0pKTtcbiAgfSwgW2UsIG8sIG5dKSwgLyogQF9fUFVSRV9fICovIHooXCJkaXZcIiwgeyByZWY6IHIsIHN0eWxlOiBadCghMSksIGNoaWxkcmVuOiB0IH0pO1xufSwgQXIgPSAoeyBjaGlsZHJlbjogdCB9KSA9PiB7XG4gIGNvbnN0IGUgPSBILnVzZUNvbnRleHQoWW4pLCBuID0gSXQoXCJ3aW5kb3dWaWV3cG9ydFJlY3RcIiksIG8gPSBJdChcIml0ZW1EaW1lbnNpb25zXCIpLCByID0gZXQoXCJjdXN0b21TY3JvbGxQYXJlbnRcIiksIHMgPSBHZShuLCByLCAhMSk7XG4gIHJldHVybiBILnVzZUVmZmVjdCgoKSA9PiB7XG4gICAgZSAmJiAobyh7IGhlaWdodDogZS5pdGVtSGVpZ2h0LCB3aWR0aDogZS5pdGVtV2lkdGggfSksIG4oeyBvZmZzZXRUb3A6IDAsIHZpc2libGVIZWlnaHQ6IGUudmlld3BvcnRIZWlnaHQsIHZpc2libGVXaWR0aDogZS52aWV3cG9ydFdpZHRoIH0pKTtcbiAgfSwgW2UsIG4sIG9dKSwgLyogQF9fUFVSRV9fICovIHooXCJkaXZcIiwgeyByZWY6IHMsIHN0eWxlOiBadCghMSksIGNoaWxkcmVuOiB0IH0pO1xufSwgTXIgPSAvKiBAX19QVVJFX18gKi8gSC5tZW1vKGZ1bmN0aW9uKHsgLi4uZSB9KSB7XG4gIGNvbnN0IG4gPSBldChcInVzZVdpbmRvd1Njcm9sbFwiKSwgbyA9IGV0KFwiY3VzdG9tU2Nyb2xsUGFyZW50XCIpLCByID0gbyB8fCBuID8gR3IgOiBfciwgcyA9IG8gfHwgbiA/IEFyIDogUHIsIGkgPSBldChcImNvbnRleHRcIik7XG4gIHJldHVybiAvKiBAX19QVVJFX18gKi8geihyLCB7IC4uLmUsIC4uLloociwgaSksIGNoaWxkcmVuOiAvKiBAX19QVVJFX18gKi8gS3QocywgeyBjaGlsZHJlbjogW1xuICAgIC8qIEBfX1BVUkVfXyAqLyB6KHpyLCB7fSksXG4gICAgLyogQF9fUFVSRV9fICovIHooTHIsIHt9KSxcbiAgICAvKiBAX19QVVJFX18gKi8geihWciwge30pXG4gIF0gfSkgfSk7XG59KSwge1xuICBDb21wb25lbnQ6IFdyLFxuICB1c2VFbWl0dGVyOiBvbyxcbiAgdXNlRW1pdHRlclZhbHVlOiBldCxcbiAgdXNlUHVibGlzaGVyOiBJdFxufSA9IC8qIEBfX1BVUkVfXyAqLyBxZShcbiAgRnIsXG4gIHtcbiAgICBldmVudHM6IHtcbiAgICAgIGF0Qm90dG9tU3RhdGVDaGFuZ2U6IFwiYXRCb3R0b21TdGF0ZUNoYW5nZVwiLFxuICAgICAgYXRUb3BTdGF0ZUNoYW5nZTogXCJhdFRvcFN0YXRlQ2hhbmdlXCIsXG4gICAgICBlbmRSZWFjaGVkOiBcImVuZFJlYWNoZWRcIixcbiAgICAgIGlzU2Nyb2xsaW5nOiBcImlzU2Nyb2xsaW5nXCIsXG4gICAgICByYW5nZUNoYW5nZWQ6IFwicmFuZ2VDaGFuZ2VkXCIsXG4gICAgICByZWFkeVN0YXRlQ2hhbmdlZDogXCJyZWFkeVN0YXRlQ2hhbmdlZFwiLFxuICAgICAgc3RhcnRSZWFjaGVkOiBcInN0YXJ0UmVhY2hlZFwiLFxuICAgICAgc3RhdGVDaGFuZ2VkOiBcInN0YXRlQ2hhbmdlZFwiXG4gICAgfSxcbiAgICBtZXRob2RzOiB7XG4gICAgICBzY3JvbGxCeTogXCJzY3JvbGxCeVwiLFxuICAgICAgc2Nyb2xsVG86IFwic2Nyb2xsVG9cIixcbiAgICAgIHNjcm9sbFRvSW5kZXg6IFwic2Nyb2xsVG9JbmRleFwiXG4gICAgfSxcbiAgICBvcHRpb25hbDoge1xuICAgICAgY29tcG9uZW50czogXCJjb21wb25lbnRzXCIsXG4gICAgICBjb21wdXRlSXRlbUtleTogXCJjb21wdXRlSXRlbUtleVwiLFxuICAgICAgY29udGV4dDogXCJjb250ZXh0XCIsXG4gICAgICBjdXN0b21TY3JvbGxQYXJlbnQ6IFwiY3VzdG9tU2Nyb2xsUGFyZW50XCIsXG4gICAgICBkYXRhOiBcImRhdGFcIixcbiAgICAgIGhlYWRlckZvb3RlclRhZzogXCJoZWFkZXJGb290ZXJUYWdcIixcbiAgICAgIGluY3JlYXNlVmlld3BvcnRCeTogXCJpbmNyZWFzZVZpZXdwb3J0QnlcIixcbiAgICAgIGluaXRpYWxJdGVtQ291bnQ6IFwiaW5pdGlhbEl0ZW1Db3VudFwiLFxuICAgICAgaW5pdGlhbFRvcE1vc3RJdGVtSW5kZXg6IFwiaW5pdGlhbFRvcE1vc3RJdGVtSW5kZXhcIixcbiAgICAgIGl0ZW1DbGFzc05hbWU6IFwiaXRlbUNsYXNzTmFtZVwiLFxuICAgICAgaXRlbUNvbnRlbnQ6IFwiaXRlbUNvbnRlbnRcIixcbiAgICAgIGxpc3RDbGFzc05hbWU6IFwibGlzdENsYXNzTmFtZVwiLFxuICAgICAgbG9nTGV2ZWw6IFwibG9nTGV2ZWxcIixcbiAgICAgIG92ZXJzY2FuOiBcIm92ZXJzY2FuXCIsXG4gICAgICByZXN0b3JlU3RhdGVGcm9tOiBcInJlc3RvcmVTdGF0ZUZyb21cIixcbiAgICAgIHNjcm9sbGVyUmVmOiBcInNjcm9sbGVyUmVmXCIsXG4gICAgICBzY3JvbGxTZWVrQ29uZmlndXJhdGlvbjogXCJzY3JvbGxTZWVrQ29uZmlndXJhdGlvblwiLFxuICAgICAgdG90YWxDb3VudDogXCJ0b3RhbENvdW50XCIsXG4gICAgICB1c2VXaW5kb3dTY3JvbGw6IFwidXNlV2luZG93U2Nyb2xsXCJcbiAgICB9XG4gIH0sXG4gIE1yXG4pLCBfciA9IC8qIEBfX1BVUkVfXyAqLyBaZSh7IHVzZUVtaXR0ZXI6IG9vLCB1c2VFbWl0dGVyVmFsdWU6IGV0LCB1c2VQdWJsaXNoZXI6IEl0IH0pLCBHciA9IC8qIEBfX1BVUkVfXyAqLyBYZSh7IHVzZUVtaXR0ZXI6IG9vLCB1c2VFbWl0dGVyVmFsdWU6IGV0LCB1c2VQdWJsaXNoZXI6IEl0IH0pO1xuZnVuY3Rpb24gSG4odCwgZSwgbikge1xuICByZXR1cm4gZSAhPT0gXCJub3JtYWxcIiAmJiAhKGUgIT0gbnVsbCAmJiBlLmVuZHNXaXRoKFwicHhcIikpICYmIG4oYCR7dH0gd2FzIG5vdCByZXNvbHZlZCB0byBwaXhlbCB2YWx1ZSBjb3JyZWN0bHlgLCBlLCBodC5XQVJOKSwgZSA9PT0gXCJub3JtYWxcIiA/IDAgOiBwYXJzZUludChlICE9IG51bGwgPyBlIDogXCIwXCIsIDEwKTtcbn1cbmNvbnN0IFlyID0gV3I7XG5leHBvcnQge1xuICBqciBhcyBHcm91cGVkVmlydHVvc28sXG4gIGh0IGFzIExvZ0xldmVsLFxuICBxciBhcyBUYWJsZVZpcnR1b3NvLFxuICBLciBhcyBWaXJ0dW9zbyxcbiAgWXIgYXMgVmlydHVvc29HcmlkLFxuICBZbiBhcyBWaXJ0dW9zb0dyaWRNb2NrQ29udGV4dCxcbiAgUmUgYXMgVmlydHVvc29Nb2NrQ29udGV4dFxufTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/react-virtuoso/dist/index.mjs\n"));

/***/ })

}]);